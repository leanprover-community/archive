[
    {
        "content": "<p>Will Lean ever have support for them, e.g. linear types, affine types, quantified types, etc.?</p>",
        "id": 516107961,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1746421300
    },
    {
        "content": "<p>Not an answer, but I've seen them mentioned here: <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/Semantics.20of.20IO.20don.27t.20match.20provable.20properties.3F/with/485680245\">#lean4 &gt; Semantics of IO don't match provable properties?</a> and <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/FFI.2C.20Rust.20and.20mutability/with/500760690\">#lean4 &gt; FFI, Rust and mutability</a></p>",
        "id": 516112958,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746424505
    },
    {
        "content": "<p>To me at least, it seems fairly unlikely that Lean's core type theory will expand to include linear and affine types, because that would require a deep change to the kernel and it probably wouldn't make sense from a cost/benefit perspective. But, it might be possible to implement linear and affine types from within Lean via clever use of <code>opaque</code>, Monads, and possibly additional type checkers.</p>",
        "id": 516113857,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746424918
    },
    {
        "content": "<p>I guess the question is, what is it that you want to do with substructural types? To me at least, linear types don't feel useful when working with pure Lean structures, since everything is functional and there's no need to restrict the amount of times something is referenced. The scenarios in which I could imagine Linear Types being useful seem to mostly involve interacting with something with behavior defined by external code, like:</p>\n<ul>\n<li>Making sure that a single <code>Array</code> stays at reference count at most 1 so that it doesn't get accidentally copied and cause performance issues</li>\n<li>Having a version of <code>IO</code> with properties you can prove about it (so that there are no \"time traveling tokens\" as seen in the thread above)</li>\n<li>Implementing RAII for things like file handles</li>\n<li>FFI with languages using linear types, like Rust</li>\n</ul>\n<p>It's not clear that the same solution would be best for all of these (like maybe a monad would be best for semantically valid <code>IO</code> but not for interfacing with Rust?)</p>",
        "id": 516114648,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746425309
    },
    {
        "content": "<p>This topic has been explored to some degree in: <a href=\"https://pp.ipd.kit.edu/uploads/publikationen/huisinga23masterarbeit.pdf\">https://pp.ipd.kit.edu/uploads/publikationen/huisinga23masterarbeit.pdf</a></p>",
        "id": 516115165,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1746425592
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/Substructural.20types/near/516114648\">said</a>:</p>\n<blockquote>\n<p>I guess the question is, what is it that you want to do with substructural types? To me at least, linear types don't feel useful when working with pure Lean structures, since everything is functional and there's no need to restrict the amount of times something is referenced. The scenarios in which I could imagine Linear Types being useful seem to mostly involve interacting with something with behavior defined by external code, like:</p>\n<ul>\n<li>Making sure that a single <code>Array</code> stays at reference count at most 1 so that it doesn't get accidentally copied and cause performance issues</li>\n<li>Having a version of <code>IO</code> with properties you can prove about it (so that there are no \"time traveling tokens\" as seen in the thread above)</li>\n<li>Implementing RAII for things like file handles</li>\n<li>FFI with languages using linear types, like Rust</li>\n</ul>\n<p>It's not clear that the same solution would be best for all of these (like maybe a monad would be best for semantically valid <code>IO</code> but not for interfacing with Rust?)</p>\n</blockquote>\n<p>Having linear types would make it easier to reason on programs. e.g. qubits cannot be shared.</p>",
        "id": 516182501,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1746448064
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/270676-lean4/topic/Substructural.20types/near/516114648\">said</a>:</p>\n<blockquote>\n<p>I guess the question is, what is it that you want to do with substructural types? To me at least, linear types don't feel useful when working with pure Lean structures, since everything is functional and there's no need to restrict the amount of times something is referenced. The scenarios in which I could imagine Linear Types being useful seem to mostly involve interacting with something with behavior defined by external code, like:</p>\n<ul>\n<li>Making sure that a single <code>Array</code> stays at reference count at most 1 so that it doesn't get accidentally copied and cause performance issues</li>\n<li>Having a version of <code>IO</code> with properties you can prove about it (so that there are no \"time traveling tokens\" as seen in the thread above)</li>\n<li>Implementing RAII for things like file handles</li>\n<li>FFI with languages using linear types, like Rust</li>\n</ul>\n<p>It's not clear that the same solution would be best for all of these (like maybe a monad would be best for semantically valid <code>IO</code> but not for interfacing with Rust?)</p>\n</blockquote>\n<p>just the first use case for ref counts is worth it to me</p>",
        "id": 516292966,
        "sender_full_name": "Alok Singh",
        "timestamp": 1746477903
    }
]