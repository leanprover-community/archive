[
    {
        "content": "<p>Hi. I am trying to work around a <a href=\"https://github.com/ufmg-smite/lean-smt/issues/100\">bug in <code>lean-smt</code></a> that means duplicate binder names don't get translated correctly.</p>\n<p>The solution I'm attempting to implement is to traverse the <code>Expr</code> and give a fresh name to every binder.  That seems to work. But I can't actually replace my goal with the <code>defEq</code> goal with different binder names. I'm not sure what's going on – although I suspect it's something trivial.</p>\n<p>Any help, please? Here's a MWE with what I've tried:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> I am trying to workaround https://github.com/ufmg-smite/lean-smt/issues/100-/</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">uniqueBinder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">forallE</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">bt</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bn'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">  </span><span class=\"n\">Name</span><span class=\"bp\">.</span><span class=\"n\">mkSimple</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{bn}_{id}\"</span>\n<span class=\"w\">    </span><span class=\"n\">dbg_trace</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"renaming {bn} in {←ppExpr e} to {bn'}\"</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">forallE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bn'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">bt</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"n\">bi</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">e</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">renameBinders</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> If I use `Meta.transform`, only the first ∀ is visited -/</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e'</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Core</span><span class=\"bp\">.</span><span class=\"n\">transform</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">TransformStep</span><span class=\"bp\">.</span><span class=\"n\">continue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">uniqueBinder</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">hash</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">e'</span>\n\n<span class=\"c1\">-- Trying to implement what's suggested here:</span>\n<span class=\"c1\">-- https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Why.20does.20the.20fvar.20delab.20pretty-print.20bvars.3F/near/425221088</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"rename_binders\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getMainGoal</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">goalType</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getMainTarget</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">goalType'</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">renameBinders</span><span class=\"w\"> </span><span class=\"n\">goalType</span>\n<span class=\"w\">  </span><span class=\"n\">dbg_trace</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"goalType' := {← ppExpr goalType'}\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">goal'</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"bp\">.</span><span class=\"n\">replaceTargetDefEq</span><span class=\"w\"> </span><span class=\"n\">goalType'</span>\n<span class=\"w\">  </span><span class=\"n\">setGoals</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">goal'</span><span class=\"o\">]</span>\n\n<span class=\"n\">simproc</span><span class=\"w\"> </span><span class=\"n\">renameBindersP</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">forallE</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">bi</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bn'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LocalContext</span><span class=\"bp\">.</span><span class=\"n\">getUnusedName</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getLCtx</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">bn</span>\n<span class=\"w\">    </span><span class=\"n\">dbg_trace</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"renaming {bn} in {←ppExpr e} to {bn'}\"</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">forallE</span><span class=\"w\"> </span><span class=\"n\">bn'</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">bi</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">visit</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e'</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">exists_elim</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">¬∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">not_forall_not</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">st</span><span class=\"w\"> </span><span class=\"n\">st'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">st</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">st'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">exists_elim</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">not_not</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- FIXME: why aren't the binders renamed in the goal?</span>\n<span class=\"w\">    </span><span class=\"n\">rename_binders</span>\n<span class=\"w\">    </span><span class=\"c1\">-- this also doesn't work:</span>\n<span class=\"w\">    </span><span class=\"c1\">-- simp only [renameBindersP]</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 453887562,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1721896807
    },
    {
        "content": "<p>There's a gotcha in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.replaceTargetDefEq#doc\">docs#Lean.MVarId.replaceTargetDefEq</a> where it uses <code>==</code> to check whether the new type is the same as the old one. This equality is up to alpha renaming unfortunately for your application!</p>\n<p>It's probably easiest to copy the <code>else</code> clause of that function into <code>rename_binders</code></p>",
        "id": 453904493,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721901502
    },
    {
        "content": "<p>I believe simp also uses <code>==</code> when determining if a step made any progress, hence why the simproc doesn't do anything.</p>",
        "id": 453905035,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721901590
    },
    {
        "content": "<p>That works. Thank you very much, <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>!</p>",
        "id": 453930325,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1721909582
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542918\">George Pîrlea</span> has marked this topic as resolved.</p>",
        "id": 453930336,
        "sender_full_name": "Notification Bot",
        "timestamp": 1721909586
    }
]