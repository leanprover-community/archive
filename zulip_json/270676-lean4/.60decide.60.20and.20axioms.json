[
    {
        "content": "<p>This doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Bool</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">Bool</span> <span class=\"n\">where</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">add</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">true_add</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">+</span> <span class=\"n\">false</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span> <span class=\"c1\">-- fails, of course</span>\n</code></pre></div>\n<p>Can I tell <code>decide</code> to use <code>true_add</code> somehow?</p>\n<p>To un-#xy : In NNG I am clamping down on people who abuse defeq <code>x + 0 = x</code>. We have made <code>rfl</code> worse to stop this being rfl, but people can abuse this in <code>apply</code> and I can't just be asking Jon and Alex to make all tactics worse. Patrick has always been a proponent of defining <code>+</code> on <code>MyNat</code> via axioms, and I just tried this refactor and the entire game still compiles apart from the two <code>decide</code> levels in Algorithm world, a world whose future existence is not guaranteed if I can't get this working. Algorithm world in its current format puts a <code>DecidableEq</code> instance on MyNat and then proves 2+2=4 and 2+2!=5 by <code>decide</code>; these have previously been proved manually by the user so the selling point is that algorithms can do stuff which is boring for humans (<code>decide</code> can prove 20+20=40, for example).</p>\n<p>One idea: can one make make <code>add'</code> defined recursively, and tell <code>decide</code> somehow that <code>add'=add</code>?</p>",
        "id": 399517630,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698757662
    },
    {
        "content": "<p>Does <code>csimp</code> do this?</p>",
        "id": 399534483,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698762943
    },
    {
        "content": "<p>Hmm... this doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Bool</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">add_eq_or</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">||</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">Bool</span> <span class=\"n\">where</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">add</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">csimp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">add</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">or</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">funext</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_eq_or</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">+</span> <span class=\"n\">false</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">decide</span>\n</code></pre></div>\n<p>But I don't actually know much about <code>csimp</code>, so maybe I'm just doing it wrong.</p>",
        "id": 399536278,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698763444
    },
    {
        "content": "<p>csimp would have an effect on native_decide since it is only used in code gen (AFAIK)</p>",
        "id": 399537177,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1698763714
    },
    {
        "content": "<p>Making <code>apply</code> weaker wouldn't be a big deal though...</p>",
        "id": 399540703,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1698764686
    },
    {
        "content": "<p>What if you defined <code>MyNatExpr</code> as an inductive type with constructors for all of the syntactically different ways you can produce a natural number in the game and then defined <code>MyNat</code> as the quotient of <code>MyNatExpr</code> by equality of the denoted natural number? (Example constructors for <code>MyNatExpr</code>: <code>zero</code>, <code>succ</code>, <code>numeral</code>, <code>add</code>, <code>mul</code>, <code>pow</code>, etc.)</p>\n<p>Definitional equality would then be syntactic equality, just like you want, and you could still implement a <code>DecidableEq MyNat</code> instance</p>",
        "id": 399558436,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1698769250
    },
    {
        "content": "<p>To answer the original question, to help <code>decide</code> you add <code>Decidable</code> instances:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Bool</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">Bool</span> <span class=\"n\">where</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">add</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">true_add</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">true</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"n\">true_add</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">+</span> <span class=\"n\">false</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 399562781,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698770819
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">true</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">r</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"n\">true_add</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">true_add</span><span class=\"o\">])</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">+</span> <span class=\"n\">false</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">+</span> <span class=\"n\">false</span> <span class=\"bp\">≠</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 399563351,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698771040
    },
    {
        "content": "<p>Can you get something like this to work for the opaque version of Nat though? It looks like this would effectively just turn TC into a decisision procedure for sums of Bools, which is fine for this example but I don't see how to extend it</p>",
        "id": 399567245,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1698772304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/.60decide.60.20and.20axioms/near/399517630\">said</a>:</p>\n<blockquote>\n<p>(<code>decide</code> can prove 20+20=40, for example)</p>\n</blockquote>\n<p>As far as I'm understanding it, the proof <code>decide</code> comes up with is <code>rfl</code> with an extra step. (Rather than applying <code>rfl</code> directly, it checks that <code>20 + 20 == 40</code> is <code>true</code> then uses a theorem that <code>(a + b == c) = true</code> implies <code>a + b = c</code> for natural numbers.)</p>",
        "id": 399568890,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698772894
    },
    {
        "content": "<p>I just checked, even with a custom MyNat the <code>by decide</code> tactic is just doing a defeq check and getting <code>+</code> to reduce. (I was looking at the term that <code>by decide</code> produces -- it's asking that <code>20 + 20</code> and <code>40</code> are equal according to some algorithm, but that involves reducing things -- take a look at <code>set_option trace.Meta.isDefEq true</code> to see the 20-ish steps)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MyNat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyNat.add</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">x.add</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyNat.ofNat</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">zero</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">MyNat</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">MyNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">MyNat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">MyNat.add</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">20</span> <span class=\"bp\">+</span> <span class=\"mi\">20</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">40</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">20</span> <span class=\"bp\">+</span> <span class=\"mi\">20</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">40</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 399571564,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698773863
    },
    {
        "content": "<p>Here's one way to solve the original problem.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MyNat</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MyNat</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">ofNat</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">zero</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">succ</span> <span class=\"bp\">$</span> <span class=\"n\">MyNat.ofNat</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">MyNat</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">ofNat</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">toNat</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n.toNat</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_eq_zero</span> <span class=\"o\">:</span> <span class=\"n\">zero</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">MyNat</span> <span class=\"n\">where</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">add</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">add_zero</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">add_succ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eq_toNat_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">),</span> <span class=\"n\">m.toNat</span> <span class=\"bp\">=</span> <span class=\"n\">n.toNat</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congrArg</span> <span class=\"n\">succ</span> <span class=\"bp\">$</span> <span class=\"n\">eq_toNat_eq</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ.inj</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- We reduce equality of `MyNat` to equality of `Nat`.</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">eq_iff_eq_toNat</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">m.toNat</span> <span class=\"bp\">=</span> <span class=\"n\">n.toNat</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">],</span> <span class=\"n\">eq_toNat_eq</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- We let `simp` push `toNat` through all relevant operations, to the leaves.</span>\n<span class=\"c1\">-- Here, the only relevant operation is addition.</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">toNat_add</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span> <span class=\"bp\">=</span> <span class=\"n\">m.toNat</span> <span class=\"bp\">+</span> <span class=\"n\">n.toNat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_add</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- At the leaves, we get regular natural numbers, so our entire goal is now</span>\n<span class=\"c1\">-- about `Nat`.</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">toNat_ofNat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">MyNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congrArg</span> <span class=\"n\">Nat.succ</span> <span class=\"o\">(</span><span class=\"n\">toNat_ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- As a result, `simp` can now solve goals about `MyNat` addition.</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">20</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">20</span> <span class=\"bp\">=</span> <span class=\"mi\">40</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>\n<p>I think ideally one would package the <code>simp</code> lemmas relating <code>MyNat</code> equality and <code>Nat</code> equality as a <code>MyNatEq</code> <code>simp</code> rule set, then use that as a preprocessor for <code>decide</code>.</p>",
        "id": 399576885,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1698775849
    },
    {
        "content": "<p>I am terrified to try this approach though, because we're using <code>simp</code> to do other things, and MyNats changing randomly to Nats is a recipe for disaster.</p>",
        "id": 399591235,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698781467
    },
    {
        "content": "<p>You should be able to put all the <code>MyNat</code>-to-<code>Nat</code> <code>simp</code> lemmas in a separate <code>simp</code> set and then define a macro <code>my_decide := simp_MyNat; decide</code>. I was just too lazy to figure out the syntax for this.</p>",
        "id": 399594862,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1698783088
    },
    {
        "content": "<p>Oh!!</p>",
        "id": 399612178,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698790034
    },
    {
        "content": "<p>I asked Morph to prove this theorem. After a few trials, it suggested using the tactic <code>rw [true_add]</code> and it works!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Bool</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">Bool</span> <span class=\"n\">where</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">add</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">true_add</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">+</span> <span class=\"n\">false</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">true_add</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 399612227,
        "sender_full_name": "Min-Hsien Weng",
        "timestamp": 1698790070
    },
    {
        "content": "<p>I love this place</p>",
        "id": 399612296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698790095
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"500038\">Timo Carlin-Burns</span> <a href=\"#narrow/stream/270676-lean4/topic/.60decide.60.20and.20axioms/near/399558436\">said</a>:</p>\n<blockquote>\n<p>What if you defined <code>MyNatExpr</code> as an inductive type with constructors for all of the syntactically different ways you can produce a natural number in the game and then defined <code>MyNat</code> as the quotient of <code>MyNatExpr</code> by equality of the denoted natural number? (Example constructors for <code>MyNatExpr</code>: <code>zero</code>, <code>succ</code>, <code>numeral</code>, <code>add</code>, <code>mul</code>, <code>pow</code>, etc.)</p>\n<p>Definitional equality would then be syntactic equality, just like you want, and you could still implement a <code>DecidableEq MyNat</code> instance</p>\n</blockquote>\n<p>This would be a major refactor, involving a rewrite of the <code>induction</code> tactic, and it looks like fortunately there are easier options :-)</p>",
        "id": 399612722,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698790367
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/270676-lean4/topic/.60decide.60.20and.20axioms/near/399594862\">said</a>:</p>\n<blockquote>\n<p>You should be able to put all the <code>MyNat</code>-to-<code>Nat</code> <code>simp</code> lemmas in a separate <code>simp</code> set and then define a macro <code>my_decide := simp_MyNat; decide</code>. I was just too lazy to figure out the syntax for this.</p>\n</blockquote>\n<p>One drawback with this approach is that we would then kind of be lying to the players, because the idea would be \"first we implement this algorithm which decides x&lt;=y, and then we prove it's correct, and now boom we can solve 2&lt;=3 with <code>decide</code>, except that actually we just convert it back to proper naturals and do it there and screw your instance :P</p>",
        "id": 399614190,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698791199
    },
    {
        "content": "<p>I can just add a warning in the decide docs that the entire thing is an illusion.</p>",
        "id": 399614496,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698791391
    },
    {
        "content": "<p>(deleted, I messed up my examples and mislead myself)</p>",
        "id": 399618409,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698793826
    },
    {
        "content": "<p>I have Jannis' hack(?) up and running in a branch on NNG4, although I have my misgivings about cheating by reducing to nat. Is there a way of using a custom simp set to get this + decide running without having to pass to nat?</p>",
        "id": 399620577,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698795388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/.60decide.60.20and.20axioms/near/399612722\">said</a>:</p>\n<blockquote>\n<p>This would be a major refactor, involving a rewrite of the <code>induction</code> tactic, and it looks like fortunately there are easier options :-)</p>\n</blockquote>\n<p>I agree it would be a big refactor. I don't know if it would be a difficult one though. For example I think the necessary change to the <code>rfl</code> tactic would be deleting the custom one for NNG and just using the default one instead. I don't know how the NNG induction tactic works, but if it's capable of using custom induction principles it wouldn't require changing code. With the <code>MyNatExpr</code> approach, you can prove the standard induction principle for <code>MyNat</code> and mark it with <code>@[eliminator]</code>.</p>\n<p>This seems like a really clean solution to me because it expresses directly in lean the defeq behavior you want and means that you no longer have to fight against all of the default tactics which use defeq. Is the only critique that it seems like a lot of work? Would a PR be welcome then?</p>",
        "id": 399622290,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1698796675
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Here's a version using <code>irreducible_def</code> and then making a version of <code>decide</code> that re-enables reduction for <code>+</code> by swapping it for its definition.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.IrreducibleDef</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">MyNat</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MyNat</span>\n\n<span class=\"c1\">-- Nat notation</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span> <span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">ofNat</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">zero</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">MyNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">MyNat</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">ofNat</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- Addition</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">addImpl</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span>\n  <span class=\"bp\">|</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">addImpl</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"n\">irreducible_def</span> <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">addImpl</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">MyNat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">add</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">add_def'</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">addImpl</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">add_def</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">add_zero</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_def'</span><span class=\"o\">,</span> <span class=\"n\">addImpl</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">add_succ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_def'</span><span class=\"o\">,</span> <span class=\"n\">addImpl</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">10</span> <span class=\"bp\">=</span> <span class=\"mi\">20</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"my_decide\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"o\">(</span>\n  <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.Meta.Simp.neutralConfig</span><span class=\"o\">)</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_def'</span><span class=\"o\">]</span>\n  <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">decide</span> <span class=\"c1\">-- using `&lt;;&gt;` in case `simp` closes it by rfl</span>\n  <span class=\"o\">))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">10</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">my_decide</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">10</span> <span class=\"bp\">=</span> <span class=\"mi\">20</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">my_decide</span> <span class=\"c1\">-- succeeds</span>\n</code></pre></div>",
        "id": 399622389,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698796742
    },
    {
        "content": "<p>It's not perfect because it only affects <code>+</code>'s you can see from the beginning (i.e., definitions that themselves have <code>+</code> will  not be able to reduce), and you'll get some incomprehensible errors when it fails</p>",
        "id": 399622516,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698796810
    },
    {
        "content": "<p>The <code>Lean.Meta.Simp.neutralConfig</code> configuration turns off <code>simp</code>'s own <code>decide</code>, among other things.</p>",
        "id": 399622580,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698796846
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"500038\">@Timo Carlin-Burns</span> Note that <code>@[eliminator]</code> is currently buggy since it tries to use the same eliminator for both <code>induction</code> and <code>cases</code>)</p>",
        "id": 399622804,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698796935
    },
    {
        "content": "<p>Oh I can get it working without the hack of moving to Nat. I use a custom simp set to rewrite add_zero and add_succ, and  I use this for numerals other than zero:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">MyNat_decide</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ofNat_succ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">MyNat.succ</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">_root_.rfl</span>\n</code></pre></div>\n<p><code>MyNat_decide</code> is my custom simp set.</p>",
        "id": 399624481,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698797912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"500038\">@Timo Carlin-Burns</span> I cannot see the point of obfuscating what is going on even further. Every deviation from Lean/mathlib is a possible point of confusion for future Lean users. I think I'll stick with the usual inductive definition. You're right about the induction tactic. But I think I've got <code>decide</code> working the way I want it now.</p>",
        "id": 399624697,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698798061
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/NNG4/pull/41\">https://github.com/leanprover-community/NNG4/pull/41</a> for my current solution (which is using my own DecidableEq instance)</p>",
        "id": 399628954,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698799934
    },
    {
        "content": "<p>Here's a way to make <code>decide</code> work without modification:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.IrreducibleDef</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">MyNat</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MyNat</span>\n\n<span class=\"c1\">-- Nat notation</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span> <span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">ofNat</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">zero</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">MyNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">MyNat</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">ofNat</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- Addition</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">addImpl</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span>\n  <span class=\"bp\">|</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">addImpl</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"n\">irreducible_def</span> <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">addImpl</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">MyNat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">add</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">add_def'</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">addImpl</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">add_def</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">add_zero</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_def'</span><span class=\"o\">,</span> <span class=\"n\">addImpl</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">add_succ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_def'</span><span class=\"o\">,</span> <span class=\"n\">addImpl</span><span class=\"o\">]</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">10</span> <span class=\"bp\">=</span> <span class=\"mi\">20</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span> <span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">toNat</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">MyNat.toNat</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ofNat_inj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">},</span> <span class=\"n\">MyNat.ofNat</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">MyNat.ofNat</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">eq</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congrArg</span> <span class=\"n\">Nat.succ</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">MyNat.ofNat_inj</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">MyNat.succ.inj</span> <span class=\"n\">eq</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ofNat_toNat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">,</span> <span class=\"n\">MyNat.ofNat</span> <span class=\"n\">a.toNat</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congrArg</span> <span class=\"n\">succ</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">ofNat_toNat</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ofNat_add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyNat.ofNat</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">MyNat.ofNat</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">MyNat.ofNat</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_def'</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">induction</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">MyNat.ofNat</span><span class=\"o\">,</span> <span class=\"n\">addImpl</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ToNat</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">MyNat.ofNat</span> <span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ToNat</span> <span class=\"n\">a</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">a.toNat</span>\n  <span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"n\">ofNat_toNat</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ToNat</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ToNat</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ToNat</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">ToNat.val</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">ToNat.val</span> <span class=\"n\">b</span>\n  <span class=\"n\">eq</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ofNat_add</span><span class=\"o\">,</span> <span class=\"n\">ToNat.eq</span><span class=\"o\">,</span> <span class=\"n\">ToNat.eq</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ToNat</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ToNat</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">decidable_of_iff</span> <span class=\"o\">(</span><span class=\"n\">ToNat.val</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">ToNat.val</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n    <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rhs</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">ToNat.eq</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"bp\">←</span> <span class=\"n\">ToNat.eq</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">b</span><span class=\"o\">)]</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">congrArg</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ofNat_inj</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">10</span> <span class=\"bp\">=</span> <span class=\"mi\">20</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span> <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 399636454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698803469
    }
]