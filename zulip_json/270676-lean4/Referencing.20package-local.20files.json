[
    {
        "content": "<p>Is there a best practice for how to get the path/contents of a file relative to the package, rather than to the user's package being built? Given that the shared libraries are precompiled, this information seems tricky to obtain.</p>",
        "id": 516764167,
        "sender_full_name": "Chase Norman",
        "timestamp": 1746651171
    },
    {
        "content": "<p>This question might be unfairly difficult; it seems uncommon for languages to have nice support for this. I will try another route.</p>",
        "id": 516764807,
        "sender_full_name": "Chase Norman",
        "timestamp": 1746651453
    },
    {
        "content": "<p>That's common for other languages to have support for this, its very common in Rust, Golang, C, or something else.</p>\n<p>In general there are two style: 1. Write an elaboration such that it can performs side-effects, read file and so on; 2. Write custom build scripts in Lakefile to generate Lean files that contents those infomation.</p>\n<p>When writing elaboration for them, you might find <code>Lean.MonadLog.getFileName</code> useful.</p>",
        "id": 516966800,
        "sender_full_name": "Alissa Tung",
        "timestamp": 1746732644
    },
    {
        "content": "<p>I'm not sure I understand your question, but in Veil we've <a href=\"https://github.com/verse-lab/veil/blob/e08b4a81db2fe79f64cb3117b792a42fe5d22549/Veil/Util/Meta.lean#L5-L16\">used</a> this (<a href=\"#narrow/channel/270676-lean4/topic/initSrcSearchPath/near/497828809\">Zulip thread</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">currentDirectory</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"currentDirectory!\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Elab.Term</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span><span class=\"w\"> </span><span class=\"n\">currentDirectory</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">elabCurrentFilePath</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElab</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">currentDirectory</span><span class=\"bp\">!</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">readThe</span><span class=\"w\"> </span><span class=\"n\">Lean.Core.Context</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">srcPath</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">System.FilePath.mk</span><span class=\"w\"> </span><span class=\"n\">ctx.fileName</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">srcDir</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">srcPath.parent</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"cannot compute parent directory of '{srcPath}'\"</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">mkStrLit</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{srcDir}\"</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwUnsupportedSyntax</span>\n</code></pre></div>\n<p>If you depend on a file, you probably want to make <code>lake</code> aware of it as well, e.g. <a href=\"https://github.com/abdoo8080/lean-cvc5/blob/319a41a2e84fbe5138620e7111354c4036ebff75/lakefile.lean#L98\">like this</a>.</p>",
        "id": 517108867,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1746796532
    },
    {
        "content": "<p>That looks like a bad idea to me, since you risk compiling the current path into the distributed olean files</p>",
        "id": 517109779,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746796826
    },
    {
        "content": "<p>Instead you should write a function in <code>CoreM</code>, and call that when you need it</p>",
        "id": 517109885,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746796858
    },
    {
        "content": "<p>Indeed, this isn't great, since it prevents you from distributing oleans. It only works if each user builds your package on their own machine and then doesn't move it. Bundling the needed file's contents into the Lean file (via <code>include_str</code> or similar) is likely better.</p>\n<blockquote>\n<p>Instead you should write a function in <code>CoreM</code>, and call that when you need it</p>\n</blockquote>\n<p>Maybe I misunderstood <span class=\"user-mention\" data-user-id=\"346696\">@Chase Norman</span>'s intention, but I think his use-case is: you define package A, and your user imports A in their own package X; the question is how to get paths relative to A rather than relative to X.</p>\n<p>If you get <code>core.Context.fileName</code> or <code>IO.currentDir</code> or anything like that at runtime, you will only get paths relative to X.</p>",
        "id": 517132528,
        "sender_full_name": "George Pîrlea",
        "timestamp": 1746802997
    },
    {
        "content": "<p>Currently I think the preferred approach is to use <code>include_str</code>, to not only resolve the path but also inline its contents</p>",
        "id": 517133263,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746803210
    }
]