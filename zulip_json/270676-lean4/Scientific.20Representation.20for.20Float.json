[
    {
        "content": "<p>By default Repr represent Float without without Scientific notation. <br>\nThis is annoying when Float are really small for example, because Repr will show them as <code>0.000000</code>.<br>\nSo is there an option to change the default Repr ? <br>\nIf not would a PR be acceptable to change the Repr to use Scientific notation when the number is too small or too big ?</p>",
        "id": 538800428,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1757579903
    },
    {
        "content": "<p>It was asked here also :<br>\n<a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22.25.2E5g.22.20.25.20x.20for.20Float/with/418168531\">https://leanprover.zulipchat.com/#narrow/channel/217875-Is-there-code-for-X.3F/topic/.22.25.2E5g.22.20.25.20x.20for.20Float/with/418168531</a></p>",
        "id": 538801253,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1757580143
    },
    {
        "content": "<p>IIRC you can set priorities for instances. Something along the lines of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">high</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 538812920,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1757583705
    },
    {
        "content": "<p>Yes, i did that in custom code. But i was thinking about adding it natively. And wanted to know if such a change would be accepted</p>",
        "id": 538835575,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1757590975
    },
    {
        "content": "<p>Funnily enough, we'd probably get scientific notation if we used C++26 (we use <code>std::to_string</code>)<br>\n<a href=\"https://en.cppreference.com/w/cpp/string/basic_string/to_string\">https://en.cppreference.com/w/cpp/string/basic_string/to_string</a></p>",
        "id": 538837441,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757591591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"942100\">ecyrbe</span> <a href=\"#narrow/channel/270676-lean4/topic/Scientific.20Representation.20for.20Float/near/538835575\">said</a>:</p>\n<blockquote>\n<p>Yes, i did that in custom code. But i was thinking about adding it natively. And wanted to know if such a change would be accepted</p>\n</blockquote>\n<p>Ah, I think that's sensible.<br>\nThis is what Python 3.10.12 shows</p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"mf\">0.000000000000000003</span>\n<span class=\"mf\">3e-18</span>\n</code></pre></div>\n<p>And this is what Node 20.5.1 shows</p>\n<div class=\"codehilite\" data-code-language=\"JavaScript\"><pre><span></span><code><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mf\">0.000000000000000003</span>\n<span class=\"mf\">3e-18</span>\n</code></pre></div>\n<p>And Rust (toolchain 1.88) shows the exact same thing.</p>",
        "id": 538837559,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1757591629
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/270676-lean4/topic/Scientific.20Representation.20for.20Float/near/538837441\">said</a>:</p>\n<blockquote>\n<p>Funnily enough, we'd probably get scientific notation if we used C++26 (we use <code>std::to_string</code>)<br>\n<a href=\"https://en.cppreference.com/w/cpp/string/basic_string/to_string\">https://en.cppreference.com/w/cpp/string/basic_string/to_string</a></p>\n</blockquote>\n<p>So if we don't want to target c++26, maybe a PR to use c++20 using std::format instead would be ok ?</p>",
        "id": 538841322,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1757592594
    },
    {
        "content": "<p>so changing this :</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"n\">LEAN_EXPORT</span><span class=\"w\"> </span><span class=\"n\">lean_obj_res</span><span class=\"w\"> </span><span class=\"n\">lean_float_to_string</span><span class=\"p\">(</span><span class=\"kt\">double</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">isnan</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">))</span>\n<span class=\"w\">        </span><span class=\"c1\">// override NaN because we don't want NaNs to be distinguishable</span>\n<span class=\"w\">        </span><span class=\"c1\">// because the sign bit / payload bits can be architecture-dependent</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">mk_ascii_string_unchecked</span><span class=\"p\">(</span><span class=\"s\">\"NaN\"</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">mk_ascii_string_unchecked</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">to_string</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">));</span>\n</code></pre></div>\n<p>into this :</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"n\">LEAN_EXPORT</span><span class=\"w\"> </span><span class=\"n\">lean_obj_res</span><span class=\"w\"> </span><span class=\"n\">lean_float_to_string</span><span class=\"p\">(</span><span class=\"kt\">double</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">isnan</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">))</span>\n<span class=\"w\">        </span><span class=\"c1\">// override NaN because we don't want NaNs to be distinguishable</span>\n<span class=\"w\">        </span><span class=\"c1\">// because the sign bit / payload bits can be architecture-dependent</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">mk_ascii_string_unchecked</span><span class=\"p\">(</span><span class=\"s\">\"NaN\"</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">mk_ascii_string_unchecked</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 538842495,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1757592913
    },
    {
        "content": "<p>I created an RFC here : <a href=\"https://github.com/leanprover/lean4/issues/10349\">https://github.com/leanprover/lean4/issues/10349</a></p>",
        "id": 538847739,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1757594329
    },
    {
        "content": "<p>After some tests, it seems we are using CLang 15, to be able to use c++20, we would need to switch to at least CLang 17</p>",
        "id": 538883244,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1757602916
    },
    {
        "content": "<p>The configuration to at least switch to CLang 17 is on the Nix configuration here :<br>\n<a href=\"https://github.com/leanprover/lean4/blob/master/flake.nix\">https://github.com/leanprover/lean4/blob/master/flake.nix</a></p>\n<p>And we would need to change this line :</p>\n<div class=\"codehilite\" data-code-language=\"Nix\"><pre><span></span><code>      <span class=\"ss\">llvmPackages</span> <span class=\"o\">=</span> pkgs<span class=\"o\">.</span>llvmPackages_15<span class=\"p\">;</span>\n</code></pre></div>\n<p>into this :</p>\n<div class=\"codehilite\" data-code-language=\"Nix\"><pre><span></span><code>      <span class=\"ss\">llvmPackages</span> <span class=\"o\">=</span> pkgs<span class=\"o\">.</span>llvmPackages_17<span class=\"p\">;</span>\n</code></pre></div>\n<p>And add the flag on <code>CMakeList.txt</code> to use <code>std:c++20</code><br>\nNot sure how of a breaking change it is to update Lean4 C++ toolset.</p>\n<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>  is it complicated ?</p>",
        "id": 538904502,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1757608778
    },
    {
        "content": "<p>This works even with C++11</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;iostream&gt;</span>\n<span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;sstream&gt;</span>\n<span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;string&gt;</span>\n\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"w\"> </span><span class=\"nf\">double_to_string</span><span class=\"p\">(</span><span class=\"kt\">double</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">ostringstream</span><span class=\"w\"> </span><span class=\"n\">oss</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"n\">oss</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">oss</span><span class=\"p\">.</span><span class=\"n\">str</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">double_to_string</span><span class=\"p\">(</span><span class=\"mf\">0.01</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">double_to_string</span><span class=\"p\">(</span><span class=\"mf\">0.00000000000000000000001</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 538909889,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1757610687
    },
    {
        "content": "<p>Right, the <code>std::cout</code> option described in the docs. I think the main difference to <code>std::format</code> is that it is inprecise; but so is the current version so I guess that would still be some improvement.</p>",
        "id": 538911877,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757611461
    },
    {
        "content": "<p>There's <code>std::to_chars</code> in C++17 if you want shortest unique representation. But I think Lean is build with C++14?</p>",
        "id": 538914398,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1757612329
    }
]