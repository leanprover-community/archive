[
    {
        "content": "<p>I'm defining a DSL, but Lean is having trouble parsing it. I've reduced the problem to a minimal test case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span> <span class=\"n\">thing</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"thing% \"</span> <span class=\"n\">thing</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"a\"</span> <span class=\"n\">thing</span> <span class=\"s2\">\"b\"</span> <span class=\"n\">thing</span> <span class=\"o\">:</span> <span class=\"n\">thing</span>\n<span class=\"n\">syntax</span> <span class=\"n\">thing</span> <span class=\"s2\">\"b\"</span> <span class=\"n\">thing</span> <span class=\"o\">:</span> <span class=\"n\">thing</span>\n<span class=\"n\">syntax</span> <span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">thing</span>\n<span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"n\">thing</span><span class=\"bp\">%</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>I get an <code>expected 'b'</code> error on the third <code>x</code>. But there is a correct parse as <code>(a x b x) x</code>. What's going on? Can this be fixed, to have it correctly parse my context-free language?</p>",
        "id": 404110707,
        "sender_full_name": "Jason Ganz",
        "timestamp": 1700917684
    },
    {
        "content": "<p>I think this language is still ambiguous if you have something like <code>a x b x b x</code>, right? If I make it unambiguous by making <code>x b x</code> too low a precedence to occur in the left of <code>a _ b _</code>, Lean parses fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span> <span class=\"n\">thing</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"thing% \"</span> <span class=\"n\">thing</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"s2\">\"a\"</span> <span class=\"n\">thing</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"s2\">\"b\"</span> <span class=\"n\">thing</span> <span class=\"o\">:</span> <span class=\"n\">thing</span>\n<span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">90</span> <span class=\"n\">thing</span> <span class=\"s2\">\"b\"</span> <span class=\"n\">thing</span> <span class=\"o\">:</span> <span class=\"n\">thing</span>\n<span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">thing</span>\n</code></pre></div>",
        "id": 404111731,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1700918644
    },
    {
        "content": "<p>although I'm not sure how to get the left recursive variant of this working...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span> <span class=\"n\">thing</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"thing% \"</span> <span class=\"n\">thing</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"s2\">\"a\"</span> <span class=\"n\">thing</span><span class=\"o\">:</span><span class=\"mi\">90</span> <span class=\"s2\">\"b\"</span> <span class=\"n\">thing</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">thing</span>\n<span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">90</span> <span class=\"n\">thing</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"s2\">\"b\"</span> <span class=\"n\">thing</span><span class=\"o\">:</span><span class=\"mi\">90</span> <span class=\"o\">:</span> <span class=\"n\">thing</span>\n<span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">thing</span>\n</code></pre></div>",
        "id": 404112229,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1700919117
    },
    {
        "content": "<p>I see, the language is in fact ambiguous, but I didn't realize this would prevent Lean from parsing even unambiguous expressions. Thanks for the info!</p>",
        "id": 404112340,
        "sender_full_name": "Jason Ganz",
        "timestamp": 1700919187
    },
    {
        "content": "<p>I'm not sure how ambiguity has to do with what grammars Lean can/can't parse. You can definitely parse ambiguous grammars, and unambiguous grammars can definitely not parse the way you want (see above). So someone with more knowledge than me should chime in.</p>\n<p>I think the <code>_ b _</code> rule needs some extra combinators or something. I'm not sure how left recursion is handled.</p>",
        "id": 404112780,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1700919596
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"670165\">@Jason Ganz</span> For your original example, the way Lean will end up parsing <code>a x b x x</code> as a <code>thing</code> is as follows:</p>\n<ul>\n<li>As <code>thing</code> is a syntax category, it will select the longest matching parse of its alternatives (if equal, chooses the successful parse with the highest priority). Lean parses category syntax via a single leading parser and many optional trailing parsers. Trailing parser are those whose LHS is recursion (e.g., <code>thing \"b\" thing</code>). This approach is Pratt parsing.</li>\n<li>As the expression starts with the symbol <code>a</code>,  the only possible leading parser is <code>\"a\" thing \"b\" thing</code>.</li>\n<li>It will then recurse on the first thing in <code>\"a\" **thing** \"b\" thing</code>.</li>\n<li>Since the next token is <code>x</code>, the only possible leading parser is <code>ident</code>.</li>\n<li>Finished with the level 2  leading<code>thing</code>, Lean will then attempt to match zero or more trailing <code>\"b\" thing</code> (i.e., parse many <code>thing \"b\" thing</code>) .</li>\n<li>It matches the <code>b</code> and recurses on the following <code>thing</code>.</li>\n<li>Once again, since the next token is <code>x</code>, the only possible leading parser is <code>ident</code>.</li>\n<li>As there are no longer any matching trailing parsers (i.e., more trailing <code>\"b\" thing</code>), Lean will stop and work back up the parse call stack.</li>\n<li>Prior to this at failure this point, Lean has parsed <code>a x b x</code> and the parse call stack is currently: <code>\"a\" **thing** \"b\" thing</code> -&gt; <code>thing \"b\" **thing**</code> (LHS parsed as the <code>ident</code>, <code>x</code>) -&gt; <code>ident</code>.</li>\n<li>It thus works back up to <code>\"a\" **thing** \"b\" thing</code> with the finished <code>thing</code> being <code>x b x</code>.</li>\n<li>Now, the next required token is <code>b</code>, but the next token in the expression is <code>x</code>, hence the error.</li>\n</ul>",
        "id": 404513388,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701131791
    },
    {
        "content": "<p>More visually:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"n\">a</span>    <span class=\"n\">x</span>     <span class=\"n\">b</span>    <span class=\"n\">x</span>       <span class=\"n\">x</span>\n<span class=\"c1\">----------------------------------</span>\n<span class=\"s2\">\"a\"</span> <span class=\"n\">thing</span>              <span class=\"bp\">~</span><span class=\"s2\">\"b\"</span> <span class=\"n\">thing</span><span class=\"bp\">~</span>\n      <span class=\"bp\">|</span>\n    <span class=\"n\">ident</span> <span class=\"o\">[</span><span class=\"s2\">\"b\"</span> <span class=\"n\">thing</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">~</span><span class=\"s2\">\"b\"</span> <span class=\"n\">thing</span><span class=\"bp\">~</span><span class=\"o\">]</span>\n                 <span class=\"bp\">|</span>\n               <span class=\"n\">ident</span>  <span class=\"o\">[</span><span class=\"bp\">~</span><span class=\"s2\">\"b\"</span> <span class=\"n\">thing</span><span class=\"bp\">~</span><span class=\"o\">]</span>\n</code></pre></div>\n<p><code>[..]</code> is the RHS of the attempted trailing parser, and <code>~...~</code> is a failed match.</p>",
        "id": 404514703,
        "sender_full_name": "Mac Malone",
        "timestamp": 1701132361
    }
]