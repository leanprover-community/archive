[
    {
        "content": "<p>Lean 4 seems to support a very general form of induction, strictly more general than <em>HoTT</em>. I ran into this because <code>Syntax</code> nodes involve <code>Array Syntax</code>, and trepplein 3 does not support this.</p>\n<p>My question is whether recursors of inductive types of a general form are documented anywhere. I looked at Mario's thesis and the section was not detailed enough for me to understand the following rather gothic example (or even the more modest one with <code>Array Syntax</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MyList</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">MyList</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tail</span> <span class=\"o\">:</span> <span class=\"n\">MyList</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyList</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">MyListTree</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">children</span><span class=\"o\">:</span> <span class=\"n\">MyList</span> <span class=\"o\">(</span><span class=\"n\">MyListTree</span> <span class=\"n\">α</span><span class=\"o\">))(</span><span class=\"n\">family</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">MyListTree</span> <span class=\"n\">α</span> <span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree</span> <span class=\"n\">α</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">MyListTree.rec</span> <span class=\"c\">/-</span><span class=\"cm\"> {α : Type u} →</span>\n<span class=\"cm\">  {motive_1 : MyListTree α → Sort u_1} →</span>\n<span class=\"cm\">    {motive_2 : MyList (MyListTree α) → Sort u_1} →</span>\n<span class=\"cm\">      {motive_3 : List (MyListTree α) → Sort u_1} →</span>\n<span class=\"cm\">        ((a : α) → motive_1 (MyListTree.leaf a)) →</span>\n<span class=\"cm\">          ((children : MyList (MyListTree α)) →</span>\n<span class=\"cm\">              (family : ℕ → List (MyListTree α)) →</span>\n<span class=\"cm\">                motive_2 children → ((a : ℕ) → motive_3 (family a)) → motive_1 (MyListTree.node children family)) →</span>\n<span class=\"cm\">            motive_2 MyList.nil →</span>\n<span class=\"cm\">              ((head : MyListTree α) →</span>\n<span class=\"cm\">                  (tail : MyList (MyListTree α)) → motive_1 head → motive_2 tail → motive_2 (MyList.cons head tail)) →</span>\n<span class=\"cm\">                motive_3 [] →</span>\n<span class=\"cm\">                  ((head : MyListTree α) →</span>\n<span class=\"cm\">                      (tail : List (MyListTree α)) → motive_1 head → motive_3 tail → motive_3 (head :: tail)) →</span>\n<span class=\"cm\">                    (t : MyListTree α) → motive_1 t</span>\n<span class=\"cm\">      -/</span>\n</code></pre></div>\n<p>I can try to work this out and document it, but if there is someplace I can look up that would be useful.</p>",
        "id": 396819352,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1697429885
    },
    {
        "content": "<p>My thesis does not cover nested inductives, as they were not primitive in lean 3</p>",
        "id": 396823316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697432433
    },
    {
        "content": "<p>I believe <a href=\"https://publikationen.bibliothek.kit.edu/1000161074\">Sebastian's thesis</a> has a section on nested inductives, but IIRC it does not go into enough detail to work as a spec</p>",
        "id": 396823518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697432568
    },
    {
        "content": "<p>Probably the best precise source at the moment is <a href=\"https://github.com/digama0/lean4lean/blob/master/Lean4Lean/Inductive/Add.lean#L473-L672\">https://github.com/digama0/lean4lean/blob/master/Lean4Lean/Inductive/Add.lean#L473-L672</a> (I intend to add comments once the bugs are ironed out, there are also some comments in the <a href=\"https://github.com/leanprover/lean4/blob/master/src/kernel/inductive.cpp#L791C7-L1175\">original source</a>). My intention is to unpack this code into a spec sometime soon</p>",
        "id": 396823749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697432750
    },
    {
        "content": "<p>In other words, no there is no documentation</p>",
        "id": 396823782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697432763
    },
    {
        "content": "<p>I can give the gist of the algorithm though. It helps if you are familiar with the nested inductive algorithm from lean 3. The first pass is to collect all the mutual inductives needed. We walk the inductive specification looking for inductive types with our inductive(s) in the parameters, and add them to a list. We also have to recursively walk the specifications of these inductives (after applying our instantiation) looking for more inductive types involving our types. Once the list reaches a fixed point, we construct a mutual inductive with all of these inductive specifications and defer to the regular mutual inductive mechanism. But we intercept the resulting inductive type and edit the constructors and recursor to remove references to the auxiliary mutual inductive types we created.</p>",
        "id": 396824307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697433129
    },
    {
        "content": "<p>In your example, we walk the inductive specification looking for occurrences of inductive types containing <code>MyListTree</code> in the parameters, and we find two: <code>MyList (MyListTree α)</code>, and later <code>List (MyListTree α)</code>. We then walk the inductive spec of <code>MyList</code> with the parameter substituted for <code>α</code>, but we only find <code>MyList (MyListTree α)</code> again. Similarly, we walk <code>List (MyListTree α)</code> and find <code>MyListTree α</code> and <code>List (MyListTree α)</code>, nothing new. So the first pass terminates with the following auxiliary types:</p>\n<ul>\n<li><code>MyListTree α</code></li>\n<li><code>MyListTree.aux_1 α := MyList (MyListTree α)</code></li>\n<li><code>MyListTree.aux_2 α := List (MyListTree α)</code></li>\n</ul>\n<p>We construct the following mutual inductive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">MyListTree</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">children</span><span class=\"o\">:</span> <span class=\"n\">MyList.aux_1</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">family</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">MyListTree.aux_2</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">MyListTree.aux_1</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree.aux_1</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tail</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree.aux_1</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree.aux_1</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">MyListTree.aux_2</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree.aux_2</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tail</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree.aux_2</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree.aux_2</span> <span class=\"n\">α</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This is passed to the add_inductive function, which constructs three types, 6 constructors and 3 recursors for the 3 mutual inductive types. This is added to an environment <code>aux_env</code>, but this is not the real environment we will be using. The recursor for <code>MyListTree</code> looks something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">recursor</span> <span class=\"n\">MyListTree.rec</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n  <span class=\"o\">{</span><span class=\"n\">motive_1</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n    <span class=\"o\">{</span><span class=\"n\">motive_2</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree.aux_1</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n      <span class=\"o\">{</span><span class=\"n\">motive_3</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree.aux_2</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n        <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive_1</span> <span class=\"o\">(</span><span class=\"n\">MyListTree.leaf</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n          <span class=\"o\">((</span><span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree.aux_1</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n              <span class=\"o\">(</span><span class=\"n\">family</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">MyListTree.aux_2</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n                <span class=\"n\">motive_2</span> <span class=\"n\">children</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive_3</span> <span class=\"o\">(</span><span class=\"n\">family</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive_1</span> <span class=\"o\">(</span><span class=\"n\">MyListTree.node</span> <span class=\"n\">children</span> <span class=\"n\">family</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n            <span class=\"n\">motive_2</span> <span class=\"n\">MyListTree.aux_1.nil</span> <span class=\"bp\">→</span>\n              <span class=\"o\">((</span><span class=\"n\">head</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n                  <span class=\"o\">(</span><span class=\"n\">tail</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree.aux_1</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive_1</span> <span class=\"n\">head</span> <span class=\"bp\">→</span> <span class=\"n\">motive_2</span> <span class=\"n\">tail</span> <span class=\"bp\">→</span> <span class=\"n\">motive_2</span> <span class=\"o\">(</span><span class=\"n\">MyListTree.aux_1.cons</span> <span class=\"n\">head</span> <span class=\"n\">tail</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n                <span class=\"n\">motive_3</span> <span class=\"n\">MyListTree.aux_2.nil</span> <span class=\"bp\">→</span>\n                  <span class=\"o\">((</span><span class=\"n\">head</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n                      <span class=\"o\">(</span><span class=\"n\">tail</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree.aux_2</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive_1</span> <span class=\"n\">head</span> <span class=\"bp\">→</span> <span class=\"n\">motive_3</span> <span class=\"n\">tail</span> <span class=\"bp\">→</span> <span class=\"n\">motive_3</span> <span class=\"o\">(</span><span class=\"n\">MyListTree.aux_2.cons</span> <span class=\"n\">head</span> <span class=\"n\">tail</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n                    <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">MyListTree</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive_1</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>(Note that there are two other recursors, at <code>MyListTree.rec_1</code> and <code>MyListTree.rec_2</code>.) We now postprocess this term to replace all occurrences of <code>MyListTree.aux_1 α</code> with <code>MyList (MyListTree α)</code>, using the mapping generated at the beginning, and similarly replace <code>MyListTree.aux_2 α</code> with <code>List (MyListTree α)</code>. The constructors are just replaced by corresponding (instantiated) constructors from the original inductive. The result is the recursor that you have shown.</p>",
        "id": 396825499,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697433966
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I will work with the above description, and the <code>Lean4Lean</code> source and \"follow my nose\" to try to implement this.</p>",
        "id": 396827999,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1697435698
    },
    {
        "content": "<p>In the case of <code>Syntax</code>, whose node has <code>Array Syntax</code>, I take it that there are auxiliary inductive types for <code>Array Syntax</code> and then <code>List Syntax</code>. We have recursors for each of these from which the big one is built.</p>",
        "id": 396830536,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1697437173
    },
    {
        "content": "<p>yes</p>",
        "id": 396831579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697437721
    },
    {
        "content": "<p>One further question about the <em>reduction rules</em>. To be concrete, let me consider a simpler example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">ArrayTree</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ArrayTree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">ArrayTree</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ArrayTree</span>\n</code></pre></div>\n<p>where we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">ArrayTree.rec</span> <span class=\"c\">/-</span><span class=\"cm\"> {motive_1 : ArrayTree → Sort u} →</span>\n<span class=\"cm\">  {motive_2 : Array ArrayTree → Sort u} →</span>\n<span class=\"cm\">    {motive_3 : List ArrayTree → Sort u} →</span>\n<span class=\"cm\">      ((n : ℕ) → motive_1 (ArrayTree.leaf n)) →</span>\n<span class=\"cm\">        ((node : Array ArrayTree) → motive_2 node → motive_1 (ArrayTree.node node)) →</span>\n<span class=\"cm\">          ((data : List ArrayTree) → motive_3 data → motive_2 { data := data }) →</span>\n<span class=\"cm\">            motive_3 [] →</span>\n<span class=\"cm\">              ((head : ArrayTree) → (tail : List ArrayTree) → motive_1 head → motive_3 tail → motive_3 (head :: tail)) →</span>\n<span class=\"cm\">                (t : ArrayTree) → motive_1 t -/</span>\n</code></pre></div>\n<p>Am I correct that we have reduction rules corresponding to tuples of constructors. For example, in the above we will have a reduction rule corresponding to <code>ArrayTree.node (Array.mk (head :: tail))</code>?</p>",
        "id": 396873807,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1697452625
    },
    {
        "content": "<p>HoTT is not a single formal system. Some varieties have nested inductives too, such as Agda. Agda doesn't generate recursors at all though.</p>",
        "id": 396898202,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1697461461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"404479\">Trebor Huang</span> <a href=\"#narrow/stream/270676-lean4/topic/Complicated.20induction.3A.20documentation.3F/near/396898202\">said</a>:</p>\n<blockquote>\n<p>HoTT is not a single formal system. Some varieties have nested inductives too, such as Agda. Agda doesn't generate recursors at all though.</p>\n</blockquote>\n<p>By \"HoTT\" I meant \"book HoTT\", the foundations in the HoTT book. This is where I first learnt type theory.</p>",
        "id": 396908787,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1697464559
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266304\">@Siddhartha Gadgil</span> <a href=\"#narrow/stream/270676-lean4/topic/Complicated.20induction.3A.20documentation.3F/near/396873807\">said</a>:</p>\n<blockquote>\n<p>Am I correct that we have reduction rules corresponding to tuples of constructors. For example, in the above we will have a reduction rule corresponding to <code>ArrayTree.node (Array.mk (head :: tail))</code>?</p>\n</blockquote>\n<p>No, reduction rules apply only to single constructors. In this example there are 5 reduction rules for 3 recursors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">ArrayTree.rec</span> <span class=\"n\">leaf</span> <span class=\"n\">node</span> <span class=\"n\">mk</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"bp\">=</span> <span class=\"n\">leaf</span> <span class=\"n\">n</span>\n<span class=\"n\">ArrayTree.rec</span> <span class=\"n\">leaf</span> <span class=\"n\">node</span> <span class=\"n\">mk</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"bp\">=</span> <span class=\"n\">node</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">ArrayTree.rec_1</span> <span class=\"n\">leaf</span> <span class=\"n\">node</span> <span class=\"n\">mk</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"n\">ArrayTree.rec_1</span> <span class=\"n\">leaf</span> <span class=\"n\">node</span> <span class=\"n\">mk</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">data</span><span class=\"o\">)</span>\n  <span class=\"bp\">=</span> <span class=\"n\">mk</span> <span class=\"n\">data</span> <span class=\"o\">(</span><span class=\"n\">ArrayTree.rec_2</span> <span class=\"n\">leaf</span> <span class=\"n\">node</span> <span class=\"n\">mk</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"n\">data</span><span class=\"o\">)</span>\n<span class=\"n\">ArrayTree.rec_2</span> <span class=\"n\">leaf</span> <span class=\"n\">node</span> <span class=\"n\">mk</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"bp\">.</span><span class=\"n\">nil</span>\n  <span class=\"bp\">=</span> <span class=\"n\">nil</span>\n<span class=\"n\">ArrayTree.rec_2</span> <span class=\"n\">leaf</span> <span class=\"n\">node</span> <span class=\"n\">mk</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">head</span> <span class=\"n\">tail</span><span class=\"o\">)</span>\n  <span class=\"bp\">=</span> <span class=\"n\">cons</span> <span class=\"n\">head</span> <span class=\"n\">tail</span> <span class=\"o\">(</span><span class=\"n\">ArrayTree.rec</span> <span class=\"n\">leaf</span> <span class=\"n\">node</span> <span class=\"n\">mk</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"n\">head</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ArrayTree.rec_2</span> <span class=\"n\">leaf</span> <span class=\"n\">node</span> <span class=\"n\">mk</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"n\">tail</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 397005586,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697506212
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> - without the auxiliary recursors I could not figure out any valid simplification rules except of the form I mentioned. But now it is all clear.</p>",
        "id": 397009460,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1697508552
    },
    {
        "content": "<p>I was trying to work out what to do with the following example, and found that it is forbidden. So I assume that we cannot have families and nested types together. I am pasting the example for the record and so someone who knows can confirm.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">VectorTree</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">VectorTree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">branches</span><span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">VectorTree</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">VectorTree</span>\n</code></pre></div>",
        "id": 397076569,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1697538160
    },
    {
        "content": "<p>nested inductives don't support definitions at all</p>",
        "id": 397076962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697538289
    },
    {
        "content": "<p>even just</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">List'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"n\">List'</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span>\n</code></pre></div>\n<p>fails</p>",
        "id": 397077055,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697538321
    },
    {
        "content": "<p>if you inline the definition you get a different error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">VectorTree</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">VectorTree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">branches</span><span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">VectorTree</span> <span class=\"bp\">//</span> <span class=\"n\">l.length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">VectorTree</span>\n</code></pre></div>\n<blockquote>\n<p>(kernel) invalid nested inductive datatype 'Subtype', nested inductive datatypes parameters cannot contain local variables.</p>\n</blockquote>",
        "id": 397077410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697538430
    },
    {
        "content": "<p>However, if you use the classic inductive definition of <code>Vector</code> then it works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Vector'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Vector'</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Vector'</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vector'</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">VectorTree</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">VectorTree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">branches</span><span class=\"o\">:</span> <span class=\"n\">Vector'</span> <span class=\"n\">VectorTree</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">VectorTree</span>\n</code></pre></div>",
        "id": 397078102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697538638
    },
    {
        "content": "<p>which is to say, inductive families are allowed</p>",
        "id": 397078168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697538660
    },
    {
        "content": "<p>Thanks. Indeed I just tried the classical definition and got this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Vec</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)(</span><span class=\"n\">head</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tail</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">α</span>  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">VectorTree</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">VectorTree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">branches</span><span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">VectorTree</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">VectorTree</span>\n\n\n<span class=\"k\">#check</span> <span class=\"n\">VectorTree.rec</span> <span class=\"c\">/-</span>\n<span class=\"cm\">{motive_1 : VectorTree → Sort u} →</span>\n<span class=\"cm\">  {motive_2 : (a : ℕ) → Vec VectorTree a → Sort u} →</span>\n<span class=\"cm\">    ((n : ℕ) → motive_1 (VectorTree.leaf n)) →</span>\n<span class=\"cm\">      ((n : ℕ) → (branches : Vec VectorTree n) → motive_2 n branches → motive_1 (VectorTree.node n branches)) →</span>\n<span class=\"cm\">        motive_2 0 Vec.nil →</span>\n<span class=\"cm\">          ((n : ℕ) →</span>\n<span class=\"cm\">              (head : VectorTree) →</span>\n<span class=\"cm\">                (tail : Vec VectorTree n) → motive_1 head → motive_2 n tail → motive_2 (n + 1) (Vec.cons n head tail)) →</span>\n<span class=\"cm\">            (t : VectorTree) → motive_1 t</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 397078421,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1697538785
    },
    {
        "content": "<p>I am concerned that in translation to mutual inductives we end up with <code>Vec VectorTree n</code> which has an <code>n</code> that has no meaning except when associated to a constructor. Have not thought through this but any clarification is welcome.</p>",
        "id": 397078686,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1697538879
    },
    {
        "content": "<p>not sure what you mean by that, the mutual inductive in question is the <code>Vec VectorTree</code> family itself</p>",
        "id": 397078763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697538917
    },
    {
        "content": "<p>Note that the self type is only allowed to appear in the parameters, it is rejected if it is in an index</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Vector'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Vector'</span> <span class=\"n\">Nat</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Vector'</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vector'</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">VectorTree</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">VectorTree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">branches</span><span class=\"o\">:</span> <span class=\"n\">Vector'</span> <span class=\"n\">VectorTree</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">VectorTree</span>\n</code></pre></div>\n<blockquote>\n<p>(kernel) arg <a href=\"https://github.com/leanprover-community/mathlib4/pull/2\">#2</a> of 'VectorTree.node' contains a non valid occurrence of the datatypes being declared</p>\n</blockquote>",
        "id": 397078940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1697538994
    },
    {
        "content": "<p>Ah thanks. I see that the indices in the family like <code>n</code> become <em>indices</em> of the type. That makes sense.</p>",
        "id": 397079398,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1697539152
    },
    {
        "content": "<p>(Just a comment from the sidelines that this is a very interesting thread, and the patient and careful explanations by Mario a good example of why the lean/mathlib community is so pleasant and welcoming.)</p>",
        "id": 397088429,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1697542288
    }
]