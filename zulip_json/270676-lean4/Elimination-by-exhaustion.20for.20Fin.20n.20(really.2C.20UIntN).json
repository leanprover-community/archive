[
    {
        "content": "<p>I'm getting back to work on my little de-/serialization framework and I'd like to start proving some roundtrip equality properties, i.e. theorems of the form <code>v = deserialize (serialize v)</code>.</p>\n<p>One of my representable types is <code>UInt8</code> (really, a standin for \"some fixed-width integer\"). I can probably adjust my de-/serialization (henceforth \"serdes\") functions so that I can prove roundtrip algebraically, but given that these functions have computable implementations, it's a lot easier to just prove it by exhaustion. That also means that the proof is independent of the implementation, which is helpful since I'm changing stuff frequently.</p>\n<p>Now, given any particular UInt8 (or Nat, or Fin 256) value, I have a short tactic proof which demonstrates the roundtrip equality. However, I can't figure out how to actually do a proof by exhaustion on UInt8 (or Fin, for that matter). The eliminators for Fin seem to all be inductive, which isn't useful.</p>\n<p>If I could get an exhaustion eliminator, I could just do something like <code>cases n using exhaustive_eliminator &lt;;&gt; my_tactic</code>, which feels natural.</p>\n<p>I found <a href=\"#narrow/channel/270676-lean4/topic/About.20.60Nat.2Eall.60.2F.60Nat.2Eany.60\">#lean4 &gt; About &#96;Nat.all&#96;/&#96;Nat.any&#96;</a>  which references <code>Nat.all</code> and <code>Nat.all_eq_finRange_all</code>, but I wasn't successfully able to adapt that idea to my problem. I also don't know if building up a big chain of <code>\\and</code>s is as useful as building up a chain of <code>&amp;&amp;</code>s (since I need to work in <code>Prop</code> as opposed to <code>Bool</code>).</p>\n<p>I also found <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/Pattern.20matching.20on.20Fin.20isn.27t.20exhaustive.20for.20large.20matches/near/428049672\">#lean4 &gt; Pattern matching on Fin isn't exhaustive for large matches @ ðŸ’¬</a> , which seems like it could be directly relevant, but I haven't tried to actually understand it yet; it certainly didn't make immediate sense to me.</p>\n<p>So, is there some straightforward proof-by-exhaustion eliminator for UInt8/BitVec/Fin?</p>",
        "id": 533635561,
        "sender_full_name": "neil",
        "timestamp": 1754815084
    },
    {
        "content": "<p>(there are also some weird questions which arise from the specifics of my functions, including that I have to do stuff like <code>simp[Vector.range, Array.range, Array.ofFn, Array.ofFn.go]</code> to get some (what I think are) basic equalities to actually go through, and that if I try to prove roundtrip using a <code>Fin</code> to instantiate/destruct a <code>UInt8</code><br>\n it's a nightmare, but going via <code>Nat</code> seems to play nicer with the simplifier, but I digress)</p>",
        "id": 533635750,
        "sender_full_name": "neil",
        "timestamp": 1754815257
    },
    {
        "content": "<p><code>fin_cases</code> in Mathlib?</p>",
        "id": 533635859,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754815351
    },
    {
        "content": "<p><code>UInt8</code> is like, pretty large though</p>",
        "id": 533635906,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754815398
    },
    {
        "content": "<p>UInt8 is 256 values, which is sufficiently close to 1 for me</p>",
        "id": 533635927,
        "sender_full_name": "neil",
        "timestamp": 1754815419
    },
    {
        "content": "<p>and if you say you run some kind of tactic afterwards you're going to have a proof that takes a <em>while</em> to elaborate</p>",
        "id": 533635932,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754815424
    },
    {
        "content": "<p>Which kind of tactic do you want to run later?</p>",
        "id": 533635954,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754815447
    },
    {
        "content": "<p>it's actually just a big call to <code>simp[...]</code></p>",
        "id": 533635966,
        "sender_full_name": "neil",
        "timestamp": 1754815464
    },
    {
        "content": "<p>since the functions are calculable, there's not really anything interesting to do; you just have to evaluate them completely</p>",
        "id": 533635988,
        "sender_full_name": "neil",
        "timestamp": 1754815485
    },
    {
        "content": "<p>Hmm well that might still take a minute or so</p>",
        "id": 533636052,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754815537
    },
    {
        "content": "<p>that said, I must be unfamiliar with lean, because my tactic is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">parseInt8</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">serializeInt8</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">ofFn</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">ofFn</span><span class=\"bp\">.</span><span class=\"n\">go</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and, coming from Rocq, the second simp call feels like it should not be necessary</p>",
        "id": 533636054,
        "sender_full_name": "neil",
        "timestamp": 1754815539
    },
    {
        "content": "<p>is there a better way to tell lean to just evaluate a term than these simp commands? given that simp is, you know, more than just evaluation</p>",
        "id": 533636079,
        "sender_full_name": "neil",
        "timestamp": 1754815567
    },
    {
        "content": "<p>Can you point me to the source code again?</p>",
        "id": 533636089,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754815581
    },
    {
        "content": "<p>let me excise it and post it here</p>",
        "id": 533636099,
        "sender_full_name": "neil",
        "timestamp": 1754815591
    },
    {
        "content": "<p>and well you usually evaluate using <code>rfl</code>; but I suppose your proof is more than just evaluation</p>",
        "id": 533636142,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754815638
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Implementing example roundtrip ser/des for UInt8 / Vector Bool 8</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">parseInt8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c1\">-- [1, 2, 4, ..., 128]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">coeffs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"bp\">Â·</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"c1\">-- use b as a bitmask</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">summer</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">on</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">coeff</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">coeff</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">zip</span><span class=\"w\"> </span><span class=\"n\">coeffs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">foldr</span><span class=\"w\"> </span><span class=\"n\">summer</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"n\">value</span>\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">serializeInt8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"w\">  </span><span class=\"c1\">-- NOTE: we /don't/ want to reverse this because we're going to do a foldr on</span>\n<span class=\"w\">  </span><span class=\"c1\">-- digitifier.</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">coeffs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"bp\">Â·</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">digitifier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">coeff</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&gt;=</span><span class=\"w\"> </span><span class=\"n\">coeff</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">coeff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">true</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span>\n<span class=\"w\">                  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">false</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"c1\">-- (if n &gt;= coeff then n - coeff else n, #[(n â‰¥ coeff : Bool)] ++ acc)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">coeffs</span><span class=\"bp\">.</span><span class=\"n\">foldr</span><span class=\"w\"> </span><span class=\"n\">digitifier</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[])</span>\n<span class=\"w\">  </span><span class=\"c1\">-- proofs</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">digitifierSize</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"n\">coeff</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">digitifier</span><span class=\"w\"> </span><span class=\"n\">coeff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">coeff</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">digitifier</span>\n<span class=\"w\">    </span><span class=\"c1\">-- proceed by cases on n â‰¥ coeff</span>\n<span class=\"w\">    </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">heq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">â‰¥</span><span class=\"w\"> </span><span class=\"n\">coeff</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">heq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_comm</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">helper</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">coeffs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">v</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">64</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">128</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"c1\">-- Why does `simp` not want to just compute this constant??</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">coeffs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">ofFn</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">ofFn</span><span class=\"bp\">.</span><span class=\"n\">go</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"w\"> </span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">helper</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">digitifierSize</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 533636144,
        "sender_full_name": "neil",
        "timestamp": 1754815642
    },
    {
        "content": "<p>note that this is not pretty because I just needed to have /some/ way to de-/serialize these values</p>",
        "id": 533636165,
        "sender_full_name": "neil",
        "timestamp": 1754815661
    },
    {
        "content": "<p>so.. this is what I came up with</p>",
        "id": 533636174,
        "sender_full_name": "neil",
        "timestamp": 1754815668
    },
    {
        "content": "<p>Yeah right that <code>simp</code> call is literally just <code>rfl</code></p>",
        "id": 533636206,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754815712
    },
    {
        "content": "<p>if I wanted to prove this algebraically, I think I would make \"digitifier\" and \"summer\" real functions and prove that they're inverses, but... I don't want to do that</p>",
        "id": 533636213,
        "sender_full_name": "neil",
        "timestamp": 1754815718
    },
    {
        "content": "<p>yup, but it seems that the compiler cannot see that definitional equality</p>",
        "id": 533636245,
        "sender_full_name": "neil",
        "timestamp": 1754815732
    },
    {
        "content": "<p>huh?</p>",
        "id": 533636279,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754815745
    },
    {
        "content": "<p><code>rfl</code> works for me at that position</p>",
        "id": 533636296,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754815755
    },
    {
        "content": "<p>oh really? let me try that</p>",
        "id": 533636313,
        "sender_full_name": "neil",
        "timestamp": 1754815766
    },
    {
        "content": "<p>wow it does!</p>",
        "id": 533636344,
        "sender_full_name": "neil",
        "timestamp": 1754815779
    },
    {
        "content": "<p>it feels really weird that <code>rfl</code> succeeds where <code>simp</code> makes no progress</p>",
        "id": 533636376,
        "sender_full_name": "neil",
        "timestamp": 1754815807
    },
    {
        "content": "<p>Well, <code>simp</code> only unfolds <code>abbrev</code>s and other things tagged <code>reducible</code> but it's not for evaluation really</p>",
        "id": 533636420,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754815849
    },
    {
        "content": "<p>If you want it to unfold something, you need to tell it to</p>",
        "id": 533636444,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754815872
    },
    {
        "content": "<p>yeah, I figured as much but didn't realize <code>rfl</code> would actually be useful here. I have Rocq brain I guess</p>",
        "id": 533636450,
        "sender_full_name": "neil",
        "timestamp": 1754815882
    },
    {
        "content": "<p>Heh, well, I guess I have another question though</p>",
        "id": 533636476,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754815909
    },
    {
        "content": "<p>Why <code>Vector Bool</code>?</p>",
        "id": 533636479,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754815914
    },
    {
        "content": "<p>That's basically 64 bit per <code>Bool</code>?</p>",
        "id": 533636514,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754815945
    },
    {
        "content": "<p>I'm not really caring about the particulars of the representations at this point</p>",
        "id": 533636711,
        "sender_full_name": "neil",
        "timestamp": 1754816151
    },
    {
        "content": "<p>I'm also new enough to Lean that I haven't really bothered to learn the stdlib/built in types, cos I have some deadlines related to my PhD work, and I'd rather get more of the domain-relevant stuff done before then, then rewrite this to actually be efficient and choose good data structures. For now, I'm just trying to have a demonstrator with a rich enough type system that I can prove some theories about</p>",
        "id": 533636895,
        "sender_full_name": "neil",
        "timestamp": 1754816313
    },
    {
        "content": "<p>Hmm well still can you point me to a github (if you have one)</p>",
        "id": 533636921,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754816340
    },
    {
        "content": "<p>I have it private for now. Would you like me to add you?</p>",
        "id": 533637026,
        "sender_full_name": "neil",
        "timestamp": 1754816434
    },
    {
        "content": "<p>this repo being private, that is (it's in the same repo as a bunch of my PhD materials because that's what my advisors requested).</p>",
        "id": 533637064,
        "sender_full_name": "neil",
        "timestamp": 1754816464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/270676-lean4/topic/Elimination-by-exhaustion.20for.20Fin.20n.20.28really.2C.20UIntN.29/near/533636142\">said</a>:</p>\n<blockquote>\n<p>and well you usually evaluate using <code>rfl</code>; but I suppose your proof is more than just evaluation</p>\n</blockquote>\n<p>so, in Rocq there's <code>simp</code>, which just does evaluation, <code>reflexivity</code>, which does deeper evaluation and some rewriting and terminates the proof, and <code>auto</code>, which does proof search. Lean doesn't seem to have an equivalent for Rocq's <code>simp</code>, which is a shame because sometimes it's really helpful to just try to evaluate some terms when working through a proof without asserting that the proof should finish</p>",
        "id": 533637233,
        "sender_full_name": "neil",
        "timestamp": 1754816634
    },
    {
        "content": "<p>Just letting reduction run is usually a bad idea, it can cause performance issues and make it very difficult for you to refactor your code further down the line as your proofs are now bound to the precise reduction behavior of your definitions. For that reason you should prefer to build  up a simp or grind set of theorems that you can then let the automation apply.</p>",
        "id": 533637327,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1754816722
    },
    {
        "content": "<p>that is true!</p>",
        "id": 533637401,
        "sender_full_name": "neil",
        "timestamp": 1754816800
    },
    {
        "content": "<p>it would be nice if there /were/ some way to do it though, a la <code>eval!</code>, since these things can be useful when prototyping or developing new features (at least, in the sorts of smaller developments I tend to be working on)</p>",
        "id": 533637477,
        "sender_full_name": "neil",
        "timestamp": 1754816877
    },
    {
        "content": "<p><code>reduce</code> exists but you <em>should</em> only use it for prototyping (<code>import Mathlib.Tactic.DefEqTransformations</code>)</p>",
        "id": 533637570,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754816972
    },
    {
        "content": "<p>I do also find it interesting that a lot of this sort of functionality is in Mathlib instead of closer to the core of the language or base developer experience</p>",
        "id": 533637671,
        "sender_full_name": "neil",
        "timestamp": 1754817078
    },
    {
        "content": "<p>Well it's not really useful in complete proofs</p>",
        "id": 533638055,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754817467
    },
    {
        "content": "<p>and <code>#reduce</code> does something similar</p>",
        "id": 533638064,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754817480
    },
    {
        "content": "<p>(but as a command)</p>",
        "id": 533638078,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754817491
    },
    {
        "content": "<p>yeah, it's not useful in complete proofs, but, at least the way I got used to working in Rocq, it's useful in the development of proofs. I'm not yet in the habit of making sure my developments integrate nicely with automation--namely tagging thms appropriately and making sure they have consistent forms--but I assume that once that becomes natural, then my desire for these sorts of features will lessen</p>",
        "id": 533638434,
        "sender_full_name": "neil",
        "timestamp": 1754817858
    },
    {
        "content": "<p>ok Robin you were right:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">UInt8_roundtrip_ex_fin</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ofFin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">256</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">parseInt8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">serializeInt8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ofFin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">256</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- this times out lol</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">UInt8_roundtrip</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">256</span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ofFin</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">parseInt8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">serializeInt8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ofFin</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"n\">fin_cases</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 533639630,
        "sender_full_name": "neil",
        "timestamp": 1754819197
    },
    {
        "content": "<p>wait WOW it's got even stranger behavior: this somehow discharges 180 of the 256 goals, and of the remaining 76, you can check that they <em>should</em> be discharged by rfl by checking the individual value using the example definition above. </p>\n<p>I'm assuming this is related to it timing out, but producing really weird output as a result</p>",
        "id": 533639828,
        "sender_full_name": "neil",
        "timestamp": 1754819412
    },
    {
        "content": "<p>For these cases, <code>decide +revert</code> usually works better since it doesn't create new goals (instead of <code>fin_cases u &lt;;&gt; rfl</code>)</p>",
        "id": 533639862,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754819445
    },
    {
        "content": "<p>(and the proof term is tiny)</p>",
        "id": 533639870,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754819452
    },
    {
        "content": "<p>But it will probably still take forever (and throw maximum recursion depth reached)</p>",
        "id": 533639899,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754819478
    },
    {
        "content": "<p>it succeeds if I set maxHeartbeats to 500000 (from 200000)</p>",
        "id": 533639976,
        "sender_full_name": "neil",
        "timestamp": 1754819542
    },
    {
        "content": "<p>I see</p>",
        "id": 533640037,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754819609
    },
    {
        "content": "<p>so... why is this so slow? is it elaborating the 256 goals? Naively, I would expect this sort of thing to be pretty quick: a relatively small enumeration, producing relatively small terms (I guess you have triangle(256) constructors, but that still feels like not a very big number?), with a relatively quick tactic to discharge each goal</p>",
        "id": 533640114,
        "sender_full_name": "neil",
        "timestamp": 1754819695
    },
    {
        "content": "<p>also, Kenny, thanks for the solution, forgot to mention it earlier :)</p>",
        "id": 533640183,
        "sender_full_name": "neil",
        "timestamp": 1754819770
    },
    {
        "content": "<p>yeah you have 256 goals, what happens if you follow Robin's advice to use decide +revert?</p>",
        "id": 533640302,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754819881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/270676-lean4/topic/Elimination-by-exhaustion.20for.20Fin.20n.20.28really.2C.20UIntN.29/near/533639899\">said</a>:</p>\n<blockquote>\n<p>But it will probably still take forever (and throw maximum recursion depth reached)</p>\n</blockquote>\n<p><code>decide +revert</code> terminates pretty quickly with max recursion depth exceeded, I'm going to see if I can binary search to find the threshold where it passes (though I suppose the time is more interesting than the depth limit...)</p>",
        "id": 533640339,
        "sender_full_name": "neil",
        "timestamp": 1754819925
    },
    {
        "content": "<p>also, asides: <code>import Mathlib.Tactics</code> was adding 4s to my build time on its own somehow, plus one of my functions (<code>def segment</code>) collides with something in mathlib... are there comprehensive docs on the import system? I haven't really been able to find any in all my time using Lean.</p>",
        "id": 533640450,
        "sender_full_name": "neil",
        "timestamp": 1754820024
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931836\">neil</span> <a href=\"#narrow/channel/270676-lean4/topic/Elimination-by-exhaustion.20for.20Fin.20n.20.28really.2C.20UIntN.29/near/533639976\">said</a>:</p>\n<blockquote>\n<p>it succeeds if I set maxHeartbeats to 500000 (from 200000)</p>\n</blockquote>\n<p><code>fin_cases u &lt;;&gt; rfl</code> seems to take around 45s to build</p>",
        "id": 533640488,
        "sender_full_name": "neil",
        "timestamp": 1754820059
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">maxHeartbeats</span><span class=\"w\"> </span><span class=\"mi\">500000</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">maxRecDepth</span><span class=\"w\"> </span><span class=\"mi\">10000</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">UInt8_roundtrip</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">256</span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ofFin</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">parseInt8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">serializeInt8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ofFin</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"c1\">-- fin_cases u &lt;;&gt; rfl</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">revert</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>$<span class=\"w\"> </span><span class=\"nb\">time</span><span class=\"w\"> </span>lake<span class=\"w\"> </span>build\n...\nBuild<span class=\"w\"> </span>completed<span class=\"w\"> </span>successfully.\nlake<span class=\"w\"> </span>build<span class=\"w\">  </span><span class=\"m\">29</span>.43s<span class=\"w\"> </span>user<span class=\"w\"> </span><span class=\"m\">6</span>.26s<span class=\"w\"> </span>system<span class=\"w\"> </span><span class=\"m\">103</span>%<span class=\"w\"> </span>cpu<span class=\"w\"> </span><span class=\"m\">34</span>.593<span class=\"w\"> </span>total\n</code></pre></div>",
        "id": 533640686,
        "sender_full_name": "neil",
        "timestamp": 1754820236
    },
    {
        "content": "<p>so <code>decide +revert</code> seems to take about 2/3rds as long as <code>fin_cases</code>, though this is not a rigorous benchmarking because I... should actually go to sleep pretty soon</p>",
        "id": 533640742,
        "sender_full_name": "neil",
        "timestamp": 1754820298
    },
    {
        "content": "<p>(note also that <code>decide +revert</code> means that I can drop the dependency on Mathlib.Tactic, which brings the time down to 21s, but that's no longer a ceteris-paribus comparison)</p>",
        "id": 533640866,
        "sender_full_name": "neil",
        "timestamp": 1754820409
    },
    {
        "content": "<p>I'd recommend you to just use a simpler definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofFnLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n<span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">â‰¤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h'</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_of_le_of_ne</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">h'</span>\n<span class=\"w\">      </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"bp\">âŸ©</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">this</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">getElem_ofFnLE</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofFnLE</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">âŸ©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">â‰¤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">ofFnLE</span><span class=\"bp\">.</span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"bp\">âŸ©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">fun_induction</span><span class=\"w\"> </span><span class=\"n\">ofFnLE</span><span class=\"bp\">.</span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ofFnLE</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">parseInt8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">UInt8</span><span class=\"bp\">.</span><span class=\"n\">ofBitVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofFnLE</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">])</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">serializeInt8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">ofFn</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">parseInt16</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt16</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">UInt16</span><span class=\"bp\">.</span><span class=\"n\">ofBitVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofFnLE</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">])</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">serializeInt16</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt16</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">ofFn</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- ...</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">parseInt8_serializeInt8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">parseInt8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">serializeInt8</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"bp\">.</span><span class=\"n\">toBitVec_inj</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">parseInt8</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">serializeInt8</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">serializeInt8_parseInt8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">serializeInt8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">parseInt8</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">parseInt8</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">serializeInt8</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">parseInt16_serializeInt16</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt16</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">parseInt16</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">serializeInt16</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"n\">UInt16</span><span class=\"bp\">.</span><span class=\"n\">toBitVec_inj</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">parseInt16</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">serializeInt16</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">serializeInt16_parseInt16</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">serializeInt16</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">parseInt16</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">parseInt16</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">serializeInt16</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- ...</span>\n</code></pre></div>",
        "id": 533641101,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754820628
    },
    {
        "content": "<p>you're suggesting that the perf bottleneck is in the <code>rfl</code> steps, then?</p>",
        "id": 533641278,
        "sender_full_name": "neil",
        "timestamp": 1754820828
    },
    {
        "content": "<p>oh wait</p>",
        "id": 533641284,
        "sender_full_name": "neil",
        "timestamp": 1754820837
    },
    {
        "content": "<p>I mean, yeah, but for the moment I was mostly just interested in how to even approach a proof-by-exhaustion for these sorts of inductive, rather than enumerated, types in Lean</p>",
        "id": 533641323,
        "sender_full_name": "neil",
        "timestamp": 1754820886
    },
    {
        "content": "<p>the enumeration is the Fintype</p>",
        "id": 533641715,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754821326
    },
    {
        "content": "<p>the lean philosophy is that you shouldn't rely too much on the unique \"underlying\" definition</p>",
        "id": 533641728,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754821337
    },
    {
        "content": "<p>fin_cases relies on Fintype</p>",
        "id": 533641736,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754821350
    },
    {
        "content": "<p>decide +revert is also Fintype</p>",
        "id": 533641739,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754821360
    },
    {
        "content": "<p>Well, there is also a special instance <code>decide</code> uses to make <code>forall _ : Fin n</code> not rely on Fintype</p>",
        "id": 533641781,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754821415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/270676-lean4/topic/Elimination-by-exhaustion.20for.20Fin.20n.20.28really.2C.20UIntN.29/near/533641728\">said</a>:</p>\n<blockquote>\n<p>the lean philosophy is that you shouldn't rely too much on the unique \"underlying\" definition</p>\n</blockquote>\n<p>I mean, you're relying on the unique properties of the underlying definitions somehow: either that the de-/serialization functions are easy to prove things about algebraically, or that the types they range over are \"easy\" to work over exhaustively, where \"easy\" in the former refers to \"difficulty to produce a proof\" and in the latter means \"performance\"</p>",
        "id": 533641877,
        "sender_full_name": "neil",
        "timestamp": 1754821505
    },
    {
        "content": "<p>also, just for fun, I \"manually\" elaborated this exercise into 256 separate statements, and that seems to be a hair quicker, but not anything really significant (35s using rfl, 40s using decide +revert, though presumably the +revert is now superfluous)</p>",
        "id": 533642029,
        "sender_full_name": "neil",
        "timestamp": 1754821638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931836\">neil</span> <a href=\"#narrow/channel/270676-lean4/topic/Elimination-by-exhaustion.20for.20Fin.20n.20.28really.2C.20UIntN.29/near/533641323\">said</a>:</p>\n<blockquote>\n<p>I mean, yeah, but for the moment I was mostly just interested in how to even approach a proof-by-exhaustion for these sorts of inductive, rather than enumerated, types in Lean</p>\n</blockquote>\n<p>and what this has taught me is that it seems like I should anticipate that I will be proving things algebraically, so the particulars of the function definitions matter.</p>",
        "id": 533642098,
        "sender_full_name": "neil",
        "timestamp": 1754821694
    },
    {
        "content": "<p>thanks for all the info, you guys :)</p>",
        "id": 533642501,
        "sender_full_name": "neil",
        "timestamp": 1754822087
    },
    {
        "content": "<p>The Lean philosophy is basically what you see with my <code>ofFnLE</code> example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofFnLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n<span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">â‰¤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h'</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_of_le_of_ne</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">h'</span>\n<span class=\"w\">      </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"bp\">âŸ©</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">this</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">getElem_ofFnLE</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofFnLE</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">âŸ©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">â‰¤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">ofFnLE</span><span class=\"bp\">.</span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"bp\">âŸ©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">fun_induction</span><span class=\"w\"> </span><span class=\"n\">ofFnLE</span><span class=\"bp\">.</span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ofFnLE</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Basically: First write a definition and then write enough characterizing lemmas that you don't need to rely on the definition afterwards.</p>",
        "id": 533642934,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754822538
    },
    {
        "content": "<p>If you only want one lemma (<code>deserialize_serialize</code> for every encoding/decoding function) this might not be as important though</p>",
        "id": 533643254,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754822916
    },
    {
        "content": "<p>Sounds like <code>fin_cases</code> could help here, maybe try it on <code>Fin 256</code> and check roundtrip equality. Could also explore faster term evaluation than <code>simp</code>.</p>\n<p>You might find more approaches like this on LeanFinder (<a href=\"http://www.leanfinder.org/\">www.leanfinder.org</a>).</p>",
        "id": 533847157,
        "sender_full_name": "Wuyang",
        "timestamp": 1754937393
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 533847184,
        "sender_full_name": "Wuyang",
        "timestamp": 1754937410
    },
    {
        "content": "<p>Failure! Bot is unavailable</p>",
        "id": 533847226,
        "sender_full_name": "leanfinder",
        "timestamp": 1754937431
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"946339\">@leanfinder</span> Lean proof by exhaustion for UInt8 or Fin types to verify serialize-deserialize roundtrip equality</p>",
        "id": 533847315,
        "sender_full_name": "Wuyang",
        "timestamp": 1754937469
    },
    {
        "content": "<p>Hereâ€™s what I found:</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt8.val_injective#doc\">theorem UInt8.val_injective : Function.Injective val run_cmd</a> \"The function <code>val : UInt8 â†’ â„•</code> that extracts the underlying natural number from an unsigned 8-bit integer is injective. That is, for any two unsigned 8-bit integers <code>x</code> and <code>y</code>, if <code>val x = val y</code>, then <code>x = y</code>.\"  (score: 0.697)</li>\n<li>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt8.ext#doc\">theorem UInt8.ext : {x y : UInt8} â†’ x.toNat = y.toNat â†’ x = y\n  | âŸ¨âŸ¨_,_âŸ©âŸ©, âŸ¨âŸ¨_,_âŸ©âŸ©, rfl =&gt; rfl</a> \"For unsigned 8-bit integers <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span>, if their natural number representations are equal, i.e., <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mi mathvariant=\"normal\">.</mi><mtext>toNat</mtext><mo>=</mo><mi>y</mi><mi mathvariant=\"normal\">.</mi><mtext>toNat</mtext></mrow><annotation encoding=\"application/x-tex\">x.\\text{toNat} = y.\\text{toNat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord text\"><span class=\"mord\">toNat</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord\">.</span><span class=\"mord text\"><span class=\"mord\">toNat</span></span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> are equal as unsigned 8-bit integers.\"  (score: 0.680)</p>\n</li>\n<li>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ByteArray.getElem_ofFn#doc\">theorem getElem_ofFn (f : Fin n â†’ UInt8) (i) (h : i &lt; (ofFn f).size) :\n    (ofFn f)[i] = f âŸ¨i, size_ofFn f â–¸ hâŸ© := get_ofFn f âŸ¨i, hâŸ©</a> \"For a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width=\"0.1111em\"/><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext>â€‰â£</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333em\"/><mrow><mi mathvariant=\"normal\">F</mi><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">n</mi></mrow><mtext>â€‰</mtext><mi>n</mi><mo>â†’</mo><mrow><mi mathvariant=\"normal\">U</mi><mi mathvariant=\"normal\">I</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">t</mi><mn>8</mn></mrow></mrow><annotation encoding=\"application/x-tex\">f \\colon \\mathrm{Fin}\\,n \\to \\mathrm{UInt8}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Fin</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">UInt8</span></span></span></span></span> and an index <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">f</mi><mi mathvariant=\"normal\">F</mi><mi mathvariant=\"normal\">n</mi></mrow><mtext>â€‰</mtext><mi>f</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mrow><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">z</mi><mi mathvariant=\"normal\">e</mi></mrow></mrow><annotation encoding=\"application/x-tex\">i &lt; (\\mathrm{ofFn}\\,f).\\mathrm{size}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">ofFn</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord mathrm\">size</span></span></span></span></span>, the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>-th element of the ByteArray constructed from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> via <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">f</mi><mi mathvariant=\"normal\">F</mi><mi mathvariant=\"normal\">n</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{ofFn}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">ofFn</span></span></span></span></span> is equal to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span>.</p>\n</li>\n</ul>\n<p>In symbols:<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">f</mi><mi mathvariant=\"normal\">F</mi><mi mathvariant=\"normal\">n</mi></mrow><mtext>â€‰</mtext><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">âŸ¨</mo><mi>i</mi><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">z</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">_</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">f</mi><mi mathvariant=\"normal\">F</mi><mi mathvariant=\"normal\">n</mi></mrow><mtext>â€‰</mtext><mi>f</mi><mo lspace=\"0.22em\" rspace=\"0.22em\">âˆ™</mo><mi>h</mi><mo stretchy=\"false\">âŸ©</mo><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">(\\mathrm{ofFn}\\,f)[i] = f(\\langle i, \\mathrm{size\\_ofFn}\\,f \\mathbin{\\bullet} h \\rangle).</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">ofFn</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.06em;vertical-align:-0.31em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(âŸ¨</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">size_ofFn</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mord\">âˆ™</span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">âŸ©)</span><span class=\"mord\">.</span></span></span></span>\"  (score: 0.676)</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt8.natCast_def#doc\">theorem UInt8.natCast_def (n : â„•) : (n : UInt8) = âŸ¨nâŸ© run_cmd</a> \"For any natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, the canonical cast of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> to an 8-bit unsigned integer is equal to the truncation of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> modulo 256, i.e., <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>:</mo><mtext>UInt8</mtext><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">âŸ¨</mo><mi>n</mi><mo stretchy=\"false\">âŸ©</mo></mrow><annotation encoding=\"application/x-tex\">(n : \\text{UInt8}) = \\langle n \\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">UInt8</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">âŸ¨</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">âŸ©</span></span></span></span>.\"  (score: 0.674)</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ByteArray.get_ofFn#doc\">theorem get_ofFn (f : Fin n â†’ UInt8) (i : Fin (ofFn f).size) :\n    (ofFn f).get i = f (i.cast (size_ofFn f)) := by\n  simp [get, Fin.cast]</a> \"For a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width=\"0.1111em\"/><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext>â€‰â£</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333em\"/><mrow><mi mathvariant=\"normal\">F</mi><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">n</mi></mrow><mtext>â€‰</mtext><mi>n</mi><mo>â†’</mo><mrow><mi mathvariant=\"normal\">U</mi><mi mathvariant=\"normal\">I</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">t</mi><mn>8</mn></mrow></mrow><annotation encoding=\"application/x-tex\">f \\colon \\mathrm{Fin}\\,n \\to \\mathrm{UInt8}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Fin</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">UInt8</span></span></span></span></span> and an index <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>âˆˆ</mo><mrow><mi mathvariant=\"normal\">F</mi><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">n</mi></mrow><mtext>â€‰</mtext><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">f</mi><mi mathvariant=\"normal\">F</mi><mi mathvariant=\"normal\">n</mi></mrow><mtext>â€‰</mtext><mi>f</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mrow><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">z</mi><mi mathvariant=\"normal\">e</mi></mrow></mrow><annotation encoding=\"application/x-tex\">i \\in \\mathrm{Fin}\\,(\\mathrm{ofFn}\\,f).\\mathrm{size}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">âˆˆ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Fin</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">ofFn</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord mathrm\">size</span></span></span></span></span>, the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>-th element of the ByteArray constructed from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> via <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">f</mi><mi mathvariant=\"normal\">F</mi><mi mathvariant=\"normal\">n</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{ofFn}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">ofFn</span></span></span></span></span> is equal to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span>, considering the appropriate casting of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>.</li>\n</ul>\n<p>In symbols:<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">f</mi><mi mathvariant=\"normal\">F</mi><mi mathvariant=\"normal\">n</mi></mrow><mtext>â€‰</mtext><mi>f</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mrow><mi mathvariant=\"normal\">g</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">t</mi></mrow><mtext>â€‰</mtext><mi>i</mi><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mi mathvariant=\"normal\">.</mi><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">t</mi></mrow><mtext>â€‰</mtext><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">z</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">_</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">f</mi><mi mathvariant=\"normal\">F</mi><mi mathvariant=\"normal\">n</mi></mrow><mtext>â€‰</mtext><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">(\\mathrm{ofFn}\\,f).\\mathrm{get}\\,i = f(i.\\mathrm{cast}\\,(\\mathrm{size\\_ofFn}\\,f)).</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">ofFn</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord mathrm\">get</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.06em;vertical-align:-0.31em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord mathrm\">cast</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">size_ofFn</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">))</span><span class=\"mord\">.</span></span></span></span>\"  (score: 0.673)</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt8.ext_iff#doc\">theorem UInt8.ext_iff {x y : UInt8} : x = y â†” x.toNat = y.toNat := âŸ¨congrArg _, UInt8.extâŸ©</a> \"For unsigned 8-bit integers <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x = y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> if and only if their natural number representations are equal, i.e., <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mi mathvariant=\"normal\">.</mi><mtext>toNat</mtext><mo>=</mo><mi>y</mi><mi mathvariant=\"normal\">.</mi><mtext>toNat</mtext></mrow><annotation encoding=\"application/x-tex\">x.\\text{toNat} = y.\\text{toNat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord text\"><span class=\"mord\">toNat</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord\">.</span><span class=\"mord text\"><span class=\"mord\">toNat</span></span></span></span></span>. This establishes that equality of UInt8 values can be determined by comparing their corresponding natural numbers.\"  (score: 0.672)</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt8.val_val_eq_toNat#doc\">theorem UInt8.val_val_eq_toNat (x : UInt8) : x.val.val = x.toNat := rfl</a> \"For any unsigned 8-bit integer <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>, the value obtained by converting <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> to a natural number using <code>x.toNat</code> is equal to the value obtained by accessing its internal representation as a natural number, i.e., <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mi mathvariant=\"normal\">.</mi><mtext>val.val</mtext><mo>=</mo><mi>x</mi><mi mathvariant=\"normal\">.</mi><mtext>toNat</mtext></mrow><annotation encoding=\"application/x-tex\">x.\\text{val.val} = x.\\text{toNat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord text\"><span class=\"mord\">val.val</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord text\"><span class=\"mord\">toNat</span></span></span></span></span>.\"  (score: 0.672)</li>\n<li>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ByteArray.data_ofFn#doc\">theorem data_ofFn (f : Fin n â†’ UInt8) : (ofFn f).data = .ofFn f := by\n  induction n with\n  | zero =&gt; rfl\n  | succ n ih =&gt; simp [ofFn_succ, Array.ofFn_succ, ih, Fin.last]</a> \"For a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mtext>Fin</mtext><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>â†’</mo><mtext>UInt8</mtext></mrow><annotation encoding=\"application/x-tex\">f : \\text{Fin}(n) \\to \\text{UInt8}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">Fin</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord\">UInt8</span></span></span></span></span>, the data of the byte array constructed using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>ofFn</mtext><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{ofFn}(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">ofFn</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span> is the same as constructing the data directly from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>. In symbols: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>(ofFn</mtext><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mtext>).data</mtext><mo>=</mo><mtext>ofFn</mtext><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{(ofFn}(f)\\text{).data} = \\text{ofFn}(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">(ofFn</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mord text\"><span class=\"mord\">).data</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">ofFn</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span>. This is proved by induction on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>.\"  (score: 0.670)</p>\n</li>\n<li>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt8.val_ofNat#doc\">theorem UInt8.val_ofNat (n) :\n    (no_index (OfNat.ofNat n) : UInt8).val = OfNat.ofNat n := rfl</a> \"For any natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, the value of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> when interpreted as an 8-bit unsigned integer (UInt8) is equal to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> itself, i.e., <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>UInt8</mtext><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mtext>val</mtext><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\text{UInt8}(n).\\text{val} = n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">UInt8</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord text\"><span class=\"mord\">val</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>. This holds because the conversion does not alter the value within the range of UInt8.\"  (score: 0.668)</p>\n</li>\n<li>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt8.toChar#doc\">definition UInt8.toChar (n : UInt8) : Char := âŸ¨n.toUInt32, .inl (Nat.lt_trans n.toBitVec.isLt (by decide))âŸ©</a> \"The function converts an unsigned 8-bit integer <code>n</code> to a Unicode character, provided that <code>n</code> represents a valid UTF-8 code point (which is always true for values between 0 and 255 inclusive).\"  (score: 0.667)</p>\n</li>\n</ul>",
        "id": 533847319,
        "sender_full_name": "leanfinder",
        "timestamp": 1754937471
    },
    {
        "content": "<p>try <code>decide +revert +kernel</code></p>",
        "id": 533847339,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754937481
    },
    {
        "content": "<p>the <code>+kernel</code> makes it faster to succeed but slower to fail</p>",
        "id": 533847384,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754937502
    },
    {
        "content": "<p>I think you also won't have to bump the rec depth</p>",
        "id": 533847515,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754937565
    },
    {
        "content": "<p>I've noticed that a few fold-like functions are no longer tail recursive with the new compiler. Did you check with v4.21.0?</p>",
        "id": 533994721,
        "sender_full_name": "FranÃ§ois G. Dorais",
        "timestamp": 1755009078
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">FranÃ§ois G. Dorais</span> <a href=\"#narrow/channel/270676-lean4/topic/Elimination-by-exhaustion.20for.20Fin.20n.20.28really.2C.20UIntN.29/near/533994721\">said</a>:</p>\n<blockquote>\n<p>I've noticed that a few fold-like functions are no longer tail recursive with the new compiler. Did you check with v4.21.0?</p>\n</blockquote>\n<p>I bumped to 4.22.0-rc4 because I added mathlib as a dependency (and presumably that's what the latest mathlib requires). I may try reverting the lean version since I can just use <code>decide +revert</code>, which doesn't require anything from mathlib.</p>",
        "id": 534145324,
        "sender_full_name": "neil",
        "timestamp": 1755057555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/270676-lean4/topic/Elimination-by-exhaustion.20for.20Fin.20n.20.28really.2C.20UIntN.29/near/533847384\">said</a>:</p>\n<blockquote>\n<p>the <code>+kernel</code> makes it faster to succeed but slower to fail</p>\n</blockquote>\n<p>oh yeah, WAY faster (about 10s) and doesn't require bumping either heartbeats or recursion depth</p>",
        "id": 534147806,
        "sender_full_name": "neil",
        "timestamp": 1755057663
    },
    {
        "content": "<p>I suppose I should just be using Shift-K (open documentation) on everything suggested. <code>kernel</code> seems like what I wanted: I know that this will succeed, and I don't need any elaboration</p>",
        "id": 534149469,
        "sender_full_name": "neil",
        "timestamp": 1755057731
    },
    {
        "content": "<p>using <code>+native</code> gets it down to 5s, which is much closer to my expectations, and fine for now. Thanks again, Aaron!</p>",
        "id": 534150971,
        "sender_full_name": "neil",
        "timestamp": 1755057795
    },
    {
        "content": "<p>so I've settled on </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">UInt8_roundtrip</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">parseInt8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">serializeInt8</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"c1\">-- unwrap the UInt8 into its BitVec8 and then into its Fin 256, which has a</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Decidable instance.</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨âŸ¨</span><span class=\"n\">fin</span><span class=\"bp\">âŸ©âŸ©</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">revert</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">native</span>\n</code></pre></div>\n<p>which is the overall result that I needed. And it runs in 5s, so I have no problem leaving it in there like this, and I can just swap <code>+native</code> for <code>+kernel</code> if I want to trust less code. </p>\n<p>Thanks everyone!</p>",
        "id": 534155592,
        "sender_full_name": "neil",
        "timestamp": 1755059357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931836\">neil</span> <a href=\"#narrow/channel/270676-lean4/topic/Elimination-by-exhaustion.20for.20Fin.20n.20.28really.2C.20UIntN.29/near/534150971\">said</a>:</p>\n<blockquote>\n<p>using <code>+native</code> gets it down to 5s, which is much closer to my expectations, and fine for now. Thanks again, Aaron!</p>\n</blockquote>\n<p>it is not recommended to use +native</p>",
        "id": 534171276,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755069496
    },
    {
        "content": "<p><code>+native</code> adds a dependency on the (somewhat unsound) axiom <code>Lean.trustCompiler</code> (i.e. no, you can't trust the compiler all the time lol)</p>",
        "id": 535190833,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1755631705
    },
    {
        "content": "<p>yeah, I'm just using +native to keep my builds a bit snappier, since lean doesn't have partial compilation, right?<br>\nI might also make some sort of wrapper tactic that switches between native/kernel depending on the build environment: kernel for CI, native for local.</p>\n<p>also, as a side note, and not something I bothered to actually test: it seemed that I got a considerable speedup when I pulled this theorem into a smaller file, from the relatively large file it was originally in (something like 3-500 lines, I would guess). So is there some sort of relationship between the size of individual files or modules and compile times, even if the code itself is otherwise identical?</p>",
        "id": 536343309,
        "sender_full_name": "neil",
        "timestamp": 1756267009
    }
]