[
    {
        "content": "<p>Hi! I am trying to introduce a notation which partially overlaps with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mspace></mspace><mspace width=\"0.4444em\"/><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mspace width=\"0.3333em\"/><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\pmod N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0em;\"></span><span class=\"mspace allowbreak\"></span><span class=\"mspace\" style=\"margin-right:0.4444em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">mod</span></span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> notation from mathlib. It works in one variant, and not in another. Does anybody understand why this is happening?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.Nat.ModEq</span>\n\n<span class=\"k\">#check</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">â‰¡</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MOD</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- 1 â‰¡ 5 [MOD 4] : Prop</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"s2\">\" â‰¡ \"</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"s2\">\" [AMOD \"</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"s2\">\"]\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">N</span>\n<span class=\"k\">#check</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">â‰¡</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AMOD</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- 3 : â„•</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"s2\">\" âˆ£ \"</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"s2\">\" â‰¡ \"</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"s2\">\" [BMOD \"</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"s2\">\"]\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">N</span>\n<span class=\"k\">#check</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">âˆ£</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">â‰¡</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BMOD</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- unexpected token '[BMOD'; expected '[AMOD' or '[MOD'</span>\n</code></pre></div>",
        "id": 468274737,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1725651418
    },
    {
        "content": "<p>You'll probably want to increase the precedence of <code>a</code> so that it doesn't capture all of <code>1 | 2</code> as a single term</p>",
        "id": 468278841,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1725652594
    },
    {
        "content": "<p>I used a Unicode <code>âˆ£</code> to avoid clashing with <code>|</code>. Increasing the precedence does not seem to change anything.</p>",
        "id": 468495478,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1725760240
    },
    {
        "content": "<p>Here's the incantation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">notation</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"mi\">51</span><span class=\"w\"> </span><span class=\"s2\">\" âˆ£ \"</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"mi\">51</span><span class=\"w\"> </span><span class=\"s2\">\" â‰¡ \"</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"s2\">\" [BMOD \"</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"s2\">\"]\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">N</span>\n</code></pre></div>\n<p>You have to match the precedences that the <code>infix</code> command sets for the <code> âˆ£ </code> operator</p>",
        "id": 468495878,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725760562
    },
    {
        "content": "<p>Thank you! Are you sure this is about the precedence of the <code>âˆ£</code> operator? Using a symbol which is certainly not an infix operator fails in the same way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"s2\">\" âœ¨ \"</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"s2\">\" â‰¡ \"</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"s2\">\" [BMOD \"</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"s2\">\"]\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">N</span>\n<span class=\"k\">#check</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">âœ¨</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">â‰¡</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BMOD</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- unexpected token '[BMOD'; expected '[AMOD' or '[MOD'</span>\n</code></pre></div>\n<p>but with <code>notation:50 a \" âœ¨ \" b:51 \" â‰¡ \" c \" [BMOD \" N \"]\" =&gt; N</code>, it works. So I am led to conclude that without the extra precedence, it is being parsed as <code>1 âœ¨ (2 â‰¡ 3 [BMOD 4])</code>. The <code>â‰¡</code> mod notations from mathlib also have precedence 50.</p>",
        "id": 469242872,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1726016411
    },
    {
        "content": "<p>I think you're right, <code>b</code>'s precedence is the one that matters</p>",
        "id": 469345932,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1726048254
    },
    {
        "content": "<p>Is there anything I could read to better understand the Pratt parsing rules of Lean? <a href=\"https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html\">This article</a> is nice but it doesn't account for the feature of \"output precedences\" <code>syntax:$prec</code> that Lean has.</p>",
        "id": 469458511,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1726072595
    },
    {
        "content": "<p>The new manual is in progress but does <a href=\"https://lean-lang.org/lean4/doc/notation.html\">this</a> help in the meantime? I wouldn't think about it on the Pratt algorithm level but as a combination of the placeholder and longest parse rules mentioned there</p>",
        "id": 469459521,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1726072757
    },
    {
        "content": "<p>Ahh, not really. \"Local longest parse\" isn't precise enough for me to predict or understand what would happen in situations like the one above. I mean, <code>1 âˆ£ 2 â‰¡ 3 [BMOD 4]</code> is a longer parse than <code>1 âˆ£ (2 â‰¡ 3 &lt;error&gt;)</code>, I think? But maybe the \"local\" part implies that once we start parsing the nested <code>b:term</code> and see something that _could_ be <code>2 â‰¡ 3 [MOD ..</code>, we'll commit to that and hence the error occurs? Overall, a precise description would be preferable (but I understand it's not super high priority to explain the weeds).</p>",
        "id": 469524022,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1726098392
    }
]