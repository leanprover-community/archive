[
    {
        "content": "<p>Here's an easy proof that if <code>a b c n</code> are natural numbers with <code>0 &lt; a</code> and <code>0 &lt; b</code> and <code>2 &lt; n</code>, then <code>a ^ n + b ^ n ≠ c ^ n</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pow</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pow</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pow_eq_one</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>This is, of course, cheating: I've redefined <code>a ^ n</code> to be <code>1</code>, thus making the theorem trivial. However, the cheating would be much more difficult to detect in a long file with more separation between the <code>Pow Nat</code> instance and the theorem statement. I could even imagine doing something like this accidentally.</p>\n<p>It is worth noting that I cannot use the same method to prove the following much more difficult theorem, because <code>Nat.pow a n</code>, unlike <code>a ^ n</code>, can't be redefined.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pow</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pow</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pow</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Is there any automatic way to prevent such deceitful and underhanded proof strategies?</p>",
        "id": 491467282,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1735704305
    },
    {
        "content": "<p>If in the same library you have a proof that there are infinite positive a b c such that a^2 + b^2 = c^2, one could trust it a little bit more (unless your adversarial Pow instance does the right thing for an exponent of 2 and the evil thing for other exponents).</p>",
        "id": 491468944,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1735706133
    },
    {
        "content": "<p>If you override the <code>OfNat Nat</code> instance you can prove some silly (or just silly-looking) things:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"c1\">-- a million lines of code later:</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 491469450,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1735706681
    },
    {
        "content": "<p>Wow, that is silly indeed.</p>\n<p>This exploit is, of course, related to the well-known and unsolvable issue with proof assistants that they do not check whether the terms in the theorem statement are defined correctly. However, it is different from proving a theorem by not having the right definition. <code>a ^ n</code> is defined correctly; the problem is that it is also defined incorrectly.</p>\n<p>There is already one way around this, which is to use <code>set_option trace.Meta.synthInstance true</code>in important theorems to verify that none of the instances are unreasonable. However, it would be nice if there was an easier way, because it can be difficult to actually find the instance declarations.</p>\n<p>To be clear, I don't think this is a huge problem and I would totally understand if the answer was \"there is nothing much that can be done about this\", but I thought I would bring it up in case someone can, in fact, think of something that can be done about it.</p>",
        "id": 491471513,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1735708501
    },
    {
        "content": "<p>Not much more than \"prove things about your definition\" - for example that <code>2 ^ 2</code> is 4 rather than 1</p>",
        "id": 491483984,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1735722057
    },
    {
        "content": "<p>For FLT one could just prove the Peano axioms (<code>succ_ne_zero</code> etc) defining facts about + (<code>add_zero</code>, <code>add_succ</code>) and ^ and &lt;= and 3 (<code>three_eq_succ_succ_succ_zero</code>) and <code>\\ne</code> and <code>\\not</code> and you should be fine</p>",
        "id": 491490998,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1735729109
    },
    {
        "content": "<p>You could still redefine pow after proving stuff about it</p>",
        "id": 491495199,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1735733328
    },
    {
        "content": "<p>My question and worry is about how stuff like this interact with LLMs.  If an LLM dumps a gargantuan, inscrutable proof of a crucial result and verifiers verify it, how can we be reasonably confident that the LLM has not sneaked in a trick like the above?  And if this proof is part of a self training loop, how can we avoid such a result within the billions of iterations (which could cascade into training an expert scammer)?</p>\n<p>It seems that either we must require that the network \"does not cheat\" by limiting a priori the kind of output it generates, or we must build a cheat-resistant verifier.  The former seems to me impossible, but I am far from an expert.</p>",
        "id": 491496663,
        "sender_full_name": "Number Eighteen",
        "timestamp": 1735734725
    },
    {
        "content": "<p>You can define the conclusion outside of the purported proof (see e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FermatLastTheorem#doc\">docs#FermatLastTheorem</a>), so it won't be affected by the bad instance and then verify the proof produces a term of that type</p>",
        "id": 491498049,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1735736213
    },
    {
        "content": "<p>Note that you need to make sure you get the imports right. If you import the purported proof into the file that defines <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FermatLastTheorem#doc\">docs#FermatLastTheorem</a>, then that statement might change its meaning.<br>\nSo you have to import the statement into the file that has the proof. (Or import both in a new file.)</p>",
        "id": 491585243,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1735810965
    }
]