[
    {
        "content": "<p>For a linter that I'm trying to implement, I would like to parse the names that come after <code>definition</code> or <code>theorem</code> (or <code>lemma</code>) For instances here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"n\">definition</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>I want to extract <code>foo</code> and <code>bar</code>.</p>\n<p>I think what I need is a function that  with of the following type,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getNames</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Syntax</span>\n</code></pre></div>\n<p>so I probably want to match on <code>| stx@(.node info kind args) =&gt;</code>, but I don't quite know how to detect if we are in a definition/lemma/theorem from then (and also how to get access to the name after that).</p>",
        "id": 475786634,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1728461470
    },
    {
        "content": "<p>I think this question is not too difficult. I'm pretty sure <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> knows; if not, I'll try to take a look in the next hours (have to go now, but should be able to get back to this before lunch).</p>",
        "id": 475786911,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1728461532
    },
    {
        "content": "<p>It depends a little on how \"robust\" you want this to be.  The \"name\" of a theorem has a very special SyntaxNodeKind that is a <code>declId</code> (and is the name with possibly a universe level specification as in <code>lift_univ.{u, v}</code>).</p>",
        "id": 475802477,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728464871
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Parser</span><span class=\"w\"> </span><span class=\"n\">Command</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"getName \"</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">:</span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"n\">cmd</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``declId</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">nm</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"The name is '{nm}'.\"</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"No given name.\"</span>\n\n<span class=\"sd\">/-- info: The name is 'X'. -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"n\">getName</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"sd\">/-- info: The name is 'X1'. -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"n\">getName</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">X1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n\n<span class=\"sd\">/-- info: No given name. -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"n\">getName</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n</code></pre></div>",
        "id": 475803605,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728465216
    },
    {
        "content": "<p>Directly matching on the declaration is a little bit tricky since there are some moving parts and your match would have to take into account at least a few variations.</p>",
        "id": 475803823,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728465278
    },
    {
        "content": "<p>Do you want to extrant names generated by <code>to_additive</code> too?</p>",
        "id": 475804125,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728465372
    },
    {
        "content": "<p>If so you probably want to consult the environment, not just the syntax</p>",
        "id": 475804178,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728465388
    },
    {
        "content": "<p>For now, I don't care about the <code>to_additive</code> names, so no probably need to look into the environment yet...</p>",
        "id": 475805564,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1728465829
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>, <code>declID</code> was just what I was looking for</p>",
        "id": 475805682,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1728465859
    },
    {
        "content": "<p>Let me then also mention another way in which this is brittle: there is no information about the \"actual\" final name in the above.  Namespaces,<code>_root_</code> and whatever other consideration is ignored.</p>",
        "id": 475805793,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728465894
    },
    {
        "content": "<p>I could not find exactly what you want in core, but you can look around <a href=\"https://github.com/leanprover/lean4/blob/01d414ac36dc28f3e424dabd36d818873fea655c/src/Lean/Elab/Declaration.lean#L59\">docs#Lean.Elab.Command.getDefName?</a> (a private declaration in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Elab/Declaration.html#Lean.Elab.Command.elabAxiom\">file#Lean.Elab.Command</a>).</p>",
        "id": 475813206,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728467785
    },
    {
        "content": "<p>Here's what I needed this for. Instead of just fixing the (presumably) unintentional double underscore here:  <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FirstOrder.Language.PartialEquiv.toEmbeddingOfEqTop__apply#doc\">docs#FirstOrder.Language.PartialEquiv.toEmbeddingOfEqTop__apply</a><br>\nI added a (extendable) linter: <a href=\"https://github.com/leanprover-community/mathlib4/pull/17580\">#17580</a>, feedback/reviews welcome. <br>\nStill wip, because </p>\n<ol>\n<li>\n<p>I also plan to depecrecate <code>toEmbeddingOfEqTop__apply</code> and replace it with <code>oEmbeddingOfEqTop_apply</code> in the pull request, but I wanted to wait and see if the CI triggers on this linter.</p>\n</li>\n<li>\n<p>apparently importing  <code>Batteries.Data.String.Matcher</code> is perhaps not the best idea...</p>\n</li>\n</ol>",
        "id": 475847779,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1728477078
    },
    {
        "content": "<p>ci failed sucessfully: <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/11254853203/job/31293151730?pr=17580\">https://github.com/leanprover-community/mathlib4/actions/runs/11254853203/job/31293151730?pr=17580</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Some</span><span class=\"w\"> </span><span class=\"n\">required</span><span class=\"w\"> </span><span class=\"n\">builds</span><span class=\"w\"> </span><span class=\"n\">logged</span><span class=\"w\"> </span><span class=\"n\">failures</span><span class=\"o\">:</span>\n<span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">ModelTheory</span><span class=\"bp\">.</span><span class=\"n\">PartialEquiv</span>\n</code></pre></div>\n<p>so this works as intended. pushed the deprecation, 1. is fixed. Not sure about \"2.\"</p>",
        "id": 475865351,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1728480934
    },
    {
        "content": "<p>I think this linter should be checking the environment not the syntax</p>",
        "id": 475869924,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728482165
    },
    {
        "content": "<p>How does the <code>linter.dupNamespace</code> linter handle it?</p>",
        "id": 475870119,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728482224
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- `getIds stx` extracts the `declId` nodes from the `Syntax` `stx`.</span>\n<span class=\"sd\">If `stx` is an `alias` or an `export`, then it extracts an `ident`, instead of a `declId`. -/</span>\n<span class=\"n\">partial</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getIds</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Syntax</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"ss\">`Batteries.Tactic.Alias.alias</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"mi\">3</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"ss\">``Lean.Parser.Command.export</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"mi\">4</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"n\">args</span><span class=\"bp\">.</span><span class=\"n\">attach</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">getIds</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">stx</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">getKind</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"ss\">``declId</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">default</span>\n</code></pre></div>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/9b43951ca72df001cffd7fbab1023a00282824ef/Mathlib/Tactic/Linter/Lint.lean#L80-L88\">https://github.com/leanprover-community/mathlib4/blob/9b43951ca72df001cffd7fbab1023a00282824ef/Mathlib/Tactic/Linter/Lint.lean#L80-L88</a></p>",
        "id": 475873122,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1728482745
    },
    {
        "content": "<p>so I suppose <code>linter.dupNamespace</code> does not check the environment then?</p>",
        "id": 475951153,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1728505789
    },
    {
        "content": "<p>The duplicated namespace linter was initially an environment linter and checked \"all\" declarations, but did not give live feedback.</p>",
        "id": 475951541,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728505917
    },
    {
        "content": "<p>I wrote the syntax linter to get live, although incomplete, feedback and the syntax linter completely replaced the environment linter, even with its short-comings.</p>",
        "id": 475951782,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728505962
    },
    {
        "content": "<p>If I remember correctly, I also have a test showing that if the <code>to_additive</code> name of a declaration has a duplicated namespace, the linter ignores it.</p>",
        "id": 475951903,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728505991
    },
    {
        "content": "<p>I have similar uneasiness about other linters that may exist in both syntax and environment form, since the syntax linter gives immediate feedback, which is normally enough, but the environment linter would give a \"definite\" answer, albeit later.</p>",
        "id": 475952115,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728506050
    },
    {
        "content": "<p>Indeed, this is one of the tests:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- the `dupNamespace` linter does not notice that `to_additive` created `Foo.add.add`.</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"bp\">.</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n\n<span class=\"c1\">--  However, the declaration `Foo.add.add` is present in the environment.</span>\n<span class=\"n\">run_cmd</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"ss\">``Foo.add.add</span>\n<span class=\"w\">  </span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"bp\">.</span><span class=\"n\">isSome</span>\n</code></pre></div>",
        "id": 475952708,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728506238
    },
    {
        "content": "<p>What does that mean for the proposed linter? Of course it won't catch double underscore (and when extended potentially other things we don't want) in the namespace, but of course namespaces are added less often then definitions/theorems/lemmas. I think it would be nice to have immediate feedback.</p>\n<p>What about the import form Batteries, that gives the red warning label on the pr?<br>\n Might it make sense to factor out a function <code>getIds : Syntax → Array Syntax</code> that can be used by both the dupNamespace and the new linter?</p>",
        "id": 475954045,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1728506620
    },
    {
        "content": "<p>I think that a \"serious\" function that really extracts the name of the \"visible\" declaration is something that would be very useful.</p>",
        "id": 475955424,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728507059
    },
    {
        "content": "<p>I also think that its signature should be <code>Syntax -&gt; (appropriate monad) (Option Syntax)</code>, returning <code>none</code> only for syntax that is not a declaration and returning <code>some</code> for everything else, also nameless instances, retrieving their name and attaching some meaningful position to the (fake) syntax node that the function creates.</p>",
        "id": 475955434,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728507061
    },
    {
        "content": "<p>I remember that I used recently the \"hover\" information to find the correct name, also for nameless instances.</p>",
        "id": 475955562,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728507116
    },
    {
        "content": "<p>Let me see if I can find the code.</p>",
        "id": 475955580,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728507121
    },
    {
        "content": "<p>Ideally, there should not be the need to match on the actual syntax, since I hope that all the information that is needed is already extracted somewhere, since hovers know where they are in scope and know the full name.</p>",
        "id": 475955949,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728507218
    },
    {
        "content": "<p>Probably we should build some reusable boilerplate for \"name\" linters, and then implement both the dupNamespace and __ linter with that boilerplate</p>",
        "id": 475956602,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728507434
    },
    {
        "content": "<p>We can have the hacky syntax-based linter for now; but probably the right thing to do is to extract information from the infotree about which names in the provided syntax correspond to declarations</p>",
        "id": 475956694,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728507475
    },
    {
        "content": "<p>Let's just not have the same hack in more than one place</p>",
        "id": 475956761,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728507491
    },
    {
        "content": "<p>As you may guess, I really like syntax linters, but another advantage of the environment linters is that they also check declarations that have been defined <em>before</em> the linter is imported.</p>",
        "id": 475956840,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728507535
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Parse.20names.20of.20theorems/near/475956694\">said</a>:</p>\n<blockquote>\n<p>We can have the hacky syntax-based linter for now; but probably the right thing to do is to extract information from the infotree about which names in the provided syntax correspond to declarations</p>\n</blockquote>\n<p>My experience with working with InfoTrees, is that they contain all the information that you usually want, but I also cannot find <em>efficient</em> ways of extracting this information.</p>",
        "id": 475956945,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728507601
    },
    {
        "content": "<p>I realize that this is a limitation of my skills, but I do find that this potentially challenging.</p>",
        "id": 475957061,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728507632
    },
    {
        "content": "<p>Hopefully, this is more robust: you feed into the command the <code>Syntax</code> of the declaration and it returns the name of the declaration, whether it is nameless or not.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">ToAdditive</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">If `stx` is a declaration, then `getNames stx` returns the array of identifiers</span>\n<span class=\"sd\">for the name of the declarations whose syntax range is contained in `stx`.</span>\n\n<span class=\"sd\">If `stx` is not a declaration, then `getNames stx` returns `#[]`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getNames</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadEnv</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadFileMap</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">drs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">declRangeExt</span><span class=\"bp\">.</span><span class=\"n\">getState</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">stxPos</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"bp\">.</span><span class=\"n\">getRange?</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">default</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getFileMap</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">stxPos1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">stxPos</span><span class=\"bp\">.</span><span class=\"n\">start</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">stxPos2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">stxPos</span><span class=\"bp\">.</span><span class=\"n\">stop</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">nms</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rgs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">drs</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">stxPos1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">fm</span><span class=\"bp\">.</span><span class=\"n\">ofPosition</span><span class=\"w\"> </span><span class=\"n\">rgs</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">fm</span><span class=\"bp\">.</span><span class=\"n\">ofPosition</span><span class=\"w\"> </span><span class=\"n\">rgs</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">stxPos2</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ofPos1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fm</span><span class=\"bp\">.</span><span class=\"n\">ofPosition</span><span class=\"w\"> </span><span class=\"n\">rgs</span><span class=\"bp\">.</span><span class=\"n\">selectionRange</span><span class=\"bp\">.</span><span class=\"n\">pos</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ofPos2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fm</span><span class=\"bp\">.</span><span class=\"n\">ofPosition</span><span class=\"w\"> </span><span class=\"n\">rgs</span><span class=\"bp\">.</span><span class=\"n\">selectionRange</span><span class=\"bp\">.</span><span class=\"n\">endPos</span>\n<span class=\"w\">      </span><span class=\"n\">nms</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nms</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkIdentFrom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ofRange</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ofPos1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ofPos2</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">nm</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">nms</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"#show_names \"</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"o\">:</span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"n\">stx</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">nmStx</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getNames</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">logInfoAt</span><span class=\"w\"> </span><span class=\"n\">nmStx</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"The name is '{nmStx}'\"</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: The name is 'add_add'</span>\n<span class=\"sd\">---</span>\n<span class=\"sd\">info: The name is 'mul_mul'</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">show_names</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mul_mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n\n<span class=\"sd\">/-- info: The name is 'instAddNat_1' -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">show_names</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n\n<span class=\"sd\">/-- info: The name is 'instAddNat_2' -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">show_names</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n\n<span class=\"sd\">/-- info: The name is 'X' -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">show_names</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: The name is 'X1.mk'</span>\n<span class=\"sd\">---</span>\n<span class=\"sd\">info: The name is 'X1'</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">show_names</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">X1</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">show_names</span>\n<span class=\"kn\">section</span>\n</code></pre></div>",
        "id": 475966358,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728511488
    },
    {
        "content": "<p>I edited the above code: it occurred to me that the functions above could be adapted to catch <code>to_additive</code> names as well.</p>",
        "id": 475968361,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728512509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"313038\">Moritz Firsching</span> <a href=\"#narrow/stream/270676-lean4/topic/Parse.20names.20of.20theorems/near/475847779\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>apparently importing  <code>Batteries.Data.String.Matcher</code> is perhaps not the best idea...</li>\n</ol>\n</blockquote>\n<p>This response is way aside at this point in the thread, apologies. I don't think this is the optimal route for your use case but note that <code>Batteries.Data.String.Matcher</code> is built upon a much more general <code>Batteries.Data.Array.Match</code> that can be used on much more general data types than strings. (Still in linear time!) The interface is admittedly not optimal but comments and ideas are most welcome! There are plenty of ways to make this algorithm more usable.</p>",
        "id": 476035258,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1728538422
    },
    {
        "content": "<p>Ah, I had missed that import!</p>\n<p><code>Mathlib.Tactic.Linter.Style</code> is imported in <code>Mathlib.Init</code> and <code>Mathlib.Init</code> is quite controlled in its imports.  So, I would recommend against adding imports to it, even in Batteries.  Instead of matching, you can use <code>str.splitOn \"__\"</code> in your case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\">  </span><span class=\"c1\">-- [true, false]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">strs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\"ab__cd__ef\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s2\">\"ab_cd_ef\"</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">strs</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">splitOn</span><span class=\"w\"> </span><span class=\"s2\">\"__\"</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(I am not really sure about efficiency, so feel free to suggest more performant, import-less solutions!)</p>",
        "id": 476037166,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728539465
    },
    {
        "content": "<p>ok, cool, now I'm using the code you suggested and moved it to a file Linter/Common.lean, where both the dupNamespace linter and hte new linter use the new funcitons <code>getNames</code>. Seems like it works in principle, but I get lots of new (false positive?) duplicate namespace warnings:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/11274654137/job/31354283516?pr=17580\">https://github.com/leanprover-community/mathlib4/actions/runs/11274654137/job/31354283516?pr=17580</a></p>\n<p>The large import should now not be a problem anymore.</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/17580\">mathlib#17580</a></p>",
        "id": 476147129,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1728570178
    },
    {
        "content": "<p>Thanks!</p>\n<p>I'm benching the PR, since I'm curious about performance of the new script.  I don't have time to review it now, though.</p>",
        "id": 476155777,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728572524
    },
    {
        "content": "<p>it still does not work, because for some reason I'm getting these false postivies</p>",
        "id": 476156017,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1728572595
    },
    {
        "content": "<p>I left some comments, mostly about style and documentation.</p>",
        "id": 476163820,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1728574754
    },
    {
        "content": "<p>I also left some comments, hopefully with a fix for the build!</p>",
        "id": 476207958,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728588265
    },
    {
        "content": "<p>Thanks to both of you! Build seems fixed now. I will address the remaining points raised</p>",
        "id": 476208074,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1728588309
    },
    {
        "content": "<p>I am hoping that the linter will now catch a \"hidden\" name that has a duplicated namespace...</p>",
        "id": 476208563,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728588452
    }
]