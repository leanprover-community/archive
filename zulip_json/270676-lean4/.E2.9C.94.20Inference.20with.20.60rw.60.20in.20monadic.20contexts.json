[
    {
        "content": "<p>Assume this simplified (and slightly altered) class from Sebastian's mpl library:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MonadMorphism</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">morph</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">bind_bind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">morph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">morph</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">morph</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>\n<p>Now suppose:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MonadMorphism</span><span class=\"bp\">.</span><span class=\"n\">map_map</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MonadMorphism</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">morph</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulMonad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulMonad</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">morph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">morph</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"n\">bind_pure_comp</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">morph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">morph</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>At this point, <code>simp only [MonadMorphism.bind_bind]</code> gives me <code>morph x &gt;&gt;= morph ‚àò pure ‚àò f = f &lt;$&gt; morph x</code>.<br>\nHowever, <code>rw [MonadMorphism.bind_bind]</code> fails with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">rewrite'</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pattern</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">metavariable</span>\n<span class=\"w\">  </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">845</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">equation</span>\n<span class=\"w\">  </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">845</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">845</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">845</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">f</span>\n</code></pre></div>\n<p>I can make it go through with either <code>rw [MonadMorphism.bind_bind (self := A)]</code> or <code>rw [MonadMorphism.bind_bind (m := m) (morph := morph)]</code>, but I am mostly wondering about what _exactly_ is happening so that Lean's <code>rw</code> cannot figure out the motive here <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> - it _seems_ to me it should have all the implicit arguments right there from the type of the target?</p>",
        "id": 508554303,
        "sender_full_name": "Franti≈°ek Silv√°≈°i ü¶â",
        "timestamp": 1743090270
    },
    {
        "content": "<p><code>rw</code> considers any pattern whose head is a metavariable to \"be\" a metavariable, so it's not willing to even try to look for obvious matches to <code>?m.845 (?x &gt;&gt;= ?f)</code>. The workaround is to specify a concrete value for the argument that sets <code>?m.845</code>.</p>\n<p>I think it would be nice if <code>rw</code> supported this. The Lean FRO has been thinking about some improvements to <code>rw</code>. The issue with this particular example though is that it's completely incompatible with the way <code>rw</code> looks for matches ‚Äî it uses something called \"key matching\", and function arguments don't contribute to the key.</p>",
        "id": 508555878,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743090638
    },
    {
        "content": "<p>So I assume that <code>?m.845</code> is the <code>morph</code> function, yet <code>rw [MonadMorphism.bind_bind (morph := morph)]</code> fails with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">rewrite'</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">did</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">pattern</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">target</span><span class=\"w\"> </span><span class=\"n\">expression</span>\n<span class=\"w\">  </span><span class=\"n\">morph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is this a completely separate issue? (Giving an additional <code>(m := m)</code> or <code>(n := n)</code> makes Lean happy.)</p>",
        "id": 508557425,
        "sender_full_name": "Franti≈°ek Silv√°≈°i ü¶â",
        "timestamp": 1743091007
    },
    {
        "content": "<p>At least it's trying to find a match at all once you set <code>morph</code>, but I don't know why it's not finding the pattern. Sometimes it's typeclass instances preventing unification, but it'd take some investigation. (<a href=\"https://github.com/leanprover/lean4/pull/7172\">lean4#7172</a> has an attempt at some auto-diagnosis for this sort of issue, but it's on the backburner.)</p>\n<p>If <code>simp</code> works, something you might like is <code>simp_rw</code>, which is a convenient frontend to <code>simp only</code>. I know you're trying to understand the <code>rw</code> failure here, but I thought I'd mention the tactic.</p>",
        "id": 508559115,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743091385
    },
    {
        "content": "<p>Yup, I am familiar with <code>simp_rw</code>, really just trying to actually see how the motive is computed fully with <code>rw</code>; <code>simp</code> (and its derivatives) have made me spoiled :).</p>\n<p>Thanks for the discussion Kyle &lt;3.</p>",
        "id": 508559773,
        "sender_full_name": "Franti≈°ek Silv√°≈°i ü¶â",
        "timestamp": 1743091536
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"364929\">Franti≈°ek Silv√°≈°i ü¶â</span> has marked this topic as resolved.</p>",
        "id": 508559820,
        "sender_full_name": "Notification Bot",
        "timestamp": 1743091548
    },
    {
        "content": "<p>I think a big difference here is that <code>simp</code> is able to find matches in a more syntactic way (using discrimination trees) where <code>rw</code> matches heads syntactically but then uses full unification.</p>\n<p>I don't know if it will happen, but I'm hoping for a future where <code>rw</code> uses the same matching algorithm as <code>simp</code>. I'd like to see it be a more-powerful <code>simp_rw</code>, one that can do multiple rewrites at once (if there are multiple matches), that can rewrite with conditional rewrites (creating side-goals, like <code>rw</code> currently does), and that only applies a single iteration of rewriting (unlike <code>simp_rw</code>, which rewrites until no more rewrites can be done).</p>",
        "id": 508561869,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743091959
    }
]