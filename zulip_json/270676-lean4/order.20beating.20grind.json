[
    {
        "content": "<p>I've seen Kim requesting a few times for things that maybe grind could/should do. Here's a simple problem I just ran into:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">order</span>\n</code></pre></div>\n<p>This works. But <code>constructor &lt;;&gt; grind</code> doesn't work. (Indeed, I would hope that just <code>grind</code> suffices.)</p>",
        "id": 540522115,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1758310182
    },
    {
        "content": "<p>It can be solved by telling grind about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=le_antisymm#doc\">docs#le_antisymm</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">le_antisymm</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Perhaps <code>le_antisymm</code> should be marked with a grind annotation.</p>",
        "id": 540528177,
        "sender_full_name": "Julia Scheaffer",
        "timestamp": 1758313226
    },
    {
        "content": "<p>I suspect we'll just implement a custom order solver in grind at some point, so I've been holding off shiny such annotations.</p>",
        "id": 540530678,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1758314434
    },
    {
        "content": "<p>(Update: hopefully this will arrive in v4.25.0-rc1)</p>",
        "id": 541143939,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1758690523
    },
    {
        "content": "<p>nice!</p>",
        "id": 542853317,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1759453537
    },
    {
        "content": "<p>What will be supported by the order module in grind? Will it support linear orders, partial orders and preorders? Will it support top/bottom and max/min/sup/inf?</p>",
        "id": 543968462,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1760018428
    },
    {
        "content": "<p>At least linear, partial and pre orders as well as modules (i.e. linear combinations). Afaik we didn't talk about lattice theory yet.</p>",
        "id": 543970468,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1760018875
    },
    {
        "content": "<p>Is there a way for grind to speculatively use the density of a dense linear order? e.g. once we've derived a minimal set of LE relations, you can then also add an element between each minimal pair.</p>\n<p>Obviously would make sense the same way as a @[grind] rule since it would immediately loop, but it could be a cool feature/option to have within a module. I think that would substantially improve grind's power in a lot of analysis stuff.</p>",
        "id": 543973384,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1760019505
    },
    {
        "content": "<p>I noticed that due to the new order module the following gives a kernel error on the current nightly. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">(kernel) application type mismatch</span>\n<span class=\"cm\">  Lean.Grind.Order.eq_of_le_of_le</span>\n<span class=\"cm\">    (Lean.Grind.Order.eq_mp</span>\n<span class=\"cm\">      (id</span>\n<span class=\"cm\">        (Lean.Grind.CommRing.le_norm_expr (Lean.RArray.branch 1 (Lean.RArray.leaf a) (Lean.RArray.leaf b))</span>\n<span class=\"cm\">          ((Lean.Grind.CommRing.Expr.var 0).add</span>\n<span class=\"cm\">            ((Lean.Grind.CommRing.Expr.num 1).neg.mul (Lean.Grind.CommRing.Expr.var 1)))</span>\n<span class=\"cm\">          (Lean.Grind.CommRing.Expr.num 0) (Lean.Grind.CommRing.Expr.var 0)</span>\n<span class=\"cm\">          ((Lean.Grind.CommRing.Expr.var 1).add (Lean.Grind.CommRing.Expr.intCast 0)) (eagerReduce (Eq.refl true))))</span>\n<span class=\"cm\">      h2)</span>\n<span class=\"cm\">argument has type</span>\n<span class=\"cm\">  a ≤ b + IntCast.intCast 0</span>\n<span class=\"cm\">but function has type</span>\n<span class=\"cm\">  a ≤ b → b ≤ a → a = b</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 544237014,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1760125559
    },
    {
        "content": "<p>is adding zero not a defeq anymore</p>",
        "id": 544237232,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760125652
    },
    {
        "content": "<p>I guess with Int...</p>",
        "id": 544237259,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760125664
    },
    {
        "content": "<p>Is <code>grind</code> meant to be complete for partial orders? This example fails on nightly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">LawfulOrderLT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">IsPartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h5</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>",
        "id": 544252483,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1760132809
    },
    {
        "content": "<p>This is going to be supported in the future</p>",
        "id": 544261183,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1760137500
    }
]