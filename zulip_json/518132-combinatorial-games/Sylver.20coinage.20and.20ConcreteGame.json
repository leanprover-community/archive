[
    {
        "content": "<p>I've defined the concrete impartial game of Sylver coinage <a href=\"https://github.com/leanprover-community/mathlib4/pull/27743/files#diff-882c55627a7d698d8960dfd34b09e5c09b0be63482ffd626e907dd015decf6c1R228\">here</a>, shown it always terminates, solved a few simple positions, and listed Hutchings' theorem and corollaries as to-dos. I made a definition of P-position just for Sylver coinage, but it would work for any well-founded impartial game described by a relation / transition graph. Maybe this could inspire more work around <a href=\"https://vihdzp.github.io/combinatorial-games/CombinatorialGames/Game/Concrete.html#ConcreteGame\">ConcreteGame</a>; for example, it might be more convenient if <code>relLeft : α → α → Prop</code> is replaced by <code>LeftMoves : α → Type _</code> and <code>moveLeft (a : α) : LeftMoves a → α</code>.</p>",
        "id": 532173946,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1753998623
    },
    {
        "content": "<p>I'd be glad to help you port this over to our repo.</p>",
        "id": 532201097,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754012085
    },
    {
        "content": "<p>The idea behind <a href=\"https://vihdzp.github.io/combinatorial-games/CombinatorialGames/Game/Concrete.html#ConcreteGame\"><code>ConcreteGame</code></a> is that it represents the directed graph of all possible states in a game.</p>",
        "id": 532201651,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754012277
    },
    {
        "content": "<p>In the case of Sylver coinage, the type would be sets of named numbers, and the relation would be between <code>s</code> and <code>insert a s</code> when <code>a</code> is a valid new number to name.</p>",
        "id": 532201933,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754012387
    },
    {
        "content": "<p>What would the benefit of <code>LeftMoves</code> and <code>moveLeft</code> be as you define them? I admit the use of dependent types makes me somewhat skeptical. <code>PGame</code> was awful to work with because of them.</p>",
        "id": 532202026,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754012433
    },
    {
        "content": "<p><code>simp</code> and <code>aesop</code> generally work much better at proving relations between sets than they do at proving relations between indexed families (especially when the index types aren't even def-eq!)</p>",
        "id": 532202992,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754012933
    },
    {
        "content": "<p>I mean that in this case it's more convenient if the moves are indexed by a subtype of <code>Nat</code>; I wrote <a href=\"https://github.com/alreadydone/mathlib4/blob/IsNoetherianRing_Nat/Mathlib/NumberTheory/FrobeniusNumber.lean#L263-L271\">two lemmas</a> that quantifies over such moves, and introducing <code>Left/RightMoves</code> would allow you to state these lemmas as general API.</p>",
        "id": 532238910,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754031446
    },
    {
        "content": "<p>Why can't these lemmas be general API as is?</p>",
        "id": 532274224,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754043477
    },
    {
        "content": "<p>I prefer them much more to the dependently typed versions.</p>",
        "id": 532274251,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754043487
    },
    {
        "content": "<p>The issue is, if you have two games that are prop-eq but not def-eq (a very common occurrence), then the same is true for the types indexing the moves of said games. Which means you have to introduce casts and heqs everywhere. Which sucks.</p>",
        "id": 532274426,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754043554
    },
    {
        "content": "<p>That was the issue back when <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PGame#doc\">docs#PGame</a> was still a part of the library, and in fact removing that type was the whole reason we made our own repo in the first place!</p>",
        "id": 532274493,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754043586
    },
    {
        "content": "<p>I'm currently in the process of splitting <code>ConcreteGame</code> into a loopy and a well-founded counterpart. Once that's done we can add the Sylver coinage code.</p>",
        "id": 532422693,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754115645
    },
    {
        "content": "<p>I'd suggest that you include the type <code>α</code> in the structure <code>ConcreteGame</code>. For example for Sylver coinage it seems pointless to introduce a type synonym for <code>Finset Nat</code> in order to put a <code>ConcreteGame</code> instance on it. This will also make it clear that you shouldn't consider prop-eq between games because they include prop-eq between types. But a suitable quotient of <code>ConcreteGame</code> will be identifiable with IGame/LGame.</p>\n<p>I think we should focus on usability and API for concrete games when developing <code>ConcreteGame</code>. The way humans play concrete games is to make moves that transition between states, rather than consider all possible states and check which ones have moves from the current state. We would like to quantify over moves rather than states. With the current definition you can make a constructor that collapses LeftMoves/moveLeft into relLeft (btw it should be RelLeft), and build APIs around the constructor, but it would be easier if you just build LeftMoves/moveLeft into the definition. (It might be better to allow an arbitrary type of labels instead of just Bool (left/right); we may build \"ConcreteZFSet\" with a single label and the von Neumann ordinal of a Lean Ordinal will simply be any representative well-ordered type of the Ordinal.)</p>",
        "id": 532431421,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754123137
    },
    {
        "content": "<blockquote>\n<p>I'd suggest that you include the type <code>α</code> in the structure <code>ConcreteGame</code>.</p>\n</blockquote>\n<p>How would this look for sylver coinage? What type would the instance exist on, if not on (an alias for) the type of states?</p>\n<blockquote>\n<p>The way humans play concrete games is to make moves that transition between states, rather than consider all possible states and check which ones have moves from the current state.</p>\n</blockquote>\n<p>This is true, and you can do this through the <code>IGame.leftMoves</code> / <code>IGame.rightMoves</code> functions, as you can for any other game. </p>\n<blockquote>\n<p>(It might be better to allow an arbitrary type of labels instead of just Bool (left/right); we may build \"ConcreteZFSet\" with a single label and the von Neumann ordinal of a Lean Ordinal will simply be any representative well-ordered type of the Ordinal.)</p>\n</blockquote>\n<p>I think the \"correct\" way to define <code>ZFSet.{u}</code> would be as the initial algebra of the functor <code>fun α ↦ {x : Set α // Small.{u} x}</code>. The two argument version of this is what we did for <code>IGame</code>, which has the benefit that we can also build the final co-algebra, which happens to be the type of loopy games <code>LGame</code>. I don't know if this can actually be implemented into Mathlib though, since as I understand it there are people who're very invested in keeping <code>ZFSet</code> and its constructors computable.</p>",
        "id": 532432135,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754123690
    },
    {
        "content": "<p>(the final coalgebra corresponding to the <code>ZFSet</code> functor would give Aczel's non-well-founded set theory)</p>",
        "id": 532432339,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754123847
    },
    {
        "content": "<blockquote>\n<p>This will also make it clear that you shouldn't consider prop-eq between games because they include prop-eq between types. But a suitable quotient of <code>ConcreteGame</code> will be identifiable with IGame/LGame.</p>\n</blockquote>\n<p>I think there might be a misunderstanding. Prop-eq between games is fine and commonplace ever since we ditched <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PGame#doc\">docs#PGame</a> for <code>IGame</code>. In our current setup even basic equations like <code>x = {leftMoves x | rightMoves x}</code> are not definitional. But since all the API is about sets rather than types of moves, there is no problem whatsoever.</p>\n<p>Also, there isn't a type of <code>ConcreteGames</code>. The idea behind <code>ConcreteGame</code> is that you should be able to define an <code>IGame</code> (or really, an <code>LGame</code>) from its game graph. You're still ultimately working with <code>IGame</code> when you do this, rather than a new type of games.</p>",
        "id": 532432771,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754124199
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> I've thought about this some more. Following <a href=\"https://vihdzp.github.io/combinatorial-games/CombinatorialGames/Game/Loopy/Basic.html#LGame.corec\"><code>LGame.corec</code></a>, it makes sense to redefine <code>ConcreteGame</code> to use functions <code>leftMoves : a -&gt; Set a</code> and <code>rightMoves : a -&gt; Set a</code> rather than relations.</p>",
        "id": 533008094,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754441923
    },
    {
        "content": "<p>After all, the function <code>ConcreteGame.toLGame</code> is nothing more than a call to <code>LGame.corec</code>!</p>",
        "id": 533008244,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754442048
    },
    {
        "content": "<p>I agree that in the case of Sylver coinage it makes more sense to think of the options of a move as being indexed by a natural number, rather than a set of lists. I don't think we need dependent types to address this, though. We can define <code>Sylver.cons</code> in the obvious way, and prove that options of <code>toIGame l</code> look like <code>toIGame (cons a l)</code>.</p>",
        "id": 533008509,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754442260
    },
    {
        "content": "<p>On the topic of <code>ConcreteGame</code>. We currently have <a href=\"https://vihdzp.github.io/combinatorial-games/CombinatorialGames/Game/Specific/Poset.html#IGame.Poset\"><code>IGame.Poset</code></a> and <a href=\"https://vihdzp.github.io/combinatorial-games/CombinatorialGames/Game/Specific/Domineering.html#IGame.Domineering\"><code>IGame.Domineering</code></a> living in the <code>IGame</code> namespace. I don't like that as a pattern - we could conceivably define loopy versions of these games, or others in the future.</p>",
        "id": 533027813,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754458518
    },
    {
        "content": "<p>What do you think about moving them to the <code>ConcreteGame</code> namespace?</p>",
        "id": 533027873,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754458562
    },
    {
        "content": "<p>I've opened this PR: <a href=\"https://github.com/vihdzp/combinatorial-games/pull/174\">https://github.com/vihdzp/combinatorial-games/pull/174</a></p>",
        "id": 533030138,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754460212
    },
    {
        "content": "<p>I think the current ConcreteGame should be called GameGraph instead, and the actual ConcreteGame should take types <code>Left/RightMoves</code> as I suggested above. <a href=\"https://github.com/leanprover-community/PR/pull/174\">PR#174</a> doesn't really change the definition (it's defeq up to reordering). You can see the definition of <code>PosetRel</code> and <code>relLeft/Right</code> in Domineering all include an existential quantifier, and what they quantify over are exactly the moves. With the <code>Outcome</code> development, it would be nice to replace <code>∀ y ∈ x.leftMoves,</code> by <code>∀ y : x.LeftMoves</code> in user-facing API.<br>\nI also don't see the point of introducing a type synonym <code>def Domineering := Finset (ℤ × ℤ)</code> and <code>def Poset (α : Type*) [Preorder α] := Set α</code> with the <code>to/ofDomineering</code>/<code>to/ofPoset</code> auxiliary functions, which can be avoided if the type <code>Finset (ℤ × ℤ)</code>/<code>Set α</code> is included as a field of ConcreteGame. I might submit my version of <a href=\"https://github.com/leanprover-community/PR/pull/174\">PR#174</a> at some point. My version of Sylver coinage would be something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ConcreteImpartialGame</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">States</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"c1\">-- maybe call it `Pos` instead</span>\n<span class=\"w\">  </span><span class=\"n\">Moves</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">States</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"c1\">-- maybe allow a different universe</span>\n<span class=\"w\">  </span><span class=\"n\">move</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">States</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Moves</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">States</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SylverCoinage</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ConcreteImpartialGame</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">States</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"n\">Moves</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">move</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">s</span>\n</code></pre></div>",
        "id": 533346012,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754592272
    },
    {
        "content": "<p>Again, I'm very heavily against this dependent type design. We've had trouble with this in the past with <code>PGame</code>. I'd rather not have to go through that again.</p>",
        "id": 533446120,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754652633
    },
    {
        "content": "<p>Working with sets has done us wonders. Aesop in particular has had a lot of opportunity to shine, solving goals that were 30 lines or more in the old development.</p>",
        "id": 533446225,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754652691
    },
    {
        "content": "<p>Also, <code>ConcreteGame</code> isn't supposed to be a structure. We're not really interested in the type of concrete games (or game graphs, if you prefer to call them that); rather, the class is supposed to function as a shortcut to build <code>IGame</code>s and <code>FGame</code>s in \"realistic\" scenarios.</p>",
        "id": 533446856,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754652968
    },
    {
        "content": "<p>I think this should be a structure rather than a class</p>",
        "id": 533447041,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754653036
    },
    {
        "content": "<p>The type of game graphs is just FGame with worse equality. We don't need it.</p>",
        "id": 533447113,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754653067
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformSpace.Core#doc\">docs#UniformSpace.Core</a> is also just a shortcut to building uniform spaces but it's also a structure</p>",
        "id": 533447215,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754653103
    },
    {
        "content": "<p>This should not be a class</p>",
        "id": 533447237,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754653115
    },
    {
        "content": "<p>Oh, I think I see what you mean now.</p>",
        "id": 533447277,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754653139
    },
    {
        "content": "<p>I guess using a structure rather than a class would obviate the need for type aliases.</p>",
        "id": 533447433,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754653205
    },
    {
        "content": "<p>Not sure about bundling the type though</p>",
        "id": 533447647,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754653293
    },
    {
        "content": "<p>Yeah, I agree with using a structure. I was just confused about what the motivation was.</p>",
        "id": 533447832,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754653369
    },
    {
        "content": "<p>I don't agree with having a type of moves for every state. I think this is a really bad idea which has already failed us before.</p>",
        "id": 533447967,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754653431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/stream/518132-combinatorial-games/topic/Sylver.20coinage.20and.20ConcreteGame/near/533447647\">said</a>:</p>\n<blockquote>\n<p>Not sure about bundling the type though</p>\n</blockquote>\n<p>What's the alternative? Taking the type as an argument?</p>",
        "id": 533448031,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754653457
    },
    {
        "content": "<p>Yeah, that does make more sense to me.</p>",
        "id": 533448098,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754653483
    },
    {
        "content": "<p>Just to make sure. The idea would be to make functions, say, <code>IGame.domineering</code>, or <code>IGame.sylver</code>, instead of using <code>ConcreteGame.toIGame</code> for everything, right?</p>",
        "id": 533448503,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754653649
    },
    {
        "content": "<p>oh you can play sylver coinage on any noetherian semiring</p>",
        "id": 533451062,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754654720
    },
    {
        "content": "<p>or I guess any noetherian semimodule over any semiring</p>",
        "id": 533451111,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754654739
    },
    {
        "content": "<p>Well presumably you can play it in any semiring, it just doesn't always terminate</p>",
        "id": 533451186,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754654764
    },
    {
        "content": "<p>yeah</p>",
        "id": 533451205,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754654769
    },
    {
        "content": "<blockquote>\n<p>oh you can play sylver coinage on any noetherian semiring</p>\n</blockquote>\n<p>Great comment! Golfed <code>wellFounded_rel</code> accordingly.</p>",
        "id": 533476179,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754663829
    },
    {
        "content": "<blockquote>\n<p>Again, I'm very heavily against this dependent type design. We've had trouble with this in the past with <code>PGame</code>. I'd rather not have to go through that again.<br>\nWorking with sets has done us wonders. Aesop in particular has had a lot of opportunity to shine, solving goals that were 30 lines or more in the old development.</p>\n</blockquote>\n<p>Probably there's some misunderstanding; I'm not asking you to change the definition of IGame or LGame or forbid you to work with sets. Even without changing the definition of ConcreteGame, we still have to provide a constructor for game graphs starting from types of moves and functions from moves to positions, and I'm just suggesting wrapping the inputs of the constructor into a structure. You take the ranges of the functions from moves to positions when you pass from concrete games to game graphs, and you'll continue to use sets and relations and aesop once you're in the world of game graphs.</p>\n<p>We're not going to work with equalities in ConcreteGame or GameGraph, but it would be an interesting problem to define an equivalence relation on GameGraphs with a starting position such that GameGraph.toLGame identifies the quotient with LGame.</p>",
        "id": 533476180,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754663830
    },
    {
        "content": "<p>Well, if the idea is to state results on LGame and IGame in the set form, then what's the advantage of using the dependent types in ConcreteGame?</p>",
        "id": 533526719,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754686385
    },
    {
        "content": "<p>The whole concept of building a game from its graph is what the corecursor on LGame is doing. I don't see a reason to not just copy down that design.</p>",
        "id": 533527008,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754686470
    },
    {
        "content": "<p>I'm not concerned with building a game from its graph, I'm concerned with building a graph from the moves. You can't use the same type for all positions, because available moves depend on the position. In the case of Sylver coinage, the type of moves is <code>{n : ℕ // n ∉ Ideal.span s ∧ n ≠ 1}</code> which depends on <code>s</code> (more precisely the predicate defining the subtype depends on <code>s</code> even though the ambient type <code>ℕ</code> doesn't).</p>",
        "id": 533527976,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754686735
    },
    {
        "content": "<p>Again, I'd rather we just write down the sets of left and right options explicitly.</p>",
        "id": 533537435,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754693777
    },
    {
        "content": "<p>We then could (and should) add a simp lemma that \"for all left options x of a Sylver coinage position, P x\" is equivalent to \"for every natural number not in the span, P n\"</p>",
        "id": 533537484,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754693825
    },
    {
        "content": "<p>(I hope I'm not coming off as too harsh. I'd like to hear someone else's opinion on this DTT design.)</p>",
        "id": 533537602,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754693946
    },
    {
        "content": "<p>Instead of writing that lemma only for Sylver coinage, I'd write a generic lemma that also applies to e.g. poset games and domineering. Maybe another simp lemma for the case that the type of moves is a subtype.</p>",
        "id": 533538906,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754695063
    },
    {
        "content": "<p>I don't think there's really a generic lemma here. The best way to write down left/right options of a game depends heavily on how that game is defined</p>",
        "id": 533539378,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754695504
    },
    {
        "content": "<p>Compare e.g. <code>forall_leftMoves_neg</code>, <code>forall_leftMoves_add</code>, and <code>forall_leftMoves_mul</code>.</p>",
        "id": 533539407,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754695533
    },
    {
        "content": "<p>You're saying that the type of moves may have multiple constructors so one forall over the type might break into a conjunction of foralls. This is a valid concern and occurs in concrete games like chess where you first choose a piece to move and then which square to move to (depending on the piece). I think the single constructor case still applies to a lot of games, but I agree maybe we should name it <code>SingleConstructorCore</code> rather than <code>ConcreteGame</code>.</p>",
        "id": 533540782,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754696708
    },
    {
        "content": "<blockquote>\n<p>or I guess any noetherian semimodule over any semiring</p>\n</blockquote>\n<p>It seems possible to unify this with poset games under the following general setting: given a type T and a closure operator on it, we construct the game with positions <code>Set T</code>, and the moves available at a position <code>s : Set T</code> are elements of <code>T</code> not contained in the closure of <code>s</code>. For poset games we take the upper closure of <code>s</code> while for Sylver coinage we take the subsemimodule spanned by <code>s</code>.</p>",
        "id": 533540799,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754696721
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/518132-combinatorial-games/topic/Sylver.20coinage.20and.20ConcreteGame/near/533540782\">said</a>:</p>\n<blockquote>\n<p>You're saying that the type of moves may have multiple constructors so one forall over the type might break into a conjunction of foralls. </p>\n</blockquote>\n<p>More generally than that, there are usually \"nice\" ways to index moves in forall/exist, and instead of using the \"every position has a type of moves\" idea, we can simply use lemmas of this type to achieve the same ease of use.</p>",
        "id": 533540952,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754696874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/518132-combinatorial-games/topic/Sylver.20coinage.20and.20ConcreteGame/near/533540799\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>or I guess any noetherian semimodule over any semiring</p>\n</blockquote>\n<p>It seems possible to unify this with poset games under the following general setting: given a type T and a closure operator on it, we construct the game with positions <code>Set T</code>, and the moves available at a position <code>s : Set T</code> are elements of <code>T</code> not contained in the closure of <code>s</code>. For poset games we take the upper closure of <code>s</code> while for Sylver coinage we take the subsemimodule spanned by <code>s</code>.</p>\n</blockquote>\n<p>That's an interesting idea. Does \"closure operator\" just mean any function <code>a -&gt; Set a</code>? Or is there some more specific condition? And can we state a general termination condition, that translates to being a WQO in the poset case, and to being noetherian in the Sylver coinage case?</p>",
        "id": 533541157,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754697109
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ClosureOperator#doc\">docs#ClosureOperator</a></p>",
        "id": 533541216,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754697167
    },
    {
        "content": "<p>it's the reflector for a reflective subcategory of a preorder <code>α</code> viewed as a thin category</p>",
        "id": 533541342,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754697321
    },
    {
        "content": "<p>I don't know what those words mean <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 533541378,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754697355
    },
    {
        "content": "<p>But I can understand \"function with similar order properties to the closure operator of a topological space\"</p>",
        "id": 533541397,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754697374
    },
    {
        "content": "<p>Wait. Say we have a game that can sometimes be loopy/infinite but which can sometimes be well-founded. Under suitable assumptions, Sylver coinage and poset games are examples of this.</p>\n<p>If we make concrete games a class, this isn't an issue. We can make the well-founded class extend the loopy class, which makes <code>toIGame</code> and <code>toLGame</code> both available under the suitable typeclass assumptions. </p>\n<p>If we make them a structure, doesn't that mean we have to choose one of two structures (the loopy or the well-founded one) to state our results?</p>",
        "id": 533545666,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754702979
    },
    {
        "content": "<p>A solution would be to, for every game, choose whether we're going to treat it as an <code>IGame</code> or an <code>LGame</code>. That feels like a weird decision. e.g. poset games are better studied in the well-founded case. But does that mean that we shouldn't allow for the loopy case? Or does that mean that we'd have to create two structures <code>ConcreteIGame.Poset</code> and <code>ConcreteLGame.Poset</code> just to state the results?</p>",
        "id": 533545873,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754703235
    },
    {
        "content": "<p>(though thinking about it. Maybe the idea is that you use the structures to define the <code>toIGame</code> and <code>toLGame</code> functions, and then never make reference to the structure again?)</p>",
        "id": 533545902,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754703274
    },
    {
        "content": "<p>I think the idea is to prove theorems about the class</p>",
        "id": 533546018,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754703428
    },
    {
        "content": "<p>or not the class but the type that holds your stuff</p>",
        "id": 533546033,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754703449
    },
    {
        "content": "<p><em>hmmmm</em> should <code>ConcreteGame</code> be a class after all?</p>",
        "id": 533546045,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754703475
    },
    {
        "content": "<p>I like that the structure approach gets rid of the need for type aliases.</p>",
        "id": 533546064,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754703511
    },
    {
        "content": "<p>It feels similar to proving theorems about a type like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithTop#doc\">docs#WithTop</a> which gains more properties as the base type gains properties (preorder -&gt; partial order -&gt; semilattice -&gt; lattice -&gt; ...)</p>",
        "id": 533546102,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754703577
    },
    {
        "content": "<p>but in this case there is only one property, which is well-foundedness</p>",
        "id": 533546121,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754703599
    },
    {
        "content": "<p>Maybe we should fully Lean into the idea of having these types as mere auxiliaries.</p>",
        "id": 533546197,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754703691
    },
    {
        "content": "<p>You define your structures representing your games. You use those to define the maps into <code>IGame</code> and/or <code>LGame</code>. Maybe you're able to prove some properties like <code>Impartial</code> and <code>Dicotic</code> more easily. But after that, you don't touch the concrete classes anymore.</p>",
        "id": 533546319,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754703859
    },
    {
        "content": "<p>Under that philosophy it's not really an issue to have redundancy in <code>ConcreteIGame</code> / <code>ConcreteLGame</code>. You're not using these to state the public API anyways.</p>",
        "id": 533546369,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754703937
    },
    {
        "content": "<p>sure that works?</p>",
        "id": 533546374,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754703944
    },
    {
        "content": "<p>yeah that works</p>",
        "id": 533546378,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754703950
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> what do you think about that design?</p>",
        "id": 533546453,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754704036
    },
    {
        "content": "<p>I think ConcreteGame (GameGraph) need not bundle the well-founded condition; you can have a <code>ConcreteGame.toLGame</code> constructor and also <code>.toIGame</code> given a <code>[IsWellFounded IsOption]</code> argument (in fact you only need <code>Acc IsOption startPosition</code>).<br>\nIt might be beneficial to introduce <code>HasLeft/RightMoves</code> typeclasses of which <code>IGame</code>, <code>LGame</code> and the positions in any <code>ConcreteGame</code> could all be instances. Then you can define <code>IsOption</code>/<code>Subposition</code> and <code>IsLeft/RightWin/Loss/Draw</code> uniformly for all three. Otherwise you may want to state all results using ConcreteGame since it's the most general.</p>",
        "id": 533575420,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754741685
    },
    {
        "content": "<blockquote>\n<p>And can we state a general termination condition, that translates to being a WQO in the poset case, and to being noetherian in the Sylver coinage case?</p>\n</blockquote>\n<p>I think the termination condition is the ascending chain condition on closed subsets.</p>",
        "id": 533575491,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754741762
    },
    {
        "content": "<p>Equivalently, every closed subset is finitely generated (the closure of a finite set)</p>",
        "id": 533578120,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754744772
    },
    {
        "content": "<p>In order to show the union of a chain of a closed sets is closed, you need that every element in the closure of a set is in the closure of some finite subset, which is satisfied by poset games (every element is in the closure of a single element) and Sylver coinage, but not for e.g. topological closure. (This goes inside the argument that every closed set is f.g. ⇒ WellFoundedGT on closed sets)</p>",
        "id": 533580134,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754747157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/518132-combinatorial-games/topic/Sylver.20coinage.20and.20ConcreteGame/near/533580134\">said</a>:</p>\n<blockquote>\n<p>In order to show the union of a chain of a closed sets is closed, you need that every element in the closure of a set is in the closure of some finite subset, which is satisfied by poset games (every element is in the closure of a single element) and Sylver coinage, but not for e.g. topological closure. (This goes inside the argument that every closed set is f.g. ⇒ WellFoundedGT on closed sets)</p>\n</blockquote>\n<p>What do you mean? Can you explain?</p>",
        "id": 533581534,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754748913
    },
    {
        "content": "<p>The prime spectrum of Z with the Zariski topology is an example of a topological space failing ACC on closed subsets (it's closed subsets are finite subsets of the complement of the zero ideal and the whole space), but every closed subset is the closure of a finite subset (since the whole space is the closure of the generic point (the zero ideal)).<br>\n(Gemini came up with an equivalent example by constructing a topology on Nat adjoining a point.)</p>\n<p>Spaces satisfying ACC on closed subsets are called Artinian in some online posts, but it might be better to call them co-Noetherian, since they have nothing to do with Artinian rings.</p>",
        "id": 533583240,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754750874
    },
    {
        "content": "<p>oh I see where I went wrong</p>",
        "id": 533583450,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754751131
    },
    {
        "content": "<p>yeah that makes sense</p>",
        "id": 533583452,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754751135
    },
    {
        "content": "<p>yeah since it doesn't preserve filtered colimits</p>",
        "id": 533583492,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754751180
    },
    {
        "content": "<p><a href=\"https://mathoverflow.net/questions/93276/a-game-on-noetherian-rings\">https://mathoverflow.net/questions/93276/a-game-on-noetherian-rings</a> is apparently exactly the generalization of Sylver coinage to rings, also played under the misere convention (by requiring choosing a non-unit).</p>",
        "id": 533583694,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754751410
    },
    {
        "content": "<p>This paper is linked in the answers, might be an interesting thing to work towards formalizing.<br>\n<a href=\"https://arxiv.org/abs/1205.2884\">https://arxiv.org/abs/1205.2884</a></p>",
        "id": 533615173,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754793095
    },
    {
        "content": "<p>One issue of unifying poset games and Sylver coinage is that the positions in poset games are represented as sets of <strong>playable</strong> moves (in particular they're complements of closed sets), while in Sylver coinage they're usually represented as sets of <strong>played</strong> moves (contained in the closed sets of non-playable moves). If we want to unify both we'll need to change one of them ...</p>",
        "id": 533641613,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754821215
    },
    {
        "content": "<p>It seems much more natural to do the former. If after two sequences of moves you have the same options, it doesn't make much sense to distinguish them.</p>",
        "id": 533641795,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754821435
    },
    {
        "content": "<p>(In fact, by extensionality, these games would be equal)</p>",
        "id": 533641825,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754821460
    },
    {
        "content": "<p>Yeah, two sets with the same closure describe equivalent positions in Sylver coinage, so equal when passed to IGame/LGame. However, note that the number of played moves is always finite, but the number of playble moves is often infinite, so of course you see positions always described as sets of played moves in the literature.</p>",
        "id": 533642358,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754821934
    },
    {
        "content": "<p>I think that's just a matter of how we write the theorems. If f is the function returning the playable moves from a set of played moves, we can prove that the left moves of f s look like f (insert n s) for n such that (...)</p>",
        "id": 533734313,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754901495
    },
    {
        "content": "<blockquote>\n<p>It seems much more natural to do the former.</p>\n</blockquote>\n<p>IMO the latter (Sylver coinage's convention) is more natural because the position changes are just <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo>↦</mo><mi>s</mi><mo>∪</mo><mo stretchy=\"false\">{</mo><mi>a</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">s\\mapsto s\\cup\\{a\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.522em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5556em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">}</span></span></span></span> (and playable moves are <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mover accent=\"true\"><mi>s</mi><mo stretchy=\"true\">‾</mo></mover><mi>c</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\overline{s}^c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6849em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6306em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">s</span></span></span><span style=\"top:-3.5506em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6849em;\"><span style=\"top:-3.0835em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span></span></span>). While with the former (poset game's convention), the position changes come with double negation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo>⇝</mo><msup><mover accent=\"true\"><mrow><msup><mi>s</mi><mi>c</mi></msup><mo>∪</mo><mo stretchy=\"false\">{</mo><mi>a</mi><mo stretchy=\"false\">}</mo></mrow><mo stretchy=\"true\">‾</mo></mover><mi>c</mi></msup></mrow><annotation encoding=\"application/x-tex\">s\\rightsquigarrow\\overline{s^c\\cup\\{a\\}}^c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">⇝</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2543em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">}</span></span></span><span style=\"top:-3.87em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.25em;\"><span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0043em;\"><span style=\"top:-3.4029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span></span></span>, even though the playable are simply <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span>. (Here <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> denotes the set representing the position and overline denotes closure). Admittedly in the special case of poset games the position changes boil down to the simpler <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo>⇝</mo><mi>s</mi><mo>∖</mo><mover accent=\"true\"><mrow><mo stretchy=\"false\">{</mo><mi>a</mi><mo stretchy=\"false\">}</mo></mrow><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">s\\rightsquigarrow s\\setminus\\overline{\\{a\\}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">⇝</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2em;vertical-align:-0.25em;\"></span><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mopen\">{</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">}</span></span></span><span style=\"top:-3.87em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.25em;\"><span></span></span></span></span></span></span></span></span>, and if you play them on a finite poset the positions are finite under both conventions, but the latter convention still likely gives shorter description of the positions.</p>",
        "id": 533742413,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754903793
    },
    {
        "content": "<p>Hmm. Yeah, that double negation is annoying.</p>",
        "id": 533751099,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754906749
    },
    {
        "content": "<p>I guess we could do the former, and prove a lemma that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>s</mi><mo stretchy=\"true\">‾</mo></mover><mo>=</mo><mover accent=\"true\"><mi>t</mi><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline s = \\overline t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6306em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6306em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">s</span></span></span><span style=\"top:-3.5506em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8151em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8151em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span></span></span><span style=\"top:-3.7351em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span></span></span></span> then the games are equal.</p>",
        "id": 533751304,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754906822
    },
    {
        "content": "<p>Can't we just use the closure of the played moves to describe the position?</p>",
        "id": 533751608,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754906940
    },
    {
        "content": "<p>Since equal closures means equal games</p>",
        "id": 533751716,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754906978
    },
    {
        "content": "<p>How would that work?</p>",
        "id": 533751866,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754907021
    },
    {
        "content": "<p>wdym?</p>",
        "id": 533751966,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754907051
    },
    {
        "content": "<p>Surely requiring <code>toIGame</code> to take an argument <code>IsClosed s</code> is more annoying than to just make it take the closure internally.</p>",
        "id": 533752002,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754907061
    },
    {
        "content": "<p>oh yeah just don't do that</p>",
        "id": 533752101,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754907092
    },
    {
        "content": "<p>make it return junk values</p>",
        "id": 533752133,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754907102
    },
    {
        "content": "<p>none of the math for calculating the moves actually requires your set be closed</p>",
        "id": 533752189,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754907116
    },
    {
        "content": "<p>but every move will take you to a closed position since you take the closure</p>",
        "id": 533752392,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754907176
    },
    {
        "content": "<p>So from a position s the moves are to the closures of positions in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mover accent=\"true\"><mi>s</mi><mo stretchy=\"true\">‾</mo></mover><mi>c</mi></msup></mrow><annotation encoding=\"application/x-tex\">{\\overline s}^c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6849em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6306em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">s</span></span></span><span style=\"top:-3.5506em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6849em;\"><span style=\"top:-3.0835em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span></span></span>, is that what you're saying?</p>",
        "id": 533752596,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754907251
    },
    {
        "content": "<p>maybe I'm misunderstanding what this closure thing is</p>",
        "id": 533753746,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754907591
    },
    {
        "content": "<p>I've just been thinking about it like it's a topological space</p>",
        "id": 533753815,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754907614
    },
    {
        "content": "<p>I've been thinking of it like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subgroup.closure#doc\">docs#Subgroup.closure</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.span#doc\">docs#Ideal.span</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=upperClosure#doc\">docs#upperClosure</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IntermediateField.adjoin#doc\">docs#IntermediateField.adjoin</a></p>",
        "id": 533754253,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754907780
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/stream/518132-combinatorial-games/topic/Sylver.20coinage.20and.20ConcreteGame/near/533752133\">said</a>:</p>\n<blockquote>\n<p>make it return junk values</p>\n</blockquote>\n<p>Surely the junk value for s can just be the actual value for its closure?</p>",
        "id": 533754404,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754907838
    },
    {
        "content": "<p>but what does this closure operater represent again?</p>",
        "id": 533754405,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754907838
    },
    {
        "content": "<p>I have forgotten</p>",
        "id": 533754415,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754907843
    },
    {
        "content": "<p>The closure basically represents the moves you've exhausted</p>",
        "id": 533754536,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754907885
    },
    {
        "content": "<p>In the poset game it's the upper closure of your set</p>",
        "id": 533754557,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754907893
    },
    {
        "content": "<p>In Sylver coinage it's the span of your set</p>",
        "id": 533754599,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754907904
    },
    {
        "content": "<p>You can't choose positions in there</p>",
        "id": 533754618,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754907909
    },
    {
        "content": "<p>oh ok</p>",
        "id": 533754641,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754907917
    },
    {
        "content": "<p>so how do you plan to take this closure operator</p>",
        "id": 533754680,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754907933
    },
    {
        "content": "<p>Wdym by \"take it\"?</p>",
        "id": 533754704,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754907943
    },
    {
        "content": "<p>like as an argument</p>",
        "id": 533754736,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754907956
    },
    {
        "content": "<p>We can define a function <code>ClosureIGame f s</code> taking a closure operation <code>f</code> and a position <code>s</code></p>",
        "id": 533754875,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754907993
    },
    {
        "content": "<p>to your game building function</p>",
        "id": 533754877,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754907993
    },
    {
        "content": "<p>Then we can define poset games, Sylver coinage, etc. in terms of this</p>",
        "id": 533754930,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754908013
    },
    {
        "content": "<p>is <code>f</code> just a function? will I have to pass around the proof that it's a closure operator?</p>",
        "id": 533755015,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754908036
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ClosureOperator#doc\">docs#ClosureOperator</a> is a structure</p>",
        "id": 533755093,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754908061
    },
    {
        "content": "<p>can we use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LowerAdjoint#doc\">docs#LowerAdjoint</a> instead?</p>",
        "id": 533755211,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754908098
    },
    {
        "content": "<p>I noticed it in the same file</p>",
        "id": 533755246,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754908107
    },
    {
        "content": "<p>hmmm actually maybe not since it doesn't</p>",
        "id": 533755337,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754908135
    },
    {
        "content": "<p>ok yeah I have no idea</p>",
        "id": 533755366,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754908141
    },
    {
        "content": "<p>oh we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=GaloisInsertion#doc\">docs#GaloisInsertion</a></p>",
        "id": 533755631,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754908218
    },
    {
        "content": "<p>yknow what it actually doesn't matter to me how we represent the moves</p>",
        "id": 533757359,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754908698
    },
    {
        "content": "<p>anything that works is fine</p>",
        "id": 533757386,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754908707
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> I've completely redone <a href=\"https://github.com/vihdzp/combinatorial-games/pull/174\">#174</a>, making <code>ConcreteGame</code> into a single structure. This is definitely much cleaner! No need for type aliases all over the place anymore.</p>",
        "id": 533808592,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754923044
    },
    {
        "content": "<p>I do have a certain design question</p>",
        "id": 533810500,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754923692
    },
    {
        "content": "<p>Where should we put stuff like the poset to IGame function, or the domineering to IGame function?</p>",
        "id": 533810596,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754923720
    },
    {
        "content": "<p>Or more broadly, the material about these functions.</p>",
        "id": 533810745,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754923764
    },
    {
        "content": "<p>It feels weird to put the stuff about <code>PosetRel</code> in the root namespace. But it also feels weird putting it in <code>IGame</code> - what if we ever want to define a loopy poset game? And it also feels weird putting it in <code>LGame</code>.</p>",
        "id": 533810920,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754923819
    },
    {
        "content": "<p>What do you think about this:</p>\n<ul>\n<li>Put all the \"preliminary\" material about a given game in a namespace inside the <code>ConcreteGame</code> namespace, e.g. <code>ConcreteGame.Poset</code> for preliminaries on poset games, <code>ConcreteGame.Domineering</code> for preliminaries on domineering.</li>\n<li>Put results on <code>IGame</code>/<code>LGame</code>/whatever of these games in the appropriate namespace, e.g. <code>IGame.poset_univ_fuzzy_zero</code></li>\n</ul>",
        "id": 533811263,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754923930
    },
    {
        "content": "<p>I think I'd put everything under the ConcreteGame.&lt;NameOfGame&gt; namespace. Results about the corresponding abstract games might be distinguished by subscripts ᵢ ₗ  if IGame/LGame is too cumbersome to type.</p>",
        "id": 533848054,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754937831
    },
    {
        "content": "<p>I don't know how I feel about the subscript idea, but I guess we could define e.g. <code>ConcreteGame.Poset.toIGame</code> and <code>ConcreteGame.Poset.toLGame</code> and just write <code>toIGame</code> / <code>toLGame</code> in theorems.</p>",
        "id": 533850135,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1754938755
    },
    {
        "content": "<p>So, now that <code>ConcreteGame</code> has been refactored (twice), how should we use it to formalize this?</p>",
        "id": 535754329,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1755895916
    },
    {
        "content": "<p>I imagine <code>ClosureGame</code> would be the concrete game, which takes a closure operator <code>f</code> on <code>Set a</code>, where <code>moves s = (insert . s) '' (f s)^C</code></p>",
        "id": 535755027,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1755896274
    },
    {
        "content": "<p>Making an <code>LGame</code> from this is simple enough. But how would we state the well-foundedness condition?</p>",
        "id": 535755109,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1755896313
    },
    {
        "content": "<p>I think it'd have to be a case by case basis</p>",
        "id": 535755167,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1755896345
    },
    {
        "content": "<p>Well, before I do anything of the sort, there are a few more changes I want to do with <code>ConcreteGame</code>, so that the API fits Yuyang Zhao's refactor better: <a href=\"https://github.com/vihdzp/combinatorial-games/pull/210\">#210</a></p>",
        "id": 535767079,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1755904716
    },
    {
        "content": "<p>Though thinking about this a bit more... Would defining <code>closureGame</code> really gain us anything?</p>",
        "id": 535782556,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1755925648
    },
    {
        "content": "<p>Sure, both games are a special case of that, but is there anything whatsoever we can say about <code>closureGame</code> in the general case?</p>",
        "id": 535782574,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1755925679
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span></p>",
        "id": 537192366,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756776268
    },
    {
        "content": "<p>Sorry I've been busy lately. I wouldn't have the time to refactor posetGame using closureGame, and it probably is the easiest to add Sylver coinage directly rather than going through closureGame. Sylver coinage is removed from <a href=\"https://github.com/leanprover-community/mathlib4/pull/27743\">#27743</a> for now. However there's an issue about dependencies between projects downstream of mathlib that I communicated with <strong>Johan Commelin</strong> in private message:</p>\n<blockquote>\n<p>There are some open conjectures around Sylver coinage which I intend to PR to the formal conjectures repo. If the definition of Sylver coinage isn't in mathlib but only in combinatorial-games, then I think I either need to copy the code over to the formal conjectures repo, or else make combinatorial-games a dependency of formal conjectures (I'm not sure they'd accept this dependency).</p>\n</blockquote>",
        "id": 537883177,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1757082345
    },
    {
        "content": "<p>There are more conjectures about combinatorial games we could potentially add. One of them currently exists as a <code>proof_wanted</code>, being the inequality:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">proof_wanted</span><span class=\"w\"> </span><span class=\"n\">birthday_mul_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Surreal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">birthday</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">birthday</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">birthday</span>\n</code></pre></div>\n<p>I do think it probably makes sense to keep the repositories separate, though. The CGT repo is a bit volatile in its current state. We haven't yet had to seriously consider having downstream dependents.</p>",
        "id": 537978386,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757138429
    },
    {
        "content": "<p>I think the best thing is probably to re-define Sylver coinage as a game using machinery other than <code>IGame</code> (i.e. copy over the code you had about P-positions and such).</p>",
        "id": 537978477,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757138491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/518132-combinatorial-games/topic/Sylver.20coinage.20and.20ConcreteGame/near/537883177\">said</a>:</p>\n<blockquote>\n<p>I wouldn't have the time to refactor posetGame using closureGame</p>\n</blockquote>\n<p>I can do that, if that's what we want to do. My question is rather whether there are any benefits to doing so. Are there any theorems about either poset games or Sylver coinage that generalize to that setting? Or at the very least, is the construction of either game made simpler by establishing this common groundwork first?</p>",
        "id": 537978491,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757138514
    },
    {
        "content": "<p>I'd really like to have an answer to this. It's blocking work on both Sylver coinage and poset games.</p>",
        "id": 538476183,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757434540
    },
    {
        "content": "<p>I guess I could just try implementing <code>ClosureGame</code> and see how that goes</p>",
        "id": 538478130,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757435191
    },
    {
        "content": "<p>Ok yeah there are certainly a few nontrivial results we'd otherwise have to prove twice</p>",
        "id": 538480347,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757435910
    },
    {
        "content": "<p>One that immediately comes to mind is \"the positions accessible from the empty set are finite sets\"</p>",
        "id": 538480466,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757435947
    },
    {
        "content": "<p>There's also this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ClosureOperator</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">WellFoundedGT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subtype</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">IsClosed</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsWellFounded</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">closureGame</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">IsOption</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 538480802,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757436061
    },
    {
        "content": "<p>On a somewhat unrelated note, I realize that <code>ConcreteGame</code> isn't a very informative name</p>",
        "id": 538482654,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757436723
    },
    {
        "content": "<p>What do you think about renaming it to <code>GameGraph</code> or even just <code>Graph</code>?</p>",
        "id": 538482679,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757436731
    },
    {
        "content": "<p>Isn't it a bit weird that we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toLGame_congr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">closureGame</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toLGame</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">closureGame</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toLGame</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Why not just define the states of <code>closureGame</code> as <code>f.Closeds</code>?</p>",
        "id": 538499892,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757441194
    },
    {
        "content": "<p>sounds reasonable to me</p>",
        "id": 538502405,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1757442151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/518132-combinatorial-games/topic/Sylver.20coinage.20and.20ConcreteGame/near/538499892\">said</a>:</p>\n<blockquote>\n<p>Isn't it a bit weird that we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toLGame_congr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">closureGame</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toLGame</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">closureGame</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toLGame</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Why not just define the states of <code>closureGame</code> as <code>f.Closeds</code>?</p>\n</blockquote>\n<p>That's what I said</p>",
        "id": 538525813,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757449098
    },
    {
        "content": "<p>Just realized something cool: <code>WellQuasiOrderedLE a -&gt; WellFoundedLT (UpperSet a)</code></p>",
        "id": 538528423,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757450142
    },
    {
        "content": "<p>what's the LT on UpperSet</p>",
        "id": 538528509,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757450173
    },
    {
        "content": "<p><del>the wrong one</del></p>",
        "id": 538528547,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757450188
    },
    {
        "content": "<p>which one is that</p>",
        "id": 538528622,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757450222
    },
    {
        "content": "<p>Opposite of subset</p>",
        "id": 538533185,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757452478
    },
    {
        "content": "<p>oh well yeah that's literally one of the definitions</p>",
        "id": 538534454,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757453114
    }
]