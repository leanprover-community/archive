[
    {
        "content": "<p>In <code>BEq.lean</code>, I came across the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkMatch</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">header</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Header</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">indVal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">InductiveVal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">auxFunName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">discrs</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkDiscrs</span><span class=\"w\"> </span><span class=\"n\">header</span><span class=\"w\"> </span><span class=\"n\">indVal</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">alts</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAlts</span>\n<span class=\"w\">  </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">discrs</span><span class=\"o\">],</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">alts</span><span class=\"o\">:</span><span class=\"n\">matchAlt</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I think it separates every element of <code>discrs</code> with a comma, but I'm not sure. Where in the language reference is this documented? I worry I'm missing out on other features</p>",
        "id": 519873901,
        "sender_full_name": "Will Bradley",
        "timestamp": 1747930457
    },
    {
        "content": "<p>The core idea is that parsers generally have both a syntax for normal terms and a syntax for antiquotations.</p>\n<p>Here's the definition of <code>match</code> syntax: <a href=\"https://github.com/leanprover/lean4/blob/5e40f4af52c50ff670c2b09b87930b42ff30a6ba/src/Lean/Parser/Term.lean#L469\">https://github.com/leanprover/lean4/blob/5e40f4af52c50ff670c2b09b87930b42ff30a6ba/src/Lean/Parser/Term.lean#L469</a></p>\n<p>Notice that the discriminants appear using the <code>sepBy1 matchDiscr \", \"</code> parser. The <code>sepBy1 p s</code>'s parser also recognizes the antiquotation syntax <code>$[p]s*</code>. Antiquotations are parseable <em>everywhere</em>. For example, while this doesn't elaborate, it does parse:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">],</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>It's up to elaborators to make sense of it. For example, the syntax quotation <code> `(...)</code> notation knows to interpret a <code>sepBy1</code> antiquotation by taking the array inside and constructing the appropriate Syntax that <code>sepBy1</code> would generate itself.</p>\n<p>Without this point of view — that antiquotations come from the parsers themselves — it's easy to get the wrong idea of what's allowed and why they work! In particular, it's not that <code>$[$discrs],*</code> is a way to separate the <code>discrs</code> array with commas, but that it's a way to hook into the <code>sepBy1</code> that's there in the parser.</p>\n<p>By the way, the full form of this would be <code>$[$discrs:matchDiscr],*</code>. Often parsing can figure out which antiquotation it is supposed to be for, like in this case, but for a given syntax <code>foo</code>, the full form of the antiquotation it can parse is <code>$x:foo</code>, where <code>x</code> is an ident or a parenthesized term.</p>",
        "id": 519876616,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747931262
    },
    {
        "content": "<p>The Lean Language Reference has some documentation on antiquotations around here: <a href=\"https://lean-lang.org/doc/reference/latest///Notations-and-Macros/Macros/#quotation\">https://lean-lang.org/doc/reference/latest///Notations-and-Macros/Macros/#quotation</a></p>",
        "id": 519877661,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747931605
    }
]