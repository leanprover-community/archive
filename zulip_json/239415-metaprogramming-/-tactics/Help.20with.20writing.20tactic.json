[
    {
        "content": "<p>Hi, I need some guidance on writing tactics. The goal is to have a simple way to replace expressions in the goal with variables. Here's what I want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">introNames</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">C</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  This should introduce the following into the context:</span>\n<span class=\"cm\">    A : ℕ := 1</span>\n<span class=\"cm\">    B : ℕ := 2</span>\n<span class=\"cm\">    C : ℕ := 3</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>And it should be functionally the same as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> The obstacle? is how to find what A B C should be in the tactic -/</span>\n  <span class=\"n\">set</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span> <span class=\"k\">with</span> <span class=\"n\">hA</span>\n  <span class=\"n\">set</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"k\">with</span> <span class=\"n\">hB</span>\n  <span class=\"n\">set</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span> <span class=\"k\">with</span> <span class=\"n\">hC</span>\n  <span class=\"n\">change</span> <span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">C</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>It feels like some combination of <code>change</code> (of course) and <code>refine</code>, but I don't know how to implement it. The source code of the two tactics are huge...</p>",
        "id": 397966608,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698002611
    },
    {
        "content": "<p>Is using <code>set</code> instead of <code>let</code> closer to what you want?</p>",
        "id": 397967749,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698003830
    },
    {
        "content": "<p>Oh yeah forgot about that</p>",
        "id": 397967931,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698003983
    },
    {
        "content": "<p>Sorry I’m on phone right now but I will edit it when I get back.</p>",
        "id": 397967947,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698004013
    },
    {
        "content": "<p>After hours of struggling I at least learned how to make the hypotheses I want. Now I need to do the parsing step with A B C...<br>\nIt seems that all the work has been done already, since it's how <code>IsDefEq</code> work, but I don't know how to use it. Any help would be great.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">Usage: introNames ?A</span>\n<span class=\"cm\">It adds `A : Prop := &lt;target&gt;` and `hA : A = &lt;target&gt;` into the local context</span>\n<span class=\"cm\">Then replaces the entire goal with just `A` lmao</span>\n<span class=\"cm\">-/</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"introNames\"</span> <span class=\"o\">(</span><span class=\"n\">ppSpace</span> <span class=\"n\">colGt</span> <span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">introNames</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">te</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"n\">mayPostpone</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"n\">e</span> <span class=\"n\">none</span>\n    <span class=\"k\">match</span> <span class=\"n\">te</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Expr.mvar</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"bp\">←</span><span class=\"n\">getMCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">decls.find</span><span class=\"bp\">!</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">userName</span>\n      <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Ident</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"n\">name</span>\n      <span class=\"k\">let</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">Ident</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"bp\">$</span> <span class=\"n\">name.appendBefore</span> <span class=\"s2\">\"h\"</span>\n      <span class=\"k\">let</span> <span class=\"n\">goal</span> <span class=\"bp\">←</span> <span class=\"n\">getMainGoal</span>\n      <span class=\"k\">let</span> <span class=\"n\">val</span> <span class=\"bp\">←</span> <span class=\"n\">getMainTarget</span>\n      <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">fvar</span><span class=\"o\">,</span> <span class=\"n\">goal</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">goal.define</span> <span class=\"s2\">\"A\"</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">inferType</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"n\">val</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">intro1P</span>\n      <span class=\"n\">replaceMainGoal</span> <span class=\"o\">[</span><span class=\"n\">goal</span><span class=\"o\">]</span>\n      <span class=\"n\">evalTactic</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">try</span> <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">Term.exprToSyntax</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"k\">from</span> <span class=\"n\">rfl</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">))</span>\n      <span class=\"n\">evalTactic</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"k\">have</span> <span class=\"bp\">$</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">Term.exprToSyntax</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">))</span>\n      <span class=\"n\">dbg_trace</span> <span class=\"n\">f</span><span class=\"bp\">!</span><span class=\"s2\">\"POGGERS!\"</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"RHS is not a hole\"</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">12</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">introNames</span> <span class=\"bp\">?</span><span class=\"n\">A</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  ▶ 1 goal</span>\n<span class=\"cm\">  A : Prop := 1 + 1 + (2 + 2) + (3 + 3) = 12</span>\n<span class=\"cm\">  hA : A = (1 + 1 + (2 + 2) + (3 + 3) = 12)</span>\n<span class=\"cm\">  ⊢ A</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">done</span>\n</code></pre></div>",
        "id": 397977293,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698015206
    },
    {
        "content": "<p>Nice! You’re right to identify <code>isDefEq</code> as doing the important work!</p>\n<p>Broadly, the way I’d approach this is</p>\n<ol>\n<li><code>elabTermWithHoles</code> on the argument to collect the new metavariables.</li>\n<li><code>isDefEq</code> to unify with the goal type and assign them, figuring out what they have to be.</li>\n<li>Use the values of these assignments (but not the mvars themselves) to generate the local declarations, and add them to the original goal’s local context.</li>\n<li>Replace the metavariables in the expression we got with <code>elabTermWithHoles</code> not with their assignments, but with these new hypotheses</li>\n<li>change the goal target to this new goal</li>\n</ol>\n<p>But you might notice something tricky here: we assign the metavariables to figure out what they should be, but then go through and replace them with something that isn’t their assignment! What gives?</p>\n<p>One way to solve this is by abstracting the new metavariables as the arguments of a function first (iirc stuff surrounding <code>elimMVar</code> might be relevant), then creating temporary metavariables that exist just for the unification step to extract the necessary values, then adding the hypotheses and applying this function to the hypotheses we’ve made (and reducing).</p>\n<p>Another way is to assign them by isDefEq, backtrack the state so that they’re now unassigned (while keeping the assignments we found), then eventually assign them to the hypotheses we make!</p>\n<p>This is kind of a cheeky strategy but involves fewer manual transformations of the expressions in question into functions and back. However, the former involves less fiddling with the <code>MetaM</code> state (which tracks assignments). Which is preferable is, to my mind, a matter of taste. Maybe there’s an answer in terms of performance, though, I’m not sure.</p>\n<p>Now, if you want to rename these everywhere, you might want to rewrite the hypothesis types as well, but that’s fairly straightforward compared to the rest. :)</p>\n<p>I’d be happy to write up this code later, but if this is a “learning how to do it” situation instead of a “having it written” situation I’m also happy to refrain from doing so. :)</p>\n<p>Also I think <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> is working on something similar.</p>",
        "id": 397981554,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698019814
    },
    {
        "content": "<p>Thanks a lot for your answer, I will read and try out what you said when I wake :) It's probably best for me to try it myself rather than having someone write it for me &lt;3</p>",
        "id": 397981917,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698020169
    },
    {
        "content": "<p>What am I doing wrong here? In the Lean book on <code>isDefEq</code>, it gives this code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.Meta.mkFreshExprMVar</span> <span class=\"o\">(</span><span class=\"n\">Expr.const</span> <span class=\"bp\">`</span><span class=\"n\">Nat</span> <span class=\"o\">[])</span> <span class=\"o\">(</span><span class=\"n\">userName</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">expr1</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.mkAppN</span> <span class=\"o\">(</span><span class=\"n\">Expr.const</span> <span class=\"bp\">`</span><span class=\"n\">Nat.add</span> <span class=\"o\">[])</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Lean.mkNatLit</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">expr2</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.mkAppN</span> <span class=\"o\">(</span><span class=\"n\">Expr.const</span> <span class=\"bp\">`</span><span class=\"n\">Nat.add</span> <span class=\"o\">[])</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Lean.mkNatLit</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">Lean.mkNatLit</span> <span class=\"mi\">1</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">isEqual</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.Meta.isDefEq</span> <span class=\"n\">expr1</span> <span class=\"n\">expr2</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">isEqual</span> <span class=\"c1\">-- true</span>\n</code></pre></div>\n<p>However, my version with a tactic doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"s2\">\"testDefEq\"</span> <span class=\"o\">(</span><span class=\"n\">ppSpace</span> <span class=\"n\">colGt</span> <span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">testDefEq</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">$</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">ee</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermWithHoles</span> <span class=\"n\">e</span> <span class=\"n\">none</span> <span class=\"s2\">\"suffix\"</span> <span class=\"o\">(</span><span class=\"n\">allowNaturalHoles</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermWithHoles</span> <span class=\"n\">f</span> <span class=\"n\">none</span> <span class=\"s2\">\"suffix\"</span> <span class=\"o\">(</span><span class=\"n\">allowNaturalHoles</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n  <span class=\"n\">dbg_trace</span> <span class=\"n\">f</span><span class=\"bp\">!</span><span class=\"s2\">\"defeq : {←isDefEq ee ff}\"</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">testDefEq</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"c1\">-- false</span>\n</code></pre></div>",
        "id": 398053909,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698056267
    },
    {
        "content": "<p>Here's the <code>ee</code> and <code>ff</code> in my version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">ee</span> <span class=\"o\">:</span> <span class=\"n\">Eq.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"n\">HAdd.hAdd.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"n\">instHAdd.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"n\">instAddNat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">instOfNatNat</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">instOfNatNat</span> <span class=\"mi\">2</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"mi\">3</span> <span class=\"o\">(</span><span class=\"n\">instOfNatNat</span> <span class=\"mi\">3</span><span class=\"o\">))</span>\n<span class=\"n\">ff</span> <span class=\"o\">:</span> <span class=\"n\">Eq.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"n\">HAdd.hAdd.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"n\">instHAdd.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"n\">instAddNat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">instOfNatNat</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">?</span><span class=\"n\">_uniq.47755</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"mi\">3</span> <span class=\"o\">(</span><span class=\"n\">instOfNatNat</span> <span class=\"mi\">3</span><span class=\"o\">))</span>\n<span class=\"n\">defeq</span> <span class=\"o\">:</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>which should unify right? I can literally replace <code>?_uniq.47755</code> (as a string) with that <code>OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)</code> and it is an exact match :/</p>",
        "id": 398054541,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698056518
    },
    {
        "content": "<p>Perhaps this is a bit clearer<br>\n<a href=\"/user_uploads/3121/6t74i1QrnlHNFFJyJLcz-5W6/Screenshot-2023-10-23-at-11.38.57.png\">Screenshot-2023-10-23-at-11.38.57.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/6t74i1QrnlHNFFJyJLcz-5W6/Screenshot-2023-10-23-at-11.38.57.png\" title=\"Screenshot-2023-10-23-at-11.38.57.png\"><img src=\"/user_uploads/3121/6t74i1QrnlHNFFJyJLcz-5W6/Screenshot-2023-10-23-at-11.38.57.png\"></a></div>",
        "id": 398056931,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698057564
    },
    {
        "content": "<p>I have never used the <code>termWithHoles</code> but it seems to create opaque holes.  I wonder if that is the issue: Lean may not be able to assign those.  Did you try with a plain <code>elabTerm</code>?</p>",
        "id": 398057133,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698057641
    },
    {
        "content": "<p>I will try that. I used elabTermWithHoles since Thomas mentioned it up there :)</p>",
        "id": 398058695,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698058275
    },
    {
        "content": "<p>No, the isDefEq still doesn't work</p>",
        "id": 398059035,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698058423
    },
    {
        "content": "<p>I'm on mobile, but try to look at the <code>move_add</code> tactic: I have certainly unified similar terms with holes and it worked for my purpose.</p>",
        "id": 398059246,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698058495
    },
    {
        "content": "<p>Okay! Thanks</p>",
        "id": 398059307,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698058519
    },
    {
        "content": "<p>The <code>?A [unassignable]</code> in the defeq trace indicates that something is indeed creating opaque metavariables.</p>",
        "id": 398059376,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1698058550
    },
    {
        "content": "<p>Here</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/MoveAdd.lean#L407\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/MoveAdd.lean#L407</a></p>\n<p>Is the parsing, I think, earlier in the file there is an isDefEq check.  I hope that this helps!</p>",
        "id": 398059626,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698058653
    },
    {
        "content": "<p>Okay I understand (not really) what you two mean for \"opaque metavariables\" now, which led to a terrible solution</p>",
        "id": 398060212,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698058876
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gd\">-     dbg_trace f!\"defeq : {←isDefEq ee ff}\"</span>\n<span class=\"gi\">+     dbg_trace f!\"defeq : {←withAssignableSyntheticOpaque &lt;| isDefEq ee ff}\"</span>\n</code></pre></div>",
        "id": 398060252,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698058889
    },
    {
        "content": "<p>My vague understanding of this is that mvars are very willing to unify, which is sometimes desirable, sometimes not.  With elabTermsWithHoles you explicitly try to avoid \"random unification\".  With elabTerm, the holes should be more receptive.</p>\n<p>Having said that, I do not know if using <code>?A</code> instead of <code>_</code> for a hole has further implications.</p>",
        "id": 398061102,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698059251
    },
    {
        "content": "<p>Looking at this again, I think that</p>\n<ul>\n<li><code>elabTermWithHoles</code> will create an opaque metavariable that will not get unified in the <code>isDefEq</code> call</li>\n<li><code>elabTerm</code> produces live metavariables, but not if they are \"named\".</li>\n</ul>\n<p>So, using <code>elabTerm</code>, this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">testDefEq</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>gives <code>true</code>, but passing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">testDefEq</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>gives false.  With <code>elabTermWithHoles</code> it is <code>false</code> regardless.</p>\n<p>I do not know if your solution using <code>withAssignableSyntheticOpaque</code> is \"standard\", but seems a good way  to proceed, given the constraints.</p>",
        "id": 398066589,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698061418
    },
    {
        "content": "<p>I think the easiest solution here, though maybe not the \"cleanest\", is to set every hole to <code>.natural</code> instead of the opaque hole right now. However, this is giving me error...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> MRC -/</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab.Tactic</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"testDefEq\"</span> <span class=\"o\">(</span><span class=\"n\">ppSpace</span> <span class=\"n\">colGt</span> <span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">testDefEq</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">$</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">mvarIds</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermWithHoles</span> <span class=\"n\">f</span> <span class=\"n\">none</span> <span class=\"s2\">\"suffix\"</span> <span class=\"o\">(</span><span class=\"n\">allowNaturalHoles</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n    <span class=\"n\">mvarIds.mapM</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mvarId.setKind</span> <span class=\"bp\">.</span><span class=\"n\">natural</span>\n\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">▶ 214:5-214:55: error:</span>\n<span class=\"cm\">type mismatch</span>\n<span class=\"cm\">  mapM (fun mvarId =&gt; ?m.44983 mvarId) mvarIds</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  ReaderT Tactic.Context (StateRefT' IO.RealWorld Tactic.State TermElabM) (List ?m.44934) : Type</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  TacticM PUnit.{1} : Type</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 398066703,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698061448
    },
    {
        "content": "<p>Oh oops, we were typing at the same minute</p>",
        "id": 398066754,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698061467
    },
    {
        "content": "<p>I think that the error is telling you that you should be returning a unit, while you are returning a list of units: try</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">mvarIds.mapM</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mvarId.setKind</span> <span class=\"bp\">.</span><span class=\"n\">natural</span>\n</code></pre></div>",
        "id": 398067283,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698061640
    },
    {
        "content": "<p>Oh, that works, thanks</p>",
        "id": 398067515,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698061705
    },
    {
        "content": "<p>What does the <code>ReaderT Tactic.Context (StatRefT' IO.RealWorld Tactic.State TermElabM)</code> part mean?</p>",
        "id": 398067582,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698061735
    },
    {
        "content": "<p>See the comment at the top of <code>Lean.MetavarContext</code> for precise info about opaque mvars (and many other things besides).</p>\n<p>Usually Lean syntax uses <code>?A</code> for opaque metavariables and <code>?_A</code> for non-opaque mvars (I think), but if you only want non-opaque  mvars, then it makes sense to collect the opaque mvars and turn them into non-opaque ones, either via an option for <code>elabTerm*</code> if available or via your <code>mapM</code> hack. The <code>withAssignableSyntheticOpaque</code> may affect other mvars present in the goal, so it's probably less correct.</p>",
        "id": 398067859,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1698061838
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"579936\">Gareth Ma</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Help.20with.20writing.20tactic/near/398067582\">said</a>:</p>\n<blockquote>\n<p>What does the <code>ReaderT Tactic.Context (StatRefT' IO.RealWorld Tactic.State TermElabM)</code> part mean?</p>\n</blockquote>\n<p>This is the definition of <code>TacticM</code>, which apparently got unfolded somewhere during typechecking.</p>",
        "id": 398067945,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1698061883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Help.20with.20writing.20tactic/near/398067283\">said</a>:</p>\n<blockquote>\n<p>I think that the error is telling you that you should be returning a unit, while you are returning a list of units: try</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">mvarIds.mapM</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mvarId.setKind</span> <span class=\"bp\">.</span><span class=\"n\">natural</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Even better: <code>mvarIds.forM ...</code>, which avoids constructing the list entirely.</p>",
        "id": 398067994,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1698061902
    },
    {
        "content": "<p>Sorry for the many questions :/ but why is <code>?A</code> a bound variable</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab.Tactic</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"testDefEq\"</span> <span class=\"o\">(</span><span class=\"n\">ppSpace</span> <span class=\"n\">colGt</span> <span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">testDefEq</span> <span class=\"bp\">$</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">target</span> <span class=\"bp\">←</span> <span class=\"n\">getMainTarget</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">mvarIds</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermWithHoles</span> <span class=\"n\">f</span> <span class=\"n\">none</span> <span class=\"s2\">\"suffix\"</span> <span class=\"o\">(</span><span class=\"n\">allowNaturalHoles</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n    <span class=\"n\">mvarIds.forM</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mvarId.setKind</span> <span class=\"bp\">.</span><span class=\"n\">natural</span>\n    <span class=\"k\">let</span> <span class=\"n\">mvar</span> <span class=\"o\">:=</span> <span class=\"n\">mvarIds</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n    <span class=\"k\">let</span> <span class=\"n\">mctx</span> <span class=\"bp\">←</span> <span class=\"n\">getMCtx</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> mvar should be the `?A` -/</span>\n    <span class=\"n\">assert</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">mctx.decls.find</span><span class=\"bp\">!</span> <span class=\"n\">mvar</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">userName</span> <span class=\"bp\">=</span> <span class=\"s2\">\"A\"</span>\n    <span class=\"k\">if</span> <span class=\"bp\">←</span><span class=\"n\">isDefEq</span> <span class=\"n\">target</span> <span class=\"n\">ff</span> <span class=\"k\">then</span>\n      <span class=\"c\">/-</span><span class=\"cm\"> Now mvar should be set to 2 because of the isDefEq? -/</span>\n      <span class=\"n\">assert</span><span class=\"bp\">!</span> <span class=\"bp\">←</span><span class=\"n\">mvar.isAssigned</span>\n      <span class=\"k\">let</span> <span class=\"n\">mvarVal</span> <span class=\"o\">:=</span> <span class=\"n\">mctx.eAssignment.find</span><span class=\"bp\">!</span> <span class=\"n\">mvar</span>\n      <span class=\"c\">/-</span><span class=\"cm\"> Why is it a bound variable? -/</span>\n      <span class=\"c\">/-</span><span class=\"cm\"> kind : Lean.Expr.bvar 0 -/</span>\n      <span class=\"n\">dbg_trace</span> <span class=\"n\">f</span><span class=\"bp\">!</span><span class=\"s2\">\"kind : {repr mvarVal}\"</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"Not isDefEq\"</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">testDefEq</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span>\n</code></pre></div>\n<p>I don't understand how <code>isDefEq</code> works and how to use it</p>",
        "id": 398072007,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698063300
    },
    {
        "content": "<p>I tried to clean my code up so it's easier to read</p>",
        "id": 398072066,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698063324
    },
    {
        "content": "<p><code>mvar</code> is a metavariable corresponding to the goal that <code>?A</code> represents, that is, a natural number.   If you use</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>      <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"ff after: {ff}</span><span class=\"se\">\\n</span><span class=\"s2\">mvar: {mvar}\"</span>\n</code></pre></div>\n<p>you can see that <code>ff</code> is assigned to the right sum, and that mvar is a single goal with type Nat.  So Lean deduced that your <code>?A</code> represents a natural number.  If you place a</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"ff before: {ff}\"</span>\n</code></pre></div>\n<p>just before the <code>if isDefEq</code> you will see that <code>ff</code> contains an mvar.</p>",
        "id": 398077262,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698065153
    },
    {
        "content": "<p>Btw, if I remember correctly, in Lean 3 <code>ff</code> was what is now called <code>false</code>, so seeing it in your code always makes me a little anxious...</p>",
        "id": 398078828,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698065667
    },
    {
        "content": "<p>Aha I see, so the entire <code>ff</code> becomes the sum</p>",
        "id": 398086483,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698068069
    },
    {
        "content": "<p>But how should I extract \"what should ?A be replaced with\"? Since my tactic's goal is to eventually create a <code>let A := &lt;what A should be&gt;</code></p>",
        "id": 398086691,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698068143
    },
    {
        "content": "<p>I think this is where I should go back to Thomas' original reply and read the \"... you might notice something tricky here:\" part :P<br>\nThanks everyone for the help so far</p>",
        "id": 398086834,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698068183
    },
    {
        "content": "<p>Ohh I should use <code>getExprMVarAssignment?</code>!!</p>",
        "id": 398089281,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698068919
    },
    {
        "content": "<p>Wait, then from here it seems quite straightforward (I will regret saying this)</p>",
        "id": 398089328,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698068934
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"s2\">\"testDefEq\"</span> <span class=\"o\">(</span><span class=\"n\">ppSpace</span> <span class=\"n\">colGt</span> <span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">testDefEq</span> <span class=\"bp\">$</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">goal</span> <span class=\"bp\">←</span> <span class=\"n\">getMainGoal</span>\n    <span class=\"k\">let</span> <span class=\"n\">target</span> <span class=\"bp\">←</span> <span class=\"n\">getMainTarget</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">mvarIds</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermWithHoles</span> <span class=\"n\">f</span> <span class=\"n\">none</span> <span class=\"s2\">\"suffix\"</span> <span class=\"o\">(</span><span class=\"n\">allowNaturalHoles</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n    <span class=\"n\">mvarIds.forM</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mvarId.setKind</span> <span class=\"bp\">.</span><span class=\"n\">natural</span>\n    <span class=\"k\">let</span> <span class=\"n\">mvarId</span> <span class=\"o\">:=</span> <span class=\"n\">mvarIds</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n    <span class=\"k\">let</span> <span class=\"n\">mctx</span> <span class=\"bp\">←</span> <span class=\"n\">getMCtx</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> mvar should be the `?A` -/</span>\n    <span class=\"k\">let</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"bp\">←</span><span class=\"n\">getMCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">decls.find</span><span class=\"bp\">!</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">userName</span>\n    <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Ident</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"n\">name</span>\n    <span class=\"k\">let</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">Ident</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"bp\">$</span> <span class=\"n\">name.appendBefore</span> <span class=\"s2\">\"h\"</span>\n    <span class=\"n\">assert</span><span class=\"bp\">!</span> <span class=\"n\">name</span> <span class=\"bp\">=</span> <span class=\"s2\">\"A\"</span>\n\n    <span class=\"k\">if</span> <span class=\"bp\">←</span><span class=\"n\">isDefEq</span> <span class=\"n\">target</span> <span class=\"n\">ff</span> <span class=\"k\">then</span>\n      <span class=\"c\">/-</span><span class=\"cm\"> Now mvar should be set to 2 because of the isDefEq? -/</span>\n      <span class=\"n\">assert</span><span class=\"bp\">!</span> <span class=\"bp\">←</span><span class=\"n\">mvarId.isAssigned</span>\n      <span class=\"k\">let</span> <span class=\"n\">mvarVal</span> <span class=\"o\">:=</span> <span class=\"n\">mctx.eAssignment.find</span><span class=\"bp\">!</span> <span class=\"n\">mvarId</span>\n      <span class=\"c\">/-</span><span class=\"cm\"> Why is it a bound variable? -/</span>\n      <span class=\"c\">/-</span><span class=\"cm\"> kind : Lean.Expr.bvar 0 -/</span>\n      <span class=\"n\">logInfo</span> <span class=\"n\">f</span><span class=\"bp\">!</span><span class=\"s2\">\"ff : {ff}\"</span>\n      <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"mvar : {mvarId}\"</span>\n      <span class=\"n\">logInfo</span> <span class=\"n\">f</span><span class=\"bp\">!</span><span class=\"s2\">\"kind : {repr mvarVal}\"</span>\n\n      <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">getExprMVarAssignment</span><span class=\"bp\">?</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">mvarAss</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"ass : {mvarAss}\"</span>\n        <span class=\"k\">let</span> <span class=\"n\">mvarType</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">mvarAss</span>\n        <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">fvar</span><span class=\"o\">,</span> <span class=\"n\">goal</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">goal.define</span> <span class=\"s2\">\"A\"</span> <span class=\"n\">mvarType</span> <span class=\"n\">mvarAss</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">intro1P</span>\n        <span class=\"n\">replaceMainGoal</span> <span class=\"o\">[</span><span class=\"n\">goal</span><span class=\"o\">]</span>\n        <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"syn : {←delabToRefinableSyntax mvarAss}\"</span>\n        <span class=\"n\">evalTactic</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">Term.exprToSyntax</span> <span class=\"n\">mvarAss</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"k\">from</span> <span class=\"n\">rfl</span><span class=\"o\">]))</span>\n        <span class=\"n\">evalTactic</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"k\">have</span> <span class=\"bp\">$</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">Term.exprToSyntax</span> <span class=\"n\">mvarAss</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">))</span>\n      <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"what\"</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"Not isDefEq\"</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"bp\">-</span> <span class=\"mi\">3</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">testDefEq</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  ▶ 1 goal</span>\n<span class=\"cm\">  A : ℕ := 2 * (5 - 3)</span>\n<span class=\"cm\">  hA : A = 2 * (5 - 3)</span>\n<span class=\"cm\">  ⊢ 1 + A = 3</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>Very proud of myself for this :) All that remains is to do it for all the variables, but that's easy.<br>\nThanks everyone for the help once again!!!</p>",
        "id": 398093314,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698070040
    },
    {
        "content": "<p>Exactly what I want (I think)</p>",
        "id": 398093353,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698070053
    },
    {
        "content": "<p>Final code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"s2\">\"testDefEq\"</span> <span class=\"o\">(</span><span class=\"n\">ppSpace</span> <span class=\"n\">colGt</span> <span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">testDefEq</span> <span class=\"bp\">$</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">target</span> <span class=\"bp\">←</span> <span class=\"n\">getMainTarget</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">mvarIds</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermWithHoles</span> <span class=\"n\">f</span> <span class=\"n\">none</span> <span class=\"s2\">\"suffix\"</span> <span class=\"o\">(</span><span class=\"n\">allowNaturalHoles</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">mctx</span> <span class=\"bp\">←</span> <span class=\"n\">getMCtx</span>\n    <span class=\"n\">mvarIds.forM</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mvarId.setKind</span> <span class=\"bp\">.</span><span class=\"n\">natural</span>\n    <span class=\"k\">if</span> <span class=\"bp\">←</span><span class=\"n\">isDefEq</span> <span class=\"n\">target</span> <span class=\"n\">ff</span> <span class=\"k\">then</span>\n      <span class=\"n\">mvarIds.forM</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">goal</span> <span class=\"bp\">←</span> <span class=\"n\">getMainGoal</span>\n        <span class=\"k\">let</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">mctx.decls.find</span><span class=\"bp\">!</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">userName</span>\n        <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Ident</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"n\">name</span>\n        <span class=\"k\">let</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">Ident</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"bp\">$</span> <span class=\"n\">name.appendBefore</span> <span class=\"s2\">\"h\"</span>\n        <span class=\"n\">assert</span><span class=\"bp\">!</span> <span class=\"bp\">←</span><span class=\"n\">mvarId.isAssigned</span>\n        <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">getExprMVarAssignment</span><span class=\"bp\">?</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">mvarAss</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"k\">let</span> <span class=\"n\">mvarType</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">mvarAss</span>\n          <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">goal</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">goal.define</span> <span class=\"n\">name</span> <span class=\"n\">mvarType</span> <span class=\"n\">mvarAss</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">intro1P</span>\n          <span class=\"n\">replaceMainGoal</span> <span class=\"o\">[</span><span class=\"n\">goal</span><span class=\"o\">]</span>\n          <span class=\"c\">/-</span><span class=\"cm\"> Copied from `set ... with ...` -/</span>\n          <span class=\"n\">evalTactic</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">Term.exprToSyntax</span> <span class=\"n\">mvarAss</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"k\">from</span> <span class=\"n\">rfl</span><span class=\"o\">]))</span>\n          <span class=\"n\">evalTactic</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"k\">have</span> <span class=\"bp\">$</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">Term.exprToSyntax</span> <span class=\"n\">mvarAss</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">))</span>\n        <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"what\"</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"Not isDefEq\"</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"bp\">-</span> <span class=\"mi\">3</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">testDefEq</span> <span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  ▶ 1 goal</span>\n<span class=\"cm\">  A : ℕ := 1</span>\n<span class=\"cm\">  hA : A = 1</span>\n<span class=\"cm\">  B : ℕ := 2 * (5 - 3)</span>\n<span class=\"cm\">  hB : B = 2 * (5 - 3)</span>\n<span class=\"cm\">  ⊢ A + B = 3</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">done</span>\n</code></pre></div>",
        "id": 398095510,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698070648
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Help.20with.20writing.20tactic/near/397981554\">said</a>:</p>\n<blockquote>\n<p>...</p>\n<p>But you might notice something tricky here: we assign the metavariables to figure out what they should be, but then go through and replace them with something that isn’t their assignment! What gives?</p>\n<p>...</p>\n<p>Another way is to assign them by isDefEq, backtrack the state so that they’re now unassigned (while keeping the assignments we found), then eventually assign them to the hypotheses we make!</p>\n<p>This is kind of a cheeky strategy but involves fewer manual transformations of the expressions in question into functions and back. However, the former involves less fiddling with the <code>MetaM</code> state (which tracks assignments). Which is preferable is, to my mind, a matter of taste. Maybe there’s an answer in terms of performance, though, I’m not sure.</p>\n<p>Now, if you want to rename these everywhere, you might want to rewrite the hypothesis types as well, but that’s fairly straightforward compared to the rest. :)</p>\n</blockquote>\n<p>Also, I don't think the backtracking part is necessary. Or at least my code seems to work without doing any backtracking. I just get the assignments, make local hypotheses, then use <code>rewrite</code> and <code>have</code> (like how <code>set ... with ...</code> works)</p>",
        "id": 398095872,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698070757
    },
    {
        "content": "<p>Following some precedents in mathlib, this could be called <code>setm</code>, for <code>set with match</code>, similar to <code>congrm</code>.</p>",
        "id": 398108853,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698074453
    },
    {
        "content": "<p>Great! I will polish it and add some more features then make a PR :)</p>",
        "id": 398131911,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698083329
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"579936\">@Gareth Ma</span> it would be great if you could modify this to accept a location with the <code>at</code> syntax, so that you could do this for hypotheses too instead of just the main goal.</p>",
        "id": 398132712,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698083760
    },
    {
        "content": "<p>Also, I expect that once Scott answers my question <a href=\"#narrow/stream/287929-mathlib4/topic/fixes.20to.20simp.20regressions/near/398134511\">here</a> that the inclusion of <code>hA</code> and <code>hB</code> should be unnecessary, which currently clutters the tactic state.</p>",
        "id": 398135041,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698084801
    },
    {
        "content": "<p>Seems like it. It's easily fixable though after your question is fixed. I will add a note.</p>",
        "id": 398136545,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698085557
    },
    {
        "content": "<p>Very nice! :D However, there <em>is</em> a subtle reason I didn't suggest using <code>rewrite</code> in this case: a situation in which someone might not have their subexpressions named the way they want after using <code>rewrite</code>. Can you spot it?</p>",
        "id": 398138357,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698086437
    },
    {
        "content": "<p>(I am trying to come up with an example where ?A=1+1 and ?B=1+1+1 (which doesn't rewrite) but my tactic is working too well)</p>",
        "id": 398141177,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698087704
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"bp\">-</span> <span class=\"bp\">?</span><span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">A : ℕ := 4 + 0</span>\n<span class=\"cm\">B : ℕ := 3 + 1</span>\n<span class=\"cm\">hA : A = B</span>\n<span class=\"cm\">hB : B = 3 + 1</span>\n<span class=\"cm\">⊢ A - A = 0</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>Is this what you mean?</p>",
        "id": 398141854,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698087973
    },
    {
        "content": "<p>If so, can I just do a stupid <code>change</code> at the end to make it precisely what the user wants? As in here, I will add a <code>change A - B = _</code></p>",
        "id": 398142576,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698088336
    },
    {
        "content": "<p>Yep, that! When one is reducibly defeq to another, that’ll happen; and likewise when one is a subexpression of an expression which is reducibly defeq to another.</p>\n<p>Hmm, how do you know where <code>A</code> and <code>B</code> should be? And if we do know, why not just <code>change</code> and avoid the rewrite? (Well, we still might want to rewrite hypotheses, but at least avoid it on the goal)</p>",
        "id": 398143105,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698088610
    },
    {
        "content": "<p>Ah wait, the version above isn't the newest one, I made some modifications</p>",
        "id": 398143168,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698088650
    },
    {
        "content": "<p>Give me a second</p>",
        "id": 398143175,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698088653
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> todo: handle loc -/</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">setM</span><span class=\"o\">)</span> <span class=\"s2\">\"setm \"</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"n\">location</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">setm</span> <span class=\"bp\">$</span><span class=\"n\">expr</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> dbg_trace f!\"at : {loc}\" -/</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">pattern</span><span class=\"o\">,</span> <span class=\"n\">mvarIds</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermWithHoles</span> <span class=\"n\">expr</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">getMainTag</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">allowNaturalHoles</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n    <span class=\"n\">dbg_trace</span> <span class=\"n\">f</span><span class=\"bp\">!</span><span class=\"s2\">\"{pattern}\"</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> Named holes are by default syntheticOpaque and not assignable, so we change that -/</span>\n    <span class=\"n\">mvarIds.forM</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mvarId.setKind</span> <span class=\"bp\">.</span><span class=\"n\">natural</span>\n    <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Tactic.setm</span><span class=\"o\">]</span> <span class=\"s2\">\"pattern : {pattern}\"</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> We let isDefEq match the given pattern with the target specified (default: main goal) -/</span>\n    <span class=\"k\">let</span> <span class=\"n\">mctx</span> <span class=\"bp\">←</span> <span class=\"n\">getMCtx</span>\n    <span class=\"k\">let</span> <span class=\"n\">mdecls</span> <span class=\"o\">:=</span> <span class=\"n\">mctx.decls</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> TODO : Handle loc -/</span>\n    <span class=\"k\">if</span> <span class=\"bp\">←</span><span class=\"n\">isDefEq</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">getMainTarget</span><span class=\"o\">)</span> <span class=\"n\">pattern</span> <span class=\"k\">then</span>\n      <span class=\"n\">mvarIds.forM</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">mdecls.find</span><span class=\"bp\">!</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">userName</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">Name.anonymous</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">()</span>\n        <span class=\"bp\">|</span> <span class=\"n\">name</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"n\">name</span>\n          <span class=\"k\">let</span> <span class=\"n\">ha</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"bp\">$</span> <span class=\"n\">name.appendBefore</span> <span class=\"s2\">\"h\"</span>\n          <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">getExprMVarAssignment</span><span class=\"bp\">?</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n          <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">mvarAss</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">evalTactic</span> <span class=\"o\">(</span><span class=\"bp\">←`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">set</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">Term.exprToSyntax</span> <span class=\"n\">mvarAss</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"bp\">$</span><span class=\"n\">ha</span><span class=\"o\">))</span>\n          <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"File a bug report!\"</span>\n        <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{←getMainGoal}</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">throwError</span> <span class=\"n\">f</span><span class=\"bp\">!</span><span class=\"s2\">\"setm: pattern is not definitionally equal to the goal.\"</span>\n</code></pre></div>",
        "id": 398143286,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698088714
    },
    {
        "content": "<p>I use a <code>set</code> instead, but it runs into the same problem</p>",
        "id": 398143313,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698088732
    },
    {
        "content": "<p>I will be back in an hour or so</p>",
        "id": 398144014,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698089141
    },
    {
        "content": "<p>I think the process should look something like this:</p>\n<ol>\n<li>Take a some <code>stx</code> representing a term and traverse it with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.TSyntax.replaceM#doc\">docs#Lean.TSyntax.replaceM</a>. Whenever you come across the relevant piece of named syntax (e.g., a named hole <code>?a</code>), check if there is already a declaration in the context with that name (this is for when you have something repeated), if so, replace it with an atom of the same name. If not, create a new metavariable, and a local <code>let</code> declaration with the provided name, and replace it with an atom for that name.</li>\n<li>Call <code>change</code> on the modified <code>stx</code>, which should assign all the metavariables which were created.</li>\n</ol>",
        "id": 398162127,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698098644
    },
    {
        "content": "<p>Okay, I will try it... <code>replaceM</code> is used once in the entire codebase and without docs <span aria-label=\"tear\" class=\"emoji emoji-1f972\" role=\"img\" title=\"tear\">:tear:</span> Not ideal...</p>",
        "id": 398162620,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698098985
    },
    {
        "content": "<p>(Also, take everything I say with a grain of salt, I'm pretty new to metaprogamming <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span>)</p>",
        "id": 398162812,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698099082
    },
    {
        "content": "<p>You can't be newer than me, I started around 24 hours ago :P</p>",
        "id": 398162914,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698099139
    },
    {
        "content": "<p>~2 weeks isn't that much more!</p>",
        "id": 398162935,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698099159
    },
    {
        "content": "<p>I think it's easier to work with <code>Expr</code> instead of <code>Syntax</code>, so I probably need <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Util/ReplaceExpr.html#Lean.Expr.replace\">docs#Lean.Expr.replace</a> instead :D</p>",
        "id": 398162992,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698099204
    },
    {
        "content": "<p>Hmm... I don't <em>think</em> that's what you want, because you are dealing with actual syntax coming in.</p>",
        "id": 398163374,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698099448
    },
    {
        "content": "<p>Once you do <code>ElabTermWithHoles</code>, you have metavariables all throughout your resulting expression. You need to make local <code>let</code> declarations for all of them and then substitute back. Hmmm...., nevermind, I think you may be right.</p>",
        "id": 398163489,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698099521
    },
    {
        "content": "<p>I spent almost an hour debugging nothing... I thought <code>getMCtx</code> returns a pointer to the context (which should be \"global\"), but of course it doesn't</p>",
        "id": 398171010,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698104027
    },
    {
        "content": "<p>Anyways I am close, here is what I have</p>",
        "id": 398171017,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698104035
    },
    {
        "content": "<p>I agree that syntax should not be present here. :) Here's one way to do it, using the first option I presented (abstract the mvars) which might introduce you to some useful metaprogramming functions.</p>\n<ol>\n<li>after <code>elabTermWithHoles</code>, abstract the mvars you've collected using (I believe) <code>mkLambdaFVars</code>. Despite referring to fvars, I think it also works for mvars. This gets you an Expr which is a lambda.</li>\n<li>Use <code>lambdaMetaTelescope</code> on the resulting lambda to introduce these back as <em>new</em> metavariables.</li>\n<li>Use <code>isDefEq</code> to unify the result with the goal, assigning those new metavariables.</li>\n<li>Create local hypotheses using the new metavariables as the body and the names of the original metavariables. Collect the resulting expressions/fvars as you go.</li>\n<li>Assign your <em>original</em> metavariables to these resulting fvars.</li>\n<li><code>change</code> the goal to the original expression you got from elaboration, which now includes assigned mvars. (You don't need syntax; use the MetaM version.)</li>\n</ol>\n<p>Also, stylistic note: you should never really need to get the <code>mctx</code>. For most things, there's a function that does it, e.g. <code>getUsername</code>. :)</p>",
        "id": 398171023,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698104041
    },
    {
        "content": "<p>Oops, sorry, race condition :)</p>",
        "id": 398171070,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698104053
    },
    {
        "content": "<p>I am <em>very</em> close on mine, so I will finish it first :D</p>",
        "id": 398171525,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698104483
    },
    {
        "content": "<p>That's a neat trick I wouldn't have thought of: duplicating the expression with new mvars; nice.</p>",
        "id": 398171622,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698104567
    },
    {
        "content": "<p>That's what I am doing</p>",
        "id": 398171775,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698104711
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> : just read the tag and the thread properly . <span class=\"user-mention\" data-user-id=\"579936\">@Gareth Ma</span> , the tactic is pretty cool. Fwiw, I will continue working on my version in the coming weekend, since I see it as a learning exercise. I want to learn what I can get out of conv and working maximally within macros anyway.</p>",
        "id": 398171802,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698104757
    },
    {
        "content": "<p>Damn it's looking great</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">▶</span> <span class=\"mi\">97</span><span class=\"o\">:</span><span class=\"mi\">3</span><span class=\"bp\">-</span><span class=\"mi\">97</span><span class=\"o\">:</span><span class=\"mi\">7</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"o\">[</span><span class=\"n\">error</span> <span class=\"n\">when</span> <span class=\"n\">printing</span> <span class=\"n\">message</span><span class=\"o\">:</span> <span class=\"n\">unknown</span> <span class=\"n\">goal</span> <span class=\"o\">[</span><span class=\"n\">anonymous</span><span class=\"o\">]]</span>\n\n<span class=\"bp\">▶</span> <span class=\"mi\">97</span><span class=\"o\">:</span><span class=\"mi\">3</span><span class=\"bp\">-</span><span class=\"mi\">97</span><span class=\"o\">:</span><span class=\"mi\">7</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">unknown</span> <span class=\"n\">metavariable</span> <span class=\"bp\">'?</span><span class=\"o\">[</span><span class=\"n\">anonymous</span><span class=\"o\">]</span><span class=\"bp\">'</span>\n</code></pre></div>\n<p>My code is so messed up now that I am not sure it's worth anyone's time reading it :(</p>",
        "id": 398174240,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698106618
    },
    {
        "content": "<p>If anyone has some spare time to help debug and explain what went wrong I will greatly appreciate it :(</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">setM</span><span class=\"o\">)</span> <span class=\"s2\">\"setm \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">setm</span> <span class=\"bp\">$</span><span class=\"n\">expr</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">origPattern</span><span class=\"o\">,</span> <span class=\"n\">mvarIds</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermWithHoles</span> <span class=\"n\">expr</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">getMainTag</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">allowNaturalHoles</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> Named holes are by default syntheticOpaque and not assignable, so we change that -/</span>\n    <span class=\"n\">mvarIds.forM</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mvarId.setKind</span> <span class=\"bp\">.</span><span class=\"n\">natural</span>\n    <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Tactic.setm</span><span class=\"o\">]</span> <span class=\"s2\">\"origPattern : {origPattern}\"</span>\n\n    <span class=\"c\">/-</span><span class=\"cm\"> Create new placeholder mvars -/</span>\n    <span class=\"k\">let</span> <span class=\"n\">name</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">x.getDecl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">userName</span>\n    <span class=\"k\">let</span> <span class=\"n\">mvarIdsPairs</span> <span class=\"bp\">←</span> <span class=\"n\">mvarIds.mapM</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">mkFreshExprMVar</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"n\">userName</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span><span class=\"n\">name</span> <span class=\"n\">x</span><span class=\"o\">)))</span>\n    <span class=\"k\">let</span> <span class=\"n\">mvarIdsMap</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">HashMap.ofList</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">instBEqMVarId</span> <span class=\"n\">instHashableMVarId</span> <span class=\"n\">mvarIdsPairs</span>\n\n    <span class=\"c\">/-</span><span class=\"cm\"> newPattern is the placeholder pattern with a bunch of placeholder mvars -/</span>\n    <span class=\"k\">let</span> <span class=\"n\">newPattern</span> <span class=\"o\">:=</span> <span class=\"n\">origPattern.replace</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">mvar</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mvarIdsMap.find</span><span class=\"bp\">?</span> <span class=\"n\">x</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n    <span class=\"o\">)</span>\n\n    <span class=\"c\">/-</span><span class=\"cm\"> We let isDefEq match the given pattern -/</span>\n    <span class=\"k\">let</span> <span class=\"n\">mctx</span> <span class=\"bp\">←</span> <span class=\"n\">getMCtx</span>\n    <span class=\"k\">let</span> <span class=\"n\">mdecls</span> <span class=\"o\">:=</span> <span class=\"n\">mctx.decls</span>\n    <span class=\"k\">if</span> <span class=\"bp\">←</span><span class=\"n\">isDefEq</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">getMainTarget</span><span class=\"o\">)</span> <span class=\"n\">newPattern</span> <span class=\"k\">then</span>\n      <span class=\"c\">/-</span><span class=\"cm\"> We iterate over the (old, new) vars -/</span>\n      <span class=\"n\">mvarIdsPairs.forM</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">mvarIdOld</span><span class=\"o\">,</span> <span class=\"n\">mvarExprNew</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">mvarIdNew</span> <span class=\"o\">:=</span> <span class=\"n\">mvarExprNew.mvarId</span><span class=\"bp\">!</span>\n        <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">mdecls.find</span><span class=\"bp\">!</span> <span class=\"n\">mvarIdNew</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">userName</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">Name.anonymous</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">()</span>\n        <span class=\"bp\">|</span> <span class=\"n\">name</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"n\">name</span>\n          <span class=\"k\">let</span> <span class=\"n\">ha</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"bp\">$</span> <span class=\"n\">name.appendBefore</span> <span class=\"s2\">\"h\"</span>\n          <span class=\"k\">let</span> <span class=\"n\">goal</span> <span class=\"bp\">←</span> <span class=\"n\">getMainGoal</span>\n          <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">getExprMVarAssignment</span><span class=\"bp\">?</span> <span class=\"n\">mvarIdNew</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n          <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">mvarAss</span> <span class=\"bp\">=&gt;</span>\n            <span class=\"c\">/-</span>\n<span class=\"cm\">            Here mvarIdNew is assigned to mvarAss, and mvarIdOld &lt;-&gt; mvarIdNew, so I</span>\n<span class=\"cm\">              (1) let $a := mvarAss -- Here fvarId stores $a (?)</span>\n<span class=\"cm\">              (2) have $ha : $a = mvarAss := rfl</span>\n<span class=\"cm\">              (3) assign $a to mvarIdOld</span>\n<span class=\"cm\">            -/</span>\n            <span class=\"c\">/-</span><span class=\"cm\"> (1) -/</span>\n            <span class=\"k\">let</span> <span class=\"n\">mvarType</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">mvarAss</span>\n            <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">fvarId</span><span class=\"o\">,</span> <span class=\"n\">goal</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">goal.define</span> <span class=\"n\">a.getId</span> <span class=\"n\">mvarType</span> <span class=\"n\">mvarAss</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">intro1P</span>\n            <span class=\"n\">replaceMainGoal</span> <span class=\"o\">[</span><span class=\"n\">goal</span><span class=\"o\">]</span>\n            <span class=\"c\">/-</span><span class=\"cm\"> (2) -/</span>\n            <span class=\"n\">evalTactic</span> <span class=\"o\">(</span><span class=\"bp\">←`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"k\">have</span> <span class=\"bp\">$</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">Term.exprToSyntax</span> <span class=\"n\">mvarAss</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">))</span>\n            <span class=\"c\">/-</span><span class=\"cm\"> (3) -/</span>\n            <span class=\"n\">mvarIdOld.assign</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">fvar</span> <span class=\"n\">fvarId</span><span class=\"o\">)</span>\n          <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"File a bug report!\"</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">throwError</span> <span class=\"n\">f</span><span class=\"bp\">!</span><span class=\"s2\">\"setm: pattern is not definitionally equal to the goal.\"</span>\n\n    <span class=\"c\">/-</span><span class=\"cm\"> At the end, all the original mvars are replaced with the new fvars -/</span>\n    <span class=\"n\">replaceMainGoal</span> <span class=\"o\">[</span><span class=\"n\">origPattern.mvarId</span><span class=\"bp\">!</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"bp\">-</span> <span class=\"bp\">?</span><span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"n\">done</span>\n</code></pre></div>",
        "id": 398174697,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698106935
    },
    {
        "content": "<p>Ah I know, the <code>fvar</code> are bound variables, but origPattern doesn't include those uh bounds</p>",
        "id": 398174885,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698107095
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gd\">-     replaceMainGoal [origPattern.mvarId!]</span>\n<span class=\"gi\">+     evalTactic (←`(tactic| change $(←Term.exprToSyntax origPattern)))</span>\n</code></pre></div>\n<p>Done!</p>",
        "id": 398175052,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698107226
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/MRUXIiasZ11JuIxatoaPP7Tc/Screenshot-2023-10-24-at-01.27.17.png\">Screenshot-2023-10-24-at-01.27.17.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/MRUXIiasZ11JuIxatoaPP7Tc/Screenshot-2023-10-24-at-01.27.17.png\" title=\"Screenshot-2023-10-24-at-01.27.17.png\"><img src=\"/user_uploads/3121/MRUXIiasZ11JuIxatoaPP7Tc/Screenshot-2023-10-24-at-01.27.17.png\"></a></div><p>Sorry for the spam, though I don't think anyone receives any notifications <a href=\"https://github.com/zulip/zulip/issues/12309\">anyways</a>... but it works now</p>",
        "id": 398175173,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698107304
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> About your first two points using <code>mkLambdaFVars</code> and <code>lambdaMetaTelescope</code>, it seems I used a completely different method:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"c\">/-</span><span class=\"cm\"> Create new placeholder mvars -/</span>\n    <span class=\"k\">let</span> <span class=\"n\">name</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">x.getDecl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">userName</span>\n    <span class=\"k\">let</span> <span class=\"n\">mvarIdsPairs</span> <span class=\"bp\">←</span> <span class=\"n\">mvarIds.mapM</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">mkFreshExprMVar</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"n\">userName</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span><span class=\"n\">name</span> <span class=\"n\">x</span><span class=\"o\">)))</span>\n    <span class=\"k\">let</span> <span class=\"n\">mvarIdsMap</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">HashMap.ofList</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">instBEqMVarId</span> <span class=\"n\">instHashableMVarId</span> <span class=\"n\">mvarIdsPairs</span>\n\n    <span class=\"c\">/-</span><span class=\"cm\"> newPattern is the placeholder pattern with a bunch of placeholder mvars -/</span>\n    <span class=\"k\">let</span> <span class=\"n\">newPattern</span> <span class=\"o\">:=</span> <span class=\"n\">origPattern.replace</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">mvar</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mvarIdsMap.find</span><span class=\"bp\">?</span> <span class=\"n\">x</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n    <span class=\"o\">)</span>\n</code></pre></div>\n<p>Is it doing the same thing as what you are saying? (the <code>mvarIdsMap</code> isn't really necessary, but speeds up <code>newPattern</code> a bit I guess)</p>",
        "id": 398176002,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698107851
    },
    {
        "content": "<p>Oh, very nice! <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> Yes, that should be doing the same thing—I think. I'm not completely sure what the business with the cache occurring in <code>replace</code> is. Anyway, replacing the mvars with new ones directly is a good deal better than going through a lambda and back, I'd think! Nice work! :)</p>\n<p>I've got a list of technical and stylistic comments; would you like to hear them? Or I can save them for github if you like; feel free to make a PR and just label it WIP if you're still polishing things. :)</p>",
        "id": 398180424,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698110429
    },
    {
        "content": "<p>When you make the PR, please link both to this thread, and to the one where the tactic was originally mentioned.</p>",
        "id": 398189153,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698115198
    },
    {
        "content": "<p>Sorry I fell asleep last night, I'll open a draft PR</p>",
        "id": 398222547,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698131866
    },
    {
        "content": "<p>GH PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/7890\">here</a>, there's some work I know of, but styling suggestions are greatly appreciated <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span></p>",
        "id": 398224933,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698132714
    },
    {
        "content": "<p>Nice, will review tomorrow! :)</p>",
        "id": 398226229,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698133271
    },
    {
        "content": "<p>I think there should also be a <code>dsetm</code> or something, where you just remove the variables set by the previous <code>setm</code>. Is that possible? Can we either maintain some global set of variables set by <code>setm</code>, or perhaps add a tag to the variables created by <code>setm</code>?</p>",
        "id": 398234470,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698136017
    },
    {
        "content": "<p>This is the use case that inspired this tactic</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">setm</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">B</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">C</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">D</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">E</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">F</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"bp\">𝕜</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">+</span> <span class=\"n\">C</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"bp\">+</span> <span class=\"n\">E</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"n\">C</span> <span class=\"bp\">-</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">-</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"kd\">by</span> <span class=\"n\">intros</span> <span class=\"bp\">;</span> <span class=\"n\">ring_nf</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hA</span><span class=\"o\">,</span> <span class=\"n\">hB</span><span class=\"o\">,</span> <span class=\"n\">hC</span><span class=\"o\">,</span> <span class=\"n\">hD</span><span class=\"o\">,</span> <span class=\"n\">hE</span><span class=\"o\">,</span> <span class=\"n\">hF</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span> <span class=\"bp\">;</span> <span class=\"n\">clear</span> <span class=\"n\">A</span> <span class=\"n\">hA</span> <span class=\"n\">B</span> <span class=\"n\">hB</span> <span class=\"n\">C</span> <span class=\"n\">hC</span> <span class=\"n\">D</span> <span class=\"n\">hD</span> <span class=\"n\">E</span> <span class=\"n\">hE</span> <span class=\"n\">F</span> <span class=\"n\">hF</span> <span class=\"c\">/-</span><span class=\"cm\"> Probably doable with a tactic -/</span>\n</code></pre></div>\n<p>It will be nice if the third line is just <code>dsetm</code><br>\nOr do some indented-based stuff similar to <code>conv</code>, but that sounds hard :P</p>",
        "id": 398234922,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698136125
    },
    {
        "content": "<p>All mechanisms for tracking state between tactic calls suck in some way. You can try to wrap the hypothesis types with an <code>mdata</code>, but some tactics may not preserve the <code>mdata</code>. You can turn <code>setm</code> into a scoped tactic (<code>setm ... =&gt; ...</code>) and remember the <code>FVarId</code>s you introduced at the start, but tactics using the revert-intro technique may modify <code>FVarId</code>s. You can also remember the user names of the introduced hypotheses, but these too can change. So I sadly don't see a reliable way to implement this.</p>",
        "id": 398269034,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1698147259
    },
    {
        "content": "<p>Hi, there seems to be a bug with my tactic and I don't know how to fix it. The problem is I can't use the tactic twice with the same variable names, since (I think) the second <code>?A</code> will get replaced by the previous definition of <code>A</code>. For example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">8</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"bp\">*</span> <span class=\"bp\">?</span><span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"n\">unfold_let</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">clear</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">hA</span> <span class=\"n\">hB</span>\n  <span class=\"n\">change</span> <span class=\"mi\">4</span> <span class=\"bp\">+</span> <span class=\"mi\">4</span> <span class=\"bp\">=</span> <span class=\"mi\">8</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Trace for the first <code>setm</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">▶</span> <span class=\"mi\">8</span><span class=\"o\">:</span><span class=\"mi\">3</span><span class=\"bp\">-</span><span class=\"mi\">8</span><span class=\"o\">:</span><span class=\"mi\">27</span><span class=\"o\">:</span> <span class=\"n\">information</span><span class=\"o\">:</span>\n<span class=\"n\">mvarIds</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">Lean.Name.mkNum</span> <span class=\"bp\">`</span><span class=\"n\">_uniq</span> <span class=\"mi\">316</span><span class=\"o\">,</span> <span class=\"n\">Lean.Name.mkNum</span> <span class=\"bp\">`</span><span class=\"n\">_uniq</span> <span class=\"mi\">319</span><span class=\"o\">,</span> <span class=\"n\">Lean.Name.mkNum</span> <span class=\"bp\">`</span><span class=\"n\">_uniq</span> <span class=\"mi\">321</span><span class=\"o\">]</span>\n\n<span class=\"bp\">▶</span> <span class=\"mi\">8</span><span class=\"o\">:</span><span class=\"mi\">3</span><span class=\"bp\">-</span><span class=\"mi\">8</span><span class=\"o\">:</span><span class=\"mi\">27</span><span class=\"o\">:</span> <span class=\"n\">information</span><span class=\"o\">:</span>\n<span class=\"o\">[</span><span class=\"n\">Tactic.setm</span><span class=\"o\">]</span> <span class=\"n\">origPattern</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"bp\">*</span> <span class=\"bp\">?</span><span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">m.321</span>\n</code></pre></div>\n<p>Trace for the second <code>setm</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">▶</span> <span class=\"mi\">12</span><span class=\"o\">:</span><span class=\"mi\">3</span><span class=\"bp\">-</span><span class=\"mi\">12</span><span class=\"o\">:</span><span class=\"mi\">27</span><span class=\"o\">:</span> <span class=\"n\">information</span><span class=\"o\">:</span>\n<span class=\"n\">mvarIds</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">Lean.Name.mkNum</span> <span class=\"bp\">`</span><span class=\"n\">_uniq</span> <span class=\"mi\">735</span><span class=\"o\">]</span>\n\n<span class=\"bp\">▶</span> <span class=\"mi\">12</span><span class=\"o\">:</span><span class=\"mi\">3</span><span class=\"bp\">-</span><span class=\"mi\">12</span><span class=\"o\">:</span><span class=\"mi\">27</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">setm</span><span class=\"o\">:</span> <span class=\"n\">pattern</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">the</span> <span class=\"n\">goal.</span>\n\n<span class=\"bp\">▶</span> <span class=\"mi\">12</span><span class=\"o\">:</span><span class=\"mi\">3</span><span class=\"bp\">-</span><span class=\"mi\">12</span><span class=\"o\">:</span><span class=\"mi\">27</span><span class=\"o\">:</span> <span class=\"n\">information</span><span class=\"o\">:</span>\n<span class=\"o\">[</span><span class=\"n\">Tactic.setm</span><span class=\"o\">]</span> <span class=\"n\">origPattern</span> <span class=\"o\">:</span> <span class=\"mi\">4</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">m.735</span>\n</code></pre></div>\n<p>Then it fails with the error.</p>",
        "id": 398283897,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698152335
    },
    {
        "content": "<p>This is actually one of the technical notes I was going to bring up on GitHub <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> Basically, once that metavariable <code>?A</code> exists, it’s still accessible even when assigned. You’ll want to set the usernames of all the mvars to something inaccessible at the end of the tactic to prevent this.</p>\n<p>I think it’d be helpful if we had standard mechanisms for avoiding this instead of just going through and writing <code>g.setUsername …</code>, but the thread I started in this stream (<a class=\"stream-topic\" data-stream-id=\"239415\" href=\"/#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Hide.20intermediate.20goals.20from.20user.3F\">#metaprogramming / tactics &gt; Hide intermediate goals from user?</a>) didn’t get any traction, so I never made a PR :P</p>",
        "id": 398330990,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698167882
    },
    {
        "content": "<p>Ahhhhh okay. I also tried unsetting the .assign but that didn’t fix the problem. How do I get an inaccessible name?</p>",
        "id": 398332005,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698168389
    },
    {
        "content": "<p>Or like just .anonymous?</p>",
        "id": 398332061,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698168412
    },
    {
        "content": "<p>The method I use in the linked thread is just to append <code>\"✝\"</code>, but that's a bit of a hack. <code>.anonymous</code> would probably work. Maybe a better way is to append some randomly generated numbers like happens automatically for metavariables created without a name (e.g. <code>?m.32124</code>), but I'd need to double-check if this actually prevents e.g. <code>?m</code> alone from referring to it.</p>",
        "id": 398332387,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698168571
    },
    {
        "content": "<p>This should be possible with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Core.mkFreshUserName#doc\">docs#Lean.Core.mkFreshUserName</a></p>",
        "id": 398332915,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698168794
    },
    {
        "content": "<p>(Also btw I was wrong when I mentioned earlier about <code>getUsername</code> existing! We have <code>FVarId.getUserName</code>, but the canonical way for mvars is <code>(← mvar.getDecl).userName</code>. For some reason. :P)</p>",
        "id": 398335266,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698169830
    },
    {
        "content": "<p>True, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.setUserName#doc\">docs#Lean.MVarId.setUserName</a> exists.</p>",
        "id": 398336064,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698170209
    },
    {
        "content": "<p>Yep! It’s just <code>get</code>ting that doesn’t have a name. (I was referring to a message way back where I mentioned <code>getUserName</code>.)</p>",
        "id": 398337419,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698170759
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span>  and <span class=\"user-mention\" data-user-id=\"579936\">@Gareth Ma</span> , there is one thing this can't do yet: <code>?a + _ = ?b</code></p>",
        "id": 398338116,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698171076
    },
    {
        "content": "<p>This is because of the <code>allowNaturalHoles := true</code> which is necessary because we're not supplying the expected type.</p>",
        "id": 398338246,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698171133
    },
    {
        "content": "<p>Do you want to take over this instead?</p>",
        "id": 398338250,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698171137
    },
    {
        "content": "<p>You're getting ahead of all my comments, I better not wait any longer! :D</p>",
        "id": 398338257,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698171139
    },
    {
        "content": "<p>So, what we want to do there is split the mvarIds we get by kind. The <code>?a</code> ones are still <code>syntheticOpaque</code> even when <code>allowNaturalHoles := true</code>.</p>",
        "id": 398338318,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698171182
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"579936\">Gareth Ma</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Help.20with.20writing.20tactic/near/398338250\">said</a>:</p>\n<blockquote>\n<p>Do you want to take over this instead?</p>\n</blockquote>\n<p>Nope, you're doing great!</p>",
        "id": 398338353,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698171200
    },
    {
        "content": "<p>We want to keep the non-<code>.syntheticOpaque</code> ones around just to make sure they're assigned at the end of the day, but we only want to do our local decl stuff with the ones that started off as <code>.syntheticOpaque</code>.</p>",
        "id": 398338527,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698171257
    },
    {
        "content": "<p>Does that make sense?</p>",
        "id": 398338613,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698171306
    },
    {
        "content": "<p>But we still have the problem that we can't <code>elabTermWithHoles</code> something like <code>?a - ?b = _</code> without adding type ascriptions (it can't synthesize an instance) because were passing <code>none</code> as the expected type.</p>",
        "id": 398338867,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698171433
    },
    {
        "content": "<p>Oh, hmm, in that case we probably also need to say that we can postpone the synthesis of mvars.</p>",
        "id": 398339026,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698171495
    },
    {
        "content": "<p>Does <code>elabTermWithHoles</code> have an argument for doing that?</p>",
        "id": 398339045,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698171507
    },
    {
        "content": "<p>no</p>",
        "id": 398339201,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698171589
    },
    {
        "content": "<p>Ah, apparently not. It's not too much trouble to define it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">elabTermWithHolesPostponing</span> <span class=\"o\">(</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tagSuffix</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">allowNaturalHoles</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TacticM</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">withCollectingNewGoalsFrom</span> <span class=\"o\">(</span><span class=\"n\">elabTermEnsuringType</span> <span class=\"n\">stx</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"n\">tagSuffix</span> <span class=\"n\">allowNaturalHoles</span>\n</code></pre></div>",
        "id": 398339214,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698171596
    },
    {
        "content": "<p>(All we've modified is the argument <code>true</code> to <code>elabTermEnsuringType</code> which lets mvars be postponed.)</p>",
        "id": 398339366,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698171650
    },
    {
        "content": "<p>We'll then want to perform <code>isDefEq</code> to unify what we can, then execute <code>Term.synthesizeSyntheticMVarsNoPostponing</code>. (Note: <code>.synthetic</code> mvars are for typeclass synthesis; <code>.syntheticOpaque</code> are (generally) for user assignment.)</p>",
        "id": 398339593,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698171748
    },
    {
        "content": "<p>Ok, that's a good chance to mention another technical thing, which I think is better to mention here than on GitHub so that I can introduce it from scratch: there's a thing called the metavariable context depth. It's just a number that lives in part of the <code>MetaM</code> state, and determines which metavariables are assignable. Each metavariable remembers the depth it was created at (and we say that such an mvar is \"at\" that depth). Only metavariables at the current depth or deeper can be assigned.</p>\n<p>This lets us prevent assignment of earlier mvars via <code>withNewMCtxDepth</code>, which executes its (monadic) argument at a higher (deeper) depth. You'll see this a lot in front of <code>isDefEq</code>, since we want to be \"polite\" and not assign any already-present mvars with our <code>isDefEq</code> check.</p>\n<p>In this situation, we can't put <code>withNewMCtxDepth</code> directly in front of <code>isDefEq</code>, since that would prevent the mvars from <code>elabTermWithHolesPostponing</code> to not be able to be assigned either. Instead, we want to create the mvars at the new depth as well.</p>\n<p>So that's all to say: <code>withNewMCtxDepth</code> should go in front of the bulk of this tactic. :)</p>",
        "id": 398340620,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698172142
    },
    {
        "content": "<p>Also btw, <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>, are you now taking this over/working on this as well? I see some commits from you on the PR.</p>",
        "id": 398340997,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698172268
    },
    {
        "content": "<p>Oh whoops, I see you said you weren't taking it over. So I guess, which parts do you want to work on and which parts is Gareth working on? Just so I know how to direct my comments, lol. :)</p>",
        "id": 398341097,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698172305
    },
    {
        "content": "<p>I'm not taking over, I just pushed a few commits I mentioned to Gareth, but I'll be done and let him go for it unless he explicitly asks for my help.</p>",
        "id": 398341234,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698172339
    },
    {
        "content": "<p>Ah I see, cool!</p>",
        "id": 398341337,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698172381
    },
    {
        "content": "<p>I've got to go soon, but before I do, here's my list of suggested changes, including ones we've discussed for summary:</p>\n<ul>\n<li><code>withNewMCtxDepth</code> (discussed above)</li>\n<li>rename the intermediate mvars (discussed above)</li>\n<li>use <code>elabTermWithHolesPostponing</code> in conjunction with <code>Term.synthesizeSyntheticMVarsNoPostPoning</code> after <code>isDefEq</code> to handle instances (discussed above)</li>\n<li>We should automatically generate sensible names for any <code>?_</code> that appears in the pattern</li>\n<li>We should probably have a <em>secondary</em> location: <code>in &lt;loc&gt;</code>. This would determine what actually gets the new fvars substituted in. E.g. if you wanted to substitute everywhere by renaming things in <code>h</code>, <code>setm ... at h in *</code></li>\n<li>We want to take care to make sure the <code>rfl</code> equations are asserted at the right point, and maybe give the option to not insert them as hypotheses at all</li>\n</ul>",
        "id": 398342942,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698173108
    },
    {
        "content": "<p>yeah, the <code>rfl</code> equations should go away once <a href=\"https://github.com/leanprover/lean4/pull/2734\">lean4#2734</a> lands in mathlib because they will be unnecessary.</p>",
        "id": 398344030,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698173647
    },
    {
        "content": "<p>I'm not sure how you would intend to generate sensible names for arbitrary (sub)expressions marked by <code>?_</code>.</p>",
        "id": 398344148,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698173716
    },
    {
        "content": "<p>I need some time to catch up on the discussion, but I will work on this. Thanks for the review, Thomas :)</p>",
        "id": 398349996,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698176492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Help.20with.20writing.20tactic/near/398344148\">said</a>:</p>\n<blockquote>\n<p>I'm not sure how you would intend to generate sensible names for arbitrary (sub)expressions marked by <code>?_</code>.</p>\n</blockquote>\n<p>Yeah, I was wondering if there were any existing tools for heuristic naming! E.g. terms of <code>Prop</code>s should be named <code>h</code>, <code>Nat</code>'s should be named <code>n</code>, <code>List</code>s should be named <code>l</code>, etc., with as many subscripts as necessary to distinguish them from existing names in the context... if not it might be worth making such a tool. (In that case though we can just name the expressions <code>a</code> with a suffix or something here for now.)</p>",
        "id": 398354917,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698178641
    },
    {
        "content": "<p>I don't think we should do that. It kind of goes against the idea of hygienic naming (at least in spirit, even if not in letter). I think the user should <em>always</em> supply names if they want things introduced into the context.</p>",
        "id": 398355330,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698178845
    },
    {
        "content": "<p>Hmmm. I still think it would be useful to not have to name things yourself, and you could make sure that the names introduced don't conflict with existing names pretty easily. Maybe a compromise would be a <code>Try this:</code> suggestion which replaces the <code>?_</code>'s with their auto-generated names in this case? But in general, we <em>do</em> introduce things to the context without explicitly naming them ourselves, e.g. via <code>intros</code> or <code>have :=</code>. I'm not totally convinced this is anti-hygienic—is there a type of situation you're thinking of where this causes issues?</p>",
        "id": 398360786,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698181644
    },
    {
        "content": "<p>Also, do you have an issue with more \"predictable\" auto-generated names for <code>?_</code> in this case (e.g. using <code>a₁</code>, <code>a₂</code>, etc.), or just heuristic-generated names?</p>",
        "id": 398361073,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698181756
    },
    {
        "content": "<p>I think this is a distinct case, different from <code>intros</code> or <code>have :=</code>.</p>\n<ol>\n<li><code>intros</code> is name-preserving, so there is (often) an underlying name to be had, and when there isn't the generated name is inaccessible; this is sort of what I mean by hygienic even though that's not entirely what is meant in the macro sense.</li>\n<li><code>have :=</code> can introduce <em>only one</em> new declaration, and so using <code>this</code> at least makes some sense, even though it's not hygienic in the same way <code>intros</code> is.</li>\n<li>There are reasons why you might want to <code>intros</code> and not even care about what the names are; for instance, the tactic you apply next closes the goal immediately and can work with unnamed variables.</li>\n<li>In contrast, (at least in my mind) <em>the entire point</em> of <code>setm</code> is to provide names to things for later reference. If you aren't referencing it later, what is the point to naming it?</li>\n</ol>",
        "id": 398365621,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698184243
    },
    {
        "content": "<p>Note: I tried to see if my argument in (4) was a straw man. For example, I considered that maybe a <code>rw</code> would work after <code>setm</code> because some of the structure is hidden that <code>rw</code> wouldn't have otherwise seen. But I don't think it is. At least, my naive test works either with or without <code>setm</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"bp\">?</span><span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"bp\">?</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 398365629,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698184251
    },
    {
        "content": "<p>In addition, we can have references to subexpressions repeated (as in my example above), which is not possible if they're all just <code>?_</code>. So would <code>?_ + ?_ = ?_</code> introduce one new declarations or three?</p>",
        "id": 398367666,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698185395
    },
    {
        "content": "<p>That would introduce three, because each <code>?_</code> is independent (this is a general fact, present in e.g. <code>refine</code>). (I'm certainly not suggesting they <em>all</em> be <code>?_</code>, but the question is \"what should happen when the user writes <code>?_</code>\")</p>\n<p>I think the question here is \"should a tactic be able to introduce a new name\"—if <code>?_</code> creates an accessible name, you can reference it later just as well as you could have if you wrote <code>?&lt;name&gt;</code> yourself.</p>\n<p>I see the point in making sure the code is readable, though. I'm not totally sure I see the connection to hygiene, as we can solve that problem even if we do introduce names—I suspect we have different ideas as to what the spirit of hygiene is about. :)</p>\n<p>I think there are three sensible paths for readability:</p>\n<ul>\n<li>introduce a single kind of accessible name with very predictable behavior, like <code>this</code>—e.g. <code>this₁</code> etc.</li>\n<li>disallow <code>?_</code> in <code>setm</code></li>\n<li>use a <code>Try this:</code> suggestion to rename <code>?_</code>'s automatically (cool, but probably not necessary for v1 of the tactic)</li>\n</ul>",
        "id": 398368333,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698185831
    },
    {
        "content": "<p>What I'm referring to as hygiene is historically related to the actual hygiene issues solved by Lean 4, but at this point they may not be connected. However, what you may not understand, given that you only came to the project with the advent of Lean 4, is that in Lean 3, several tactics (IIRC, <code>cases</code>, <code>by_cases</code>, <code>by_contra</code>, <code>induction</code>, maybe more, or maybe some of these are wrong) would introduce a named (accessible, because this was Lean 3) hypothesis, generally <code>h</code>, into the context when the user didn't supply a name. In Lean 4, this has almost universally been removed. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">foo</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inr</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"c1\">-- unavoidable because the introduced hypothesis has an inaccessible name</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inl</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span>\n</code></pre></div>\n<p>(I will admit after testing just now, <code>induction</code>, <code>cases</code> and <code>by_contra</code> all introduce inaccessible names, but <code>by_cases</code> gives you <code>h</code>)</p>\n<p>So, my point is that Lean 4 is trying to enforce naming by making things inaccessible. I would suggest that <code>setm</code> exhibits the same behavior: <code>?_</code> is allowed, but it generates inaccessible names.</p>",
        "id": 398370503,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698187117
    },
    {
        "content": "<p>A <code>Try this:</code> is certainly acceptable, because ultimately it means the user is agreeing to the names, but agreed that it's not necessary for v1.</p>",
        "id": 398370962,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698187397
    },
    {
        "content": "<p>Ah, ok, thanks for the context! I considered it, but I wasn't totally sure about the inaccessible names option—I'm not opposed, but like you said, isn't the point of <code>setm</code> to name things? I guess it makes sense if you want to visually clean up your expression but don't want to use the name! Could it be useful for anything else?</p>",
        "id": 398371077,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698187467
    },
    {
        "content": "<p>Hmm...maybe an inaccessible name would still be useful to something that takes in a wildcard location argument?</p>",
        "id": 398371098,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698187488
    },
    {
        "content": "<p>what do you mean?</p>",
        "id": 398371184,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698187555
    },
    {
        "content": "<p>oh, nevermind, I see</p>",
        "id": 398371238,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698187566
    },
    {
        "content": "<p>I'm okay with generating inaccessible names so that things don't break, but I still contend that the whole point is for the user to assign names.</p>",
        "id": 398371344,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698187650
    },
    {
        "content": "<p>To be honest, I am kind of lost with the \"giving a name or not\" discussion, so I will work on the part that I understand first :P I have updated the <a href=\"https://github.com/leanprover-community/mathlib4/pull/7890\">PR</a> TODO list</p>",
        "id": 398526036,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698252498
    },
    {
        "content": "<p>By the way, are tests for tactics required? There doesn't seem to be any in Mathlib right now, but it sounds helpful even just as demo on how to use the tactic</p>",
        "id": 398526688,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698252730
    },
    {
        "content": "<p>They are in the <code>tests</code> folder.</p>",
        "id": 398526727,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698252745
    },
    {
        "content": "<p>That's inside the Mathlib4 repo, but outside the <code>Mathlib</code> folder.</p>",
        "id": 398526764,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698252760
    },
    {
        "content": "<p>And yes, you should have tests.</p>",
        "id": 398526786,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698252771
    },
    {
        "content": "<p>Oh that's why I couldn't find them oops</p>",
        "id": 398527036,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698252871
    },
    {
        "content": "<p>I believe the conclusion of the name discussion is this: if the user writes <code>?_ + ?a = ?_</code>, then <code>setm</code> should introduce 3 new declarations, one with name <code>a</code>, and two with inaccessible names (those are the ones with a <code>✝</code> in the tactic state).</p>",
        "id": 398527342,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698252985
    },
    {
        "content": "<p>I am not sure how <code>setm ?A = ?B at &lt;two targets&gt;</code> should work, specifically about the naming. It will try to let <code>A := target1.left</code> and then <code>A := target2.left</code> as well.</p>",
        "id": 398529607,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698253803
    },
    {
        "content": "<p>Should we append a number after the variable or something?</p>",
        "id": 398529676,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698253823
    },
    {
        "content": "<p>For example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">h3</span> <span class=\"bp\">⊢</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Hypotheses introduced:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">▶</span> <span class=\"mi\">1</span> <span class=\"n\">goal</span>\n<span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"n\">A</span><span class=\"bp\">✝²</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"n\">hA</span><span class=\"bp\">✝²</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"bp\">✝²</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">B</span><span class=\"bp\">✝²</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"n\">hB</span><span class=\"bp\">✝²</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"bp\">✝²</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"bp\">✝²</span> <span class=\"bp\">+</span> <span class=\"n\">B</span><span class=\"bp\">✝²</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span>\n<span class=\"n\">A</span><span class=\"bp\">✝¹</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"n\">hA</span><span class=\"bp\">✝¹</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"bp\">✝¹</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">B</span><span class=\"bp\">✝¹</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n<span class=\"n\">hB</span><span class=\"bp\">✝¹</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"bp\">✝¹</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span>\n<span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"bp\">✝¹</span> <span class=\"bp\">+</span> <span class=\"n\">B</span><span class=\"bp\">✝¹</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span>\n<span class=\"n\">A</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"n\">hA</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"bp\">✝</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span>\n<span class=\"n\">B</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"n\">hB</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"bp\">✝</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span>\n<span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"bp\">✝</span> <span class=\"bp\">+</span> <span class=\"n\">B</span><span class=\"bp\">✝</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span>\n<span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n<span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">b</span>\n<span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">c</span>\n</code></pre></div>",
        "id": 398529866,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698253915
    },
    {
        "content": "<p>(Would anyone even want to <code>setm</code> at multiple targets though... My original usage was for making rearranging terms easier, and it doesn't make too much sense to rearrange at many goals at once?)</p>",
        "id": 398530019,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698253967
    },
    {
        "content": "<p>I don't think this is what Thomas meant about multiple locations. Let me write up what it should be.</p>",
        "id": 398530230,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698254050
    },
    {
        "content": "<p>This is what's on the branch right now</p>",
        "id": 398530422,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698254132
    },
    {
        "content": "<p>I know, give me a minute.</p>",
        "id": 398530574,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698254187
    },
    {
        "content": "<p>Thomas' suggestion was this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h2</span> <span class=\"k\">in</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">h3</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>would result in the goal state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span>\n<span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">C</span>\n<span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">C</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>\n</code></pre></div>",
        "id": 398530713,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698254258
    },
    {
        "content": "<p>So we should only allow one location for the <code>at</code> part?</p>",
        "id": 398530870,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698254323
    },
    {
        "content": "<p>By the way, I've had a think about Thomas' comment about a second location, and I think it's not quite what we want. Instead, I think the syntax should be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">setM</span><span class=\"o\">)</span> <span class=\"s2\">\"setm\"</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"n\">usingArg</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">location</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n</code></pre></div>\n<p>The point is that you could then feed an arbitrary term (<code>usingArg</code>), not just hypotheses or the goal, as the thing to match, but it would still support these, and if none is provided then we just use the goal. Then the <code>location</code> is just the list of places we want to do the rewriting. Note that <code>usingArg</code> only allows a single term, which the behavior we want, but then we can rewrite at multiple locations.</p>",
        "id": 398531019,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698254397
    },
    {
        "content": "<p>One reason <em>not</em> to do this, and it's the same with Thomas' point about rewriting in multiple locations, is that it runs into the same reducible defeq problem you had before when you were using <code>rewrite</code> to do the replacement.</p>",
        "id": 398531094,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698254409
    },
    {
        "content": "<p>Now, personally, my feeling is that if users want to set <code>?a</code> and <code>?b</code> where <code>?a</code> is a subexpression of <code>?b</code>, then they should do it in two steps, and that's not overly burdensome. Likewise, if they are trying to give two names to reducibly defeq things, then they shouldn't, and they should give them the same name. Reducible defeq is a <em>very strong</em> (weak? I don't know what the correct adjective is here) form of equality (i.e., most things won't be defeq under this).</p>",
        "id": 398531154,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698254439
    },
    {
        "content": "<p>What is <code>usingArg</code>? Do you mind giving an example of like the <code>setm</code> command</p>",
        "id": 398531589,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698254634
    },
    {
        "content": "<p>I think your syntax involves typing the actual expression you are matching? As in <code>setm 1 + 2 = 3 using ?A + ?B = ?C</code> or something? But that's what I am trying to avoid with this tactic</p>",
        "id": 398531730,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698254690
    },
    {
        "content": "<p><code>usingArg</code> is by definition (you can right-click on hover and click \"Go to definition\") is <code>\"using \" term</code></p>",
        "id": 398531804,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698254733
    },
    {
        "content": "<p>No, it would be <code>setm ?A + ?B = ?C using h1 at h1 h2 h3 ⊢</code>.</p>",
        "id": 398531960,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698254790
    },
    {
        "content": "<p>But, crucially, you could replace <code>h1</code> with any term (and it would match on the <em>type</em> of the resulting expression)</p>",
        "id": 398532125,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698254862
    },
    {
        "content": "<p>Let me give an example.</p>",
        "id": 398532142,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698254870
    },
    {
        "content": "<p>Makes sense, so like <code>setm ?A + ?B = ?A using Nat.add_zero 3</code> or whatever it's called</p>",
        "id": 398532222,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698254889
    },
    {
        "content": "<p><del>Is that the same as what Thomas suggested but with different words</del></p>",
        "id": 398532519,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698255016
    },
    {
        "content": "<p>Okay, I think I can implement that</p>",
        "id": 398532538,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698255023
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"bp\">?</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"mi\">4</span> <span class=\"n\">using</span> <span class=\"n\">h</span> <span class=\"n\">k</span> <span class=\"n\">at</span> <span class=\"n\">h'</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  h : ∀ n, (n + 2) ^ 2 - n ^ 2 = 4 * n + 4</span>\n<span class=\"cm\">  k : ℕ</span>\n<span class=\"cm\">  a : ℕ := (k + 2) ^ 2</span>\n<span class=\"cm\">  b : ℕ := k ^ 2</span>\n<span class=\"cm\">  c : ℕ := 4 * k</span>\n<span class=\"cm\">  h' : a = b + c + 4)</span>\n<span class=\"cm\">  ⊢ True</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 398532921,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698255212
    },
    {
        "content": "<p>Maybe you want to see if <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span>  agrees with this idea first, so it's not just me spitballing.</p>",
        "id": 398533124,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698255302
    },
    {
        "content": "<p>If I understand correctly, Thomas' idea is a subset of yours, replacing using -&gt; at and at -&gt; in</p>",
        "id": 398533195,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698255343
    },
    {
        "content": "<p>Yes, they are pretty similar.</p>",
        "id": 398533277,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698255365
    },
    {
        "content": "<p>I think the point is that there should be two steps:</p>\n<ol>\n<li>matching and introducing <code>let</code>s</li>\n<li>rewriting at the appropriate places.</li>\n</ol>\n<p>which means that <code>setMCore</code> should probably return a list (or array) of <code>FVarId</code>s corresponding to the new <code>let</code> declarations, and these can be used by the rewriting procedure.</p>",
        "id": 398533629,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698255543
    },
    {
        "content": "<p>I like the <code>using</code> idea a lot! :) It does make more sense to use <code>at</code> to specify which hypotheses are affected instead of which are used.</p>",
        "id": 398585055,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698283834
    },
    {
        "content": "<p>Hi sorry I was a bit busy with other stuff but I am working on it now. I don't understand how to write the <code>elab</code> tactic header thing. This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">setM</span><span class=\"o\">)</span> <span class=\"s2\">\"setm\"</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"s2\">\" using \"</span> <span class=\"n\">term</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">location</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">setm</span> <span class=\"bp\">$</span><span class=\"n\">stx</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">using</span> <span class=\"bp\">$</span><span class=\"n\">usingArg</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">loc</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n</code></pre></div>\n<p>But this doesn't</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">setM</span><span class=\"o\">)</span> <span class=\"s2\">\"setm\"</span> <span class=\"n\">stx</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"n\">usingArg</span><span class=\"o\">:(</span><span class=\"s2\">\" using \"</span> <span class=\"n\">term</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"n\">loc</span><span class=\"o\">:(</span><span class=\"n\">location</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n</code></pre></div>\n<p>For that I mean when I log <code>usingArg</code>, it says it's <code>none</code> even when I am using <code>using</code>. What is the correct syntax for the <code>elab</code>?</p>",
        "id": 398784469,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698364264
    },
    {
        "content": "<p>Okay I got the <code>using</code> thing done, it's surprisingly easy</p>",
        "id": 398786721,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698365523
    },
    {
        "content": "<p>I am glad that I wrote the tests beforehand though, I broke every single one of them :P</p>",
        "id": 398786758,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698365535
    },
    {
        "content": "<p>Just a thought that came to mind. Say I write something like <code>setm ?A + ?B = _ using h k at h1 h2 h3</code>. Should we also introduce <code>h k</code> into the context?</p>",
        "id": 398797043,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698370576
    },
    {
        "content": "<p>Otherwise we will have a bunch of <code>A</code>s and <code>B</code>s but no equation linking them directly (in the context)</p>",
        "id": 398797068,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698370601
    },
    {
        "content": "<p>I think it's easily possible, but I don't know what to name it. <code>this</code>? What if the user wants to change the name, what should the syntax be :/</p>",
        "id": 398797165,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698370654
    },
    {
        "content": "<p>Hi, I did some work now <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> at <a href=\"https://github.com/leanprover-community/mathlib4/pull/7890\">PR</a><br>\nLooking at the TODOs, I don't think I understand what the remaining two mean <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> Do you mind explaining a bit? I read the discussion from 2 days ago, where you said</p>\n<blockquote>\n<p>So that's all to say: withNewMCtxDepth should go in front of the bulk of this tactic. :)</p>\n</blockquote>\n<p>but I don't understand what you mean - maybe pointing at the code will be nice for this one :D And about handling instances, I will try that tomorrow. But if you can provide a test that currently fails that will be great too :D</p>",
        "id": 398799183,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698371767
    },
    {
        "content": "<p>I learned a whole ton working on this tactic, it's pretty great, and I am actually using it in my main project(?) and proof too.</p>",
        "id": 398799240,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698371808
    },
    {
        "content": "<p>The <code>withNewMCtxDepth</code> should go before you create any metavariables, so before the <code>elabTermWithHoles</code></p>",
        "id": 398805243,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698374444
    },
    {
        "content": "<p>As for a test that fails, suppose the goal is <code>2 + 3 = 5</code>. We want <code>setm ?a + ?b = _</code> to succeed <em>without</em> a type ascription</p>",
        "id": 398805481,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698374542
    },
    {
        "content": "<p>I don't think we need to introduce the term supplied after <code>using</code> into the context. After all, it may frequently just be a hypothesis that already exists in the context.</p>",
        "id": 398805747,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698374677
    },
    {
        "content": "<p>Also, note that the <code>usingArg</code> I was referring to before was <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Tactic.usingArg#doc\">docs#Mathlib.Tactic.usingArg</a></p>",
        "id": 398805960,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698374772
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Help.20with.20writing.20tactic/near/398805747\">said</a>:</p>\n<blockquote>\n<p>I don't think we need to introduce the term supplied after <code>using</code> into the context. After all, it may frequently just be a hypothesis that already exists in the context.</p>\n</blockquote>\n<p>Hmm but think about the example I gave</p>",
        "id": 398845919,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698393655
    },
    {
        "content": "<p>I will have to type setm ?A+?B=_ using h a; have := h a</p>",
        "id": 398846036,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698393688
    },
    {
        "content": "<p>will something like setm ?A+?B=_ using this:h a be fine? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 398846256,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698393752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Help.20with.20writing.20tactic/near/398805960\">said</a>:</p>\n<blockquote>\n<p>Also, note that the <code>usingArg</code> I was referring to before was <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Tactic.usingArg#doc\">docs#Mathlib.Tactic.usingArg</a></p>\n</blockquote>\n<p>I think I saw that but also if you look at the entire mathlib Tactic, it’s not really used, people just do it my way</p>",
        "id": 398846375,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698393797
    },
    {
        "content": "<p>Just grep “ using “ term</p>",
        "id": 398846407,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698393812
    },
    {
        "content": "<p>(Sorry as you can tell I’m on phone</p>",
        "id": 398846429,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698393824
    },
    {
        "content": "<p>I am back on computer. This is what I meant: <a href=\"/user_uploads/3121/ovPh_L2-6ZbVOUKBToF4dKsE/Screenshot-2023-10-27-at-10.05.03.png\">Screenshot-2023-10-27-at-10.05.03.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/ovPh_L2-6ZbVOUKBToF4dKsE/Screenshot-2023-10-27-at-10.05.03.png\" title=\"Screenshot-2023-10-27-at-10.05.03.png\"><img src=\"/user_uploads/3121/ovPh_L2-6ZbVOUKBToF4dKsE/Screenshot-2023-10-27-at-10.05.03.png\"></a></div><p>Though we can definitely do a PR or something, that'll be cool.</p>",
        "id": 398856762,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698397535
    },
    {
        "content": "<p>This doesn't work, it says \"unknown metavariable ...\" <a href=\"/user_uploads/3121/HUZxtQ7gYp6tWCmNYaacZZMB/Screenshot-2023-10-27-at-10.57.10.png\">Screenshot-2023-10-27-at-10.57.10.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/HUZxtQ7gYp6tWCmNYaacZZMB/Screenshot-2023-10-27-at-10.57.10.png\" title=\"Screenshot-2023-10-27-at-10.57.10.png\"><img src=\"/user_uploads/3121/HUZxtQ7gYp6tWCmNYaacZZMB/Screenshot-2023-10-27-at-10.57.10.png\"></a></div>",
        "id": 398865406,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698400722
    },
    {
        "content": "<p>Very weird bugs...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fails</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">B</span> <span class=\"bp\">-</span> <span class=\"bp\">?</span><span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"bp\">∀</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"n\">B</span> <span class=\"bp\">-</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"k\">from</span> <span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">add_sub_cancel</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n  <span class=\"n\">unfold_let</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"bp\">;</span> <span class=\"n\">clear</span> <span class=\"n\">hA</span> <span class=\"n\">hB</span> <span class=\"n\">A</span> <span class=\"n\">B</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  ▶ 8:8-8:10: error:</span>\n<span class=\"cm\">  synthetic hole has already been defined and assigned to value incompatible with the current context</span>\n<span class=\"cm\">    A</span>\n\n<span class=\"cm\">  ▶ 8:3-8:20: error:</span>\n<span class=\"cm\">  setm: ?A = (1 : ℝ) is not definitionally equal to the goal.</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">trivial</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">works</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">B</span> <span class=\"bp\">-</span> <span class=\"bp\">?</span><span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"n\">B</span> <span class=\"bp\">-</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"k\">from</span> <span class=\"n\">add_sub_cancel</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n  <span class=\"n\">unfold_let</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"bp\">;</span> <span class=\"n\">clear</span> <span class=\"n\">hA</span> <span class=\"n\">hB</span> <span class=\"n\">A</span> <span class=\"n\">B</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n  <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 398919178,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698420084
    },
    {
        "content": "<p>I think I need help with this example, it's quite confusing...</p>",
        "id": 398919263,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698420106
    },
    {
        "content": "<p>Sorry, I don't think I have time to look at this today.</p>",
        "id": 398935483,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698425395
    },
    {
        "content": "<p>Unfortunately I also <em>probably</em> won't have time today <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> But I will (also) look over things/respond when I next have the chance!! :)</p>",
        "id": 398961400,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698437076
    },
    {
        "content": "<p>No worries, as always it’s not in a rush. I’ll push with the failed cases first</p>",
        "id": 398979108,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698447908
    },
    {
        "content": "<p>I'm looking at this again now :)</p>",
        "id": 399391671,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698708235
    },
    {
        "content": "<p>Ah sorry didn’t see this. I really hope the Zulip people implement “subscribe to thread” with push notifs ASAP</p>",
        "id": 399402355,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698714592
    },
    {
        "content": "<p>Maybe I should write a browser extension for it lol</p>",
        "id": 399402419,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698714607
    },
    {
        "content": "<p>Anyways yes, the latest code I sent with fails and works is my latest progress</p>",
        "id": 399402464,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698714632
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"579936\">@Gareth Ma</span> It’s ok, I was looking and then got called away, lol <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> I’m going to keep looking tomorrow!</p>",
        "id": 399426510,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698726676
    },
    {
        "content": "<p>Okay, so I'll mention some stuff here as I notice it! :)</p>\n<p>Also, I don't want to simply be telling you stuff to do, so feel free to simply <img alt=\":merge:\" class=\"emoji\" src=\"https://zulip-avatars.s3.amazonaws.com/3121/emoji/images/18527.png\" title=\"merge\"> react to something if you'd be okay with me pushing a commit for it, since I am playing with it on my end anyway to make sure what I'm saying makes sense, and could easily do so if it's convenient. Of course I also don't want to get in the way of learning, so, totally up to you, just wanted to give the option. :)</p>",
        "id": 399663287,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698818825
    },
    {
        "content": "<p>The issue with \"unknown goal\" when adding <code>withNewMCtxDepth</code> is because <code>withNewMCtxDepth</code> does more than reset the depth when it's done—it actually resets the whole mvar context to whatever it was when it started. (I wasn't expecting this, tbh.) So, all metavariables created during this time should be gone in the result: assigned and replaced with their assignments, essentially. The fact that we replace the main goal with one we've created inside <code>withNewMCtxDepth</code> is the issue.</p>\n<p>This makes our job a little tricky if we want to use <code>withNewMCtxDepth</code>. Inside <code>withNewMCtxDepth</code>, we have to</p>\n<ol>\n<li>create the mvars in <code>elabTermWithHoles</code></li>\n<li>perform <code>isDefEq</code> to assign them</li>\n<li>make sure all newly-created mvars are assigned</li>\n</ol>\n<p>while also making sure we do <em>not</em> create the goal we'll replace the main goal with (or any other goals that make it outside).</p>\n<p>We <em>could</em> manipulate the depth ourselves, but I'd rather not be bespoke here. The simplest option is to simply return the elaborated expression, the array of <code>MVarId</code>s we'll be replacing, and their assignments. But I'm reluctant to even be in possession of <code>MVarId</code>s that the mctx doesn't know about, and it seems like a lot of manual management. It's just a bit awkward.</p>\n<p>I'm not sure what the best solution is to this issue. Maybe it is actually worth just creating a new combinator like <code>withNewMCtxDepth</code> but which behaves differently and doesn't reset the mctx. In the meantime not increasing the depth at all seems ok-ish. I'll think about it, but I'd be interested to hear what more experienced metaprogrammers would do here.</p>",
        "id": 399668677,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698821685
    },
    {
        "content": "<p>Ok, some small things:</p>",
        "id": 399668700,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698821703
    },
    {
        "content": "<ul>\n<li>Instead of <code>mvarIdsPairs.forM fun (mvarIdOld, mvarExprNew) =&gt; do</code>, we should simply be able to use <code>for (mvarIdOld, mvarExprNew) in mvarIdsPairs do</code></li>\n</ul>",
        "id": 399668866,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698821786
    },
    {
        "content": "<ul>\n<li><code>fun</code> takes match alternatives, so <code>fun x =&gt; match x with | ... | ...</code> is equivalent to just <code>fun | ... | ...</code>!</li>\n</ul>",
        "id": 399669117,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698821905
    },
    {
        "content": "<p>A more major thing: we seem to be using the username of the mvar quite heavily; we shouldn't, as this doesn't reflect the actual logic we want to implement. Rather, we should</p>\n<ol>\n<li>split the mvars we get from <code>elabTermWithHoles</code> into <code>.syntheticOpaque</code> ones and otherwise</li>\n<li>synthesize the postponed mvars</li>\n<li>make sure all the non-originally-syntheticOpaque mvars are assigned by the end of the isDefEq`</li>\n<li>just iterate through all the (formerly) <code>.syntheticOpaque</code> ones instead of matching on the username</li>\n</ol>\n<p>(Note that we only want to set the syntheticOpaque ones to natural anyway.)</p>\n<p>Likewise, we do a lot of copying usernames from old mvars to new ones, and we shouldn't do that (nor should we need to).</p>",
        "id": 399670004,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698822342
    },
    {
        "content": "<p>Instead of using <code>evalTactic</code> and <code>exprToSyntax</code>, I think it'd be better style to use <code>MVarId.assert</code>—or even <code>assertAfter</code> to get the hypotheses in a nice place!</p>",
        "id": 399671152,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698822901
    },
    {
        "content": "<p>Again, happy to contribute instead of just saying what needs to be done, lol. Lmk either way! :)</p>",
        "id": 399671596,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1698823103
    },
    {
        "content": "<p>I think I can try it out first :) i will be away from keyboard until Sunday then I’ll work on it!</p>",
        "id": 399772381,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1698861454
    },
    {
        "content": "<p>I'd suggest using a different strategy than trying to fight with metavariable names. What you can do is create fresh metavariables for each <code>?n</code> that appears in the expression, record the provided names, create a local context with <code>let</code> bindings for each of these, then elaborate, do a defeq check, and replace the main goal.</p>\n<p>For the local context, a trick you can do is that for metavariable <code>?n</code>, you create yet another new metavariable <code>?n'</code>, create <code>let n := ?n'</code> in the local context, and then assign <code>?n := ?n'</code>. That way when you elaborate the pattern you get the replacement of <code>?n</code> by <code>n</code> for free.</p>\n<p>One thing to be careful about is that you should elaborate in the context with these new locals to get the replacements to work correctly, but you don't want the names to be accessible yet. You can use <code>mkFreshUserName</code> for these locals to temporarily make them inaccessible, and then you rename them later.</p>\n<p>Also, watch out, <code>elabTermWithHoles</code> is not what you want. It doesn't take into account the goal when it elaborates. Here's an example that fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>You can get it to succeed by changing the pattern to <code>?z + ?w = (2 : Int)</code>. The issue is that <code>elabTermWithHoles</code> causes default instances to be entertained.</p>\n<p>I've made an implementation using this strategy, just for the <code>setm patt</code> syntax -- no <code>using</code> or <code>at</code> clauses.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">Copyright (c) 2023 Gareth Ma. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Gareth Ma</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.DefEqTransformations</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># The `setm` tactic</span>\n\n<span class=\"cm\">The `setm` tactic (\"`set` with matching\") is used for introducing `let` declarations representing</span>\n<span class=\"cm\">subexpressions of the goal or in the types of local hypotheses.</span>\n\n<span class=\"cm\">For example, if the goal is `⊢ (x + 5) ^ 2 + (2 * y + x) * (x + 5) + 3 = 28` (with `x y : ℕ`), then</span>\n<span class=\"cm\">`setm ?a ^ 2 + ?b * ?a + 3 = 28` would introduce `a : ℕ := x + 5` and `b : ℕ := 2 * y + 5` into the</span>\n<span class=\"cm\">context and change the goal to `a ^ 2 + b * a + 3 = 28`</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span> <span class=\"n\">Tactic</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span> <span class=\"n\">Meta</span>\n\n<span class=\"n\">initialize</span> <span class=\"n\">registerTraceClass</span> <span class=\"bp\">`</span><span class=\"n\">Tactic.setm</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">SetMReplaceState</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Collected mvars to use for each fvar that we want to introduce.</span>\n<span class=\"sd\">  A name can be anonymous, and in that case it gets an auto-generated name. -/</span>\n  <span class=\"n\">mvars</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Name</span> <span class=\"bp\">×</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">SetMReplaceM</span> <span class=\"o\">:=</span> <span class=\"n\">StateT</span> <span class=\"n\">SetMReplaceState</span> <span class=\"n\">TermElabM</span>\n\n<span class=\"sd\">/-- Collect all synthetic holes and replace them with fresh metavariables. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">replaceWithMVars</span> <span class=\"o\">(</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">SetMReplaceM</span> <span class=\"n\">Term</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"n\">stx.raw.replaceM</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">?$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">str</span> <span class=\"bp\">.</span><span class=\"n\">anonymous</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">n.getId</span>\n        <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"In {stx}, the name must either be an atomic string or be a hole (`_`).\"</span>\n      <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">mvar</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mvars.find</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"mi\">1</span> <span class=\"bp\">==</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n        <span class=\"n\">withRef</span> <span class=\"n\">stx</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.exprToSyntax</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">mvar</span> <span class=\"n\">mvar</span><span class=\"o\">)</span>\n      <span class=\"k\">else</span>\n        <span class=\"k\">let</span> <span class=\"n\">mvar</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"n\">none</span>\n        <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">mvars</span> <span class=\"o\">:=</span> <span class=\"n\">s.mvars</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">push</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">mvar.mvarId</span><span class=\"bp\">!</span><span class=\"o\">)}</span>\n        <span class=\"n\">withRef</span> <span class=\"n\">stx</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.exprToSyntax</span> <span class=\"n\">mvar</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">stx</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">mvar</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"n\">none</span>\n      <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">mvars</span> <span class=\"o\">:=</span> <span class=\"n\">s.mvars</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">push</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">anonymous</span><span class=\"o\">,</span> <span class=\"n\">mvar.mvarId</span><span class=\"bp\">!</span><span class=\"o\">)}</span>\n      <span class=\"n\">withRef</span> <span class=\"n\">stx</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.exprToSyntax</span> <span class=\"n\">mvar</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">pure</span> <span class=\"n\">none</span>\n  <span class=\"n\">return</span> <span class=\"o\">⟨</span><span class=\"n\">stx</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- Creates locals for each mvar. The `Option` in the resulting array records whether we should</span>\n<span class=\"sd\">later make the given variable be accessible. -/</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">createLocals</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">mvars</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Name</span> <span class=\"bp\">×</span> <span class=\"n\">MVarId</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Name</span> <span class=\"bp\">×</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">TermElabM</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">run</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fvars</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Name</span> <span class=\"bp\">×</span> <span class=\"n\">Expr</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">mvars.size</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">mvar</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mvars</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n      <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"k\">do</span>\n        <span class=\"k\">if</span> <span class=\"n\">n.isAnonymous</span> <span class=\"k\">then</span>\n          <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshUserName</span> <span class=\"bp\">`</span><span class=\"n\">x</span><span class=\"o\">)</span>\n        <span class=\"k\">else</span>\n          <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshUserName</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n      <span class=\"c1\">-- Create a new mvar so that we can assign the old one to the created fvar</span>\n      <span class=\"k\">let</span> <span class=\"n\">mvar'</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvar.getType</span><span class=\"o\">)</span>\n      <span class=\"n\">withLetDecl</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvar.getType</span><span class=\"o\">)</span> <span class=\"n\">mvar'</span> <span class=\"k\">fun</span> <span class=\"n\">fvar</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"n\">mvar.assignIfDefeq</span> <span class=\"n\">fvar</span>\n        <span class=\"n\">run</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fvars.push</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">fvar</span><span class=\"o\">))</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">m</span> <span class=\"n\">fvars</span>\n  <span class=\"n\">run</span> <span class=\"mi\">0</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The `setm` tactic (\"`set` with matching\") matches a pattern containing named holes the type of a</span>\n<span class=\"sd\">local declaration (using the `at h` syntax) or the main goal, and introduces `let` bound variables</span>\n<span class=\"sd\">representing subexpressions whose location corresponds to the given named hole. These variables are</span>\n<span class=\"sd\">also substituted into the type of declaration (or main goal).</span>\n\n<span class=\"sd\">For example, if the goal is `⊢ (x + 5) ^ 2 + (2 * y + x) * (x + 5) + 3 = 28` (with `x y : ℕ`), then</span>\n<span class=\"sd\">`setm ?a ^ 2 + ?b * ?a + 3 = 28` would introduce `a : ℕ := x + 5` and `b : ℕ := 2 * y + 5` into the</span>\n<span class=\"sd\">context and change the goal to `a ^ 2 + b * a + 3 = 28`.</span>\n\n<span class=\"sd\">Likewise if the local context contains `h : (x + 5) ^ 2 + (2 * y + x) * (x + 5) + 3 = 28`</span>\n<span class=\"sd\">(with `x y : ℕ`), then `setm ?a ^ 2 + ?b * ?a + 3 = 28 at h` would introduce `a : ℕ := x + 5` and</span>\n<span class=\"sd\">`b : ℕ := 2 * y + 5` into the context and changes the type to `h : a ^ 2 + b * a + 3 = 28`. -/</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">setM</span><span class=\"o\">)</span> <span class=\"s2\">\"setm\"</span> <span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"s2\">\" using \"</span> <span class=\"n\">term</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">location</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">setm</span> <span class=\"bp\">$</span><span class=\"n\">stx</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"bp\">←</span> <span class=\"n\">getMainGoal</span>\n  <span class=\"k\">let</span> <span class=\"n\">g'</span> <span class=\"bp\">←</span> <span class=\"n\">g.withContext</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">pattern</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">mvars</span><span class=\"o\">})</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">replaceWithMVars</span> <span class=\"n\">stx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"o\">{}</span>\n    <span class=\"n\">createLocals</span> <span class=\"n\">mvars</span> <span class=\"k\">fun</span> <span class=\"n\">fvars</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"n\">Term.withSynthesize</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">pattern</span> <span class=\"bp\">←</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">pattern</span> <span class=\"n\">none</span>\n        <span class=\"k\">let</span> <span class=\"n\">g'</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprSyntheticOpaqueMVar</span> <span class=\"n\">pattern</span> <span class=\"o\">(</span><span class=\"n\">tag</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">g.getTag</span><span class=\"o\">))</span>\n        <span class=\"c1\">-- Make the variables from the named synthetic holes be accessible:</span>\n        <span class=\"n\">g'.mvarId</span><span class=\"bp\">!.</span><span class=\"n\">modifyLCtx</span> <span class=\"k\">fun</span> <span class=\"n\">ctx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n          <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">ctx</span> <span class=\"o\">:=</span> <span class=\"n\">ctx</span>\n          <span class=\"n\">for</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">fvar</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">fvars</span> <span class=\"k\">do</span>\n            <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r</span><span class=\"bp\">?</span> <span class=\"k\">then</span>\n              <span class=\"n\">ctx</span> <span class=\"o\">:=</span> <span class=\"n\">ctx.setUserName</span> <span class=\"n\">fvar.fvarId</span><span class=\"bp\">!</span> <span class=\"n\">r</span>\n          <span class=\"n\">pure</span> <span class=\"n\">ctx</span>\n        <span class=\"n\">g'.mvarId</span><span class=\"bp\">!.</span><span class=\"n\">withContext</span> <span class=\"k\">do</span>\n          <span class=\"k\">if</span> <span class=\"bp\">←</span> <span class=\"n\">withAssignableSyntheticOpaque</span> <span class=\"o\">(</span><span class=\"n\">isDefEq</span> <span class=\"n\">pattern</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">g.getType</span><span class=\"o\">))</span> <span class=\"k\">then</span>\n            <span class=\"n\">g.assign</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">←</span> <span class=\"n\">mkLetFVars</span> <span class=\"o\">(</span><span class=\"n\">fvars.map</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"n\">g'</span>\n            <span class=\"n\">pure</span> <span class=\"n\">g'.mvarId</span><span class=\"bp\">!</span>\n          <span class=\"k\">else</span>\n            <span class=\"n\">throwError</span> <span class=\"s2\">\"setm pattern{indentD pattern}</span><span class=\"se\">\\n</span><span class=\"s2\">is not definitionally equal {</span>\n<span class=\"s2\">              \"\"}to the goal{indentD (← g.getType)}</span><span class=\"se\">\\n\\n</span><span class=\"s2\">Context:{g'.mvarId!}\"</span>\n  <span class=\"n\">replaceMainGoal</span> <span class=\"o\">[</span><span class=\"n\">g'</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">28</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">28</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  x y : Nat</span>\n<span class=\"cm\">  a : Nat := x + 5</span>\n<span class=\"cm\">  b : Nat := 2 * y + x</span>\n<span class=\"cm\">  ⊢ a ^ 2 + b * a + 3 = 28</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">28</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">*</span> <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">28</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  x y : Nat</span>\n<span class=\"cm\">  a : Nat := x + 5</span>\n<span class=\"cm\">  x✝ : Nat := 2 * y + x</span>\n<span class=\"cm\">  ⊢ a ^ 2 + x✝ * a + 3 = 28</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setm</span> <span class=\"bp\">?</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  x y : Int</span>\n<span class=\"cm\">  z : Int := x + 1</span>\n<span class=\"cm\">  w : Int := y</span>\n<span class=\"cm\">  ⊢ z + w = 2</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n</div></div>",
        "id": 399800680,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698871436
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Help.20with.20writing.20tactic/near/399800680\">said</a>:</p>\n<blockquote>\n<p>Also, watch out, <code>elabTermWithHoles</code> is not what you want. ... The issue is that <code>elabTermWithHoles</code> causes default instances to be entertained.</p>\n</blockquote>\n<p>Note this part of the conversation, which addresses that:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Help.20with.20writing.20tactic/near/398339214\">said</a>:</p>\n<blockquote>\n<p>Ah, apparently not. It's not too much trouble to define it:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">elabTermWithHolesPostponing</span> <span class=\"o\">(</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tagSuffix</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">allowNaturalHoles</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TacticM</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">withCollectingNewGoalsFrom</span> <span class=\"o\">(</span><span class=\"n\">elabTermEnsuringType</span> <span class=\"n\">stx</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"n\">tagSuffix</span> <span class=\"n\">allowNaturalHoles</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 400448854,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1699239789
    },
    {
        "content": "<p>(I do switch back to just calling it <code>elabTermWithHoles</code> for convenience later on in the conversation, though. Really <code>elabTermWithHoles</code> should take a <code>mayPostpone</code> argument...)</p>",
        "id": 400449064,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1699239942
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Help.20with.20writing.20tactic/near/399800680\">said</a>:</p>\n<blockquote>\n<p>For the local context, a trick you can do is that for metavariable <code>?n</code>, you create yet another new metavariable <code>?n'</code>, create <code>let n := ?n'</code> in the local context, and then assign <code>?n := ?n'</code>. That way when you elaborate the pattern you get the replacement of <code>?n</code> by <code>n</code> for free.</p>\n</blockquote>\n<p>I liked this trick! I extended it to a slightly different assignment than the one given here, where we assign <code>?n</code> to the fvar <code>n</code>, then perform the <code>isDefEq</code> check. This means we don't need <code>withAssignableSyntheticOpaque</code>. (Which is maybe the assignment you meant to write, if there was a typo? I'm not sure.)</p>\n<p>More generally, I have a different strategy I thought I'd share, which in some senses is cleaner, but requires a bit more metaprogramming infrastructure than we have currently—mostly in the form of tweaks to existing things:</p>\n<ol>\n<li><code>elabTermWithHoles</code> should provide the option to do three things differently: (1) preserve the <code>MetavarKind</code> of the holes (by default, <code>.natural</code> holes are made <code>.syntheticOpaque</code> when <code>allowNaturalHoles := true</code>) (2) <em>not</em> tag the untagged new goals—currently it tags them all using the parent tag (3) take a <code>mayPostpone</code> argument to pass to <code>elabTermEnsuringType</code>. I create <code>elabTermWithHoles'</code> for this.</li>\n<li>Currently <code>withNewMCtxDepth</code> resets the whole <code>MCtx</code> once it finishes, meaning you lose all mvars and assignments created during it. However, the advice for matching like this is to create the terms inside a <code>withNewMCtxDepth</code>—it would be convenient to have a toggle for whether to reset the context or not. I introduce <code>withNewMCtxNoReset</code> for this, which could use a better name. It also lowers the depth of any mvars back to the resulting ambient depth upon exiting. (In the future it could use another line of code to only bother doing this for unassigned mvars.) I'm assuming that we want the ambient depth never to be lower than the depth of any mvar, given how <code>isAssignable</code> is written.</li>\n<li>I introduce <code>withoutCreatingAccessibleGoals</code> as a generic combinator for hiding metavariables created during a tactic. By default, only new assigned metavariables are made to have an inaccessible name.</li>\n</ol>\n<p>Note that the above makes up the bulk of the following code; the actual <code>setm</code>-relevant parts are the two definitions at the bottom.</p>\n<p>Now, <span class=\"user-mention\" data-user-id=\"579936\">@Gareth Ma</span>, feel free to ignore this and/or use this! Like Kyle, I've left off all <code>using</code> and <code>at</code> functionality. If you'd like me to PR my utilities, I'm happy to do so (if Kyle and/or others think they're reasonable and useful in other circumstances, that is; this is just a draft).</p>\n<p>Also, by the way, I realized I was wrong about there not existing an <code>MVarId.getUserName</code>—only it's not called <code>getUserName</code>, it's called <code>getTag</code>! I had forgotten that metavariables' usernames were sometimes called \"tags\". (I think this is a holdover from Lean 3 when metavariables actually had things called tags?)</p>",
        "id": 400489727,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1699262125
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.DefEqTransformations</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># The `setm` tactic</span>\n\n<span class=\"cm\">The `setm` tactic (\"`set` with matching\") is used for introducing `let` declarations representing</span>\n<span class=\"cm\">subexpressions of the goal or in the types of local hypotheses.</span>\n\n<span class=\"cm\">For example, if the goal is `⊢ (x + 5) ^ 2 + (2 * y + x) * (x + 5) + 3 = 28` (with `x y : ℕ`), then</span>\n<span class=\"cm\">`setm ?a ^ 2 + ?b * ?a + 3 = 28` would introduce `a : ℕ := x + 5` and `b : ℕ := 2 * y + 5` into the</span>\n<span class=\"cm\">context and change the goal to `a ^ 2 + b * a + 3 = 28`</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span> <span class=\"n\">Tactic</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span> <span class=\"n\">Meta</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  Like `withCollectingNewGoalsFrom`, execute `k`, and collect new \"holes\" in the resulting</span>\n<span class=\"sd\">  expression. However, this function differs in two key respects:</span>\n\n<span class=\"sd\">  1. It preserves the `MetavarKind` of each metavariable (in contrast, `withCollectingNewGoalsFrom`</span>\n<span class=\"sd\">  turns natural holes into synthetic opaque holes and uses `withAssignableSyntheticOpaque` when</span>\n<span class=\"sd\">  `allowNaturalHoles := true`)</span>\n<span class=\"sd\">  2. It does not tag all untagged goals.</span>\n\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">withCollectingNewGoalsFrom'</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">TacticM</span> <span class=\"n\">Expr</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">allowNaturalHoles</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TacticM</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mvarCounterSaved</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getMCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mvarCounter</span>\n  <span class=\"k\">let</span> <span class=\"n\">val</span> <span class=\"bp\">←</span> <span class=\"n\">k</span>\n  <span class=\"k\">let</span> <span class=\"n\">newMVarIds</span> <span class=\"bp\">←</span> <span class=\"n\">getMVarsNoDelayed</span> <span class=\"n\">val</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> ignore let-rec auxiliary variables, they are synthesized automatically later -/</span>\n  <span class=\"k\">let</span> <span class=\"n\">newMVarIds</span> <span class=\"bp\">←</span> <span class=\"n\">newMVarIds.filterM</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"bp\">!</span><span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Term.isLetRecAuxMVar</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> Filter out all mvars that were created prior to `k`. -/</span>\n  <span class=\"k\">let</span> <span class=\"n\">newMVarIds</span> <span class=\"bp\">←</span> <span class=\"n\">filterOldMVars</span> <span class=\"n\">newMVarIds</span> <span class=\"n\">mvarCounterSaved</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> If `allowNaturalHoles := false`, all natural mvarIds must be assigned.</span>\n<span class=\"cm\">  Passing this guard ensures that `newMVarIds` does not contain unassigned natural mvars. -/</span>\n  <span class=\"n\">unless</span> <span class=\"n\">allowNaturalHoles</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">naturalMVarIds</span> <span class=\"bp\">←</span> <span class=\"n\">newMVarIds.filterM</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvarId.getKind</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isNatural</span>\n    <span class=\"n\">logUnassignedAndAbort</span> <span class=\"n\">naturalMVarIds</span>\n  <span class=\"k\">let</span> <span class=\"n\">newMVarIds</span> <span class=\"bp\">←</span> <span class=\"n\">sortMVarIdsByIndex</span> <span class=\"n\">newMVarIds.toList</span>\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">newMVarIds</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Like `elabTermWithHoles`, but with three key differences:</span>\n\n<span class=\"sd\">  1. It preserves the `MetavarKind` of each metavariable when `allowNaturalHoles := true`</span>\n<span class=\"sd\">  2. It does not tag untagged goals</span>\n<span class=\"sd\">  3. It enables postponing metavariables via `mayPostpone := true` (the default is</span>\n<span class=\"sd\">  `mayPostpone := false`)</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabTermWithHoles'</span> <span class=\"o\">(</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">allowNaturalHoles</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">mayPostpone</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TacticM</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">withCollectingNewGoalsFrom'</span> <span class=\"o\">(</span><span class=\"n\">elabTermEnsuringType</span> <span class=\"n\">stx</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"n\">mayPostpone</span><span class=\"o\">)</span> <span class=\"n\">allowNaturalHoles</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- Executes `k`, and makes all of the metavariables created during `k` inaccessible to the user by</span>\n<span class=\"sd\">acting on their username with `mkFreshUserName`.</span>\n\n<span class=\"sd\">By default, only assigned metavariables are made inaccessible.</span>\n\n<span class=\"sd\">The argument `shouldHide : MVarId → m Bool` can be specified to hide metavariable names using a</span>\n<span class=\"sd\">condition other than assignment status; when `← shouldHide mvarId` is `true`, `mvarId` will be</span>\n<span class=\"sd\">renamed with an inaccessible name. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">withoutCreatingAccessibleGoals</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadLiftT</span> <span class=\"n\">CoreM</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadMCtx</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">shouldHide</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">MVarId.isAssigned</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">initialMVarCounter</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getMCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mvarCounter</span>\n  <span class=\"k\">let</span> <span class=\"n\">val</span> <span class=\"bp\">←</span> <span class=\"n\">k</span>\n  <span class=\"n\">for</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span><span class=\"o\">,</span> <span class=\"n\">decl</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getMCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">decls</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"n\">decl.index</span> <span class=\"bp\">&gt;=</span> <span class=\"n\">initialMVarCounter</span>\n        <span class=\"bp\">&amp;&amp;</span> <span class=\"bp\">!</span><span class=\"n\">decl.userName.isInaccessibleUserName</span>\n        <span class=\"bp\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">shouldHide</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span>\n    <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">newUserName</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshUserName</span> <span class=\"n\">decl.userName</span>\n      <span class=\"n\">modifyMCtx</span> <span class=\"k\">fun</span> <span class=\"n\">mctx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mctx.setMVarUserName</span> <span class=\"n\">mvarId</span> <span class=\"n\">newUserName</span>\n  <span class=\"n\">return</span> <span class=\"n\">val</span>\n\n<span class=\"sd\">/-- Decrease the depth of a `MetaVarContext` as well as the depths of all metavariables in it to at</span>\n<span class=\"sd\">most `depth`. If `levelAssignDepth` is given, decrease the `levelAssignDepth` and the `lDepth`.</span>\n\n<span class=\"sd\">Note that the resulting `MetavarContext`'s `depth` and `levelAssignDepth` will be exactly `depth`</span>\n<span class=\"sd\">and `levelAssignDepth`; it is possible they are raised by `decDepthTo`. This ensures that the</span>\n<span class=\"sd\">resulting `MetavarContext` has no mvars with higher depth than the ambient depth. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">_root_.Lean.MetavarContext.decDepthTo</span> <span class=\"o\">(</span><span class=\"n\">mctx</span> <span class=\"o\">:</span> <span class=\"n\">MetavarContext</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">depth</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">levelAssignDepth</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetavarContext</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"c1\">-- Could possibly avoid changing the depth for assigned mvars.</span>\n  <span class=\"k\">let</span> <span class=\"n\">decls</span> <span class=\"o\">:=</span> <span class=\"n\">mctx.decls.map</span> <span class=\"k\">fun</span> <span class=\"n\">decl</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">decl.depth</span> <span class=\"bp\">&gt;</span> <span class=\"n\">depth</span> <span class=\"k\">then</span> <span class=\"o\">{</span> <span class=\"n\">decl</span> <span class=\"k\">with</span> <span class=\"n\">depth</span> <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"n\">decl</span>\n  <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">levelAssignDepth</span> <span class=\"o\">:=</span> <span class=\"n\">levelAssignDepth</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"n\">lDepth</span> <span class=\"o\">:=</span> <span class=\"n\">mctx.lDepth.map</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"n\">levelAssignDepth</span><span class=\"o\">)</span>\n    <span class=\"n\">pure</span> <span class=\"o\">{</span> <span class=\"n\">mctx</span> <span class=\"k\">with</span> <span class=\"n\">decls</span><span class=\"o\">,</span> <span class=\"n\">depth</span><span class=\"o\">,</span> <span class=\"n\">lDepth</span><span class=\"o\">,</span> <span class=\"n\">levelAssignDepth</span> <span class=\"o\">}</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">pure</span> <span class=\"o\">{</span> <span class=\"n\">mctx</span> <span class=\"k\">with</span> <span class=\"n\">decls</span><span class=\"o\">,</span> <span class=\"n\">depth</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">withNewMCtxDepthNoResetImp</span> <span class=\"o\">(</span><span class=\"n\">allowLevelAssignments</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">saved</span> <span class=\"bp\">←</span> <span class=\"n\">get</span>\n  <span class=\"k\">let</span> <span class=\"n\">postponed</span> <span class=\"o\">:=</span> <span class=\"n\">saved.postponed</span>\n  <span class=\"k\">let</span> <span class=\"n\">depth</span> <span class=\"o\">:=</span> <span class=\"n\">saved.mctx.depth</span>\n  <span class=\"k\">let</span> <span class=\"n\">levelAssignDepth</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">allowLevelAssignments</span> <span class=\"k\">then</span> <span class=\"n\">none</span> <span class=\"k\">else</span> <span class=\"n\">some</span> <span class=\"n\">saved.mctx.levelAssignDepth</span>\n  <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">mctx</span> <span class=\"o\">:=</span> <span class=\"n\">s.mctx.incDepth</span> <span class=\"n\">allowLevelAssignments</span><span class=\"o\">,</span> <span class=\"n\">postponed</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span> <span class=\"o\">}</span>\n  <span class=\"n\">try</span>\n    <span class=\"n\">x</span>\n  <span class=\"n\">finally</span>\n    <span class=\"n\">modify</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">mctx</span> <span class=\"o\">:=</span> <span class=\"n\">s.mctx.decDepthTo</span> <span class=\"n\">depth</span> <span class=\"n\">levelAssignDepth</span><span class=\"o\">,</span> <span class=\"n\">postponed</span> <span class=\"o\">:=</span> <span class=\"n\">s.postponed</span> <span class=\"bp\">++</span> <span class=\"n\">postponed</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  `withNewMCtxDepthNoReset k` is like `withNewMCtxDepth`, but does not reset the whole mvar context</span>\n<span class=\"sd\">  after evaluation. This means that metavariables created within `withNewMCtxDepthNoReset` (and</span>\n<span class=\"sd\">  their assignments) persist after `withNewMCtxDepthNoReset`. The prior `depth`,</span>\n<span class=\"sd\">  `levelAssignDepth`, are restored; all mvar depths (and, if level</span>\n<span class=\"sd\">  assignments were *not* allowed, level mvar depths) are lowered to at most prior depth. This</span>\n<span class=\"sd\">  ensures that the ambient depth is not lower than the depth of any mvar.</span>\n\n<span class=\"sd\">  `k` is run with no postponed mvars initially; any</span>\n<span class=\"sd\">  postponed mvars created during `k` are accumulated and retained.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">withNewMCtxDepthNoReset</span> <span class=\"o\">[</span><span class=\"n\">MonadControlT</span> <span class=\"n\">MetaM</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">allowLevelAssignments</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mapMetaM</span> <span class=\"o\">(</span><span class=\"n\">withNewMCtxDepthNoResetImp</span> <span class=\"n\">allowLevelAssignments</span><span class=\"o\">)</span> <span class=\"n\">k</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\">! # setm -/</span>\n\n<span class=\"sd\">/-- Introduce `let n : type := val` to the local context of `goal` for each element</span>\n<span class=\"sd\">`(n, type, val)` of `locals`. If `n` is `.anonymous`, then an inaccessible version of `x is used</span>\n<span class=\"sd\">for the name. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">_root_.Lean.MVarId.createLocals</span> <span class=\"o\">(</span><span class=\"n\">goal</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">locals</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Name</span> <span class=\"bp\">×</span> <span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">Expr</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">FVarId</span> <span class=\"bp\">×</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">goal</span>\n  <span class=\"n\">for</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">locals.reverse</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">name</span> <span class=\"bp\">←</span> <span class=\"k\">if</span> <span class=\"n\">name.isAnonymous</span> <span class=\"k\">then</span> <span class=\"n\">mkFreshUserName</span> <span class=\"bp\">`</span><span class=\"n\">x</span> <span class=\"k\">else</span> <span class=\"n\">pure</span> <span class=\"n\">name</span>\n    <span class=\"n\">g</span> <span class=\"bp\">←</span> <span class=\"n\">g.define</span> <span class=\"n\">name</span> <span class=\"n\">type</span> <span class=\"n\">val</span>\n  <span class=\"n\">g.introNP</span> <span class=\"n\">locals.size</span>\n\n<span class=\"sd\">/-- [`setm` docstring] -/</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"setm \"</span> <span class=\"n\">patt</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">withMainContext</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">withoutCreatingAccessibleGoals</span> <span class=\"bp\">&lt;|</span>\n  <span class=\"n\">withNewMCtxDepthNoReset</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.withSynthesize</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"bp\">←</span> <span class=\"n\">getMainGoal</span>\n    <span class=\"k\">let</span> <span class=\"n\">savedUserName</span> <span class=\"bp\">←</span> <span class=\"n\">g.getTag</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">gs</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermWithHoles'</span> <span class=\"n\">patt</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"n\">allowNaturalHoles</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mayPostpone</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">gs</span> <span class=\"o\">:=</span> <span class=\"n\">gs.toArray</span>\n    <span class=\"c1\">-- Extract synthetic opaque goals (`?l`/`?_`) and natural goals (`_`) in `patt`.</span>\n    <span class=\"k\">let</span> <span class=\"n\">ldeclGoals</span>   <span class=\"bp\">←</span> <span class=\"n\">gs.filterM</span> <span class=\"k\">fun</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">g.getKind</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isSyntheticOpaque</span>\n    <span class=\"k\">let</span> <span class=\"n\">placeholders</span> <span class=\"bp\">←</span> <span class=\"n\">gs.filterM</span> <span class=\"k\">fun</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">g.getKind</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isNatural</span>\n    <span class=\"c1\">-- Create `fvars` consisting of `let l : _ := _` for each `?l` in `patt`.</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">fvars</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">g.createLocals</span> <span class=\"bp\">&lt;|←</span> <span class=\"n\">ldeclGoals.mapM</span> <span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">l.withContext</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">name</span> <span class=\"bp\">←</span> <span class=\"n\">l.getTag</span>\n      <span class=\"k\">let</span> <span class=\"n\">type</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"n\">none</span>\n      <span class=\"k\">let</span> <span class=\"n\">val</span>  <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"n\">type</span>\n      <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">val</span><span class=\"o\">)</span>\n    <span class=\"n\">g.withContext</span> <span class=\"k\">do</span>\n      <span class=\"c1\">-- Assign each `?l` in `patt` to the corresponding new fvar in the context of `g`.</span>\n      <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[:</span><span class=\"n\">ldeclGoals.size</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n        <span class=\"n\">ldeclGoals</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!.</span><span class=\"n\">assign</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">fvar</span> <span class=\"n\">fvars</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span><span class=\"o\">)</span>\n      <span class=\"c1\">-- Unify `patt` with the goal, and assign it.</span>\n      <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"bp\">←</span> <span class=\"n\">g.change</span> <span class=\"n\">e</span> <span class=\"c1\">-- Should wrap or inline for a better error message!</span>\n      <span class=\"n\">logUnassignedAndAbort</span> <span class=\"n\">placeholders</span> <span class=\"c1\">-- Ensure all `_` are assigned</span>\n      <span class=\"n\">g.setUserName</span> <span class=\"n\">savedUserName</span>\n      <span class=\"n\">replaceMainGoal</span> <span class=\"o\">[</span><span class=\"n\">g</span><span class=\"o\">]</span>\n</code></pre></div>\n</div></div>",
        "id": 400489901,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1699262199
    }
]