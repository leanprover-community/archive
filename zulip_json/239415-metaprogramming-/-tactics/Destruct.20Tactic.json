[
    {
        "content": "<h1>New <code>destruct</code> tactic</h1>\n<p><code>destruct</code> is a new tactic which eliminates structure types from the local context and goal, by unpacking them. It comes pre-packaged with <a href=\"#narrow/channel/113486-announce/topic/Canonical.20is.20available.20now!/near/517154362\">Canonical</a>, and powers its new encoding of structure types.</p>\n<p>You can use <code>destruct</code> to skolemize existentials:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Canonical</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">destruct</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  p_w : Nat</span>\n<span class=\"cm\">  p_h : p_w = p_w + 1</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p><code>destruct</code> can unpack nested structures:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">destruct</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  p_left_mp : A → B</span>\n<span class=\"cm\">  p_left_mpr : B → A</span>\n<span class=\"cm\">  p_right : C</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p><code>destruct</code> can even unpack structure types that are behind universal quantifiers, implications, and function types. Observe how each field has <code>A</code> as an antecedent, and only the <code>right</code> field has <code>B</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">destruct</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  p_left : A → B</span>\n<span class=\"cm\">  p_right : A → B → C</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>But wait, there's more. You can even unpack structures in the antecedents of premises:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">destruct</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  p_fst p_snd : Nat → Nat → Nat</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>If the goal is a structure type, multiple goals can be created:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">destruct</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> 2 goals</span>\n<span class=\"cm\">  ⊢ Nat</span>\n<span class=\"cm\">  ⊢ ?m.476 = ?m.476</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>There is a default list of structures that unfold, but you can specify your own:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">destruct</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">DHashMap</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">DHashMap</span><span class=\"bp\">.</span><span class=\"n\">Raw</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  map_inner_inner_size : Nat</span>\n<span class=\"cm\">  map_inner_inner_buckets_toList : List (Std.DHashMap.Internal.AssocList String fun x ↦ Nat)</span>\n<span class=\"cm\">  map_inner_wf : { size := map_inner_inner_size, buckets := { toList := map_inner_inner_buckets_toList } }.WF</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p><code>Unit</code> is treated like a structure, and is eliminated. Also notice the treatment of dependence on variables that were previously structure types:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">×'</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">destruct</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  ∀ (a_snd_snd_w_fst a_snd_snd_w_snd : Nat),</span>\n<span class=\"cm\">  (a_snd_snd_w_fst, a_snd_snd_w_snd).fst = (a_snd_snd_w_fst, a_snd_snd_w_snd).snd → A → B</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>While structure types can be useful for encapsulation, if the structure is intended to be used it is often best to unfold it for the purposes of automation and compilation. With <code>destruct</code> this transformation can be done automatically.</p>",
        "id": 538032110,
        "sender_full_name": "Chase Norman",
        "timestamp": 1757193145
    }
]