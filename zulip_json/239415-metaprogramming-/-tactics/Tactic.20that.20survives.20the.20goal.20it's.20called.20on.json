[
    {
        "content": "<p>Is there a way to write a tactic that closes the goal it's pointed at and keeps going? In particular, I'm trying to write a <code>capture x</code> conv tactic that assigns the currently-focused goal to a metavariable <code>?x</code>, closes the most recent <code>conv</code> context with <code>rfl</code>, and then runs <code>set x := ?x</code>; the current implementation gets as far as <code>rfl</code> and then says \"no goals left to be solved\". Fair enough, but is there a workaround?</p>",
        "id": 504705130,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1741648170
    },
    {
        "content": "<p>You have to match the contexts though</p>",
        "id": 504708924,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741650282
    },
    {
        "content": "<p>how so?</p>",
        "id": 504708972,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1741650314
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">capture</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">  </span><span class=\"c1\">-- what is `hx` here?</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 504709146,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741650413
    },
    {
        "content": "<p>Ah, I see. In that case the answer is \"whatever is most suitable for rewriting/wrapping and generalizing later\", so in this case <code>hx := fun x =&gt; x = x</code></p>",
        "id": 504709921,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1741650873
    },
    {
        "content": "<p>Which yes, isn't particularly useful in this specific case, but if you imagine some more complicated sequence like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">enter</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">capture</span><span class=\"w\"> </span><span class=\"n\">ab</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Now you can generate a function that represents <code>a + b</code> for any <code>a, b</code> from your conv target. In general it gets more useful the more complicated your target is -- it was conceived because I got tired of writing long <code>change</code> or <code>convert</code> lines &gt;.&gt;;</p>",
        "id": 504709943,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1741650889
    },
    {
        "content": "<p>If there were some term elaborator that could refer to a metavariable in an incompatible context and close the incompatible free variables, you could get this to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">enter</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">ab</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ab</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">ab</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  synthetic hole has already been defined and assigned to value incompatible with the current context</span>\n<span class=\"cm\">    a + b</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>",
        "id": 504712064,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741651923
    },
    {
        "content": "<p>In simpler cases (i.e. ones without funext), that already works when you write it out like that; I just don't see a way to turn it into a single tactic that exits conv mode for you and does one last thing in the 'outside' context before it terminates.</p>",
        "id": 504712334,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1741652066
    },
    {
        "content": "<p>Maybe it would be helpful to have some realistic examples with what you'd want to see happen (before/after goal states)</p>",
        "id": 504712613,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741652215
    },
    {
        "content": "<p>With the funext, things are somewhat harder, but I think it should basically be a matter of looking at the captured local context of the saved metavariable, comparing it to the \"new\" context (context outside the original <code>conv</code> environment), and then using one of the <code>mkLambdaFVars</code> series to create an appropriate new definition</p>",
        "id": 504712666,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1741652242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Tactic.20that.20survives.20the.20goal.20it's.20called.20on/near/504712613\">said</a>:</p>\n<blockquote>\n<p>Maybe it would be helpful to have some realistic examples with what you'd want to see happen (before/after goal states)</p>\n</blockquote>\n<p>Unfortunately, kinda by definition all the realistic examples involve a whole bunch of leadup/complexity ^.^; I'll try and come up with something, though.</p>",
        "id": 504712774,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1741652285
    },
    {
        "content": "<p>I think this would be useful! There have been many times I have wanted to traverse into an expression and \"capture\" a long complicated form.</p>",
        "id": 504712912,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741652365
    },
    {
        "content": "<p>But mostly, the short answer is that what I want is pretty much exactly what you have up there, modulo whatever is necessary to make it work inside binders, so that I can abstract away some annoying complicated expression that also repeats many times. </p>\n<p>Oh, I know. Functor application. One sec.</p>",
        "id": 504713142,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1741652486
    },
    {
        "content": "<p>... Okay, this doesn't quite work, but it's at least very similar to an example I've actually run into:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Equivalence</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"n\">u₂</span><span class=\"w\"> </span><span class=\"n\">u₁</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u₁</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u₂</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"w\">         </span><span class=\"o\">(</span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">≌</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span>\n\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ffffff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"bp\">.</span><span class=\"n\">inverse</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"bp\">.</span><span class=\"n\">inverse</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">ffffff</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">enter</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">lhs</span>\n<span class=\"w\">    </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">X'</span>\n<span class=\"w\">  </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">X'</span>\n</code></pre></div>",
        "id": 504713875,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1741652894
    },
    {
        "content": "<p>In practice the long chain of applications on both objects of the hom isn't quite so easily removed as repeated functor-inverse pairs, and I'd really like to be able to just eat them into an <code>ε f</code> for some <code>ε : (X ⟶ Y) -&gt; ...</code></p>",
        "id": 504713993,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1741652972
    },
    {
        "content": "<p>Not least because in that form, it tends to be a lot easier to rewrite or operate on <code>ε</code> and <code>ε f</code>; much less dependent typing to get in the way</p>",
        "id": 504714102,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1741653006
    },
    {
        "content": "<p>(I have no idea why <code>conv</code> is complaining here when we try to enter the body of <code>ffffff</code>)</p>",
        "id": 504714197,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1741653069
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Tactic.20that.20survives.20the.20goal.20it's.20called.20on/near/504714197\">said</a>:</p>\n<blockquote>\n<p>(I have no idea why <code>conv</code> is complaining here when we try to enter the body of <code>ffffff</code>)</p>\n</blockquote>\n<p>That's a bug in <code>conv</code>! <code>conv</code> assumes that all dependent functions are \"forall\" statements, and tries to apply <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=forall_congr#doc\">docs#forall_congr</a>, which only works for <code>Prop</code>-valued motives.</p>",
        "id": 504714608,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741653302
    },
    {
        "content": "<p>Ahh, instead of trying to use <code>hfunext</code>? <br>\nOkay, good to know.</p>",
        "id": 504715750,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1741653976
    }
]