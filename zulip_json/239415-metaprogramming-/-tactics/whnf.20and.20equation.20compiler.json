[
    {
        "content": "<p>When I <code>whnf</code> reduce <code>x + (y.succ)</code>, Lean is miraculously able to provide me <code>(x.add y).succ</code>, managing at once to evaluate the definitional equality of Nat.add without unfolding it. As I understand it, this is thanks to the equation compiler, which generates <code>Nat.add.eq_1</code> and <code>Nat.add.eq_2</code>.</p>\n<p>I am looking to write my own code performing reductions in the same way as <code>whnf</code>, using these equalities. It is not clear to me if the equations generated by the equation compiler (1) always have a standard form (the function applied by either universally quantified variables or a constructor application?), (2) have an algorithm to determine whether one of these equalities applies in a given context, (3) are exclusively definitional equalities, etc. </p>\n<p>Essentially, I am looking for a better understanding of how Lean internally represents the reduction behavior of these functions without resorting to definition unfolding and the <code>ReductionRules</code> of the recursor. Thanks!</p>",
        "id": 482679600,
        "sender_full_name": "Chase Norman",
        "timestamp": 1731698222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346696\">Chase Norman</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/whnf.20and.20equation.20compiler/near/482679600\">said</a>:</p>\n<blockquote>\n<p>When I <code>whnf</code> reduce <code>x + (y.succ)</code>, Lean is miraculously able to provide me <code>(x.add y).succ</code>, managing at once to evaluate the definitional equality of Nat.add without unfolding it. As I understand it, this is thanks to the equation compiler, which generates <code>Nat.add.eq_1</code> and <code>Nat.add.eq_2</code>.</p>\n</blockquote>\n<p>Actually it is not those equations, but rather \"smart unfolding\" which does this party trick, that is, <code>Nat.add._sunfold</code></p>",
        "id": 482684632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731700158
    },
    {
        "content": "<p>Ah... I was beginning to suspect that it was something to do with <code>Nat.add</code>. I couldn't reproduce it with my own add definition. Do you think it is possible at all to have a definitional reduction scheme that relies directly on the output from the equation compiler?</p>",
        "id": 482684948,
        "sender_full_name": "Chase Norman",
        "timestamp": 1731700306
    },
    {
        "content": "<p>the way it works is that <code>Nat.add._sunfold</code> is a definition with the same type as <code>Nat.add</code> but defined using a series of matches terminated by other things. If reducing <code>Nat.add._sunfold</code> applied to the given arguments reduces away the matches, then it is asserting that the result is defeq to <code>Nat.add</code> applied to those same arguments and the result is the desired re-folded expression</p>",
        "id": 482685132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731700372
    },
    {
        "content": "<p>in this case, <code>Nat.add._sunfold x y.succ</code> reduces to <code>(Nat.add x y).succ</code> so that's what we should make <code>Nat.add x y.succ</code> unfold to</p>",
        "id": 482685260,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731700429
    },
    {
        "content": "<p>So the smart unfolding definition is kind of like all of the equations all packed together in one definition, but expressed as a case tree instead of just a list</p>",
        "id": 482685477,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731700511
    },
    {
        "content": "<p>curiously, <code>Nat.add._sunfold</code> is what i kind of expected <code>Nat.add</code> to be by definition...</p>",
        "id": 482685563,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731700551
    },
    {
        "content": "<p>but it's different</p>",
        "id": 482685580,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731700557
    },
    {
        "content": "<p>well, it couldn't be because <code>Nat.add._sunfold</code> is using non-recursive case splitting</p>",
        "id": 482685660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731700583
    },
    {
        "content": "<p>note that it calls <code>Nat.add</code> and not <code>Nat.add._sunfold</code> again</p>",
        "id": 482685682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731700597
    },
    {
        "content": "<p>oh ahhhhh<br>\nright, they're not the same</p>",
        "id": 482685686,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731700599
    },
    {
        "content": "<p>so in a sense, <code>Nat.add._sunfold</code> models unfolding <code>Nat.add</code> for a single step.</p>",
        "id": 482685944,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731700714
    }
]