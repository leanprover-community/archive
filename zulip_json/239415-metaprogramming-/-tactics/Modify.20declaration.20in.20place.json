[
    {
        "content": "<p>I want to make an attribute that modifies a definition declaration in place (by changing its type to something defeq). What functions would I need to use to do the modification? Should I use <code>addDecl</code> using the same name as the tagged definition to overwrite it?</p>",
        "id": 476619551,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1728837487
    },
    {
        "content": "<p>I don't think that you can override an existing declaration.</p>",
        "id": 476619619,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728837556
    },
    {
        "content": "<p>Is there a way to modify it using <code>modifyEnv</code>?</p>",
        "id": 476619644,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1728837584
    },
    {
        "content": "<p>I have never tried to do anything of this sort, but I suspect that you should try hard to \"catch\" the declaration <em>before</em> it is added to the environment, rather than expunging it after the fact.</p>",
        "id": 476619774,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728837678
    },
    {
        "content": "<p>Can you say a little more what it is that you are trying to do?</p>",
        "id": 476619786,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728837695
    },
    {
        "content": "<p>(Also, note that every \"explicit\" declaration may add several \"behind-the-scenes\" declarations to the enviroment, so removing just the one that you see may leave you in a weird state with unwanted stuff still present.)</p>",
        "id": 476619904,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728837795
    },
    {
        "content": "<p>Given a class such as e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- An open immersion of PresheafedSpaces is an open embedding `f : X ⟶ U ⊆ Y` of the underlying</span>\n<span class=\"sd\">spaces, such that the sheaf map `Y(V) ⟶ f _* X(V)` is an iso for each `V ⊆ U`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PresheafedSpace</span><span class=\"bp\">.</span><span class=\"n\">IsOpenImmersion</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PresheafedSpace</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- the underlying continuous map of underlying spaces from the source to an open subset of the</span>\n<span class=\"sd\">    target. -/</span>\n<span class=\"w\">  </span><span class=\"n\">base_open</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OpenEmbedding</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">base</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- the underlying sheaf morphism is an isomorphism on each open subset -/</span>\n<span class=\"w\">  </span><span class=\"n\">c_iso</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Opens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">base_open</span><span class=\"bp\">.</span><span class=\"n\">isOpenMap</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>I want to create an attribute <code>@[MorphismProperty]</code> which changes the type of this class to <code>MorphismProperty (PresheafedSpace C)</code>. <code>MorphismProperty</code> is defined as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A `MorphismProperty C` is a class of morphisms between objects in `C`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MorphismProperty</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>So the problem is that I cant immediately define it with type <code>MorphismProperty _</code> as it is not of type <code>Type</code>.</p>",
        "id": 476620038,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1728837908
    },
    {
        "content": "<p>There is a naive solution where you define <code>PresheafedSpace.IsOpenImmersionAux</code> as above, then add an abbrev <code>PresheafedSpace.IsOpenImmersion</code> with type <code>MorphismProperty (PresheafedSpace C)</code>. But I was hoping for some automation to make this nicer.</p>",
        "id": 476620143,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1728837994
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Modify.20declaration.20in.20place/near/476619774\">said</a>:</p>\n<blockquote>\n<p>I have never tried to do anything of this sort, but I suspect that you should try hard to \"catch\" the declaration <em>before</em> it is added to the environment, rather than expunging it after the fact.</p>\n</blockquote>\n<p>Is this possible to do with attributes?</p>",
        "id": 476620196,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1728838053
    },
    {
        "content": "<p>Without having thought too much about this, you may be able to write a macro that automatically adds more declarations to the enviroment.</p>",
        "id": 476620202,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728838060
    },
    {
        "content": "<p>It would work if we could somehow make</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">MorphismProperty</span><span class=\"kd\">]</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>expand to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MorphismProperty</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"kn\">class</span>\n</code></pre></div>\n<p>But I have no idea if this is possible or not.</p>",
        "id": 476620293,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1728838134
    },
    {
        "content": "<p>yes that would be great</p>",
        "id": 476620323,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1728838160
    },
    {
        "content": "<p>That may not be so hard.</p>",
        "id": 476620392,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728838210
    },
    {
        "content": "<p>So, you would like to generate an \"intermediate\" <code>class</code> with <code>.class</code> as tail of its name, but everything else as given in the initial syntax and then the abbreviation?</p>",
        "id": 476620415,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728838251
    },
    {
        "content": "<p>Let me see if I can write a prototype for this.</p>",
        "id": 476620434,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728838272
    },
    {
        "content": "<p>yeah exactly!</p>",
        "id": 476620438,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1728838276
    },
    {
        "content": "<p>and I guess at this point it wouldn't even need to be an attribute, but could be a command/macro of some sort</p>",
        "id": 476620570,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1728838391
    },
    {
        "content": "<p>Can you try this and see if it has a chance of doing something correctly?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"toMorProp \"</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">:</span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">oldName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cmd</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.declId</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">default</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">className</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkIdentFrom</span><span class=\"w\"> </span><span class=\"n\">oldName</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">oldName</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"ss\">`class</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- replaces the given name with `name.class`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">withClassName</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">replaceM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.declId</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">className</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"c1\">-- elaborates the `.class` syntax</span>\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"n\">withClassName</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newAbbrev</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">oldName</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`MorphismProperty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`Scheme</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">className</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"n\">newAbbrev</span>\n\n<span class=\"n\">toMorProp</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>",
        "id": 476620898,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728838693
    },
    {
        "content": "<p>(This is very simple-minded, there is quite a bit of space for improvement, but if it works in easy situations, then I can look into making it more robust.)</p>",
        "id": 476620939,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728838753
    },
    {
        "content": "<p>Yeah, attributes can't change declarations, but they can add new declarations. <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span>'s can be modified where it reads something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">MorphismProperty</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"kd\">]</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">FooClass</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>That <code>Foo</code> is optional, but it seems like a nice way to say what name you want for the <code>abbrev</code>.</p>",
        "id": 476621772,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1728839482
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> Your elab can be a macro:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"toMorProp \"</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">:</span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">oldName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cmd</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.declId</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">default</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">className</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkIdentFrom</span><span class=\"w\"> </span><span class=\"n\">oldName</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">oldName</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"ss\">`class</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- replaces the given name with `name.class`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">withClassName</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">replaceM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.declId</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">className</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newAbbrev</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">oldName</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`MorphismProperty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`Scheme</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">className</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">mkNullNode</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">withClassName</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">newAbbrev</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 476621863,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1728839565
    },
    {
        "content": "<p>(That's completely untested!)</p>",
        "id": 476621877,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1728839586
    },
    {
        "content": "<p>Oh, with <code>macro</code> the <code>elabCommand</code>s are automatic for the resulting syntax?</p>",
        "id": 476621967,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728839664
    },
    {
        "content": "<p>Yeah, and in particular <code>elabCommand</code> is what is responsible for expanding <code>command</code> macros.</p>",
        "id": 476622452,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1728840137
    },
    {
        "content": "<p>It also has special support for macros that expand a command into multiple commands, via <code>mkNullNode</code>.</p>",
        "id": 476622474,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1728840173
    },
    {
        "content": "<p>Ok, I did not know whether that <code>mkNullNode</code> was a \"common\" way of merging two commands into one -- thanks!</p>",
        "id": 476622499,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728840209
    },
    {
        "content": "<p>There's also special support for <code> `(...)</code> syntax where if it fails to parse as a term quotation, it parses as a command quotation, and it also supports multiple commands, like in <code> `($(⟨withClassName⟩):command $newAbbrev)</code>. This uses a null node too.</p>",
        "id": 476622716,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1728840413
    },
    {
        "content": "<p>I knew about <code>term</code> falling back to <code>command</code>, but I did not know about <code>command</code>Seq!</p>",
        "id": 476622820,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728840517
    },
    {
        "content": "<p>This explains why you can write <code> `(def a := 1 def b := 2)</code> but not <code> `(command| def a := 1 def b := 2) </code></p>",
        "id": 476623738,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1728841382
    },
    {
        "content": "<p>Is there a performance cost to taking advantage of these special cases, or is this the idiomatic way of proceeding?</p>",
        "id": 476623823,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728841473
    },
    {
        "content": "<p>If there is, it's likely negligible</p>",
        "id": 476624075,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1728841708
    },
    {
        "content": "<p>Thanks a lot! Will play around with this for a bit</p>",
        "id": 476629060,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1728846149
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Modify.20declaration.20in.20place/near/476620898\">said</a>:</p>\n<blockquote>\n<p>Can you try this and see if it has a chance of doing something correctly?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"toMorProp \"</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">:</span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">oldName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cmd</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.declId</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">default</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">className</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkIdentFrom</span><span class=\"w\"> </span><span class=\"n\">oldName</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">oldName</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"ss\">`class</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- replaces the given name with `name.class`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">withClassName</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">replaceM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.declId</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">className</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"c1\">-- elaborates the `.class` syntax</span>\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"n\">withClassName</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newAbbrev</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">oldName</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`MorphismProperty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`Scheme</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">className</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"n\">newAbbrev</span>\n\n<span class=\"n\">toMorProp</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This almost works, one needs to use strict-implicit (or explicit) binders for <code>{X Y : Scheme}</code>, otherwise it doesn't work</p>",
        "id": 476629083,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1728846183
    },
    {
        "content": "<p>Thank you all so much! <span class=\"user-mention\" data-user-id=\"132603\">@Calle Sönne</span> <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span></p>\n<p>I was also wondering whether there was a method to run some command <code>macro</code> last night, and today I find your suggestions. Here is what I wanted to do last night (add a Haskell-style definition syntax to Lean4) and I succeeded this morning:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"[hs| \"</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"s2\">\" :: \"</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"s2\">\" ; \"</span>\n<span class=\"w\">  </span><span class=\"n\">name1</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"s2\">\" := \"</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"s2\">\" ]\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span>\n<span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"s2\">\"definition with haskell syntax!\"</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">name1</span>\n<span class=\"w\">  </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">value</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"n\">cmd</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"s2\">\"are you talking about the same term?\"</span>\n\n<span class=\"o\">[</span><span class=\"n\">hs</span><span class=\"bp\">|</span>\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">;</span>\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\">   </span><span class=\"c1\">-- x : Nat</span>\n</code></pre></div>",
        "id": 476677472,
        "sender_full_name": "Linyu Yang",
        "timestamp": 1728881801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Modify.20declaration.20in.20place/near/476629083\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Modify.20declaration.20in.20place/near/476620898\">said</a>:</p>\n<p>This almost works, one needs to use strict-implicit (or explicit) binders for <code>{X Y : Scheme}</code>, otherwise it doesn't work</p>\n</blockquote>\n<p>Do you have a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> showing where this fails?</p>",
        "id": 476692078,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728888612
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">MorphismProperty</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">AlgebraicGeometry</span><span class=\"bp\">.</span><span class=\"n\">Scheme</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">AlgebraicGeometry</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"mkMorphismProperty \"</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">:</span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">oldName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cmd</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.declId</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">default</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">className</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkIdentFrom</span><span class=\"w\"> </span><span class=\"n\">oldName</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">oldName</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"ss\">`class</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- replaces the given name with `name.class`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">withClassName</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">replaceM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.declId</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">className</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"c1\">-- elaborates the `.class` syntax</span>\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"n\">withClassName</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newAbbrev</span><span class=\"w\"> </span><span class=\"bp\">←</span>\n<span class=\"w\">    </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">oldName</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`MorphismProperty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`Scheme</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">className</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"n\">newAbbrev</span>\n\n<span class=\"n\">mkMorphismProperty</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>Here is one</p>",
        "id": 476705027,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1728891684
    },
    {
        "content": "<p>I have looked into this a little. First, I found a small bug in the previous code, here is a fix for that other bug (just using an <code>ident</code> where a <code>declId</code> was expected):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"mkMorphismProperty \"</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">:</span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">oldName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cmd</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.declId</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">default</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">className</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkIdentFrom</span><span class=\"w\"> </span><span class=\"n\">oldName</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">oldName</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"ss\">`class</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">classNameId</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">declId</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">className</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- replaces the given name with `name.class`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">withClassName</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">replaceM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.declId</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">classNameId</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"c1\">-- elaborates the `.class` syntax</span>\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"n\">withClassName</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newAbbrev</span><span class=\"w\"> </span><span class=\"bp\">←</span>\n<span class=\"w\">    </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">oldName</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`MorphismProperty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`Scheme</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@$</span><span class=\"n\">className</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"n\">newAbbrev</span>\n</code></pre></div>",
        "id": 476708118,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728892356
    },
    {
        "content": "<p>Second, it looks like <code>MorphismProperty</code> expects strict-implicit binders itself and I think that this is the source of the issue.</p>",
        "id": 476708302,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728892409
    },
    {
        "content": "<p>I am really not sure how \"good\" this change is, but the example that you gave is fixed by adding a <code>@</code> here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">oldName</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`MorphismProperty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`Scheme</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@$</span><span class=\"n\">className</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 476708653,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728892481
    },
    {
        "content": "<p>(Note the <code>@</code> at the end, just before <code>$className</code>.  I also edited the code above to include this modification.)</p>",
        "id": 476708751,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728892508
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 476716125,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1728894411
    },
    {
        "content": "<p>I think that Kyle's suggestion is better: the \"typed\" command remains untouched and parsed as is, the \"auto-generated one\" is completely straightforward and you get a chance to provide a name.  Here is an implementation in a similar spirit to the above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">MorphismProperty</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">AlgebraicGeometry</span><span class=\"bp\">.</span><span class=\"n\">Scheme</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"mkMorphismProperty\"</span><span class=\"w\"> </span><span class=\"n\">tk</span><span class=\"o\">:(</span><span class=\"s2\">\"?\"</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">:(</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"n\">ppSpace</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">:</span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">oldName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">cmd</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.declId</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"o\">)[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">                  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">                  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">                    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">oldName</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">                      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">endsWith</span><span class=\"w\"> </span><span class=\"s2\">\"Class\"</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">dropRight</span><span class=\"w\"> </span><span class=\"s2\">\"Class\"</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">))</span>\n<span class=\"w\">                      </span><span class=\"k\">else</span>\n<span class=\"w\">                        </span><span class=\"n\">default</span>\n<span class=\"w\">                    </span><span class=\"k\">else</span>\n<span class=\"w\">                      </span><span class=\"n\">default</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">newName</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">logWarning</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"'mkMorphismProperty' can only autogenerate a name if '{oldName}' ends in 'Class'. </span><span class=\"se\">\\</span>\n<span class=\"s2\">                  Please provide an explicit name.\"</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">newName</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getId</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">logInfoAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"The autogenerated name coincides with the provided name: you may omit it.\"</span>\n<span class=\"w\">  </span><span class=\"c1\">-- syntax for `abbrev id : MorphismProperty Scheme := oldName`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newAbbrev</span><span class=\"w\"> </span><span class=\"bp\">←</span>\n<span class=\"w\">    </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">newName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`MorphismProperty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`Scheme</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@$</span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">oldName</span><span class=\"bp\">⟩</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">tk</span><span class=\"bp\">.</span><span class=\"n\">isSome</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"Autogenerated declaration '{newName}':</span><span class=\"se\">\\n\\n</span><span class=\"s2\">{newAbbrev}\"</span>\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkNullNode</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">cmd</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">newAbbrev</span><span class=\"o\">])</span>\n\n<span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"mkMorphismProperty?\"</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">:(</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"n\">ppSpace</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">:</span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">mkMorphismProperty</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">cmd</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">AlgebraicGeometry</span>\n\n<span class=\"c1\">-- success</span>\n<span class=\"n\">mkMorphismProperty</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">FooClass</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"c1\">-- success, but unneeded name</span>\n<span class=\"n\">mkMorphismProperty</span><span class=\"w\"> </span><span class=\"n\">Foo2</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Foo2Class</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"c1\">-- success and verbose</span>\n<span class=\"n\">mkMorphismProperty?</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Foo1Class</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"c1\">-- fail</span>\n<span class=\"n\">mkMorphismProperty</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">FooClass1</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>",
        "id": 476853787,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728941168
    },
    {
        "content": "<p>Thanks! Although there will be more general morphism properties where the arguments are not just the objects of some previously defined category + a morphism (for example the category the morphism takes place in could be an argument). So what I was planning to do was use your original approach, run <code>elabCommand withClassName</code>, then analyze that declaration &amp; use it to define the abbrev (so its important that they get declared separately)</p>",
        "id": 476854213,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1728941455
    },
    {
        "content": "<p>Ok, that is fine.  What I think improves robustness is if the macro/elab does not modify the given command, so that you know that what you typed is certainly part of what gets elaborated, plus possibly some more that depends on that command.</p>",
        "id": 476854419,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728941557
    },
    {
        "content": "<p>So, the elab takes <code>cmd</code> and elaborates it as is, and then does extra things.  And the user can control the names of the new declarations that are added and also can peek at them by using some <code>?</code> flag, like in the latest prototype.</p>",
        "id": 476854486,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728941611
    },
    {
        "content": "<p>This way, you can inspect what it really is that you are adding easily.</p>",
        "id": 476854516,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728941627
    },
    {
        "content": "<p>(This is good for later users, but also for debugging.)</p>",
        "id": 476854539,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728941642
    },
    {
        "content": "<p>Yes, good point!</p>",
        "id": 476854838,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1728941824
    }
]