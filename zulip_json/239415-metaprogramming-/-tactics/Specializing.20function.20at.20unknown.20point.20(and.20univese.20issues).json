[
    {
        "content": "<p>I have a term of type <code>∀ ..., η = θ</code>, where the <code>...</code> is an unknown amount of arguments. I want to specialize this function at a specific argument, but I don't know in general at what point this argument appears. However, I should be able to find it by analysing the equality <code>η = θ</code>. Here is my specific situation: the equality <code>η = θ</code> will be an equality of 2-morphisms in some bicategory <code>B</code>. This bicategory <code>B</code> will be an argument to the function, and I want to specialize <code>B</code> to the bicategory <code>Cat</code>. However, there may be multiple bicategories appearing as arguments to the function, so I have to find <code>B</code> by looking at the equality <code>η = θ</code>. Here is an example of a type for which I want to do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₁</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bicategory</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₂</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bicategory</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pseudofunctor</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">mapComp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">mapComp</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map₂</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α_</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"bp\">≫</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">mapComp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">mapComp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">▷</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In this case I want to specialize <code>C</code> to <code>Cat</code>(which is where the equality is taking place).</p>\n<p>I have almost managed to do this, modulo some universe issues which I would like help with. I am also new to metaprogramming, so I am also happy to receive suggestions for completely different approaches to this problem.</p>\n<p>To do this specialization I have been using <code>forallMetaTelescope</code> (and then I construct my new, specialized, term using <code>mkLambdaFVars</code> at the end). Say my original term was called <code>e</code>, then I write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">conclusion</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">forallMetaTelescope</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>After this, I have successfully extracted the metavariable I want to specialize to <code>Cat</code> (I called it <code>CAT</code>) and assigned it <code>Cat</code> using <code>Qq</code> in the following way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">mkFreshLevelMVar</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">mkFreshLevelMVar</span>\n<span class=\"n\">CAT</span><span class=\"bp\">.</span><span class=\"n\">assign</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">})</span>\n</code></pre></div>\n<p>I also specialize the bicategory instance <code>[Bicategory B]</code> to <code>Bicategory.{max v u, max v u} Cat.{v u}</code>.</p>\n<p>I then update the list of metavariables <code>args</code> to obtain <code>args2</code>. This seems to replace <code>C</code> with <code>Cat</code>, just like I wanted. It also seems to correctly replace occurrences of <code>C</code> in the other types that depend on <code>C</code> by <code>Cat</code> (such as <code>F</code> in the example above). However, it does not seem to do this for universes. This is my problem. So in the example above, <code>F</code> gets updated to have type <code>Pseudofunctor B Cat</code>, but <code>Pseudofunctor B Cat</code> still says it has type <code>Type (max (max (max (max (max u₁ u₂) v₁) v₂) w₁) w₂)</code>. Here <code>u₂, v₂, w₂</code> appear, and they are the old universe parameter for <code>C</code> and <code>[Bicategory C]</code>. How would I go about updating these types so that they get the correct universes (depending on the new universe metavariables u and v)?</p>",
        "id": 464324252,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1724320782
    },
    {
        "content": "<p>Instead of doing this specialisation by hand, can you apply the expression of the given type to the correct arguments (here <code>(B := Cat)</code>)? Then you can infer the type of the partially applied expression. This should correctly specialise everything.</p>",
        "id": 464341532,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1724325232
    },
    {
        "content": "<p>What function would allow me to do this? In general I do not know that the argument will be called <code>B</code>, but I guess I could maybe use <code>forallMetaTelescope</code> to find the index of the argument, and then maybe there is some function which applies the expression with the nth argument being <code>Cat</code>?</p>",
        "id": 464345333,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1724326320
    },
    {
        "content": "<p>I was going to say <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.mkAppOptM#doc\">docs#Lean.Meta.mkAppOptM</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.mkAppOptM%27#doc\">docs#Lean.Meta.mkAppOptM'</a>, but both of these try to infer all instance arguments, which may or may not be a problem for you. It would be possible to make a variant that doesn't do this, and maybe someone has already done this in Batteries or Mathlib.</p>",
        "id": 464355246,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1724328750
    },
    {
        "content": "<p>I am trying to make this work now (but I also think that I will run into the instance issue later), but I am still stuck with a similar universe issue as before.</p>\n<p>Now I still use <code>forallMetaTelescope</code>, I get my list of (metavariable) arguments, instantiate <code>C</code> to <code>Cat.{v, u}</code>, and <code>[Bicategory C]</code> to <code>Bicategory.{max v u, max v u} Cat.{v u}</code>. Here I still define <code>u, v</code> as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">mkFreshLevelMVar</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">mkFreshLevelMVar</span>\n</code></pre></div>\n<p>Then I replace all arguments still containing metavariables with <code>none</code>, so I get a list of arguments <code>[none, .., Cat, Category Cat, none, ..., none]</code>.</p>\n<p>Then I run into the issue that <code>mkAppOptM'</code> complains that <code>Cat</code> does not have the right Type when I try to apply the above list to the function (because of universes).</p>\n<p>In the example from the original post it expects <code>Cat</code> to have type <code>Type u₂</code>, but it has type <code>Type ...</code> where <code>...</code> is some complicated expression involving the level metavariables <code>u, v</code>. Is there any way I can instantiate <code>u, v</code> so that this works (or specialize u₂ somehow)?</p>",
        "id": 464583761,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1724401763
    },
    {
        "content": "<p>I guess one thing I don't quite understand is that when using <code>forallMetaTelescope</code>, it does not seem like the universes get turned into metavariables, so I am not sure how to deal with them.</p>",
        "id": 464584642,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1724402071
    },
    {
        "content": "<p>Could you make a branch with your code? Then I can take a closer look.</p>",
        "id": 464605547,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1724407648
    },
    {
        "content": "<p>Thanks a lot! I have it on the branch <code>tactic-toCat</code>.</p>\n<p>What I'm trying to do on that branch is to make an attribute which specializes a lemma as described above, then applies <code>NatTrans.app</code> to the equality and then simplifies it with some basic <code>Cat</code> lemmas. Everything is in <code>Tactic/CategoryTheory/ToApp.lean</code>, but I am testing the attribute in <code>Tactic/CategoryTheory/TEST.lean</code> (otherwise I am not sure how to get the exact right input). The function that I have been talking about above, and need help with, is <code>to_appExpr</code>. Also most of the code apart from <code>to_appExpr</code> is more or less copied from <code>reassoc</code>.</p>\n<p>Let me know if you need to know anything else.</p>",
        "id": 464607729,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1724408409
    },
    {
        "content": "<p>I made some progress by replacing the theorem's original universe parameters with universe mvars. But now I need to stop procrastinating writing my paper. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 464630688,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1724413914
    },
    {
        "content": "<p>Good luck with the paper, and thanks a lot already!!</p>",
        "id": 464631079,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1724414060
    },
    {
        "content": "<p>Thanks! I pushed a final commit just now that fixes a wrong refactoring.</p>",
        "id": 464631666,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1724414294
    },
    {
        "content": "<p>Thanks a lot for the help again, I managed to get the attribute working now!</p>",
        "id": 464714069,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1724437094
    },
    {
        "content": "<p>Nice, very happy to hear that!</p>",
        "id": 465216153,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1724685588
    }
]