[
    {
        "content": "<p>I'm trying to understand how Lean's hygiene interacts with shadowing, and I'm a bit confused. The <code>#eval</code> in this program yields \"top\", whereas I would expect it to yield \"defined by m1\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"top\"</span>\n<span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"m1\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"defined by m1\"</span>\n<span class=\"w\">  </span><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"o\">)</span>\n<span class=\"n\">m1</span>\n</code></pre></div>\n<p>What's more confusing is that if I omit the <code>def x := \"top\"</code> definition I do get the result \"defined by m1\". So it's not that the macro-introduced definition is not visible in the macro-introduced <code>#eval x</code>. Instead, it seems that the top-level definition is preferred over the macro-introduced one somehow.</p>\n<p>I'm most familiar with Racket; the equivalent program there would be:</p>\n<div class=\"codehilite\" data-code-language=\"Racket\"><pre><span></span><code><span class=\"p\">(</span><span class=\"k\">define</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"s2\">\"top\"</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"k\">define-syntax-rule</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">m1</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"k\">begin</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"k\">define</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"s2\">\"defined by m1\"</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nb\">displayln</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)))</span>\n<span class=\"p\">(</span><span class=\"n\">m1</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>which does produce \"defined by m1\". The way that I understand this in Racket is that the macro-introduced names belong to a lexical scope whose parent scope is the macro definition site, so resolution first looks for bindings in new scopes created by the expansion and then in the definition site. (The story under the hood is more complicated with various scope set manipulations, of course.)</p>\n<p>Any hints on the right mental model for Lean's behavior?</p>",
        "id": 537482474,
        "sender_full_name": "Michael Ballantyne",
        "timestamp": 1756907854
    },
    {
        "content": "<p>If you swap <code>def x := \"top\"</code> and <code>macro \"m1\" : command =&gt; `(</code> (so that <code>x</code> doesn't exist at the time the macro is defined) then it does give <code>\"defined by m1\"</code></p>",
        "id": 537502515,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756913538
    },
    {
        "content": "<p>Yes, the scoping story on the top level is a bit less clear than on the term level (and also quite different from Racket given strict declaration ordering, not that that makes this specific behavior more reasonable). The main hygiene property there is to disallow \"retroactive\" bindings like in Aaron's example.</p>",
        "id": 537503619,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1756913877
    },
    {
        "content": "<p>With the resolution code from your dissertation it looks like this would produce an ambiguity error, which would make more sense to me. I just tried the example with the code from the paper supplement (<a href=\"https://github.com/Kha/macro-supplement/tree/master\">https://github.com/Kha/macro-supplement/tree/master</a>) and that indeed seems to be the result there. Maybe I'll keep digging to see why it behaves differently in current Lean.</p>",
        "id": 537513096,
        "sender_full_name": "Michael Ballantyne",
        "timestamp": 1756916651
    },
    {
        "content": "<p>Hmm, okay, it's as simple as the version in the supplement appending the global resolution with the pre-resolveds (<a href=\"https://github.com/Kha/macro-supplement/blob/1d98fe918cc70433a489cae1dab5b2b2f889829d/Expander.lean#L113\">code</a>) whereas current Lean only tries global resolution if there are no pre-resolveds (<a href=\"https://github.com/leanprover/lean4/blob/fef390df0815324ab8685f79aba5ce068d405048/src/Lean/Elab/Term.lean#L1989-L1992\">code</a>).</p>",
        "id": 537519336,
        "sender_full_name": "Michael Ballantyne",
        "timestamp": 1756918674
    },
    {
        "content": "<p>Here's one way to avoid potential collisions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"top\"</span>\n\n<span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"m1\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">xx</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">mkFreshIdent</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←`</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"bp\">`</span><span class=\"o\">(</span>\n<span class=\"w\">    </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">xx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"defined by m1\"</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">xx</span>\n<span class=\"w\">  </span><span class=\"o\">)</span>\n\n<span class=\"n\">m1</span>\n</code></pre></div>",
        "id": 537524343,
        "sender_full_name": "David Renshaw",
        "timestamp": 1756920566
    },
    {
        "content": "<p>Not sure if there's a better way.</p>",
        "id": 537524357,
        "sender_full_name": "David Renshaw",
        "timestamp": 1756920574
    },
    {
        "content": "<p>I guess if the types of the surrounding binding and the introduced binding are the same, the ambiguity error forces you to choose a different name in your macro just the same. But if the types are different, more programs should work with the design from the supplement, e.g.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">42</span>\n<span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"m1\"</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"defined by m1\"</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"o\">)</span>\n<span class=\"n\">m1</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>",
        "id": 537524550,
        "sender_full_name": "Michael Ballantyne",
        "timestamp": 1756920637
    },
    {
        "content": "<p>It's also interesting that the resolution that happens when quoting a name (<a href=\"https://github.com/leanprover/lean4/blob/fef390df0815324ab8685f79aba5ce068d405048/src/Lean/Elab/Quotation.lean#L142-L144\">here</a>) appends the pre-resolveds, unlike the term resolveName, so in the following program you do get the ambiguous resolution behavior:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"top\"</span>\n<span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"m1\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"defined by m1\"</span>\n<span class=\"w\">  </span><span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"m2\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"n\">m1</span>\n<span class=\"n\">m2</span>\n</code></pre></div>",
        "id": 537526151,
        "sender_full_name": "Michael Ballantyne",
        "timestamp": 1756921185
    }
]