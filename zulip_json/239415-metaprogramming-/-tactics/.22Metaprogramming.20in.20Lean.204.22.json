[
    {
        "content": "<p>In step 2 in <a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/main/02_overview.html#connection-to-compilers\">this</a> section, should</p>\n<p>\"Then, the new <code>Syntax</code> is processed similarly (repeating steps 1 and 2), until there are no more <strong>macros</strong> to apply.\"<br>\nbe<br>\n\"Then, the new <code>Syntax</code> is processed similarly (repeating step 2), until there are no more <strong>macros</strong> to apply.\"</p>\n<p>since step 1 takes Lean code to <code>Syntax</code>? Or does the <code>Syntax</code> generated by the macro in step 2 get translated back to Lean code?</p>",
        "id": 473003676,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727405150
    },
    {
        "content": "<p>I think you're right. Macros are only Syntax -&gt; Syntax transformations.</p>",
        "id": 473003964,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727405342
    },
    {
        "content": "<p>Maybe the syntax generated by the macro, when expanded into Lean code, might match another syntax rule?</p>",
        "id": 473004168,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727405496
    },
    {
        "content": "<p>Like \"x\" -&gt; \"xx\", and \"xx\" -&gt; \"xy\"? But then this could cause an infinite loop for something like \"x\" -&gt; \"x\".</p>",
        "id": 473004393,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727405647
    },
    {
        "content": "<p>Once Lean code has been parsed and turned into Syntax, it's never turned back into lean code and re-parsed.</p>\n<p>Macros repeatedly apply to a Syntax until no more apply. Yes, this can infinite loop, but with correctly designed macros this does not happen.</p>",
        "id": 473004475,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727405725
    },
    {
        "content": "<p>Ok, that makes sense. Thank you.</p>",
        "id": 473004562,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727405768
    },
    {
        "content": "<p>Does <code>term</code> mean any raw string of code in a Lean program? Does it have a formal meaning? Is it used to mean different things in different contexts? Or is it just anything with a type? Does it have a well formed rule?</p>",
        "id": 473011638,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727410940
    },
    {
        "content": "<p><code>term</code> is a syntax category. It has multiple related features:</p>\n<ul>\n<li>There are parsers that have been declared as being part of the <code>term</code> category.</li>\n<li>When parsing a <code>term</code>, the parser tries all of these parsers.</li>\n<li>A <code>Syntax</code> object \"is\" a <code>term</code> if it comes from the output of one of the <code>term</code> parsers.</li>\n</ul>\n<p>The purpose of the <code>term</code> category is to represent \"terms\", which is a word from type theory for, essentially, expressions.</p>\n<p>Usually we don't think too hard about the difference between the raw string that could parse as a <code>term</code> and a <code>Syntax</code> for a <code>term</code>. Certainly there's a difference, but once things are parsed we stick with <code>Syntax</code>.</p>",
        "id": 473013730,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727412416
    },
    {
        "content": "<p>What does it mean for a term to have a type of <code>Expr</code>, as in \"Expressions (terms of type <code>Expr</code>) are an abstract syntax tree for Lean programs.\" This is different than the type theory definition of \"type of\", where a term has a type determined by the typing rules?</p>",
        "id": 473014268,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727412882
    },
    {
        "content": "<p>In type theory, terms are the elements of a type. A \"term of type Expr\" is a term whose type is Expr, i.e. an element of Expr. (Using the word \"element\" is speaking loosely. We can think of types as being sets of terms, at least in Lean.)</p>",
        "id": 473014548,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727413112
    },
    {
        "content": "<p>This is not different from the type theory \"type of\"</p>",
        "id": 473014585,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727413167
    },
    {
        "content": "<p>So, connecting back, the <code>term</code> syntax category is meant to represent all the possible terms of all types.</p>",
        "id": 473014597,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727413177
    },
    {
        "content": "<p>Oh, so an <code>Expr</code> is an inductive type that takes instances of <code>Syntax</code> for its constructors, and if the <code>Syntax</code> the string parsed into is one of those constructors, it has a type of <code>Expr</code>?</p>",
        "id": 473015110,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727413350
    },
    {
        "content": "<p>No, both <code>Expr</code> and <code>Syntax</code> are their own inductive types.</p>",
        "id": 473015154,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727413394
    },
    {
        "content": "<p>They both are their own kind of abstract syntax tree.</p>",
        "id": 473015169,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727413408
    },
    {
        "content": "<p>The <code>Syntax</code> is the immediate parsed form, and the <code>Expr</code> is the elaborated form (representing <code>term</code>s only; there are a number of other syntax categories too).</p>",
        "id": 473015248,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727413459
    },
    {
        "content": "<p><code>Expr</code> is the type that Lean uses to do all of its type theory calculations, so for example the type-of calculation for terms of <code>Expr</code>.</p>",
        "id": 473015417,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727413587
    },
    {
        "content": "<p>How is it determined if a <code>term</code> has a type of <code>Expr</code>?</p>",
        "id": 473015691,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727413833
    },
    {
        "content": "<p>Or does every term have a type of <code>Expr</code>?</p>",
        "id": 473015840,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727413979
    },
    {
        "content": "<p>We're working with multiple levels of representation, it's easy to get confused here.</p>",
        "id": 473016330,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727414400
    },
    {
        "content": "<p>Every term of <code>Expr</code> <em>represents</em> a term in the type theory. Given <code>e : Expr</code>, let's say <code>r(e)</code> is the term it represents. if we calculate <code>t &lt;- inferType e</code>, then in the type theory <code>r(e) : r(t)</code>.</p>",
        "id": 473016469,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727414478
    },
    {
        "content": "<p>The first <code>:</code>, for <code>e : Expr</code>, is at the meta level. The second <code>:</code>, for <code>r(e) : r(t)</code>, is inside the theory.</p>",
        "id": 473016507,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727414520
    },
    {
        "content": "<p>Then there's <code>term</code> the syntax category, which is different from all this. If <code>t : Syntax</code> is a piece of syntax that is in the <code>term</code> category, then we can try running <code>e &lt;- elabTerm t</code>, and if it succeeds, we obtain some <code>e : Expr</code> that is the \"meaning\" of the syntax <code>t</code>.</p>",
        "id": 473016618,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727414609
    },
    {
        "content": "<ul>\n<li>terms in the theory are represented by terms of <code>Expr</code> via this made-up-by-me <code>r(..)</code> function</li>\n<li>terms of <code>Expr</code> are represented by <code>Syntax</code> in the syntax category called <code>term</code>, via two functions. First, <code>elabTerm</code> from <code>Syntax</code> to <code>Expr</code>, and second by pretty printing, from <code>Expr</code> to <code>Syntax</code></li>\n<li>also, terms of <code>Syntax</code> can be represented by strings, first via parsing (strings to Syntax), second by formatting (Syntax back to strings).</li>\n</ul>",
        "id": 473016923,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727414846
    },
    {
        "content": "<p>So there is a <code>term</code> syntax category that contains a set of parsers.<br>\nThose parsers generate instances of the <code>Syntax</code> inductive type.<br>\nIf a raw string in the source code is parsed by one of those parsers, it is called a <code>term</code> at the meta level (maybe could be called <code>meta_term</code>?).<br>\nThere is a function called <code>elabTerm</code>, which when applied to a <code>meta_term</code> , either succeeds or fails. If it succeeds, it generates an instance of the <code>Expr</code> inductive type. This represents the semantics of the syntax and a type theory term.<br>\nThere is a function called <code>inferType</code>, which when applied to an instance of <code>Expr</code>, generates (an instance of something?) that represents the type theory type of the type theory term.</p>\n<p>So, raw string -&gt; parser from term syntax category -&gt; Syntax -&gt; elabTerm -&gt; Option Expr (represents term in type theory) -&gt; elabType -&gt; ? (represents type in type theory)</p>",
        "id": 473019155,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727416456
    },
    {
        "content": "<p><code>inferType</code> takes an Expr and yields an Expr</p>",
        "id": 473019254,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727416525
    },
    {
        "content": "<p>So an <code>Expr</code> can represent either a type theory term or a type theory type?</p>",
        "id": 473019356,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727416578
    },
    {
        "content": "<p>Yes, every type is a term in type theory</p>",
        "id": 473019373,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727416594
    },
    {
        "content": "<p>ah. ok.</p>",
        "id": 473019395,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727416611
    },
    {
        "content": "<p>A type is a term of a type called a universe</p>",
        "id": 473019404,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727416617
    },
    {
        "content": "<p><code>elabType</code> isn't a step after <code>elabTerm</code>. There <em>is</em> an <code>elabType</code> though, and it takes a <code>term</code> syntax and produces an <code>Expr</code> for a type.</p>",
        "id": 473019438,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727416640
    },
    {
        "content": "<p>To make it easier keep track of things, Lean has the type <code>TSyntax `term</code> for <code>Syntax</code> that's <em>supposed</em> to be in the <code>term</code> category. This has the alias <code>Term</code>. There's nothing that actually checks that terms of <code>Term</code> are actually <code>term</code>s though.</p>",
        "id": 473019610,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727416751
    },
    {
        "content": "<p>oh, ok.</p>\n<p>So,<br>\nraw string in source code -&gt; parser from <code>term</code> syntax category -&gt; instance of <code>Syntax</code><br>\nthen either<br>\n  -&gt; <code>elabTerm</code> -&gt; <code>Option Expr</code> (representing a term in the type theory)<br>\nor<br>\n  -&gt; <code>elabType</code> -&gt; <code>Option Expr</code> (representing the type of the term in the type theory)</p>",
        "id": 473019859,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727416868
    },
    {
        "content": "<p>and I take it that <code>elabTerm</code> succeeds iff <code>elabType</code> succeeds?</p>",
        "id": 473020056,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727416950
    },
    {
        "content": "<p>No, not \"iff\", just \"if\". Not every term is a type. For example \"<a href=\"http://Nat.zero\">Nat.zero</a>\" succeeds with elabTerm but fails with elabType. \"Nat\" succeeds with both.</p>",
        "id": 473020683,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727417253
    },
    {
        "content": "<p>oh, wait, the <code>elabType</code> is not generating the type theory type for the result of the <code>elabTerm</code>?</p>",
        "id": 473020877,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727417346
    },
    {
        "content": "<p>Oh, no, it does, because a term can be a type, and a type can be a term (in the type theory)</p>",
        "id": 473021176,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727417461
    },
    {
        "content": "<p><code>elabType</code> is the same sort of thing as <code>elabTerm</code>.  They both take Syntax and produce an Expr. (It's actually basically <code>elabTerm</code>, but it checks that the result represents a type.)</p>",
        "id": 473021276,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727417504
    },
    {
        "content": "<p>I think I see. I was thinking that if you ran both <code>elabTerm</code> and <code>elabType</code> on the same instance of <code>Syntax</code>, if the first gave you <code>Nat.zero</code> then the second would give you <code>Nat</code>. But I think this is incorrect?</p>",
        "id": 473021885,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727417767
    },
    {
        "content": "<p>Instead, one tries to cast the instance of the <code>Syntax</code> to a type theory term, and the other tries to cast it to a type theory type? So running <code>elabType</code> on <code>Nat.zero</code> would fail, because it is not a type, but both would succeed being run on <code>Nat</code>, because it is both a term and a type?</p>",
        "id": 473022245,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727417997
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 473022389,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727418067
    },
    {
        "content": "<p>I'm trying to work through the first sentence of the <a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/main/03_expressions.html#de-bruijn-indexes\">section</a> on De Bruijn indexes:</p>\n<p>\"Consider the following lambda expression <code>(λ f x =&gt; f x x) (λ x y =&gt; x + y) 5</code>, we have to be very careful when we reduce this, because we get a clash in the variable <code>x</code>.\"</p>\n<p>I'm trying to understand where the clash occurs. I am probably reducing this wrong, but I'm not sure where. I am comparing the reduction as is, and with it alpha renamed to use all unique variables, and I seem to get the same answer for both:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>(λ f x =&gt; f x x) (λ x y =&gt; x + y) 5\n\n(λ x =&gt; (λ x y =&gt; x + y) x x) 5\n\n(λ x =&gt; (λ y =&gt; x + y) x) 5\n\n(λ x =&gt; (x + x)) 5\n\n5 + 5\n\n-----------------\n\n(λ f x =&gt; f x x) (λ z y =&gt; z + y) 5\n\n(λ x =&gt; (λ z y =&gt; z + y) x x) 5\n\n(λ x =&gt; (λ y =&gt; x + y) x) 5\n\n(λ x =&gt; (x + x)) 5\n\n5 + 5\n</code></pre></div>",
        "id": 473287822,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727499824
    },
    {
        "content": "<p>Indeed this example doesn't seem right. Here's a better one:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>(λ x =&gt; λ y =&gt; x y) y\n</code></pre></div>",
        "id": 473433491,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1727603385
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean4-metaprogramming-book/pull/147\">lean4-metaprogramming-book#147</a></p>",
        "id": 473440447,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1727609317
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> Thank you!</p>",
        "id": 473456358,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1727621854
    }
]