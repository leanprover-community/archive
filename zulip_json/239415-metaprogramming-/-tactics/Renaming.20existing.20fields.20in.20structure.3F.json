[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"319772\">@Devon Tuma</span> and I are building VCVio, which defines an oracle computation framework that is equal to taking the free monad over a polynomial functor (seen as a (dependent) oracle). Specifically, our stack is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">PFunctor</span><span class=\"bp\">.</span><span class=\"n\">Univariate</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">uA</span><span class=\"w\"> </span><span class=\"n\">uB</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"sd\">/-- Alias the base functor. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PFunctor</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">uA</span><span class=\"o\">,</span><span class=\"n\">uB</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span>\n<span class=\"sd\">/-- Pretty names for `PFunctor.A`/`PFunctor.B`. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Domain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uA</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"bp\">.</span><span class=\"n\">A</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"bp\">.</span><span class=\"n\">Domain</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uB</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"bp\">.</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PFunctor</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">uA</span><span class=\"o\">,</span><span class=\"n\">uB</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">uA</span><span class=\"w\"> </span><span class=\"n\">uB</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">roll</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FreeM</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"sd\">/-- Query object is the polynomial functor object. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">OracleQuery</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">uA</span><span class=\"o\">,</span><span class=\"n\">uB</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">uA</span><span class=\"w\"> </span><span class=\"n\">uB</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">PFunctor</span><span class=\"bp\">.</span><span class=\"n\">Obj</span><span class=\"w\"> </span><span class=\"n\">spec</span>\n\n<span class=\"sd\">/-- Syntactic query (same as `⟨t, id⟩`). -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">query</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"bp\">.</span><span class=\"n\">Domain</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleQuery</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">spec</span><span class=\"bp\">.</span><span class=\"n\">Range</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"bp\">⟩</span>\n\n<span class=\"sd\">/-- Computations are the free monad over the spec. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">OracleComp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">uA</span><span class=\"o\">,</span><span class=\"n\">uB</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">uA</span><span class=\"w\"> </span><span class=\"n\">uB</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">FreeM</span><span class=\"w\"> </span><span class=\"n\">spec</span>\n</code></pre></div>\n<p>My question is: is it possible to show <code>.Domain</code> and <code>.Range</code> in the infoview instead of  the default names <code>.A</code> and <code>.B</code> in <code>PFunctor</code>? Similarly, print out  <code>PFunctor.Obj</code> as <code>OracleQuery</code> and <code>PFunctor.FreeM</code> as <code>OracleComp</code>?</p>",
        "id": 546504171,
        "sender_full_name": "Quang Dao",
        "timestamp": 1761151002
    },
    {
        "content": "<p>I'm not sure this is the most principled way of doing it, but this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">PrettyPrinter</span><span class=\"w\"> </span><span class=\"n\">Delaborator</span><span class=\"w\"> </span><span class=\"n\">SubExpr</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">app_delab</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">delabFooA</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Delab</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getExpr</span>\n<span class=\"w\">  </span><span class=\"n\">let_expr</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\":(\"</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">delab</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"o\">)</span><span class=\"bp\">.$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`newName</span><span class=\"o\">))</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">app_delab</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">delabFooB</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Delab</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getExpr</span>\n<span class=\"w\">  </span><span class=\"n\">let_expr</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\":(\"</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">delab</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"o\">)</span><span class=\"bp\">.$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`otherNewName</span><span class=\"o\">))</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- x y : Foo</span>\n<span class=\"w\">  </span><span class=\"c1\">-- h : x.newName = y.newName</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ x.otherNewName = ⋯ ▸ y.otherNewName</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It feels a bit like a hack though, and there are a bunch of edge cases you'd need to deal with in the delaborator to get the behavior everywhere</p>",
        "id": 547024025,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1761364141
    },
    {
        "content": "<p>What advantage does <code>PFunctor</code> provide here vs directly passing around the index types <code>{ι : Type*} {ω : ι → Type*}</code>?</p>",
        "id": 547050239,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1761391655
    },
    {
        "content": "<p>(for instance, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.DHashMap#doc\">docs#Std.DHashMap</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFinsupp#doc\">docs#DFinsupp</a> could take a PFunctor as input, but they do not)</p>",
        "id": 547050318,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1761391751
    },
    {
        "content": "<p>Putting types into structures is generally a way to end up in a fight with Lean's typeclass resolution</p>",
        "id": 547050403,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1761391850
    },
    {
        "content": "<p>I guess the current reason would be that the dependent <code>omega</code> type can get complicated quite quickly, even just adding a few <code>PFunctor</code> together gives multiple eliminator calls in it. This seemed to get fairly messy in my experience, especially in reductions where you modify the oracle spec multiple times.</p>\n<p>We did at one time have both an indexing type being passed around and also a domain type in the struct, but combined the indexing into the domain in the struct (giving essentially<code>PFunctor</code>). Maybe it would be better to instead move the domain out of the struct into the indexing being passed around. </p>\n<p>Type class resolution errors have come up but they generally seem to have been handled by marking structs as reducible, at least for now</p>",
        "id": 547068542,
        "sender_full_name": "Devon Tuma",
        "timestamp": 1761409922
    },
    {
        "content": "<p>I guess once you get to eliminator calls you run into trouble with typeclass inference anyway</p>",
        "id": 547253897,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1761564944
    }
]