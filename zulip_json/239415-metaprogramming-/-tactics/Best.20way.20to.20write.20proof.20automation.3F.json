[
    {
        "content": "<p>I am currently learning Lean4 metaprogramming by translating the Certified Programming with Dependent Types chapter on proof by reflection. I was able to define an \"obvious\" tactic for proving tautologies in <code>Prop</code>. However, the code for closing the main goal required manually constructing an <code>Expr</code> denoting the final proof. Is this the correct approach in Lean or are there better ways to apply theorems and close goals in tactics?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Reflect</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">reflectT</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Reflect</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">reflectF</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Reflect</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Reflect</span><span class=\"bp\">.</span><span class=\"n\">iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Reflect</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">&lt;-&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bool</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">BExp</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">BExp</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"w\">   </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">BExp</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">BExp</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"bp\">.</span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"bp\">.</span><span class=\"n\">reify</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">BExp</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"bp\">.</span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"bp\">.</span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Reflect</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">eval</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"obvious\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">withMainContext</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">getMainTarget</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"bp\">.</span><span class=\"n\">reify</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">iff</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``Reflect.iff</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">&lt;-</span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``BExp.spec</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">]]</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">mkEqRefl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``true</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">    </span><span class=\"n\">closeMainGoal</span><span class=\"w\"> </span><span class=\"ss\">`obvious</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``Iff.mpr</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">])</span>\n\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">obvious</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">obvious</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex3</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">obvious</span>\n</code></pre></div>",
        "id": 491065784,
        "sender_full_name": "Qiancheng Fu",
        "timestamp": 1735367205
    },
    {
        "content": "<p>You're in good company:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">builtin_tactic</span><span class=\"w\"> </span><span class=\"bp\">«</span><span class=\"n\">exact</span><span class=\"bp\">»</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">evalExact</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">closeMainGoalUsing</span><span class=\"w\"> </span><span class=\"ss\">`exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">elabTermEnsuringType</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwUnsupportedSyntax</span>\n</code></pre></div>\n<p>You have <code>Lean.Elab.Tactic.evalTactic</code> to use tactic-style reasoning inside other tactics, which isn't uncommon for more complicated \"solver\" style tactics in order to simplify development and interoperate, but it all boils down to elaborating a proof term; emitting an explicit expr is perfectly normal.</p>",
        "id": 491067970,
        "sender_full_name": "Soundwave",
        "timestamp": 1735369388
    },
    {
        "content": "<p>You generally have to construct an expression, but it is common to use <code>liftMetaTactic</code> as a function taking the goal <code>MVar</code> to a list of MVars. In this case you assign the expression to the goal MVar and then return the empty list.</p>",
        "id": 491081101,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1735381377
    },
    {
        "content": "<p>You generally have to construct an expression, but it is common to use <code>liftMetaTactic</code> as a function taking the goal <code>MVar</code> to a list of MVars. In this case you assign the expression to the goal MVar and then return the empty list.</p>",
        "id": 491081102,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1735381380
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"815400\">@Qiancheng Fu</span> I'd write this using the <code>closeMainGoalUsing</code> combinator:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"obvious\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">closeMainGoalUsing</span><span class=\"w\"> </span><span class=\"ss\">`obvious</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">goal</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">BExp</span><span class=\"bp\">.</span><span class=\"n\">reify</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toExpr</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">iff</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``Reflect.iff</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``BExp.spec</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">]]</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">mkEqRefl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``true</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">    </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``Iff.mpr</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This makes sure that you're not introducing any new metavariables, and it does an occurs check before assignment. This is something <code>liftMetaTactic</code>-defined tactics tend to overlook...</p>\n<p>Notice also the added <code>instantiateMVars</code>. You may consider changing that to <code>(&lt;- instantiateMVars goal).consumeTypeAnnotations</code> if <code>obvious</code> is going to be used in contexts that prove an <code>optParam</code>/<code>autoParam</code>.</p>\n<p>Core Lean uses these <code>mkAppM</code>-and-friends, though you'll find in downstream projects (like Mathlib) uses of the Qq library, which lets you write in a way that checks types of Exprs at compile time.</p>",
        "id": 491298316,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1735574162
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  Thanks for the recommendations! I was originally really concerned with getting the types of <code>mkAppM</code> and <code>Expr</code>s to line up correctly in more complicated proofs. If Qq helps with that then I will definitely look into it.</p>",
        "id": 491321628,
        "sender_full_name": "Qiancheng Fu",
        "timestamp": 1735587868
    },
    {
        "content": "<p>At least <code>mkAppM</code> gives runtime errors, and at worst the kernel will catch any remaining problems, so you aren't going to end up with invalid theorems. It's good writing a comprehensive test suite!</p>",
        "id": 491322637,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1735588492
    },
    {
        "content": "<p>Oh I wasn't worried about invalid theorems, I was worried about debugging tactics which is quite a pain in Coq.</p>",
        "id": 491323013,
        "sender_full_name": "Qiancheng Fu",
        "timestamp": 1735588729
    }
]