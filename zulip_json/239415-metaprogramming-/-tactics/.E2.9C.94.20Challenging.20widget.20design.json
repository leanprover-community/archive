[
    {
        "content": "<p>Perhaps what I am trying to do goes beyond the scope of widgets, but it is conceptually simple. I want <code>addExactSuggestion</code> but where the suggestion is not known until the user interacts with the widget. Here's an example of the widget in use:</p>\n<p><a href=\"/user_uploads/3121/3jTJYC0fpgA7Fxhhh1qAWrh4/refine.gif\">refine.gif</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/3jTJYC0fpgA7Fxhhh1qAWrh4/refine.gif\" title=\"refine.gif\"><img data-animated=\"true\" data-original-content-type=\"image/gif\" data-original-dimensions=\"800x263\" src=\"/user_uploads/thumbnail/3121/3jTJYC0fpgA7Fxhhh1qAWrh4/refine.gif/840x560-anim.webp\"></a></div><p>I want to be able to insert the generated term into the file at the request of the user. Unfortunately (1) the term is only known to my Rust code, which is hosting the webserver (2) the term is not a Lean term, and requires using my translation code and the pretty-printer, and (3) the translation requires an <code>Expr</code> known only at widget-creation time. </p>\n<p>Here is a diagram of the current flow of information:</p>\n<p><a href=\"/user_uploads/3121/H4UxGShbJBc5JVdAKuZ7WNEF/IMG_0354.jpg\">IMG_0354.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/H4UxGShbJBc5JVdAKuZ7WNEF/IMG_0354.jpg\" title=\"IMG_0354.jpg\"><img data-original-content-type=\"image/jpeg\" data-original-dimensions=\"1178x558\" src=\"/user_uploads/thumbnail/3121/H4UxGShbJBc5JVdAKuZ7WNEF/IMG_0354.jpg/840x560.webp\"></a></div><p>Here is the only solution I could come up with, which is not ideal:</p>\n<p><a href=\"/user_uploads/3121/eKjZQCxJG1qTf7pIabNnESUD/IMG_0356.jpg\">IMG_0356.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/eKjZQCxJG1qTf7pIabNnESUD/IMG_0356.jpg\" title=\"IMG_0356.jpg\"><img data-original-content-type=\"image/jpeg\" data-original-dimensions=\"1093x606\" src=\"/user_uploads/thumbnail/3121/eKjZQCxJG1qTf7pIabNnESUD/IMG_0356.jpg/840x560.webp\"></a></div><p>Essentially, I need to somehow escape the iframe to call javascript in the widget. That javascript can use RPC, which hopefully lets me invoke an FFI function to fetch the term and translate it. At widget creation time, I will need to store the goal type <code>Expr</code> and replacement <code>Lsp.Range</code>, which is probably possible. To do the replacement I can maybe use <code>EditorContext</code> like <code>addExactSuggestion</code>. </p>\n<p>Any ideas? Am I pushing the widget system too far?</p>",
        "id": 517577307,
        "sender_full_name": "Chase Norman",
        "timestamp": 1747062263
    },
    {
        "content": "<p>I didnâ€™t read all the explanations carefully but â€œI want <code>addExactSuggestion</code> but where the suggestion is not known until the user interacts with the widget.â€ sounds very feasible. For instance the <code>calc</code> widget or the <code>conv?</code> widgets do that.</p>",
        "id": 517582172,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1747063270
    },
    {
        "content": "<p>If you donâ€™t see what those widget do, you can try</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Widget</span><span class=\"bp\">.</span><span class=\"n\">Conv</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">conv?</span>\n<span class=\"w\">  </span><span class=\"n\">omega</span>\n</code></pre></div>\n<p>and shift-click on some subexpression in the goal.</p>",
        "id": 517582299,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1747063299
    },
    {
        "content": "<p>Or better, just go to Baker hall and grab Wojciech to ask your question directly.</p>",
        "id": 517582481,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1747063332
    },
    {
        "content": "<p>But if you do that last one, please add a summary of the conclusion here so the rest of us can learn too!</p>",
        "id": 517598324,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1747066668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346696\">@Chase Norman</span> is the Rust webserver necessary in this picture? I am assuming it's doing more computation than just hosting a WASM build of Canonical, with all the computation (mvar refinement and so on) actually happening in the browser? Could you compile the UI into a WASM blob that is self-contained? That would allow you to get rid of the iframe and implement everything as more or less an ordinary widget.</p>",
        "id": 517625755,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1747073626
    },
    {
        "content": "<p>I figured out how to do away with the iframe using include_str, I think. But there is no WASM here, itâ€™s actually running the rust code in parallel.</p>",
        "id": 517628580,
        "sender_full_name": "Chase Norman",
        "timestamp": 1747074382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346696\">Chase Norman</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Challenging.20widget.20design/near/517628580\">said</a>:</p>\n<blockquote>\n<p>I figured out how to do away with the iframe using include_str, I think. But there is no WASM here, itâ€™s actually running the rust code in parallel.</p>\n</blockquote>\n<p>Sorry, I don't understand your message; do you still need the webserver after this change? Part of the reason for getting rid of it, if possible, would be that it will always be more fragile to require that a webserver can run in the background as opposed to doing all computation in the infoview. For parallelism, per <a href=\"https://caniuse.com/wasm-threads\">caniuse</a> WASM threads are supported in Chrome, though I don't know whether they are in Electron (VSCode) and whether they actually work in practice.</p>",
        "id": 517634829,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1747076022
    },
    {
        "content": "<p>I need the webserver, because it is what is actually doing all of the reasoning. Switching from a Rust runtime to a WASM runtime to support this feature of widgets in Lean is not really an option.</p>",
        "id": 517644871,
        "sender_full_name": "Chase Norman",
        "timestamp": 1747078769
    },
    {
        "content": "<p>Ok, then your proposed architecture makes sense to me. You can communicate between the widget JS that uses <code>EditorContext</code> and the Rust-webserver-iframe with <code>postMessage</code> like you suggest.</p>",
        "id": 517647222,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1747079440
    },
    {
        "content": "<p>I've managed to get \"messages\" out of the iframe. However, I'm having trouble getting the RPC function to not \"cache\" its results. </p>\n<p>Here's my RPC method</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Server</span><span class=\"w\"> </span><span class=\"n\">RequestM</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">server_rpc_method</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">params</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">InsertParams</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RequestM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RequestTask</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">withWaitFindSnapAtPos</span><span class=\"w\"> </span><span class=\"n\">params</span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">snap</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">runTermElabM</span><span class=\"w\"> </span><span class=\"n\">snap</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">getRefinement</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"s2\">\"No term.\"</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">termToString</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and my react component:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">useRpcSession</span><span class=\"o\">()</span><span class=\"bp\">;</span>\n<span class=\"n\">React</span><span class=\"bp\">.</span><span class=\"n\">useEffect</span><span class=\"o\">(()</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">onMessage</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">async</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">event</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">event</span><span class=\"bp\">.</span><span class=\"n\">data?</span><span class=\"bp\">.</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">===</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">insert'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">            </span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">await</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"bp\">.</span><span class=\"n\">call</span><span class=\"o\">(</span><span class=\"bp\">'</span><span class=\"n\">insert'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">pos</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">props</span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"bp\">;</span>\n<span class=\"w\">            </span><span class=\"n\">console</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"w\">        </span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">}</span><span class=\"bp\">;</span>\n<span class=\"w\">    </span><span class=\"n\">window</span><span class=\"bp\">.</span><span class=\"n\">addEventListener</span><span class=\"o\">(</span><span class=\"bp\">'</span><span class=\"n\">message'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">onMessage</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">window</span><span class=\"bp\">.</span><span class=\"n\">removeEventListener</span><span class=\"o\">(</span><span class=\"bp\">'</span><span class=\"n\">message'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">onMessage</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"bp\">;</span>\n</code></pre></div>\n<p>I do see the <code>console.log</code> with each message, but the <code>getRefinement</code> is only triggered once at the creation of the widget (even when no message is sent). How do I prevent React from performing the call in advance?</p>",
        "id": 517936294,
        "sender_full_name": "Chase Norman",
        "timestamp": 1747176490
    },
    {
        "content": "<p>The issue was that Lean was caching the result of the extern function during compilation. Here's a version that works using IO.rand:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Server</span><span class=\"w\"> </span><span class=\"n\">RequestM</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">server_rpc_method</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">params</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">InsertParams</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RequestM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RequestTask</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">withWaitFindSnapAtPos</span><span class=\"w\"> </span><span class=\"n\">params</span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">snap</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">runTermElabM</span><span class=\"w\"> </span><span class=\"n\">snap</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">getRefinement</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">rand</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">65536</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"s2\">\"No term.\"</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">termToString</span><span class=\"w\"> </span><span class=\"n\">tm</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 517939774,
        "sender_full_name": "Chase Norman",
        "timestamp": 1747178651
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346696\">Chase Norman</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Challenging.20widget.20design/near/517939774\">said</a>:</p>\n<blockquote>\n<p>The issue was that Lean was caching the result of the extern function during compilation.</p>\n</blockquote>\n<p>Judging by your words, it seems like you're hitting an issue I've hit before: <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/FFI.2C.20Rust.20and.20mutability/near/504712353\">#lean4 &gt; FFI, Rust and mutability @ ğŸ’¬</a> </p>\n<p>You can try tagging your function with <code>@[never_extract]</code>.</p>",
        "id": 517949164,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1747184870
    },
    {
        "content": "<p>No, that is at best a workaround. If you have an effectful FFI function, you must put it in IO!</p>",
        "id": 517980169,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1747204150
    },
    {
        "content": "<p>Ok, I will make my functions return a closure of type â€œUnit -&gt; Result Error Unit Xâ€ that acts as a pure return of the value of type X, using Result.ok</p>",
        "id": 517984075,
        "sender_full_name": "Chase Norman",
        "timestamp": 1747205761
    },
    {
        "content": "<p>Or, would it suffice to just add an argument to these functions of type unit and have them return â€œ(Result.ok x Unit.unit)â€ by uncurrying?</p>",
        "id": 517984474,
        "sender_full_name": "Chase Norman",
        "timestamp": 1747205890
    },
    {
        "content": "<p>I was avoiding this because closures seemed hard to construct</p>",
        "id": 517985313,
        "sender_full_name": "Chase Norman",
        "timestamp": 1747206200
    },
    {
        "content": "<p>I'm not sure I understand, your function has as input only the type X? How does that work?</p>",
        "id": 517992838,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1747208663
    },
    {
        "content": "<p>I'm trying to figure out how to make a function return <code>(IO X)</code>. Are there any examples of this being done through FFI? I can't use any <code>inline</code> functions from <code>lean.h</code> because of <a href=\"https://github.com/leanprover/lean4/issues/8075\">issue#8075</a>. From what I understand, <code>IO X</code> is equivalent to <code>Unit -&gt; Result Error Unit X</code>, and I'm wondering if my code needs to create and compile such a closure, or if I can just add the argument of type Unit to my function (which contains multiple other arguments already) and just return an instance of type <code>Result Error Unit X</code></p>",
        "id": 518115730,
        "sender_full_name": "Chase Norman",
        "timestamp": 1747241509
    },
    {
        "content": "<p>If external code tends to be nondeterministic, it might be useful to have a <code>lean.h</code> symbol dedicated to creating an <code>IO X</code> from an <code>X</code></p>",
        "id": 518116111,
        "sender_full_name": "Chase Norman",
        "timestamp": 1747241630
    },
    {
        "content": "<p>I think you need <code>lean_io_result_mk_ok</code> from <code>lean.h</code></p>",
        "id": 518116207,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1747241653
    },
    {
        "content": "<p>Oh, perfect! Sorry, I tried looking for this symbol and missed it.</p>",
        "id": 518116475,
        "sender_full_name": "Chase Norman",
        "timestamp": 1747241743
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Challenging.20widget.20design/near/517980169\">said</a>:</p>\n<blockquote>\n<p>No, that is at best a workaround. If you have an effectful FFI function, you must put it in IO!</p>\n</blockquote>\n<p>To clarify my suggestion, I thought Chase was dealing with a situation like mine, as I know he's been working with Rust, which usually does things via in-place mutation. That is, my use case involved computations that were incidentally stateful but wouldn't be modeled in Lean as such</p>",
        "id": 518117117,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1747241905
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> I wanted to update everyone now that this project is completed. Although the proposed design was quite complex, it was the correct way to go forward and it succeeded. RPC ended up doing most of the heavy lifting, with RPC-refs used to send information from the tactic state to the widget state. postMessage is the only way for the iframe to communicate to the widget (and the widget cannot access localhost without embedding an iframe). Regardless, the full implementation can be seen on the <a href=\"https://github.com/chasenorman/CanonicalLean\">CanonicalLean</a> repository. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"346696\">Chase Norman</span> <a href=\"#narrow/channel/113488-general/topic/Canonical/near/522451293\">said</a>:</p>\n<blockquote>\n<p>The <strong>first structure editor for Lean</strong> was added with the v4.20.0 release of Canonical. </p>\n<p><a href=\"/user_uploads/3121/vkcqBUt2nVTuTTIlYlBpQiJJ/refinement.gif\">/user_uploads/3121/vkcqBUt2nVTuTTIlYlBpQiJJ/refinement.gif</a></p>\n<p>Prove theorems, implement functions, and construct objects just by clicking.</p>\n</blockquote>",
        "id": 523016003,
        "sender_full_name": "Chase Norman",
        "timestamp": 1749436267
    },
    {
        "content": "<p>And be sure to wrap any effectful extern definitions in IO. It's not difficult using <code>lean_io_result_mk_ok</code>, and it fixes the Heisenbugs.</p>",
        "id": 523016065,
        "sender_full_name": "Chase Norman",
        "timestamp": 1749436353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346696\">Chase Norman</span> has marked this topic as resolved.</p>",
        "id": 523201543,
        "sender_full_name": "Notification Bot",
        "timestamp": 1749527494
    }
]