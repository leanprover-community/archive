[
    {
        "content": "<p>In <code>Meta/Tactic/Cases.lean</code>, an induct with indices will generate additional <code>Eq.refl</code> calls:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"bp\">.</span><span class=\"n\">inductiveVal</span><span class=\"bp\">.</span><span class=\"n\">numIndices</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">          </span><span class=\"c1\">-- Simple case</span>\n<span class=\"w\">          </span><span class=\"n\">inductionCasesOn</span><span class=\"w\"> </span><span class=\"n\">mvarId</span><span class=\"w\"> </span><span class=\"n\">majorFVarId</span><span class=\"w\"> </span><span class=\"n\">givenNames</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">useNatCasesAuxOn</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">useNatCasesAuxOn</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"k\">else</span>\n<span class=\"w\">          </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s₁</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">generalizeIndices</span><span class=\"w\"> </span><span class=\"n\">mvarId</span><span class=\"w\"> </span><span class=\"n\">majorFVarId</span>\n<span class=\"w\">          </span><span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">cases</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"s2\">\"after generalizeIndices</span><span class=\"se\">\\n</span><span class=\"s2\">{MessageData.ofGoal s₁.mvarId}\"</span>\n<span class=\"w\">          </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inductionCasesOn</span><span class=\"w\"> </span><span class=\"n\">s₁</span><span class=\"bp\">.</span><span class=\"n\">mvarId</span><span class=\"w\"> </span><span class=\"n\">s₁</span><span class=\"bp\">.</span><span class=\"n\">fvarId</span><span class=\"w\"> </span><span class=\"n\">givenNames</span><span class=\"w\"> </span><span class=\"n\">ctx</span>\n<span class=\"w\">          </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elimAuxIndices</span><span class=\"w\"> </span><span class=\"n\">s₁</span><span class=\"w\"> </span><span class=\"n\">s₂</span>\n<span class=\"w\">          </span><span class=\"n\">unifyCasesEqs</span><span class=\"w\"> </span><span class=\"n\">s₁</span><span class=\"bp\">.</span><span class=\"n\">numEqs</span><span class=\"w\"> </span><span class=\"n\">s₂</span>\n</code></pre></div>\n<p>This is not the case for <code>Option</code> since it has no indices. However, consider this example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mystery</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Min</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min_eq_left</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">min</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">min</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">mystery</span>\n</code></pre></div>\n<p>This theorem generates <code>Eq.refl a</code> and <code>Eq.refl b</code> at the end of some <code>casesOn</code> calls. Why does this happen?</p>",
        "id": 566852951,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1767836681
    },
    {
        "content": "<p>Well, Lean.Meta.Tactic.Cases and Lean.Meta.Tactic.Induction (which contain <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.cases#doc\">docs#Lean.MVarId.cases</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.induction#doc\">docs#Lean.MVarId.induction</a>) have almost no code in common with the implementation of the tactics <code>cases</code> and <code>induction</code> which is in Lean.Elab.Tactic.Induction: they both use independent implementations, one of which optimized for elaborating syntax and the other optimized for use in metaprogramming and are used for <code>rcases</code> and <code>match</code> (as such, the Meta versions are much shorter). The <code>cases</code> tactic actually always calls <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.generalizeTargetsEq#doc\">docs#Lean.Meta.generalizeTargetsEq</a> which (or specifically <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.mkEqAndProof#doc\">docs#Lean.Meta.mkEqAndProof</a>) causes the <code>Eq.refl</code> to occur.</p>",
        "id": 566988515,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1767890975
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/.60Eq.2Erefl.60.20in.20.60cases.60.20and.20.60induction.60/near/566988515\">said</a>:</p>\n<blockquote>\n<p>Well, Lean.Meta.Tactic.Cases and Lean.Meta.Tactic.Induction (which contain <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.cases#doc\">docs#Lean.MVarId.cases</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.induction#doc\">docs#Lean.MVarId.induction</a>) have almost no code in common with the implementation of the tactics <code>cases</code> and <code>induction</code> which is in Lean.Elab.Tactic.Induction: they both use independent implementations, one of which optimized for elaborating syntax and the other optimized for use in metaprogramming and are used for <code>rcases</code> and <code>match</code> (as such, the Meta versions are much shorter). The <code>cases</code> tactic actually always calls <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.generalizeTargetsEq#doc\">docs#Lean.Meta.generalizeTargetsEq</a> which (or specifically <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.mkEqAndProof#doc\">docs#Lean.Meta.mkEqAndProof</a>) causes the <code>Eq.refl</code> to occur.</p>\n</blockquote>\n<p>is there any particular reason why it does this?</p>",
        "id": 567097708,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1767950048
    },
    {
        "content": "<p>I guess doing it always is just simpler?</p>",
        "id": 567175050,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1767974646
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/.60Eq.2Erefl.60.20in.20.60cases.60.20and.20.60induction.60/near/567175050\">said</a>:</p>\n<blockquote>\n<p>I guess doing it always is just simpler?</p>\n</blockquote>\n<p>I don't think its simpler in this case. Seems like this <code>Eq.refl</code> is necessary for a lot of proofs to proceed</p>",
        "id": 573450983,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1770881461
    }
]