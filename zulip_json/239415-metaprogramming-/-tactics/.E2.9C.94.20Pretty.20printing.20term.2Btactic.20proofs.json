[
    {
        "content": "<p>I would like to create <code>Syntax</code> for proofs like the following, which have arbitrary nesting between term and tactic modes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_add</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">      </span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">n_ih</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ_add</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span>\n<span class=\"w\">            </span><span class=\"n\">rfl</span>\n<span class=\"w\">          </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n_ih</span>\n<span class=\"w\">      </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>I would like to be able to use the pretty printer for the term portions, with occasional tactics inserted at various points (and then returning to term mode with <code>exact</code>). Does anyone have an idea for how this might be done?</p>",
        "id": 523201837,
        "sender_full_name": "Chase Norman",
        "timestamp": 1749527760
    },
    {
        "content": "<p>I'm thinking about using a custom delaborator for the tactic portions.</p>",
        "id": 523203008,
        "sender_full_name": "Chase Norman",
        "timestamp": 1749528662
    },
    {
        "content": "<p>Can you say more about how exactly you are representing terms? If everything is Syntax, then you can use <code>Lean.PrettyPrinter.ppTerm</code> for example to format it, even if there are nested tactics.</p>\n<p>If you have <code>Expr</code>s that you want to pretty print, then there's the important question of how you're embedding un-evaluated tactic scripts in your data model.</p>",
        "id": 523342962,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749577952
    },
    {
        "content": "<p>It‚Äôs a custom data structure that is essentially an Expr with embedded data about where tactics are necessary, if any. I have code that translates this into a Lean Expr, ignoring any tactic data, which can then be pretty printed (but does not type check)</p>",
        "id": 523347493,
        "sender_full_name": "Chase Norman",
        "timestamp": 1749579639
    },
    {
        "content": "<p>So I can output any structure that is necessary. But it would be hard to output syntax unless I could use the pretty printer for my terms</p>",
        "id": 523347611,
        "sender_full_name": "Chase Norman",
        "timestamp": 1749579683
    },
    {
        "content": "<p>I assume the data structure for tactics is custom too? And it's a mutual inductive with your custom Expr-like structure embedded into the <code>exact</code> constructors?</p>",
        "id": 523348858,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749580149
    },
    {
        "content": "<p>Do the tactic scripts ever introduce variables or otherwise modify the types of variables? Or do they always just change the type of the goal?</p>\n<p>If the tactics can do more arbitrary things, then there's the large complication that you can't reliably pretty print <code>Expr</code>s inside the tactics, without computing what the local context will be at the <code>exact</code>.</p>",
        "id": 523349281,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749580310
    },
    {
        "content": "<p>A hacky approach I suggested to Chase would be to first pretty-print the tactic into <code>Syntax</code>, then embed them as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.DataValue.ofSyntax#doc\">docs#Lean.DataValue.ofSyntax</a> in the <code>Expr</code>, and then pretty-print the term with a custom delaborator that, when it sees such mdata, just prints out that syntax. This would have to happen recursively to accommodate the arbitrary nesting.</p>",
        "id": 523353848,
        "sender_full_name": "ùö†ùöòùöìùöåùöíùöéùöåùöë ùöóùöäùö†ùöõùöòùöåùöîùöí",
        "timestamp": 1749582263
    },
    {
        "content": "<p>I want my framework to be generalizable, but for now the most form is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n<span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">recursive</span><span class=\"w\"> </span><span class=\"n\">call</span><span class=\"o\">)</span>\n<span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>Essentially, I want certain simp lemmas to be applied to unify the goal with the term. But I can imagine more general situations where the type of a variable is modified with these rewrites.</p>",
        "id": 523356340,
        "sender_full_name": "Chase Norman",
        "timestamp": 1749583389
    },
    {
        "content": "<p>For <code>h</code> in <code>exact h</code>, do you have a local context available for that point of the tactic script?</p>\n<p>One hacky idea I have, along the lines of Wojciech's, is that you could create an Expr for the whole thing, including with elaborated tactic scripts (if possible). You make sure that this Expr has two sorts of features:</p>\n<ol>\n<li>Wherever there's a <code>by</code>, you have some mdata marking it as a tactic script, and include an ofSyntax with the tactic script. This tactic script would include special syntax nodes for where expressions should be spliced in (e.g. a <code>insert_expr% exprId27</code> syntax node).</li>\n<li>Inside that tactic term, you have some subexpressions marked with some mdata indicating that it's the target of one of these <code>insert_expr%</code> nodes, along with its expression id.</li>\n</ol>\n<p>Then, you have a custom delaborator for terms marked with the tactic script mdata. It would then go through its whole term, looking for marked subexpressions, delaborating them and collecting them into a map (being careful to use the delaboration framework to enter binding constructs as necessary), and finally using this to replace all the <code>insert_expr%</code> nodes in the tactic syntax.</p>\n<p>This requires actually running the tactic scripts to create proof terms, and being able to interleave translating your expr-like type to Expr with running these scripts.</p>\n<p>Wojciech's recursive approach seems like it would be simpler, especially if you know what the local context and expected type are supposed to be at each <code>exact</code> without running the tactic scripts.</p>",
        "id": 523359478,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749584788
    },
    {
        "content": "<p>Well, in my example the local context shouldn't be different at h. <code>simp only</code> only affects the goal. </p>\n<p>Perhaps this is what you're saying, but I'm thinking of just having some kind of <code>mdata</code> that contains the lemmas for <code>simp only</code>, and a delaborator for it that generates the tactic calls. Looking at some example delaborators, they can return execution flow to the main delaborator with a simple <code>delab</code> call, which I would do at that point that says <code>(recursive call)</code>.</p>",
        "id": 523360019,
        "sender_full_name": "Chase Norman",
        "timestamp": 1749584998
    },
    {
        "content": "<p><code>simp only [...] at h</code> changes the local context though, right?</p>",
        "id": 523360289,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749585112
    },
    {
        "content": "<p>But after that all I do is <code>exact h</code>. So no delaboration is necessary on that changed context.</p>",
        "id": 523360409,
        "sender_full_name": "Chase Norman",
        "timestamp": 1749585153
    },
    {
        "content": "<p>Earlier you had examples like <code>exact Eq.refl b</code>. Are you saying that <code>exact h</code> is supposed to mean that <code>h</code> can only be a free variable?</p>",
        "id": 523360576,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749585214
    },
    {
        "content": "<p>Essentially I want to unify the goal type with the type of the proof, but I don't know of a single tactic to do this. So the general form is the one I gave in my second message. If no reductions are required at <code>h</code>, then you can just collapse the recursive call into an exact statement, explaining my first message.</p>",
        "id": 523360737,
        "sender_full_name": "Chase Norman",
        "timestamp": 1749585285
    },
    {
        "content": "<p>Out of curiosity, how would delaboration be affected by changes to the local context? Is it secretly inferring types in the background?</p>",
        "id": 523360950,
        "sender_full_name": "Chase Norman",
        "timestamp": 1749585372
    },
    {
        "content": "<p>Delaboration assumes it's given type-correct terms, basically. Even the app pretty printer needs to be able to infer types of a function to know which arguments are implicit or explicit, but also there are options to have the delaborator insert type ascriptions in some positions.</p>",
        "id": 523361824,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749585739
    },
    {
        "content": "<p>It's possible that in your case this doesn't matter, since it's all about using tactics like simp to align mismatched types.</p>",
        "id": 523362089,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749585841
    },
    {
        "content": "<p>By the way, <code>simpa only [...] using e</code> is a way to do <code>have h := e; simp only [...] at h |-; exact h</code>. It might be convenient, if it's ok to simplify the goal too at the same time.</p>",
        "id": 523362273,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749585914
    },
    {
        "content": "<p>Oh, wonderful! I‚Äôll try that</p>",
        "id": 523364296,
        "sender_full_name": "Chase Norman",
        "timestamp": 1749586846
    },
    {
        "content": "<p>How can I avoid Lean changing <code>Nat.zero_add</code> to <code>Nat.zero_add‚úù</code> in this example: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"n\">PrettyPrinter</span><span class=\"w\"> </span><span class=\"n\">Delaborator</span><span class=\"w\"> </span><span class=\"n\">SubExpr</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">dbg_trace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">ppCategory</span><span class=\"w\"> </span><span class=\"ss\">`tactic</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_add</span><span class=\"o\">])))</span>\n</code></pre></div>\n<p>More generally, how can I convert a <code>List Name</code> into <code>Syntax</code> for the list <code>simp</code> expects?</p>",
        "id": 523846963,
        "sender_full_name": "Chase Norman",
        "timestamp": 1749770309
    },
    {
        "content": "<p>This is a result of sanitization adding macro scopes</p>",
        "id": 523847124,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749770465
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"n\">PrettyPrinter</span><span class=\"w\"> </span><span class=\"n\">Delaborator</span><span class=\"w\"> </span><span class=\"n\">SubExpr</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">dbg_trace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">ppCategory</span><span class=\"w\"> </span><span class=\"ss\">`tactic</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`Nat.zero_add</span><span class=\"o\">):</span><span class=\"n\">ident</span><span class=\"o\">])))</span>\n</code></pre></div>",
        "id": 523847154,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749770486
    },
    {
        "content": "<p>For converting a list of names to a syntax, this should work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"n\">PrettyPrinter</span><span class=\"w\"> </span><span class=\"n\">Delaborator</span><span class=\"w\"> </span><span class=\"n\">SubExpr</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">`tactic</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Unhygienic</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">cc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">`ident</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">toArray</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">cc</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">],</span><span class=\"bp\">*</span><span class=\"o\">])</span>\n</code></pre></div>",
        "id": 523847401,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749770711
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 523884228,
        "sender_full_name": "Chase Norman",
        "timestamp": 1749798545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346696\">Chase Norman</span> has marked this topic as resolved.</p>",
        "id": 523884429,
        "sender_full_name": "Notification Bot",
        "timestamp": 1749798657
    }
]