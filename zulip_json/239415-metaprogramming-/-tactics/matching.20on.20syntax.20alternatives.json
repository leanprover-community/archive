[
    {
        "content": "<p>i'd like to match on a syntax rule wich contains <code>l &lt;|&gt; r</code> with syntax quotations.<br>\nIs there a way to do this which introduces variables <code>l : Option (TSyntax ``l)</code> and <code>r : Option (TSyntax ``r)</code>? or maybe somehow get <code>Sum (TSyntax ``l) (TSyntax ``r)</code>?</p>\n<p>(my concrete usecase is that I'd like to extract the head <code>ident</code> from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.Tactic.inductionAltLHS#doc\">docs#Lean.Parser.Tactic.inductionAltLHS</a> with only two match branches, where the second returns <code>throwUnsupportedSyntax</code>)</p>",
        "id": 510119157,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743754717
    },
    {
        "content": "<p><del>I think <code>l &lt;|&gt; r</code> is an \"untagged\" sum, so you need to differentiate it by hand.</del></p>",
        "id": 510143660,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743761740
    },
    {
        "content": "<p>how do you mean \"untagged\"? do you mean that there is no syntax node where we can see that indeed this part of syntax matches an alternative?</p>",
        "id": 510143904,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743761816
    },
    {
        "content": "<p>For example, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sum#doc\">docs#Sum</a> is tagged, since the extra constructor on top means you can distinguish <code>.inl ()</code> from <code>.inr ()</code>, <del>but the representation of <code>l &lt;|&gt; r</code> doesn't have that extra layer.</del></p>",
        "id": 510144417,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743761968
    },
    {
        "content": "<p>Oh, misread the symbol. Disregard everything I just said.</p>",
        "id": 510144947,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743762136
    }
]