[
    {
        "content": "<p>Is there an easy way to do this?</p>\n<p>One way is to iterate through one environment and filter out the constants which are in the other environment. This is slow when there are lots of symbols. On the other hand, <code>Environment</code> does not store constants in an ordered sequence, making this feature difficult to implement.</p>\n<p>I think if the environment stores constants in order, it would make calculating differentials much easier.</p>",
        "id": 524956227,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1750374008
    },
    {
        "content": "<p>I have found that for a certain (quite arbitrary) subset of constants the order was quite consistent across mathlib versions</p>",
        "id": 524956437,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750374146
    },
    {
        "content": "<p>The order in which object?</p>",
        "id": 524956451,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1750374156
    },
    {
        "content": "<p>The order in the <code>(‚Üê getEnv).constants.toList</code></p>",
        "id": 524956599,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750374319
    },
    {
        "content": "<p>what I mean is if some process inserts additional constants into an environment, I want to capture the constants generated in this process. In this case since <code>.constants</code> is a hash table, its order is not guaranteed</p>",
        "id": 524959559,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1750377376
    },
    {
        "content": "<p>That's what I'm saying - the order is not guaranteed, but it was more consistent across mathlib versions than I expected</p>",
        "id": 524960038,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750377725
    },
    {
        "content": "<p>Is it fine if I open a PR that adds a new field to <code>Environment</code>, where the constant names are stored in order?</p>",
        "id": 524961750,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1750378874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Calculating.20the.20delta.20between.20two.20.60Environment.60s/near/524956227\">said</a>:</p>\n<blockquote>\n<p>I think if the environment stores constants in order, it would make calculating differentials much easier.</p>\n</blockquote>\n<p>This seems more directed toward speed than ease, or am I missing something? What is the use case, and do you need the diff to cover every declaration in the environment?</p>",
        "id": 524963342,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1750380025
    },
    {
        "content": "<p>It's no longer being maintained, but this is the purpose of <a href=\"https://github.com/alexjbest/leaff\">https://github.com/alexjbest/leaff</a>. Maybe you want to resurrect it?</p>",
        "id": 524968118,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1750385407
    },
    {
        "content": "<p>There are two use cases:</p>\n<p>One is during data scraping from Lean files where I establish a correspondence between compilation units and constant names in the environment. I would run a Lean file unit by unit and calculate which new constants were introduced in a unit.</p>\n<p>The other one is to collect generated auxiliary lemmas for proof replay. I know I can just query the aux lemma environment extension, but there is nothing preventing a tactic from defining its own extension and generating lemmas bypassing the env extension. Hence I want to query what new constants were generated after a tactic runs.</p>",
        "id": 524968264,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1750385549
    },
    {
        "content": "<p>Maybe the newish <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Environment.replayConsts#doc\">docs#Lean.Environment.replayConsts</a> works for you. This is what I now use in Aesop to reconcile branches on which different consts were added, including aux decls. If a tactic breaks this functionality, it's arguably the tactic's problem. ^^</p>\n<p>Note that with async compilation, consts are not added in a fixed order any more. There is probably still an order in terms of where they appear in a file, but if we get more fine-grained parallelism in the future, we might not even have that.</p>",
        "id": 525059592,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1750432089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Calculating.20the.20delta.20between.20two.20.60Environment.60s/near/525059592\">said</a>:</p>\n<blockquote>\n<p>Maybe the newish <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Environment.replayConsts#doc\">docs#Lean.Environment.replayConsts</a> works for you. This is what I now use in Aesop to reconcile branches on which different consts were added, including aux decls. If a tactic breaks this functionality, it's arguably the tactic's problem. ^^</p>\n<p>Note that with async compilation, consts are not added in a fixed order any more. There is probably still an order in terms of where they appear in a file, but if we get more fine-grained parallelism in the future, we might not even have that.</p>\n</blockquote>\n<p>Is there a function that explicitly returns the delta so I don't have to pickle the entire environment when I send something across threads?</p>\n<p>I also need to detect cases of collision with <code>dest</code> and <code>new</code> have constants that don't exist in <code>old</code>.</p>",
        "id": 525065965,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1750434445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Calculating.20the.20delta.20between.20two.20.60Environment.60s/near/525065965\">said</a>:</p>\n<blockquote>\n<p>Is there a function that explicitly returns the delta so I don't have to pickle the entire environment when I send something across threads?</p>\n</blockquote>\n<p>Not as far as I'm aware, but you can look at the implementation of <code>replayConsts</code>. I believe it 'diffs' the <code>asyncConsts</code>, which seems like a bit of a hack but whatever.</p>",
        "id": 525080814,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1750441266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> has marked this topic as resolved.</p>",
        "id": 525796410,
        "sender_full_name": "Notification Bot",
        "timestamp": 1750888832
    }
]