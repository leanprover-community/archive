[
    {
        "content": "<p>I am trying to write an elaborator <code>filltype</code> to replace a hole (meant for a type variable) with a given type. E.g. <code>filltype Int (List ?X)</code> to <code>List Int</code>. For a single type, something like this seems to work, but the last result here is unexpected:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"n\">Command</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">filltype</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"filltype\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n<span class=\"n\">elab_rules</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filltype</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">tyvar</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">expr</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">pattern</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">replaceM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">          </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"bp\">.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Term.syntheticHole</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">            </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">tyvar</span>\n<span class=\"w\">          </span><span class=\"k\">else</span>\n<span class=\"w\">            </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">stx</span>\n<span class=\"w\">        </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">elabType</span><span class=\"w\"> </span><span class=\"n\">pattern</span>\n\n<span class=\"c1\">-- these two are as expected</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">filltype</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">X</span><span class=\"w\">        </span><span class=\"c1\">-- Int : Type</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">filltype</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">       </span><span class=\"c1\">-- Nat : Type</span>\n\n<span class=\"c1\">-- but this seems to have no effect</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">filltype</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- List ?X : Type u_1</span>\n</code></pre></div>",
        "id": 496824048,
        "sender_full_name": "Chris Henson",
        "timestamp": 1738256007
    },
    {
        "content": "<p>In case it is relevant, the fuller scope of what I'd like the elaborator to do is take some type with holes, e.g. <code>List (?X x ?Y)</code>, and elaborate to a command that looks something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>where <code>A</code> and <code>B</code> are some existing typeclasses.</p>",
        "id": 496826858,
        "sender_full_name": "Chris Henson",
        "timestamp": 1738256834
    },
    {
        "content": "<p>For replaceM, if you return non-<code>none</code>, then it accepts that as the replacement and it does not recurse.</p>\n<p>Try doing <code>pure none</code> in the <code>else</code> clause instead</p>",
        "id": 496828337,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738257314
    },
    {
        "content": "<p>That worked, thanks!</p>",
        "id": 496829933,
        "sender_full_name": "Chris Henson",
        "timestamp": 1738257822
    }
]