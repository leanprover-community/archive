[
    {
        "content": "<p>Often a tactic involves creating some \"intermediate\" metavariable, which is both created and assigned over the course of the tactic. E.g., the tactic might involve something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span> <span class=\"n\">Term</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"make_intermediate_goal\"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">elabType</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">.</span><span class=\"n\">syntheticOpaque</span> <span class=\"bp\">`</span><span class=\"n\">a</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">elabType</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">.</span><span class=\"n\">syntheticOpaque</span> <span class=\"bp\">`</span><span class=\"n\">b</span>\n  <span class=\"n\">a.mvarId</span><span class=\"bp\">!.</span><span class=\"n\">assign</span> <span class=\"n\">b</span>\n  <span class=\"n\">appendGoals</span> <span class=\"o\">[</span><span class=\"n\">b.mvarId</span><span class=\"bp\">!</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The mvar <code>a</code> gets created and assigned over the course of the tactic, and we shouldn't even know about it when calling the tactic.</p>\n<p>Of course, if you have control over the names of the intermediate mvars, you can just give them inaccessible names in the first place. But sometimes names are created automatically, such as in <code>forallMetaTelescope</code>.</p>\n<p>Consider the following example of this \"in the wild\", which can cause confusing behavior if you're naming a new metavariable during e.g. <code>refine'</code> after <code>constructor</code>, where the type has named parameters (in this case <code>And (a b : Prop)</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"n\">True.intro</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"bp\">∧</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">refine'</span> <span class=\"n\">f</span> <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"c1\">-- application type mismatch</span>\n    <span class=\"c1\">-- f True / argument / True / has type / Prop : Type / but is expected to have type / Nat : Type</span>\n</code></pre></div>\n<p>Here, the metavariable <code>?a</code> got created for <code>And</code> and assigned to <code>True</code> during <code>constructor</code>, unbeknownst to the user, who would probably assume it was free to use.</p>\n<hr>\n<p>I was wondering what the best way to deal with this is, in general. You can of course rename everything by hand, but that seems very low-level. Is there (or should there be) some kind of combinator that would render all metavariables created during a monadic computation inaccessible? Something roughly along the lines of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">withInaccessibleAssignedMVars</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mvarCounterSaved</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getMCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mvarCounter</span>\n  <span class=\"k\">let</span> <span class=\"n\">val</span> <span class=\"bp\">←</span> <span class=\"n\">k</span>\n  <span class=\"n\">for</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span><span class=\"o\">,</span> <span class=\"n\">decl</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getMCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">decls</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"n\">decl.index</span> <span class=\"bp\">&gt;=</span> <span class=\"n\">mvarCounterSaved</span>\n        <span class=\"bp\">&amp;&amp;</span> <span class=\"bp\">!</span><span class=\"n\">decl.userName.isInaccessibleUserName</span>\n        <span class=\"bp\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvarId.isAssigned</span><span class=\"o\">)</span>\n    <span class=\"k\">then</span>\n      <span class=\"n\">mvarId.setUserName</span> <span class=\"o\">(</span><span class=\"n\">decl.userName.appendAfter</span> <span class=\"s2\">\"✝\"</span><span class=\"o\">)</span>\n  <span class=\"n\">return</span> <span class=\"n\">val</span>\n</code></pre></div>\n<p>(but with a more careful way of rendering usernames inaccessible).</p>\n<p>Or maybe elaboration should as a matter of principle consider assigned mvars \"dead\" and should clean up the mctx on the fly (making the old mvar with that username inaccessible one way or another, and creating a new mvar with the same username).</p>\n<p>This might be a bad idea, as then you couldn't refer to metavariables again once they were assigned without some special tool to do so—however, it would be one less responsibility to manage during metaprogramming (and there are already a few), and makes a kind of intuitive sense (assignment ~ replacement).</p>\n<p>Or maybe there's already a standard way to deal with this issue. :)</p>",
        "id": 386268540,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1692574828
    },
    {
        "content": "<p>Also, here’s a slightly refined version of the code:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- Executes `k`, and makes all of the metavariables created during `k` inaccessible to the user by</span>\n<span class=\"sd\">acting on their username with `mkFreshUserName`.</span>\n\n<span class=\"sd\">By default, only assigned metavariables are made inaccessible.</span>\n\n<span class=\"sd\">The argument `shouldHide : MVarId → m Bool` can be specified to hide metavariable names using a</span>\n<span class=\"sd\">condition other than assignment status; when `← shouldHide mvarId` is `true`, `mvarId` will be</span>\n<span class=\"sd\">renamed with an inaccessible name. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">withoutCreatingAccessibleGoals</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadLiftT</span> <span class=\"n\">CoreM</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadMCtx</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">shouldHide</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">MVarId.isAssigned</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">initialMVarCounter</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getMCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mvarCounter</span>\n  <span class=\"k\">let</span> <span class=\"n\">val</span> <span class=\"bp\">←</span> <span class=\"n\">k</span>\n  <span class=\"n\">for</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span><span class=\"o\">,</span> <span class=\"n\">decl</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getMCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">decls</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"n\">decl.index</span> <span class=\"bp\">&gt;=</span> <span class=\"n\">initialMVarCounter</span>\n        <span class=\"bp\">&amp;&amp;</span> <span class=\"bp\">!</span><span class=\"n\">decl.userName.isInaccessibleUserName</span>\n        <span class=\"bp\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">shouldHide</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span>\n    <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">newUserName</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshUserName</span> <span class=\"n\">decl.userName</span>\n      <span class=\"n\">modifyMCtx</span> <span class=\"k\">fun</span> <span class=\"n\">mctx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mctx.setMVarUserName</span> <span class=\"n\">mvarId</span> <span class=\"n\">newUserName</span>\n  <span class=\"n\">return</span> <span class=\"n\">val</span>\n</code></pre></div>\n</div></div>",
        "id": 402519429,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700155180
    },
    {
        "content": "<p>(Though, thinking about it now, we should also be able to hide goals on the basis of the value we obtain from the computation, so that we can e.g. return a list of goals that should not be user-facing.)</p>",
        "id": 402521459,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700155805
    }
]