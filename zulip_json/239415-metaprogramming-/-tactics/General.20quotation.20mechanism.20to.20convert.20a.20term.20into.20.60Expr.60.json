[
    {
        "content": "<p>Is there a general way in Lean to translate a normal term into its meta-level equivalent, an <code>Expr</code>? Essentially, I am looking for a functionality similar to Agda's <code>quote</code> and MetaCoq's <code>tmQuote</code>.</p>",
        "id": 485174073,
        "sender_full_name": "David Deng",
        "timestamp": 1732924433
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.ToExpr#doc\">docs#Lean.ToExpr</a></p>",
        "id": 485174307,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732924625
    },
    {
        "content": "<p>Thanks! It works great for primitive types. And I wonder if I want to extend it to work also for functions, what should I do in their implementation? For example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">plus</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">ToExpr</span><span class=\"bp\">.</span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"n\">plus</span><span class=\"w\"> </span><span class=\"c1\">-- failed to synthesize ToExpr (Nat → Nat → Nat)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toExpr</span><span class=\"w\">     </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- what should I use here?</span>\n<span class=\"w\">  </span><span class=\"n\">toTypeExpr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- And here?</span>\n</code></pre></div>",
        "id": 485175154,
        "sender_full_name": "David Deng",
        "timestamp": 1732925331
    },
    {
        "content": "<p>There's no way to do that — is that something that Agda/MetaCoq can somehow do? If so, I'm curious what they're doing.</p>",
        "id": 485176700,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732926700
    },
    {
        "content": "<p>So MetaCoq is using <code>Ffix</code> to denote recursive constructs in the meta program:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Check</span> <span class=\"n\">plus</span><span class=\"o\">.</span> <span class=\"c\">(* : forall (_ : nat) (_ : nat), nat *)</span>\n<span class=\"kn\">Compute</span> <span class=\"n\">tmQuote</span> <span class=\"n\">plus</span><span class=\"o\">.</span>\n<span class=\"c\">(* = @tmQuote (forall (_ : nat) (_ : nat), nat) *)</span>\n<span class=\"c\">(*          (fix Ffix (x x0 : nat) {struct x} : nat := *)</span>\n<span class=\"c\">(*             match x return nat with *)</span>\n<span class=\"c\">(*             | @O =&gt; x0 *)</span>\n<span class=\"c\">(*             | @S x1 =&gt; S (Ffix x1 x0) *)</span>\n<span class=\"c\">(*             end) *)</span>\n<span class=\"c\">(*      : TemplateMonad term *)</span>\n</code></pre></div>\n<p>I believe Agda can do something similar based on one usage of <code>quote _+_</code> in their documentation <a href=\"https://agda.readthedocs.io/en/latest/language/reflection.html\">https://agda.readthedocs.io/en/latest/language/reflection.html</a></p>",
        "id": 485177510,
        "sender_full_name": "David Deng",
        "timestamp": 1732927474
    },
    {
        "content": "<p>Ah, <code>ToExpr</code> is for turning runtime values into Exprs, but do I have it right that Agda's <code>quote</code> is taking the compile-time expression and turning it into an expr that represents the Expr?</p>",
        "id": 485178047,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732927937
    },
    {
        "content": "<p>(That's why <code>ToExpr (Nat -&gt; Nat -&gt; Nat)</code> can't possibly work — how do you take an arbitrary run-time closure and reflect it to an Expr? But there's no problem if you're working with Expr and only Expr.)</p>",
        "id": 485178068,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732927982
    },
    {
        "content": "<p>Mathlib has a <code>ToExpr Expr</code> instance, and with it you can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">ToExpr</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Meta</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"quote_expr% \"</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">withSynthesize</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">quote_expr</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Expr.lam `a (Expr.const `Nat [])</span>\n<span class=\"cm\">  (Expr.lam `b (Expr.const `Nat [])</span>\n<span class=\"cm\">    (((((((Expr.const `HAdd.hAdd [Level.zero, Level.zero, Level.zero]).app (Expr.const `Nat [])).app</span>\n<span class=\"cm\">                      (Expr.const `Nat [])).app</span>\n<span class=\"cm\">                  (Expr.const `Nat [])).app</span>\n<span class=\"cm\">              (((Expr.const `instHAdd [Level.zero]).app (Expr.const `Nat [])).app (Expr.const `instAddNat []))).app</span>\n<span class=\"cm\">          (Expr.bvar 1)).app</span>\n<span class=\"cm\">      (Expr.bvar 0))</span>\n<span class=\"cm\">    BinderInfo.default)</span>\n<span class=\"cm\">  BinderInfo.default : Expr</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 485178216,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732928130
    },
    {
        "content": "<p>Anyway, that's the idea. If you want the behavior where it takes an identifier instead of an expression and quotes the declaration's definition, that's easy to do as well.</p>",
        "id": 485178348,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732928261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485178047\">said</a>:</p>\n<blockquote>\n<p>Ah, <code>ToExpr</code> is for turning runtime values into Exprs, but do I have it right that Agda's <code>quote</code> is taking the compile-time expression and turning it into an expr that represents the Expr?</p>\n</blockquote>\n<p>I am not familiar with the internals of a proof assistant. Would you mind explaining me a bit more on what is runtime and what is compile-time? What is the essential difference between a runtime closure and a compile-time function?</p>",
        "id": 485178397,
        "sender_full_name": "David Deng",
        "timestamp": 1732928293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485178348\">said</a>:</p>\n<blockquote>\n<p>Anyway, that's the idea. If you want the behavior where it takes an identifier instead of an expression and quotes the declaration's definition, that's easy to do as well.</p>\n</blockquote>\n<p>Yes. I think that would be what I wanted to do. The mathlib example looks great, but do I need the library in order to reflect an identifier's definition?</p>",
        "id": 485178468,
        "sender_full_name": "David Deng",
        "timestamp": 1732928399
    },
    {
        "content": "<p>By \"compile time expression\" I'm loosely referring to meta representations of values, like Expr or maybe Syntax. This is the representation that elaboration makes use of, but an Expr whose type is computed to be an Expr that represents <code>Nat -&gt; Nat -&gt; Nat</code> is not itself an executable function.</p>\n<p>By \"runtime\" I'm meaning the terms of a type after code extraction. So for example, a term of <code>Nat -&gt; Nat -&gt; Nat</code> in this case is more-or-less machine code. If you are running a program that makes use of terms of <code>Nat -&gt; Nat -&gt; Nat</code>, there is no reflection of that value that you are allowed to do.</p>",
        "id": 485179663,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732929343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"783900\">David Deng</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485178468\">said</a>:</p>\n<blockquote>\n<p>but do I need the library in order to reflect an identifier's definition?</p>\n</blockquote>\n<p>That's where there's a <code>ToExpr Expr</code> instance. If you don't want to use mathlib, you can try to extract the relevant code.</p>\n<p>There's a project in progress to move this instance to core Lean, but you shouldn't expect it for the next release.</p>",
        "id": 485179801,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732929450
    },
    {
        "content": "<p>Could you say a bit about what you're doing? I'm worried you might be going into some direction here that's not how people normally do metaprogramming. It's very niche turning an Expr into an Expr that evaluates to the Expr.</p>",
        "id": 485180172,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732929765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485179663\">said</a>:</p>\n<blockquote>\n<p>By \"compile time expression\" I'm loosely referring to meta representations of values, like Expr or maybe Syntax. This is the representation that elaboration makes use of, but an Expr whose type is computed to be an Expr that represents <code>Nat -&gt; Nat -&gt; Nat</code> is not itself an executable function.</p>\n<p>By \"runtime\" I'm meaning the terms of a type after code extraction. So for example, a term of <code>Nat -&gt; Nat -&gt; Nat</code> in this case is more-or-less machine code. If you are running a program that makes use of terms of <code>Nat -&gt; Nat -&gt; Nat</code>, there is no reflection of that value that you are allowed to do.</p>\n</blockquote>\n<p>I see what you are saying. I am not trying to do reflection on runtime terms. <br>\nI only want to \"quote\" the expressions based on their face value at the definition site, as in the examples above.</p>",
        "id": 485180654,
        "sender_full_name": "David Deng",
        "timestamp": 1732930179
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485179801\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"783900\">David Deng</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485178468\">said</a>:</p>\n<blockquote>\n<p>but do I need the library in order to reflect an identifier's definition?</p>\n</blockquote>\n<p>That's where there's a <code>ToExpr Expr</code> instance. If you don't want to use mathlib, you can try to extract the relevant code.</p>\n<p>There's a project in progress to move this instance to core Lean, but you shouldn't expect it for the next release.</p>\n</blockquote>\n<p>Okay, that makes sense. Can you explain a bit more on what the <code>elab</code> command is doing here though?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"quote_expr% \"</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">withSynthesize</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 485180746,
        "sender_full_name": "David Deng",
        "timestamp": 1732930239
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"783900\">David Deng</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485180654\">said</a>:</p>\n<blockquote>\n<p>I only want to \"quote\" the expressions based on their face value at the definition site, as in the examples above.</p>\n</blockquote>\n<p>Could you explain more about what your application is?</p>",
        "id": 485181194,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732930588
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485180172\">said</a>:</p>\n<blockquote>\n<p>Could you say a bit about what you're doing? I'm worried you might be going into some direction here that's not how people normally do metaprogramming. It's very niche turning an Expr into an Expr that evaluates to the Expr.</p>\n</blockquote>\n<p>Yeah, sure, though I guess what I am trying to do is indeed a bit unconventional. I am trying to embed another language using Lean's regular terms (e.g. functions), and then convert those terms in Lean into string format of its corresponding language. The reason that I want to use Lean's regular term as a host language is because its dependent type can be used to embed extra information (e.g. the stack length of a PostScript program) to verify program correctness.</p>\n<p>In other words, I am trying to replicate <a href=\"https://dl.acm.org/doi/10.1145/3486609.3487201\">https://dl.acm.org/doi/10.1145/3486609.3487201</a> in Lean. The original paper used Agda.</p>",
        "id": 485181202,
        "sender_full_name": "David Deng",
        "timestamp": 1732930601
    },
    {
        "content": "<p><code>Term.elabTerm</code> takes Syntax and elaborates it to an Expr. The <code>withSynthesize</code> function completes the elaboration, and in the end you have to be sure to instantiate metavariables that might still be present in the expression.</p>",
        "id": 485181740,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732931128
    },
    {
        "content": "<p>Having skimmed some of the paper, I'm having doubts that you want to use <code>ToExpr Expr</code>. All the examples in the paper using <code>quote</code> seem to be not much more than doing basic constructions for expressions.</p>",
        "id": 485181861,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732931231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485181740\">said</a>:</p>\n<blockquote>\n<p><code>Term.elabTerm</code> takes Syntax and elaborates it to an Expr. The <code>withSynthesize</code> function completes the elaboration, and in the end you have to be sure to instantiate metavariables that might still be present in the expression.</p>\n</blockquote>\n<p>Thanks for the explanation -- mostly make sense to me. <br>\nStill,</p>\n<ol>\n<li>What does the <code>&lt;|</code> operator do? </li>\n<li>How can a term contain uninstantiated meta variables if the term's definition is already available?</li>\n</ol>",
        "id": 485183488,
        "sender_full_name": "David Deng",
        "timestamp": 1732932662
    },
    {
        "content": "<p>I think I'll have to direct you to resources such as <a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/\">https://leanprover-community.github.io/lean4-metaprogramming-book/</a> and <a href=\"https://lean-lang.org/functional_programming_in_lean/\">https://lean-lang.org/functional_programming_in_lean/</a></p>\n<p>The <code>&lt;|</code> operator is <code>$</code>, it's like a <code>(</code> that gets closed as late as possibel.</p>\n<p>Metavariables are represented by <code>Expr.mvar</code>, and the table of assignments is part of the elaborator's state. Since everything is immutable, you need to do an explicit step to do the substitutions for all the assignments that have accumulated.</p>",
        "id": 485183632,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732932825
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485181861\">said</a>:</p>\n<blockquote>\n<p>Having skimmed some of the paper, I'm having doubts that you want to use <code>ToExpr Expr</code>. All the examples in the paper using <code>quote</code> seem to be not much more than doing basic constructions for expressions.</p>\n</blockquote>\n<p>Well, I think the <code>quote</code> section of the paper is just giving an overview of Agda's reflection interface. In the repository, they do use <code>quote</code> to reflect functions whose type signature contains customly defined inductive structures, similar to the <code>plus</code> function above.</p>",
        "id": 485183636,
        "sender_full_name": "David Deng",
        "timestamp": 1732932835
    },
    {
        "content": "<p>Is it that they're quoting an arbitrary function, or that there's a global constant?</p>",
        "id": 485183708,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732932883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485183708\">said</a>:</p>\n<blockquote>\n<p>Is it that they're quoting an arbitrary function, or that there's a global constant?</p>\n</blockquote>\n<p>I believe the latter. The function being quoted is defined as a global constant.</p>",
        "id": 485183757,
        "sender_full_name": "David Deng",
        "timestamp": 1732932922
    },
    {
        "content": "<p>Yeah, that's what I was understanding from looking at the paper. In Lean you can access the environment and inspect constants' values. You can also refer to <code>Expr.const ``nameOfConstant [..]</code> where <code>..</code> stands for any universe levels you might need.</p>\n<p>There's also the Qq library do do this with some more compile-time typechecking.</p>",
        "id": 485183900,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732933080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485183900\">said</a>:</p>\n<blockquote>\n<p>In Lean you can access the environment and inspect constants' values.</p>\n</blockquote>\n<p>Are you referring to <code>getLCtx</code>? Can I inspect constant values if they are functions?</p>",
        "id": 485184675,
        "sender_full_name": "David Deng",
        "timestamp": 1732933723
    },
    {
        "content": "<p>No, that's the local context, not the environment.</p>",
        "id": 485185068,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732934086
    },
    {
        "content": "<p>Here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">info</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getConstInfo</span><span class=\"w\"> </span><span class=\"ss\">``Nat.add</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{info.value?}\"</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">fun x x_1 =&gt;</span>\n<span class=\"cm\">  Nat.brecOn (motive := fun x =&gt; Nat → Nat) x_1</span>\n<span class=\"cm\">    (fun x f x_2 =&gt;</span>\n<span class=\"cm\">      (match (motive := Nat → (x : Nat) → Nat.below (motive := fun x =&gt; Nat → Nat) x → Nat) x_2, x with</span>\n<span class=\"cm\">        | a, Nat.zero =&gt; fun x =&gt; a</span>\n<span class=\"cm\">        | a, b.succ =&gt; fun x =&gt; (x.1 a).succ)</span>\n<span class=\"cm\">        f)</span>\n<span class=\"cm\">    x</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 485185073,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732934089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485185073\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">info</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getConstInfo</span><span class=\"w\"> </span><span class=\"ss\">``Nat.add</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{info.value?}\"</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I got the following error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">▶</span><span class=\"w\"> </span><span class=\"mi\">71</span><span class=\"o\">:</span><span class=\"mi\">3</span><span class=\"bp\">-</span><span class=\"mi\">71</span><span class=\"o\">:</span><span class=\"mi\">36</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">typeclass</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">problem</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">stuck</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">often</span><span class=\"w\"> </span><span class=\"n\">due</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">metavariables</span>\n<span class=\"w\">  </span><span class=\"n\">Bind</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">2800</span>\n</code></pre></div>",
        "id": 485185603,
        "sender_full_name": "David Deng",
        "timestamp": 1732934624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485178068\">said</a>:</p>\n<blockquote>\n<p>(That's why <code>ToExpr (Nat -&gt; Nat -&gt; Nat)</code> can't possibly work — how do you take an arbitrary run-time closure and reflect it to an Expr? But there's no problem if you're working with Expr and only Expr.)</p>\n</blockquote>\n<p>I don't think we are taking \"arbitrary runtime closures,\" because <code>toExpr : α → Lean.Expr</code> also takes an object of type <code>α</code> that we want to reflect, and it should be possible for <code>toExpr</code> to analyze the structure of the object, reflecting it into an <code>Expr</code> object?</p>",
        "id": 485245767,
        "sender_full_name": "David Deng",
        "timestamp": 1732986503
    },
    {
        "content": "<p>I was recently discussing this kind of thing with some adga devs, because agda actually does support this (quoting runtime values into expressions) and it was a bit mind bending for me.</p>",
        "id": 485246015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732986711
    },
    {
        "content": "<p>The trick is that the evaluation of the metaprogram is happening via what we would call <code>whnf</code> or kernel evaluation, i.e. it's expression normalization rather than interpretation, and as a result all of the values are available in expression form. So when you normalize a call to the magic <code>quote</code> function it just grabs the expression it is applied to and quotes it into a deeply embedded expression value</p>",
        "id": 485246244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732986883
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"783900\">@David Deng</span> the issue you are having with Kyle's code is solved by adding a type annotation (this is fixed on nightly and I think Kyle is on the development version), i.e. <code>#eval show MetaM _ from do ...</code></p>",
        "id": 485246401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732987002
    },
    {
        "content": "<p>But for lean, reflecting objects of function type is not possible. <code>toExpr</code> is a typeclass function, so even if you call it someone has to implement it, and there is no way to implement an instance for <code>ToExpr (A -&gt; B)</code> because that code receives only a runtime closure object, not an expression, and is somehow tasked with building an expression from the closure object</p>",
        "id": 485246513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732987104
    },
    {
        "content": "<p>I'm wondering how impossible an (unsafe) <code>ToExpr (A -&gt; B)</code> is — I imagine a sufficiently smart decompiler could trace runtime objects and figure out an expression that represents the function, though I'd hate to try to un-erase all the types, proofs, and type parameters.</p>",
        "id": 485248311,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732988665
    },
    {
        "content": "<p>But David, what Mario's saying is pointing toward how implementing that paper in Lean will probably look fairly different. In Lean, you can do computations with Expr directly and there's no need to quote, since the Expr is already an Expr.</p>",
        "id": 485248537,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732988863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485248311\">said</a>:</p>\n<blockquote>\n<p>I'm wondering how impossible an (unsafe) <code>ToExpr (A -&gt; B)</code> is — I imagine a sufficiently smart decompiler could trace runtime objects and figure out an expression that represents the function, though I'd hate to try to un-erase all the types, proofs, and type parameters.</p>\n</blockquote>\n<p>Doing such an unerasing just from runtime information  for proofs seems impossible to me. A proof is just <code>lean_box(0)</code> (or sometimes not even that and just completely gone as a value), you cannot recover any information about it at all. So the unerasing procedure would need to be equivalent to writing a proof automatically. I guess it might be possible if you had access to the original Lean source code but even then it would be pretty horrific to implementz.</p>",
        "id": 485249134,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1732989363
    },
    {
        "content": "<p>At least you know that there was a proof to begin with, so All You Need To Do<span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span> is enumerate all expressions until you stumble across the proof :-)</p>",
        "id": 485249767,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732989813
    },
    {
        "content": "<p>You can probably do it for a limited class of runtime types. This is, after all, exactly what Normalization by Evaluation (NbE) is about</p>",
        "id": 485423419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733003598
    },
    {
        "content": "<p>you may need to tweak some details of the interpreter, but it can definitely be done in principle if the system is cooperating with this goal</p>",
        "id": 485423501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733003667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/General.20quotation.20mechanism.20to.20convert.20a.20term.20into.20.60Expr.60/near/485248537\">said</a>:</p>\n<blockquote>\n<p>But David, what Mario's saying is pointing toward how implementing that paper in Lean will probably look fairly different. In Lean, you can do computations with Expr directly and there's no need to quote, since the Expr is already an Expr.</p>\n</blockquote>\n<p>But wouldn't that basically \"force\" all expressions to have the same type (e.g. <code>Expr</code>) and give up the ability to use Lean's dependent type checker to provide some sort of correctness guarantee?</p>",
        "id": 485445342,
        "sender_full_name": "David Deng",
        "timestamp": 1733026349
    },
    {
        "content": "<p>You might be interested in the quote4 / <code>import Qq</code> library, which while providing no correctness guarantee, does make it easier to avoid typing mistakes</p>",
        "id": 485462628,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1733043217
    }
]