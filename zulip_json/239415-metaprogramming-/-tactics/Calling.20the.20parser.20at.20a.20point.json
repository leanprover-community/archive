[
    {
        "content": "<p>How do I call the parser? Basically I have a <code>String</code> and I want to parse it into <code>Syntax</code>, while letting it use any locally defined notation at a specific point in a source file. I'm running inside a linter if that helps, so I have a <code>Syntax</code> object that came from that specific point.<br>\nI found <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.runParserCategory#doc\">docs#Lean.Parser.runParserCategory</a> but I'm not sure that's it</p>",
        "id": 567329436,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768060739
    },
    {
        "content": "<p>(specifically, I'm taking the <code>stx : Syntax</code> object I get, modifying the string <code>stx.getSubstring?</code>, then I want to reparse it as if it was written at the same place)</p>",
        "id": 567329602,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768060871
    },
    {
        "content": "<p>I think usually it's just easier to manually create the <code>Syntax</code> you want?</p>",
        "id": 567337003,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1768067894
    },
    {
        "content": "<p>But I don't know what <code>Syntax</code> I want, the point is to check what the parser parses it as</p>",
        "id": 567340294,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768071079
    },
    {
        "content": "<p>I assume the parser has round-trip tests together with the pretty-printer, which have to call a \"parse\" function at some point, can you point me to them?</p>",
        "id": 567340396,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768071198
    },
    {
        "content": "<p>Would you mind <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> ’ing bit? It’s a bit unusual to be in this situation, and maybe this is the only way, but I’d really hope there’s another way :) This doesn’t sound like something a linter would usually do (but maybe there’s a specific use case).</p>\n<p>(Note also that you would need to take care of <code>open scoped</code>s that appear within the command itself if you were to parse!)</p>",
        "id": 567340801,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1768071651
    },
    {
        "content": "<p>Sure- I'm trying to solve <a href=\"https://github.com/leanprover-community/mathlib4/blob/7379a9f204985ff78ea2cb10c194a36ad69f0c4d/Mathlib/Data/Nat/Factorial/Basic.lean#L44\">this TODO</a> for factorial notation, using a linter.<br>\nThe idea is to find all uses of the factorial notation with a space before it, attempt to remove the spaces, and the reparsing is to figure out if we need to add parentheses or not.</p>\n<p>Not all situations need parentheses, and while we can do a conservative approximation with \"is this a numeral or already surrounded by parentheses\", I really want to know precisely if we need to add parentheses or not.<br>\nI started out with the approximation, then found out <code>3.!</code> is valid, then I found out that if I add <code>notation \"/\" =&gt; 3</code> then <code>/!</code> is valid, so I decided to ask the parser.</p>",
        "id": 567341433,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768072444
    },
    {
        "content": "<p>There's also the strange <code>[0][0] !</code> which needs parentheses</p>",
        "id": 567341719,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768072904
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Code skeleton</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">module</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"n\">meta</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Linter</span><span class=\"bp\">.</span><span class=\"n\">Header</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Syntax</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Init</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">TakeDrop</span>\n<span class=\"n\">meta</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">Linter</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Linter</span>\n\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"n\">register_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">style</span><span class=\"bp\">.</span><span class=\"n\">testing</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">defValue</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadLog</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddMessageContext</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadOptions</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">info</span><span class=\"w\"> </span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">kind</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"ss\">`Nat.term_!</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">child</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">atom</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"s2\">\"!\"</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"c1\">-- TODO: remove the space after `child`, reparse, and compare to `stx`.</span>\n<span class=\"w\">      </span><span class=\"c1\">--       if the result changes (besides the offset of the `!`), add parentheses.</span>\n<span class=\"w\">      </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"'{stx.getSubstring?.getD default}' '{child.getSubstring?.getD default}'\"</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">arg</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span>\n\n<span class=\"n\">initialize</span><span class=\"w\"> </span><span class=\"n\">addLinter</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">withSetOptionIn</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"n\">Linter</span><span class=\"bp\">.</span><span class=\"n\">getLinterValue</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">style</span><span class=\"bp\">.</span><span class=\"n\">testing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getLinterOptions</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">return</span>\n<span class=\"w\">  </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">stx</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Linter</span>\n</code></pre></div>\n</div></div>",
        "id": 567341853,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768073089
    },
    {
        "content": "<p>Ah, I see!</p>\n<p>This does seem like the right approach from one perspective! But I actually wonder if it’s better for human readability to just say</p>\n<ul>\n<li>numeric literals are unparenthesized</li>\n<li>everything else is parenthesized</li>\n</ul>\n<p>Then you know it’s a factorial, and not part of the name <em>or</em> notation. (We’d save some code complexity too.) But, are there real-world examples where we have some notation and want it followed by a <code>!</code>, without parentheses? Then it makes sense to take a reparsing approach.</p>",
        "id": 567343963,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1768075773
    },
    {
        "content": "<p>I don't think we have such a case in Mathlib based on a rudimentary regex search, so this sounds good, thanks!</p>",
        "id": 567344590,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768076619
    },
    {
        "content": "<p>I am still interested to know how to call the parser, though</p>",
        "id": 567344594,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768076621
    },
    {
        "content": "<p>Yes, me too—especially \"in the middle of a command\" like this! :) I started poking around, and I'm pretty sure <code>runParserCategory</code> is designed just for testing. It seems to use empty options and an empty parser state. To parse correctly, one approach would be to <code>run</code> the appropriate <code>ParserFn</code> (e.g. <code>categoryParserFnImpl catName</code> as <code>runParserCategory</code> uses, with <code>catName</code> being <code> `term</code>), but then set up the state so that the right declarations are open (and possibly some other facts?). I'm not sure what exactly this looks like yet.</p>\n<p>To get the open decls, at least, I think it might be sufficient to just consider <code>open</code> syntax that appears in the command, and collect them on your way to the nested syntax. I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.withOpenDecl#doc\">docs#Lean.Parser.withOpenDecl</a> (and component declarations) are the only thing that affects the parser, that they check for <code>open</code> explicitly, and that parsing completes entirely before any kind of elaboration, meaning that e.g. syntax like <code>classical</code> which opens scopes for elaboration do not also open scopes for parsing. Maybe!</p>",
        "id": 567344874,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1768077016
    },
    {
        "content": "<p>Hmm, actually, I suppose it's possible that a parser could depend on <code>withNamespaces</code> directly, and not check for <code>open</code> syntax. (Or be written from the ground up to modify the parser state.) Does e.g. <code>classical</code> do this? (Is there any scoped classical notation?)</p>",
        "id": 567345097,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1768077331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Calling.20the.20parser.20at.20a.20point/near/567344590\">said</a>:</p>\n<blockquote>\n<p>I don't think we have such a case in Mathlib based on a rudimentary regex search</p>\n</blockquote>\n<p>Actually I found <a href=\"https://github.com/leanprover-community/mathlib4/blob/4baa44807be87d9aba67c680ae68c2ba4a7fc29b/Mathlib/Data/Nat/Factorial/NatCast.lean#L106\">this</a> and <a href=\"https://github.com/leanprover-community/mathlib4/blob/4baa44807be87d9aba67c680ae68c2ba4a7fc29b/Mathlib/NumberTheory/Bernoulli.lean#L150\">this</a></p>",
        "id": 567345547,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768077822
    },
    {
        "content": "<p>And <a href=\"https://github.com/leanprover-community/mathlib4/blob/4baa44807be87d9aba67c680ae68c2ba4a7fc29b/Mathlib/RingTheory/Nilpotent/Exp.lean#L99\">here's</a> the same case but with a redundant space</p>",
        "id": 567345603,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768077900
    },
    {
        "content": "<p>Nice finds! Those in fact reinforce my feeling that they would be more readable/predictable if parenthesized, but I'm open to differing opinions <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 567345646,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1768077948
    }
]