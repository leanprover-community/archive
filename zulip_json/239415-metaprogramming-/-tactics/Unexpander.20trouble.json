[
    {
        "content": "<p>I have a problem with unexpanders when optional syntax is involved. I am writing STLC+integers+addition for a course (disclosure below): In order to simplify including integers, since they come up multiple times I declare the following syntax category:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span> <span class=\"n\">int</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"s2\">\"-\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">int</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[Z| \"</span> <span class=\"n\">int</span> <span class=\"s2\">\" ]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n</code></pre></div>\n<p>When writing the unexpander for my language I include an unexpander for int literals contained in a constructor called <code>IntLit</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">s.raw</span><span class=\"o\">⟩</span>\n<span class=\"kd\">@[</span><span class=\"n\">app_unexpander</span> <span class=\"n\">Expr.LitInt</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">unexpandLitInt</span> <span class=\"o\">:</span> <span class=\"n\">Unexpander</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">_Expr.LitInt</span> <span class=\"o\">[</span><span class=\"n\">Z</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">int</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"n\">lam</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n</code></pre></div>\n<p>Unfortunately this unexpander alone never kicks in. I can write expressions without any int literals and they unexpand very well.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">lam</span><span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"c1\">-- [lam| \"x\" ] : _root_.Expr</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">lam</span><span class=\"bp\">|</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"c1\">-- [lam| λ \"y\" ↦ \"y\" + \"y\" + \"x\" ] : _root_.Expr</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">lam</span><span class=\"bp\">|</span> <span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"c1\">-- Expr.LitInt (-1) : _root_.Expr</span>\n<span class=\"c1\">-- The last line is not unexpanding into [lam | -1] as it should</span>\n</code></pre></div>\n<p>I tried the exercise with <code>num</code> literals instead of <code>int</code> for  integers (which of course means no negatives), and then the unexpander works perfectly well .</p>\n<p>DISCLOSURE:</p>\n<ol>\n<li>This is derived from the exercise of a Semantics course I am auditing</li>\n<li>I am not taking this course for grades.</li>\n<li>The assignments are in Coq. They absolutely don't test my ability to write lean (or Coq) metaprograms. All this stuff is given already. I am writing it in Lean for convenience and for learning. No solutions are included anywhere here. </li>\n<li>The assignments are not graded. Grading is done through quizzes in the tutorials. The assignment is to help get comfortable with the proofs and Coq is just supposed to be an aide. It is not examined in any way.</li>\n</ol>",
        "id": 399406191,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698716652
    },
    {
        "content": "<p>I'd be grateful for any help in this.</p>",
        "id": 399406718,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698716943
    },
    {
        "content": "<p>If it helps to post all the code  I can create a web editor link as well with the entire file.</p>",
        "id": 399406942,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698717061
    },
    {
        "content": "<p>Here's my <a href=\"https://live.lean-lang.org/#code=import%20Mathlib.Tactic%0D%0Aimport%20Lean%0D%0A%0D%0Aopen%20Lean%20Lean.Syntax%20Lean.PrettyPrinter%0D%0A%0D%0Ainductive%20Binder%20where%0D%0A%20%20%7C%20BNamed%20(s%20%3A%20String)%0D%0A%20%20%7C%20BAnon%0D%0Aderiving%20Repr%0D%0A%0D%0Ainductive%20Expr%20where%0D%0A%20%20%7C%20Var%20(x%20%3A%20String)%0D%0A%20%20%7C%20Lam%20(x%20%3A%20Binder)%20(e%20%3A%20Expr)%0D%0A%20%20%7C%20App%20(e%E2%82%81%20e%E2%82%82%20%3A%20Expr)%0D%0A%20%20%7C%20LitInt%20(n%20%3A%20%E2%84%A4)%0D%0A%20%20%7C%20Plus%20(e%E2%82%81%20e%E2%82%82%20%3A%20Expr)%0D%0Aderiving%20Repr%0D%0A%0D%0Adeclare_syntax_cat%20int%0D%0Asyntax%20(%22-%22)%3F%20num%20%3A%20int%0D%0Asyntax%20%22%5BZ%7C%20%22%20int%20%22%20%5D%22%20%3A%20term%0D%0A%0D%0Amacro_rules%0D%0A%7C%20%60(%5BZ%7C%24n%3Anum%5D)%20%3D%3E%20%60((%24n%20%3A%20%E2%84%A4))%0D%0A%7C%20%60(%5BZ%7C-%24n%3Anum%5D)%20%3D%3E%20%60((-%24n%20%3A%20%E2%84%A4))%0D%0A%0D%0A%0D%0A%0D%0Adeclare_syntax_cat%20binder%0D%0Asyntax%20ident%20%3A%20binder%0D%0Asyntax%20%22%5BB%7C%22%20binder%20%22%5D%22%20%3A%20term%0D%0A%0D%0Amacro_rules%0D%0A%7C%20%60(%5BB%7C%24x%3Aident%5D)%20%3D%3E%20%20do%0D%0A%20%20%20%20%20%20let%20xString%20%3A%3D%20Lean.quote%20(toString%20x.getId)%0D%0A%20%20%20%20%20%20%60(Binder.BNamed%20%24xString)%0D%0A%0D%0Adeclare_syntax_cat%20expr%0D%0Asyntax%20ident%20%3A%20expr%0D%0Asyntax%20int%20%3A%20expr%0D%0Asyntax%20%22%CE%BB%20%22%20binder%20%22%20%E2%86%A6%20%22%20expr%20%3A%20expr%0D%0Asyntax%20expr%20%22%20%C2%B7%20%22%20expr%20%3A%20expr%0D%0Asyntax%20expr%20%22%20%2B%20%22%20expr%20%3A%20expr%0D%0Asyntax%20%22%5Blam%7C%20%22%20expr%20%22%20%5D%22%20%3A%20term%0D%0A%0D%0Amacro_rules%0D%0A%7C%20%60(%5Blam%7C%20%24x%3Aident%5D)%20%3D%3E%20%60(Expr.Var%20%24(Lean.quote%20(toString%20x.getId)))%0D%0A%7C%20%60(%5Blam%7C%20%CE%BB%20%24b%3Abinder%20%E2%86%A6%20%24e%3Aexpr%5D)%20%3D%3E%20%60(Expr.Lam%20%5BB%7C%24b%5D%20%5Blam%7C%20%24e%5D)%0D%0A%7C%20%60(%5Blam%7C%20%24e%E2%82%81%20%C2%B7%20%24e%E2%82%82%5D)%20%3D%3E%20%60(Expr.App%20%5Blam%7C%24e%E2%82%81%5D%20%5Blam%7C%24e%E2%82%82%5D)%0D%0A%7C%20%60(%5Blam%7C%20%24n%3Aint%5D)%20%3D%3E%20%60(Expr.LitInt%20%5BZ%7C%24n%5D)%0D%0A%7C%20%60(%5Blam%7C%20%24e%E2%82%81%20%2B%20%24e%E2%82%82%5D)%20%3D%3E%20%60(Expr.Plus%20%5Blam%7C%20%24e%E2%82%81%5D%20%5Blam%7C%20%24e%E2%82%82%5D)%0D%0A%0D%0Ainstance%20%3A%20Coe%20NumLit%20(TSyntax%20%60expr)%20where%0D%0A%20%20coe%20s%20%3A%3D%20%E2%9F%A8s.raw%E2%9F%A9%0D%0A%0D%0Ainstance%20%3A%20Coe%20(TSyntax%20%60int)%20(TSyntax%20%60expr)%20where%0D%0A%20%20coe%20s%20%3A%3D%20%E2%9F%A8s.raw%E2%9F%A9%0D%0A%0D%0A%0D%0Ainstance%20%3A%20Coe%20Ident%20(TSyntax%20%60expr)%20where%0D%0A%20%20coe%20s%20%3A%3D%20%E2%9F%A8s.raw%E2%9F%A9%0D%0A%0D%0Ainstance%20%3A%20Coe%20StrLit%20(TSyntax%20%60binder)%20where%0D%0A%20%20coe%20s%20%3A%3D%20%E2%9F%A8s.raw%E2%9F%A9%0D%0Ainstance%20%3A%20Coe%20StrLit%20(TSyntax%20%60expr)%20where%0D%0A%20%20coe%20s%20%3A%3D%20%E2%9F%A8s.raw%E2%9F%A9%0D%0A%0D%0A%0D%0A%0D%0A%40%5Bapp_unexpander%20Binder.BNamed%5D%0D%0Adef%20unexpandBNamed%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_Binder.BNamed%20%24x%3Astr)%20%3D%3E%20%60(%5BB%7C%20%24x%5D)%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%40%5Bapp_unexpander%20Expr.LitInt%5D%0D%0Adef%20unexpandLitInt%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_Expr.LitInt%20%5BZ%7C%20%24x%3Aint%5D)%20%3D%3E%20%60(%5Blam%7C%20%24x%5D)%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%40%5Bapp_unexpander%20Expr.Plus%5D%0D%0Adef%20unexpandPlus%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_Expr.Plus%20%5Blam%7C%20%24e%E2%82%81%3Aexpr%5D%20%5Blam%7C%20%24e%E2%82%82%3Aexpr%5D)%20%3D%3E%20%60(%5Blam%7C%20%24e%E2%82%81%20%2B%20%24e%E2%82%82%5D)%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%40%5Bapp_unexpander%20Expr.Lam%5D%0D%0Adef%20unexpandLam%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_Expr.Lam%20%5BB%7C%20%24b%3Abinder%5D%20%5Blam%7C%20%24e%3Aexpr%5D)%20%3D%3E%20%60(%5Blam%7C%CE%BB%20%24b%20%E2%86%A6%20%24e%5D)%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%40%5Bapp_unexpander%20Expr.App%5D%0D%0Adef%20unexpandApp%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_Expr.App%20%5Blam%7C%20%24e%E2%82%81%3Aexpr%5D%20%5Blam%7C%20%24e%E2%82%82%3Aexpr%5D)%20%3D%3E%20%60(%5Blam%7C%20%24e%E2%82%81%20%C2%B7%20%24e%E2%82%82%5D)%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%40%5Bapp_unexpander%20Expr.Var%5D%0D%0Adef%20unexpandVar%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_Expr.Var%20%24x%3Astr)%20%3D%3E%20%60(%5Blam%7C%20%24x%5D)%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%23check%20%5Blam%7C%20x%5D%20--%20%5Blam%7C%20%22x%22%20%5D%20%3A%20_root_.Expr%0D%0A%23check%20%5Blam%7C%20%CE%BB%20y%20%E2%86%A6%20y%20%2B%20y%20%2B%20x%5D%20--%20%5Blam%7C%20%CE%BB%20%22y%22%20%E2%86%A6%20%22y%22%20%2B%20%22y%22%20%2B%20%22x%22%20%5D%20%3A%20_root_.Expr%0D%0A%23check%20%5Blam%7C%20-1%5D%20--%20Expr.LitInt%20(-1)%20%3A%20_root_.Expr%0D%0A%0D%0A%0D%0Ainductive%20Val%20where%0D%0A%20%20%7C%20LitIntV%20(n%20%3A%20%E2%84%A4)%0D%0A%20%20%7C%20LamV%20(x%20%3A%20Binder)%20(e%20%3A%20_root_.Expr)%0D%0A%0D%0A%0D%0Adeclare_syntax_cat%20val%0D%0Asyntax%20int%20%3A%20val%0D%0Asyntax%20%22%CE%BB%20%22%20binder%20%22%20%E2%86%A6%20%22%20expr%20%3A%20val%0D%0Asyntax%20%22%5Bval%7C%20%22%20val%20%22%20%5D%22%20%3A%20term%0D%0A%0D%0Amacro_rules%0D%0A%7C%20%60(%5Bval%7C%20%24n%3Aint%5D)%20%3D%3E%20%60(Val.LitIntV%20%5BZ%7C%20%24n%5D)%0D%0A%7C%20%60(%5Bval%7C%20%CE%BB%20%24b%3Abinder%20%E2%86%A6%20%24e%3Aexpr%5D)%20%3D%3E%20%60(Val.LamV%20%5BB%7C%24b%5D%20%5Blam%7C%24e%5D)%0D%0A%0D%0Ainstance%20%3A%20Coe%20NumLit%20(TSyntax%20%60val)%20where%0D%0A%20%20coe%20s%20%3A%3D%20%E2%9F%A8s.raw%E2%9F%A9%0D%0Ainstance%20%3A%20Coe%20(TSyntax%20%60int)%20(TSyntax%20%60val)%20where%0D%0A%20%20coe%20s%20%3A%3D%20%E2%9F%A8s.raw%E2%9F%A9%0D%0A%40%5Bapp_unexpander%20Val.LitIntV%5D%0D%0Adef%20unexpandLitIntV%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_Val.LitIntV%20%5BZ%7C%20%24x%5D)%20%3D%3E%20%60(%5Bval%7C%20%24x%5D)%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%40%5Bapp_unexpander%20Val.LamV%5D%0D%0Adef%20unexpandLamV%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_Val.LamV%20%5BB%7C%24x%5D%20%5Blam%7C%24e%5D)%20%3D%3E%20%60(%5Bval%7C%20%CE%BB%20%24x%20%E2%86%A6%20%24e%5D)%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%23check%20%5Bval%7C%201%5D%0D%0A%23check%20%5Bval%7C%20%CE%BB%20x%20%E2%86%A6%20x%C2%B7x%C2%B7x%5D%0D%0A%23check%20%5Bval%7C%20-1%5D%0D%0A\">full code</a></p>",
        "id": 399407378,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698717335
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 399407750,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698717557
    },
    {
        "content": "<p>I think the problem isn't optional syntax, but rather that you're matching on <code>[Z| ...]</code> syntax. You can match on <code>$x:num</code> for positive numbers, but there's a subtlety with negative numbers. Here's a solution:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">app_unexpander</span> <span class=\"n\">Expr.LitInt</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">unexpandLitInt</span> <span class=\"o\">:</span> <span class=\"n\">Unexpander</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">_</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"n\">lam</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">])</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">-$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"n\">lam</span><span class=\"bp\">|</span> <span class=\"bp\">-$</span><span class=\"n\">x</span><span class=\"o\">])</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n</code></pre></div>\n<p>The problem with negatives is that <code>($_ -$x)</code> matches <em>subtraction</em>, not negatives, and <code>($_ (-$x))</code> matches only when there are actually parentheses, but parentheses aren't inserted until later.</p>",
        "id": 399413070,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698719634
    },
    {
        "content": "<p>Thanks. It works. But I am still puzzled that there should be any confusion over <code>-</code> since I don't have subtraction in my language. Only negation and specifically only for integer literals</p>",
        "id": 399460729,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698745123
    },
    {
        "content": "<p>While I am at it, I don't understand why the <code>$_</code> is needed or what it does. The example in the mpil book doesn't have any underscores there</p>",
        "id": 399465712,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698746857
    },
    {
        "content": "<p><code>$</code> is for antiquotations inside a quotation, and <code>_</code> matches everything. Writing <code>$_Expr.LitInt</code> also matches everything, but it gives the matched term the name <code>_Expr.LitInt</code>. Preceding a name with <code>_</code> makes the linter not complain about an unused variable.</p>",
        "id": 399564271,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698771358
    },
    {
        "content": "<p>In your code, you had a <code>[Z| $x:int]</code> pattern, but you don't have any unexpanders/delaborators to represent ints using this syntax, so the unexpander won't ever fire (this syntax never arises). Instead, without such an unexpander, you instead can match on how ints are delaborated.</p>",
        "id": 399564578,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698771459
    },
    {
        "content": "<p>Integers are represented as either natural numbers (the <code>num</code> class) or as <code>Neg.neg</code> of a natural number. When you have notation on, then the unexpander will see the unary operator <code>-</code> applied to the num.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">pp.notation</span> <span class=\"n\">false</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"c1\">-- 2</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"c1\">-- Neg.neg 2</span>\n</code></pre></div>",
        "id": 399565439,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698771705
    },
    {
        "content": "<p>Okay I am beginning to see some light. Another question because it popped up in the <a href=\"https://live.lean-lang.org/#code=import%20Lean%0D%0Aimport%20Mathlib.Tactic%0D%0Aopen%20Lean%20Lean.Syntax%20Lean.PrettyPrinter%0D%0A%0D%0Ainductive%20Binder%20where%0D%0A%20%20%7C%20BNamed%20(s%20%3A%20String)%0D%0A%20%20%7C%20BAnon%0D%0Aderiving%20Repr%2C%20DecidableEq%0D%0A%0D%0Ainductive%20LExpr%20where%0D%0A%20%20%7C%20Var%20(x%20%3A%20String)%0D%0A%20%20%7C%20Lam%20(x%20%3A%20Binder)%20(e%20%3A%20LExpr)%0D%0A%20%20%7C%20App%20(e%E2%82%81%20e%E2%82%82%20%3A%20LExpr)%0D%0A%20%20%7C%20LitInt%20(n%20%3A%20%E2%84%A4)%0D%0A%20%20%7C%20Plus%20(e%E2%82%81%20e%E2%82%82%20%3A%20LExpr)%0D%0Aderiving%20Repr%2C%20DecidableEq%0D%0A%0D%0Aopen%20LExpr%0D%0Adeclare_syntax_cat%20int%0D%0Asyntax%20(%22-%22)%3F%20num%20%3A%20int%0D%0Asyntax%20%22%5BZ%7C%20%22%20int%20%22%20%5D%22%20%3A%20term%0D%0A%0D%0Amacro_rules%0D%0A%7C%20%60(%5BZ%7C%24n%3Anum%5D)%20%3D%3E%20%60(%24n)%0D%0A%7C%20%60(%5BZ%7C-%24n%3Anum%5D)%20%3D%3E%20%60(-%24n)%0D%0A%0D%0A%0D%0A%0D%0Adeclare_syntax_cat%20binder%0D%0Asyntax%20ident%20%3A%20binder%0D%0Asyntax%20%22%5BB%7C%22%20binder%20%22%5D%22%20%3A%20term%0D%0A%0D%0Amacro_rules%0D%0A%7C%20%60(%5BB%7C%24x%3Aident%5D)%20%3D%3E%20%20do%0D%0A%20%20%20%20%20%20let%20xString%20%3A%3D%20Lean.quote%20(toString%20x.getId)%0D%0A%20%20%20%20%20%20%60(Binder.BNamed%20%24xString)%0D%0A%0D%0Adeclare_syntax_cat%20expr%0D%0Asyntax%20ident%20%3A%20expr%0D%0Asyntax%20int%20%3A%20expr%0D%0Asyntax%20%22%CE%BB%20%22%20binder%20%22%20%E2%86%A6%20%22%20expr%20%3A%20expr%0D%0Asyntax%20expr%20%22%20%C2%B7%20%22%20expr%20%3A%20expr%0D%0Asyntax%20expr%20%22%20%2B%20%22%20expr%20%3A%20expr%0D%0Asyntax%20%22(%20%22%20expr%20%22%20)%22%20%3A%20expr%0D%0Asyntax%20%22%5Blam%7C%20%22%20expr%20%22%20%5D%22%20%3A%20term%0D%0A%0D%0Amacro_rules%0D%0A%7C%20%60(%5Blam%7C%20%24x%3Aident%5D)%20%3D%3E%20%60(LExpr.Var%20%24(Lean.quote%20(toString%20x.getId)))%0D%0A%7C%20%60(%5Blam%7C%20%CE%BB%20%24b%3Abinder%20%E2%86%A6%20%24e%3Aexpr%5D)%20%3D%3E%20%60(LExpr.Lam%20%5BB%7C%24b%5D%20%5Blam%7C%20%24e%5D)%0D%0A%7C%20%60(%5Blam%7C%20%24e%E2%82%81%20%C2%B7%20%24e%E2%82%82%5D)%20%3D%3E%20%60(LExpr.App%20%5Blam%7C%24e%E2%82%81%5D%20%5Blam%7C%24e%E2%82%82%5D)%0D%0A%7C%20%60(%5Blam%7C%20%24n%3Aint%5D)%20%3D%3E%20%60(LExpr.LitInt%20%5BZ%7C%24n%5D)%0D%0A%7C%20%60(%5Blam%7C%20(%24e%3Aexpr)%5D)%20%3D%3E%20%60(%5Blam%7C%20%24e%5D)%0D%0A%7C%20%60(%5Blam%7C%20%24e%E2%82%81%20%2B%20%24e%E2%82%82%5D)%20%3D%3E%20%60(LExpr.Plus%20%5Blam%7C%20%24e%E2%82%81%5D%20%5Blam%7C%20%24e%E2%82%82%5D)%0D%0A%0D%0Ainstance%20%3A%20Coe%20NumLit%20(TSyntax%20%60expr)%20where%0D%0A%20%20coe%20s%20%3A%3D%20%E2%9F%A8s.raw%E2%9F%A9%0D%0A%0D%0Ainstance%20%3A%20Coe%20(TSyntax%20%60int)%20(TSyntax%20%60expr)%20where%0D%0A%20%20coe%20s%20%3A%3D%20%E2%9F%A8s.raw%E2%9F%A9%0D%0A%0D%0A%0D%0Ainstance%20%3A%20Coe%20Ident%20(TSyntax%20%60expr)%20where%0D%0A%20%20coe%20s%20%3A%3D%20%E2%9F%A8s.raw%E2%9F%A9%0D%0A%0D%0Ainstance%20%3A%20Coe%20StrLit%20(TSyntax%20%60binder)%20where%0D%0A%20%20coe%20s%20%3A%3D%20%E2%9F%A8s.raw%E2%9F%A9%0D%0Ainstance%20%3A%20Coe%20StrLit%20(TSyntax%20%60expr)%20where%0D%0A%20%20coe%20s%20%3A%3D%20%E2%9F%A8s.raw%E2%9F%A9%0D%0A%0D%0A%0D%0A%0D%0A%40%5Bapp_unexpander%20Binder.BNamed%5D%0D%0Adef%20unexpandBNamed%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_Binder.BNamed%20%24x%3Astr)%20%3D%3E%20%60(%5BB%7C%20%24x%5D)%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%40%5Bapp_unexpander%20LExpr.LitInt%5D%0D%0Adef%20unexpandLitInt%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_%20%24x)%20%3D%3E%0D%0A%20%20%20%20match%20x%20with%0D%0A%20%20%20%20%7C%20%60(%24x%3Anum)%20%3D%3E%20%60(%5Blam%7C%20%24x%5D)%0D%0A%20%20%20%20%7C%20%60(-%24x%3Anum)%20%3D%3E%20%60(%5Blam%7C%20-%24x%5D)%0D%0A%20%20%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%40%5Bapp_unexpander%20LExpr.Plus%5D%0D%0Adef%20unexpandPlus%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_LExpr.Plus%20%5Blam%7C%20%24e%E2%82%81%3Aexpr%5D%20%5Blam%7C%20%24e%E2%82%82%3Aexpr%5D)%20%3D%3E%20%60(%5Blam%7C%20%24e%E2%82%81%20%2B%20%24e%E2%82%82%5D)%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%40%5Bapp_unexpander%20LExpr.Lam%5D%0D%0Adef%20unexpandLam%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_LExpr.Lam%20%5BB%7C%20%24b%3Abinder%5D%20%5Blam%7C%20%24e%3Aexpr%5D)%20%3D%3E%20%60(%5Blam%7C%CE%BB%20%24b%20%E2%86%A6%20%24e%5D)%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%40%5Bapp_unexpander%20LExpr.App%5D%0D%0Adef%20unexpandApp%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_LExpr.App%20%5Blam%7C%20%24e%E2%82%81%3Aexpr%5D%20%5Blam%7C%20%24e%E2%82%82%3Aexpr%5D)%20%3D%3E%20%60(%5Blam%7C%20%24e%E2%82%81%20%C2%B7%20%24e%E2%82%82%5D)%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%40%5Bapp_unexpander%20LExpr.Var%5D%0D%0Adef%20unexpandVar%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_LExpr.Var%20%24x%3Astr)%20%3D%3E%20%60(%5Blam%7C%20%24x%5D)%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%0D%0A%0D%0A%23check%20%5Blam%7C%20x%5D%20--%20%5Blam%7C%20%22x%22%20%5D%20%3A%20_root_.LExpr%0D%0A%23check%20%5Blam%7C%20%CE%BB%20y%20%E2%86%A6%20y%20%2B%20y%20%2B%20x%5D%20--%20%5Blam%7C%20%CE%BB%20%22y%22%20%E2%86%A6%20%22y%22%20%2B%20%22y%22%20%2B%20%22x%22%20%5D%20%3A%20_root_.LExpr%0D%0A%23check%20%5Blam%7C%20-1%5D%20--%20LExpr.LitInt%20(-1)%20%3A%20_root_.LExpr%0D%0A%0D%0A%0D%0Ainductive%20Val%20where%0D%0A%20%20%7C%20LitIntV%20(n%20%3A%20%E2%84%A4)%0D%0A%20%20%7C%20LamV%20(x%20%3A%20Binder)%20(e%20%3A%20LExpr)%0D%0Aderiving%20Repr%2C%20DecidableEq%0D%0Aopen%20Val%0D%0A%0D%0Adeclare_syntax_cat%20val%0D%0Asyntax%20int%20%3A%20val%0D%0Asyntax%20%22%CE%BB%20%22%20binder%20%22%20%E2%86%A6%20%22%20expr%20%3A%20val%0D%0Asyntax%20%22%5Bval%7C%20%22%20val%20%22%20%5D%22%20%3A%20term%0D%0A%0D%0Amacro_rules%0D%0A%7C%20%60(%5Bval%7C%20%24n%3Aint%5D)%20%3D%3E%20%60(Val.LitIntV%20%5BZ%7C%20%24n%5D)%0D%0A%7C%20%60(%5Bval%7C%20%CE%BB%20%24b%3Abinder%20%E2%86%A6%20%24e%3Aexpr%5D)%20%3D%3E%20%60(Val.LamV%20%5BB%7C%24b%5D%20%5Blam%7C%24e%5D)%0D%0A%0D%0Ainstance%20%3A%20Coe%20NumLit%20(TSyntax%20%60val)%20where%0D%0A%20%20coe%20s%20%3A%3D%20%E2%9F%A8s.raw%E2%9F%A9%0D%0Ainstance%20%3A%20Coe%20(TSyntax%20%60int)%20(TSyntax%20%60val)%20where%0D%0A%20%20coe%20s%20%3A%3D%20%E2%9F%A8s.raw%E2%9F%A9%0D%0A%40%5Bapp_unexpander%20Val.LitIntV%5D%0D%0Adef%20unexpandLitVInt%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_%20%24x)%20%3D%3E%0D%0A%20%20%20%20match%20x%20with%0D%0A%20%20%20%20%7C%20%60(%24x%3Anum)%20%3D%3E%20%60(%5Bval%7C%20%24x%5D)%0D%0A%20%20%20%20%7C%20%60(-%24x%3Anum)%20%3D%3E%20%60(%5Bval%7C%20-%24x%5D)%0D%0A%20%20%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%40%5Bapp_unexpander%20Val.LamV%5D%0D%0Adef%20unexpandLamV%20%3A%20Unexpander%0D%0A%20%20%7C%20%60(%24_Val.LamV%20%5BB%7C%24x%5D%20%5Blam%7C%24e%5D)%20%3D%3E%20%60(%5Bval%7C%20%CE%BB%20%24x%20%E2%86%A6%20%24e%5D)%0D%0A%20%20%7C%20_%20%3D%3E%20throw%20()%0D%0A%0D%0A%23check%20%5Bval%7C%201%5D%0D%0A%23check%20%5Bval%7C%20%CE%BB%20x%20%E2%86%A6%20x%C2%B7x%C2%B7x%5D%0D%0A%23check%20%5Bval%7C%20-1%5D%0D%0A\">example which I have now modified</a>. This is in particular about the <code>val</code> syntax category in which a value is either an integer literal or a lambda abstraction. I want to focus on the literal.</p>\n<p>The syntax and macro definitions let me write something like <code>[val| 1]</code> and <code>[val| 100]</code> and automatically parses them to <code>Val.LitIntV 1</code> and <code>Val.LitIntV</code> respectively. But how would I write a function like <code>fun (n : ℤ) =&gt; [val| $n]</code>. Specifically  when applied to some integer, say 100,  the function will output<code>[val| 100]</code>. My best guess is that I have to take <code>n</code> and construct a <code>NumLit</code>, say <code>n_numlit</code> and return <code>[val| n_numlit]</code>. However the only relevant function I found was <code>mkNumLit</code> which does not take integer values, only string values.</p>",
        "id": 399643409,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698806874
    },
    {
        "content": "<p>Currently I am circumventing this trouble by writing the constructors and arguments explicitly, where necessary. This is fine of course, but it means that whenever variables show up and I have to build expressions from the values they get assigned, I am out of my neat little syntax world</p>",
        "id": 399643547,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698806922
    },
    {
        "content": "<p>Maybe this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mkValOfInt</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"o\">:=</span> <span class=\"n\">Unhygienic.run</span> <span class=\"bp\">&lt;|</span>\n  <span class=\"k\">if</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n    <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"n\">val</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">quote</span> <span class=\"n\">n.natAbs</span><span class=\"o\">)])</span>\n  <span class=\"k\">else</span>\n    <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"n\">val</span><span class=\"bp\">|</span> <span class=\"bp\">-$</span><span class=\"o\">(</span><span class=\"n\">quote</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">natAbs</span><span class=\"o\">)])</span>\n</code></pre></div>",
        "id": 399775101,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698862505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Unexpander.20trouble/near/399775101\">said</a>:</p>\n<blockquote>\n<p>Maybe this?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mkValOfInt</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"o\">:=</span> <span class=\"n\">Unhygienic.run</span> <span class=\"bp\">&lt;|</span>\n  <span class=\"k\">if</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n    <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"n\">val</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">quote</span> <span class=\"n\">n.natAbs</span><span class=\"o\">)])</span>\n  <span class=\"k\">else</span>\n    <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"n\">val</span><span class=\"bp\">|</span> <span class=\"bp\">-$</span><span class=\"o\">(</span><span class=\"n\">quote</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">natAbs</span><span class=\"o\">)])</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>The function itself works. It only works with <code>Lean.Unhygienice.run</code> which I am learning about just now. Thanks :)</p>",
        "id": 399809671,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1698875982
    }
]