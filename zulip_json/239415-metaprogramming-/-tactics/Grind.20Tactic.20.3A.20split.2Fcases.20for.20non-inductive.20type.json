[
    {
        "content": "<p>Hello,</p>\n<p>As I understand, the grind tactic can do case-splitting on inductive types like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"kd\">]</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">IsEven</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsEven</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsEven</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsEven</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">[grind.split] IsEven 5, generation: 0</span>\n<span class=\"sd\">[grind.split] IsEven n, generation: 1</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsEven</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>Now, If I have a type that is not an inductive type, how can I guide the grind tactic to do case splitting? Say I have this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">DefEven</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">IsEven</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- this fails as grind can't do case splitting for DefEven</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DefEven</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>I understand that I can : 1) make the <code>DefEven</code> definition reducible,  or 2) unfold it before running grind in my example. So,  I'm wondering if there's another way to provide my own case splitting for grind? </p>\n<p>The reason is, in my real use case, my type is defined to be a <code>List</code>, and I'm transferring many nice facts about List while I can still some modifications that suits my own application. However, I lose some nice properties so I was hoping I could find a hack were I provide <code>nil</code>/<code>cons</code> theorems for my custom type and still could benefit from grind.</p>",
        "id": 565934300,
        "sender_full_name": "Dolores Haze",
        "timestamp": 1767216579
    },
    {
        "content": "<p>you can make it an <code>abbrev</code></p>",
        "id": 565934777,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767217110
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Grind.20Tactic.20.3A.20split.2Fcases.20for.20non-inductive.20type/near/565934777\">said</a>:</p>\n<blockquote>\n<p>you can make it an <code>abbrev</code></p>\n</blockquote>\n<p>Thanks. Yes I know about abbrev; that's why I mentioned in my original post that I can make the definition reduicible. </p>\n<p>But My question is is there a way to not abbrev my type and instead manually guide the grind? (e.g., by providing theorems like <code>DefEven.zero</code> and <code>DefEven.step</code> ?</p>",
        "id": 565935204,
        "sender_full_name": "Dolores Haze",
        "timestamp": 1767217689
    },
    {
        "content": "<p>you can <code>unfold DefEven at *</code></p>",
        "id": 565935486,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767218090
    },
    {
        "content": "<p>Well you can provide a lemma to the effect of case splitting like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">DefEven</span><span class=\"bp\">.</span><span class=\"n\">unstep</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DefEven</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">DefEven</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">DefEven</span><span class=\"bp\">.</span><span class=\"n\">no_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">DefEven</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nofun</span>\n</code></pre></div>",
        "id": 565935499,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1767218114
    },
    {
        "content": "<p>Now, my guess is that, in your real application, you should use a one-field structure instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"kd\">]</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">StructEven</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ofIsEven</span><span class=\"w\"> </span><span class=\"bp\">::</span>\n<span class=\"w\">  </span><span class=\"n\">toIsEven</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsEven</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>",
        "id": 565935559,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1767218216
    },
    {
        "content": "<p>or well, something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"kd\">]</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MyCustomList</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ofList</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>",
        "id": 565935581,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1767218246
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Grind.20Tactic.20.3A.20split.2Fcases.20for.20non-inductive.20type/near/565935499\">said</a>:</p>\n<blockquote>\n<p>Well you can provide a lemma to the effect of case splitting like:</p>\n</blockquote>\n<p>Thank you. This is very close to what I was looking for.  </p>\n<blockquote>\n<p>or well, something like</p>\n</blockquote>\n<p>I wasn't aware of the one-field structure. I have to learn more about this.</p>",
        "id": 565937526,
        "sender_full_name": "Dolores Haze",
        "timestamp": 1767220430
    },
    {
        "content": "<p>I have a similar question: how to let grind unfold the le/lt instance?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ofBitVec</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">toBitVec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">64</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Word</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"bp\">.</span><span class=\"n\">toFin</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"bp\">.</span><span class=\"n\">toFin</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le_refl</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instLE</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instLE</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n<span class=\"w\">  </span><span class=\"n\">lt_iff_le_not_ge</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instLE</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">instLT</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Word</span>\n</code></pre></div>",
        "id": 566000792,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1767303371
    },
    {
        "content": "<p>I seems have to unfold the <code>instLE/instLT</code> everywhere before applying <code>grind</code>.</p>",
        "id": 566000807,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1767303411
    },
    {
        "content": "<p>write a <code>le_def</code> theorem and have <code>grind</code> use that</p>",
        "id": 566001110,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767303948
    },
    {
        "content": "<p>You mean something like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_def</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Addr</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 566001444,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1767304380
    },
    {
        "content": "<p>Thanks! It works like a charm.</p>",
        "id": 566001452,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1767304393
    }
]