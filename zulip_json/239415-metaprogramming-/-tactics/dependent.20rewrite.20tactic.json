[
    {
        "content": "<p>I wrote a dependent rewrite tactic. This is the first time I've written a tactic, so I'd like some feedback.<br>\n<a href=\"/user_uploads/3121/_Bqy7QVMfA9vHrFl3LHs7rdP/DepRewrite.lean\">DepRewrite.lean</a>, last updated <time datetime=\"2025-02-23T04:32:40Z\">2025-02-22T23:32:40-05:00</time></p>",
        "id": 494682985,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737323449
    },
    {
        "content": "<p>Could you say a bit about what it does and what sorts of examples it can handle?</p>",
        "id": 494684114,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737324194
    },
    {
        "content": "<p>I built this by modifying the <code>rw</code> tactic, so it should be able to do anything that <code>rw</code> can do. I tried it with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">Î³</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î³</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">Î³</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">â–¸</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">rec</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">Î³</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"bp\">â–¸</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">h'</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">â–¸</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â–¸</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)))</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">Î³</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">â–¸</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- rw! [h] works</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- conv =&gt; also works</span>\n<span class=\"w\">  </span><span class=\"c1\">--   congr</span>\n<span class=\"w\">  </span><span class=\"c1\">--   Â· rw! [h]</span>\n<span class=\"w\">  </span><span class=\"c1\">--   Â· rw! [h]</span>\n</code></pre></div>",
        "id": 494686270,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737325576
    },
    {
        "content": "<p>The tactic is meant to do the same as <code>rw</code>, but insert casts so that the motive does not become type incorrect.</p>",
        "id": 494687175,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737326230
    },
    {
        "content": "<p>The version of my tactic that I posted here leaks free variables when operating on let expressions. I have updated it to not do that. If anyone wants the updated version then feel free to ping me.</p>",
        "id": 494957216,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737428558
    },
    {
        "content": "<p>I had a vague idea of a project in this area that you might be interested in looking into.</p>\n<p>Unconstrained rewrites are not great to work with, which is a reason that <code>rw</code> and <code>simp</code> don't insert casts just to make a rewrite go through (that's to say, it can lead you deeper into \"DTT hell\"). However, sometimes there is a \"good\" cast function available. There might be a way where we can synthesize a good cast with these. For example, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.cast#doc\">docs#Fin.cast</a> could be used when the discrepancy appears inside the Nat argument to Fin inside the type of the term that needs rewriting.</p>\n<p>Unconstrained casts are always there as a fallback, but we could have an option that enables the fallback. We can also allow unconstrained casts in certain situations indiscriminately, for example if the value is a proof. That's what <code>simp</code> does already. There are other strategies too to consider.</p>",
        "id": 497185687,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738433583
    },
    {
        "content": "<p>Independently of this, you might also look into modifying your <code>rw!</code> to make use of <code>simp</code>'s congruence lemma system when rewriting applications. There is not much example code, but the <code>conv</code>-mode <code>arg</code> tactic uses it in a custom way. The idea being that you can ask for a lemma with <code>CongrArgKind.cast</code> arguments, and the generator will handle building up a relatively efficient congruence lemma for you for the entire application, rather than just rewriting individual <code>Expr.app</code> nodes.</p>\n<p>It might not be necessary to do, but it would be a reasonable thing to look into to learn this part of metaprogramming.</p>",
        "id": 497187240,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738434868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/dependent.20rewrite.20tactic/near/497185687\">said</a>:</p>\n<blockquote>\n<p>I had a vague idea of a project in this area that you might be interested in looking into.</p>\n<p>Unconstrained rewrites are not great to work with, which is a reason that <code>rw</code> and <code>simp</code> don't insert casts just to make a rewrite go through (that's to say, it can lead you deeper into \"DTT hell\"). However, sometimes there is a \"good\" cast function available. There might be a way where we can synthesize a good cast with these. For example, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.cast#doc\">docs#Fin.cast</a> could be used when the discrepancy appears inside the Nat argument to Fin inside the type of the term that needs rewriting.</p>\n<p>Unconstrained casts are always there as a fallback, but we could have an option that enables the fallback. We can also allow unconstrained casts in certain situations indiscriminately, for example if the value is a proof. That's what <code>simp</code> does already. There are other strategies too to consider.</p>\n</blockquote>\n<p>I am wondering what exactly you mean by a \"good\" cast\". My working characterization atm is that these are casts along an equality of indices of a type family, where the indices are not themselves types. So e.g. <code>cast (h : n = m) (motive := Fin) (v : Fin n)</code> is good, but <code>cast (h : Nat = Nat') (motive := Î»(Î±: Type) =&gt; Î±) (n : Nat)</code> (rewriting along an equality of types) is bad, and <code>cast (h : Nat = Nat') (motive := Î»Î±. List Î±) (l : List Nat)</code> is also bad. Mathlib tends to introduce definitions for the \"good\" casts, though one could as well just use <code>Eq.rec</code> with a \"good\" motive.</p>",
        "id": 500996544,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1740097653
    },
    {
        "content": "<p>By \"good\" cast, I was meaning some registered casting function, but I think you're right about this characterization. The difference though between a registered casting function and <code>Eq.rec</code> with a \"good\" motive is that the registered casting function will have a library around it with algebraic rules , where <code>Eq.rec</code> tends to be less amenable to rw-based reasoning.</p>",
        "id": 501008147,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740104733
    },
    {
        "content": "<blockquote>\n<p>We can also allow unconstrained casts in certain situations indiscriminately, for example if the value is a proof. That's what <code>simp</code> does already.</p>\n</blockquote>\n<p>Why is <a href=\"#narrow/channel/116395-maths/topic/Rewriting.20in.20slice.20categories\">my question here</a> not a counterexample to this? The thing you need to do is exactly to rewrite in a proof's type, but <code>simp</code> doesn't seem to be doing this.</p>",
        "id": 501207098,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1740183057
    },
    {
        "content": "<p><code>simp</code> can't rewrite in that position.</p>\n<p>The signature of <code>homMk</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">homMk</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OverHom</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">V</span>\n</code></pre></div>\n<p>and the rewrite you want to do involves needing to rewrite <code>U</code>. However, <code>f</code> depends on <code>U</code>, so it's fixed. It also appears in the resulting type <code>OverHom U V</code>, so it's fixed for that reason as well (simp can't rewrite something to have a different type).</p>",
        "id": 501228147,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740200702
    },
    {
        "content": "<p>And you are saying it would be in principle possible to do the rewriting of the U argument by putting casts around the next argument and the results, but that it would lead to basically impossible to work with terms, with casts all over the place. It would also possibly start to loop, since U is mentioned in the type of the casts, if one isn't careful, I assume.</p>",
        "id": 501237754,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1740209108
    },
    {
        "content": "<p>Yeah, that looping issue is a problem too.</p>\n<p>I forgot to mention that sometimes the \"good\" casts are good not just because they're canonical. They have good defeq properties:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">â–¸</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- succeeds</span>\n</code></pre></div>\n<p>The custom cast is able to drop the rewrite down inside the proof field of <code>Fin</code>.</p>",
        "id": 501308134,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740263586
    },
    {
        "content": "<p>Here is a minimized example of what problem I ran into in <a href=\"https://github.com/leanprover/lean4/pull/7181\">lean4#7181</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subring</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsFunnyRing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsFunnyRing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"c1\">-- Adding this instance makes the rewrite break:</span>\n<span class=\"c1\">-- instance : IsFunnyRing (foo 3) where</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsFunnyRing</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"s2\">\"hello\"</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>If this dependent rewrite tactic can solve this problem then that would be amazing. It only needs to insert a cast around a proof.</p>\n<p>See also the conversation <a href=\"#narrow/channel/270676-lean4/topic/dsimp.20simplifies.20proofs.2C.20which.20is.20slow/near/501154048\">here</a></p>",
        "id": 501376275,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740318542
    },
    {
        "content": "<p>It seems that it can <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span><br>\nIt replaces the instance with the somewhat scary looking</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">IsFunnyRing</span><span class=\"w\"> </span><span class=\"bp\">â†¥</span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">IsFunnyRing</span><span class=\"w\"> </span><span class=\"bp\">â†¥</span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"n\">instIsFunnyRingSubtypeIntMemSubringFooOfNatNat</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 501376700,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740318884
    },
    {
        "content": "<p>I agree that better rewriting tactics are a worthwhile direction to explore</p>",
        "id": 504032567,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1741334258
    },
    {
        "content": "<p>I certainly agree! I took Aaron's code posted above, added a couple of features, and deployed it in a project I am working on: <a href=\"https://github.com/Vtec234/Poly/commit/137221d4fda5153fe9701dfd5d261187149816d8\">commit</a>. While it doesn't solve all my DTT problems, it helps with many of them; in the commit, results that could only be established via careful <code>generalize</code> sequences are now just <code>rw!</code>. See also <a href=\"https://github.com/Vtec234/lean4-seq/blob/b6b76a5d7cc1c8b11c52f12a7bd90c460b7cba5a/test/drw/basic.lean\">tests</a> for what the tactic can do. I am wondering if there is interest in including this in mathlib.</p>\n<blockquote>\n<p>it would be in principle possible to do the rewriting of the U argument by putting casts around the next argument and the results, but that it would lead to basically impossible to work with terms, with casts all over the place</p>\n</blockquote>\n<p>This is not really true. The point is that in some cases (including the <code>Over</code> example) you <em>only</em> have to cast proofs. Casting these causes no increase in complexity because we don't care about proof terms anyway. As one addition to Aaron's code, I added a configuration option for what kinds of casts can be inserted. The default mode only casts proof terms.</p>",
        "id": 504228022,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1741406371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/dependent.20rewrite.20tactic/near/501228147\">said</a>:</p>\n<blockquote>\n<p><code>simp</code> can't rewrite in that position.</p>\n<p>The signature of <code>homMk</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">homMk</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OverHom</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">V</span>\n</code></pre></div>\n<p>and the rewrite you want to do involves needing to rewrite <code>U</code>. However, <code>f</code> depends on <code>U</code>, so it's fixed. It also appears in the resulting type <code>OverHom U V</code>, so it's fixed for that reason as well (simp can't rewrite something to have a different type).</p>\n</blockquote>\n<p>Right, so it depends on how you interpret 'allow unconstrained casts if the value is a proof'; in my interpretation (allow it even if this changes the proof's type), there are examples that <code>rw!</code> can handle but <code>simp</code> and <code>rw</code> cannot.</p>",
        "id": 504228516,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1741406698
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 514934809,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745891363
    }
]