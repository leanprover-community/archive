[
    {
        "content": "<p>\"<a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/main/05_syntax.html\">Metaprogramming in Lean 4</a>\" states that, when using <code>isDefEq</code>:</p>\n<blockquote>\n<p>The unification <code>?m₁ + ?m₂ + ?m₃ =?= m + n - k</code> fails and no metavariables are assigned (even though there is a 'partial match' between the expressions).</p>\n</blockquote>\n<p>Are there any unification methods that <em>do</em> distinguish between the two terms being <em>certainly</em> definitionally unequal to each other (i.e. mismatched types or constructor calls) and <em>being (currently) unable to make them definitionally equal</em>, like with the term above or (forgive my Idris-ism) <code>Vect (.cons x) Nat =?= Vect (?a + ?b) Nat</code>? </p>\n<p>In the second case, ideally, I'd like to also somehow get the metavariable assigments it successfully made (for the quoted example, that'd be <code>?m1 = m</code>) and the constraint(s) it can't resolve further (for the quoted example, <code>?m2 + ?m3 =?= n - k</code>, for my example, <code>?a + ?b = .cons x</code>). If this is impossible, then I need to at least be able to distinguish the two categories. I know that in Idris, such a distinction can be made (if somewhat non-trivially, owing to the quirks of its elaborator): when typechecking <code>Refl</code> as a value of type <code>a = b </code> (where a and b are the  expressions being unified), it will fail outright if the unification is impossible, and \"successfully\" return <code>?postpone</code> if it's merely stalled. However, I don't know if Lean has any parallels to this behavior.</p>\n<p>Distinguishing between those two kinds of results seems crucial for my task (checking which constructors can produce a value given certain parameters and indices of that value's type, and, if so, what values their arguments have to be for that to happen), since definitional un-equality means the constructor can <em>never</em> produce such a value, while the unification stalling means there are <em>non-trivial conditions</em> under which the constructor may produce a value.</p>",
        "id": 565724429,
        "sender_full_name": "Anton Gusev",
        "timestamp": 1767045570
    },
    {
        "content": "<p>I know we have three-state instance synthesis but I don't see an isDefEq function that can return \"maybe\"</p>",
        "id": 565726039,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767047004
    },
    {
        "content": "<p>Indeed, type class synthesis can get \"stuck\" when there are metavariables that it isn't allowed to instantiate, but that is different from what you want. I don't think there is such an <code>isDefEq</code> function. Could you give an example of your use case?</p>",
        "id": 565763329,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1767085284
    },
    {
        "content": "<p>I'm going to start with a synthetic example that demonstrates the problem I'm trying to solve at the lowest level. Let's say we've got a type that looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">e0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">eS</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">eSum</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Starting off, we'd like to know which constructors may produce a value of type <code>Example 0</code>, and which ones a value of type <code>Example 1</code>. </p>\n<p>Intuitively, we can see that <code>Example 0</code> can be produced by <code>.e0</code> and <code>.eSum</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">e0</span><span class=\"w\"> </span><span class=\"c1\">-- e0 always creates Example 0</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">eSum</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- eSum creates Example 0 so long as a + b = 0</span>\n</code></pre></div>\n<p>And <code>Example 1</code> - by <code>.eS</code> and <code>.eSum</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">eS</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- eS creates Example 1 if n = 0</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">eSum</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- eSum creates Example 1 if a + b = 1</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">eSum</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>The problem, then, is performing such analysis programmatically, rather than by hand. The way I did it in Idris was by performing unifications like this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- Succeeds</span>\n<span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- Fails, since .succ and .zero are different constructors</span>\n<span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- Postpones, since there are constraints it can't solve</span>\n\n<span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- Fails, since .succ and .zero are different constructors</span>\n<span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- Succeeds, metavariable n is assigned 0</span>\n<span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- Postpones</span>\n</code></pre></div>\n<p>However, when performing unification with <code>isDefEq</code>,  <code>Example (.succ ?n) =?= Example 0</code> and <code>Example (?a + ?b) =?= Example 0</code> both simply return false.</p>",
        "id": 565768995,
        "sender_full_name": "Anton Gusev",
        "timestamp": 1767089193
    },
    {
        "content": "<p>All right, for this simple example you could write your own unification algorithm, which would first run <code>whnf</code> on both sides. If the sides get the same head, recursively continue. If they have different heads, check if they are both constructors, in which case you fail, and otherwise you postpone.</p>\n<p>How are you planning on dealing with the postponed cases? Because <code>isDefEq</code> won't solve them for you. Is it to try every possible constructor?</p>",
        "id": 565769659,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1767089670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Handling.20.22partial.20matches.22.20when.20unifying.20two.20terms/near/565769659\">said</a>:</p>\n<blockquote>\n<p>How are you planning on dealing with the postponed cases? Because <code>isDefEq</code> won't solve them for you. Is it to try every possible constructor?</p>\n</blockquote>\n<p>This depends on what information I get. If I only know <em>that</em> they're postponed (as is the case with Idris), I'll have to write my own primitive unifier that does its best to extract whatever constraints it can. If I receive those constraints (<code>?a + ?b = 0</code> in case of <code>Example (?a + ?b) =?= Example 0</code>) right away, then I don't really have to do anything further.</p>",
        "id": 565787080,
        "sender_full_name": "Anton Gusev",
        "timestamp": 1767100182
    },
    {
        "content": "<p>To explain a bit, the (current) use-case for all this constructor unification is deriving specialized variants of types.</p>\n<p>For instance, a specialized variant of <code>Example</code> corresponding to <code>Example 0</code> would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Example0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">e0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Example0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">eSum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Example0</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toPoly</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Example0</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">e0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">e0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">eSum</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">prf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">prf</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">eSum</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ofPoly</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Example0</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">eSum</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">eSum</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">e0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">e0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">eS</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"bp\">;</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Example0</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ofPoly</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">Example0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">toPoly</span>\n</code></pre></div>\n<p>So all those unresolved-during-unification constraints are \"simply\" included in the signatures of specialized constructors.</p>",
        "id": 565799034,
        "sender_full_name": "Anton Gusev",
        "timestamp": 1767107539
    }
]