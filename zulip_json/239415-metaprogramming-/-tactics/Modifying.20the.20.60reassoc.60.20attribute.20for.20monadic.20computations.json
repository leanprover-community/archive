[
    {
        "content": "<p>I would like to have a variant of <code>reassoc</code> which generates associated lemmas for theorems like <code>∀ (s₁ s₂ : σ), (do set s₁; set s₂ : m PUnit) = set s₂</code> which states a universally quantified equality between stuff of the form <code>m α</code> for some monad <code>m</code> (possible being quantified over). Here is an excerpt of my intended applications</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">LawfulMonadStateOf</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n    <span class=\"o\">[</span><span class=\"n\">MonadStateOf</span> <span class=\"n\">σ</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">LawfulMonad</span> <span class=\"n\">m</span> <span class=\"n\">where</span>\n  <span class=\"n\">set_set</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"n\">set</span> <span class=\"n\">s₁</span><span class=\"bp\">;</span> <span class=\"n\">set</span> <span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">PUnit</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">set</span> <span class=\"n\">s₂</span>\n  <span class=\"n\">set_get</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"n\">set</span> <span class=\"n\">s</span><span class=\"bp\">;</span> <span class=\"n\">get</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"n\">set</span> <span class=\"n\">s</span><span class=\"bp\">;</span> <span class=\"n\">pure</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"n\">get_set</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">get</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">set</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">pure</span> <span class=\"n\">PUnit.unit</span>\n  <span class=\"n\">get_get_pair</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"k\">let</span> <span class=\"n\">s₁</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">get</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"k\">let</span> <span class=\"n\">s₂</span> <span class=\"bp\">←</span> <span class=\"n\">get</span><span class=\"bp\">;</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">s₁</span><span class=\"o\">,</span> <span class=\"n\">s₂</span><span class=\"o\">))</span>\n               <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">get</span><span class=\"bp\">;</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">))</span>\n  <span class=\"n\">modifyGet_def</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">σ</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"n\">modifyGet</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">get</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">set</span> <span class=\"n\">p.snd</span><span class=\"bp\">;</span> <span class=\"n\">pure</span> <span class=\"n\">p.fst</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">reassocM</span> <span class=\"o\">(</span><span class=\"n\">attr</span> <span class=\"o\">:=</span> <span class=\"n\">simp</span><span class=\"o\">)]</span> <span class=\"n\">set_set</span>\n<span class=\"c1\">-- attribute [reassocM (attr := simp)] set_get get_set modifyGet_def</span>\n</code></pre></div>\n<p>And here is my attempt at modifying the <code>Mathlib.Tactic.CategoryTheory.Assoc</code> file:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Util.AddRelatedDecl</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Lean.Meta.Simp</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Lean.Meta</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">LawfulMonad</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eq_bind</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">w</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">monadSimp</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Simp.Result</span> <span class=\"o\">:=</span>\n  <span class=\"n\">getAllSimpDecls</span> <span class=\"bp\">`</span><span class=\"n\">monad_norm</span> <span class=\"bp\">&gt;&gt;=</span>\n  <span class=\"o\">(</span><span class=\"n\">simpOnlyNames</span> <span class=\"bp\">.</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">decide</span> <span class=\"o\">:=</span> <span class=\"n\">false</span> <span class=\"o\">}))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">reassocMExpr</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">mapForallTelescope</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">simpType</span> <span class=\"n\">monadSimp</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">eq_bind</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">]))</span> <span class=\"n\">e</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">reassocM</span><span class=\"o\">)</span> <span class=\"s2\">\"reassocM\"</span> <span class=\"o\">(</span><span class=\"s2\">\" (\"</span> <span class=\"bp\">&amp;</span><span class=\"s2\">\"attr\"</span> <span class=\"s2\">\":=\"</span> <span class=\"n\">Parser.Term.attrInstance</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"s2\">\")\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">attr</span>\n\n<span class=\"n\">initialize</span> <span class=\"n\">registerBuiltinAttribute</span> <span class=\"o\">{</span>\n  <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">reassocM</span>\n  <span class=\"n\">descr</span> <span class=\"o\">:=</span> <span class=\"s2\">\"\"</span>\n  <span class=\"n\">applicationTime</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">afterCompilation</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">src</span> <span class=\"n\">ref</span> <span class=\"n\">kind</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">ref</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"bp\">|</span> <span class=\"n\">reassocM</span> <span class=\"bp\">$</span><span class=\"o\">[(</span><span class=\"n\">attr</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">stx</span><span class=\"bp\">?</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"o\">)]</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MetaM.run'</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"bp\">!=</span> <span class=\"n\">AttributeKind.global</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"`reassocM` can only be used as a global attribute\"</span>\n    <span class=\"n\">addRelatedDecl</span> <span class=\"n\">src</span> <span class=\"s2\">\"_assoc\"</span> <span class=\"n\">ref</span> <span class=\"n\">stx</span><span class=\"bp\">?</span> <span class=\"k\">fun</span> <span class=\"n\">type</span> <span class=\"n\">value</span> <span class=\"n\">levels</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">reassocMExpr</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkExpectedTypeHint</span> <span class=\"n\">value</span> <span class=\"n\">type</span><span class=\"o\">),</span> <span class=\"n\">levels</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Term</span> <span class=\"k\">in</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"reassocM_of% \"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">reassocMExpr</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">LawfulMonad</span>\n</code></pre></div>\n<p>I'm currently getting an error that looks like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">...</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"n\">set</span> <span class=\"n\">s₁</span><span class=\"bp\">;</span> <span class=\"n\">set</span> <span class=\"n\">s₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">set</span> <span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">Eq.</span><span class=\"o\">{</span><span class=\"bp\">?</span><span class=\"n\">u.1614</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m</span> <span class=\"bp\">?</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">x</span> <span class=\"bp\">?</span><span class=\"n\">y</span>  <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>so my assumption is that lean is having trouble inferring the <code>m</code> and <code>α</code> arguments to <code>eq_bind</code> in <code>reassocMExpr</code>. Does anyone know how I can make this work?</p>",
        "id": 402617594,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1700198425
    },
    {
        "content": "<p>You need to set up the additional binders for <code>m</code> and <code>α</code> so that they come out as universally quantified</p>",
        "id": 402618509,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700198937
    },
    {
        "content": "<p>I thought that's what <code>mapForallTelescope</code> was doing, but I guess I misunderstood?</p>",
        "id": 402618569,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1700198990
    },
    {
        "content": "<p>You could look at the elementwise attribute instead, which might be more similar to what you want to do</p>",
        "id": 402618578,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700198998
    },
    {
        "content": "<p>I might be misunderstanding what you need to do exactly -- maybe take a look at <code>mkAppOptM</code> as well, if you know the <code>m</code>, etc., that you need to pass in.</p>",
        "id": 402618813,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700199125
    },
    {
        "content": "<p>It's supposed to work for theorems involving universally quantified monads or even multiple monads. I guess what I had in mind is that it would figure out the monad by matching the type of the eqation (after all universal quantifiers) with <code>m a</code>. So maybe I'll try to do that match and then use <code>mkAppOptM</code>with the discovered <code>m</code> passed in?</p>",
        "id": 402619048,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1700199286
    },
    {
        "content": "<p>(Btw, <code>mapForallTelescope</code> is able to take the binders from the type of <code>e</code> itself, but if you need to introduce new variables you'll have to do that inside the body of the <code>fun</code> using <code>withLocalDecl</code> to create the local binding and then use <code>mkForallFVars</code> or <code>mkLambdaFVars</code> (depending on what you want) before leaving <code>withLocalDecl</code>)</p>",
        "id": 402619121,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700199336
    },
    {
        "content": "<p>One way you could do this is by using <code>forallMetaTelescope</code> on the type of <code>eq_bind</code>, unifying the correct argument with <code>e</code>, and then passing the remaining arguments to <code>mkAppN ``eq_bind metavars</code>, and then use <code>mkLambdaFVars</code> on this with the unsolved-for metavariables. It turns out <code>mkLambdaFVars</code> is able to take metavariables too, despite the name.</p>",
        "id": 402619446,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700199520
    },
    {
        "content": "<p>That's for the fully general multi-monad lemma, if I'm understanding this right.</p>",
        "id": 402619595,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700199604
    },
    {
        "content": "<p>also re: what I want this to do, an example would be to generate </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">set_set_assoc</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MonadStateOf</span> <span class=\"n\">σ</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LawfulMonad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LawfulMonadStateOf</span> <span class=\"n\">σ</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">PUnit</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"n\">set</span> <span class=\"n\">s₁</span><span class=\"bp\">;</span> <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"bp\">←</span> <span class=\"n\">set</span> <span class=\"n\">s₂</span><span class=\"bp\">;</span> <span class=\"n\">f</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"bp\">←</span> <span class=\"n\">set</span> <span class=\"n\">s₂</span><span class=\"bp\">;</span> <span class=\"n\">f</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>from the annotation <code>attribute [reassocM (attr := simp)] set_set</code>, where <code>set_set : ∀ (s₁ s₂ : σ), (do set s₁; set s₂ : m PUnit) = set s₂</code> is a field of the typeclass <code>LawfulMonadStateOf </code></p>",
        "id": 402619755,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1700199706
    },
    {
        "content": "<p>as a less simple example, I think this should be able to generate </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">get_set_pure_eq_get_assoc</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">do</span> <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">get</span><span class=\"bp\">;</span> <span class=\"n\">set</span> <span class=\"n\">s</span><span class=\"bp\">;</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">get</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">f</span>\n</code></pre></div>\n<p>from <code>get_set_pure_eq_get : (do let s ← get; set s; pure s) = (get : m σ)</code></p>",
        "id": 402619870,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1700199767
    },
    {
        "content": "<p>The multi monad stuff would be if I wanted to use this for a hypothetical <code>LawfulMonadLift</code> class, where axioms or theorem statements quantify over multiple monads</p>",
        "id": 402620011,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1700199857
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110401\">@Brendan Seamas Murphy</span> I get it now -- it was a failure to do higher-order unification I think. Here's a replacement function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">reassocMExpr</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">mapForallTelescope</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">ety</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ety.eq</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"Expecting an equality, not{indentD ety}\"</span>\n    <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">m</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">ty</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"Expecting an equality for a monad, not{indentD ty}\"</span>\n    <span class=\"n\">simpType</span> <span class=\"n\">monadSimp</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkAppOptM</span> <span class=\"bp\">``</span><span class=\"n\">eq_bind</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">some</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">e</span><span class=\"o\">]))</span> <span class=\"n\">e</span>\n</code></pre></div>",
        "id": 402620530,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700200177
    },
    {
        "content": "<p>Does this look right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">reassocM</span> <span class=\"o\">(</span><span class=\"n\">attr</span> <span class=\"o\">:=</span> <span class=\"n\">simp</span><span class=\"o\">)]</span> <span class=\"n\">LawfulMonadStateOf.set_set</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">LawfulMonadStateOf.set_set_assoc</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">⊢ ∀ {σ : Type u} {m : Type u → Type v} [inst : MonadStateOf σ m] [inst_1 : Monad m] [self : LawfulMonadStateOf σ m]</span>\n<span class=\"cm\">  (s₁ s₂ : σ) {β : Type u} (f : PUnit → m β),</span>\n<span class=\"cm\">  (do</span>\n<span class=\"cm\">        set s₁</span>\n<span class=\"cm\">        set s₂) &gt;&gt;=</span>\n<span class=\"cm\">      f =</span>\n<span class=\"cm\">    set s₂ &gt;&gt;= f</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 402620619,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700200218
    },
    {
        "content": "<p>Hm, it should be applying the simplifier with bind_assoc. Maybe the <code>monad_norm</code> tag needs to be in scope when I define <code>reassocM</code>?</p>",
        "id": 402620688,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1700200261
    },
    {
        "content": "<p>I don't understand metaprogramming in lean well <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 402620723,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1700200283
    },
    {
        "content": "<p>I just have the code you gave me -- I don't have any <code>monad_norm</code> lemmas</p>",
        "id": 402620800,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700200315
    },
    {
        "content": "<p>ahh, of course</p>",
        "id": 402620864,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1700200326
    },
    {
        "content": "<p>That looks awesome then, thanks!</p>",
        "id": 402620881,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1700200339
    },
    {
        "content": "<p>If you make the <code>m</code> argument explicit in <code>eq_bind</code>, then you can switch the <code>mkAppOptM</code> to <code>mkAppM ``eq_bind #[m, e]</code></p>",
        "id": 402620993,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700200437
    },
    {
        "content": "<p>Is there a reason that's better? Also, it simplifies correctly when in a context with <code>monad_norm</code> lemmas so hooray!</p>",
        "id": 402621068,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1700200466
    },
    {
        "content": "<p>I feel like it makes the meta code cleaner, rather than needing to count implicit arguments carefully. I think it's good making the lemmas that support meta code be tailored to it.</p>",
        "id": 402621165,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700200539
    },
    {
        "content": "<p>Makes sense, I'll change that then. Thanks for the help!</p>",
        "id": 402621179,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1700200555
    },
    {
        "content": "<p>You don't need to, but it's something you could do if you wanted.</p>",
        "id": 402621182,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700200557
    }
]