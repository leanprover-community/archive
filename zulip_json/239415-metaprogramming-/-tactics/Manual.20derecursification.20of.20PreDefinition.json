[
    {
        "content": "<p>Is it in principle possible to manually turn a <code>PreDefinition</code> into a kernel-ready recursion-free expression from within a <code>MetaM</code> declaration? I am looking at <code>Elab/PreDefinition/Structural/BRecOn.lean</code> and it seems like <code>replaceRecApps</code> is the key function here.  Will be attempting to do this for educational purposes and editing with progress</p>",
        "id": 491912281,
        "sender_full_name": "nrs",
        "timestamp": 1736028207
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.addPreDefinitions#doc\">docs#Lean.Elab.addPreDefinitions</a> will do this and add the definition to the environment. You can get the term by reading the environment. It's <code>TermElabM</code>, but you can run <code>TermElabM</code> from within <code>MetaM</code>.</p>",
        "id": 491912702,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1736028571
    },
    {
        "content": "<p>Amazing thanks for the reference! Will attempt a mwe<br>\nedit: relevant:  <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/How.20is.20Nat.2Ebelow.20and.20Nat.2EbrecOn.20compiled\">#lean4 &gt; How is Nat.below and Nat.brecOn compiled</a></p>",
        "id": 491912843,
        "sender_full_name": "nrs",
        "timestamp": 1736028700
    },
    {
        "content": "<p>Maybe you haven't found <code>elabMutualDef</code> yet? Lean/Elab/MutualDef.lean</p>\n<p>That's the main entry point to elaborating definitions/theorems/etc., and I got to <code>addPreDefinitions</code> by just skimming the code.</p>",
        "id": 491913225,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1736029037
    },
    {
        "content": "<p>ah nice I had not seen it yet</p>",
        "id": 491913516,
        "sender_full_name": "nrs",
        "timestamp": 1736029303
    },
    {
        "content": "<p>I wonder if <code>PreDefinition</code>s are somewhere in the environment or the only way of getting them is by manually building an <code>Expr</code><br>\nedit: oh it seems that the two <code>elabMutualDef</code> are a bit lower level than <code>PreDefinition</code>s, they take variations of <code>Array Syntax</code><br>\nedit2: only the <code>elabMutualDef</code> targeting <code>TermElab</code> uses <code>addPreDefinitions</code> so I'll be focusing on that one to start off. in the <code>DefView</code>s it takes, <code>DefView.value</code> seems to give the body of a definition as a <code>Syntax</code> object<br>\nedit3: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Elab/MutualDef.html#Lean.Elab.Term.MutualClosure.main\">Lean.Elab.Term.MutualClosure.main</a> seems to be the first function in the body of <code>elabMutualDef</code> that will generate a <code>PreDefinition</code><br>\nedit4: it seems that covers the extent of the existence of <code>PreDefinition</code>s? produced within <code>elabMutualDef</code> by <code>MutualClosure.main</code>, then gets mvars instantiated and universe levels fixed, and then gets passed to <code>addPreDefinitions</code><br>\nedit5: possible ways a <code>PreDefinition</code> gets consumed in <code>addPreDefinitions</code>, if no error:</p>\n<p>1. nonrec, noncomputable: <code>addNonRec</code><br>\n  2. nonrec, computable : <code>addAndCompileNonRec</code><br>\n  3. unsafe: <code>addAndCompileUnsafe</code><br>\n  4. partial: <code>addAndCompilePartial</code><br>\n  if none of these,</p>\n<p>5. <code>structuralRecursion</code><br>\n  6. <code>wfRecursion</code><br>\n  7. (failure: will attempt <code>addAsAxioms</code>)<br>\nedit6:  <code>structuralRecursion</code> or <code>wfRecursion</code> chosen by matching  <code>PreDefinition.termination.terminationBy?</code> with <code>{ structural := true/false, ..}</code></p>",
        "id": 491913569,
        "sender_full_name": "nrs",
        "timestamp": 1736029329
    },
    {
        "content": "<p>to more closely follow <code>structuralRecursion</code> and <code>wfRecursion</code> I'm taking a detour and manually creating a <code>PreDefinition</code> from a definition identical to <code>Nat.add</code>. given the above comments I will try to pass this to <code>MutualClosure.main</code>. The main problem will be to get the <code>Expr</code> as it is before it is given to <code>elabMutualDef</code>, I think manually building a <code>let rec</code> <code>Expr</code> should do it</p>\n<p>edit: it turns this is not that simple and requires reading the stuff above <code>MutualClosure.main</code>. Am trying to pass the result of applying <code>elabTerm</code> (with maybe <code>toExpr</code>)  to <code>let rec add (n m : Nat) : Nat := Nat.casesOn m n (fun mm =&gt; add n.succ mm); add</code> to <code>MutualClosure.main</code></p>\n<p>edit2: from <code>MutualDef.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span>\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">,</span>\n<span class=\"w\">  </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">;</span>\n<span class=\"n\">body</span>\n</code></pre></div>\n<p>is encoded as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m₁</span><span class=\"bp\">;</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m₂</span><span class=\"bp\">;</span>\n<span class=\"n\">body</span>\n</code></pre></div>\n<p>where <code>?m₁</code> and <code>?m₂</code> are synthetic opaque metavariables.  The body of <code>f</code> (or <code>g</code>) is stored the field <code>val</code> of a <code>LetRecToLift</code>.</p>",
        "id": 491919534,
        "sender_full_name": "nrs",
        "timestamp": 1736035265
    },
    {
        "content": "<p>here is my progress so far, from emulating what happens within <code>elabMutualDef</code>. the following incomplete definition for a <code>PreDefinition</code> requires a successful call to <code>elabHeaders</code>; am currently working on understanding on how it works. any tips/suggestions are welcome</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">OpenPrivate</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">Term</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">elabHeaders</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">MutualDef</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">declValToTerminationHint</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">MutualDef</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkAddPreDef</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">defview</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkDefViewOfDef</span><span class=\"w\"> </span><span class=\"o\">{}</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">headerAr</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">elabHeaders</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">defview</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">headerArEmpty</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">headerAr</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"n\">dbg_trace</span><span class=\"w\"> </span><span class=\"n\">headerArEmpty</span><span class=\"w\"> </span><span class=\"c1\">-- outputs .true, so call to elabHeaders isn't working properly</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ifWeHaveHeader</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DefViewElabHeader</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"n\">PreDefinition</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">header</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">termination</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">declValToTerminationHint</span><span class=\"w\"> </span><span class=\"n\">header</span><span class=\"bp\">.</span><span class=\"n\">value</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">predef</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PreDefinition</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span>\n<span class=\"w\">      </span><span class=\"n\">defview</span><span class=\"bp\">.</span><span class=\"n\">ref</span>\n<span class=\"w\">      </span><span class=\"bp\">.</span><span class=\"kn\">def</span>\n<span class=\"w\">      </span><span class=\"o\">[]</span>\n<span class=\"w\">      </span><span class=\"o\">{}</span>\n<span class=\"w\">      </span><span class=\"n\">header</span><span class=\"bp\">.</span><span class=\"n\">declName</span>\n<span class=\"w\">      </span><span class=\"n\">header</span><span class=\"bp\">.</span><span class=\"n\">type</span>\n<span class=\"w\">      </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"c1\">-- PreDefinition.value : Lean.Expr, built within pushMain in MutualDef.lean</span>\n<span class=\"w\">      </span><span class=\"n\">termination</span>\n<span class=\"w\">    </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">predef</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n</code></pre></div>",
        "id": 491999001,
        "sender_full_name": "nrs",
        "timestamp": 1736111588
    },
    {
        "content": "<p>the following seems to produce a minimal <code>PreDefinition</code> that has not yet undergone derecursification. I don't understand what <code>withAlwaysResolvedPromises</code> is doing, but omitting it makes <code>elabHeaders</code> fail, and attempting to manually create the <code>DefViewElabHeader</code> that <code>elabHeaders</code> returns will result in failure to recognize the variables <code>n</code>, <code>m</code>, in the body, which should be bound by the binders <code>(n : Nat)</code> and <code>(m : Nat)</code>. The exact point where going through <code>elabHeaders</code> vs. creating a <code>DefViewElabHeader</code> manually will differ seems to be in the body of <code>elabFunValues</code>, at the line <code>let val ← elabTermEnsuringType valStx type &lt;* synthesizeSyntheticMVarsNoPostponing</code>. Without <code>elabHeaders</code>, the symbols <code>n</code>, <code>m</code> in the body of the declaration will be replaced by a <code>sorry</code>. It seems that <code>TermElabM</code>'s <code>Context</code> and <code>State</code> are the exact same in the <code>elabHeaders</code> case vs. the case without, yet the result of the above mentioned line differs. Would be very interested if someone has an explanation for this!</p>\n<p>running <code>dbg_trace</code> on the fields of <code>predef</code> seems to have the expected outputs, and the term to derecursify seems to be <code>predef.value</code>. Will attempt to feed this to <code>structuralRecursion</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">OpenPrivate</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Language</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">elabHeaders</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">MutualDef</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">withFunLocalDecls</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">MutualDef</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">elabFunValues</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">MutualDef</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkAddPreDef</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">defview</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkDefViewOfDef</span><span class=\"w\"> </span><span class=\"o\">{}</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">withAlwaysResolvedPromises</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">bodyPromises</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">withAlwaysResolvedPromises</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">tacPromises</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">headers</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabHeaders</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">defview</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">bodyPromises</span><span class=\"w\"> </span><span class=\"n\">tacPromises</span>\n<span class=\"w\">    </span><span class=\"n\">withFunLocalDecls</span><span class=\"w\"> </span><span class=\"n\">headers</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">funFVars</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabFunValues</span><span class=\"w\"> </span><span class=\"n\">headers</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">header</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span><span class=\"o\">}</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">predef</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">MutualClosure</span><span class=\"bp\">.</span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">headers</span><span class=\"w\"> </span><span class=\"n\">funFVars</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"w\"> </span><span class=\"o\">[])[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n</code></pre></div>\n<p>edit: the code below is a mwe for the case that attempts to avoid <code>elabHeaders</code> (and fails). the <code>#eval</code> will report <code>unknown identifier m/n</code>. From my tracing, it seems to me that both<code>State</code> and <code>Context</code> in <code>TermElabM</code> are the same as the case above just before the call to <code>elabFunValues</code>, so I don't understand why it fails</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">OpenPrivate</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">Term</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">withFunLocalDecls</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">MutualDef</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">elabFunValues</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">MutualDef</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkAddPreDef</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">defview</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkDefViewOfDef</span><span class=\"w\"> </span><span class=\"o\">{}</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">shortName</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">declName</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">levelNames</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">withRef</span><span class=\"w\"> </span><span class=\"n\">defview</span><span class=\"bp\">.</span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">expandDeclId</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">getCurrNamespace</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">getLevelNames</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">defview</span><span class=\"bp\">.</span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"n\">defview</span><span class=\"bp\">.</span><span class=\"n\">modifiers</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">typeExpr</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">defview</span><span class=\"bp\">.</span><span class=\"n\">binders</span><span class=\"bp\">.</span><span class=\"n\">getArgs</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">dveh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DefViewElabHeader</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">elabBindersEx</span><span class=\"w\"> </span><span class=\"n\">binders</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">synthesizeSyntheticMVarsNoPostponing</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">binderIds</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">unzip</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">proto_dveh_data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DefViewElabHeaderData</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">      </span><span class=\"n\">declName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">declName</span>\n<span class=\"w\">      </span><span class=\"n\">shortDeclName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">shortName</span>\n<span class=\"w\">      </span><span class=\"n\">levelNames</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">levelNames</span>\n<span class=\"w\">      </span><span class=\"n\">binderIds</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">binderIds</span>\n<span class=\"w\">      </span><span class=\"n\">numParams</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">size</span>\n<span class=\"w\">      </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">typeExpr</span>\n<span class=\"w\">    </span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">proto_dveh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DefViewElabHeader</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">      </span><span class=\"n\">defview</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">proto_dveh_data</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">bodySnap?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tacSnap?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">proto_dveh</span>\n<span class=\"w\">  </span><span class=\"n\">withFunLocalDecls</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">dveh</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">fvars</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">fvar</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">fvars</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">addLocalVarInfo</span><span class=\"w\"> </span><span class=\"n\">defview</span><span class=\"bp\">.</span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"n\">fvar</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">funvalues</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">elabFunValues</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">dveh</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">header</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">mkAddPreDef</span>\n</code></pre></div>",
        "id": 492038308,
        "sender_full_name": "nrs",
        "timestamp": 1736142784
    },
    {
        "content": "<p>continuing with this today, if anyone has inputs it would be highly appreciated! will edit this comment with incomplete progress<br>\nedit: currently working on a way to automatically get dependencies between a declaration within a same file (from <code>env.constants.map\\2</code>) in order to make reverse engineering easier</p>",
        "id": 493125481,
        "sender_full_name": "nrs",
        "timestamp": 1736627423
    }
]