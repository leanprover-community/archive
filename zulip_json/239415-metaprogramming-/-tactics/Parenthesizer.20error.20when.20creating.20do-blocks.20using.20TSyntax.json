[
    {
        "content": "<p>Hi! I'm trying to programmatically create a monadic <code>do</code>-block using <code>TSyntax</code> terms, but I keep running into a <code>parenthesize: uncaught backtrack exception</code> error when pretty-printing the <code>do</code>-block I've generated. </p>\n<p>Here's a MWE -- I've defined a dummy command elaborator that triggers the issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Parser</span>\n\n<span class=\"sd\">/-- `mkLetBind lhs rhsTerms` constructs a monadic let-bind expression of the form</span>\n<span class=\"sd\">    `let lhs ← e0 e1 … en`, where `rhsTerms := #[e0, e1, …, en]`.</span>\n<span class=\"sd\">    - Note: `rhsTerms` cannot be empty, otherwise this function throws an exception -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkLetBind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ident</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rhsTerms</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntaxArray</span><span class=\"w\"> </span><span class=\"ss\">`term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">``Term.doSeq</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rhsList</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rhsTerms</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">rhsList</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">argTerms</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"bp\">.</span><span class=\"n\">toArray</span>\n<span class=\"w\">    </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">doSeq</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">argTerms</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"rhsTerms can't be empty\"</span>\n\n\n<span class=\"sd\">/-- Constructs a Lean monadic `do` block out of an array of `doSeq`s</span>\n<span class=\"sd\">    (expressions that appear in the `do` block) -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkDoBlock</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">doBlockExprs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntaxArray</span><span class=\"w\"> </span><span class=\"ss\">``Term.doSeq</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">`term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">doSeqElems</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">TSyntaxArray</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">doBlockExprs</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">doBlockBody</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">doSeq</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">doSeqElems</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">doBlockBody</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Dummy monadic function for example purposes</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">dummyMonadicFunc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Print the raw expr when the command elaborator below fails</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">rawOnError</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\"> Example command elaborator that triggers the issue:</span>\n<span class=\"cm\">   In this example, we are trying to create the do-block</span>\n<span class=\"cm\">  ```</span>\n<span class=\"cm\">  do</span>\n<span class=\"cm\">     let x ← dummyMonadicFunc 1</span>\n<span class=\"cm\">     let y ← dummyMonadicFunc 2</span>\n<span class=\"cm\">     return (x, y)</span>\n<span class=\"cm\">  ```</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"#test_doblock\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">doBlockExprs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Creates `let x ← dummyMonadicFunc 1`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"bp\">.</span><span class=\"n\">mkStr1</span><span class=\"w\"> </span><span class=\"s2\">\"x\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rhs1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">dummyMonadicFunc</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bind1</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">mkLetBind</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">rhs1</span>\n<span class=\"w\">  </span><span class=\"n\">doBlockExprs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">doBlockExprs</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">bind1</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Creates `let y ← dummyMonadicFunc 2`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"bp\">.</span><span class=\"n\">mkStr1</span><span class=\"w\"> </span><span class=\"s2\">\"y\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rhs2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">dummyMonadicFunc</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bind2</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">mkLetBind</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">rhs2</span>\n<span class=\"w\">  </span><span class=\"n\">doBlockExprs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">doBlockExprs</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">bind2</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Creates `return (x, y)`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">returnExpr</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">doSeq</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">doBlockExprs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">doBlockExprs</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">returnExpr</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Creates the offending do-block</span>\n<span class=\"w\">  </span><span class=\"c1\">-- This causes the exception `parenthesize: uncaught backtrack exception`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">doBlock</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">mkDoBlock</span><span class=\"w\"> </span><span class=\"n\">doBlockExprs</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{doBlock}\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">test_doblock</span>\n</code></pre></div>\n<p>I suspect the issue is that I am creating nested <code>doSeq</code>s, which causes the parenthesizer to complain, although I'm not sure how else to programmatically create do-blocks with let-bind expressions in them. Any advice would be much appreciated, thanks!</p>",
        "id": 523843765,
        "sender_full_name": "Ernest Ng",
        "timestamp": 1749768056
    },
    {
        "content": "<p>You diagnosed the problem correctly, you are creating invalid syntax, that's why it doesn't work <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n<p>Any code that uses constructors like <code>TSyntax.mk</code> or <code>TSyntaxArray.mk</code> (like in <code>mkDoBlock</code>) must be done with a lot of care (or, better, be avoided!) since that circumvents the small amount of typechecking that the <code>TSyntax</code> system provides. In particular, there should always at least be a type ascription (otherwise you're at the mercy of the syntax quotations assigning types; here it comes up with <code>TSyntaxArray `Lean.Parser.Term.doSeqItem</code>) and then verify that the conversion is actually valid. Converting a <code>Term.doSeq</code> to a <code>Lean.Parser.Term.doSeqItem</code> is definitely not valid, since they have different internal Syntax structures. (<code>doSeq</code> has kind <code>doSeqIndent</code>  or <code>doSeqBracketed</code>, but <code>doSeqItem</code> has kind <code>doSeqItem</code>)</p>\n<p>The right kind of syntax to work with here is the syntax category <code>doElem</code>, since the body of a <code>do</code> is ultimately a list of them.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Parser</span>\n\n<span class=\"sd\">/-- `mkLetBind lhs rhsTerms` constructs a monadic let-bind expression of the form</span>\n<span class=\"sd\">    `let lhs ← e0 e1 … en`, where `rhsTerms := #[e0, e1, …, en]`.</span>\n<span class=\"sd\">    - Note: `rhsTerms` cannot be empty, otherwise this function throws an exception -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkLetBind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ident</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rhsTerms</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntaxArray</span><span class=\"w\"> </span><span class=\"ss\">`term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">`doElem</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rhsList</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rhsTerms</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">rhsList</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">argTerms</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"bp\">.</span><span class=\"n\">toArray</span>\n<span class=\"w\">    </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">doElem</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">argTerms</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"rhsTerms can't be empty\"</span>\n\n\n<span class=\"sd\">/-- Constructs a Lean monadic `do` block out of an array of `doSeq`s</span>\n<span class=\"sd\">    (expressions that appear in the `do` block) -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkDoBlock</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">doElems</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntaxArray</span><span class=\"w\"> </span><span class=\"ss\">`doElem</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">`term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">doElems</span><span class=\"o\">:</span><span class=\"n\">doElem</span><span class=\"o\">]</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Dummy monadic function for example purposes</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">dummyMonadicFunc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Print the raw expr when the command elaborator below fails</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">rawOnError</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\"> Example command elaborator that triggers the issue:</span>\n<span class=\"cm\">   In this example, we are trying to create the do-block</span>\n<span class=\"cm\">  ```</span>\n<span class=\"cm\">  do</span>\n<span class=\"cm\">     let x ← dummyMonadicFunc 1</span>\n<span class=\"cm\">     let y ← dummyMonadicFunc 2</span>\n<span class=\"cm\">     return (x, y)</span>\n<span class=\"cm\">  ```</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"#test_doblock\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">doBlockExprs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Creates `let x ← dummyMonadicFunc 1`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"bp\">.</span><span class=\"n\">mkStr1</span><span class=\"w\"> </span><span class=\"s2\">\"x\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rhs1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">dummyMonadicFunc</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bind1</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">mkLetBind</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">rhs1</span>\n<span class=\"w\">  </span><span class=\"n\">doBlockExprs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">doBlockExprs</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">bind1</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Creates `let y ← dummyMonadicFunc 2`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"bp\">.</span><span class=\"n\">mkStr1</span><span class=\"w\"> </span><span class=\"s2\">\"y\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rhs2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">dummyMonadicFunc</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bind2</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">mkLetBind</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">rhs2</span>\n<span class=\"w\">  </span><span class=\"n\">doBlockExprs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">doBlockExprs</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">bind2</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Creates `return (x, y)`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">returnExpr</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">doElem</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">doBlockExprs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">doBlockExprs</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">returnExpr</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Creates the offending do-block</span>\n<span class=\"w\">  </span><span class=\"c1\">-- This causes the exception `parenthesize: uncaught backtrack exception`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">doBlock</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">mkDoBlock</span><span class=\"w\"> </span><span class=\"n\">doBlockExprs</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{doBlock}\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">test_doblock</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">do</span>\n<span class=\"cm\">  let x ← dummyMonadicFunc✝ 1</span>\n<span class=\"cm\">  let y ← dummyMonadicFunc✝ 2</span>\n<span class=\"cm\">  return (x, y)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 523847398,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749770706
    },
    {
        "content": "<p>Thanks a lot! This was very helpful &amp; informative! </p>\n<p>I was looking at the <a href=\"https://lean-lang.org/doc/reference/latest/Functors___-Monads-and--do--Notation/Syntax/\">section in the language reference on the grammar for do-expressions</a> and mistakenly thought that <code>doElem</code> only described <code>let mut</code> expressions (since the page only mentions <code>doElem</code> in the context of local mutability). However, looking at the <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Parser/Do.lean\">source code for the Lean parser</a>, it seems like <code>doElem</code> is the most primitive construct and should be preferred during metaprogramming (since the parser for <code>doElem</code>s is a built-in).</p>",
        "id": 523858449,
        "sender_full_name": "Ernest Ng",
        "timestamp": 1749779549
    }
]