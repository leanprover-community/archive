[
    {
        "content": "<p>Suppose that I have something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Synth</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">lemma_with_extra_typeclasses</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Synth</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>where I know that once I have used <code>Synth.prop</code> that the instance is irrelevant to the actual proof. Is there a way that I can simp <code>inst.prop</code>, remove the typeclass instance, and keep the body of the proof?</p>",
        "id": 505754693,
        "sender_full_name": "Chris Henson",
        "timestamp": 1741981352
    },
    {
        "content": "<p>Is this what you want?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Synth</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">lemma_with_extra_typeclasses</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Synth</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 505755135,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741981522
    },
    {
        "content": "<p>Yes, but I would like this to happen as a metaprogram that removes <code>[inst : Synth X]</code> so that it does not appear in the type signature of the theorem.</p>",
        "id": 505762033,
        "sender_full_name": "Chris Henson",
        "timestamp": 1741984337
    },
    {
        "content": "<p>Then you can't do it with just <code>theorem</code>. How to you expect to interface this action?</p>",
        "id": 505763384,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741984838
    },
    {
        "content": "<p>I may have been unclear, let me try again. If I want to <em>insert</em> typeclass instances, I can do something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Synth</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"c1\">-- in a real use case this would depend on $sig, but in a way where I know we</span>\n<span class=\"c1\">-- should be able to remove Synth instances and still have a valid proof</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">synth_theorem</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">declModifiers</span><span class=\"w\"> </span><span class=\"n\">group</span><span class=\"o\">(</span><span class=\"s2\">\"synth_theorem \"</span><span class=\"w\"> </span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"n\">ppIndent</span><span class=\"o\">(</span><span class=\"n\">declSig</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">declVal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span>\n<span class=\"kn\">macro_rules</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">synth_theorem</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">sig</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">proof</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Synth</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">proof</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">synth_theorem</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">sig</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">proof</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Synth</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">proof</span><span class=\"o\">)</span>\n\n<span class=\"n\">synth_theorem</span><span class=\"w\"> </span><span class=\"n\">lemma_with_extra_typeclasses</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- lemma_with_extra_typeclasses : ∀ (X : Type) [inst : Synth X], Synth.prop X</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">lemma_with_extra_typeclasses</span>\n</code></pre></div>\n<p>At the end I have <code>∀ (X : Type) [inst : Synth X], Synth.prop X</code>, and I know that the only thing that the typeclass instance is doing is providing some proposition, and that the proof would be valid with or without it. So I would like to have a metaprogram that gives us a new theorem that uses the same proof, but removes <code>[inst : Synth X]</code>.</p>",
        "id": 505767458,
        "sender_full_name": "Chris Henson",
        "timestamp": 1741986567
    },
    {
        "content": "<p>I don't understand how you expect <code>inst.prop</code> to be a well defined term after we remove the <code>[inst : Synth X]</code> binder.</p>",
        "id": 505974536,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742144109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/removing.20an.20unused.20typeclass/near/505974536\">said</a>:</p>\n<blockquote>\n<p>I don't understand how you expect <code>inst.prop</code> to be a well defined term after we remove the <code>[inst : Synth X]</code> binder.</p>\n</blockquote>\n<p>This is my initial assumption, that once you simplify <code>inst.prop</code> it is not otherwise dependent on the instance. (I would expect the metaprogram to simply fail if this were somehow violated). As an extreme example, suppose there were a polymorphic instance of <code>Synth</code> where <code>prop</code> is now always <code>1 = 1</code>. Should it not make sense that after simplifying <code>inst.prop</code> to this, we should be able to remove the <code>inst</code> from the type signature and be left with a valid proof?</p>",
        "id": 505975526,
        "sender_full_name": "Chris Henson",
        "timestamp": 1742144832
    },
    {
        "content": "<p>Ah that makes sense. You want the program to simplify the type (and maybe even the proof) and if some variable doesn't appear anymore, remove it from the theorem.</p>",
        "id": 505975690,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742144970
    },
    {
        "content": "<p>Yes, exactly. I want, as a metaprogram, to simplify <code>inst.prop</code> and remove the instance from the theorem. I am fine assuming the <strong><em>only</em></strong> place it appears is this type of the theorem, so I am fine transferring the proof as is.</p>",
        "id": 505976095,
        "sender_full_name": "Chris Henson",
        "timestamp": 1742145235
    },
    {
        "content": "<p>There are two parts to this: what simplification function do you use, and adding the modified declaration to the environment.</p>\n<p>I wouldn't be surprised if there already exists some function that unfolds type class projections.</p>",
        "id": 505976402,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742145414
    },
    {
        "content": "<p>This one: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Tactic.unfoldProjs#doc\">docs#Mathlib.Tactic.unfoldProjs</a></p>",
        "id": 505976838,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742145708
    },
    {
        "content": "<p>Nice! I was able to use that along with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.unfoldDefinition#doc\">docs#Lean.Meta.unfoldDefinition</a> to simplify the type at least.</p>",
        "id": 506000604,
        "sender_full_name": "Chris Henson",
        "timestamp": 1742162174
    },
    {
        "content": "<p>What did you need <code>unfoldDefinition</code> for? Didn't you only want to unfold the type class projections? Or did <code>unfoldProjs</code> not unfold the instance in your example?</p>",
        "id": 506000787,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742162331
    },
    {
        "content": "<p>Yes, in my example the projections are sufficient. In my actual use case it takes the proof signature  as an argument, so I needed to unfold once.</p>",
        "id": 506001240,
        "sender_full_name": "Chris Henson",
        "timestamp": 1742162679
    },
    {
        "content": "<p>Is there a section of the docs similarly helpful for modifying the declaration?</p>",
        "id": 506001292,
        "sender_full_name": "Chris Henson",
        "timestamp": 1742162723
    },
    {
        "content": "<p>Well I don't there is an easy way to modify a declaration directly. You can make a new declaration with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.addDecl#doc\">docs#Lean.addDecl</a> (or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.addAndCompile#doc\">docs#Lean.addAndCompile</a>)</p>",
        "id": 506002910,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742163935
    },
    {
        "content": "<p>Been trying this for a bit. Does this look headed in the right direction?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Synth</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"c1\">-- want to remove `[inst : Synth X]` from this</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">simp_with_extra_typeclasses</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Synth</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">filterSynth</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoreM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Environment</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"c1\">-- is this the right constrcutor where I could filter out `[inst : Synth X]`?</span>\n<span class=\"w\">  </span><span class=\"c1\">-- just changing the name to test for now</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">ConstantInfo</span><span class=\"bp\">.</span><span class=\"n\">thmInfo</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">new_decl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Declaration</span><span class=\"bp\">.</span><span class=\"n\">thmDecl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">name</span><span class=\"bp\">.</span><span class=\"n\">appendAfter</span><span class=\"w\"> </span><span class=\"s2\">\"_filt\"</span><span class=\"o\">}</span>\n<span class=\"w\">      </span><span class=\"n\">addAndCompile</span><span class=\"w\"> </span><span class=\"n\">new_decl</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span>\n\n<span class=\"c1\">-- eval the function and see it successfully registers the new declaration</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">filterSynth</span><span class=\"w\"> </span><span class=\"ss\">`simp_with_extra_typeclasses</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">simp_with_extra_typeclasses_filt</span>\n</code></pre></div>\n<p>I think I understand accessing a declaration by its name, but I am unsure how to take that old declaration and filter out the instances I want to remove.</p>",
        "id": 506019004,
        "sender_full_name": "Chris Henson",
        "timestamp": 1742173685
    },
    {
        "content": "<p>Okay, I finally figured it out! Thanks for all the help. By pattern matching on the <code>Expr</code>s of <code>Lean.TheoremVal.type</code> and <code>Lean.TheoremVal.value</code>, I was able to remove the unused instances.</p>",
        "id": 506032359,
        "sender_full_name": "Chris Henson",
        "timestamp": 1742182398
    }
]