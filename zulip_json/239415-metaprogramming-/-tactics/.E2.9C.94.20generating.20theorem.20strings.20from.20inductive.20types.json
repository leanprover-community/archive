[
    {
        "content": "<p>Hello all! My new-ish research project aims to create a bridge between Lean and the <a href=\"https://github.com/verus-lang/verus\">Verus</a> automated theorem prover. In pursuit of this project, I have a question about how to use Lean's elab/delab infrastructure to take syntax/term/expression objects representing a theorem and transform them back into a string corresponding to that theorem. (All the code included here can be found <a href=\"https://github.com/JamesGallicchio/verus-lean/tree/cayden\">at this branch on GitHub</a>.)</p>\n<p>(This question arguably has too much context included, and is very long anyways, so feel free to skim/skip to where Lean snippets start appearing.)</p>\n<p>For background: Verus is like dafny, why3, and F*, where programmers can annotate their (Rust) code with pre-/post-conditions, loop invariants, and asserts, and then Verus tries to prove prove that those contracts/specifications hold. Verus uses SMT solvers on the back-end to discharge these proof goals, but SMT solvers can be unstable or inappropriate for some theories/domains, which prevents verification in those cases, and so the team has requested the ability to export proof goals to Lean instead.</p>\n<p>Currently, my Lean project can consume serialized JSON proof goal objects from Verus and then construct <code>inductive</code> types that represent these goals. We then want to produce actual <code>.lean</code> files from these objects, containing the theorems to be discharged by Lean. Right now, I've hard-coded some pretty-printing. For example, to print a string corresponding to a binary operation, I do the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Pretty-print a binary operation</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BinaryOp</span><span class=\"bp\">.</span><span class=\"n\">pp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BinaryOp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"s2\">\" ∧ \"</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"s2\">\" ∨ \"</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Xor</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"s2\">\" ^^ \"</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Implies</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"s2\">\" → \"</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"s2\">\" = \"</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Ne</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"s2\">\" ≠ \"</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ... and so on</span>\n</code></pre></div>\n<p>At top-level, theorems are generated via a call to the following function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Take an expression object `ExpX` and create a theorem string for it</span>\n<span class=\"c1\">-- `decls` contains the strings for type declarations for variables referenced in the `ExpX`</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ExpX</span><span class=\"bp\">.</span><span class=\"n\">toTheoremString</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ExpX</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"verus_thm\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">decls</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"s2\">\"theorem \"</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"s2\">\" \"</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">decls</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"s2\">\": \"</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">ExpX</span><span class=\"bp\">.</span><span class=\"n\">pp</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"s2\">\" := by sorry</span><span class=\"se\">\\n\\n</span><span class=\"s2\">\"</span>\n</code></pre></div>\n<p>However, this is not the \"morally correct\" thing to do. Hard-coded strings are brittle, they don't enable Lean's type-checker to sanity-check things, and they are hard to format without tons of parentheses.</p>\n<p>Instead, my fellow lab members tell me that the \"morally correct\" thing to do is to generate <code>Term</code> or <code>Syntax</code> or <code>Expr</code> objects, and then ask Lean to give the theorem string back instead. For example, binary operations can be processed like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Generate a term for a binary operation, given the terms for the LHS and RHS</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BinaryOp</span><span class=\"bp\">.</span><span class=\"n\">toSyntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BinaryOp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">rhs</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">rhs</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Xor</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"bp\">^^</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">rhs</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Implies</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">rhs</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">rhs</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Ne</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">rhs</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ... and so on</span>\n</code></pre></div>\n<p>We then work with top-level assertions in the command monad, since theorems are commands(?):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Generate a command for a top-level assertion or theorem statement (a `Decl`)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Decl</span><span class=\"bp\">.</span><span class=\"n\">toSyntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommandElabM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntaxArray</span><span class=\"w\"> </span><span class=\"ss\">`command</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">assertion</span><span class=\"w\"> </span><span class=\"n\">thmName</span><span class=\"w\"> </span><span class=\"n\">decls</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ExpX</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">thmName</span><span class=\"bp\">.</span><span class=\"n\">toSyntax</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntaxArray</span><span class=\"w\"> </span><span class=\"ss\">``Lean.Parser.Term.bracketedBinder</span><span class=\"w\"> </span><span class=\"bp\">←</span>\n<span class=\"w\">      </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"o\">(</span>\n<span class=\"w\">        </span><span class=\"c1\">-- `decls` stores mappings of variable identifiers to types</span>\n<span class=\"w\">        </span><span class=\"n\">decls</span><span class=\"bp\">.</span><span class=\"n\">toArray</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">          </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">toSyntax</span>\n<span class=\"w\">          </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"bp\">.</span><span class=\"n\">toSyntax</span>\n<span class=\"w\">          </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">))</span>\n<span class=\"w\">        </span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">eTerm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">toSyntax</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span>\n<span class=\"w\">      </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">):</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">*</span>\n<span class=\"w\">        </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">eTerm</span>\n<span class=\"w\">        </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">c</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Once we have our command, we ask Lean to run it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Decl</span><span class=\"bp\">.</span><span class=\"n\">toFormat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"w\"> </span><span class=\"n\">Exception</span><span class=\"w\"> </span><span class=\"n\">Format</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">withImportModules</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">imports</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[])</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">opts</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Options</span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">trustLevel</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">EIO</span><span class=\"bp\">.</span><span class=\"n\">toIO'</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">      </span><span class=\"n\">Core</span><span class=\"bp\">.</span><span class=\"n\">CoreM</span><span class=\"bp\">.</span><span class=\"n\">run'</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">          </span><span class=\"n\">fileName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"Example.lean\"</span>\n<span class=\"w\">          </span><span class=\"n\">fileMap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">default</span>\n<span class=\"w\">        </span><span class=\"o\">})</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">          </span><span class=\"n\">env</span>\n<span class=\"w\">        </span><span class=\"o\">})</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"k\">do</span>\n<span class=\"w\">          </span><span class=\"n\">try</span>\n<span class=\"w\">            </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">syns</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">liftCommandElabM</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">toSyntax</span>\n<span class=\"w\">            </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">syn</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">syns</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">              </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">liftCommandElabM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">elabCommandTopLevel</span><span class=\"w\"> </span><span class=\"n\">syn</span>\n<span class=\"w\">            </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">fmt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Format</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span>\n<span class=\"w\">            </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">syn</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">syns</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">              </span><span class=\"n\">fmt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fmt</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">line</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">(</span>\n<span class=\"w\">                </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">PrettyPrinter</span><span class=\"bp\">.</span><span class=\"n\">format</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Formatter</span><span class=\"bp\">.</span><span class=\"n\">categoryFormatter</span><span class=\"w\"> </span><span class=\"ss\">`command</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">syn</span>\n<span class=\"w\">              </span><span class=\"o\">)</span>\n<span class=\"w\">            </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">fmt</span>\n<span class=\"w\">          </span><span class=\"n\">catch</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">            </span><span class=\"n\">throw</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">        </span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"s2\">\"bad syntax\"</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Format</span><span class=\"bp\">.</span><span class=\"n\">pretty</span><span class=\"w\"> </span><span class=\"n\">res</span>\n</code></pre></div>\n<p>Yet when I do this on relatively simple statements (such as \"x = y -&gt; y = x\"), I get errors. For example, running the above code on the <code>x = y -&gt; y = x</code> fact gives output like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">declaration</span>\n<span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">declModifiers</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"kn\">theorem</span>\n<span class=\"w\">  </span><span class=\"s2\">\"theorem\"</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"ss\">`assert_37</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">declSig</span>\n<span class=\"w\">   </span><span class=\"o\">[(</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">explicitBinder</span><span class=\"w\"> </span><span class=\"s2\">\"(\"</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\":\"</span><span class=\"w\"> </span><span class=\"ss\">`Int</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"s2\">\")\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">explicitBinder</span><span class=\"w\"> </span><span class=\"s2\">\"(\"</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`x</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\":\"</span><span class=\"w\"> </span><span class=\"ss\">`Int</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"s2\">\")\"</span><span class=\"o\">)]</span>\n<span class=\"w\">   </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">typeSpec</span><span class=\"w\"> </span><span class=\"s2\">\":\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">arrow</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">«</span><span class=\"n\">term_</span><span class=\"bp\">=_»</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"s2\">\"=\"</span><span class=\"w\"> </span><span class=\"ss\">`y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"→\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">«</span><span class=\"n\">term_</span><span class=\"bp\">=_»</span><span class=\"w\"> </span><span class=\"ss\">`y</span><span class=\"w\"> </span><span class=\"s2\">\"=\"</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"o\">))))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">declValSimple</span>\n<span class=\"w\">   </span><span class=\"s2\">\":=\"</span>\n<span class=\"w\">   </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">byTactic</span><span class=\"w\"> </span><span class=\"s2\">\"by\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">tacticSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">tacticSeq1Indented</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">tacticSorry</span><span class=\"w\"> </span><span class=\"s2\">\"sorry\"</span><span class=\"o\">)])))</span>\n<span class=\"w\">   </span><span class=\"o\">(</span><span class=\"n\">Termination</span><span class=\"bp\">.</span><span class=\"n\">suffix</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">   </span><span class=\"o\">[])))</span>\n</code></pre></div>\n<p>This works for generation, but when we go to write the command to file, Lean complains during <code>Decl.toFormat</code> because the</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">elaboration</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"bp\">'«</span><span class=\"n\">term_</span><span class=\"bp\">=_»'</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">been</span><span class=\"w\"> </span><span class=\"n\">implemented</span>\n</code></pre></div>\n<p>Fair enough. Perhaps we replace the <code>.Eq</code> branch during <code>BinaryOp.toSyntax</code> with the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"bp\">.</span><span class=\"n\">mkApp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`Eq</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">lhs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>That seems to take care of the complaints around equality in the generated command:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">declaration</span>\n<span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">declModifiers</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"kn\">theorem</span>\n<span class=\"w\">  </span><span class=\"s2\">\"theorem\"</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">declId</span><span class=\"w\"> </span><span class=\"ss\">`assert_37</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">declSig</span>\n<span class=\"w\">   </span><span class=\"o\">[(</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">explicitBinder</span><span class=\"w\"> </span><span class=\"s2\">\"(\"</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\":\"</span><span class=\"w\"> </span><span class=\"ss\">`Int</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"s2\">\")\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">explicitBinder</span><span class=\"w\"> </span><span class=\"s2\">\"(\"</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`x</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"s2\">\":\"</span><span class=\"w\"> </span><span class=\"ss\">`Int</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"s2\">\")\"</span><span class=\"o\">)]</span>\n<span class=\"w\">   </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">typeSpec</span><span class=\"w\"> </span><span class=\"s2\">\":\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">arrow</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"ss\">`Eq</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"ss\">`y</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"s2\">\"→\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"ss\">`Eq</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`y</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"o\">]))))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">declValSimple</span>\n<span class=\"w\">   </span><span class=\"s2\">\":=\"</span>\n<span class=\"w\">   </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">byTactic</span><span class=\"w\"> </span><span class=\"s2\">\"by\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">tacticSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">tacticSeq1Indented</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">tacticSorry</span><span class=\"w\"> </span><span class=\"s2\">\"sorry\"</span><span class=\"o\">)])))</span>\n<span class=\"w\">   </span><span class=\"o\">(</span><span class=\"n\">Termination</span><span class=\"bp\">.</span><span class=\"n\">suffix</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">   </span><span class=\"o\">[])))</span>\n</code></pre></div>\n<p>But Lean now complains that there is an</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unknown</span><span class=\"w\"> </span><span class=\"n\">constant</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">CoeFun'</span>\n</code></pre></div>\n<p>Hmm... Perhaps the <code>Init</code> module needs to be imported? But adding <code>Init</code> to the <code>Lean.withImportModules</code> gives a new error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">uncaught</span><span class=\"w\"> </span><span class=\"n\">exception</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">unknown</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"kn\">prefix</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Init'</span>\n</code></pre></div>\n<p>And thus I have run out of experiments to try.</p>\n<p>In summary, I feel like there is a one-line or one-function fix here, but I'm not familiar enough with meta-programming to know what that fix might be. I would appreciate any input, including suggestions for what the \"morally correct\" way of generating theorem strings are in Lean.</p>",
        "id": 483572523,
        "sender_full_name": "Cayden Codel",
        "timestamp": 1732137194
    },
    {
        "content": "<p>The fact that the module was not found means that you aren't calling your program with the right LEAN_PATH</p>",
        "id": 483574973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732138305
    },
    {
        "content": "<p>Try running it as <code>lake env myprog</code> instead of just <code>myprog</code></p>",
        "id": 483575055,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732138332
    },
    {
        "content": "<p>Nah, even with <code>lake env</code> I get the same error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">lake</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"bp\">./</span><span class=\"n\">verus</span><span class=\"bp\">-</span><span class=\"n\">lean</span><span class=\"w\"> </span><span class=\"n\">dir</span><span class=\"w\"> </span><span class=\"bp\">../../../</span><span class=\"n\">small</span>\n<span class=\"n\">uncaught</span><span class=\"w\"> </span><span class=\"n\">exception</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">unknown</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"kn\">prefix</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Init'</span>\n\n<span class=\"n\">No</span><span class=\"w\"> </span><span class=\"n\">directory</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Init'</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Init</span><span class=\"bp\">.</span><span class=\"n\">olean'</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">search</span><span class=\"w\"> </span><span class=\"n\">path</span><span class=\"w\"> </span><span class=\"n\">entries</span><span class=\"o\">:</span>\n</code></pre></div>\n<p>David suggested at the Hoskinson Center meeting to add</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">searchPathRef</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">compile_time_search_path</span><span class=\"bp\">%</span>\n</code></pre></div>\n<p>before running <code>withImportModules</code>, but I'm getting a type error. I've only been at it for a minute though so this is not concerning yet.</p>",
        "id": 483584481,
        "sender_full_name": "Cayden Codel",
        "timestamp": 1732142795
    },
    {
        "content": "<p>Okay, adding <code>searchPathRef</code> worked, but the generated file uses <code>Eq x y</code> instead of <code>x = y</code>. But this seems a smaller matter now. Thanks for the help Mario!</p>",
        "id": 483585018,
        "sender_full_name": "Cayden Codel",
        "timestamp": 1732143066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"424407\">Cayden Codel</span> has marked this topic as resolved.</p>",
        "id": 483585030,
        "sender_full_name": "Notification Bot",
        "timestamp": 1732143072
    },
    {
        "content": "<p>Oh, and once I made this fix, I can use <code>=</code> in the elaboration again. So that's much better</p>",
        "id": 483585471,
        "sender_full_name": "Cayden Codel",
        "timestamp": 1732143266
    }
]