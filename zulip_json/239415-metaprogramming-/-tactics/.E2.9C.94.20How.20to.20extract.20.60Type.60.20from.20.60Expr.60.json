[
    {
        "content": "<p>Hello all! I'm implementing a tactic to work with polynomials on <code>Field</code>s, similar in scope to <code>polyrith</code> (i.e., solving for Groebner bases). I need to examine a proof context and extract certain equalities on <code>Field</code>s in a meta-programming way, but then create concrete data representations of polynomials on that type (i.e. to compute the Groebner basis). Basically, if <code>e : Expr</code> ultimately has type <code>F : Type</code>, where <code>[Field F]</code> holds, then I want to construct a <code>List F</code>. I then want to compute on that data.</p>\n<p>In other words, I want a function <code>typeFromExpr : Lean.Expr â†’ Î£' (t : Type), Field t</code>. However, to work on <code>Expr</code>, you probably need to be in <code>MetaM</code>, and having a function of type <code>Lean.Expr â†’ MetaM (Î£' (t : Type), Field t)</code> is not possible, because <code>MetaM</code> must live in <code>Type</code>.</p>\n<p>Are there alternative ways of doing this? Or must I resign myself to calling <code>evalExpr</code> a ton?</p>",
        "id": 500994951,
        "sender_full_name": "Cayden Codel",
        "timestamp": 1740096728
    },
    {
        "content": "<p>When working in MetaM (at the meta-level), you'd generally not use object values at their object-level types, instead storing everything as an <code>Expr</code>. It's then easy to get confused about which <code>Expr</code>s are object-types, object-values, object-fields or whatever, so you can use <code>Qq</code> to keep track of this.</p>",
        "id": 500996947,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1740097858
    },
    {
        "content": "<p>In particular, if you want your metaprograms to handle terms containing variables, you cannot use <code>evalExpr</code>: it can only evaluate closed expressions.</p>",
        "id": 500997238,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1740098035
    },
    {
        "content": "<p>Yeah, you're not going to want to work with terms of <code>F</code> itself (what if <code>F</code> is the reals for example -- what computations are you going to do when key operations are noncomputable?) You want to work with an <code>Expr</code> that symbolically represents a term of <code>F</code>, and operate on that.</p>\n<p>If you use Qq, then <code>q(Nat)</code> is a <code>Lean.Expr</code> but annotated to have type <code>Q(Type)</code>.</p>\n<p>Your <code>typeFromExpr</code> should return <code>Î£' (t : Q(Type)), Q(Field $t)</code>, so you're working with symbolic expressions.</p>\n<p>(I don't think <code>evalExpr</code> works with <code>Type</code> anyway, since <code>Type</code> has no runtime representation.)</p>",
        "id": 501008987,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740105237
    },
    {
        "content": "<p>Indeed, after further discussion with a labmate and some sleuthing in <code>ring</code>, we determined that this approach is wrong. But it's good to know that it's also impossible!</p>",
        "id": 501147092,
        "sender_full_name": "Cayden Codel",
        "timestamp": 1740156967
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"424407\">Cayden Codel</span> has marked this topic as resolved.</p>",
        "id": 501147101,
        "sender_full_name": "Notification Bot",
        "timestamp": 1740156971
    }
]