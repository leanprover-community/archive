[
    {
        "content": "<p>Hi all! First, I was wondering if there's already work underway on a mutual induction tactic (for things in Prop in particular)? </p>\n<p>If not, I was thinking of hacking one together myself for now, which would work something like this:<br>\nSuppose I had <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> mutual inductives <code>I₁ ... Iₙ</code> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> constructors total, so that each <code>Iᵢ.rec</code> would have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> arguments, and suppose I were in a proof state with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> cases <code>case₁ ... caseₘ</code>, each with an element of an inductive <code>h₁ ... hₘ</code> . Then a tactic shaped something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">mutual_induction</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">case₁</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">caseₘ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">hₘ</span>\n</code></pre></div>\n<p>would do the following:</p>\n<ol>\n<li>Get the types of <code>h₁ ... hₘ</code>, check that they belong to one of <code>I₁ ... Iₘ</code>, and ensure that they are disjoint so that no types overlap (necessarily, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">m \\le n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>)</li>\n<li>Get the types of the goals of <code>case₁ ... caseₘ</code>, and infer a motive based on the corresponding <code>h : I</code></li>\n<li>In each case, apply recursors <code>I₁.rec ... Iₘ.rec</code>, specializing the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> motives by the ones inferred above, and specializing the rest by <code>(λ _ ↦ True)</code></li>\n<li>At this point, there should be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> duplicates of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> new goals, one for each subgoal of every recursor, so deduplicate them in the proof state so that the user only sees <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> goals, while they are actually applied to each of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> recursors</li>\n</ol>\n<p>How should I go about starting something like this? I've written small tactics before that manipulate the current proof state, but not dealing with mutual inductives or with multiple goals at once. I also imagine that a lot of this is done for the usual <code>induction</code> tactic, like steps 2 and 3, so where should I look to find code that I can reuse?</p>",
        "id": 502284678,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1740663117
    },
    {
        "content": "<p><code>induction</code> lives in <code>Lean.Elab.Tactic.Inducion</code>, and probably depends on an implementation in <code>Lean.Meta.*</code>. You can find where a tactic lives by writing out the tactic in a <code>by</code> block and doing \"go to definition\" (default shortcuts : F12, Ctrl-click) in VSCode or the web editor.</p>",
        "id": 502289111,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740664292
    },
    {
        "content": "<p>okay I'm following along <code>Lean.Elab.Tactic.Induction</code> mostly, here's my next problem: how do I get the <code>MVarId</code> of a goal from a bit of syntax? The full syntax looks like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mutual_induction</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"mutual_induction \"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\"| \"</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"s2\">\" =&gt; \"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span>\n</code></pre></div>\n<p>and I get <code>getId</code> of an <code>ident</code> and put that inside an <code>MVarId</code>, but that doesn't seem like the proper way to do it<br>\nI haven't found tactics around that manipulate existing goals, and I can't seem to Ctrl-click into what <code>case</code> is doing to select a goal</p>",
        "id": 503122558,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1741035627
    },
    {
        "content": "<p>So the functions for getting and switching goals work in the TacticM monad</p>",
        "id": 503362365,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1741121670
    },
    {
        "content": "<p>You can find some examples here: <a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/main/09_tactics.html#exploring-tacticm\">https://leanprover-community.github.io/lean4-metaprogramming-book/main/09_tactics.html#exploring-tacticm</a></p>",
        "id": 503362407,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1741121689
    },
    {
        "content": "<p><del><code>getMainGoal</code></del> <code>Lean.Elab.Tactic.getMainTarget</code> is probably what you are looking for</p>",
        "id": 503362479,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1741121712
    },
    {
        "content": "<p>I'm actually trying to work under the context of given subgoals that might <em>not</em> be the current main goal<br>\nIn the end I went for copying <code>Lean.Elab.Tactic.BuiltinTactic.findTag?</code> to get the <code>MVarId</code> associated with the given subgoal</p>",
        "id": 503364346,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1741122437
    },
    {
        "content": "<p>Oh okay. I think you can get all the goals as well. In general, the functions for manipulating and fetching goals are in this module:</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Elab/Tactic/Basic.html\">https://leanprover-community.github.io/mathlib4_docs/Lean/Elab/Tactic/Basic.html</a></p>",
        "id": 503382787,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1741129785
    },
    {
        "content": "<p>For example there are functions like getGoals and getUnsolvedGoals</p>",
        "id": 503382989,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1741129890
    },
    {
        "content": "<p>I don’t know if it gets the goal from the syntax in the sense that you would like to get it.</p>",
        "id": 503383114,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1741129940
    },
    {
        "content": "<p>But I imagine that for cases and induction, you essentially supply metavariables to the various arguments of the recursor and then manipulate the goals using the functions in the link. The hypothesis and goals get their names when their mvar is instantiated, but you essentially get their mvarId right away in the tactic code, and use them everywhere further down.</p>",
        "id": 503383287,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1741130035
    },
    {
        "content": "<p>I have working examples here now: <a href=\"https://github.com/ionathanch/MutualInduction\">https://github.com/ionathanch/MutualInduction</a><br>\nI'm thinking of opening an RFC for this soon to see if this might be something worth adding</p>",
        "id": 504318250,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1741468523
    },
    {
        "content": "<p>Nice! I've never seen a tactic that operates on multiple goals simultaneously like this, it's interesting.</p>\n<p>One thought: having theorems that prove a conjunction tends to be a bit odd. One tool we have is mutual recursion, which works for theorems too. In EvenOdd for example, one can write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kn\">variable</span>\n<span class=\"w\">  </span><span class=\"c1\">-- motives</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">Odd</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- subgoals</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ezero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">esucc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Odd</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">osucc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">en</span><span class=\"o\">))</span>\n\n<span class=\"n\">include</span><span class=\"w\"> </span><span class=\"n\">ezero</span><span class=\"w\"> </span><span class=\"n\">esucc</span><span class=\"w\"> </span><span class=\"n\">osucc</span>\n\n<span class=\"kn\">mutual</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">evenOddInd_even</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ezero</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">esucc</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"n\">on</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">evenOddInd_odd</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">evenOddInd_odd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Odd</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">osucc</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"n\">en</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">evenOddInd_even</span>\n<span class=\"kn\">end</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>(Note: this seems to be triggering an \"unused variables\" bug!)</p>\n<p>I think this doesn't work for <code>wtfInd</code> in TypeTheory though. Mutual recursion for <code>evenOddInd</code> is taking advantage of structural recursion on the natural number, but mutually recursing on the proofs of <code>⊢ Γ</code> and <code>Γ ⊢ a ∶ A</code> doesn't seem to work (maybe there's some <code>termination_by</code> that would work, though I didn't check).</p>\n<p>Anyway, I'm wondering if, instead of a tactic, there could be a <code>mutual_induction</code> block to define multiple theorems. Do you think it would be common to do a mutual induction in the middle of another proof, instead of at the top level?</p>",
        "id": 504324943,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741473766
    },
    {
        "content": "<p>Yeah, it seems structural recursion on some mutual inductive predicates doesn't work because the corresponding <code>.brecOn</code> doesn't get generated; not sure why, since I see it is generated for <code>Even</code>/<code>Odd</code> and <code>Le</code>/<code>LeUnder</code>/<code>LeOver</code> in the examples I have, just not for <code>Wf</code>/<code>Wt</code></p>\n<p>Proving mutual theorems with a conjunction is a common pattern in Rocq, especially since you can generate a combined induction principle with <code>Combined Scheme</code> that produces a conjunction, i.e. for <code>Even</code>/<code>Odd</code> you would get something ending in <code>(∀ n (en : Even n), P en) ∧ (∀ n (on : Odd n), Q on)</code><br>\nIt would be possible to do the same thing and produce a combined recursor out of all of the recursors that get generated, but I don't like working directly with this kind of recursor because then you need to prove everything in exactly that shape and order, and you need to generalize all your induction dependencies yourself<br>\nThis tactic was how I imagined working around that, where you're not fixed to a conjunction, and you have the tactic generalizing everything necessary for you, and most importantly infer the motive for you</p>\n<p>I would prefer writing mutual structural recursion though (Agda is where I really started so that's how I think about things). So it seems the solution would be to fix whatever generates <code>.brecOn</code> to also do it for really all mutual inductives, and you would get mutual structural recursion out of that<br>\nBut anything you can write with the <code>induction</code> tactic you can also do with structural recursion, and I think they each have their place in spite of that, so I think it would be reasonable to have both mutual recursion and a mutual induction tactic coexist</p>\n<p>I think it would be nice to be able to declare a mutual theorem though, which generates multiple proof obligations at once. Maybe that's what you were describing, but I'm imagining you would still prove it using a tactic, while at the top level you have multiple definitions instead of a conjoined one. So something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">theorems</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">evenOddInd_even</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">en</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">evenOddInd_odd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Odd</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- there are two goals here named `evenOddInd_even` and `evenOddInd_odd`</span>\n<span class=\"w\">  </span><span class=\"n\">mutual_induction</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">evenOddInd_even</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">evenOddInd_odd</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">on</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>You can't really do the two proofs separately, since invoking induction on <em>one</em> of the inductives requires proving the subcases for <em>all</em> constructors, and you don't want to duplicate that work. I suppose you could chop up the proofs and at the end of the mutual block try to match up all the pieces? But I imagine you could be trying to invoke half of a mutual induction deep in one proof and then trying to complete the other half outside of it with a mismatched context...</p>",
        "id": 504337687,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1741484576
    },
    {
        "content": "<p>What do you think about combining the first few lines into a <code>mutual_induction</code> that does <code>intro</code> and specifies the induction premises?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">evenOddInv</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Odd</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Odd</span><span class=\"w\">  </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">mutual_induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">all_goals</span><span class=\"w\"> </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 504339129,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741485820
    },
    {
        "content": "<p>Yeah, I was thinking of something similar with a <code>theorems</code> command.</p>\n<p>Given the above idea, what do you think of a <code>theorems</code> command that leaves a single tactic goal that's a conjunction of the theorems?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">theorems</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">evenOddInd_even</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">en</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">evenOddInd_odd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Odd</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- there is a single goal `(Even n -&gt; P en) /\\ (Odd n -&gt; Q on)`</span>\n<span class=\"w\">  </span><span class=\"c1\">-- (also `evenOddInd_even (n : Nat) : Even n -&gt; P e n`</span>\n<span class=\"w\">  </span><span class=\"c1\">-- and `evenOddInd_odd (n : Nat) : Odd n -&gt; Q on` can be used recursively)</span>\n<span class=\"w\">  </span><span class=\"n\">mutual_induction</span><span class=\"w\"> </span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">en</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">on</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 504339575,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741486202
    },
    {
        "content": "<p>I like the intro variables to the left of the arrow, that would be handy<br>\nall of my examples do some sort of intros beforehand anyway</p>",
        "id": 504339641,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1741486235
    },
    {
        "content": "<p>I'm not sure about the conjunction<br>\nfor <code>theorems</code>, you might as well just push each declaration as new goals anyway, instead of constructing a conjunction out of all of them, then having the mutual induction tactic immediately break it into two/multiple</p>",
        "id": 504340335,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1741486715
    },
    {
        "content": "<p>This seems to be an unprecedented use of goals though, especially if the main use case of <code>mutual_inductive</code> is to run it after <code>constructor</code> (when in the middle of a proof). Basically, why try to merge contexts if you can start with the fact that the contexts are consistent?</p>",
        "id": 504340903,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741487177
    },
    {
        "content": "<p>the other benefit of entering with two separate goals is that <code>en</code> and <code>on</code> would already be in their local contexts (they probably should be, if they're to the left of the colon), so you wouldn't even need to intro them by putting their names to the left of the arrows</p>",
        "id": 504340924,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1741487196
    },
    {
        "content": "<p>Yeah, that's a nice benefit. The only alternative I can think of is something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">theorems</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">evenOddInd_even</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">en</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">evenOddInd_odd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Odd</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- initialized with mutual induction with targets en and on</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>which isn't the greatest.</p>",
        "id": 504341256,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741487490
    },
    {
        "content": "<p>Do you see any case for custom mutual induction principles? Some sort of <code>mutual_induction ... using ...</code>?</p>",
        "id": 504341315,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741487524
    },
    {
        "content": "<p>All three of the extensions to induction (<code>using</code>, <code>generalizing</code>, <code>with</code>) would probably also be similarly useful for mutual induction, but they're just harder to implement lol<br>\nI currently assume that the motives in each of the recursors are all in the same order and at the very front, and I'm guessing that custom induction principles would be permitted to not do that, which means instantiating each recursor will mean searching through the whole type looking for a match for every motive (not a blocking technical issue. but an annoying one)<br>\nIt would also be pretty messy to add <code>with</code> I think, would that look like <code>mutual_induction h₁ with ..., h₂ with ...</code> or <code>mutual_induction h₁, h₂ with ... | ...</code>? And there's a bunch of syntax manipulation going on in the existing <code>induction</code> tactic when it comes to dealing with <code>with</code> that I don't totally understand<br>\n<code>generalizing</code> would probably be the easiest to implement, although you would need multiple clauses or else it would look kind of weird referring to free variables across contexts, so <code>mutual_induction x₁ y₁ =&gt; h₁ generalizing x₁, x₂ y₂ =&gt; h₂ generalizing x₂</code><br>\nidk if that would be the same RFC or not? it's a lot of features to plan for all at once</p>",
        "id": 504342118,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1741488193
    },
    {
        "content": "<p>Oh if proving conjunctions is more keeping in style than manipulating multiple goals though, I think you might as well just generate a Rocq-style <code>Combined Scheme</code> mutual induction principle, which is probably much easier to implement and far less tactic code to maintain<br>\nThat's basically what my mutual inductives proofs look like at the moment, I manually define a combined recursor and apply that, unification works pretty well at getting the right motive</p>",
        "id": 504343525,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1741489256
    },
    {
        "content": "<p>I should mention that it's likely on my roadmap for the next quarter to find syntax that allows mutual definitions/theorems with a shared body, and a mutual induction tactic that can be used with that. inspired by Isabelle's <code>and</code> in theorem statements a bit. I'll certainly look at the lessons learned here, once I get to it.</p>",
        "id": 504394780,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1741527643
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407610\">@Jonathan Chan</span> I know you've been talking about an RFC; here's my feeling on what would be helpful:</p>\n<ul>\n<li>Keep developing <code>mutual_induction</code> and keep using it. Your GitHub project with examples is great.</li>\n<li>Maybe write a document that you put in the repo that collects the various ways Rocq and other theorem provers you're familiar with can handle mutually inductive theorems.</li>\n</ul>\n<p>I'm speaking for Joachim here, but these would be very useful for Joachim to work out what would be compatible with the Lean FRO roadmap. Then he and/or you together could write the RFC, with the benefit of some experience with prototype implementations.</p>",
        "id": 504420011,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741546068
    },
    {
        "content": "<p>Speaking of command-level syntax, I was wondering if we find something that takes a “bodyless declaration” (<code>def</code>, <code>theorem</code>, sometimes maybe a mix), but otherwise with the syntax unchanged (so that it can have attributes, docstrings etc.) and encloses it, like <code>mutual … end</code> does.</p>\n<p>Maybe <code>joint … by … </code> or (Isabelle-inspired) <code> … and … and … := </code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">joint</span>\n<span class=\"kn\">theorem</span><span class=\"w\">  </span><span class=\"n\">evenOddInd_even</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">en</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">en</span>\n<span class=\"kn\">theorem</span><span class=\"w\">  </span><span class=\"n\">evenOddInd_even</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">on</span>\n<span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- now there are two goals</span>\n<span class=\"n\">mutual_induction</span><span class=\"w\"> </span><span class=\"bp\">…</span><span class=\"w\">  </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">…</span>\n</code></pre></div>\n<p>I currently believe that two goals are better, because the theorem declarations can have different sets of parameters before the <code>:</code>, so the contexts are different, and to put them into a conjunction you’d have to revert them  again.</p>\n<p>There may be applications for such joint definitions independent of mutual induction, so I would not bake the tactic application into the command syntax.</p>",
        "id": 504421657,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1741547272
    },
    {
        "content": "<p>how is this different from <code>mutual theorem</code>?</p>",
        "id": 505452077,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741879301
    },
    {
        "content": "<p><code>induction</code> can recurse.</p>",
        "id": 505452674,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741879433
    },
    {
        "content": "<p>I mean compared to Joachim's <code>joint theorem</code> syntax</p>",
        "id": 505452953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741879482
    },
    {
        "content": "<p>You need all the goals in one place.</p>",
        "id": 505453231,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741879539
    },
    {
        "content": "<p>While I was doing some debugging and figuring out how to handle missing motives, I realized I could use the tactic on nested inductives, but it's not really the right way to do it, so I was thinking about how to get the nested induction principles I really want, and I thought I'd write down some thoughts. (Should this be in a new topic? I'm not sure in what channel it would go...)</p>\n<p>Using rose trees as the running example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">RoseTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RoseTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">RoseTree</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>What I would usually want (which isn't as general as <code>RoseTree.rec</code> I think) is for my RoseTree motive to automatically apply to all elements of the list, so I would define (this is the usual technique, nothing new)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>so that my specialized induction principle is instead</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">RoseTree</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RoseTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hnode</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">RoseTree</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive_2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hnode</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">constructor</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n</code></pre></div>\n<p>but since <code>All</code> just follows the structure of the list and the placement of the parameters, I think it should be possible to <em>automatically generate</em> <code>All</code> for any given inductive and its strictly-positive parameters that are sorts, the same way <code>below</code> is generated, and then you could proof-search for the specialized <code>elim</code> of a nested inductive the same way you do for <code>brecOn</code>.</p>\n<p>Speaking of <code>below</code>, you could also specialize its second motive using <code>All</code>, so that you have something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">RoseTree</span><span class=\"bp\">.</span><span class=\"n\">belowAll</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RoseTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RoseTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">All</span><span class=\"w\"> </span><span class=\"n\">belowAll</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">belowAll</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which lets you prove a strong induction principle for <code>RoseTree</code> that says:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">RoseTree</span><span class=\"bp\">.</span><span class=\"n\">brecOnAll</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RoseTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hnode</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">RoseTree</span><span class=\"bp\">.</span><span class=\"n\">belowAll</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hnode</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">RoseTree</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">constructor</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">constructor</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hnode</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">assumption</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">assumption</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n</code></pre></div>\n<p>I think <code>belowAll</code> should be straightforward to automatically generate just by spotting where all the occurrences of nested induction are and applying the nesting inductive's <code>All</code>there, but I'm not so sure about the proof search for <code>brecOnAll</code>, especially since the way I've proven it involves a second recursor from the nesting inductive (<code>List</code>). I'm also not familiar with how structural recursion gets compiled to <code>brecOn</code>, but it feels to me that intuitively this <code>brecOnAll</code> has the right amount of expressivity for it.</p>\n<p>(Actually I think it would be really neat if Lean implemented what the Deep Induction paper does, but maybe that's a bit overkill...)</p>",
        "id": 508077432,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1742921412
    },
    {
        "content": "<p>And now more of a practical metaprogramming question: Is there a way to do the kind of thing that Lean.Meta.IndPredBelow does as a library instead of directly in the Lean internals? I'd like to avoid having to recompile Lean every time I make a change, and I can imagine you wouldn't want to <em>always</em> generate an <code>All</code> for every single suitable inductive, it would be better to import the functionality as a library to generate it when you need it.</p>",
        "id": 508079138,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1742921851
    },
    {
        "content": "<p>One practical way to run code as a library is to create an attribute. Example usage:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">mk_all</span><span class=\"kd\">]</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">RoseTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RoseTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">RoseTree</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>You don't have to recompile Lean, but you do have to opt in per type.</p>",
        "id": 508079533,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742921942
    },
    {
        "content": "<p>This is pretty common. You can see this with <code>@[ext]</code> and <code>@[mk_iff]</code>.</p>",
        "id": 508079708,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742921984
    },
    {
        "content": "<p><code>@[ext]</code> is even in core. I'm not sure anyone gave the rationale for why it shouldn't always attempt to run. One reason might be that <code>@[ext]</code> lets you name the ext lemma. A more immediate reason is that there's no existing interface to hook the <code>ext</code> code into to have it automatically run.</p>",
        "id": 508080164,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742922090
    },
    {
        "content": "<p>(I think it could be reasonable having an interface to register code to run after definitions are made.)</p>",
        "id": 508080555,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742922188
    },
    {
        "content": "<p>Where's <code>@[ext]</code> implemented? I guess ctrl-click doesn't work attributes</p>",
        "id": 508081690,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1742922483
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod.ext#doc\">docs#Prod.ext</a></p>",
        "id": 508082266,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742922652
    },
    {
        "content": "<p>You can check the imports for the implementation?</p>",
        "id": 508082433,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742922697
    },
    {
        "content": "<p>Found it: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Tactic.Ext.extExtension#doc\">docs#Lean.Elab.Tactic.Ext.extExtension</a></p>",
        "id": 508083056,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742922854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407610\">Jonathan Chan</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/mutual.20induction.20tactic/near/508081690\">said</a>:</p>\n<blockquote>\n<p>Where's <code>@[ext]</code> implemented? I guess ctrl-click doesn't work attributes</p>\n</blockquote>\n<p>It works, but you need to have the corresponding Lean module loaded. Having <code>import Lean</code> should be sufficient, if you don't already have Mathlib imported.</p>",
        "id": 508083516,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742922978
    },
    {
        "content": "<p>Mathlib/Tactic/MkIffOfInductiveProp.lean might be a better example. With <code>@[ext]</code>, it is also maintaining an environment extension, since the <code>ext</code> tactic needs a database of ext lemmas to refer to. I assume <code>@[mk_all]</code> doesn't need to register the <code>All</code> type for a given inductive type.</p>\n<p>With <code>@[mk_iff]</code>, the attribute is simply for running some code.</p>",
        "id": 508084197,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742923152
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/mutual.20induction.20tactic/near/508083516\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"407610\">Jonathan Chan</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/mutual.20induction.20tactic/near/508081690\">said</a>:</p>\n<blockquote>\n<p>Where's <code>@[ext]</code> implemented? I guess ctrl-click doesn't work attributes</p>\n</blockquote>\n<p>It works, but you need to have the corresponding Lean module loaded. Having <code>import Lean</code> should be sufficient, if you don't already have Mathlib imported.</p>\n</blockquote>\n<p>Half the time I want the parser and half the time I want the elaborator. Half the time I don't get what I want.</p>",
        "id": 508084686,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742923276
    },
    {
        "content": "<p>There's also \"go to declaration\", which goes to where you want another half the time.</p>",
        "id": 508085903,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742923608
    },
    {
        "content": "<p>Somehow <code>mk_iff</code> manages to make it only go to uses of the generated iff lemma no matter what you do.</p>",
        "id": 508086041,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742923647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/mutual.20induction.20tactic/near/508085903\">said</a>:</p>\n<blockquote>\n<p>There's also \"go to declaration\", which goes to where you want another half the time.</p>\n</blockquote>\n<p>I think that does the same thing</p>",
        "id": 508087801,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742924103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/mutual.20induction.20tactic/near/508086041\">said</a>:</p>\n<blockquote>\n<p>Somehow <code>mk_iff</code> manages to make it only go to uses of the generated iff lemma no matter what you do.</p>\n</blockquote>\n<p>It uses reference witchcraft (<code>to_additive</code> does it too I think)</p>",
        "id": 508087951,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742924153
    },
    {
        "content": "<p><code>to_additive</code> does it <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/ToAdditive/Frontend.lean#L827\">here</a></p>",
        "id": 508215229,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1742979825
    },
    {
        "content": "<p>I've got a six-way mutual induction example now:<br>\n<a href=\"https://github.com/ionathanch/MutualInduction/blob/main/CBPV/Normal.lean#L151\">https://github.com/ionathanch/MutualInduction/blob/main/CBPV/Normal.lean#L151</a><br>\njoint theorem syntax would be super helpful lol<br>\nthe other consideration is that it's not super convenient doing generalizations on every target before mutual induction, like I end up doing this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">case'</span><span class=\"w\"> </span><span class=\"n\">srcom</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">renameCom</span><span class=\"w\"> </span><span class=\"n\">ξ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">  </span><span class=\"n\">case'</span><span class=\"w\"> </span><span class=\"n\">srval</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">renameVal</span><span class=\"w\"> </span><span class=\"n\">ξ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">  </span><span class=\"n\">case'</span><span class=\"w\"> </span><span class=\"n\">sncom</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">renameCom</span><span class=\"w\"> </span><span class=\"n\">ξ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">snm</span>\n<span class=\"w\">  </span><span class=\"n\">case'</span><span class=\"w\"> </span><span class=\"n\">snval</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">renameVal</span><span class=\"w\"> </span><span class=\"n\">ξ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">snv</span>\n<span class=\"w\">  </span><span class=\"n\">case'</span><span class=\"w\"> </span><span class=\"n\">snecom</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">renameCom</span><span class=\"w\"> </span><span class=\"n\">ξ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">snem</span>\n<span class=\"w\">  </span><span class=\"n\">case'</span><span class=\"w\"> </span><span class=\"n\">sneval</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">renameVal</span><span class=\"w\"> </span><span class=\"n\">ξ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">snev</span>\n<span class=\"w\">  </span><span class=\"n\">mutual_induction</span><span class=\"w\"> </span><span class=\"n\">snev</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">snem</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">snv</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">snm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">ξ</span>\n</code></pre></div>\n<p>and I'm not sure what kind of syntax would be helpful to make that more convenient</p>",
        "id": 511665293,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1744381559
    }
]