[
    {
        "content": "<p>I have the following goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span>\n<span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span>\n<span class=\"n\">na</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FinAcc</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Symbol</span>\n<span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"n\">Symbol</span>\n<span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ωSequence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span>\n<span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">na</span><span class=\"bp\">.</span><span class=\"n\">totalize</span><span class=\"bp\">.</span><span class=\"n\">Run</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ss</span>\n<span class=\"n\">hl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isLeft</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"n\">left</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">na</span><span class=\"bp\">.</span><span class=\"n\">start</span>\n<span class=\"n\">right</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"n\">h</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"n\">this</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">na</span><span class=\"bp\">.</span><span class=\"n\">totalize</span><span class=\"bp\">.</span><span class=\"n\">MTr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">extract</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">na</span><span class=\"bp\">.</span><span class=\"n\">totalize</span><span class=\"bp\">.</span><span class=\"n\">MTr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">extract</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I thought <code>grind</code> should solve it, but <code>grind</code> failed.  In the end I had to use:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span>\n<span class=\"n\">assumption</span>\n</code></pre></div>\n<p>to finish the proof.  Is this a bug in <code>grind</code>?  Note that the consequent follows from the antecedents without needing additional theorems because <code>lnl s = ss 0</code> and <code>ss n = int t</code>.</p>",
        "id": 565476793,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1766790372
    },
    {
        "content": "<p>there might be some defeq abuse is the problem I'm guessing</p>",
        "id": 565477002,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766790703
    },
    {
        "content": "<p>Is <code>ωSequence (State ⊕ Unit)</code> a function type at reducible transparency</p>",
        "id": 565477071,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766790804
    },
    {
        "content": "<p>I would guess the same. This is from CSLib: <a href=\"https://api.cslib.io/docs/Cslib/Foundations/Data/OmegaSequence/Defs.html#Cslib.%CF%89Sequence\">https://api.cslib.io/docs/Cslib/Foundations/Data/OmegaSequence/Defs.html#Cslib.%CF%89Sequence</a></p>",
        "id": 565477195,
        "sender_full_name": "Chris Henson",
        "timestamp": 1766791062
    },
    {
        "content": "<p>In general, I do not expect <code>grind</code> to always succeed in these situations, as my understanding is it will not be using <code>isDefEq</code> in the same way as the <code>assumption</code> tactic.</p>",
        "id": 565477372,
        "sender_full_name": "Chris Henson",
        "timestamp": 1766791384
    },
    {
        "content": "<p>I don't know enough about <code>grind</code> to tell.  But note that the only logical rules needed in the proof is that equal can be substituted for equal.  That is, even if we don't know anything about what the symbols mean, we can still see that this is a valid proof.</p>",
        "id": 565477618,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1766791828
    },
    {
        "content": "<p>In other words, congruence closure alone should be able to solve this goal.  My understanding is that <code>grind</code> can do congruence closure.</p>",
        "id": 565477687,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1766792003
    }
]