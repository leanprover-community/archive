[
    {
        "content": "<p>During the Banff workshop/my porting attempt for <code>congrm</code> I have started writing a list of important definitions for tactic writing, which now turned somewhat into a general introduction to tactic-writing geared towards mathematicians. Anne advised me to put this into the mathlib4-wiki and now it is here: <a href=\"https://github.com/leanprover-community/mathlib4/wiki/Metaprogramming-for-dummies\">https://github.com/leanprover-community/mathlib4/wiki/Metaprogramming-for-dummies</a><br>\nIt is very far from finished, but I will probably not have too much time to work on this until next weekend. Additions and corrections are very welcome. Be careful, I now very little about metaprogramming, so there are probably lots of wrong things already (and more to come).</p>",
        "id": 361645467,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1685221372
    },
    {
        "content": "<p>Suggestion: Some examples with v/s  without Qq</p>",
        "id": 361714881,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1685266993
    },
    {
        "content": "<p>Inspired by this thread, I decided to start writing some examples.  I am learning a little bit of parsing and writing a simple example along the way.  If people think that it could be useful, I can add it to the wiki.  Of course, comments are very welcome!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span> <span class=\"n\">Term</span> <span class=\"n\">Meta</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">This example shows how to take a user input `a` and add to the local context</span>\n<span class=\"cm\">the assumption `[a].length = 1`.</span>\n\n<span class=\"cm\">The underlying principle is that we want to take some user input, embed it</span>\n<span class=\"cm\">into the rich type-system that Lean has and then process it.</span>\n\n<span class=\"cm\">The following line of code, informs Lean that `single_me &lt;something&gt;` is a tactic.</span>\n<span class=\"cm\">It also makes Lean aware that `&lt;something&gt;` is a `term` (or, with all the</span>\n<span class=\"cm\">namespaces, a `Lean.Parser.Category.term`).</span>\n<span class=\"cm\">-/</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"single_me \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Thus, if we are in tactic mode and we write `single_me whatever`, then Lean</span>\n<span class=\"cm\">knows that this is a tactic and that `whatever` is a `term`.</span>\n\n<span class=\"cm\">Let's test this out!</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">single_me</span> <span class=\"n\">whatever</span>  <span class=\"c1\">-- tactic 'tacticSingleMe_' has not been implemented</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Sure, Lean has no idea what the tactic is supposed to do.</span>\n\n<span class=\"cm\">However, if you remove `whatever`, leaving only `singleMe`, then the error</span>\n<span class=\"cm\">message changes to `expected term`: the tactic is not implemented, but Lean</span>\n<span class=\"cm\">knows that it should expect a `term`.</span>\n<span class=\"cm\">If you tried with something else, say `whoKnows`, Lean would have replied with</span>\n<span class=\"cm\">`unknown tactic`.</span>\n\n<span class=\"cm\">Let's implement the `single_me` tactic.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- these are the \"elaboration rules\" for a tactic</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"c1\">-- if Lean finds `single_me [stuff]`, it is going to assign the label `x`</span>\n<span class=\"c1\">-- to [stuff] and it is going to assume that it is a `term`.  This basically</span>\n<span class=\"c1\">-- affects what we can ask Lean to do with `x`.</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">single_me</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"c1\">-- at this point, the tactic state contains ``x: TSyntax `term``:</span>\n  <span class=\"c1\">-- `x` \"entered\" the local context of our tactic development as a</span>\n  <span class=\"c1\">-- \"Typed Syntax\" with `Category` `term`.</span>\n  <span class=\"c1\">-- The next line essentially runs `have : [$x].length = 1 := by simp` in</span>\n  <span class=\"c1\">-- the local context of where our tactic will be called.</span>\n  <span class=\"n\">evalTactic</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">))</span>\n  <span class=\"c1\">-- Note that we are using `$x` to refer to the \"quoted\" variable `x`.</span>\n  <span class=\"c1\">-- This is \"our\" input: we are going to type it in tactic mode, Lean</span>\n  <span class=\"c1\">-- parses it and performs actions with it.</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">single_me</span> <span class=\"mi\">0</span>  <span class=\"c1\">-- local context now contains `this: List.length [0] = 1`!</span>\n  <span class=\"n\">trivial</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">Great!  We managed to add to the local context the hypothesis that the</span>\n<span class=\"cm\">list consisting of `0` has length 1.</span>\n\n<span class=\"cm\">In a similar vein, here are more examples of our new tactic:</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">single_me</span> <span class=\"n\">a</span>\n  <span class=\"c1\">-- local context now contains `this: List.length [a] = 1`</span>\n  <span class=\"n\">single_me</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n  <span class=\"c1\">-- local context now contains `this: List.length [1 + 2] = 1`</span>\n  <span class=\"n\">single_me</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span>\n  <span class=\"c1\">-- local context now contains `this: List.length [a + b] = 1`</span>\n  <span class=\"n\">single_me</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- local context now contains `this: List.length [[a]] = 1`</span>\n  <span class=\"n\">single_me</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n  <span class=\"c1\">-- local context now contains `this: List.length [∀ x : Int, x + 5 = 0] = 1`</span>\n  <span class=\"n\">trivial</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">As you can see, the `term` Category is fairly flexible: basically, anything</span>\n<span class=\"cm\">that looks like an `Expr`ession will be allowed.</span>\n\n<span class=\"cm\">If we had used `ident` instead of `term`, then we would have been allowed</span>\n<span class=\"cm\">to use \"identifiers\", essentially the variables in our context.  If we did</span>\n<span class=\"cm\">that, then in the final example `single_me a` would have worked, but</span>\n<span class=\"cm\">nothing else would have.</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 364621484,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1686242272
    }
]