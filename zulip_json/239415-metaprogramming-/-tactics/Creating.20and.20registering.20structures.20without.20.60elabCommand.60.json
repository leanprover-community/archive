[
    {
        "content": "<p>Is there any way, ideally without resorting to implementing the compiler logic from <a href=\"https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Structure.lean#L1506-L1570\">https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Structure.lean#L1506-L1570</a> myself, of generating structures (with parents/subobjects) and all their associated functions like projections (including to the field of its transitive parents) from an array of fields of type <code>Array (Name × Expr)</code>?<br>\nI am not sure if I simply missed a couple of functions which would do all that or not.<br>\nCalling <code>elabCommand</code> on raw syntax is not really doable in my case (at least I don't think) since I am already managing <code>Expr</code>s, not <code>Term</code>s.</p>",
        "id": 564450555,
        "sender_full_name": "Ghilain Bergeron",
        "timestamp": 1766061949
    },
    {
        "content": "<p>At the end this uses publicly accessible meta functions so here's kinda what calling them directly looks like (no guarantee that it's complete though):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"n\">run_meta</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Level</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">param</span><span class=\"w\"> </span><span class=\"ss\">`u</span>\n<span class=\"w\">  </span><span class=\"n\">withLocalDeclQ</span><span class=\"w\"> </span><span class=\"ss\">`α</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">implicit</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">withLocalDeclDQ</span><span class=\"w\"> </span><span class=\"ss\">`thing</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">thing</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">withLocalDeclDQ</span><span class=\"w\"> </span><span class=\"ss\">`foo</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">withLocalDeclDQ</span><span class=\"w\"> </span><span class=\"ss\">`bar</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">typeName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"ss\">`Test</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">typeName</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">projNames</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"ss\">`thing</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`foo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"ss\">`bar</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">thing</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"o\">]</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ctor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Constructor</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">typeName</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"ss\">`mk</span>\n<span class=\"w\">    </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkForallFVars</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">indType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">InductiveType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">typeName</span>\n<span class=\"w\">    </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkForallFVars</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">ctors</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ctor</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">addDecl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inductDecl</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`u</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">indType</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- see mkAuxConstructions in Lean.Elab.MutualInductive</span>\n<span class=\"w\">  </span><span class=\"n\">mkRecOn</span><span class=\"w\"> </span><span class=\"n\">typeName</span>\n<span class=\"w\">  </span><span class=\"n\">mkCasesOn</span><span class=\"w\"> </span><span class=\"n\">typeName</span>\n<span class=\"w\">  </span><span class=\"n\">mkCtorElim</span><span class=\"w\"> </span><span class=\"n\">typeName</span>\n<span class=\"w\">  </span><span class=\"n\">mkNoConfusion</span><span class=\"w\"> </span><span class=\"n\">typeName</span>\n\n<span class=\"w\">  </span><span class=\"n\">mkProjections</span><span class=\"w\"> </span><span class=\"n\">typeName</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">projNames</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">missing</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">projName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">typeName</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">})</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">instImplicit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- true for classes</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- this is \"simple\" here because we don't have extends</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">flatCtorType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ctor</span><span class=\"bp\">.</span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">flatCtorValue</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkAppN</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">ctor</span><span class=\"bp\">.</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">addDecl</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Declaration</span><span class=\"bp\">.</span><span class=\"n\">defnDecl</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkFlatCtorOfStructCtorName</span><span class=\"w\"> </span><span class=\"n\">ctor</span><span class=\"bp\">.</span><span class=\"n\">name</span>\n<span class=\"w\">    </span><span class=\"n\">levelParams</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"ss\">`u</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">flatCtorType</span>\n<span class=\"w\">    </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">flatCtorValue</span>\n<span class=\"w\">    </span><span class=\"n\">hints</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"kn\">abbrev</span>\n<span class=\"w\">    </span><span class=\"n\">safety</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">safe</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n\n<span class=\"w\">  </span><span class=\"n\">modifyEnv</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">registerStructure</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">structName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">typeName</span>\n<span class=\"w\">    </span><span class=\"n\">fields</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">projNames</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">      </span><span class=\"n\">fieldName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">      </span><span class=\"n\">projFn</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">typeName</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">      </span><span class=\"n\">subobject?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"c1\">-- would be some for parent projections</span>\n<span class=\"w\">      </span><span class=\"n\">binderInfo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">default</span>\n<span class=\"w\">    </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">Test</span>\n</code></pre></div>\n<p>This is certainly not ideal though, it'd be nice if there were helper functions to make this process easier (and also make it rely less on implementation details).</p>",
        "id": 564586183,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1766100628
    },
    {
        "content": "<p>This is what I kind of already have yes, although in my case I have to handle parent structures as well (not as subobjects though).<br>\nThe logic used in <code>Lean.Elab.Command.Structure.elabStructureCommand</code> unfortunately is too coupled with the syntax itself (although with a lot less checks), and I am just reimplementing the logic itself, which as you said is less than ideal and I believe barely maintainable.</p>",
        "id": 564650093,
        "sender_full_name": "Ghilain Bergeron",
        "timestamp": 1766135801
    }
]