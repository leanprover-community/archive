[
    {
        "content": "<p>Is it possible for the <code>mvarIdPending</code> of a delayed assigned mvar be itself delayed assigned? I looked through the code of <code>instantiateMVars</code> and there does not seem to be any handling of this.</p>",
        "id": 567927436,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1768379979
    },
    {
        "content": "<p>I ran some fuzzing tests and it seems like this is possible</p>",
        "id": 568072599,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1768421961
    },
    {
        "content": "<p>Also, it seems like a mvar can be simultaneously assigned and delayed assigned, or delayed assignments could create a cycle, or mvar's eAssignment or dAssignment can change over time.</p>\n<p>This happens when there are lots of <code>revert</code> and <code>intro</code> calls</p>",
        "id": 568079687,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1768424543
    },
    {
        "content": "<p>Is there any guarantee that once a mvar is assigned it would not change? Or maybe this can be enforced at runtime?</p>",
        "id": 568093683,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1768430582
    },
    {
        "content": "<blockquote>\n<p>Is it possible for the <code>mvarIdPending</code> of a delayed assigned mvar be itself delayed assigned?</p>\n</blockquote>\n<p>I think yes; otherwise I don't see the point in functions like <code>getDelayedMVarRoot</code>.</p>\n<blockquote>\n<p>I looked through the code of <code>instantiateMVars</code> and there does not seem to be any handling of this.</p>\n</blockquote>\n<p>Indeed puzzling. Maybe open an issue with a clear reproduction instruction? That is, give meta code that does something like</p>\n<ol>\n<li>Create a synth opaque MVar <code>?m</code> in a context where <code>x</code> is in scope</li>\n<li>Create a synth opaque MVar <code>?n</code> in a context where <code>x</code> and <code>y</code> are in scope</li>\n<li>Abstract <code>?n</code> over <code>y</code> (do <code>mkForallFVars</code> or something linke that); store as <code>e1</code> (<code>e1</code> will be of the form <code>?n' y</code>, where <code>?n'</code> is delayed assigned to <code>fun y =&gt; ?n</code>.)</li>\n<li>Abstract <code>?m</code> over <code>x</code>. Store abstraction of <code>?m</code> as <code>e2</code> (<code>e2</code> will be of the form <code>?m' x</code>, where <code>?m'</code> is delayed assigned to <code>fun x =&gt; ?m</code>.)</li>\n<li>assign <code>?m</code> to <code>e1</code></li>\n<li>assign some inhabitant to <code>?n</code>, for example <code>() : Unit</code> or <code>y</code>.</li>\n<li>instantiate MVars at <code>e2</code></li>\n</ol>\n<p>Then if you don't see a fully ground expression, instantiate MVars did the wrong thing.</p>\n<blockquote>\n<p>Also, it seems like a mvar can be simultaneously assigned and delayed assigned, or delayed assignments could create a cycle, or mvar's eAssignment or dAssignment can change over time.</p>\n</blockquote>\n<p>Regular assignments take precedence over delayed assignments. Also of course there can be cycles when using <code>MVarId.assign</code> directly; it's an unchecked API. Maybe use <code>checkAssign</code> or <code>withAssignableSyntheticOpaque &lt;| isDefEq . .</code>.</p>\n<blockquote>\n<p>Is there any guarantee that once a mvar is assigned it would not change? Or maybe this can be enforced at runtime?</p>\n</blockquote>\n<p>Not if you use <code>assign</code> directly. At least <code>intro</code> checks whether the MVar in question has already been assigned.</p>",
        "id": 568138177,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1768461740
    },
    {
        "content": "<p>I don't know how I can construct a case where there's m1 delayed assigned to m2 delayed assigned to m3. Maybe something via <code>revert</code> would work? I'll try your test sequence.</p>\n<p>In <code>instantiate_mvars.cpp</code>, there is this condition gating the pending of a delayed assigned mvar:</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"w\">            </span><span class=\"n\">optional</span><span class=\"o\">&lt;</span><span class=\"n\">expr</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">get_assignment</span><span class=\"p\">(</span><span class=\"n\">mid_pending</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">val</span><span class=\"p\">)</span>\n<span class=\"w\">                </span><span class=\"c1\">// mid_pending has not been assigned yet.</span>\n<span class=\"w\">                </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">visit_mvar_app_args</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>so what would happen to nested mvars here? One hypothesis is that a delayed assigned mvar can later get e-assigned.</p>",
        "id": 568151232,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1768467165
    },
    {
        "content": "<blockquote>\n<p>I don't know how I can construct a case where there's m1 delayed assigned to m2 delayed assigned to m3.</p>\n</blockquote>\n<p>I edited my idea above with a few more details. Does that help?</p>",
        "id": 568180754,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1768475456
    },
    {
        "content": "<p><code>e1</code> is not a mvar, so what do you mean by assign <code>?m</code> to <code>e1</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">sentence</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">forallBoundedTelescope</span><span class=\"w\"> </span><span class=\"n\">sentence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">maxFVars?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">fvars</span><span class=\"w\"> </span><span class=\"n\">target</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fvars</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">unreachable!</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mTarget</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span><span class=\"n\">Unit</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">mkFreshExprSyntheticOpaqueMVar</span><span class=\"w\"> </span><span class=\"n\">mTarget</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e2</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">mkForallFVars</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">    </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">forallBoundedTelescope</span><span class=\"w\"> </span><span class=\"n\">target</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">maxFVars?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">fvars</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">target'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fvars</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">unreachable!</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">nTarget</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span><span class=\"n\">Unit</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">mkFreshExprSyntheticOpaqueMVar</span><span class=\"w\"> </span><span class=\"n\">nTarget</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e1</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">mkForallFVars</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>",
        "id": 568295688,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1768505358
    },
    {
        "content": "<p>Here's what I had in mind:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">mvars</span><span class=\"bp\">.</span><span class=\"n\">delayed</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mkType</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">dm</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">withLocalDeclD</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprSyntheticOpaqueMVar</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"ss\">`m</span>\n<span class=\"w\">    </span><span class=\"n\">withLocalDeclD</span><span class=\"w\"> </span><span class=\"ss\">`y</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprSyntheticOpaqueMVar</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"ss\">`n</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">dn</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">dm</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">      </span><span class=\"c1\">-- Note that `m!\"\"` does `instantiateMVars` internally and instantiate `n`</span>\n<span class=\"w\">      </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"m: {m}, n: {n}, dm: {dm}, dn: {dn}\"</span>\n<span class=\"w\">      </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">mvarId!</span><span class=\"bp\">.</span><span class=\"n\">withContext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">mvarId!</span><span class=\"bp\">.</span><span class=\"n\">assign</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dn</span><span class=\"bp\">.</span><span class=\"n\">beta</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mkNatLit</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]))</span>\n<span class=\"w\">      </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"m: {m}, n: {n}, dm: {dm}, dn: {dn}\"</span>\n<span class=\"w\">      </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">mvarId!</span><span class=\"bp\">.</span><span class=\"n\">withContext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">mvarId!</span><span class=\"bp\">.</span><span class=\"n\">assign</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkNatLit</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"m: {m}, n: {n}, dm: {dm}, dn: {dn}\"</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">dm</span>\n<span class=\"w\">  </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">dm</span>\n</code></pre></div>\n<p>Note that after the second assignment, we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">3</span><span class=\"w\"> </span><span class=\"bp\">|-</span><span class=\"n\">dAss</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">|-</span><span class=\"n\">eAss</span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">4</span><span class=\"w\"> </span><span class=\"bp\">|-</span><span class=\"n\">dAss</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">]</span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|-</span><span class=\"n\">eAss</span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"mi\">42</span>\n</code></pre></div>\n<p>And this would be a chain of delayed assignments if <code>?m</code> was instantiated to its assignment <code>?m.4 0</code>. But it isn't, so this is not really a reproducer.</p>\n<p>I suppose you could reproduce by using <code>delayedAssign</code>, but that's playing fast and loose with the invariants about delayed assignment. Note that <code>MkBinding.elimMVar</code> (called by <code>abstractM</code>, <code>mkLambdaFVars</code>, etc.) is careful not to introduce a chain of delayed assignments:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">        </span><span class=\"c\">/-</span><span class=\"cm\"> If `mvarId` is the lhs of a delayed assignment `?m #[x_1, ... x_n] := ?mvarPending`,</span>\n<span class=\"cm\">           then `nestedFVars` is `#[x_1, ..., x_n]`.</span>\n<span class=\"cm\">           In this case, `newMVarId` is also `syntheticOpaque` and we add the delayed assignment delayed assignment</span>\n<span class=\"cm\">           ```</span>\n<span class=\"cm\">           ?newMVar #[y_1, ..., y_m, x_1, ... x_n] := ?m</span>\n<span class=\"cm\">           ```</span>\n<span class=\"cm\">           where `#[y_1, ..., y_m]` is `toRevert` after `collectForwardDeps`.</span>\n<span class=\"cm\">        -/</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mvarIdPending</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nestedFVars</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getDelayedMVarAssignment?</span><span class=\"w\"> </span><span class=\"n\">mvarId</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mvarId</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[])</span>\n<span class=\"w\">          </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">fvars</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mvarIdPending</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mvarIdPending</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fvars</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"n\">assignDelayedMVar</span><span class=\"w\"> </span><span class=\"n\">newMVarId</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toRevert</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">nestedFVars</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">mvarIdPending</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkAppN</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toRevert</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>So maybe the correct answer to</p>\n<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Nested.20Delayed.20Assigned.20Metavariable/near/567927436\">said</a>:</p>\n<blockquote>\n<p>Is it possible for the <code>mvarIdPending</code> of a delayed assigned mvar be itself delayed assigned?</p>\n</blockquote>\n<p>is: existing APIs should not create delayed assignment chains.</p>",
        "id": 568386725,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1768554376
    },
    {
        "content": "<p>I see, so chains of delayed assigned mvars should be treated as bugs.</p>",
        "id": 568540651,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1768607180
    },
    {
        "content": "<p>I cannot answer this, as I haven't written the code. At least it seems that chains of delayed assigned mvars are not completely instantiated by <code>instantiateMVars</code>, but it also has some gotchas wrt. delayed assignments in general.</p>",
        "id": 568740126,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1768809721
    }
]