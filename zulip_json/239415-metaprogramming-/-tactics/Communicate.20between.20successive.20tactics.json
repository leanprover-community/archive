[
    {
        "content": "<p>What is the best way to transfer data between two different tactic calls? More specifically, I want to make two tactics <code>A</code> and <code>B</code> such that <code>A</code> creates some metavariables, and then <code>B</code> retrieves those metavariables and do things with them, possibly with many tactics invocation in between. I suppose I could use tags to find them back, but that seems like a hacky solution (and I'm not actually sure it even works)</p>",
        "id": 324022724,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1674818355
    },
    {
        "content": "<p>You could maybe store the mvars as types of hidden hypotheses in the context. What's the specific use case? (Also, Lean 3 or 4?)</p>",
        "id": 324031030,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1674820816
    },
    {
        "content": "<p>It’s for Lean 4. I am thinking about making a version of <code>filter_upwards</code> that is more flexible in that you don’t have to provide all hypotheses you want to make (as in \"we can assume this and this and that because these are all true in a neighborhood of <code>x_0</code>\") all at once, and you can instead add them incrementally, which makes it more intuitive</p>",
        "id": 324032273,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1674821212
    },
    {
        "content": "<p>And the way I want to do that is by having metavariables for the list of assumptions made, that I can partially instantiate when the user makes a new assumption, and eventually instantiate the remaining one with <code>true</code> when we no longer have assumptions to make</p>",
        "id": 324032886,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1674821402
    },
    {
        "content": "<p>Maybe you could have some special kind of tactic block that keeps track of a certain list of goal metavariables? Like perhaps your <code>filter_upwards</code> has syntax that allows any number of tactics to follow it (along with, possibly, one last thing for finally filling in these lingering goals)</p>",
        "id": 324033593,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674821607
    },
    {
        "content": "<p>Here is an example I did \"by hand\" in Lean3 (so it looks very messy). Each \"block\" in this proof should become one tactic call, and ideally I'd use metavariables instead of goals so that this is not too frightening for the user.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">filter</span> <span class=\"n\">function</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hpq</span> <span class=\"o\">:</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hqr</span> <span class=\"o\">:</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">_U</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">_hU</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">_U</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">_key</span> <span class=\"o\">:</span> <span class=\"n\">foldr</span> <span class=\"o\">(</span><span class=\"bp\">∩</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">_U</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">@</span><span class=\"n\">foldr_rec_on</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">_U</span> <span class=\"o\">(</span><span class=\"bp\">∩</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">univ_mem</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">inter_mem</span> <span class=\"o\">(</span><span class=\"n\">_hU</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">)</span> <span class=\"n\">hs</span><span class=\"o\">),</span>\n  <span class=\"n\">refine</span> <span class=\"n\">mem_of_superset</span> <span class=\"n\">_key</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">_hx</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_set_of</span><span class=\"o\">],</span>\n\n  <span class=\"n\">work_on_goal</span> <span class=\"mi\">3</span> <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">set_of</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">::</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n  <span class=\"n\">work_on_goal</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">forall_mem_cons.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">hqr</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">foldr_cons</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">_hx</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">_hx</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">hqrx</span><span class=\"o\">,</span> <span class=\"n\">_hx</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_set_of</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hqrx</span><span class=\"o\">,</span>\n\n  <span class=\"n\">apply</span> <span class=\"n\">hqrx</span><span class=\"o\">,</span>\n\n  <span class=\"n\">work_on_goal</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">set_of</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">::</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n  <span class=\"n\">work_on_goal</span> <span class=\"mi\">3</span> <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">forall_mem_cons.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">hpq</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">foldr_cons</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">_hx</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">_hx</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">hpqx</span><span class=\"o\">,</span> <span class=\"n\">_hx</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_set_of</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hpqx</span><span class=\"o\">,</span>\n\n  <span class=\"n\">apply</span> <span class=\"n\">hpqx</span><span class=\"o\">,</span>\n\n  <span class=\"n\">work_on_goal</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">set_of</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n  <span class=\"n\">work_on_goal</span> <span class=\"mi\">3</span> <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">forall_mem_cons.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">foldr_cons</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">_hx</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">_hx</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">hpx</span><span class=\"o\">,</span> <span class=\"n\">_hx</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_set_of</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hpx</span><span class=\"o\">,</span>\n\n  <span class=\"n\">exact</span> <span class=\"n\">hpx</span><span class=\"o\">,</span>\n\n  <span class=\"n\">exact</span> <span class=\"n\">nil</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">forall_mem_nil</span> <span class=\"n\">_</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 324033600,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1674821609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Communicate.20between.20successive.20tactics/near/324033593\">said</a>:</p>\n<blockquote>\n<p>Maybe you could have some special kind of tactic block that keeps track of a certain list of goal metavariables? Like perhaps your <code>filter_upwards</code> has syntax that allows any number of tactics to follow it (along with, possibly, one last thing for finally filling in these lingering goals)</p>\n</blockquote>\n<p>Oh I didn't think about doing that as one syntax for everything, that could probably work</p>",
        "id": 324034035,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1674821717
    }
]