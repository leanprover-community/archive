[
    {
        "content": "<p>The documentation for <code>guard_target =â‚›</code> states that it compares the two expressions \"syntactically\". There is another mode, <code>=â‚</code> which works up to alpha-equivalence. Thus I would expect the following to fail, but it succeeds. Is this a bug?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">guard_target</span><span class=\"w\"> </span><span class=\"bp\">=â‚›</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 503675712,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1741226657
    },
    {
        "content": "<p>The syntactic equality mode uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr.instBEq#doc\">docs#Lean.Expr.instBEq</a>, which does the same thing as the alpha-equivalence mode...</p>",
        "id": 503678775,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741228494
    },
    {
        "content": "<p>Likely, what was meant is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr.equal#doc\">docs#Lean.Expr.equal</a></p>",
        "id": 503679483,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741228936
    },
    {
        "content": "<p>The code is in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Tactic.GuardExpr.MatchKind.isEq#doc\">docs#Lean.Elab.Tactic.GuardExpr.MatchKind.isEq</a></p>",
        "id": 503679572,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741229022
    },
    {
        "content": "<p>Hmm, the docstring on <code>MatchKind.syntactic</code> goes: \"A syntactic match means that the <code>Expr</code>s are <code>==</code> after stripping <code>MData</code>\". So maybe it was intended that this removes mdata and then checks alpha-equivalence?</p>",
        "id": 503679842,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1741229178
    },
    {
        "content": "<p><del><code>==</code> already strips metadata</del> misread the docstring</p>",
        "id": 503680070,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741229353
    },
    {
        "content": "<p>Here's what the docstring for <code>guard_target</code> says</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>Tactic to check that the target agrees with a given expression.\n\nguard_target = e checks that the target is defeq at reducible transparency to e.\nguard_target =~ e checks that the target is defeq at default transparency to e.\nguard_target =â‚› e checks that the target is syntactically equal to e.\nguard_target =â‚ e checks that the target is alpha-equivalent to e.\nThe term e is elaborated with the type of the goal as the expected type, which is mostly useful within conv mode.\n</code></pre></div>",
        "id": 503680115,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741229399
    },
    {
        "content": "<p><code>guard_expr</code> and <code>guard_hyp</code> both seem to agree</p>",
        "id": 503680194,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741229441
    },
    {
        "content": "<p>So one of these docstrings is wrong</p>",
        "id": 503680230,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741229466
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/.60guard_target.60.20in.20syntactic.20mode/near/503680070\">said</a>:</p>\n<blockquote>\n<p><code>==</code> already strips metadata</p>\n</blockquote>\n<p>Mm are you sure? <a href=\"https://github.com/leanprover/lean4/blob/7a8c8a4fb3fbcd0ae947db3e99bcc05e61ad2da3/src/kernel/expr_eq_fn.cpp#L88\">Here's the code</a>. It seems the only difference between <code>equal</code> and <code>eqv</code> is whether they account for binder info.</p>",
        "id": 503680244,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1741229482
    },
    {
        "content": "<p>So I don't think the two <code>guard_target</code> modes do <em>exactly</em> the same thing; but I think having access to <code>Expr.equal</code> would still be much more useful.</p>",
        "id": 503680644,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1741229755
    },
    {
        "content": "<p>Hm, I'm not so sure using <code>Expr.equal</code> here is useful anymore. The problem is that it is <em>super</em> strict, including checking (non-user-visible) binder annotations on non-dependent arrows. So in practice when my goal is <code>âˆ€ (p q : Prop), p âˆ§ q â†’ q âˆ§ p</code>, <code>guard_target =â‚› âˆ€ (p q : Prop), p âˆ§ q â†’ q âˆ§ p</code> (using <code>Expr.equal</code>) fails because some invisible binder info is different.</p>",
        "id": 503683210,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1741231226
    },
    {
        "content": "<p>There was recently a discussion about this, here's the last thread: <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/Really.20strict.20guard_hyp/near/491412676\">#lean4 &gt; Really strict guard_hyp @ ğŸ’¬</a> </p>\n<p>I forgot that I had a PR in progress trying to address this (<a href=\"https://github.com/leanprover/lean4/pull/6483\">lean4#6483</a> -- edited, thanks damiano)</p>",
        "id": 503690080,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741235142
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/6483\">lean4#6483</a></p>",
        "id": 503690390,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741235265
    }
]