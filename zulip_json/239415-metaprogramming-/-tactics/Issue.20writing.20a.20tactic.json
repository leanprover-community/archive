[
    {
        "content": "<p>I noticed that the <code>inhabit</code> tactic uses <code>Classical.choice</code> even if the goal is a <code>Prop</code> (I would think we can just use <code>Nonempty.elim</code>?). This seemed weird to me since the tactic already attempts to avoid classical reasoning if the target is a <code>Prop</code>. I noticed this because <code>unique_iff_subsingleton_and_nonempty</code> relies on <code>Classical.choice</code>, which doesn't seem necessary (I was checking this because I wanted to understand the principle of unique choice better). I tried to modify the tactic to avoid <code>choice</code> if the goal is a <code>Prop</code>, but I'm not very familiar with metaprogramming (especially in Lean 4) and now I'm getting the error \"(kernel) declaration has metavariables 'unique_iff_subsingleton_and_nonempty'\"  when I try and define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">unique_iff_subsingleton_and_nonempty</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">Unique</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">Subsingleton</span> <span class=\"n\">α</span> <span class=\"bp\">∧</span> <span class=\"n\">Nonempty</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">inferInstance</span><span class=\"o\">,</span>\n   <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">inhabit</span> <span class=\"n\">α</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">Unique.mk'</span> <span class=\"n\">α</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>My modified version of the inhabit tactic is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">nonempty_elim_to_inhabited</span>\n  <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α_nonempty</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n  <span class=\"n\">α_nonempty.elim</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">Inhabited.mk</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">evalInhabit</span> <span class=\"o\">(</span><span class=\"n\">goal</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_name</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Ident</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TacticM</span> <span class=\"n\">MVarId</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">goal.withContext</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">Tactic.elabTerm</span> <span class=\"n\">term</span> <span class=\"n\">none</span>\n    <span class=\"k\">let</span> <span class=\"n\">e_lvl</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.getLevel</span> <span class=\"n\">e</span>\n    <span class=\"k\">let</span> <span class=\"n\">inhabited_e</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Inhabited</span> <span class=\"o\">[</span><span class=\"n\">e_lvl</span><span class=\"o\">])</span> <span class=\"n\">e</span>\n    <span class=\"k\">let</span> <span class=\"n\">nonempty_e</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Nonempty</span> <span class=\"o\">[</span><span class=\"n\">e_lvl</span><span class=\"o\">])</span> <span class=\"n\">e</span>\n    <span class=\"k\">let</span> <span class=\"n\">nonempty_e_pf</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstance</span> <span class=\"n\">nonempty_e</span>\n    <span class=\"k\">let</span> <span class=\"n\">h_name</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"o\">:=</span>\n      <span class=\"k\">match</span> <span class=\"n\">h_name</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">h_name</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h_name.getId</span>\n      <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"n\">inhabited_h</span>\n<span class=\"c1\">-- start of new code</span>\n    <span class=\"k\">let</span> <span class=\"n\">e_isprop</span> <span class=\"bp\">←</span> <span class=\"n\">isProp</span> <span class=\"n\">e</span>\n    <span class=\"k\">let</span> <span class=\"n\">g_type</span> <span class=\"bp\">←</span> <span class=\"n\">getMainTarget</span>\n    <span class=\"k\">let</span> <span class=\"n\">g_isprop</span> <span class=\"bp\">←</span> <span class=\"n\">isProp</span> <span class=\"n\">g_type</span>\n    <span class=\"k\">let</span> <span class=\"n\">inhab_imp_g_type</span> <span class=\"o\">:=</span> <span class=\"n\">Expr.forallE</span> <span class=\"bp\">`</span><span class=\"n\">a</span> <span class=\"n\">inhabited_e</span> <span class=\"n\">g_type</span> <span class=\"bp\">.</span><span class=\"n\">default</span>\n    <span class=\"k\">if</span> <span class=\"n\">g_isprop</span>\n    <span class=\"k\">then</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">temp</span>\n      <span class=\"k\">let</span> <span class=\"n\">pf</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"n\">inhab_imp_g_type</span> <span class=\"n\">MetavarKind.syntheticOpaque</span> <span class=\"n\">n</span>\n      <span class=\"k\">let</span> <span class=\"n\">pf'</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">nonempty_elim_to_inhabited</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">nonempty_e_pf</span><span class=\"o\">,</span> <span class=\"n\">pf</span><span class=\"o\">]</span>\n      <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">goal.assert</span> <span class=\"n\">h_name</span> <span class=\"n\">inhabited_e</span> <span class=\"n\">pf'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">intro1P</span>\n      <span class=\"n\">return</span> <span class=\"n\">r</span>\n    <span class=\"k\">else</span>\n<span class=\"c1\">-- end of new code</span>\n      <span class=\"k\">let</span> <span class=\"n\">pf</span> <span class=\"bp\">←</span>\n        <span class=\"k\">if</span> <span class=\"n\">e_isprop</span>\n        <span class=\"k\">then</span> <span class=\"n\">Meta.mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">nonempty_prop_to_inhabited</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">nonempty_e_pf</span><span class=\"o\">]</span>\n        <span class=\"k\">else</span> <span class=\"n\">Meta.mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">nonempty_to_inhabited</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">nonempty_e_pf</span><span class=\"o\">]</span>\n      <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">goal.assert</span> <span class=\"n\">h_name</span> <span class=\"n\">inhabited_e</span> <span class=\"n\">pf</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">intro1P</span>\n      <span class=\"n\">return</span> <span class=\"n\">r</span>\n</code></pre></div>",
        "id": 400311976,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1699115327
    },
    {
        "content": "<p><del><code>unique_iff_subsingleton_and_nonempty</code> needs choice because <code>subsingleton</code> and <code>nonempty</code> live in the Prop universe, and <code>unique</code> lives in the Type universe, and the axiom of choice is precisely Lean's route from the Prop universe to the Type universe.</del> Having looked at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=unique_iff_subsingleton_and_nonempty#doc\">docs#unique_iff_subsingleton_and_nonempty</a> I see that the unique part doesn't live in Type so my claim is incorrect!</p>",
        "id": 400312114,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1699115454
    },
    {
        "content": "<p>But the left hand side of <code>unique_iff_subsingleton_and_nonempty</code> is <code>Nonempty (Unique α)</code> which does live in <code>Prop</code></p>",
        "id": 400312221,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699115572
    },
    {
        "content": "<p>For reference, here's a modified version of <code>unique_iff_subsingleton_and_nonempty</code> that doesn't depend on choice or the inhabit tactic</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">unique_iff_subsingleton_and_nonempty</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">Unique</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">Subsingleton</span> <span class=\"n\">α</span> <span class=\"bp\">∧</span> <span class=\"n\">Nonempty</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n    <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">inferInstance</span><span class=\"o\">,</span>\n   <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">induction</span> <span class=\"n\">hn</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">uniqueOfSubsingleton</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 400312366,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1699115758
    },
    {
        "content": "<p>yeah I've just proved it too. But why do you care about any of this? Mathlib is a classical library. I'm sure there are many uses of classical axioms which are unnecessary.</p>",
        "id": 400312475,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1699115871
    },
    {
        "content": "<p>Why does the inhabit tactic avoid using classical.choice at all?</p>",
        "id": 400312528,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1699115906
    },
    {
        "content": "<p>I guess that's a question for whoever wrote that specific tactic?</p>",
        "id": 400312683,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1699116066
    },
    {
        "content": "<p>To answer your question directly, I wanted to work out some stuff about anafunctors without rebuilding a ton of basic definitions of category theory. Afaict apart from the choices of limits/colimits or choosing an inverse to an equivalence, most of the category theory implemented in mathlib already doesn't rely on classical reasoning. Reimplementing all that would be a pain and I would prefer to work with an existing codebase</p>",
        "id": 400312713,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1699116105
    }
]