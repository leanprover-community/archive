[
    {
        "content": "<p>After talking with ATP people, I was curious if / how it would be possible to implement perfect sharing (also known as hash-consing) in Lean. perfect sharing means that we have some inductive type <code>T</code> (representing some kind of terms), however it is implemented so that</p>\n<ol>\n<li>every time a constructor of <code>T</code> is called, it does a lookup into a global hash-table if such object has been already constructed, and if it was, it outputs the cached value</li>\n<li>equality check is done purely by pointer-equality</li>\n<li>whenever we index with an element of <code>T</code> in a hash-table, we use the raw pointer of <code>T</code> as the hash</li>\n<li>(bonus) the global hash table is a value-weak in the sense that it does not increase reference count for the object, but automatically removes an item if the value has been released from memory</li>\n</ol>\n<p>If I understand correctly, many of these steps would have to be done as <code>unsafe</code>, especially hashing with a pointer value, right? On the other hand, I don't think we could get inconsistency from pointer equality as equality decision procedure under such setup.</p>",
        "id": 574955209,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1771598116
    },
    {
        "content": "<p>This has existed for a long time in the form of the <code>shareCommon</code> function and related things and is routinely used in high performance meta programs such as grind or bv_decide developed by the FRO.</p>",
        "id": 574956199,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1771598352
    },
    {
        "content": "<p>Is there a documentation / basic example of how this is used?</p>",
        "id": 574956920,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1771598549
    },
    {
        "content": "<p>If you just want to take an object graph and share it you call <code>shareCommon</code>. If you want to build a framework where you keep accumulating shared terms you use the <code>ShareCommonT</code> monad transformer on top of whatever monad you are working in for your framework and share through their associated functions. Once you are operating on shared terms you can use (unsafe) functions like <code>ptrEq</code> to compare things. <code>SymM</code>/<code>GrindM</code> are probably the prime users of this API at the moment.</p>",
        "id": 574957861,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1771598790
    },
    {
        "content": "<p>So the idea is that inside that monad, I would call a standard constructor, and then wrap the result with <code>shareCommonM</code> to build a shared object? I was a bit confused that in <code>SymM</code>, there is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.Sym.shareCommonInc#doc\">docs#Lean.Meta.Sym.shareCommonInc</a> for gradually building objects but I don't see a global <code>shareCommon</code> alternative.</p>",
        "id": 574962130,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1771599795
    },
    {
        "content": "<p>The particular way that SymM works with share common is designed slightly differently for performance reasons. If you know that the term is already mostly shared the benefit of certain optimizations that are done in <code>shareCommon</code> diminishes. Both of the operations are going to get you there though.</p>",
        "id": 574978105,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1771603821
    }
]