[
    {
        "content": "<p>Is there a function to check what new fvars were introduced in a different lctx?</p>\n<p>e.g. I have goals <code>goal</code> and <code>goal'</code>, and I want to compare what new fvars are created in the second scope:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">goal.withContext</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">lctx</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">getLCtx</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">goal'</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">goal.mystery</span>\n<span class=\"w\">  </span><span class=\"n\">goal'.withContext</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">lctx'</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">getLCtx</span>\n</code></pre></div>",
        "id": 509544592,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1743540352
    },
    {
        "content": "<p>Something simp does is keep track of the size of the local context (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.Simp.Context.lctxInitIndices#doc\">docs#Lean.Meta.Simp.Context.lctxInitIndices</a>) to see if there are new declarations. This works so long as the local context undergoes only basic changes, like adding decls and erasing decls.</p>",
        "id": 509545661,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743540745
    },
    {
        "content": "<p>so the best way to do this is to compare <code>numIndices</code> of two lctx and use <code>getAt?</code>?</p>",
        "id": 509545837,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1743540818
    },
    {
        "content": "<p>I'm not going to say that this is best. It depends on what <code>mystery</code> is doing.</p>",
        "id": 509545883,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743540835
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Difference.20between.20two.20LCtx/near/509545883\">said</a>:</p>\n<blockquote>\n<p>I'm not going to say that this is best. It depends on what <code>mystery</code> is doing.</p>\n</blockquote>\n<p>it only adds symbols to the context of <code>goal'</code> via <code>withLocalDecl</code></p>",
        "id": 509546044,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1743540881
    },
    {
        "content": "<p>Fvars also have unique ids (the FVarId), so you can also check to see if the new lctx has new fvarids. The types of fvars can change however; I <em>think</em> it is only supposed to happen if the types are defeq. Values of fvars can also be cleared, but again I'm not sure if that's supposed to be allowed without creating a new fvarid.</p>",
        "id": 509546068,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743540894
    },
    {
        "content": "<p>So <code>mystery</code> is not a mystery, it's completely in your control? Then yes, I think using fvar indices should be fine.</p>",
        "id": 509546180,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743540935
    },
    {
        "content": "<p>If it's completely in your control, you can also have your functions return the new fvars.</p>",
        "id": 509546307,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743540974
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> has marked this topic as resolved.</p>",
        "id": 509559143,
        "sender_full_name": "Notification Bot",
        "timestamp": 1743546698
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/.E2.9C.94.20Difference.20between.20two.20LCtx/near/509546307\">said</a>:</p>\n<blockquote>\n<p>If it's completely in your control, you can also have your functions return the new fvars.</p>\n</blockquote>\n<p>its not in my control. its a function from Lean's library, and I can see its definition</p>",
        "id": 509559172,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1743546711
    },
    {
        "content": "<p>I'm not sure you should depend on the definition being what it is then, unless it documents the behavior you're depending on.</p>",
        "id": 509568364,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743551538
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/aesop/blob/master/Aesop/RuleTac/GoalDiff.lean\">Here</a> is some code that computes 'diffs' between goals.</p>\n<p>Note that there are a number of subtleties involved:</p>\n<ul>\n<li>Which notion of 'the same hyp' are you interested in? Same <code>FVarId</code>? Structurally equal type and value? Both? (This is what I implement.) Defeq type and value? </li>\n<li>Lean tactics sometimes change <code>FVarId</code>s for no good reason (e.g. <code>subst</code>). My code does not correct for this because for my use case it's fine if the diffs are not entirely precise.</li>\n<li><code>FVarId</code>s are supposed to change whenever the type or value of a hyp changes (even if the new type is defeq), but Lean itself currently does not satisfy this expectation in many places, so you can't rely on it.</li>\n</ul>",
        "id": 509913625,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1743680316
    }
]