[
    {
        "content": "<p>I'm trying to figure out how to write metaprograms which add definitions the environment. I have figured out how to add definitions which reduce, but for some reason, I cannot figure out how to get them to compile. Any advice? </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MyDefinition</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DefinitionVal</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">mkDefinitionValEx</span><span class=\"w\"> </span><span class=\"ss\">`myDef</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">`Nat</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">`OfNat.ofNat</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">`Nat</span><span class=\"w\"> </span><span class=\"o\">[]))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">lit</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">natVal</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">`instOfNatNat</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">lit</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">natVal</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">regular</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"n\">safe</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"ss\">`myDef</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">addDecl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">defnDecl</span><span class=\"w\"> </span><span class=\"n\">MyDefinition</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">myDef</span><span class=\"w\"> </span><span class=\"c1\">-- myDef : Nat</span>\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">myDef</span><span class=\"w\"> </span><span class=\"c1\">-- 5</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">myDef</span>\n<span class=\"c1\">-- (interpreter) unknown declaration '_eval'</span>\n<span class=\"c1\">-- failed to compile definition, compiler IR check failed at '_eval._closed_0'. Error: depends on declaration 'myDef', which has no executable code; consider marking definition as 'noncomputable'</span>\n</code></pre></div>",
        "id": 536777788,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1756470525
    },
    {
        "content": "<p>Use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.addAndCompile#doc\">docs#Lean.addAndCompile</a> instead</p>",
        "id": 536778900,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1756470832
    },
    {
        "content": "<p>Oh great, thank you!</p>",
        "id": 536779309,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1756470976
    },
    {
        "content": "<p>Interesting! There is a similar <a href=\"https://github.com/leanprover-community/repl/issues/62\">issue</a> in the REPL when using the pickling/unpickling feature. It is relying on Lean's <a href=\"https://github.com/leanprover/lean4/blob/8789e5621b05dc770401bc0532e57a8dabee31c5/src/Lean/Replay.lean#L76-L120\">replayConstant</a> method which is using <code>addDecl</code> (or more precisely<code>addDeclCore</code>). Is there a reason to only do <code>addDecl</code>  and not <code>compileDecl</code> when replaying constants?</p>",
        "id": 536911480,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1756556919
    },
    {
        "content": "<p>Some constants might not be computable</p>",
        "id": 536915513,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1756561117
    },
    {
        "content": "<p>Yeah actually I ended up going back to <code>addDecl</code> because I used a recursor, lol</p>",
        "id": 536920893,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1756566841
    },
    {
        "content": "<p>You can do <code>compileDecl (logErrors := false)</code> though to try compiling everything.</p>\n<p>Maybe the deal is that the use case for REPL has been replaying proofs mostly, so compiled definitions have not been relevant? Maybe it ought to record which definitions were compiled when pickling, to be able to accurately re-run <code>compileDecl</code>.</p>",
        "id": 536921769,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756567916
    },
    {
        "content": "<p>Thanks for the help! I have other questions then ^^ What are the use-cases of the <a href=\"https://github.com/leanprover/lean4/blob/8789e5621b05dc770401bc0532e57a8dabee31c5/src/Lean/Replay.lean#L76-L120\">replayConstant</a> method in Lean? The fact that computable constants are not compiled do not cause issues in these other use-cases?<br>\nAlso, do we have access to the computability of the constants in the <code>info</code> field of the <a href=\"https://github.com/leanprover/lean4/blob/8789e5621b05dc770401bc0532e57a8dabee31c5/src/Lean/Replay.lean#L76-L120\">replayConstant</a>? If so we can probably add a <code>compileDecl</code> automatically in these cases inside <code>replayConstant</code>, right?</p>",
        "id": 536983081,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1756646731
    },
    {
        "content": "<p>The computability isn't stored in the ConstantInfo, and they're also the forms of the definitions that have been \"compiled\" for the kernel to eliminate explicit recursion. For example, if you have a structurally recursive definition on <code>Nat</code>, it's been \"compiled\" to a <code>Nat.brecOn</code>.</p>\n<p>While <code>compileDecl</code> function is used directly on non-recursive definitions, for recursive and mutually recursive definitions instead the compiler is given \"predefinitions\", the definitions still in the explicitly recursive form.</p>\n<p>To support compilation, you'd need to know which definitions are the ones that are supposed to actually get compiled. First, there's an environment extension that explicitly records this (I'm not sure exactly which one to look at). Second, you need to know which declarations correspond to the predefinition. For example, if <code>f</code> is recursive, then <code>f._unsafe_rec</code> is the corresponding <code>partial</code> definition that's compiled by <code>compileDecl</code>; it's an actual separate declaration with its own ConstantInfo that's been kernel-checked too. With mathlib, if you put <code>whatsnew in</code> before a declaration you can see all the environment modifications.</p>\n<p>So, I think it should be possible to compile the declarations in a replayed environment but (1) you need more precise information about what was compiled and (2) you need to figure out how to redo some of the logic to make sure the compiler knows that these auxiliary declarations have the compiled code for the corresponding declarations.</p>\n<p>It's worth mentioning that compiling declarations can happen after the environment is replayed.</p>\n<p>I notice that <a href=\"https://github.com/leanprover/lean4/blob/8789e5621b05dc770401bc0532e57a8dabee31c5/src/Lean/Replay.lean#L163\">replay</a> doesn't include unsafe or partial definitions. Those are strictly necessary for this to succeed. The logic will also need to be modified to deal with the <code>all</code> field in <code>Lean.DefinitionVal</code> to add complete sets of mutually recursive partial definitions to the kernel simultaneously, otherwise the kernel will reject these definitions and replay will fail, even if you haven't yet gotten to compiling definitions.</p>",
        "id": 536995828,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756660868
    },
    {
        "content": "<p>Wow, thank you very much for such a detailed answer and for looking into this! This is indeed much more complicated than I thought. And so, what about doing the brute-force approach you suggested first, i.e. <code>compileDecl (logErrors := false)</code> (in topological order)? Would it be enough? Could it cause new issues?</p>",
        "id": 536996368,
        "sender_full_name": "Auguste Poiroux",
        "timestamp": 1756661527
    },
    {
        "content": "<p>I <em>think</em> the only thing to worry about is that there's a chance things won't be compiled even if you thought they'd be. Maybe you'll uncover some exciting exceptions. (Likely you can catch them with try/catch, and maybe if you want to be safe, restore the environment on failure; the code for <code>withoutModifyingEnv'</code> is a good reference.)</p>\n<p>If your module only has non-recursive definitions, and nothing is marked <code>partial</code>, I'd expect success.</p>",
        "id": 536997055,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756662196
    }
]