[
    {
        "content": "<p>The following is potentially ill-defined. Please accept my apologies, as I'm lacking the knowledge to express myself more clearly. I just hope that Syntax is the right abstraction.</p>\n<p>I frequently think of a theorem syntactically as a bunch of hypotheses and a single conclusion, where the conclusion is separated from the rest via <code>:</code>. Now, I'm searching for a nice way to split the conclusion from the hypotheses, i.e. get the Syntax object of said conclusion. More generally, I'd like to get this for each theorem in a file. I present my \"solution\" below. I would appreciate being told whether, and if so where, it is flawed, as I'm quite a novice in metaprogramming.</p>\n<p>Using the InfoTree, I can check the syntax kinds to get information on the parser, and thereby figure out whether a certain <code>CommandInfo</code> is a theorem or something else.<br>\nOnce that's obtained, I'm now obtaining all direct child nodes of such a CommandInfo node for a theorem, and simply get the syntax for the one with the largest starting line / column. This seems to work for me for now. Is there a known better way that I'm missing?</p>\n<p>I'm unsure how to press this into an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, so here's my current implementation. Note that this won't work on it's own. To run it, this <a href=\"https://github.com/leanprover-community/repl/pull/101\">PR</a> could be used. Any input is greatly appreciated - thanks for taking the time!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">maxTermNode</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">terms</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TermInfo</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">ContextInfo</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TermInfo</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">ContextInfo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">terms</span><span class=\"bp\">.</span><span class=\"n\">head?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ti</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ctx?</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">largestTail</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">maxTermNode</span><span class=\"w\"> </span><span class=\"n\">terms</span><span class=\"bp\">.</span><span class=\"n\">tail</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">largestTail</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">tailinfo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tailctx</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">ctx?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">stxRange</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"bp\">.</span><span class=\"n\">fileMap</span><span class=\"w\"> </span><span class=\"n\">ti</span><span class=\"bp\">.</span><span class=\"n\">stx</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">tailRange</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">stxRange</span><span class=\"w\"> </span><span class=\"n\">tailctx</span><span class=\"bp\">.</span><span class=\"n\">fileMap</span><span class=\"w\"> </span><span class=\"n\">tailinfo</span><span class=\"bp\">.</span><span class=\"n\">stx</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">tailRange</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"bp\">.</span><span class=\"n\">line</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"bp\">.</span><span class=\"n\">line</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">tailinfo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tailctx</span><span class=\"bp\">⟩</span>\n<span class=\"w\">        </span><span class=\"k\">else</span>\n<span class=\"w\">          </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">tailRange</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"bp\">.</span><span class=\"n\">column</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"bp\">.</span><span class=\"n\">column</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">tailinfo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tailctx</span><span class=\"bp\">⟩</span>\n<span class=\"w\">          </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ti</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"bp\">⟩</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">tailinfo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tailctx</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">ctx?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ti</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"bp\">⟩</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">conclusion</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">InfoTree</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TermInfo</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">ContextInfo</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">only_declarations</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ofCommandInfo</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">elaborator</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"ss\">``Lean.Elab.Command.elabDeclaration</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">stx</span><span class=\"bp\">.</span><span class=\"n\">getArgs</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">getLast?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"bp\">.</span><span class=\"n\">getKind</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"ss\">``Lean.Parser.Command.theorem</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">      </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">only_term</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ofTermInfo</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">trees</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">only_declarations</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">only_declarations</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">terms_info</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Info</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">ContextInfo</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trees</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">findAllInfo</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"n\">only_term</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">only_declarations</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">terms</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TermInfo</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">ContextInfo</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">terms_info</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">flatMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ctx?</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ofTermInfo</span><span class=\"w\"> </span><span class=\"n\">ti</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">ti</span><span class=\"bp\">.</span><span class=\"n\">stx</span><span class=\"bp\">.</span><span class=\"n\">getHeadInfo</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">original</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">⟨</span><span class=\"n\">ti</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ctx?</span><span class=\"bp\">⟩</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">optional_conclusions</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">terms</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">maxTermNode</span><span class=\"w\"> </span><span class=\"n\">ts</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">optional_conclusions</span><span class=\"bp\">.</span><span class=\"n\">flatMap</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">s</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n</code></pre></div>",
        "id": 526791163,
        "sender_full_name": "Simon Sorg",
        "timestamp": 1751459682
    },
    {
        "content": "<p>This would be easier to do if you don't hook into the <code>InfoTree</code> (where you first need to find all the commands), but into the code that actually calls <code>elabCommand</code>. At that point, you have the <code>Syntax</code> object and you can match on it to extract the conclusion. Is that an option?</p>",
        "id": 526806147,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1751464108
    },
    {
        "content": "<p>Btw, extracting the conclusion syntactically implies that the following theorems are treated differently:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">B</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span>\n</code></pre></div>\n<p>If you want to avoid this, you should probably go to the <code>Expr</code> level, i.e. get the type <code>Expr</code>s of all theorems in the file (this is actually quite annoying to do), do a <code>forallTelescope</code> to get the conclusion and pretty-print it. However, this introduces potential issues where the pretty-printer produces syntax that can't be elaborated for various reasons.</p>",
        "id": 526806962,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1751464337
    },
    {
        "content": "<p>Could you say a bit about what will consume this collected information?</p>\n<p>It's possible for example to take all the theorems in an imported module, get their conclusions as Exprs, and pretty print them. By \"conclusion\" I mean \"the innermost body of universal quantification\", which tends to be what's after <code>:</code> but isn't guaranteed to be the exact point (ah, Jannis just mentioned this while I was writing this comment)</p>",
        "id": 526807048,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751464362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Split.20theorem.20conclusion/near/526806962\">said</a>:</p>\n<blockquote>\n<p>Btw, extracting the conclusion syntactically implies that the following theorems are treated differently:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">B</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span>\n</code></pre></div>\n<p>If you want to avoid this, you should probably go to the <code>Expr</code> level, i.e. get the type <code>Expr</code>s of all theorems in the file (this is actually quite annoying to do), do a <code>forallTelescope</code> to get the conclusion and pretty-print it. However, this introduces potential issues where the pretty-printer produces syntax that can't be elaborated for various reasons.</p>\n</blockquote>\n<p>I remember facing some delaborator issues like this with definite integrals a few months ago, which is why I'd like to stay at syntax. But your point on <code>theorem t1: A -&gt; B</code> is quite convincing, thanks!</p>",
        "id": 526834604,
        "sender_full_name": "Simon Sorg",
        "timestamp": 1751471805
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Split.20theorem.20conclusion/near/526807048\">said</a>:</p>\n<blockquote>\n<p>Could you say a bit about what will consume this collected information?</p>\n<p>It's possible for example to take all the theorems in an imported module, get their conclusions as Exprs, and pretty print them. By \"conclusion\" I mean \"the innermost body of universal quantification\", which tends to be what's after <code>:</code> but isn't guaranteed to be the exact point (ah, Jannis just mentioned this while I was writing this comment)</p>\n</blockquote>\n<p>Okay, so I simply want to either a) negate a conclusion or b) replace a conclusion with False automatically. For the latter, using <code>Expr</code> should not be a problem, but I'm a bit afraid of how this would work for the former. But I guess I could just wrap the conclusion Expr with a negation into the corresponding Expr.</p>",
        "id": 526835089,
        "sender_full_name": "Simon Sorg",
        "timestamp": 1751471966
    },
    {
        "content": "<p>Could you say more about what you want to do? What's the output? A negated theorem could mean an Expr, some Syntax, some source code to paste in, etc. There are lots of options for lots of applications, so this is why I'm asking about what will consume the data and how.</p>",
        "id": 526839452,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751473358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Split.20theorem.20conclusion/near/526839452\">said</a>:</p>\n<blockquote>\n<p>Could you say more about what you want to do? What's the output? A negated theorem could mean an Expr, some Syntax, some source code to paste in, etc. There are lots of options for lots of applications, so this is why I'm asking about what will consume the data and how.</p>\n</blockquote>\n<p>Sure, sorry! Thanks for the patience so far! It's for Automated Theorem Proving via an external tool I'm working on (ideally not just LLM slop) - so I would like to have Lean code I can feed into c++ as string.<br>\nIdeally, it would be source code to paste in.<br>\nI take the string, do some processing in c++, and feed it back to Lean. So the negated conclusion's statement itself should make valid Lean source code.<br>\n Since this should be achievable from Syntax too (please correct me here), Syntax is also fine. But that's why I'm a bit hesitant with Expr.</p>",
        "id": 526865471,
        "sender_full_name": "Simon Sorg",
        "timestamp": 1751483756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Split.20theorem.20conclusion/near/526806962\">said</a>:</p>\n<blockquote>\n<p>Btw, extracting the conclusion syntactically implies that the following theorems are treated differently:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">B</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span>\n</code></pre></div>\n<p>If you want to avoid this, you should probably go to the <code>Expr</code> level, i.e. get the type <code>Expr</code>s of all theorems in the file (this is actually quite annoying to do), do a <code>forallTelescope</code> to get the conclusion and pretty-print it. However, this introduces potential issues where the pretty-printer produces syntax that can't be elaborated for various reasons.</p>\n</blockquote>\n<p>So I did this now (and the InfoTree was quite helpful in getting the correct <code>Expr</code> terms).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">conclusion</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">ppExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">forallMetaTelescope</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pretty'</span>\n</code></pre></div>\n<p>which gives the following outputs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">--1 + 1 = 2</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"c1\">--?p</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"c1\">--?p</span>\n</code></pre></div>\n<p>Quite amazing! For further processing, it should suffice to strip away the ?, and then treat this as this the conclusion. Thanks!</p>",
        "id": 527024806,
        "sender_full_name": "Simon Sorg",
        "timestamp": 1751556555
    }
]