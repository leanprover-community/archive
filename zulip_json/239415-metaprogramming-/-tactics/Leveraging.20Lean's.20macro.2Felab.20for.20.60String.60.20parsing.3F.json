[
    {
        "content": "<p>I have a simple parsing task where I want to parse e.g., the following <code>String</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"s2\">\"(</span>\n<span class=\"s2\">(define-fun x () Int 42)</span>\n<span class=\"s2\">(define-fun y () (_ BitVec 4) #x5)</span>\n<span class=\"s2\">)\"</span>\n</code></pre></div>\n<p>into</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">∅</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">Val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"s2\">\"x\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"s2\">\"y\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"n\">x5</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>where <code>Val</code> is defined as <code>inductive Val: Type := | int (i: Int) | bitvec {n} (bv: BitVec n)</code>.<br>\nMaybe I can define a simple parser combinators, but since I have no experience with parser combinators, I am curious if I can piggyback on Lean's features for this task.</p>\n<p>Specifically, I think I know how to write macro/elaborator in Lean4 so that</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">parseThis</span><span class=\"w\"> </span><span class=\"o\">(</span>\n<span class=\"o\">(</span>\n<span class=\"o\">(</span><span class=\"n\">define</span><span class=\"bp\">-</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">define</span><span class=\"bp\">-</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">x5</span><span class=\"o\">)</span>\n<span class=\"o\">)</span>\n<span class=\"o\">))</span>\n</code></pre></div>\n<p>evaluates to the term above. But I am not sure how to parse the <code>String</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"s2\">\"(</span>\n<span class=\"s2\">(define-fun x () Int 42)</span>\n<span class=\"s2\">(define-fun y () (_ BitVec 4) #x5)</span>\n<span class=\"s2\">)\"</span>\n</code></pre></div>\n<p>which is different from Lean <code>Syntax</code>. I guess there is a Lean's internal parser that converts <code>String</code> to <code>Syntax</code>, and maybe I can chain that with the macro to get a <code>String</code> parser?</p>\n<p>Does this make sense? Would it be something that could theoretically possible but discouraged pattern?</p>",
        "id": 495370117,
        "sender_full_name": "Youngju Song",
        "timestamp": 1737578617
    },
    {
        "content": "<p>We generally use the currently not yet stabilized parser library in <code>Std.Internal.Parsec</code> for that kind of task.</p>",
        "id": 495370362,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1737578712
    },
    {
        "content": "<p>Also out of curiosity, what's your reason for parsing SMTLIB?</p>",
        "id": 495370761,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1737578900
    },
    {
        "content": "<p>I was able to reuse an elaborator I wrote for parsing here: <a href=\"https://github.com/arthurpaulino/FxyLang\">https://github.com/arthurpaulino/FxyLang</a></p>\n<p>But be warned that this is not a proper solution. To parse strings you should not rely on metaprogramming.</p>",
        "id": 495372870,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1737579741
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> <span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> Thank you for the comments! I will give it a try to <code>Parsec</code>.</p>\n<blockquote>\n<p>Also out of curiosity, what's your reason for parsing SMTLIB?</p>\n</blockquote>\n<p>I am looking for something that corresponds to <code>z3py</code> binding in Lean4. I don't intend to use SMT solver to prove things in Lean, but I instead need to retrieve the <strong>model</strong> and play with it inside Lean4. I looked at few libraries (<code>lean-smt</code>, <code>lean-auto</code>, <code>lean-cvc5</code>) but nothing seems to fit my use case, so I am building one myself which includes a simple parser for the model written in SMTLIB format. While the whole SMTLIB format could be quite large, I just need a parser for the model which seems to be feasible.</p>",
        "id": 495600530,
        "sender_full_name": "Youngju Song",
        "timestamp": 1737673136
    },
    {
        "content": "<p>Generally speaking the SMT-LIB format is just built from s expressions so writing a parser for the entire format can be trivial if you don't want to have all syntactic variants encoded in the syntax tree but are content having them in the s expressions.</p>",
        "id": 495600812,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1737673284
    }
]