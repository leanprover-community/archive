[
    {
        "content": "<p>Hello!</p>\n<p>I am currently writing a tactic, which will encounter some expressions, and I would like to allow users to associate these expressions with a <code>MetaM</code> function that my tactic could call. For example, users could say something like \"when you encounter the term <code>f x y z</code>, use the metaprogram <code>m_f: MVarId -&gt; Expr -&gt; MetaM Unit</code>\", and my tactic would internally call <code>m_f</code>. </p>\n<p>For example something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">HasMetaprogram</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">prog</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">MVarId</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"n\">n</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"n\">HasMetaprogram</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"n\">mvarid</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"c1\">-- do something smart that assign mvarid</span>\n<span class=\"w\">    </span><span class=\"c1\">-- `expr` is the expression of `f (10*n)` that may be useful</span>\n<span class=\"w\">    </span><span class=\"n\">mvarid</span><span class=\"bp\">.</span><span class=\"n\">assign</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Unit.unit</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n</code></pre></div>\n<p>Now onto the question: given an expression <code>f (10*n)</code>, I can easily get the <code>Expr</code> which has type <code>Lean.MVarId → Lean.Expr → Lean.MetaM Unit</code>, but how can I \"call\" this expression within my tactic?</p>",
        "id": 541333077,
        "sender_full_name": "Théophile",
        "timestamp": 1758749008
    },
    {
        "content": "<p>This is a bit of a <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>, so here is the actual problem I am trying to solve (but it is a bit long to explain).</p>\n<p>In my development, I have defined many functions and corresponding theorems, and I wrote a tactic which, among many things, lookup for the theorem corresponding to a given function call. To this end, I am using Lean's typeclass mechanism as a database of theorems, in a fashion similar to this code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Theorem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">property</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">property</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"n\">n</span>\n\n<span class=\"kn\">instance</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Theorem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>then, when my tactic would encounter the expression <code>f n</code>, it invokes typeclass synthesis on <code>Theorem (f n) ?property</code>, which instantiates the metavariable <code>?property</code> to <code>fun res =&gt; res = 2*n</code>, and uses this afterward.</p>\n<p>In reality, things are slightly more complex, I sometimes need to associate a function with a <em>class</em> of theorems. This class of theorem is parametrized by another type, as shown in this code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Theorem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">property</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">property</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"n\">n</span>\n\n<span class=\"c1\">-- the property here is a bit silly, but I do have real usecases for this in my full development</span>\n<span class=\"kn\">instance</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Theorem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I then rely on users to provide this value <code>y</code> when using my tactic, which will synthetize an instance of <code>Theorem (f n) y ?property</code></p>\n<p>Now onto my question: although in some cases, the chosen value of <code>y</code> is a crucial argument in the proof, in some other cases, there is only one sensible value to choose for <code>y</code>. For example, it may be than when I encounter <code>f n</code>, I know there should be in the context <code>h: p n y0</code>, and in this case <code>y0</code> is the only sensible choice for <code>y</code>. This value is easily found by using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.assumption#doc\">docs#Lean.MVarId.assumption</a> on the goal <code>p n ?y</code>. In other words, I can write a <code>MetaM</code> that will find this value of <code>y</code> automatically.</p>\n<p>I would therefore like users to be able to provide <code>MetaM</code> function that will find such <code>y</code>, which is what I asked in my first message. But maybe there is a different way toward this goal?</p>",
        "id": 541333241,
        "sender_full_name": "Théophile",
        "timestamp": 1758749085
    },
    {
        "content": "<p>What happens when you get something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"n\">HasMetaprogram</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"n\">mvarid</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"c1\">-- do something smart that assign mvarid</span>\n<span class=\"w\">    </span><span class=\"c1\">-- `expr` is the expression of `f (n + 1)` that may be useful</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">mvarid</span><span class=\"bp\">.</span><span class=\"n\">assign</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Unit.unit</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">mvarid</span><span class=\"bp\">.</span><span class=\"n\">assign</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``id</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">])</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Unit</span><span class=\"w\"> </span><span class=\"o\">[]))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Unit.unit</span><span class=\"w\"> </span><span class=\"o\">[]))</span>\n</code></pre></div>",
        "id": 541334272,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758749648
    },
    {
        "content": "<p>then <code>n</code> is not determined at runtime</p>",
        "id": 541334650,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758749896
    },
    {
        "content": "<p>maybe you can do something like what <code>norm_num</code> does</p>",
        "id": 541334692,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758749922
    },
    {
        "content": "<p>Ah, indeed I would not be happy if provided such a metaprogram. In real scenarios I only need the <code>Expr</code> version of <code>n</code>, not its actual value. But I understand this hints toward the fact what I want may not be possible (at least not in the form of typeclass)</p>",
        "id": 541334848,
        "sender_full_name": "Théophile",
        "timestamp": 1758750025
    },
    {
        "content": "<p>I could do the following instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">prog_f_n_plus_1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mvarid</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MVarId</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"c1\">-- do something smart that assign mvarid</span>\n<span class=\"w\">    </span><span class=\"c1\">-- `expr` is the expression of `f (n + 1)` that may be useful</span>\n<span class=\"w\">    </span><span class=\"n\">mvarid</span><span class=\"bp\">.</span><span class=\"n\">assign</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Unit.unit</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"n\">HasMetaprogram</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"n\">mvarid</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">prog_f_n_plus_1</span>\n</code></pre></div>\n<p>Then I can get the <code>Name</code> corresponding to <code>prog_f_n_plus_1</code>, and I don't have such dependency problem.</p>",
        "id": 541335140,
        "sender_full_name": "Théophile",
        "timestamp": 1758750207
    },
    {
        "content": "<blockquote>\n<p>maybe you can do something like what <code>norm_num</code> does</p>\n</blockquote>\n<p>Ah, maybe like <a href=\"https://github.com/leanprover-community/mathlib4/blob/f863e92791b0d5227cccc78ea0f5e70c107428ce/Mathlib/Tactic/NormNum/Core.lean#L49-L51\">this snippet of code</a>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Read a `norm_num` extension from a declaration of the right type. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkNormNumExt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ImportM</span><span class=\"w\"> </span><span class=\"n\">NormNumExt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">opts</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">read</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">ofExcept</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"bp\">.</span><span class=\"n\">evalConstCheck</span><span class=\"w\"> </span><span class=\"n\">NormNumExt</span><span class=\"w\"> </span><span class=\"n\">opts</span><span class=\"w\"> </span><span class=\"ss\">``NormNumExt</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>(<code>NormNumExt</code> does contain a <code>MetaM</code> program)</p>",
        "id": 541335682,
        "sender_full_name": "Théophile",
        "timestamp": 1758750540
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"897795\">Théophile</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Calling.20an.20.60Expr.60.20that.20has.20type.20.60MetaM.60.20in.20a.20.60MetaM.60.20program/near/541335682\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>maybe you can do something like what <code>norm_num</code> does</p>\n</blockquote>\n<p>Ah, maybe like <a href=\"https://github.com/leanprover-community/mathlib4/blob/f863e92791b0d5227cccc78ea0f5e70c107428ce/Mathlib/Tactic/NormNum/Core.lean#L49-L51\">this snippet of code</a>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Read a `norm_num` extension from a declaration of the right type. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkNormNumExt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ImportM</span><span class=\"w\"> </span><span class=\"n\">NormNumExt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">opts</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">read</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">ofExcept</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"bp\">.</span><span class=\"n\">evalConstCheck</span><span class=\"w\"> </span><span class=\"n\">NormNumExt</span><span class=\"w\"> </span><span class=\"n\">opts</span><span class=\"w\"> </span><span class=\"ss\">``NormNumExt</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>(<code>NormNumExt</code> does contain a <code>MetaM</code> program)</p>\n</blockquote>\n<p>yeah like that</p>",
        "id": 541336947,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758751337
    },
    {
        "content": "<p>I got something to work using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.evalConstCheck#doc\">docs#Lean.evalConstCheck</a>, thanks!!</p>",
        "id": 541464769,
        "sender_full_name": "Théophile",
        "timestamp": 1758808434
    }
]