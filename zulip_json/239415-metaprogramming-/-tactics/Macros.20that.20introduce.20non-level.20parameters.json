[
    {
        "content": "<p>The <code>Type*</code> macro in <code>mathlib</code> introduces a fresh level metavariable and then converts it to a parameter using <code>Elab.Term.levelMVarToParam</code>. Is there any way to achieve the same thing for normal (non-level) parameters?</p>\n<p>For instance, I'd like to write a macro <code>HOM*</code> such that</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HOM</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>expands to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Obj</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Obj</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>which then becomes (via <code>autoImplicits</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Obj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Obj</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Obj</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Obj</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>so that I may avoid declaring <code>Obj</code> whenever possible. Such a thing might also be useful for implementing a crude version of <a href=\"https://github.com/leanprover/lean4/issues/8279\">RFC: reimplementing class abbrev #8279</a>.</p>",
        "id": 533357764,
        "sender_full_name": "Anthony Vandikas",
        "timestamp": 1754597772
    },
    {
        "content": "<p>This works, so long as <code>Obj</code> isn't a constant that's already in scope:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"HOM*\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"ss\">`Obj</span>\n<span class=\"w\">  </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HOM</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  Obj : Sort u_1</span>\n<span class=\"cm\">  hom : Obj → Obj → Type u_2</span>\n<span class=\"cm\">  ⊢ True</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 533358966,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754598428
    },
    {
        "content": "<p>The <code>mkIdent</code> prevents the identifier from being made hygienic, and autoImplicits checks to see that identifiers are not hygienic (I think because that's a proxy for \"written by the user\")</p>",
        "id": 533359143,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754598524
    },
    {
        "content": "<p>Thank you! This was exactly what I needed to proceed.</p>\n<p>Aside, I needed the names to be unique as I sometimes need to deal with more than one <code>HOM*</code>. I achieved this by re-implementing this using the <code>elab</code> command and generating the names based off a global counter.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"HOM[*]\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">objCounter</span><span class=\"bp\">.</span><span class=\"n\">getState</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">setEnv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">objCounter</span><span class=\"bp\">.</span><span class=\"n\">setState</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">anonymous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\"Obj\"</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">toSubscriptString</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">none</span>\n</code></pre></div>\n<p>In another file:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">initialize</span><span class=\"w\"> </span><span class=\"n\">objCounter</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">EnvExtension</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">registerEnvExtension</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 533367169,
        "sender_full_name": "Anthony Vandikas",
        "timestamp": 1754602976
    },
    {
        "content": "<p>Do you need to refer to the name of the <code>Obj</code>? If yes then it feels like this is a bit weird (a global counter? won't that throw off everything if you add <code>HOM[*]</code> somewhere?), if no then <code>​`(Obj → Obj → Type*)</code> would also do the trick</p>",
        "id": 533367622,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754603275
    },
    {
        "content": "<p>I don't need to refer to the name. When I do, I have an alternate macro <code>HOM[Obj]</code> which is just equivalent to <code>Obj → Obj → Type*</code>.</p>\n<blockquote>\n<p>if no then <code>​`(Obj → Obj → Type*)</code> would also do the trick</p>\n</blockquote>\n<p>If I do that, I get <code>unknown identifier 'Obj✝'</code> at the use site.</p>",
        "id": 533367919,
        "sender_full_name": "Anthony Vandikas",
        "timestamp": 1754603400
    },
    {
        "content": "<p>I'm confused; you say you sometimes have more than one; how do you distinguish?</p>",
        "id": 533368749,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754603932
    },
    {
        "content": "<p>I mean at the use site; I suppose you won't just <code>x : Obj_12754</code></p>",
        "id": 533368846,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754604002
    },
    {
        "content": "<p>Oh wait you mean that hygienic identifiers don't get auto-implicits? That might be the case</p>",
        "id": 533369035,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754604092
    },
    {
        "content": "<p>Hmm you're right it might not be as easy to make something like this if you don't do what you did</p>",
        "id": 533369679,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754604507
    },
    {
        "content": "<p>If you're using a term elaborator, then you have access to the local context, and you can avoid using a global counter by instead finding an unused name.</p>",
        "id": 533370544,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754605048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Macros.20that.20introduce.20non-level.20parameters/near/533369035\">said</a>:</p>\n<blockquote>\n<p>Oh wait you mean that hygienic identifiers don't get auto-implicits? That might be the case</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Macros.20that.20introduce.20non-level.20parameters/near/533359143\">said</a>:</p>\n<blockquote>\n<p>autoImplicits checks to see that identifiers are not hygienic</p>\n</blockquote>\n<p>In particular it checks that the name is an atomic string. (<code>isValidAutoBoundImplicitName</code>)</p>",
        "id": 533370829,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754605276
    }
]