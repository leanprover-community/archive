[
    {
        "content": "<p>Good evening! I'm trying to unify some metavariables with expressions containing <code>fvar</code>s that were created after the metavariables were (for the purpose of making a lambda expression). Specifically, I'm running into the error created by the second example below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">withLocalDecl</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">binderExpr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVar</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"w\">    </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">binderExpr</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"Couldn't unify :(\"</span>\n<span class=\"w\">    </span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">binderExpr</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"c1\">-- works fine</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVar</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"n\">withLocalDecl</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">binderExpr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n\n<span class=\"w\">    </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">binderExpr</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"Couldn't unify :(\"</span>\n<span class=\"w\">    </span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">binderExpr</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"c1\">-- throws an error (want this to work)</span>\n</code></pre></div>\n<p><code>isDefEq</code> appears to dislike this, apparently because the <code>MVarDecl</code> associated with <code>m</code> carries a <code>LocalContext</code> that doesn't have the FVar <code>binderExpr</code> in it. I did notice one could get around this by simply modifying the MVar directly (like <code>let updatedLCtx ← getLCtx; setMCtx &lt;| (← getMCtx).modifyExprMVarLCtx m.mvarId! (fun _ =&gt; updatedLCtx)</code>), which seemed to work well empirically; however, I couldn't help but notice the ominous warning on <code>modifyExprMVarLCtx</code> about requiring any modification to be \"legal\". </p>\n<p>My question: is such a modification to existing MVars a safe thing to do? (even considering that everything is turned into <code>bvar</code>s right afterwards by <code>mkLambdaFVars</code>?) And is there a more intelligent way to go about this?</p>\n<p>I greatly appreciate y'all's help!</p>",
        "id": 566864089,
        "sender_full_name": "Tate Rowney",
        "timestamp": 1767846098
    },
    {
        "content": "<p>It doesn't make sense for this to succeed. Otherwise you can prove anything</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">?</span><span class=\"n\">m1</span>\n<span class=\"bp\">|-</span><span class=\"w\"> </span><span class=\"n\">False</span>\n</code></pre></div>\n<p>Suppose we have (this is very easy to produce)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">?</span><span class=\"n\">m2</span>\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span>\n<span class=\"bp\">|-</span><span class=\"w\"> </span><span class=\"n\">False</span>\n</code></pre></div>\n<p>and if the unification succeeded it could assign <code>?m1</code> to <code>x</code> and prove <code>False</code>.</p>\n<p>However, if you have a way to produce something that has the same type as <code>x</code> in <code>?m1</code>'s context, you can assign <code>(mkLambdaFVars #[binderExpr] m2).beta #[arg]</code> to <code>m</code>.</p>",
        "id": 566872553,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1767852674
    },
    {
        "content": "<p>This is very helpful, thank you! I see now how my strategy could be problematic absent other invariants.</p>\n<p>I unfortunately don't have many guarentees on information about the types, etc. of <code>?m1</code>. However, perhaps some other reduction wizardry could help, I will keep searching...</p>",
        "id": 566879284,
        "sender_full_name": "Tate Rowney",
        "timestamp": 1767856538
    },
    {
        "content": "<p>I don't think you can generate any unsoundness by extending the local context of an MVar after it has been created. After all, meta variables are an elaboration time concept and the kernel does reject any program with a meta variable. </p>\n<p>However, extending the context of the meta variable can potentially lead to dangling free vars if the metavariable has been used in expressions where the added fvar is not in scope. This is no different to forgetting to do an, e.g. mkLambdaFVars. If you have control of all the use sites of the metavariable, I don't think it's problematic to extend its local context. It's just questionable why you haven't created the metavariable in the extended context in the first place. Also be sure that the new local context is actually strictly an extension of the old context. (No clear has happened.)</p>",
        "id": 567083125,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1767942836
    },
    {
        "content": "<p>Thanks! It seems that both the issues above might be remediated if the mvar in question can only have its local context extended if it appears solely within the body of the function, so that the fvar will never be dangling. Is this sufficient to ensure that this modification won't cause problems?</p>\n<p>(The reason I am in this situation is because I am taking Exprs elaborated in many different contexts, abstracting their metavariables, and putting them all in a single context using <code>abstractMVars</code>, which creates all the new mvars at once. Another workaround could involve modifying that API to wait to declare some mvars, but this seems like it would introduce its own set of headaches).</p>",
        "id": 567286077,
        "sender_full_name": "Tate Rowney",
        "timestamp": 1768010516
    },
    {
        "content": "<p>I'm not sure I'm following. If you already have <code>Expr</code>s <code>es</code> that contain metavariables, then the metavariables live in the same local context as <code>es</code>. <code>abstractMVars</code> shouldn't change that. So I'm not sure which free variables you are referring to; perhaps you are referring to bound variables in the specific <code>es</code>?</p>\n<p>On the other hand, you are saying</p>\n<blockquote>\n<p>I am taking Exprs elaborated in many different contexts, [...] and putting them all in a single context</p>\n</blockquote>\n<p>and that doesn't sound well-defined to me. What if one Expr refers to an FVar that is not defined in another context? Are you by chance doing <code>mkForallFVars</code>? Either way, doing <code>isDefEq ?m e</code> <em>in the original context of the expression from whence the metavariable came</em> should assign the metavariable.</p>",
        "id": 567301813,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1768031895
    },
    {
        "content": "<p>As with the example above, I'm taking let/forall/lambda expressions and creating a <code>withLocalDecl</code> at each one <em>after</em> mvars are created, changing the <code>localContext</code> (so that expressions from other contexts with the same fvar names will be changed to bvars as appropriate). I don't doubt there are situations in which this is undefined; in fact I make a point of type-checking everything afterwards to provide a message to the user if the expressions they input act in this way. I'm unsure that using the original mvar context would work, as I hope that <code>e</code> will eventually consist of a more complex expression, potentially including mvars of its own from a different context.</p>\n<p>Applications aside, I'm still curious if a modification to the <code>MCtx</code> as described above is legal if the <code>mvar</code> in question isn't used outside the <code>withLocalDecl</code>? Thanks!</p>",
        "id": 567406566,
        "sender_full_name": "Tate Rowney",
        "timestamp": 1768154420
    },
    {
        "content": "<p>Can you maybe abstract the mvars and make new ones in the new local context?</p>",
        "id": 567407263,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768155052
    },
    {
        "content": "<p>Wait this is a really interesting idea. I’d assume that if the mvar is used elsewhere in a bad place it’ll just become decoupled/not the same mvar anymore, which I think I’d be fine with… I’ll experiment with this when I get a chance, thanks Aaron!</p>",
        "id": 567407795,
        "sender_full_name": "Tate Rowney",
        "timestamp": 1768155592
    },
    {
        "content": "<p>If you create <code>?m : Nat</code> and want it to scope over a local <code>x : Nat</code> introduced later on, you could do a \"reverse <code>mkForallFVars #[x]</code>\" (<code>intro</code>?) and create <code>?m</code> instead as <code>?m : Nat -&gt; Nat</code>, then use <code>?m x</code> as \"the MVar\".</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">withLocalDecl</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">binderExpr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVar</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"w\">    </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">binderExpr</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"Couldn't unify :(\"</span>\n<span class=\"w\">    </span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">binderExpr</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"c1\">-- works fine</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVar</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"n\">withLocalDecl</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">binderExpr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n\n<span class=\"w\">    </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">binderExpr</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"Couldn't unify :(\"</span>\n<span class=\"w\">    </span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">binderExpr</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"c1\">-- throws an error (want this to work)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">better</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVar</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">withLocalDecl</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">binderExpr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkApp</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">binderExpr</span><span class=\"w\"> </span><span class=\"c1\">-- \"intro x\"</span>\n<span class=\"w\">    </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">binderExpr</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"Couldn't unify :(\"</span>\n<span class=\"w\">    </span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">binderExpr</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">better</span><span class=\"w\"> </span><span class=\"c1\">-- throws an error (want this to work)</span>\n</code></pre></div>",
        "id": 567465524,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1768207075
    }
]