[
    {
        "content": "<p>This question is more out of curiosity than anything, but I noticed that in mathlib3 there was a <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#transport\"><code>transport</code> tactic</a>, but it seems not in mathlib4 - is there any specific reason why?</p>",
        "id": 542176214,
        "sender_full_name": "Bryan Wang",
        "timestamp": 1759202429
    },
    {
        "content": "<p>I think it was almost never used in the Lean 3 days, and hence nobody bothered porting it.</p>",
        "id": 542228567,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1759225288
    },
    {
        "content": "<p>The reason <code>transport</code> is used far less often than you think is the following observation (which I learnt from Mario). Mathematicians are presumably going to want the theorem that says that if X and Y are homeomorphic, and X is compact, then Y is compact, and it would be not hard to imagine a machine proving such a theorem for us. But in fact there's a stronger theorem, which is slightly less easy to imagine a computer proving, that if X is compact and X surjects onto Y then Y is compact, and this is a theorem you want in your API, so if you need the theorem that something homeomorphic to a compact thing is compact then you may as well just use that homeomorphisms are continuous surjections and get it that way.</p>\n<p>A surprisingly large number of statements of the form \"if X has property P and there's an isomorphism X \\iso Y in the appropriate category then Y has property P\" are special cases of \"if X has property P and X -&gt; Y is monic/epic then Y has property P\", and in practice this is what gets used.</p>",
        "id": 542237632,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1759227927
    },
    {
        "content": "<p>Shouldn’t generalised rewriting be able to handle this in principle?</p>",
        "id": 542248683,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759231480
    },
    {
        "content": "<p>It looks to me like <code>grw</code> wouldn't be able to do this, because the relevent <code>gcongr</code> lemma doesn't exist in the library (and the <code>transport</code> tactic generates this kind of lemma on the fly).</p>\n<p>Besides, I have only tested <code>grw</code> for rewriting with relations, not with for rewriting with data, like an <code>Equiv</code>, but feel free to try if that seems useful :)</p>",
        "id": 542296747,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1759243604
    },
    {
        "content": "<p>Fwiw, this kind of a tactic will be super useful in theoretical CS</p>",
        "id": 542302757,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759245105
    },
    {
        "content": "<p>We often deal with isomorphic structures which are just different ways to talk about the same thing, but are computationally very different. For example adjacency matrices, adjacency lists, incidence matrices, and simplegraph, or different but equivalent computation models.</p>",
        "id": 542302975,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759245156
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> : Would it help if we simply generated and tagged Prop variants of Equiv?</p>",
        "id": 542308423,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759246526
    },
    {
        "content": "<p>Because to a point it already exists  :<a href=\"https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Init/Core.lean#L1307-L1323\">https://github.com/leanprover/lean4/blob/919e297292280cdb27598edd4e03437be5850221/src/Init/Core.lean#L1307-L1323</a></p>",
        "id": 542308650,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759246587
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> I don't think that it being in <code>Type</code> is a fundamental problem. However it seems to me that the main difficulty here is in generating the <code>@[gcongr]</code> lemmas.</p>\n<p>Can you say in more detail what you would want from this tactic? I'm not familiar with the original <code>transport</code> tactic. I might be interested in implementing this kind of tactic</p>",
        "id": 542323318,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1759250651
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/transport.20tactic/near/542302975\">said</a>:</p>\n<blockquote>\n<p>We often deal with isomorphic structures which are just different ways to talk about the same thing, but are computationally very different. For example adjacency matrices, adjacency lists, incidence matrices, and simplegraph, or different but equivalent computation models.</p>\n</blockquote>\n<p>Note the similarity to motivations for HoTT, a type theory in which isomorphism implies equality. So I would be curious to see the implementation and scope of a transport tactic.</p>",
        "id": 542325763,
        "sender_full_name": "Chris Henson",
        "timestamp": 1759251489
    },
    {
        "content": "<p>Do people have explicit examples of tactic steps for this tactic to do that aren't easy to do otherwise?</p>",
        "id": 542333686,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1759254043
    },
    {
        "content": "<p><a href=\"https://dl.acm.org/doi/10.1145/3737283\">This recent paper</a> is quite relevant. Cyril gave a talk about it at LftCM 2024 at CIRM.</p>",
        "id": 542339199,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1759255693
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"693714\">@Vincent Kuhlmann</span></p>",
        "id": 542339649,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759255878
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 542388482,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759278684
    },
    {
        "content": "<p>I would think of examples from this <a href=\"https://jfr.unibo.it/article/download/1574/1077\">paper</a></p>",
        "id": 542388525,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759278726
    },
    {
        "content": "<p>They just pick a different case of different data structures representing the same abstract data type. If you map Ordered sets to balanced search trees, you might want properties of ordered set operations to translate to their AVL tree representations.</p>",
        "id": 542388668,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759278847
    },
    {
        "content": "<p>And then from that to other search tree structures which have the ordering property for the children of each node.</p>",
        "id": 542388872,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1759279013
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/transport.20tactic/near/542339199\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://dl.acm.org/doi/10.1145/3737283\">This recent paper</a> is quite relevant. Cyril gave a talk about it at LftCM 2024 at CIRM.</p>\n</blockquote>\n<p>Yes it is quite an interesting framework regarding transport. I am currently writing an implementation for Lean, as part of my MSc thesis.</p>",
        "id": 542575668,
        "sender_full_name": "Vincent Kuhlmann",
        "timestamp": 1759350022
    },
    {
        "content": "<p>One reason why I'm interested in this is that I think that such a framework could be used to implement <code>to_additive</code>. Have you considered testing your implementation on some basic examples that <code>to_additive</code> handles?</p>",
        "id": 542724677,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1759406793
    },
    {
        "content": "<p>Good suggestion! I haven't yet, but will try how far I get. At first glance, I'm a bit unsure of how I could encode the heuristics that to_additive needs (i.e. it shouldn't blindly replace all multiplications with additions). Looking at the code of to_additive, it seems that most code is about the heuristics and the frontend/configuration. So this would only become more elegant if my implementation for Lean has plenty of powerful knobs to tweak its behaviour, and can hence replace a lot of that code. This will probably fall out of scope for my thesis project however, my goal is a proof of concept, with spare time spent on improving ergonomics and pretty printing.</p>\n<p>The strength of the Trocq framework lies more in transporting data types, with correspondence properties being modular so you only need to prove the minimum about them for what you need. Aside from equivalent and quotient types, this modular systems also allows for correspondences like <code>WithBot Nat</code> with <code>Nat</code>,  so statements can be guarded against junk values with little administrational overhead. The paper has an example of doing this with infinite sums, transporting <code>∀ (f g : seq_xnnR), Σ (f + g) = Σ f + Σ g</code> where summations yield infinity-aware values (think <code>WithBot Nat</code>) to <code>∀ (f g : summable), Σ (f + g) = Σ f + Σ g</code> where summations yield plain naturals.</p>",
        "id": 542826520,
        "sender_full_name": "Vincent Kuhlmann",
        "timestamp": 1759437175
    },
    {
        "content": "<p>Yes, I absolutely agree that actually integrating such a tool into <code>to_additive</code> would be a lot of extra work. But it could be interesting to see if it the tool also works in this context. There is indeed this issue in <code>to_additive</code> that we need a heuristic to figure out what to translate and what not, which is implemented in the <code>additiveTest</code> function that tells whether the type should be translated or not.</p>\n<p>I look forward to seeing what is possible with this kind of framework!</p>\n<p>One more example I have in mind, for which I also don't know if this is in scope, is in Euclidean geometry. The typical setup is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">MetricSpace</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddTorsor</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hd2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)]</span>\n</code></pre></div>\n<p>But proving things in this setup is equivalent to proving things with <code>V = P = ℝ × ℝ</code>, so it would be neat if you could replace <code>V</code> and <code>P</code> with <code>ℝ × ℝ</code> (using some equivalence like the one given by <code>finDimVectorspaceEquiv</code>)</p>",
        "id": 542850827,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1759451287
    }
]