[
    {
        "content": "<p>It'd be cool to have a 'rw' for inequalities. Say we have a goal <code>a ≤  b</code> and a hypothesis <code>h : c ≤  d</code>. The minimal useful product would basically be a macro that tries to unify <code>a</code> with <code>c</code> and <code>b</code> with <code>d</code>, and then chooses between <code>refine le_trans h ?_</code>, <code>refine le_trans ?_ h</code>, and <code>refine h</code> depending on the results.</p>",
        "id": 522472156,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1749082151
    },
    {
        "content": "<p>In fact I've written that much already:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">SimpRw</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Defs</span><span class=\"bp\">.</span><span class=\"n\">PartialOrder</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Expr</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">withRWRulesSeq</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">optConfig</span><span class=\"w\"> </span><span class=\"n\">rwRuleSeq</span><span class=\"w\"> </span><span class=\"n\">location</span><span class=\"w\"> </span><span class=\"n\">getConfigItems</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">relRewriteTarget</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TacticM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">withSynthesize</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">withMainContext</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getMainGoal</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"kt\">Prop</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">rhs</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferTypeQ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"bp\">.</span><span class=\"n\">getType</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwAbortTactic</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">hasSyntheticSorry</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">throwAbortTactic</span>\n<span class=\"w\">    </span><span class=\"c1\">-- let α ← Meta.inferType e</span>\n<span class=\"w\">    </span><span class=\"n\">forallTelescopeReducing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"kt\">Prop</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"bp\">«$</span><span class=\"n\">α</span><span class=\"bp\">»</span><span class=\"w\"> </span><span class=\"bp\">«$</span><span class=\"n\">inst</span><span class=\"bp\">»</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">h_lhs</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">h_rhs</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferTypeQ</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwAbortTactic</span>\n<span class=\"w\">      </span><span class=\"c1\">-- let stx ← lambdaTelescope</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">h_lhs</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">h_rhs</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">          </span><span class=\"n\">evalTactic</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">stx</span><span class=\"bp\">⟩</span><span class=\"o\">)))</span>\n<span class=\"w\">        </span><span class=\"k\">else</span>\n<span class=\"w\">          </span><span class=\"n\">evalTactic</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">stx</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"n\">evalTactic</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">stx</span><span class=\"bp\">⟩</span><span class=\"o\">)))</span>\n<span class=\"w\">      </span><span class=\"c1\">-- if let ~q(@LE.le $α $inst $lhs $rhs) := body then _</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"s2\">\"rel_rw\"</span><span class=\"w\"> </span><span class=\"n\">rws</span><span class=\"o\">:</span><span class=\"n\">rwRuleSeq</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">:(</span><span class=\"n\">location</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">withSimpRWRulesSeq</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">rws</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">loc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">expandOptLocation</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TSyntax</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"bp\">.</span><span class=\"n\">missing</span>\n<span class=\"w\">    </span><span class=\"n\">withLocation</span><span class=\"w\"> </span><span class=\"n\">loc</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">throwAbortTactic</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">relRewriteTarget</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">throwTacticEx</span><span class=\"w\"> </span><span class=\"ss\">`rel_rw</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"s2\">\"did not find instance of the pattern in the current goal\"</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rel_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 522472260,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1749082232
    },
    {
        "content": "<p>The more general concept is called generalized rewriting, which allows rewriting with inequalities, but also with e.g. equivalence relations. We've been wanting to have such a tactic for a long time, but looking at the PR it seems like we might get it soon: <a href=\"https://github.com/leanprover-community/mathlib4/pull/8167\">#8167</a></p>",
        "id": 522473047,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749082805
    },
    {
        "content": "<p>ooh, that <em>would</em> be nice</p>",
        "id": 522473092,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1749082822
    },
    {
        "content": "<p>I cut myself off because I thought I might have found an answer to my question but apparently I might just get an entire tactic for it instead</p>",
        "id": 522473176,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1749082873
    },
    {
        "content": "<p>Neat!</p>",
        "id": 522473178,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1749082874
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"359992\">@Robert Maxton</span>, thank you for reminding me about the need for this tactic. I've made an announcement at <a href=\"#narrow/channel/287929-mathlib4/topic/Announcement.3A.20New.20.60grw.60.20tactic\">#mathlib4 &gt; Announcement: New &#96;grw&#96; tactic</a> that the tactic is now available in mathlib.</p>",
        "id": 523970967,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749829542
    }
]