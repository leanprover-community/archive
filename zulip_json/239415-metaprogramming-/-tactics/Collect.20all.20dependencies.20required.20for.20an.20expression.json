[
    {
        "content": "<p>Is there a function that collects all fvars that are required for an expression to make sense?</p>\n<p>e.g., if I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>and the expression is <code>f c</code>, then both <code>b</code> and <code>c</code> would need to exist for this expression to make sense. However, <code>collectFVars</code> only collects <code>c</code>.</p>",
        "id": 536031812,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756130468
    },
    {
        "content": "<p>I'm not aware of such a function.</p>\n<p>In case it helps, I believe the specific situation you mention is not possible because <code>f</code> cannot be typed without mentioning <code>b</code> (i.e., <code>@f b c</code>), except if <code>f</code> is itself an fvar. Maybe there's an invariant here that can be exploited. Another corner case is unassigned mvars; there you'll have to assume that any fvar mentioned in the mvar's local context could potentially be used.</p>",
        "id": 536040114,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1756132708
    },
    {
        "content": "<p>First thing that comes to mind is that you could add <code>e := f c</code> to the local context then use <code>Lean.Meta.collectForwardDeps</code> on every preexisting local variable. The set of local variables that have <code>e</code> as a forward dependency consist of the minimal context for <code>f c</code>. This handles mvars too.</p>",
        "id": 536041823,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756133108
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Collect.20all.20dependencies.20required.20for.20an.20expression/near/536040114\">said</a>:</p>\n<blockquote>\n<p>I'm not aware of such a function.</p>\n<p>In case it helps, I believe the specific situation you mention is not possible because <code>f</code> cannot be typed without mentioning <code>b</code> (i.e., <code>@f b c</code>), except if <code>f</code> is itself an fvar. Maybe there's an invariant here that can be exploited. Another corner case is unassigned mvars; there you'll have to assume that any fvar mentioned in the mvar's local context could potentially be used.</p>\n</blockquote>\n<p>assume <code>f</code> is a constant</p>",
        "id": 536050142,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756135569
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">isValidChar</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- in this context the goal does not mention `n`</span>\n<span class=\"w\">  </span><span class=\"c1\">-- but the type of `m` depends on `n`</span>\n<span class=\"w\">  </span><span class=\"c1\">-- `Nat.isValidChar` is a constant</span>\n<span class=\"w\">  </span><span class=\"n\">trace_state</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 536052905,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756136419
    },
    {
        "content": "<p>I see what you mean. The example I showed I above is a bad one. This would make more sense:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and the expr is <code>f d</code>. In this case <code>b</code> and <code>c</code> are also dependencies. Or if the expr is just <code>c</code>, in which case <code>b</code> must also be a dependency.</p>",
        "id": 536055160,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756137053
    },
    {
        "content": "<p>What is your use case for this function?</p>",
        "id": 536056645,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756137462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Collect.20all.20dependencies.20required.20for.20an.20expression/near/536056645\">said</a>:</p>\n<blockquote>\n<p>What is your use case for this function?</p>\n</blockquote>\n<p>determine the minimal context for an expression</p>",
        "id": 536056688,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756137475
    },
    {
        "content": "<p>I found <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.findExprDependsOn#doc\">docs#Lean.findExprDependsOn</a></p>",
        "id": 536058161,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756137893
    },
    {
        "content": "<p>this would be great if the arguments <code>pf</code> and <code>pm</code> were monadic (but I guess then you wouldn't be able to cache it)</p>",
        "id": 536058508,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756137995
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Collect.20all.20dependencies.20required.20for.20an.20expression/near/536058161\">said</a>:</p>\n<blockquote>\n<p>I found <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.findExprDependsOn#doc\">docs#Lean.findExprDependsOn</a></p>\n</blockquote>\n<p>This doesn't work for the case where the expr is just <code>c</code></p>",
        "id": 536058816,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756138090
    },
    {
        "content": "<p>It does not signal that <code>b</code> is a dependency</p>",
        "id": 536058842,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1756138098
    },
    {
        "content": "<p>I found <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr.getMVarDependencies#doc\">docs#Lean.Expr.getMVarDependencies</a></p>",
        "id": 536058905,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756138117
    },
    {
        "content": "<p>it only works for mvar dependencies</p>",
        "id": 536058963,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756138138
    },
    {
        "content": "<p>You could loop through the local context in reverse and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.tryClear#doc\">docs#Lean.MVarId.tryClear</a> everything</p>",
        "id": 536059672,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756138364
    },
    {
        "content": "<p>I'll mention again that you can do <code>Lean.Meta.collectForwardDeps</code> on everything in the local context to figure out the correct dependencies. Adding the expression as a let variable is a trick to then let this computation process all the fvars and metavariables in your expression correctly.</p>",
        "id": 536060229,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756138535
    },
    {
        "content": "<p>Or there's the weird <code>mkLambdaFVars (&lt;- getLCtx).getFVars e (usedOnly := true)</code>, but you'll lose the connection to which fvar was actually used. It probably also needs a step to clear aux decls from the local context first.</p>",
        "id": 536060754,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756138703
    }
]