[
    {
        "content": "<p>Apologies for the basic question, which might be an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>. I have Lean terms that I want to manipulate using metaprogramming, so I'm trying to understand how to construct them using <code>MkAppN</code>. Is there a command I can run that will print out the underlying <code>Expr</code> for a term?</p>",
        "id": 533660625,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1754842354
    },
    {
        "content": "<p>Options:</p>\n<ul>\n<li><code>logInfo m!\"e = {e}\"</code> will pretty print the expression, and if you hover over things you can figure out how the expressions are constructed, if you know how surface syntax corresponds to lean terms (e.g. <code>@c.{u,v}</code> is <code>Expr.const c [u,v]</code>, <code>@f a b c</code> is <code>mkAppN f #[a, b, c]</code>, etc.). It's helpful to set <code>pp.explicit</code> and <code>pp.universes</code>.</li>\n<li><code>logInfo m!\"e = {repr e}\"</code> will show the constructors.</li>\n<li>If you do <code>deriving instance Lean.ToExpr for ...</code> enough times on all the types involved on <code>Lean.Expr</code>, then you can do <code>logInfo m!\"e = {Lean.toExpr e}\"</code>, which is like <code>repr</code>, but it'll be pretty printed nicer.</li>\n</ul>",
        "id": 533662427,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754844217
    },
    {
        "content": "<p>Thanks! It seems kind of strange to me that you need to instantiate more typeclasses to get Lean to display a Expr it already has access to, but this is good to know.</p>",
        "id": 533666861,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1754848493
    },
    {
        "content": "<p>To be clear, this is to get it to use <code>Lean.toExpr</code>, to make an <code>Expr</code> that represents the <code>Expr</code> term, to use the pretty printer. That's fancier output than the pre-existing <code>Repr</code> — doesn't seem so strange to me that fancier output might need some more work?</p>",
        "id": 533667666,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754849350
    },
    {
        "content": "<p>You can already do <code>{e}</code> to include the expression, but for your purpose, the problem is that it's giving you what the expression represents (that's what we usually want when debugging metaprograms), but you're wanting to see what a representation of the expression represents (that's to say, you want to pretty print Lean terms that represent an Expr that creates the Expr, rather than pretty print the Expr itself).</p>",
        "id": 533667902,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754849611
    },
    {
        "content": "<p>I'm not sure why exactly we don't have a ToExpr Expr instance in core yet, other than there haven't been any core applications that need it. (At least we've got the deriving handler so it doesn't have to be written by hand!)</p>",
        "id": 533667973,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754849683
    },
    {
        "content": "<p>Yeah it seems that you still need add <code>Repr</code> instances for some terms though, here's a (not self-contained) example</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">idk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NML</span><span class=\"bp\">.</span><span class=\"n\">ExecState</span><span class=\"w\"> </span><span class=\"n\">DataT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">ret</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">emp</span><span class=\"w\"> </span><span class=\"n\">DataT</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">idk</span>\n<span class=\"c1\">-- idk {DataT : Type} : NML.ExecState DataT</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"e = {repr idk}\"</span>\n<span class=\"c1\">-- failed to synthesize</span>\n<span class=\"c1\">--   Repr (NML.ExecState ?m.163)</span>\n<span class=\"c1\">-- #eval test</span>\n</code></pre></div>\n<p>I am looking for something even more unsophisticated, like \"if I can <code>#check X</code> then I can <code>#showexpr X</code>, even for open terms or for terms that are paramaterized by types that don't have <code>Repr</code>. It's fine if that doesn't exist, I can use it as a basic metaprogramming exercise anyways :)</p>",
        "id": 533668299,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1754850097
    },
    {
        "content": "<p>I see, I thought your question was \"I have an Expr, and I want to understand it\" not \"I have a run-time value, and I want to construct an Expr that represent it\", since you used the word \"term\". With metaprogramming, \"staging\" is very important to keep straight: is it a compile-time value (an Expr) or a runtime value (an <code>NML.ExecState DataT</code>).</p>",
        "id": 533668669,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754850535
    },
    {
        "content": "<p>The ToExpr deriving handler is a way to generate code to reflect runtime values back into Exprs that accurately represent those values.</p>",
        "id": 533668703,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754850580
    },
    {
        "content": "<p>When you write <code>idk</code> inside that <code>do</code>, you are evaluating <code>idk</code>, not accessing the Expr that represents it.</p>",
        "id": 533668722,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754850599
    },
    {
        "content": "<p>Here's a good metaprogramming exercise: look at the source code of <code>#check</code> and <code>#reduce</code>, and make a <code>#showexpr</code> that does what you want. Possibly you want to look at <code>#print</code> too, since that's able to print the bodies of definitions.</p>",
        "id": 533668807,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754850673
    },
    {
        "content": "<p>The broader point here is that Lean does not represent runtime values as Exprs, so there's no Expr to get.</p>",
        "id": 533668844,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754850744
    },
    {
        "content": "<p>That makes a lot of sense and was definitely a misconception I've been struggling with (I think specifically coming from Racket). Thank you for explaining it!</p>",
        "id": 533669102,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1754851065
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"721721\">@Markus de Medeiros</span> the definition of something is stored in an \"eq\" theorem</p>",
        "id": 533671979,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754854386
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">37</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">eq_1</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">eq_1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferTypeQ</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">()</span>\n<span class=\"w\">  </span><span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">debug</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{P}\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">rhs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">()</span>\n<span class=\"w\">  </span><span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">debug</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{rhs}\"</span>\n<span class=\"w\">  </span><span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">debug</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{rhs}\"</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">debug</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">test</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">[debug] e = 37</span>\n<span class=\"cm\">[debug] 37</span>\n<span class=\"cm\">[debug] OfNat.ofNat.{0} Nat 37 (instOfNatNat 37)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 533672270,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754854776
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"721721\">@Markus de Medeiros</span> is this closer to what you want?</p>",
        "id": 533672280,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754854782
    },
    {
        "content": "<p>Kenny, the definition is stored in the declaration in the environment. The eq theorems are largely for reasoning about recursive functions, to hide the way the recursion was encoded. (In particular, the function can appear both on the LHS and RHS.) I would not use these here.</p>",
        "id": 533672611,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754855165
    },
    {
        "content": "<p>well, I wrote a suboptimal code in the hopes that someone would improve upon it, because having a bad code is better than no code</p>",
        "id": 533672645,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754855209
    },
    {
        "content": "<p>i think there is <code>ppExpr</code> as an helper to pretty print an Expr</p>",
        "id": 539190552,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1757728294
    }
]