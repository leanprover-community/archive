[
    {
        "content": "<p>I'm writing some metaprograms which involve constructing <code>Expr</code>s that use <code>match</code> statements. So far, I've been able to get away with writing recursor applications \"by hand\", ie by manually constructing the motive, the types of each branch etc, which is not the same, but is good enough for my application. </p>\n<p>This technique is getting fairly cumbersome as I try to support matching with more complex types, so I'm wondering if there's a better way. What is the \"happy path\" for generating an <code>Expr</code> that includes a match?</p>",
        "id": 538000187,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1757162697
    },
    {
        "content": "<p>You need to use <code>mkMatcher</code>. Here's an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simpleMatch</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">b</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Match</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"test \"</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">discr</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabTermEnsuringTypeQ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">matcher</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkMatcher</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">matcherName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAuxDeclName</span><span class=\"w\"> </span><span class=\"ss\">`match</span>\n<span class=\"w\">    </span><span class=\"n\">matchType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">discrInfos</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[{}]</span>\n<span class=\"w\">    </span><span class=\"n\">lhss</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">      </span><span class=\"o\">{</span>\n<span class=\"w\">        </span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getRef</span>\n<span class=\"w\">        </span><span class=\"n\">fvarDecls</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">        </span><span class=\"n\">patterns</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">ctor</span><span class=\"w\"> </span><span class=\"ss\">``List.nil</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[]]</span>\n<span class=\"w\">      </span><span class=\"o\">},</span>\n<span class=\"w\">      </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">withLocalDeclDQ</span><span class=\"w\"> </span><span class=\"ss\">`a</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">withLocalDeclDQ</span><span class=\"w\"> </span><span class=\"ss\">`b</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">withLocalDeclDQ</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">withLocalDeclDQ</span><span class=\"w\"> </span><span class=\"ss\">`x_eq</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x_eq</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">          </span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getRef</span>\n<span class=\"w\">          </span><span class=\"n\">fvarDecls</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x_eq</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">fvarId!</span><span class=\"bp\">.</span><span class=\"n\">getDecl</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"n\">patterns</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">            </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">ctor</span><span class=\"w\"> </span><span class=\"ss\">``List.cons</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)]</span>\n<span class=\"w\">              </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fvarId!</span>\n<span class=\"w\">                </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ctor</span><span class=\"w\"> </span><span class=\"ss\">``Prod.mk</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">fvarId!</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">fvarId!</span><span class=\"o\">])</span>\n<span class=\"w\">                </span><span class=\"n\">x_eq</span><span class=\"bp\">.</span><span class=\"n\">fvarId!</span><span class=\"o\">,</span>\n<span class=\"w\">                </span><span class=\"bp\">.</span><span class=\"n\">ctor</span><span class=\"w\"> </span><span class=\"ss\">``List.nil</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[]]]</span>\n<span class=\"w\">        </span><span class=\"o\">},</span>\n<span class=\"w\">      </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">withLocalDeclDQ</span><span class=\"w\"> </span><span class=\"ss\">`a</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">withLocalDeclDQ</span><span class=\"w\"> </span><span class=\"ss\">`b</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">withLocalDeclDQ</span><span class=\"w\"> </span><span class=\"ss\">`c</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">          </span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getRef</span>\n<span class=\"w\">          </span><span class=\"n\">fvarDecls</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">fvarId!</span><span class=\"bp\">.</span><span class=\"n\">getDecl</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"n\">patterns</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">            </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">ctor</span><span class=\"w\"> </span><span class=\"ss\">``List.cons</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)]</span>\n<span class=\"w\">              </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">fvarId!</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ctor</span><span class=\"w\"> </span><span class=\"ss\">``List.cons</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)]</span>\n<span class=\"w\">                </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">ctor</span><span class=\"w\"> </span><span class=\"ss\">``Prod.mk</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">fvarId!</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">((</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))],</span>\n<span class=\"w\">                  </span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">fvarId!</span><span class=\"o\">]]]</span>\n<span class=\"w\">        </span><span class=\"o\">},</span>\n<span class=\"w\">      </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">withLocalDeclDQ</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">          </span><span class=\"n\">ref</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getRef</span>\n<span class=\"w\">          </span><span class=\"n\">fvarDecls</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fvarId!</span><span class=\"bp\">.</span><span class=\"n\">getDecl</span><span class=\"o\">]</span>\n<span class=\"w\">          </span><span class=\"n\">patterns</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fvarId!</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">matcher</span><span class=\"bp\">.</span><span class=\"n\">addMatcher</span>\n<span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">matcher</span><span class=\"bp\">.</span><span class=\"n\">matcher</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">alt1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">alt2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">alt3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">alt4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">((</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">mkAppN</span><span class=\"w\"> </span><span class=\"n\">matcher</span><span class=\"bp\">.</span><span class=\"n\">matcher</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">motive</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">discr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">alt1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">alt2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">alt3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">alt4</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simpleMatchWithElab</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p><code>mkMatcher</code> takes in a matcher input and then creates a matcher function and returns (among other things for error reporting) a side effect to add the matcher to the environment (<code>addMatcher</code>) and a matcher expression.<br>\nLet's first look through the matcher input:<br>\nFirst is the matcher name. This is the name under which the matcher will be added into the environment when <code>addMatcher</code> is run. You can use some specific name but usually you'll just use <code>mkAuxDeclName `match</code> which adds it under the name <code>&lt;declname&gt;.match_&lt;n&gt;</code>.<br>\nThe next part is the matcher type. This should just consist of nested foralls (one for each discriminant) and one final inner type. Which type you choose here doesn't really matter as long as it lives in the same universe as the type the <code>match</code> should have at the end. For example you can use <code>True</code> here if you want to use <code>match</code> within a proof, or <code>Unit</code> if the type is of type <code>Type</code> (e.g. <code>Bool</code> in this example), or in general <code>PUnit.{u}</code> with the right universe level.<br>\nThen comes <code>discrInfos</code>: This contains information for each discriminant whether you want an equality hypothesis and if yes under which name (in the sense of <code>match h : n with ...</code> where you would have the equality hypothesis with name <code>h</code>).<br>\nLastly and most importantly <code>lhss</code>: This provides the left-hand sides of all alternatives (i.e. what you match with). Each left-hand side then contains a <code>ref</code> for error reporting but more importantly, <code>patterns</code> and <code>fvarDecls</code>. Each pattern in the <code>patterns</code> list corresponds to a pattern in the left-hands side of the alternative so you have as many patterns as you have discriminants. <code>fvarDecls</code> then should contain <code>LocalDecl</code>s for every variable bound by the pattern. Why do you need this? Well, for one this describes the order of variables for the alternative of the resulting matcher (so make sure the variables are in dependency order!) but also you might've noticed that I wrapped the <code>AltLHS</code> creation within <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.withLocalDecl#doc\">docs#Lean.Meta.withLocalDecl</a>​s -- that means that I added declarations to the local context that exist while we're constructing the <code>AltLHS</code> but don't exist anymore after that and in particular not when we run <code>mkMatcher</code>. So with <code>fvarDecls</code> we provide the information of the name, type and id of the free variables (retrievable through <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.FVarId.getDecl#doc\">docs#Lean.FVarId.getDecl</a>) so that <code>mkMatcher</code> can later add them back with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.withExistingLocalDecls#doc\">docs#Lean.Meta.withExistingLocalDecls</a>.<br>\nNow for the description of the different pattern kinds:</p>\n<ul>\n<li><code>.var v</code> is simply a variable pattern, something like <code>_a</code>, <code>_b</code>, <code>_c</code> in my example. Note that free variables are usually passed around as expressions and here <code>v</code> is directly an <code>FVarId</code> so you might need to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr.fvarId%21#doc\">docs#Lean.Expr.fvarId!</a> to get what you need.</li>\n<li><code>.ctor ctorName levelParams params fields</code> represents the application of constructor (specifically <code>@ctorName.{levelParams...} params... fields...</code>). <code>params</code> are the arguments to the constructor that you can't match on (usually implicits), specifically, <code>#print &lt;inductive type&gt;</code> shows you how many of them your inductive type has. The remaining arguments, the fields, are arguments of the constructor that you can match on, so in constrast to the parameters (which are provided as <code>Expr</code>s), those are provided as patterns. As an example, take the <code>(_a, _b)</code> in the second alternative of <code>simpleMatch</code>: With universes and explicit parameters, this looks like <code>@Prod.mk.{0, 0} Nat Nat _a _b</code>, so you have <code>ctorName = ``Prod.mk</code>, <code>levelParams = [0, 0]</code>, <code>params = [Nat, Nat]</code> and <code>patterns = [_a, _b]</code>.</li>\n<li><code>.val e</code> allows you to have \"exact matches\", i.e. to match on a specific exact value. The usual case for these is numbers but <code>match</code> allows you to use any expression of a type with decidable equality.</li>\n<li><code>.as xId pattern hId</code> represents the named pattern <code>x@h:pattern</code>. Note that in the usual match syntax, the equality variable is optional; here you need to specify it explicitly. In principle, this is similar to <code>.var</code> where you bind the pattern in the variable <code>xId</code> (again, <code>FVarId</code>, not <code>Expr</code>) but you additionally provide a pattern to match further and a variable <code>hId : x = pattern</code>.</li>\n<li><code>.inaccessible e</code> is for inaccessible patterns (<code>.(e)</code>). Inaccessible patterns are values that aren't matched on any further but have a concrete value forced by the typing of the remaining patterns. As an example, take:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">TestType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TestType</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TestType</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">   </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Since the value for <code>n</code> needs to change in the <code>.one</code> branch (previously <code>TestType n</code>, now <code>TestType 1</code>), we also need to match on <code>n</code>. Since the value is here forced to be 1 through the typing of <code>h : TestType 1</code>, we use an inaccessible pattern:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TestType</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">   </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This is stuff <code>match</code> usually does for you but that needs to be taken into consideration when using <code>mkMatcher</code>.</p>\n<ul>\n<li>Finally, there's <code>.arrayLit type patterns</code>. This one is for the array literal <code>(#[patterns...] : Array type)</code>. Similarly to <code>.ctor</code> we simply have the element type as a \"parameter\" and then patterns for each element we want to match on.</li>\n</ul>\n<p>Finally some more information on the output of <code>mkMatcher</code>, specifically, the <code>matcher</code> expression: The first thing it takes is the motive which needs to have one parameter per discriminant and needs to live in the same universe as the body of <code>matchType</code>. After that come all of the discriminants that we want to match on. Lastly, we can provide all the right hand sides of the alternatives which should take in parameters in the order they were provided in <code>fvarDecls</code> and then (if applicable) for each discriminant with an equality hypothesis name specified in <code>discrInfos</code>, such an equality (<code>h : discriminant = pattern</code>). If an alternative has no <code>fvarDecls</code> and we also have no discriminants with equality hypotheses, the alternative will instead need to take in a single parameter of type <code>Unit</code> (such as seen in the first alternative in my example).</p>",
        "id": 538009090,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757170116
    },
    {
        "content": "<p>Thank you for the thorough explanation , I think this will take me a while to digest but it does look like what I'm after.</p>",
        "id": 538010229,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1757171099
    }
]