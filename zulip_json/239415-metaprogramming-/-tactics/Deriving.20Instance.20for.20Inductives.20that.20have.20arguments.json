[
    {
        "content": "<p>Hi! I'm currently trying to implement my own deriving instance. Here's the context:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- A typeclass that describes whether the proposition `P` is  partially decidable</span>\n<span class=\"c1\">-- (details are not important)</span>\n<span class=\"c1\">-- I'd like the user to be able to write `deriving DecOpt` for an `inductive` relation</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">DecOpt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n\n<span class=\"c1\">-- Here's an example inductive relation:</span>\n<span class=\"c1\">-- `typing Γ e τ` represents a typing derivation `Γ ⊢ e : τ`</span>\n<span class=\"c1\">-- (assume that the `type` and `term` inductives have already been defined)</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">typing</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>I'd like the user to be able to write <code>deriving instance DecOpt for (typing Γ e τ)</code>, but Lean complains that this is invalid syntax. Alternatively, if the user just writes <code>deriving DecOpt</code> underneath the definition of the <code>typing</code> <code>inductive</code>, the named arguments <code>Γ, e, τ</code> are not available to the deriving handler and the code is ill-typed (since <code>DecOpt</code> expects a <code>Prop</code> as its argument). Is there a way to implement a deriving handler for <code>inductive</code>s that are parameterized by 1 or more arguments? Thanks!</p>",
        "id": 521335672,
        "sender_full_name": "Ernest Ng",
        "timestamp": 1748623913
    },
    {
        "content": "<p>If this is not possible, would it be advisable for me to just implement a command elaborator instead? (e.g. implement an elaborator for the command <code>#derive_decopt</code> such that the user can write <code>#derive_decopt typing Γ e τ</code>)</p>",
        "id": 521336560,
        "sender_full_name": "Ernest Ng",
        "timestamp": 1748624192
    },
    {
        "content": "<p>I'm not sure why you'd need to provide these explicitly unless you want to have concrete values for <code>Γ</code>, <code>e</code> and <code>τ</code>. Otherwise you should be able to access the inductive definition and make such parameters yourself..?</p>",
        "id": 521340432,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1748625690
    },
    {
        "content": "<p>Oh right, good point, thanks! I guess I can always generate fresh names for each of these parameters.</p>",
        "id": 521347781,
        "sender_full_name": "Ernest Ng",
        "timestamp": 1748628427
    },
    {
        "content": "<p>Have you been referring to the existing deriving handlers?</p>",
        "id": 521355174,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748631635
    },
    {
        "content": "<p>Yep! I've been looking at the source code for the <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Deriving/BEq.lean\"><code>Beq</code> deriving handler</a> as well as the section in the <a href=\"https://lean-lang.org/doc/reference/latest/Type-Classes/Deriving-Instances/\">language reference</a></p>",
        "id": 521360467,
        "sender_full_name": "Ernest Ng",
        "timestamp": 1748633873
    },
    {
        "content": "<p>I was asking because these deriving handlers all handle this issue.</p>\n<p>There are also some more deriving handlers in Mathlib that might be useful to look at, for example <code>Mathlib/Tactic/Derive*.lean</code>. The <code>Fintype</code> handler is the briefest, where it uses <code>Deriving.mkHeader</code> to create the header with the fresh names: <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/DeriveFintype.lean#L91-L102\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/DeriveFintype.lean#L91-L102</a></p>",
        "id": 521376059,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748641549
    },
    {
        "content": "<p>Thanks a lot! The <code>Fintype</code> handler code is very helpful -- I'll look into using <code>mkHeader</code>!</p>",
        "id": 521377689,
        "sender_full_name": "Ernest Ng",
        "timestamp": 1748642489
    },
    {
        "content": "<p>BEq uses it too: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Deriving/BEq.lean#L16\">https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Deriving/BEq.lean#L16</a></p>",
        "id": 521378643,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748643099
    },
    {
        "content": "<p>Ah yes good point thanks!</p>",
        "id": 521449879,
        "sender_full_name": "Ernest Ng",
        "timestamp": 1748703730
    }
]