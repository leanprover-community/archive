[
    {
        "content": "<p>BTW, if we have this syntax, then we can try to migrate to \"all classes with many fields are in <code>Prop</code>\". E.g.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Mul</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Semigroup</span> <span class=\"n\">α</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[[</span><span class=\"n\">Semigroup</span> <span class=\"n\">α</span><span class=\"o\">]]</span>\n</code></pre></div>",
        "id": 328418635,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1676625488
    },
    {
        "content": "<p>Hmm, if we moved to classes like that being in Prop, would demonstrating equality between e.g. two semigroups get more complicated? We’d have to use heterogenous equality if the <code>Mul</code> instances weren’t defeq, right?</p>",
        "id": 328432048,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676629303
    },
    {
        "content": "<p>When is equality between semigroups demonstrated? This never happens, except possibly in Eckmann-Hilton.</p>",
        "id": 328434426,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1676630019
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> Yes, Reid has been convincing me that we should make that refactor (after the port).</p>",
        "id": 328434661,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1676630104
    },
    {
        "content": "<p>It would probably speed up a lot of TC inferences and avoid a whole list of problems that we are currently seeing.</p>",
        "id": 328434794,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1676630153
    },
    {
        "content": "<p>I remember being told that that design is particularly prone to exponential blowup, but maybe all paths lead to blowup anyway. It would certainly be a good thing to try</p>",
        "id": 328435929,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676630458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.20normal.20form.3A.20ofNat.20or.20Nat.2Ecast.3F/near/328434426\">said</a>:</p>\n<blockquote>\n<p>When is equality between semigroups demonstrated? This never happens, except possibly in Eckmann-Hilton.</p>\n</blockquote>\n<p>Are you saying we only talk about equalities between class instances when their data fields are defeq, though? Because this would affect much more than semigroups</p>",
        "id": 328437048,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676630801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.20normal.20form.3A.20ofNat.20or.20Nat.2Ecast.3F/near/328435929\">said</a>:</p>\n<blockquote>\n<p>I remember being told that that design is particularly prone to exponential blowup, but maybe all paths lead to blowup anyway. It would certainly be a good thing to try</p>\n</blockquote>\n<p>The idea would be to have just two levels, data and properties. With a bunch of unrelated data classes, and using <code>extends</code> or equivalent for properties.</p>",
        "id": 328438713,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676631372
    },
    {
        "content": "<p>It's very rare to have non-defeq instances</p>",
        "id": 328438719,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676631376
    },
    {
        "content": "<p>No, I'm saying that we don't talk about equality of typeclasses (except maybe <a href=\"https://leanprover-community.github.io/mathlib_docs/find/topological_space\">docs#topological_space</a>). This is (close to) evil. Instead, we talk about isomorphisms.</p>",
        "id": 328439126,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1676631514
    },
    {
        "content": "<p>Hmm, okay. I would have imagined there might be some issues where e.g. we have two non-defeq phrasings of a structure instance’s zero element, but now some rewrites of something which depends on that structure instance can’t be done, because the types have to change. But maybe we don’t want to ever do things like this, or maybe we have tools to handle it if we do…</p>",
        "id": 328442203,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676632512
    },
    {
        "content": "<p>In mathlib 3 we tried our very best to make sure that the data fields were always defeq. There are some known exceptions to this, but they typically cause trouble.</p>",
        "id": 328442582,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1676632638
    },
    {
        "content": "<p>The only instances on the same type that I can think of which are not defeq are so because they're not equal at all</p>",
        "id": 328443304,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676632851
    },
    {
        "content": "<p>I’m not actually worrying about having two declared instances which are equal but not defeq per se—I’m worried about needing to rewrite data within instances in the course of proving something about them, or in order to get something else working which depends on the instance but needs the data to be in a certain non-defeq form. But maybe I’m over-anticipating and this isn’t a real problem…or maybe this way of doing things would trivialize those problems somehow.</p>",
        "id": 328444402,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676633202
    },
    {
        "content": "<p>We have lemmas like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid.ext\">docs#monoid.ext</a>. Indeed, with this refactor it's not clear how to state them but they are very rarely used.</p>",
        "id": 328484281,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1676644358
    },
    {
        "content": "<p>I think the statement would be that <code>(m n : monoid_data M) [is_monoid m] [is_monoid n] (h : m.mul = n.mul) : m = n</code>, if I understand <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> correctly</p>",
        "id": 328484625,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676644446
    },
    {
        "content": "<p>Probably with more <code>@</code>s</p>",
        "id": 328484655,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676644459
    },
    {
        "content": "<p>No, I think it would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">monoid_data</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">is_monoid</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">is_monoid</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">h1</span> <span class=\"bp\">=</span> <span class=\"n\">h2</span>\n</code></pre></div>",
        "id": 328484843,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1676644516
    },
    {
        "content": "<p>Note that in your example, <code>m.one</code> and <code>n.one</code> have no reason to be equal.</p>",
        "id": 328484920,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1676644541
    },
    {
        "content": "<p>Or maybe that was somehow part of your <code>h</code>?</p>",
        "id": 328485044,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1676644567
    },
    {
        "content": "<p>Yes, claiming equality of two proofs makes no sense.</p>",
        "id": 328485124,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1676644588
    },
    {
        "content": "<p>Anyway, we should probably start thinking seriously about this refactor ~ 4 months from now.</p>",
        "id": 328485243,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1676644620
    },
    {
        "content": "<p>Do you suggest that we have a <code>MonoidData</code> typeclass, not just <code>Mul</code>, <code>One</code>, <code>Pow</code>?</p>",
        "id": 328485305,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1676644633
    },
    {
        "content": "<p>I would go with just <code>Mul</code>, <code>One</code> etc... But that will require better auto-implicit support.</p>",
        "id": 328485367,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1676644657
    },
    {
        "content": "<p>Will this create the same problems with structure projections that we have now?</p>",
        "id": 328485390,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1676644662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.20normal.20form.3A.20ofNat.20or.20Nat.2Ecast.3F/near/328484920\">said</a>:</p>\n<blockquote>\n<p>Note that in your example, <code>m.one</code> and <code>n.one</code> have no reason to be equal.</p>\n</blockquote>\n<p>The whole point of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid.ext\">docs#monoid.ext</a> is to show that the ones are equal if the <code>mul</code>s are</p>",
        "id": 328485406,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676644666
    },
    {
        "content": "<p>We can't do this refactor during the port, and we can't do the port without a good solution to <a href=\"https://github.com/leanprover/lean4/pull/2074\">lean4#2074</a>... even though this refactor might make such a solution superfluous.</p>",
        "id": 328485917,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1676644753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.20normal.20form.3A.20ofNat.20or.20Nat.2Ecast.3F/near/328485406\">said</a>:</p>\n<blockquote>\n<p>The whole point of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid.ext\">docs#monoid.ext</a> is to show that the ones are equal if the <code>mul</code>s are</p>\n</blockquote>\n<p>If this is the point, then it can be stated in that form</p>",
        "id": 328486263,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676644831
    },
    {
        "content": "<p>Absolutely; but if <code>monoid_data</code> does exist, then it's probably handy to have that version too. If it doesn't, then <code>monoid.ext</code> isn't a reason to make <code>monoid_data</code> exist.</p>",
        "id": 328486417,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676644871
    },
    {
        "content": "<p>If <code>MonoidData</code> does exist, it certainly shouldn't be a class... that is exactly how to get back to the current problems.</p>",
        "id": 328486910,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676644996
    },
    {
        "content": "<p>I think it avoids the current problem if <code>MonoidData</code> extends <code>One, Mul</code> instead of <code>SemigroupData</code></p>",
        "id": 328501265,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676648643
    },
    {
        "content": "<p>Assuming the \"current problem\" is 2074</p>",
        "id": 328501311,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676648652
    },
    {
        "content": "<p>The root issue is that there is more than one place to look to find out what <code>a * b</code> means</p>",
        "id": 328510647,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676650997
    },
    {
        "content": "<p>Doesn't this (i.e., <code>MonoidData</code> extending <code>One, Mul</code>) just amount to reverting to old structures? Or is the point that we generally have many more <code>Prop</code> fields than data fields, and we can lump all the <code>Prop</code> fields into a separate structure so we don't have to check them?</p>",
        "id": 328513888,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1676651857
    },
    {
        "content": "<p>Yes, it's comparable to using old structures</p>",
        "id": 328515267,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676652219
    },
    {
        "content": "<p>I don't recommend having <code>MonoidData</code> at all, and I don't understand why it came up</p>",
        "id": 328515399,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676652253
    },
    {
        "content": "<p>Instead, <code>Monoid</code> is a mix-in indexed on <code>One</code> and <code>Mul</code>, and it's a proposition. As are the other 99999 classes you can put on top of <code>One</code> and <code>Mul</code>.</p>",
        "id": 328515500,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676652287
    },
    {
        "content": "<p>You don't have to worry about diamonds here, because they are all propositions.</p>",
        "id": 328515568,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676652309
    },
    {
        "content": "<p>I guess another advantage is that it's usually going to be much quicker to find a <code>Mul</code> when you write <code>x * y</code> if there are no <code>CommRing.toCommMonoid.toCommSemigroup.toSemigroup.toMul</code> long paths to find and check equality of.</p>",
        "id": 328515911,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1676652392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.20normal.20form.3A.20ofNat.20or.20Nat.2Ecast.3F/near/328513888\">said</a>:</p>\n<blockquote>\n<p>Or is the point that we generally have many more <code>Prop</code> fields than data fields, and we can lump all the <code>Prop</code> fields into a separate structure so we don't have to check them?</p>\n</blockquote>\n<p>More that we have many more <code>Prop</code> <em>classes</em> (e.g. <code>CanionicallyLinearOrderedNonCommSemifield</code>) than actual kinds of data.</p>",
        "id": 328515967,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676652413
    },
    {
        "content": "<p>My main fear with that design is seeing all the arguments to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Injective.ring#doc\">docs4#Function.Injective.ring</a> every time we need a ring</p>",
        "id": 328516061,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676652454
    },
    {
        "content": "<p>Right, it would need some language support and that's why it was never a real option in Lean 3.</p>",
        "id": 328516177,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676652485
    },
    {
        "content": "<p>Er wait</p>",
        "id": 328516225,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676652503
    },
    {
        "content": "<p>I would be really afraid of exponential blow-up if you don't bundle data. For instance, if you don't package zero, one, add, mul and neg into a <code>RingData</code>, then anything building on a ring would have these 5 dependencies. Which is really bad if you construct a ring depending on two rings and iterate this (say, taking a product of two rings, and then the ring of polynomials on this new ring, and then a quotient of this one).</p>",
        "id": 328516240,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1676652511
    },
    {
        "content": "<p><code>[Zero β] [One β] [Add β] [Mul β] [Neg β] [Sub β] [SMul ℕ β] [inst : SMul ℤ β] [Pow β ℕ] [NatCast β] [IntCast β] [Ring β]</code></p>",
        "id": 328516245,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676652515
    },
    {
        "content": "<p>Oh, you mean the <em>class</em> arguments right?</p>",
        "id": 328516258,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676652521
    },
    {
        "content": "<p>Yes.</p>",
        "id": 328516261,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676652522
    },
    {
        "content": "<p>Not the axioms though.</p>",
        "id": 328516275,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676652527
    },
    {
        "content": "<p>While having a <code>RingData</code> and a <code>RingProp</code> wouldn't lead to exponential blowup, while ensuring much shorter paths when checking that two multiplications coincide, say.</p>",
        "id": 328516446,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1676652577
    },
    {
        "content": "<p>Even if we have magic to <em>insert</em> the 11 data typeclass arguments I have above, we also need to consider their presence in:</p>\n<ul>\n<li>The goal view</li>\n<li>The web docs</li>\n<li>Help tooltips</li>\n</ul>",
        "id": 328516850,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676652689
    },
    {
        "content": "<p>RingData + RingProp is I believe what Agda does</p>",
        "id": 328517056,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676652735
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.20normal.20form.3A.20ofNat.20or.20Nat.2Ecast.3F/near/328516446\">said</a>:</p>\n<blockquote>\n<p>while ensuring much shorter paths when checking that two multiplications coincide, say</p>\n</blockquote>\n<p>The claim is you should never have to do this (and should never do it).</p>",
        "id": 328517272,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676652806
    },
    {
        "content": "<p>Where the former has the latter as a field</p>",
        "id": 328517289,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676652811
    },
    {
        "content": "<p>The reason that you have to do it in mathlib is that you might get <code>*</code> from a CommSemiring in one place and from a GroupWithZero in another place</p>",
        "id": 328517527,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676652862
    },
    {
        "content": "<p>It's possible that adding <code>RingData</code> doesn't disturb this property meaningfully, I'm not sure.</p>",
        "id": 328518032,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676652993
    },
    {
        "content": "<p>Maybe you want to arrange the instances the other way: rather than \"if you have <code>RingData</code> then you have <code>Mul</code>\", it should be \"if you have <code>Mul</code> and <code>Add</code> and ... then you have <code>RingData</code>\"</p>",
        "id": 328518331,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676653071
    },
    {
        "content": "<p>One possible downside of the 11-single-field-typeclass approach is that to synthesize prod.ring you now have to synthesize each data field individually, so do 24 typeclass searches</p>",
        "id": 328518665,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676653152
    },
    {
        "content": "<p>That is <em>way</em> less than the amount of work the TC algorithm does today. Because each search will be constant time.</p>",
        "id": 328518984,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676653220
    },
    {
        "content": "<p>I think there are two possible problems:</p>\n<ul>\n<li>what we have currently: very long paths which lead to non-obviously defeq stuff, coming from too much bundling</li>\n<li>exponential blow-up if there is not enough bundling (there was a paper that has already been mentioned on Zulip showing that, if the data fields of a ring are not bundled, then the product of 4 or 5 rings is essentially unmanageable).</li>\n</ul>\n<p><code>RingData</code> and <code>RingProp</code> do not solve perfectly either of the two issues, but they still seem to me to be a reasonable balance.</p>",
        "id": 328520475,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1676653620
    },
    {
        "content": "<blockquote>\n<p>what we have currently: very long paths which lead to non-obviously defeq stuff, coming from too much bundling</p>\n</blockquote>\n<p>This isn't non-obvious in lean3, is it? You just unfolds all the typeclass constructors and projections, then you equate all the fields. It's only non-obvious with new-style structures because there isn't always a constructor to unfold.</p>",
        "id": 328521226,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676653814
    },
    {
        "content": "<blockquote>\n<p>I think there are two  possible problems:</p>\n</blockquote>\n<p>RingProp (either with <code>RingData</code> or separate arguments) also solves a third one, which is \"I can't add another property to monoids without duplicating the whole heirarchy for rings\"; for instance, <code>idem_semiring</code> doesn't have non-assoc versions because it generates a tonne of boilerplate. <code>[SemiringData R] [NonAssocSemiring R] [IdemSemiring R]</code> solves that.</p>",
        "id": 328521825,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676653971
    },
    {
        "content": "<p>61 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/simp.20normal.20form.3A.20ofNat.20or.20Nat.2Ecast.3F\">#mathlib4 &gt; simp normal form: ofNat or Nat.cast?</a> by <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>.</p>",
        "id": 328526324,
        "sender_full_name": "Notification Bot",
        "timestamp": 1676655219
    },
    {
        "content": "<p>I think my preference would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">IsMonoid</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Pow</span> <span class=\"n\">M</span> <span class=\"n\">Nat</span><span class=\"o\">]</span> <span class=\"bp\">...</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n    <span class=\"n\">one_mul</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n    <span class=\"n\">mul_one</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n    <span class=\"n\">mul_assoc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Monoid</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">One</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">Mul</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">Pow</span> <span class=\"n\">M</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">IsMonoid</span> <span class=\"n\">M</span>\n\n<span class=\"sd\">/-- needed so that we can still be lazy and write `Monoid M`, but the lemmas still apply to wackier cases where all the typeclasses are separate -/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">Monoid.reassemble</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Pow</span> <span class=\"n\">M</span> <span class=\"n\">Nat</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Monoid</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 328527048,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676655431
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Are you thinking of <a href=\"https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html\">https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html</a> ?</p>",
        "id": 328534600,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1676657677
    },
    {
        "content": "<p>This is an interesting proposal, but we should almost certainly not think about it during the port.</p>",
        "id": 328541581,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1676659959
    },
    {
        "content": "<p>I don't see any exponential blow-up issues, Ralf's set up is different.</p>",
        "id": 328541695,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1676659994
    },
    {
        "content": "<p><code>RingData</code>/<code>RingProp</code> combines the worst features of both approaches.  We both get complicated projections in operations, as well as all the UX issues. I don't think that's a good idea.</p>",
        "id": 328541936,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1676660074
    },
    {
        "content": "<p>Something we <em>might</em> want to consider in the port, if <a href=\"https://github.com/leanprover/lean4/pull/2074\">lean4#2074</a> remains tricky to resolve, would be forward-porting old-style classes</p>",
        "id": 328542350,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676660206
    },
    {
        "content": "<blockquote>\n<p>That is way less than the amount of work the TC algorithm does today. Because each search will be constant time.</p>\n</blockquote>\n<p>This point is way overstated.  You'll still need to search for <code>Monoid (R × S)</code>/etc. if you want to apply simp lemmas, etc.  And that would work the same as it does now.</p>",
        "id": 328542523,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1676660258
    },
    {
        "content": "<blockquote>\n<p>UX issues</p>\n</blockquote>\n<p>One kind of UX issue has already been mentioned: inputting the TC arguments.  This will require some core changes (because it needs to work in <code>def</code> etc.).  So this will be a bit difficult right now.  But I think longer time we want extensible binders anyhow.</p>",
        "id": 328543242,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1676660477
    },
    {
        "content": "<p>But there's also another UX issue.  Namely if you have 2 field arguments you'll suddenly have 24 (?) extra elements in your local context.  We'd need some way to manage that (everywhere!, error messages, infoview, etc.)</p>",
        "id": 328543249,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1676660478
    },
    {
        "content": "<p>Unbundled classes would make some things nicer though.  For example it would make <code>NormedSpace</code> look syntactically the same as <code>Field</code>.  That is, you don't need to know that <code>A</code> is a normed field and <code>B</code> is a seminormed additive commutative group to even write <code>NormedSpace A B</code>.</p>",
        "id": 328543920,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1676660711
    },
    {
        "content": "<p>I'm of the opinion that we should unbundled the <code>normed_ring</code> classes to match what we did with <code>topological_ring</code></p>",
        "id": 328544474,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676660925
    },
    {
        "content": "<p>I think that's been discussed elsewhere though (edit: <a href=\"#narrow/stream/116395-maths/topic/normed_field/near/297799021\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/normed_field/near/297799021</a>)</p>",
        "id": 328544510,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676660938
    },
    {
        "content": "<p>Just a quick comment to mention that I very much support this refactor. One benefit that hasn't been discussed yet: I think this change would make it much smoother to build some sort of hierarchy builder, and for such a hypothetical builder to interface nicely with the existing hierarchy</p>",
        "id": 328559503,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1676666499
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib-port-status/file/analysis/normed/group/basic\">port-status#analysis/normed/group/basic</a> is maybe far enough away that we could still try this</p>",
        "id": 328561103,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676667138
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/18462\">#18462</a> is one file into the attempt</p>",
        "id": 328563262,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676667996
    },
    {
        "content": "<p>One possibility for managing the instances might be to have the special syntax Yury proposed be shorthand (both forwards and backwards) for a special kind of sigma type which magically plays nicely with TC search and delaborates to its succinct special-syntax form. (I don’t know anything about how TC search works, but I’m guessing this might require some special-casing to handle it.)</p>\n<p>So instead of actually adding instances to the context macro-style like auto-implicits, special syntax around <code>Semigroup α</code> would be roughly equivalent to <code>(m : Mul α) × Semigroup α m</code> (<code>m</code> present here just to show dependence), except this special version of <code>×</code> would both delaborate to the special syntax around Semigroup α in infoviews etc. and signal to TC search that it ought to look here for instances (something it maybe would already do, I don’t know).</p>\n<p>We could also maybe adjust the inference rules for this special kind of “pseudobundling” (“instance bundling”?) type former if we encounter other problems—it gives us a thing to hold responsible, sort of. And given its restricted use, maybe it could be optimized behind the scenes in ways a fully general sigma type couldn’t.</p>\n<p>But, I really don’t know the details here, so I’m just throwing this out there! If it’s impractical, at least it narrows down what is practical. :)</p>",
        "id": 328573198,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676672219
    },
    {
        "content": "<p>The paper about exponential blowup promotes canonical structures as a solution. What is this and how is it different?</p>",
        "id": 328574293,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1676672716
    },
    {
        "content": "<p>What do you mean by canonical structures?</p>",
        "id": 328574890,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676672937
    },
    {
        "content": "<p><a href=\"https://hal.inria.fr/hal-00816703v1/document\">https://hal.inria.fr/hal-00816703v1/document</a></p>",
        "id": 328575266,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1676673075
    },
    {
        "content": "<p>Seems to just be fully bundled structures</p>",
        "id": 328575352,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1676673118
    },
    {
        "content": "<p>Are canonical structures what we’re doing now?</p>",
        "id": 328575414,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676673131
    },
    {
        "content": "<p>No, most (all?) algebraic typeclasses are semibundled</p>",
        "id": 328575510,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1676673172
    },
    {
        "content": "<p>Because I’m just proposing something entirely equivalent to “add all typeclass arguments to the context” (via tensor-hom) in order to help with the “frontend” problem of 24 instances suddenly showing up in the context</p>",
        "id": 328575690,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676673258
    },
    {
        "content": "<p>Well, maybe canonical structures means bundled structures plus some unification hints? I don't know, I haven't read the paper too closely</p>",
        "id": 328575821,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1676673339
    },
    {
        "content": "<p>I want to be clear that what I’m suggesting is still the unbundled approach being discussed here, where all the data fields are typeclass arguments</p>",
        "id": 328575994,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676673415
    },
    {
        "content": "<p>It’s just that instead of having <code>[[Semigroup α]] → … </code> mean <code>[Mul α] → [Semigroup α] → …</code>, it means roughly <code>[Mul α] × [Semigroup α] → …</code> for a special version of <code>×</code> which lets us delaborate appropriately and keep things clean in the infoview (so that we don’t actually see the <code>Mul</code> instance visually in the context)</p>",
        "id": 328576573,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676673702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/287929-mathlib4/topic/mixin.20algebraic.20typeclasses/near/328543249\">said</a>:</p>\n<blockquote>\n<p>But there's also another UX issue.  Namely if you have 2 field arguments you'll suddenly have 24 (?) extra elements in your local context.  We'd need some way to manage that (everywhere!, error messages, infoview, etc.)</p>\n</blockquote>\n<p>This is the only problem I’m attempting to address here—I’m not proposing any fundamental change to what’s been proposed (which I like now! :) )</p>",
        "id": 328576979,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676673923
    },
    {
        "content": "<p>The adhoc bundling proposal has similar issues as the current inheritance scheme. Namely you get huge instance terms in the operations. (Think of a definition about rings referencing a definition about (add) groups, which references a definition about monoids, and then you unfold them all)</p>",
        "id": 328577923,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1676674408
    },
    {
        "content": "<p>Another thing to remember is the two vector spaces over the same field issue.  The operations can and do overlap between the type classes.</p>",
        "id": 328578032,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1676674450
    },
    {
        "content": "<p>Hmm, if I’m understanding correctly (we’ll see!) I’m not sure I see why you’d have to unfold them—they’d still be present in the context just as they would be if inserted by the “auto-implicit” proposal, but in a special <code>×</code>-like type former instead of <code>forallE</code>. But it’s possible I don’t understand the problem as well as I thought I did.</p>\n<p>Also I was thinking maybe TC search could special case on such a type former so that it could zoom right to the instance it needed—the type former could hold at-the-ready information about where each relevant instance was, since this kind of thing is all it would be used for.</p>\n<p>No idea if that kind of thing is really possible or, more importantly, bears on the real issue, since now I’m a bit uncertain about my understanding of the actual issue. I wouldn’t have thought applying tensor-hom would change the computational properties!</p>",
        "id": 328580180,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676675489
    },
    {
        "content": "<p>If you have <code>def g [(_ : Mul α) × Group α] (x : α) := ..</code> and <code>def f [(_ : Mul α) × (_ : Zero α) × GroupWithZero α] (x : α) := g x</code>, then this elaborates to <code>@g ⟨inst.1, inst.2.2⟩ x</code>.  And if you unfold e.g. <code>@f ⟨inst.2.1, inst.2.2⟩ x</code>, then you'd get <code>@g ⟨⟨inst.2.1, inst.2.2⟩.1, ⟨inst.2.1, inst.2.2⟩.2.2⟩ x</code>.  Which is kind of the same situation we're in right now, but also what the original proposal here aims to avoid.</p>",
        "id": 328613446,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1676700916
    },
    {
        "content": "<p>Which kind of makes me wonder: how would you write <code>def squarefree [monoid R] (r : R) : Prop := ∀ x : R, x * x ∣ r → is_unit x</code> without unused arguments?  (Because obviously this definition only depends on * and 1, but not on the fact that these operations form a monoid.)</p>",
        "id": 328613645,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1676701077
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/287929-mathlib4/topic/mixin.20algebraic.20typeclasses/near/328541695\">said</a>:</p>\n<blockquote>\n<p>I don't see any exponential blow-up issues, Ralf's set up is different.</p>\n</blockquote>\n<p>Isn't there exponential blowup in the following situation? Say we go to fully unbundled, where a ring is given by <code>[Zero α] [One α] [HasAdd α] [HasMul α] [HasNeg α] [HasSub α] [HasNSMul α] [HasZSMul α] [RingProp α]</code> (so 9 classes). Then, if you start from a ring <code>R</code> and then build its polynomial ring <code>R[X]</code>, the very definition of the type and all its operations depend on these 9 classes. Then, if you build the fraction field of <code>R[X]</code>, say <code>Frac (R[X])</code>, the very definition of this type and all its operations depend on the ring structure on <code>R[X]</code>. And if you build the space of <code>R</code>-linear maps from <code>Frac (R[X])</code> to <code>R</code>, again this depends on everything before. Isn't there something like <code>9^3</code> complexity coming up here?</p>",
        "id": 328616619,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1676703069
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/287929-mathlib4/topic/mixin.20algebraic.20typeclasses/near/328613446\">said</a>:</p>\n<blockquote>\n<p>If you have <code>def g [(_ : Mul α) × Group α] (x : α) := ..</code> and <code>def f [(_ : Mul α) × (_ : Zero α) × GroupWithZero α] (x : α) := g x</code>, then this elaborates to <code>@g ⟨inst.1, inst.2.2⟩ x</code>.  And if you unfold e.g. <code>@f ⟨inst.2.1, inst.2.2⟩ x</code>, then you'd get <code>@g ⟨⟨inst.2.1, inst.2.2⟩.1, ⟨inst.2.1, inst.2.2⟩.2.2⟩ x</code>.  Which is kind of the same situation we're in right now, but also what the original proposal here aims to avoid.</p>\n</blockquote>\n<p>oh, I see!! I was naively assuming two differences:</p>\n<p>1) that we wouldn’t look for an instance of terms of this new product per se, which I’ll call <code>×'</code>, but instead look for instances of its components—that is, morally, instead of <code>g : [A ×' B] → …</code> we’d have “<code>g : [A] ×' [B] → …</code>” as far as TC search was concerned, and we’d be able to elaborate to <code>@g ⟨instA, instB⟩ …</code> directly</p>\n<p>2) that e.g. <code>f</code> would only unfold if its first argument were an explicit constructor application, and that it would inline the components of the product right where they needed to be instead of using a projection to extract them. So <code>@f ⟨a, b⟩ x</code> would unfold directly to <code>@g ⟨a, b.2⟩ x</code>.</p>\n<p>I don’t know if it’s possible to create such special-cased behavior for some new such <code>×'</code> type former (or its constructor), but from the way you’re talking, I’m guessing it either isn’t possible or would be impractically difficult 🙃</p>",
        "id": 328616995,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676703408
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/287929-mathlib4/topic/mixin.20algebraic.20typeclasses/near/328613645\">said</a>:</p>\n<blockquote>\n<p>Which kind of makes me wonder: how would you write <code>def squarefree [monoid R] (r : R) : Prop := ∀ x : R, x * x ∣ r → is_unit x</code> without unused arguments?  (Because obviously this definition only depends on * and 1, but not on the fact that these operations form a monoid.)</p>\n</blockquote>\n<p>Should we in fact discard the requirement that it’s a monoid in that definition? It would be really nice if definitions/lemmas could be “automatically as fully general as possible”, but it would probably be bad UX to have (in general) a ton of low-level instance arguments and no idea at a glance whether a given lemma applies to your structure.</p>\n<p>But the mathematical potential of maximal generalizability is really exciting. I wonder if it’s worth insisting that the lemma indeed only actually depend on what it needs to (no <code>Monoid M</code> argument) and tackling this as a (difficult) UI issue somehow.</p>\n<p>One rough vision of such a UI-based approach: you write <code>[Monoid M]</code> or something as the argument at first, then a code action lets you replace it automatically with the instances you actually use in the definition/proof. That code action also figures out what the minimal structures in some hierarchy are that have these instances. (Maybe <code>Monoid</code> is the lowest, or maybe you have a <code>MagmaWithOne</code> or something.) It then annotates your def/lemma with those minimal structures somehow (by including them as arguments to a special attribute?) and this annotation is (only) used to help locate and describe this def/lemma in other places (documentation, dropdowns, etc.).</p>\n<p>(I mean, we might not actually need the second step. Maybe that could be kept track of/inferred differently. But just to give a concrete example.)</p>",
        "id": 328619925,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676705521
    },
    {
        "content": "<p>What is the asymptotics of the term blow-up we have now? E.g., if you want <code>[LinearOrderedField α] [LinearOrderedField β] : Add (α × β)</code>?</p>",
        "id": 328672306,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1676728436
    },
    {
        "content": "<blockquote>\n<p>Isn't there exponential blowup in the following situation? Say we go to fully unbundled [...]. Then, if you start from a ring <code>R</code> and then build its polynomial ring <code>R[X]</code>, the very definition of the type and all its operations depend on these 9 classes. [...] Isn't there something like <code>9^3</code> complexity coming up here?</p>\n</blockquote>\n<p>The punchline here is that defining the type <code>R[x]</code> only requires 0, defining addition only requires 0 and +, etc. The worst case can still be very exponential, but it should be much more reasonable in practice.</p>",
        "id": 328703736,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1676741056
    },
    {
        "content": "<p>We already get exactly the same terms internally when checking that ring-to-semiring commutes with polynomials (when showing that <code>R[x]</code> is a semiring given that <code>R</code> is a ring).</p>",
        "id": 328704452,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1676741404
    },
    {
        "content": "<p>Yet another UX issue: how would we define these unbundled instances?  <code>instance : Semiring Nat</code> obviously no longer works.</p>",
        "id": 328704958,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1676741666
    },
    {
        "content": "<p>Why not? We currently already have <code>instance : Zero Nat</code> up to <code>instance : Mul Nat</code>. So then <code>instance : Semiring Nat</code> would work, right?</p>",
        "id": 328705063,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1676741744
    },
    {
        "content": "<p>In mathlib 3, it happens very often that notation instances are defined before defining instances of actual algebraic structures.</p>",
        "id": 328705190,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1676741798
    },
    {
        "content": "<p>You also need nsmul, nat cast, etc.  There's a lot of cases where just have a <code>instance : Field Foo := fieldBecauseReasons</code> and it would be unwieldy to write all fields by hand.</p>",
        "id": 328705346,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1676741868
    },
    {
        "content": "<p>fair enough</p>",
        "id": 328705526,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1676741932
    },
    {
        "content": "<p>We could have “default instance arguments” in place of default fields:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Foo</span> <span class=\"n\">α</span> <span class=\"o\">[</span><span class=\"n\">Bar</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Baz</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">baz</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n<span class=\"bp\">…</span>\n</code></pre></div>\n<p>Plus an <code>instance!</code> (<code>instances</code>?) command which 1) allowed field-like specification of fields of instance arguments, and created instances for those arguments 2) used these default values to create instances when unspecified. (The default values wouldn’t be used in other places.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span><span class=\"bp\">!</span> <span class=\"o\">:</span> <span class=\"n\">Semigroup</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul</span> <span class=\"o\">:=</span> <span class=\"bp\">…</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:=</span> <span class=\"bp\">…</span>\n  <span class=\"bp\">…</span>\n</code></pre></div>\n<p>As for <code>fieldBecauseReasons</code>—in the new style, the necessary data instances would be present explicitly in the type of <code>fieldBecauseReasons</code>, right? Maybe we could extract them and set them as instances via <code>instance!</code> with a bit of meta code.</p>",
        "id": 328717125,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676748423
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/287929-mathlib4/topic/mixin.20algebraic.20typeclasses/near/328703736\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Isn't there exponential blowup in the following situation? Say we go to fully unbundled [...]. Then, if you start from a ring <code>R</code> and then build its polynomial ring <code>R[X]</code>, the very definition of the type and all its operations depend on these 9 classes. [...] Isn't there something like <code>9^3</code> complexity coming up here?</p>\n</blockquote>\n<p>The punchline here is that defining the type <code>R[x]</code> only requires 0, defining addition only requires 0 and +, etc. The worst case can still be very exponential, but it should be much more reasonable in practice.</p>\n</blockquote>\n<p>The example of polynomials is not good,  indeed, because you don't need all the information to build the new type. But my point is that it happens very often that you need all the information to build the new type (for instance when you take the fraction ring, or tensor products), and so the exponential behavior will definitely come up in practice. You can look up in mathlib how the Clifford algebra is defined as a quotient of the tensor algebra, which is itself a quotient of the free algebra, which is itself built as a quotient made from the information from a semiring. Unbundling everything would make this a nightmare performancewise, if I understand correctly.</p>",
        "id": 328720560,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1676750704
    },
    {
        "content": "<p>I don't see why it makes a big difference, especially as each of those steps is a named construction with its own instances.</p>",
        "id": 328721098,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676751078
    },
    {
        "content": "<p>Instead of one definition per layer you have (say) five, and they refer to the five definitions of the previous layer in the same way that the fields of one definition referred to the fields of the previous definition.</p>",
        "id": 328721223,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676751169
    },
    {
        "content": "<p>I see why it's bad if you want to unfold all these definitions in a lemma but probably this means that we should have more irreducible definitions (either as in <code>irreducible_def</code> or as in one-field structure).</p>",
        "id": 328721258,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1676751199
    },
    {
        "content": "<p>In the example of the Coq blog post I think it makes a difference whether you work with <code>G x G x G x G x G</code> or <code>G2 := G x G</code>, <code>G3 = G x G2</code>, <code>G4 = G x G3</code>, <code>G5 = G x G4</code>.</p>",
        "id": 328721623,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676751411
    },
    {
        "content": "<p>Because the second forces you to do the correct sharing, that you could fail to do for the first</p>",
        "id": 328721786,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676751500
    },
    {
        "content": "<p>Of course if you unfold everything you're in for a bad time either way, so I agree with Yury that more irreducibility would be a good idea</p>",
        "id": 328722008,
        "sender_full_name": "Reid Barton",
        "timestamp": 1676751641
    }
]