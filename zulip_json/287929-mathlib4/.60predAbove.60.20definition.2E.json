[
    {
        "content": "<p>I have been thinking a bit about <code>predAbove</code> because this came up for me the other day.</p>\n<p><code>p.succAbove i</code> is a reasonably sensible function. Given a pivot <code>p : Fin (n + 1)</code> it injects an <code>i : Fin n</code> into <code>Fin (n + 1)</code> by avoiding the value <code>p</code>. This happens by comparing <code>castSucc i</code> to <code>p</code>: if the former is less than <code>p</code>, we should indeed map to <code>castSucc i</code> - otherwise we map to <code>succ i</code>. In a certain sense we can see <code>succAbove</code> as the generalisation of <code>castSucc</code> and <code>succ</code> across all of <code>Fin (n + 1)</code>.</p>\n<p><code>p.predAbove i</code> is sort of sensible. (Indeed I've worked with it in the past and I am partially responsible for its current definition). Given a pivot <code>p : Fin n</code>, it surjects <code>i : Fin (n + 1)</code> into <code>Fin n</code> by retaining the order but pushing <code>p.succ</code> and <code>p.castSucc</code> to the same value - essentially when <code>p.castSucc</code> is less than <code>i</code> we can find the <code>pred</code> of i, and if not we can find the <code>castPred</code> of <code>i</code>.</p>\n<p>However, thinking about it, and considering a practical scenario, <code>predAbove</code> is not a generalisation of <code>pred</code> and <code>castPred</code> in the way that <code>succAbove</code> is a generalisation of <code>succ</code> and <code>castSucc</code>. <code>pred</code> and <code>castPred</code> are both partial functions - <code>i.pred</code> requires also than <code>i ≠ 0</code> and <code>i.castPred</code> requires that <code>i ≠ last n</code>.</p>\n<p>Consider in general the problem whereby we have <code>p i : Fin (n + 1)</code>, and we know that <code>i ≠ p</code>. There is a perfectly sensible (and injective, given this condition) order-preserving map of <code>i</code> into <code>Fin n</code> - there are <code>n</code> possible values of <code>i</code>, after all! This is sort of the approach of <code>finSuccEquiv'</code> (though I don't propose using that).</p>\n<p>I argue that this function is natural and useful, and is currently tricky to define elegantly, wheras in contrast the <em>current</em> <code>predAbove</code> can be elegantly defined in terms of it.</p>",
        "id": 563925396,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765832922
    },
    {
        "content": "<p>Consider the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">SuccPred</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Fin</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">coe_succAbove</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">succAbove</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">succAbove</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">coe_castSucc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">val_succ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">coe_predAbove</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">predAbove</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">predAbove</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">coe_castSucc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">coe_pred</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">coe_castPred</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">newPredAbove</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hip</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">ne_zero_of_lt</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">castPred</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">ne_last_of_lt</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">lt_or_lt_of_ne</span><span class=\"w\"> </span><span class=\"n\">hip</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">resolve_right</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">coe_newPredAbove</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">hip</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">newPredAbove</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">hip</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">newPredAbove</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">coe_pred</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">coe_castPred</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">predAbove_eq_newPredAbove_succAbove</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">predAbove</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">newPredAbove</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">succAbove</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ne_succAbove</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">newPredAbove_eq_dite_castPred_predAbove</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">hip</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">newPredAbove</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">hip</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">castPred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">hip</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">castPred</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">predAbove</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">val_last</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">coe_castPred</span><span class=\"o\">]</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Fin</span>\n</code></pre></div>",
        "id": 563925420,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765832932
    },
    {
        "content": "<p><code>newPredAbove</code> as defined here is this more \"proper\" definition of <code>predAbove</code>, and the existing <code>predAbove</code> is neatly defined in terms of it: it is precisely the <code>newPredAbove</code> of <code>succAbove</code>.</p>\n<p>It would be a little work, but I propose that at the very least we should have <code>newPredAbove</code>, and it should probably have the name <code>predAbove</code>. There is some logic however to <em>also</em> having the current <code>predAbove</code>, but I think its current name should be changed (and I am happy to take suggestions as to what it should be). It's nice to have things like <code>Fin.predAboveOrderHom</code> - the current <code>predAbove</code> is not an unnatural function by any means! Nevertheless I think it would be more proper to think of it as derived from <code>newPredAbove</code> and <code>succAbove</code>.</p>",
        "id": 563925877,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765833151
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I am tagging you here because you've seen my work on these functions in the past and I know you've had opinions on their use. I don't want to submit a PR on spec - it seems to me useful to have the discussion first of all.</p>",
        "id": 563925998,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765833200
    },
    {
        "content": "<p>If there is a nicer way to define <code>newPredAbove</code> in terms of <code>predAbove</code> other than that I use in <code>newPredAbove_eq_dite_castPred_predAbove</code>, I am not sure of it - after all, if there were a nice way to do this, it would be simple enough to submit this as a new definition. I would still, I think, believe that the name needs changing.</p>",
        "id": 563926163,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765833267
    },
    {
        "content": "<p>I do not think it is a good idea to replace an existing definition with a new definition which does something else.</p>",
        "id": 563927072,
        "sender_full_name": "Joël Riou",
        "timestamp": 1765833659
    },
    {
        "content": "<p>I think that is a fair comment, but I don't know how we best deal with it when an existing definition is occupying a name that is less fitting. We could however choose a good name for \"newPredAbove\" and then re-define <code>predAbove</code> in terms of it - that would be an improvement for sure, and it avoids actually changing the function of an existing definition.</p>",
        "id": 563927266,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765833737
    },
    {
        "content": "<p>In general, sometimes wrong definitions will be made. If the policy of the maintainers is that such definitions must always remain, I think that is short-term reasonable but long-term problematic.</p>",
        "id": 563927373,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765833783
    },
    {
        "content": "<p>We may also just accept that <code>succAbove</code> and <code>predAbove</code> respectively define face and degeneracy maps in the simplex category (from or above a certain threshold, they indeed coincide with <code>succ</code> or <code>pred</code>, so that there is nothing wrong with the names). There are certainly other useful functions on <code>Fin</code> and I would not mind if the internals of <code>predAbove</code> are changed, but I think it is important to keep a stable API.</p>",
        "id": 563929692,
        "sender_full_name": "Joël Riou",
        "timestamp": 1765834611
    },
    {
        "content": "<p>I think it is pretty reasonable to keep them as the face and degeneracy maps but to me that does somewhat suggest better names are possible. I do see your point though - I essentially do not think that a stable API is as important, I think - certainly for a library like Mathlib which often happens not to care about backwards compatibility. (Correct me if I'm wrong on this - it certainly used to be true, and my code has been broken many times by breaking changes.)</p>",
        "id": 563929938,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765834705
    },
    {
        "content": "<p>We have the <code>deprecated</code> property, of course, but that is less suitable when tweaking a definition.</p>",
        "id": 563929979,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765834727
    },
    {
        "content": "<p>I just wanted to mention that you could use <code>Fin.succAboveCases</code> for this but then I encountered a bug I now reported as <a href=\"https://github.com/leanprover/lean4/pull/11689\">lean4#11689</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">newPredAbove</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hip</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">succAboveCases</span><span class=\"w\"> </span><span class=\"n\">nofun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">hip</span>\n</code></pre></div>",
        "id": 563930127,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1765834781
    },
    {
        "content": "<p>I always find using <code>succAboveCases</code> more troublesome than I expect.</p>",
        "id": 563930186,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765834803
    },
    {
        "content": "<p>To be clear I've never seen that rather exciting error before. But it never feels as easy as I hope.</p>",
        "id": 563930260,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765834847
    },
    {
        "content": "<p>I think that is a very nice definition though (if only it worked!)</p>",
        "id": 563930328,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765834879
    },
    {
        "content": "<p>if you want a name suggestion for <code>newPredAbove</code>, assuming the consensus does fall away from touching the name of <code>predAbove</code>, then my first fist would be <code>predAboveOfNe</code>.</p>\n<p>Which, I now find, I previously invented two years ago in <a href=\"https://github.com/leanprover-community/mathlib4/pull/9145\">#9145</a>, a refactor I abandoned for being too unwieldy (though I think elements of it remained in other PRs).</p>",
        "id": 563930759,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765835050
    },
    {
        "content": "<p>Anyway, that PR is bad and of no value - though it is always nice to find you have had a similar idea in the past.</p>",
        "id": 563931380,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765835310
    },
    {
        "content": "<p>I personally think that from a simplicial point of view, there is a coherence and symmetry among <code>succ</code>, <code>castSucc</code>, <code>succAbove</code>, <code>pred</code>, <code>castPred</code>, <code>predAbove</code>, and I would like to keep that.<br>\nI'm not against name changes, as long as they take this whole package into account.</p>",
        "id": 564007468,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1765880604
    },
    {
        "content": "<p>Whereas \"newPredAbove\" is not as natural from a simplicial point of view?</p>",
        "id": 564007603,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765880651
    },
    {
        "content": "<p>Why do we not have (I'm not proposing a change necessarily, just asking) \"pred\" and \"castPred\" defined totally (where the former sends 0 and 1 to 0 and the latter does the same for the greatest two)?</p>",
        "id": 564007798,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765880716
    },
    {
        "content": "<p>That is to me the most obvious symmetry break.</p>",
        "id": 564007872,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765880740
    },
    {
        "content": "<p>This would then make these functions behave like predAbove more properly - i.e. they would be order-preserving surjections with one point in the image where they fail to be injective.</p>",
        "id": 564008122,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765880815
    },
    {
        "content": "<p>In a similar way to how Nat.pred is global.</p>",
        "id": 564008234,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765880850
    },
    {
        "content": "<p>Yeah, I think that could improve the API further. And so maybe the conclusion is that we want multiple versions of all these <code>pred*</code>functions: (a) with proof obligation, and (b) total</p>",
        "id": 564014075,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1765882781
    },
    {
        "content": "<p>I think that would make sense actually! There is the slightly odd fact that a total version of <code>pred</code> and <code>castPred</code>, while you'd probably want to define it from <code>Fin (n + 1)</code> to <code>Fin n</code>, actually needs <code>[NeZero n]</code> I think. This doesn't happen with <code>predAbove</code> because you have to provide a <code>Fin n</code> to define it in the first place (so in fact it is implicitly true). But I think with care one could get round that.</p>",
        "id": 564014640,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765882944
    },
    {
        "content": "<p>Any thoughts on a name scheme?</p>",
        "id": 564014656,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765882952
    },
    {
        "content": "<p>Nope... was hoping you would come up with something (-;<br>\nMaybe the <code>OfNe</code> suffix is good?</p>",
        "id": 564015099,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1765883095
    },
    {
        "content": "<p>I think so but was hoping for confirmation :D</p>",
        "id": 564015174,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765883118
    },
    {
        "content": "<p>That does mean that <code>pred</code> and <code>castPred</code> as they exist currently would become <code>predOfNe</code> and <code>castPredOfNe</code>.</p>",
        "id": 564015240,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765883141
    },
    {
        "content": "<p>This would necessitate a core change.</p>",
        "id": 564015605,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765883275
    },
    {
        "content": "<p>That does complicate things...</p>",
        "id": 564024882,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1765886448
    },
    {
        "content": "<p>Quite.</p>",
        "id": 564024924,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765886460
    },
    {
        "content": "<p>The alternative would be to change <code>predAbove</code> to <code>predAboveTotal</code> or something, because then I think we can avoid touching core.</p>",
        "id": 564025065,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765886499
    },
    {
        "content": "<p>But I like that less.</p>",
        "id": 564025079,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1765886504
    }
]