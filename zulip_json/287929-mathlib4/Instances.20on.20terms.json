[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> during the meeting you are arguing that typeclasses on terms should be replaced by bespoke tactics and auto_params. But what if these typeclasses are interacting? I don't have an example right now, but I'm sure they exist.</p>",
        "id": 533733846,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1754901347
    },
    {
        "content": "<p>As in, some prop class requires some other prop class? Situations where the typeclass system needs access to a proof to construct some other instance. That's a good point. </p>\n<p>My mental model was about classes like Filter.NeBot, Ideal.IsPrime, Ideal.IsTwoSided, ones where it's not clear when to have the argument as an explicit vs instance parameter. For example, IsPrime has various instances that flow in a more complex direction, like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.IsPrime.smul#doc\">docs#Ideal.IsPrime.smul</a>. Many lemmas about prime ideals take the argument as an instance argument rather than an explicit one. It basically is a way to not have to rely on <code>include</code> and <code>omit</code>. </p>\n<p>Where my mental model particularly breaks down, as discussed in the call, was where we construct data from the prop class, like when Ideal.IsMaximal implies Field of the quotient by the ideal.</p>\n<p>Like I mentioned in the call, a similar existing pattern of relying on tactics that use/resolve based on some underlying typeclass-like search occurs in <code>nontriviality</code>, <code>positivity</code>, or <code>fun_prop</code>.</p>",
        "id": 533739298,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1754902923
    },
    {
        "content": "<p>Re the discussion about <code>instance</code>s on terms, I also have a funny feeling about them.  In particular, I am not sure how I feel about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subgroup.Normal#doc\">docs#Subgroup.Normal</a>: I have a very ambiguous perspective where I can clearly see it being inferred by the typeclass system, but I can also see it as something where I would expect to have to prove something myself.</p>",
        "id": 533741205,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1754903439
    },
    {
        "content": "<p>and of course, since you need it to prove the quotient is a group, it has to have at least as much 'class'-ness as <code>Group</code> itself</p>",
        "id": 533745648,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1754904762
    },
    {
        "content": "<p>5 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Mathlib.20community.20meetings/with/533725705\">#general &gt; Mathlib community meetings</a> by <span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span>.</p>",
        "id": 533748341,
        "sender_full_name": "Notification Bot",
        "timestamp": 1754905757
    },
    {
        "content": "<p>I think <code>auto_param</code> is still not supported by some basic tactics like <code>apply</code>, so this would need to be improved if we are going to use <code>auto_param</code> more.</p>\n<p>Should type class search be able to run <code>auto_param</code>s?</p>",
        "id": 533773063,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1754912353
    },
    {
        "content": "<p>And auto_param does not work nicely with simp either, because simp can't run those tactics</p>",
        "id": 533775935,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1754913109
    },
    {
        "content": "<p>Do you mean there is a fundamental reason why <code>simp</code> can't fun those tactics? Or just that it hasn't been implemented?</p>",
        "id": 533779472,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1754914243
    },
    {
        "content": "<p>I don't know all the details, but as discussed on the community call, I think the issue that when simp is trying to solve side goals for lemma usage, it doesn't run inside TacticM, so can't run auto_params.</p>",
        "id": 533785665,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1754916355
    },
    {
        "content": "<p>A big reason <code>simp</code> that doesn't run auto-params is caching. Simp needs to know dischargers are \"well-behaved\" to be able to determine whether the simp results are cacheable. Performance suffers greatly without the simp cache. This isn't to say that there couldn't be an option to have simp run auto-params, but it can't be the default. Maybe there could be an intermediate option of \"run well-behaved auto-params\" one day.</p>\n<p>There's no problem running tactics from within simp (and indeed you can run tactics using <code>(disch := ...)</code> argument), since SimpM is on top of MetaM, and it's easy enough to evaluate a tactic script from there.</p>",
        "id": 533787704,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754917038
    },
    {
        "content": "<p>I'm guessing \"well-behaved\" does not include things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">transpose_of</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elems</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">elemsT</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"c1\">-- this autoparam assigns the `elemsT` metavariable</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">elems</span><span class=\"o\">)</span><span class=\"bp\">ᵀ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">elemsT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">transpose_of_tac</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">elems</span><span class=\"o\">)</span><span class=\"bp\">ᵀ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">elemsT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 533792717,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1754918352
    },
    {
        "content": "<p>Regarding the discharger, current configurations would still require the discharger to be declared up front, not inferred on the fly based on the lemmas involved, correct?</p>",
        "id": 533795608,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1754919246
    },
    {
        "content": "<p>And the discharger codepath doesn't do any goal shape matching to route to the appropriate tactic, it relies on the tactics themselves to fail fast?</p>",
        "id": 533796361,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1754919444
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> I've confused things a little bringing \"discharger\" into it, but dischargers are a good point of comparison for what it would mean for simp to apply auto-params.</p>\n<p>Conceptual model for an auto-param-respecting simp:</p>\n<ul>\n<li>(True currently) Simp has a discharger that it applies to Prop simp lemma hypotheses. The default one is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.Simp.dischargeDefault%3F#doc\">docs#Lean.Meta.Simp.dischargeDefault?</a>, but it can be overridden. Discharging is attempted after instance synthesis if the argument's type is a class. The discharger is like a default auto-param tactic to use for hypotheses.</li>\n<li>If a hypothesis has an auto-param, it could override the discharger. Simp would need to be able to determine whether the auto-param is a \"well-behaved\" discharger.</li>\n</ul>\n<p>(By the way, here's what the default discharger does: It first has some logic about \"equation theorem hypotheses\" that invokes a version of <code>assumption</code> and <code>cases</code> on eq/heq, then it does a recursive <code>simp</code>, and finally it checks to see if the goal is solved by both trying Eq.rfl at reducible transparency and seeing if the expression is True.)</p>\n<p>This is all to say: no, there does not need to be a single discharger up front. It's all up to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.Simp.synthesizeArgs#doc\">docs#Lean.Meta.Simp.synthesizeArgs</a> to decide how to try to synthesize arguments to matching simp lemmas.</p>",
        "id": 533806976,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754922535
    },
    {
        "content": "<p>I used to be a member of the \"instances for types\" crowd, but working on game theory has completely won me to the other side. Being able to automatically find proofs for stuff like <code>Numeric (a * y + x * b - a * b)</code> is just way too convenient.</p>",
        "id": 535757824,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1755897806
    },
    {
        "content": "<p>Though if this can be done with autoparams (and if there's other benefits to this switch) I'd be willing to switch to that.</p>",
        "id": 535757895,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1755897845
    },
    {
        "content": "<p>(for context: <code>Numeric</code> is a predicate on games, and it's closed under addition, subtraction, multiplication, division, ω-exponentiation, casting from naturals, integers, rationals, real numbers, ordinals...)</p>",
        "id": 535758386,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1755898139
    },
    {
        "content": "<p>I'd claim that typeclasses are for when the proof is <em>always</em> structural, not just often structural. You could of course get a long way with making even and odd type classes, but that's not going to do you any favors for <code>Even (n * (n + 1))</code></p>",
        "id": 535760160,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755899200
    }
]