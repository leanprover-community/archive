[
    {
        "content": "<p>Could someone on MacOS Arm64, Linux Arm64, or Windows please do the following test on mathlib master (or any relatively recent version):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.AlgebraicGeometry.EllipticCurve.Weierstrass</span>\n<span class=\"k\">#print</span> <span class=\"n\">WeierstrassCurve.ofJ_</span><span class=\"bp\">Î”</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">$</span> <span class=\"n\">lake</span> <span class=\"n\">env</span> <span class=\"n\">lean</span> <span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Test.lean</span> <span class=\"bp\">|</span> <span class=\"n\">grep</span> <span class=\"mi\">615279405369003338004639155390251008</span>\n                  <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">Int.negOfNat</span> <span class=\"mi\">615279405369003338004639155390251008</span><span class=\"o\">))))</span>\n                  <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">615279405369003338004639155390251008</span><span class=\"o\">)))</span>\n              <span class=\"o\">(</span><span class=\"n\">Mathlib.Tactic.Ring.add_pf_add_lt</span> <span class=\"o\">(</span><span class=\"n\">Nat.rawCast</span> <span class=\"mi\">615279405369003338004639155390251008</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"n\">Mathlib.Tactic.Ring.add_pf_add_lt</span> <span class=\"o\">(</span><span class=\"n\">Nat.rawCast</span> <span class=\"mi\">615279405369003338004639155390251008</span><span class=\"o\">)</span>\n              <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.IsInt.of_raw</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">Int.negOfNat</span> <span class=\"mi\">615279405369003338004639155390251008</span><span class=\"o\">))</span>\n                <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.IsNat.of_raw</span> <span class=\"n\">R</span> <span class=\"mi\">615279405369003338004639155390251008</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 403208172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700498915
    },
    {
        "content": "<p>I'm not sure what exactly will happen if you are on one of these affected systems, it might crash or show <code>*****</code> instead of a number in those locations</p>",
        "id": 403208405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700499011
    },
    {
        "content": "<p>I get no output and a nonzero exit code on MacOS Arm64.</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>%<span class=\"w\"> </span>lake<span class=\"w\"> </span>env<span class=\"w\"> </span>lean<span class=\"w\"> </span>Mathlib/Test.lean<span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"nb\">echo</span><span class=\"w\"> </span>nonzero<span class=\"w\"> </span><span class=\"nb\">exit</span><span class=\"w\"> </span>code\nnonzero<span class=\"w\"> </span><span class=\"nb\">exit</span><span class=\"w\"> </span>code\n</code></pre></div>",
        "id": 403208919,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700499194
    },
    {
        "content": "<p>cool, that's what I thought</p>",
        "id": 403208999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700499220
    },
    {
        "content": "<p>can you also confirm that on <a href=\"https://github.com/leanprover-community/mathlib4/pull/8506\">#8506</a> the same test works?</p>",
        "id": 403209079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700499246
    },
    {
        "content": "<p>Yep:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">%</span> <span class=\"n\">lake</span> <span class=\"n\">env</span> <span class=\"n\">lean</span> <span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Test.lean</span> <span class=\"bp\">|</span> <span class=\"n\">grep</span> <span class=\"mi\">615279405369003338004639155390251008</span>\n                  <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">Int.negOfNat</span> <span class=\"mi\">615279405369003338004639155390251008</span><span class=\"o\">))))</span>\n                  <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">615279405369003338004639155390251008</span><span class=\"o\">)))</span>\n              <span class=\"o\">(</span><span class=\"n\">Mathlib.Tactic.Ring.add_pf_add_lt</span> <span class=\"o\">(</span><span class=\"n\">Nat.rawCast</span> <span class=\"mi\">615279405369003338004639155390251008</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"n\">Mathlib.Tactic.Ring.add_pf_add_lt</span> <span class=\"o\">(</span><span class=\"n\">Nat.rawCast</span> <span class=\"mi\">615279405369003338004639155390251008</span><span class=\"o\">)</span>\n              <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.IsInt.of_raw</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">Int.negOfNat</span> <span class=\"mi\">615279405369003338004639155390251008</span><span class=\"o\">))</span>\n                <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.IsNat.of_raw</span> <span class=\"n\">R</span> <span class=\"mi\">615279405369003338004639155390251008</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 403209608,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700499451
    },
    {
        "content": "<p>Great. (The bug is that some systems use GMP bignums and others don't, and these have different in-memory (and on-disk, because oleans) representations.)</p>\n<p>Incidentally, once <a href=\"https://github.com/leanprover-community/mathlib4/pull/8506\">#8506</a> is merged mathlib will actually have \"architecture-dependent oleans\", but they deserialized from architecture-independent .ltar files. (In principle, this could even handle much more significant architecture level deviation like 32-bit systems or big-endian architectures, although there hasn't been much demand for that.)</p>",
        "id": 403210945,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700499897
    },
    {
        "content": "<p>On the subject of non-GMP bignums, we saw in <a href=\"#narrow/stream/287929-mathlib4/topic/.6010.5E40000000.20.3D.2010.5E40000000.20.3A.3D.20by.20norm_num.60/near/402802012\">this other issue</a> that lean's implementation of bignum operations has trouble with very large numbers. Maybe we should have a non-GMP system running <code>lean4checker</code>, to make sure that these files aren't performing computations that are infeasible for non-GMP.</p>",
        "id": 403211547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700500125
    }
]