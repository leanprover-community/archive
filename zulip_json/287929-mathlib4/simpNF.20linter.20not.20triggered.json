[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/31563\">#31563</a> a <code>simp</code> lemma was removed. The reason is that it could already by proven by <code>simp</code>! And I checked, that is correct. Why didn't the <code>simpNF</code> linter trigger here?</p>",
        "id": 558030600,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763495852
    },
    {
        "content": "<p>Stab in the dark: can it still be proved by <code>simp</code> after <code>import Mathlib</code>? Not even sure if this is relevant.</p>",
        "id": 558032678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1763496503
    },
    {
        "content": "<p>yes</p>",
        "id": 558032795,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763496548
    },
    {
        "content": "<p>I checked that this isn't what's happening here, but here's my reminder that the correct criterion is not whether the statement of the simp lemma can be simplified, but rather if its LHS can</p>",
        "id": 558037029,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763498154
    },
    {
        "content": "<p>I think the way you worded that is confusing me. You agree that in this particular situation, the LHS can be simplified, right?</p>",
        "id": 558062527,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763498327
    },
    {
        "content": "<p>We have the lemmas <code>coe_innerSL_apply</code> and <code>innerSL_apply_apply</code>, and <code>innerSL_apply_apply</code> can be proved by <code>simp</code> using <code>coe_innerSL_apply</code>.</p>\n<p>But when <code>simpNF</code> called <code>simp</code>, it used <code>innerSL_apply_apply</code> instead of <code>coe_innerSL_apply</code>. So the <code>simpNF</code> linter didn't notice that <code>coe_innerSL_apply</code> could be used instead.</p>",
        "id": 558166234,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763548651
    },
    {
        "content": "<p>A solution could be to run <code>simp</code> with that particular <code>simp</code> lemma disabled. But this would lead to false positives, due to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">library_note2</span><span class=\"w\"> </span><span class=\"bp\">«</span><span class=\"n\">specialised</span><span class=\"w\"> </span><span class=\"n\">high</span><span class=\"w\"> </span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"bp\">»</span><span class=\"w\"> </span><span class=\"sd\">/--</span>\n<span class=\"sd\">It sometimes happens that a `@[simp]` lemma declared early in the library can be proved by `simp`</span>\n<span class=\"sd\">using later, more general simp lemmas. In that case, the following reasons might be arguments for</span>\n<span class=\"sd\">the early lemma to be tagged `@[simp high]` (rather than `@[simp, nolint simpNF]` or</span>\n<span class=\"sd\">un``@[simp]``ed):</span>\n<span class=\"sd\">1. There is a significant portion of the library which needs the early lemma to be available via</span>\n<span class=\"sd\">  `simp` and which doesn't have access to the more general lemmas.</span>\n<span class=\"sd\">2. The more general lemmas have more complicated typeclass assumptions, causing rewrites with them</span>\n<span class=\"sd\">  to be slower.</span>\n<span class=\"sd\">-/</span>\n</code></pre></div>",
        "id": 558166680,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763548788
    },
    {
        "content": "<p>When <code>simp</code> does it's discrimination tree matching, does it pick the longest matching subexpression when there are two possible matches? This could explain why it is always choosing <code>innerSL_apply_apply</code> over <code>coe_innerSL_apply</code> when the former is applicable.</p>",
        "id": 558493958,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763660992
    },
    {
        "content": "<p>Yes, the matches of different length correspond to different discrimination tree searches, which are done in order from long to short.</p>",
        "id": 558497403,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763662031
    },
    {
        "content": "<p>okay, thanks for this. I think I am satisfied. The point is that <code>simpNF</code> won't trigger when we're making a <code>simp</code> lemma whose left-hand side contains an existing <code>simp</code> lemma as an initial segment of the expression.</p>",
        "id": 558500235,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763662848
    }
]