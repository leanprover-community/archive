[
    {
        "content": "<p>If I apply a theorem that assumes <code>Monotone (s : _ → Set _)</code>, then after <code>intro i j hle</code>, the goals is <code>s i ≤ s j</code>, not <code>s i ⊆ s j</code>, so <code>gcongr</code> fails. <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> Is there an easy way to tell <code>gcongr</code> to auto simplify <code>s i ≤ s j</code> to <code>s i⊆ s j</code>?</p>",
        "id": 480134571,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730507321
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> Interesting, how many such theorems are there in the library?  I wonder whether it is worth phrasing such theorems in terms of a variant of <code>Monotone</code> which takes two named relations rather than looking for an order instance on the type? (rather than adjusting <code>gcongr</code>)</p>",
        "id": 480814928,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730848716
    },
    {
        "content": "<p>It's a common assumption in measure theory.</p>",
        "id": 480819531,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730851756
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> @Monotone _ (Set _)</p>",
        "id": 481018348,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730936383
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Basic.html#Set.monotone_setOf\">Set.monotone_setOf</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Basic.html#Set.monotone_powerset\">Set.monotone_powerset</a>, and <a href=\"https://loogle.lean-lang.org/?q=%40Monotone%20_%20%28Set%20_%29\">86 more</a></p>",
        "id": 481018349,
        "sender_full_name": "loogle",
        "timestamp": 1730936385
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> @Antitone _ (Set _)</p>",
        "id": 481018359,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730936396
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Basic.html#Set.antitone_setOf\">Set.antitone_setOf</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Basic.html#Antitone.inter\">Antitone.inter</a>, and <a href=\"https://loogle.lean-lang.org/?q=%40Antitone%20_%20%28Set%20_%29\">52 more</a></p>",
        "id": 481018360,
        "sender_full_name": "loogle",
        "timestamp": 1730936397
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> @StrictMono _ (Set _)</p>",
        "id": 481018410,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730936410
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Image.html#Function.Injective.image_strictMono\">Function.Injective.image_strictMono</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/SetLike/Basic.html#SetLike.coe_strictMono\">SetLike.coe_strictMono</a>, and <a href=\"https://loogle.lean-lang.org/?q=%40StrictMono%20_%20%28Set%20_%29\">1 more</a></p>",
        "id": 481018413,
        "sender_full_name": "loogle",
        "timestamp": 1730936410
    },
    {
        "content": "<p>OK, I scrolled through those.  So is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.tendsto_setIntegral_of_monotone#doc\">docs#MeasureTheory.tendsto_setIntegral_of_monotone</a> a canonical example of the situation you're describing?  Measure theory lemma involving a sequence of sets, monotonicity of that sequence appears as a side condition?</p>",
        "id": 481021914,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730938602
    },
    {
        "content": "<p>And you'd like the monotonicity side condition to be knocked off by <code>fun i j hle ↦ by gcongr</code>, but it isn't because <code>gcongr</code> sees <code>s i ≤ s j</code> rather than <code>s i ⊆ s j</code>?</p>",
        "id": 481022074,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730938714
    },
    {
        "content": "<p>One approach could be to offer a configurable reducibility setting in <code>gcongr</code> -- many other tactics do offer such a setting, but currently <code>gcongr</code> hard-codes reducible transparency (because of potential performance issues like <a href=\"https://github.com/leanprover-community/mathlib4/pull/8731\">#8731</a>).</p>\n<p>(Not sure whether semireducible transparency would see through the <code>LE</code> instance on <code>Set</code> -- we should obviously check this first.)</p>",
        "id": 481022688,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730939088
    },
    {
        "content": "<p><code>gcongr</code> can prove <code>le</code> from <code>lt</code>. Can we reuse this for <code>le</code> and <code>subset</code>?</p>",
        "id": 481037190,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730949458
    },
    {
        "content": "<p>When <code>gcongr</code> proves <code>le</code> from <code>lt</code>, it stays in <code>le</code>-world all through the logic and then switches to <code>lt</code> at the leaf represented by the <code>&lt;</code> hypothesis.  In your example you want the relation-switch to happen at the root (the goal), not the leaf.</p>",
        "id": 481037296,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730949548
    },
    {
        "content": "<p>Thanks for the explanation.</p>",
        "id": 481037333,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730949599
    },
    {
        "content": "<p>But it would certainly be nice to handle your use case.  Do you think having a transparency configuration would fix it?</p>",
        "id": 481037421,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730949647
    },
    {
        "content": "<p>I'm afraid that this may be too much. If <code>gcongr</code> can see through semireducible definitions, then it will spend more time trying to unify lemmas with the goal.</p>",
        "id": 481037478,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730949708
    },
    {
        "content": "<p>I wouldn't propose doing this in general (because of cases like the example in <a href=\"https://github.com/leanprover-community/mathlib4/pull/8731\">#8731</a> where this really affects performance), just that we could have a transparency config which you would set to \"semireducible\" in your use case.</p>",
        "id": 481037588,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730949805
    },
    {
        "content": "<p>I'll try to run some experiments this weekend.</p>",
        "id": 481037659,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730949845
    },
    {
        "content": "<p>The other approach is just to make a new definition <code>MonotoneFor</code> with specified relations, and adjust the lemmas you mentioned to have <code>MonotoneFor</code> hypotheses ...</p>",
        "id": 481037705,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730949908
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Relator.html#Relator.LiftFun\">Relator.LiftFun</a></p>",
        "id": 481037871,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730950066
    },
    {
        "content": "<p>Could we avoid overengineering a solution here? Bhavik and I are now making concrete plans for <code>subset</code> to be notation for <code>le</code> on <code>Set</code> and <code>Finset</code></p>",
        "id": 481064566,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730967056
    },
    {
        "content": "<p>I will try to write more about these plans in the next few days, but in the meantime let me add that it would be nice if gcongr could work on Monotone lemmas even in the case where every relation is syntactically <code>≤</code>. See eg lines 314-323 here: <a href=\"https://github.com/leanprover-community/mathlib4/pull/17694/files#diff-72ab2090c9a127e6bd5b4f0eb304fdb2ab1f475d7a78f0e37de446feb956b127R314\">https://github.com/leanprover-community/mathlib4/pull/17694/files#diff-72ab2090c9a127e6bd5b4f0eb304fdb2ab1f475d7a78f0e37de446feb956b127R314</a>. The change that Yaël and I are considering is orthogonal to this (and in fact would benefit from this)</p>",
        "id": 481195840,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1731011700
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> Do you mean that it should be possible to tag directly as <code>gcongr</code> a lemma whose conclusion is <code>Monotone Foo</code>, rather than writing a clone of the lemma with the form <code>(h : x ≤ y) : Foo x ≤ Foo y</code>?  Yes, that would be a useful feature!</p>\n<p>(This is not very closely related to Yury's use case, though.)</p>",
        "id": 481380017,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731096728
    },
    {
        "content": "<p>Yes, exactly! <del>I agree it's not directly related to Yury's case, but it'd be useful now, and in conjunction with the change Yaël and I mention above would make Yury's case work automatically too</del> edit: no longer quite so sure about this, I misread</p>",
        "id": 481380107,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1731096794
    }
]