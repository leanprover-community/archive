[
    {
        "content": "<p>I believe mathlib doesn't have entailment (correct me if i'm wrong!).<br>\nIn Set Theory one would put the quantifier over all possible domains. What would be a sensible approach in Lean?<br>\nI was thinking of checking for all models with domain in <code>Type (max u v)</code> (the smallest universe containing all the Language symbols), since one can prove that all larger universes don't change the meaning. Is this the right approach? What about smaller universes than <code>Type (max u v)</code> ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">ModelTheory</span><span class=\"bp\">.</span><span class=\"n\">Bundled</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">FirstOrder</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Language</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Theory</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Theory</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">entails</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Theory</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Structure</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Model</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T'</span><span class=\"bp\">.</span><span class=\"n\">Model</span><span class=\"w\"> </span><span class=\"n\">M</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">entails2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Theory</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"c1\">--this one contains `w` as \"free\" universe parameter</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Structure</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Model</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T'</span><span class=\"bp\">.</span><span class=\"n\">Model</span><span class=\"w\"> </span><span class=\"n\">M</span>\n\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">larger_universes_dont_change_meaning</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">entails2</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T'</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">entails</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">--provable</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Theory</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Language</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">FirstOrder</span>\n</code></pre></div>",
        "id": 567870610,
        "sender_full_name": "Moritz R",
        "timestamp": 1768343430
    },
    {
        "content": "<p>One should definitely add <code>Nonempty M</code>  to the premises in both definitons</p>",
        "id": 569252387,
        "sender_full_name": "Moritz R",
        "timestamp": 1769001621
    },
    {
        "content": "<p>Isn't <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FirstOrder.Language.Theory.ModelsBoundedFormula#doc\">docs#FirstOrder.Language.Theory.ModelsBoundedFormula</a> entailment?</p>",
        "id": 569311095,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1769015778
    },
    {
        "content": "<p>oh, nice. Thank you!</p>",
        "id": 569312660,
        "sender_full_name": "Moritz R",
        "timestamp": 1769016181
    },
    {
        "content": "<p>Oh you mean theories entails theories. I guess it's equivalent to <code>∀ φ ∈ T', T ⊨ᵇ φ</code></p>",
        "id": 569312781,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1769016210
    },
    {
        "content": "<p>I find the naming to be very unintuitive. I searched for all the synonyms i could come up with, but still didn't find it</p>",
        "id": 569312827,
        "sender_full_name": "Moritz R",
        "timestamp": 1769016222
    },
    {
        "content": "<p>Maybe we could add a comment that this is typically called <code>entailment</code> or <code>semantic consequence</code> in the literature</p>",
        "id": 569312978,
        "sender_full_name": "Moritz R",
        "timestamp": 1769016266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"602461\">Moritz R</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Define.20entailment.20.28Model.20Theory.29/near/567870610\">said</a>:</p>\n<blockquote>\n<p>I was thinking of checking for all models with domain in <code>Type (max u v)</code> (the smallest universe containing all the Language symbols), since one can prove that all larger universes don't change the meaning. Is this the right approach? What about smaller universes than <code>Type (max u v)</code> ?</p>\n</blockquote>\n<p>And the definition of <code>⊨ᵇ</code> uses the <code>Type (max u v)</code> approach. I guess due to Lowenheim-Skolem this quantifies for all models in any universe</p>",
        "id": 569313085,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1769016295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"602461\">Moritz R</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Define.20entailment.20.28Model.20Theory.29/near/569312827\">said</a>:</p>\n<blockquote>\n<p>I find the naming to be very unintuitive. I searched for all the synonyms i could come up with, but still didn't find it</p>\n</blockquote>\n<p>You can search for symbol <code>⊨</code>, that's how I found it</p>",
        "id": 569313266,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1769016344
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Define.20entailment.20.28Model.20Theory.29/near/569313266\">schrieb</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"602461\">Moritz R</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Define.20entailment.20.28Model.20Theory.29/near/569312827\">said</a>:</p>\n<blockquote>\n<p>I find the naming to be very unintuitive. I searched for all the synonyms i could come up with, but still didn't find it</p>\n</blockquote>\n<p>You can search for symbol <code>⊨</code>, that's how I found it</p>\n</blockquote>\n<p>good idea!</p>",
        "id": 569313503,
        "sender_full_name": "Moritz R",
        "timestamp": 1769016411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"602461\">Moritz R</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Define.20entailment.20.28Model.20Theory.29/near/569312978\">said</a>:</p>\n<blockquote>\n<p>Maybe we could add a comment that this is typically called <code>entailment</code> or <code>semantic consequence</code> in the literature</p>\n</blockquote>\n<p>It should be nicer to just rename it as <code>Entails</code> <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>",
        "id": 569313569,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1769016426
    },
    {
        "content": "<p>This would also be fine with me. But i can also understand that someone might want to use the same name for all the uses of a symbol, though it feels weird</p>",
        "id": 569316756,
        "sender_full_name": "Moritz R",
        "timestamp": 1769017262
    },
    {
        "content": "<p>Also the docstring is currently </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A theory models a (bounded) formula when</span>\n<span class=\"sd\">any of its nonempty models realizes that formula on all inputs. -/</span>\n</code></pre></div>\n<p>and i would much rather have it be formulated like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A theory models a (bounded) formula when</span>\n<span class=\"sd\">all of its nonempty models realize that formula on all inputs. -/</span>\n</code></pre></div>\n<p>or even better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A theory models a (bounded) formula when</span>\n<span class=\"sd\">all of its nonempty models realize that formula on for all realizations `v` of free variables. -/</span>\n</code></pre></div>",
        "id": 569360749,
        "sender_full_name": "Moritz R",
        "timestamp": 1769031216
    },
    {
        "content": "<p>The current docstring sounds a bit like existential quantification to me. It definitely isn't unambigous</p>",
        "id": 569361291,
        "sender_full_name": "Moritz R",
        "timestamp": 1769031388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"602461\">Moritz R</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Define.20entailment.20.28Model.20Theory.29/near/569360749\">said</a>:</p>\n<blockquote>\n<p>Also the docstring is currently </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A theory models a (bounded) formula when</span>\n<span class=\"sd\">any of its nonempty models realizes that formula on all inputs. -/</span>\n</code></pre></div>\n<p>and i would much rather have it be formulated like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A theory models a (bounded) formula when</span>\n<span class=\"sd\">all of its nonempty models realize that formula on all inputs. -/</span>\n</code></pre></div>\n<p>or even better:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A theory models a (bounded) formula when</span>\n<span class=\"sd\">all of its nonempty models realize that formula on for all realizations `v` of free variables. -/</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Then make a PR just changing the docstrings.</p>",
        "id": 569381487,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769040028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Define.20entailment.20.28Model.20Theory.29/near/569313569\">schrieb</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"602461\">Moritz R</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Define.20entailment.20.28Model.20Theory.29/near/569312978\">said</a>:</p>\n<blockquote>\n<p>Maybe we could add a comment that this is typically called <code>entailment</code> or <code>semantic consequence</code> in the literature</p>\n</blockquote>\n<p>It should be nicer to just rename it as <code>Entails</code> <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>\n</blockquote>\n<p>Any opinions on this?</p>",
        "id": 569382177,
        "sender_full_name": "Moritz R",
        "timestamp": 1769040307
    },
    {
        "content": "<p>As a model theorist myself, I am not a huge fan of reading <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊨</mo></mrow><annotation encoding=\"application/x-tex\">\\models</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.999em;vertical-align:-0.249em;\"></span><span class=\"mrel\">⊨</span></span></span></span> as 'models' in this context (i.e., when neither of the objects in the relationship is actually a model at all), although I know that some model theorists do read it that way.</p>",
        "id": 569387503,
        "sender_full_name": "James E Hanson",
        "timestamp": 1769043313
    }
]