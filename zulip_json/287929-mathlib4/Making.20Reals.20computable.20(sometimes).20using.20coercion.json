[
    {
        "content": "<p>So I have been reading how Mathlib defines a Real and I found it quite wierd that it was completely uncomputable.. I looked into it and it makes sense, it is a quotient and those cant be computed and all. But I still find it wierd that a calculator cant approximate reals, it feels like a programming language should be able to approximate reals at the least. I figured it should be very handy and very easy in principle to make reals be able to be a function that takes in a precision and gives you are rational which is epsilon precise. </p>\n<p>But then i found out that there are things like Specker's sequence. <br>\nHere's my solution </p>\n<p>When you type let x : ℝ := 1 in lean, it is actually OfNat (1 : ℕ) to cast from natural to real. So my thought was that we remove this cast. We add a new type, called ApproximableReal or something. Every 'normal' number will be of this type. This is because an ApproximableReal is something like </p>\n<p>structure ApproximableReal :=<br>\napproximator: ℚ → ℚ <br>\nconvergence_proofs: ommited types </p>\n<p>so very similar to our intuition on Cauchy Reals. It doesn't have decidable equality or any of the nice things that we get from normal Mathlib Reals, but it is computable. It is not intended to be used by itself, it automatically casts up to reals. </p>\n<p>However, reals constructed in this fashion are nice because of something like Int.OfNat_nonneg, this has the ability to approximate as long as the real comes from an ApproximableReal. </p>\n<p>ApproximableReals would have to be constructed differently i guess. Like for example Real.pi couldn't be an approximable real if it was written as IVT on 0 ∈ cos '' Icc (1 : ℝ) 2 like it is in lean right now, but it could if it was written using like infinite sum or integral of circle or whatever (could integrals become approximable too? or could only boxIntegrals). </p>\n<p>By doing this, we preserve all of the nice properties present in current reals, but we can add that we can also compute most numbers. </p>\n<p>I'd love to hear thoughts on why this is a good or bad idea?</p>",
        "id": 568113517,
        "sender_full_name": "Cookie Guy",
        "timestamp": 1768442568
    },
    {
        "content": "<p>what kinds of things do you expect to be easier to do with these approximate reals than with the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real#doc\">docs#Real</a> already in mathlib?</p>",
        "id": 568113843,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768442857
    },
    {
        "content": "<p>i want the ability to approximate reals. This would make, for example, bounding any approximable real, such as pi or e, trivial, but more in general, it allows us to use lean more easily for scientific calculation</p>",
        "id": 568113990,
        "sender_full_name": "Cookie Guy",
        "timestamp": 1768442994
    },
    {
        "content": "<p>pi is defined as 2 times the unique root of <code>Real.cos</code> in <code>[1, 2]</code>, and e is defined as the sum of factorial reciprocals. How would bounding them be trivial? Wouldn't it just shift the problem to defining them as approximable reals?</p>",
        "id": 568114339,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768443316
    },
    {
        "content": "<p>btw Mathlib is missing <a href=\"https://en.wikipedia.org/wiki/Hurwitz%27s_theorem_(number_theory)\">Hurwitz's theorem</a>, so if you're interested in approximating reals it seems fun to work on it</p>",
        "id": 568114486,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768443492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Reals.20computable.20.28sometimes.29.20using.20coercion/near/568114339\">said</a>:</p>\n<blockquote>\n<p>pi is defined as 2 times the unique root of <code>Real.cos</code> in <code>[1, 2]</code>, and e is defined as the sum of factorial reciprocals. How would bounding them be trivial? Wouldn't it just shift the problem to defining them as approximable reals?</p>\n</blockquote>\n<p>i believe it should be far more natural.</p>\n<p>lets say we define </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>π</mi><mo>=</mo><mn>4</mn><mtext>arctan</mtext><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\pi = 4 \\text{arctan}(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">4</span><span class=\"mord text\"><span class=\"mord\">arctan</span></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>a proof on the bound should come directly from the approximableReal arctan, which is defined as an infinite sum</p>\n<p>alternatively, if we defined it as something more complicated like</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mn>2</mn><mo>∗</mo><mi>l</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>x</mi><mo>→</mo><msup><mn>1</mn><mo>−</mo></msup></mrow></msub><mi>a</mi><mi>r</mi><mi>c</mi><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mstyle></mrow><annotation encoding=\"application/x-tex\">\\displaystyle 2 * lim_{x \\to 1^-} arcsin(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">i</span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3419em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"mrel mtight\">→</span><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7027em;\"><span style=\"top:-2.786em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mbin mtight\">−</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">rcs</span><span class=\"mord mathnormal\">in</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>then lean would use the proof that the limit converges as an epsilon delta as the first 'approximant', and i can imagine that this approximant is going to then use the approximant of arcsin internally, so some rather complicated stuff would be happening behind the hood, however it comes out directly from the construction of a ApproximableReal</p>\n<p>the way we currently prove that 3.14 &lt; π is through a rather involved proof using a recursive nested sqrt(2 + ...) and random rational numbers provided by mathematica which I honestly don't understand</p>\n<p>In my opinion, restricting to approximable reals, while shifting the problem, makes the problem also a lot easier to solve, just a proof of convergence.</p>",
        "id": 568114943,
        "sender_full_name": "Cookie Guy",
        "timestamp": 1768443925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933284\">Cookie Guy</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Reals.20computable.20.28sometimes.29.20using.20coercion/near/568113990\">said</a>:</p>\n<blockquote>\n<p>i want the ability to approximate reals. This would make, for example, bounding any approximable real, such as pi or e, trivial, but more in general, it allows us to use lean more easily for scientific calculation</p>\n</blockquote>\n<p>trivial how? don't you now need to evaluate the approximation <em>and</em> bound its error?</p>",
        "id": 568115415,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768444398
    },
    {
        "content": "<p>or are you saying that should be a lot easier</p>",
        "id": 568115428,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768444413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933284\">Cookie Guy</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Reals.20computable.20.28sometimes.29.20using.20coercion/near/568114943\">said</a>:</p>\n<blockquote>\n<p>i believe it should be far more natural.<br>\n...<br>\na proof on the bound should come directly from the approximableReal arctan, which is defined as an infinite sum<br>\n...<br>\nthen lean would use the proof that the limit converges as an epsilon delta as the first 'approximant', and i can imagine that this approximant is going to then use the approximant of arcsin internally, so some rather complicated stuff would be happening behind the hood, however it comes out directly from the construction of a ApproximableReal<br>\n...<br>\nIn my opinion, restricting to approximable reals, while shifting the problem, makes the problem also a lot easier to solve, just a proof of convergence.</p>\n</blockquote>\n<p>You're making bold claims without supplying any form of evidence (i.e. code) to support them. I don't see how that's any easier, but perhaps a code example would demonstrate it. Note that such an example needs to avoid importing the existing definition of pi, otherwise it might be using theorems which rely on the current definition of pi and so can't be used to change its definition.</p>\n<p>Also, it seems like you're advocating for changing the definition of pi using inverse trig functions, which is a separate problem.</p>",
        "id": 568116112,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768445092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Reals.20computable.20.28sometimes.29.20using.20coercion/near/568115415\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"933284\">Cookie Guy</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Reals.20computable.20.28sometimes.29.20using.20coercion/near/568113990\">said</a>:</p>\n<blockquote>\n<p>i want the ability to approximate reals. This would make, for example, bounding any approximable real, such as pi or e, trivial, but more in general, it allows us to use lean more easily for scientific calculation</p>\n</blockquote>\n<p>trivial how? don't you now need to evaluate the approximation <em>and</em> bound its error?</p>\n</blockquote>\n<p>I am imagining that ApproximableReal.approximant is a function that takes in a rational number epsilon and gives you a rational number which is closer than epsilon to the 'true value'. In my mind what will make it easier is that composition of functions comes automatically</p>\n<p>now if i defined addition between two  apporximableReal, <br>\nlet a b: approximableReal, let ε be given</p>\n<p>let a1 := a.approximant ε/2<br>\nlet b1 := b.approximant ε/2</p>\n<p>a + b</p>\n<p>now by design, we will know that approximableReal has the property of being epsilon precise through some argument with ε = ε / 2 + ε / 2. </p>\n<p>Using this , if we had appropriately defined pi and e, then lean would automatically know bounds on π + e </p>\n<p>This idea could be extended to much more than just addition, such as sin : approximableReal → approximableReal would allow us to automatically argue about sin pi.</p>",
        "id": 568116260,
        "sender_full_name": "Cookie Guy",
        "timestamp": 1768445224
    },
    {
        "content": "<p>Can you please provide a concrete example of what you mean, using code? (<a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>)</p>",
        "id": 568116409,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768445368
    },
    {
        "content": "<p>yup, gimme a minute</p>",
        "id": 568116557,
        "sender_full_name": "Cookie Guy",
        "timestamp": 1768445466
    },
    {
        "content": "<p>It would certainly be convenient to have something like this work:<br>\n<code>example : 23 &lt; exp pi := by decide</code><br>\nbut I assume that the reason it's not done with things like Approximable Reals is that it's probably very very hard and very slow</p>",
        "id": 568117721,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1768446398
    },
    {
        "content": "<p>it's also not actually decidable</p>",
        "id": 568117778,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768446446
    },
    {
        "content": "<p>It's not decidable, but it is recursively enumerable</p>",
        "id": 568117889,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1768446559
    },
    {
        "content": "<p>Like you can compute both sides to a certain precision and prove it</p>",
        "id": 568117908,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1768446577
    },
    {
        "content": "<p>ok heres my rough draft of a mwe</p>\n<p><a href=\"https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAWQIYwBYBtgCMB0ARFJHAJQFMl0cAhJAZ2AGMAoUSWRFDbHAFSQZiMmTWjCgBXAeKik4AQTBgoEAB6gkWdKTIU4Ad1SkZTABRJFylXABccQKiEcQEmEcQFiEASlMMkk1AE8bcIAARHAgcAB2ADRwGrRwZhaqIXAAtNEJVmEB7nCAJkRxJgBMWW5wAHpxIMCZoWFuboDeBACdHkwQYKSZCkqq6pra5OjCACakAGZwo8ogAHIocZm2diW2XZa9WjroNgC8TADead1WAPo74RFMcHBePv5IcFhnWP704EwAvsJVokhhDLJ7MLvAIAeVGs3gqx6IA0GwG4X0hmMVwg4Lm1m2EymEPCwzGcBgEE2cSsK3S636FGWcEAuIRPXyXOC0aBQBlMEbjJBDIYkuD+MlHCmbalQtQwvrEjH7Q6WM6AbuAEdsAHxwFQ4cxHeYAagAjCUtXz1eltXqLlcbgw/NEHvTGeaKMwrk64AAfNUa2VmOAGvXew0exJen0lVImd3GkyPYN+3xGzWRv16twuu1wU45VPOq6FMohKrWrANRo7TNO55MlkMz4sMI/P6yFbc+Tk8Vw3QYuCAC/IuUNAJfkwnEtaQo1k3xgv3+ATISmbgtblK2BiMpEZMiUAAUZAxVXAwDs11BN6Rt2G47KACwABhKYGEAGJSAA3CgAQjiOoCoqFA31cB1TAfZ90DfEwTA/AU1nnYVEzcM9EgAZmEJhklSOhrW6VE4EwhgIHrMAYCiLQYFiDkqlkIpMUwUIc1SApSmSWpoliTJnEAPCJkNSHhDDgIxlCgOBgFiOYQAgUQ/wAejosI8XGGA9AgORaAAZSMYBSFiCDoVhBcSwOAMMjOIpQxzWxsnKWomjNa5vEtfwaltZ09HQCAAHM4FQAJQjyTI9GANA4AACVTAB23dxFoVBjjCUg3LmVBSygPQ4AAbRiY5aHELBjhwkAQCiCEcEqMJsogXKAF1S1IFR+HgAKEWorRjlRY50HgVAPGdRKUoKorjlIABHFqxjairnRQuAAHEIAoWwXSMiS6NCUN5p1STSlqF1cgW0oQFTcalNYTBRjU2JCVm1apJSbaQE2vILp2vbUgO+skm8qI9FkVAkEfWR7syO61ryitXT+q77puuBMXBsG1uk50vp+9yClCWwTEvYo4AAHjgIpyhRzFy0gehBEfPyGXh77PoKBY4nR0ySmx3GEQ7QnRL84BSZgcmnS65KIogJKTNcEM4iZkAiyumjRdzCzmkh6XzIl5bc3FpoHn8KAqhc0aeaS1KsFodLMpK3KojS5qwlw6LtZCuBSwRhtaYxvIc0VtWWf8In2c57nnUwMIkE1tBbftyn3JAGmhbM16cZlhysyuKqat3AWhuOSA9GOTWXNQGBAACCOJy0tqAQCi8QUffZ2cZKeKE4dgSwkfIaAlAop6ZliWXajko8Ylj3SyuXmqibgamui44hg5qJh76wbcNICeOZ1hOk4ELDx8npvGvnxem+arQkdCVAI9Lf3A78+Lq3Gj7wgF6zMhgUh0C2XwIHEaIoCwPzA8Du4WxQYAuFYi4VjpRUA0taL0UYmhFicB2IASfK+Ak8lFIqU1upOCVgdSXmENfWQXhMgUGZIcdA/hRiDgEIA2sBIIAEkMLQWQYRy5YCMMA/iOUv7RToaQUIvweRaF+NEcQhIYSCC8M/fwABrS2ehYioDvoSO241xEMHEOgFAsg0CMNIElLAb8whDFoAgoCIE5IKWUqpdSMFMF/hwUAA\">https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAWQIYwBYBtgCMB0ARFJHAJQFMl0cAhJAZ2AGMAoUSWRFDbHAFSQZiMmTWjCgBXAeKik4AQTBgoEAB6gkWdKTIU4Ad1SkZTABRJFylXABccQKiEcQEmEcQFiEASlMMkk1AE8bcIAARHAgcAB2ADRwGrRwZhaqIXAAtNEJVmEB7nCAJkRxJgBMWW5wAHpxIMCZoWFuboDeBACdHkwQYKSZCkqq6pra5OjCACakAGZwo8ogAHIocZm2diW2XZa9WjroNgC8TADead1WAPo74RFMcHBePv5IcFhnWP704EwAvsJVokhhDLJ7MLvAIAeVGs3gqx6IA0GwG4X0hmMVwg4Lm1m2EymEPCwzGcBgEE2cSsK3S636FGWcEAuIRPXyXOC0aBQBlMEbjJBDIYkuD+MlHCmbalQtQwvrEjH7Q6WM6AbuAEdsAHxwFQ4cxHeYAagAjCUtXz1eltXqLlcbgw/NEHvTGeaKMwrk64AAfNUa2VmOAGvXew0exJen0lVImd3GkyPYN+3xGzWRv16twuu1wU45VPOq6FMohKrWrANRo7TNO55MlkMz4sMI/P6yFbc+Tk8Vw3QYuCAC/IuUNAJfkwnEtaQo1k3xgv3+ATISmbgtblK2BiMpEZMiUAAUZAxVXAwDs11BN6Rt2G47KACwABhKYGEAGJSAA3CgAQjiOoCoqFA31cB1TAfZ90DfEwTA/AU1nnYVEzcM9EgAZmEJhklSOhrW6VE4EwhgIHrMAYCiLQYFiDkqlkIpMUwUIc1SApSmSWpoliTJnEAPCJkNSHhDDgIxlCgOBgFiOYQAgUQ/wAejosI8XGGA9AgORaAAZSMYBSFiCDoVhBcSwOAMMjOIpQxzWxsnKWomjNa5vEtfwaltZ09HQCAAHM4FQAJQjyTI9GANA4AACVTAB23dxFoVBjjCUg3LmVBSygPQ4AAbRiY5aHELBjhwkAQCiCEcEqMJsogXKAF1S1IFR+HgAKEWorRjlRY50HgVAPGdRKUoKorjlIABHFqxjairnRQuAAHEIAoWwXSMiS6NCUN5p1STSlqF1cgW0oQFTcalNYTBRjU2JCVm1apJSbaQE2vILp2vbUgO+skm8qI9FkVAkEfWR7syO61ryitXT+q77puuBMXBsG1uk50vp+9yClCWwTEvYo4AAHjgIpyhRzFy0gehBEfPyGXh77PoKBY4nR0ySmx3GEQ7QnRL84BSZgcmnS65KIogJKTNcEM4iZkAiyumjRdzCzmkh6XzIl5bc3FpoHn8KAqhc0aeaS1KsFodLMpK3KojS5qwlw6LtZCuBSwRhtaYxvIc0VtWWf8In2c57nnUwMIkE1tBbftyn3JAGmhbM16cZlhysyuKqat3AWhuOSA9GOTWXNQGBAACCOJy0tqAQCi8QUffZ2cZKeKE4dgSwkfIaAlAop6ZliWXajko8Ylj3SyuXmqibgamui44hg5qJh76wbcNICeOZ1hOk4ELDx8npvGvnxem+arQkdCVAI9Lf3A78+Lq3Gj7wgF6zMhgUh0C2XwIHEaIoCwPzA8Du4WxQYAuFYi4VjpRUA0taL0UYmhFicB2IASfK+Ak8lFIqU1upOCVgdSXmENfWQXhMgUGZIcdA/hRiDgEIA2sBIIAEkMLQWQYRy5YCMMA/iOUv7RToaQUIvweRaF+NEcQhIYSCC8M/fwABrS2ehYioDvoSO241xEMHEOgFAsg0CMNIElLAb8whDFoAgoCIE5IKWUqpdSMFMF/hwUAA</a></p>\n<p>it demonstrates how we could have reals with computable data that approximate</p>",
        "id": 568119789,
        "sender_full_name": "Cookie Guy",
        "timestamp": 1768448356
    },
    {
        "content": "<p>this is great for <code>#eval!</code> but</p>",
        "id": 568120984,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768449429
    },
    {
        "content": "<p>what about writing proofs with them</p>",
        "id": 568121000,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768449436
    },
    {
        "content": "<p>can you demonstrate how you can use these approximations to prove a bound</p>",
        "id": 568121034,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768449470
    },
    {
        "content": "<p>You might define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">Approximation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℚ</span>\n<span class=\"w\">  </span><span class=\"n\">is_approx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span>\n</code></pre></div>\n<p>and constructing instances of this class for specific real numbers, and on the other hand prove lemmas or write computable functions taking instances of this class as arguments, similarly to what I do <a href=\"#narrow/channel/113489-new-members/topic/Compute.20roots.20of.20polynomials/near/420748541\">for polynomials</a>.</p>",
        "id": 568158212,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1768469064
    },
    {
        "content": "<p>Maybe we could change the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Order/CauSeq/Basic.html#IsCauSeq\">IsCauSeq</a> from <code>IsCauSeq abv f = ∀ ε &gt; 0, ∃ (i : ℕ), ∀ j ≥ i, abv (f j - f i) &lt; ε</code> to something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">IsCauSeq</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsStrictOrderedRing</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">abv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">existential</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">abv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">computable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">abv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"o\">})</span>\n</code></pre></div>\n<p>And then make Ring operations on <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Order/CauSeq/Completion.html#CauSeq.Completion.Cauchy\">CauSeq.Completion.Cauchy</a> \"try its best\" to preserve <code>computable</code> when possible?</p>",
        "id": 568163024,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768470343
    },
    {
        "content": "<p>I think instead of having this be part of the definition, having computable approximation as separate class as <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> suggested would be cleaner. But that would require adding class instances for all definitions that output Real I think?</p>",
        "id": 568163443,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768470463
    },
    {
        "content": "<p>Yet another idea is to have <code>Real</code> become a class, and have two different implementations of reals, one noncomputable and one computable.</p>",
        "id": 568164402,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768470723
    },
    {
        "content": "<p>As long as <code>IsCauSeq</code> is Prop it cannot carry any data for computability<br>\nIt looks like your <code>computable</code> can carry data while <code>existential</code> cannot; why do you want both?</p>",
        "id": 568175040,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1768473628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Reals.20computable.20.28sometimes.29.20using.20coercion/near/568175040\">said</a>:</p>\n<blockquote>\n<p>As long as <code>IsCauSeq</code> is Prop it cannot carry any data for computability</p>\n</blockquote>\n<p>Ah yes, you're right, we would have to make a change in the definition of <a href=\"https://api.cslib.io/docs/Mathlib/Algebra/Order/CauSeq/Basic.html#CauSeq\">CauSeq</a> instead of <code>IsCauSeq</code>.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Reals.20computable.20.28sometimes.29.20using.20coercion/near/568175040\">said</a>:</p>\n<blockquote>\n<p>It looks like your <code>computable</code> can carry data while <code>existential</code> cannot; why do you want both?</p>\n</blockquote>\n<p><code>computable</code> one lets you extract approximations. But not all reals can be defined using <code>computable</code> so you still need to be able to create reals with existential constructor.</p>",
        "id": 568177534,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768474405
    },
    {
        "content": "<p>In fact, maybe we could change definition of <a href=\"https://api.cslib.io/docs/Mathlib/Algebra/Order/CauSeq/Basic.html#CauSeq\">CauSeq</a> to <code>{ f : ℕ → β // ∀ ε &gt; 0, { i : ℕ // ∀ j ≥ i, abv (f j - f i) &lt; ε } }</code> and mark definitions of reals that require existential statement as <code>noncomputable</code>?</p>",
        "id": 568178962,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768474851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Reals.20computable.20.28sometimes.29.20using.20coercion/near/568178962\">said</a>:</p>\n<blockquote>\n<p>In fact, maybe we could change definition of <a href=\"https://api.cslib.io/docs/Mathlib/Algebra/Order/CauSeq/Basic.html#CauSeq\">CauSeq</a> to <code>{ f : ℕ → β // ∀ ε &gt; 0, { i : ℕ // ∀ j ≥ i, abv (f j - f i) &lt; ε } }</code> and mark definitions of reals that require existential statement as <code>noncomputable</code>?</p>\n</blockquote>\n<p>What does <code>{ f : ℕ → β // ∀ ε &gt; 0, { i : ℕ // ∀ j ≥ i, abv (f j - f i) &lt; ε } }</code> mean here? I am familiar with the syntax <code>{ x : X // P x }</code> if <code>P : X → Prop</code>, but I believe it isn't well-defined if <code>P</code> is Type-valued, as here. </p>\n<p>Are you aiming at something like this, maybe?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">CauSeqWithWitness</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"n\">bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"n\">h_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">bound</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ε</span>\n</code></pre></div>\n<p>And a CauchySeqWithWitness would count as being \"computable\" if both <code>f</code> and <code>bound</code> are computable functions?</p>",
        "id": 568196743,
        "sender_full_name": "David Loeffler",
        "timestamp": 1768480250
    },
    {
        "content": "<p>Ok so i was doing some thinking today about this, and I realized there is a far better solution</p>",
        "id": 568329863,
        "sender_full_name": "Cookie Guy",
        "timestamp": 1768519890
    },
    {
        "content": "<p>Rather than changing the underlying type on reals, its far less intrusive to make a typeclass instance on the values, similar to how the measurability tactic does it</p>",
        "id": 568329939,
        "sender_full_name": "Cookie Guy",
        "timestamp": 1768519938
    },
    {
        "content": "<p>we can make a tag called calculability which shows how to calculate something, even if the underlying type was defined in an incalculable way</p>",
        "id": 568330245,
        "sender_full_name": "Cookie Guy",
        "timestamp": 1768520125
    },
    {
        "content": "<p>since it is now a typeclass over reals, it also allows us to make a much nicer definition of approximability</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Calculable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Given ε &gt; 0, returns a rational approximation to r -/</span>\n<span class=\"w\">  </span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℚ</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The approximation is within ε of r -/</span>\n<span class=\"w\">  </span><span class=\"n\">modulus</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ε_pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">approx</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"n\">ε_pos</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ε</span>\n</code></pre></div>",
        "id": 568330441,
        "sender_full_name": "Cookie Guy",
        "timestamp": 1768520234
    },
    {
        "content": "<p>i have a working draft of it, though it does require two files to be created to allow aesop to work properly.</p>\n<p><a href=\"https://live.lean-lang.org/#codez=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\">https://live.lean-lang.org/#codez=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</a></p>",
        "id": 568330780,
        "sender_full_name": "Cookie Guy",
        "timestamp": 1768520433
    },
    {
        "content": "<p>to make aesop work, we need to create a new file Called <code>insert project</code>.Calculable.Init in<br>\nwith </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Aesop</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Init</span>\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># Calculable Rule Set</span>\n\n<span class=\"cm\">This module defines the `Calculable` Aesop rule set which is used by the</span>\n<span class=\"cm\">`approximation` tactic. Aesop rule sets only become visible once the file in which</span>\n<span class=\"cm\">they're declared is imported, so we must put this declaration into its own file.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">declare_aesop_rule_sets</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Calculable</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 568330985,
        "sender_full_name": "Cookie Guy",
        "timestamp": 1768520557
    },
    {
        "content": "<p>There are actually already several projects for making real numbers more computable and automating proofs for interval arithmetic on real numbers, the most recent one being <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/LeanBound.20-.20interval.20arithmetic.20for.20Lean.204/with/568110298\">#general &gt; LeanBound - interval arithmetic for Lean 4</a></p>",
        "id": 568331258,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1768520727
    },
    {
        "content": "<p>Another one is <a class=\"stream-topic\" data-stream-id=\"113486\" href=\"/#narrow/channel/113486-announce/topic/Computable.20Reals.20for.20native_decide/with/499057297\">#announce &gt; Computable Reals for native_decide</a> for example which works directly with <code>native_decide</code> (not quite <code>decide</code> but close)</p>",
        "id": 568331386,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1768520813
    }
]