[
    {
        "content": "<p>For what rings should there be an <code>Inv</code> instance that “computes” the inverse of an invertible element, extended in some way or some other? <br>\nMy question stems out the will to extend <code>MvPowerSeries.inv</code> from fields to arbitrary rings. However, for the moment, this is made difficult by the fact that it relies on some implicit <code>Inv k</code> instance for a field <code>k</code>, and assuming <code>Inv R</code> when <code>R</code>is a general ring does not seem to be sufficient. Replacing explicit inverses by <code>Ring.inverse</code> seems to be possible, though, but that will probably have a large number of side effects (maybe not…).</p>",
        "id": 449561375,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1720299783
    },
    {
        "content": "<p>What seems awkward to me is that rings have no <code>Inv</code> instance (that could rely on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ring.inverse#doc\">docs#Ring.inverse</a>) while matrix rings (over a commutative ring) have one, given by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.inv#doc\">docs#Matrix.inv</a>.</p>",
        "id": 449561473,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1720299869
    },
    {
        "content": "<p>What's the problem with just defining <code>inv</code> on an arbitrary monoid with 0 to be 0 if the element isn't invertible? I'm surprised we're not already doing this but something at the back of my mind is telling me that there's an issue with this idea</p>",
        "id": 449567532,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1720304334
    },
    {
        "content": "<p>The issue is that makes inverse on <code>Rat</code> noncomputable</p>",
        "id": 449574235,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720308506
    },
    {
        "content": "<p>(and on matrices)</p>",
        "id": 449574248,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720308531
    },
    {
        "content": "<p>Also it means you can't write <code>f \\inv</code> to mean \"fun x =&gt; (f x)\\inv`</p>",
        "id": 449574505,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720308836
    },
    {
        "content": "<p>What's the inverse of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>∈</mo><mi mathvariant=\"double-struck\">R</mi><mo>×</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">(0, 1) \\in \\mathbb{R} \\times \\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7722em;vertical-align:-0.0833em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>? According to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Pi.inv_apply#doc\">docs#Pi.inv_apply</a>, it needs to be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(0, 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>. So I think it's not possible to declare the inverse of every noninvertible element to be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>.</p>",
        "id": 449618085,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1720339112
    },
    {
        "content": "<p>My guess: <code>x ^ 2 * x⁻¹ = x</code>.</p>",
        "id": 449621645,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1720340681
    },
    {
        "content": "<p>Niven (1969) defines the subtypes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">P_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">P_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, where the power series have 0 or 1 as constant coefficient. Would subtyping be a solution?</p>",
        "id": 449622566,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1720341322
    },
    {
        "content": "<p>I should be clearer about what I intended to do.</p>\n<p>For all rings, there is a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ring.inverse#doc\">docs#Ring.inverse</a> function that returns their inverse for invertible elements, and zero otherwise.<br>\nSome rings have a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Inv#doc\">docs#Inv</a> instance that may coincide with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ring.inverse#doc\">docs#Ring.inverse</a>, or not. <br>\nFor example, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Pi.inv#doc\">docs#Pi.inv</a> returns the pointwise inverse (so differs from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ring.inverse#doc\">docs#Ring.inverse</a>), but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.inv#doc\">docs#Matrix.inv</a> is an <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Inv#doc\">docs#Inv</a> instance that provides the same result as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ring.inverse#doc\">docs#Ring.inverse</a>. Consequently, the identification of a product of matrix rings with the matrix ring of their products is not compatible with the two <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Inv#doc\">docs#Inv</a> instances on that rings. They could be aligned by not using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ring.inverse#doc\">docs#Ring.inverse</a> of the determinant, but a preferred <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Inv#doc\">docs#Inv</a> instance on the coefficient ring.</p>\n<p>For the moment, power series over a field have an <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Inv#doc\">docs#Inv</a> instance, which is compatible with the output of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ring.inverse#doc\">docs#Ring.inverse</a>, that relies on the natural (and reasonable) <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Inv#doc\">docs#Inv</a>  instance on a group with zero.<br>\nMy goal was to extend it somewhat to arbitrary rings. The most natural thing would be to use a given <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Inv#doc\">docs#Inv</a> instance on the coefficients, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Inv#doc\">docs#Inv</a>  does not provide any of the natural functional equations that make the construction meaningful. (I have not taken the time to check precisely which functional equations would be needed.)</p>",
        "id": 449705863,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1720379269
    },
    {
        "content": "<p>I've thought about this issue too; but I think the only way out here is to add an <code>inv</code> field to monoids, constrained only when the argument is a unit, and defaulting this to Ring.inverse.</p>",
        "id": 449724387,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720387844
    },
    {
        "content": "<p>Note that if we don't build this into Monoid itself, then we end up with the unpleasantness of not being able to invert the identity matrix over integers</p>",
        "id": 449724392,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720387846
    },
    {
        "content": "<p>But if we do that, then <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monoid.ext#doc\">docs#Monoid.ext</a> stops being true!</p>",
        "id": 449724403,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720387860
    },
    {
        "content": "<p>Of course, this new structure would be a “monoid with inv”, which is not at all a monoid. Possibly, this class structure would partially play the role that is now played by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=GroupWithZero#doc\">docs#GroupWithZero</a>.<br>\nBut maybe we could do things differently, for example, locally, we could start asking what <code>Inv</code> map we wish to use (thus removing most ambiguous <code>Inv</code> instances).</p>",
        "id": 449724890,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1720388307
    },
    {
        "content": "<p>I mean you're basically reinventing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DivisionMonoid#doc\">docs#DivisionMonoid</a>. I even have a comment explaining the various axioms that you could weaken so that it applies to matrices</p>",
        "id": 449775289,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1720415101
    },
    {
        "content": "<p>What would you weaken to make it apply to Int? (With inv defined on the units and zero everywhere else)</p>",
        "id": 449823940,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720432508
    },
    {
        "content": "<p>You don't even get div_eq_mul_inv there!</p>",
        "id": 449824169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720432599
    }
]