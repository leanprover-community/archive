[
    {
        "content": "<p>There's a lot of API duplicated (inconsistently) in this area of the algebra library. I've tried factoring the proof closure is a Galois insertion into a typeclass: <a href=\"https://github.com/leanprover-community/mathlib4/pull/20621\">#20621</a><br>\nAny thoughts?</p>",
        "id": 492863577,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736477042
    },
    {
        "content": "<p>I think this is an interesting idea to pursue. It should (in a follow-up PR, I guess) also be used to deduplicate <code>Submodule.span</code> and <code>LieModule.lieSpan</code>.</p>",
        "id": 492891424,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736494002
    },
    {
        "content": "<p>But let's make sure that we get the definition right, and not run into troubles with definitional equalities.</p>",
        "id": 492891486,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736494029
    },
    {
        "content": "<p>You currently have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">SetLikeCompleteLattice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">CompleteLattice</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le_def'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">instPartialOrder</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">lt_def'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLT</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">instPartialOrder</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">coe_sInf'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">InfSet</span><span class=\"bp\">.</span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and this is needed because <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SetLike.instPartialOrder#doc\">docs#SetLike.instPartialOrder</a> is creating data.</p>\n<p>But I think we are asking for trouble if we push along like this.<br>\nInstead, <code>SetLike</code> should extend <code>PreOrder</code>, I think.</p>",
        "id": 492891993,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736494295
    },
    {
        "content": "<p>I've wondered about this as well. Would one option be to extend SetLike to have an additional Prop-valued axiom stating that every Set-theoretic intersection is in the image of the coercion?</p>",
        "id": 492896505,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1736496396
    },
    {
        "content": "<p>What do you mean exactly?</p>",
        "id": 492896780,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736496527
    },
    {
        "content": "<p>Ooh, I see. You want to say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>a</mi><mi>b</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∃</mi><mi>c</mi><mo separator=\"true\">,</mo><mtext>coe</mtext><mtext> </mtext><mi>c</mi><mo>=</mo><mtext>coe</mtext><mtext> </mtext><mi>a</mi><mo>∩</mo><mtext>coe</mtext><mtext> </mtext><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">\\forall a b, \\exists c, \\text{coe}\\, c = \\text{coe}\\, a \\cap \\text{coe}\\, b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">ab</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\">c</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">coe</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5556em;\"></span><span class=\"mord text\"><span class=\"mord\">coe</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">coe</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></p>",
        "id": 492896930,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736496599
    },
    {
        "content": "<p>And maybe also for infinite intersections</p>",
        "id": 492897011,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736496622
    },
    {
        "content": "<p>Yes, exactly. Something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">SubobjectLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">a₀</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⋂</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SubobjectLike</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n</code></pre></div>\n<p>One annoying this is that <code>A</code> needs to be explicit, so you would still need separate declarations for all the various closures (unless you want to be writing things like <code>closure (IntermediateField K L) S</code>), but you could at least use this to streamline things.</p>",
        "id": 492898746,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1736497340
    },
    {
        "content": "<p><code>A</code> doesn't have to be explicit, right? It can be inferred from the expected type.<br>\nAnd when that is not available, we can use <code>(A := _)</code> syntax to supply it.</p>",
        "id": 492898883,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736497416
    },
    {
        "content": "<p>But still, I don't like the idea of creating more and more data out of the original <code>SetLike</code> class.</p>",
        "id": 492898979,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736497447
    },
    {
        "content": "<p>The mathlib pattern is to avoid creating data, and extending it instead.</p>",
        "id": 492899014,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736497465
    },
    {
        "content": "<p>What do you mean by creating data here?</p>",
        "id": 492899067,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1736497498
    },
    {
        "content": "<p>And we can provide a constructor with minimal axioms, so that the data can still be created when needed.</p>",
        "id": 492899068,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736497498
    },
    {
        "content": "<p>In this case <code>closure</code>. Because now it will not be defeq to the current defn of <code>Submodule.span R s</code> etc...</p>",
        "id": 492899233,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736497566
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SetLike.instPartialOrder#doc\">docs#SetLike.instPartialOrder</a> is a mathlib-antipattern.</p>",
        "id": 492899297,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736497613
    },
    {
        "content": "<p>Ah, so would it be better to have a predicate <code>IsClosureOperator</code>with instances for <code>span</code>, <code>adjoin</code>, etc..., with all the relevant API?</p>",
        "id": 492899397,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1736497664
    },
    {
        "content": "<p>Or I suppose you could include <code>closure</code> in the data of <code>SubobjectLike</code>, but have a constructor just assuming the axiom <code>foo</code>. Is that closer to what you're thinking?</p>",
        "id": 492899894,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1736497859
    },
    {
        "content": "<p>Exactly</p>",
        "id": 492900107,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736497936
    },
    {
        "content": "<p>Additionally, <code>SetLike</code> should extend <code>PartialOrder</code>, with a separate constructor that only assumes the current fields</p>",
        "id": 492900190,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736497977
    },
    {
        "content": "<p>Right. Also, what's the pros and cons of extends vs typeclass assumption:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">SubobjectLike₁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"n\">closure_le_iff</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>vs</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">SubobjectLike₂</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"n\">closure_le_iff</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>",
        "id": 492900403,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1736498075
    },
    {
        "content": "<p>For <code>SetLike</code> and <code>PartialOrder</code> it should be extends, since there are cases where you want to get the <code>PartialOrder</code> from the minimal <code>SetLike</code> constructor. But does it matter here?</p>",
        "id": 492900551,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1736498144
    },
    {
        "content": "<p>Not much difference, except in the amount of typing when setting up your <code>variable</code> lines</p>",
        "id": 492900564,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736498152
    },
    {
        "content": "<p>Oh, I guess <code>SubobjectLike</code>should also extend <code>CompleteLattice</code> since that has data.</p>",
        "id": 492900721,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1736498205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abstracting.20out.20.2Eclosure.2C.20.2Eadjoin/near/492891424\">said</a>:</p>\n<blockquote>\n<p>I think this is an interesting idea to pursue. It should (in a follow-up PR, I guess) also be used to deduplicate <code>Submodule.span</code> and <code>LieModule.lieSpan</code>.</p>\n</blockquote>\n<p>as well as (<code>Add</code>)<code>Submonoid.closure</code> and (<code>Add</code>)<code>Subgroup.closure</code>?</p>",
        "id": 492911495,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736502034
    },
    {
        "content": "<p>I've been meaning to kill <code>SetLike.instPartialOrder</code> and introduce a new class <code>OrderedSetLike</code> instead. It's really annoying that currently the semantics confuse \"I have an injective coercion to sets\" with \"I have an injective coercion to sets that orders me\". Eg this is wrong for upper sets (wrong way around) and partitions (completely nonsense).</p>",
        "id": 492913731,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1736502815
    },
    {
        "content": "<p>I'm working on a refactor right now.</p>",
        "id": 492916161,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736503621
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> What would you like to happen with upper sets?</p>",
        "id": 492920806,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736505210
    },
    {
        "content": "<p>Atm, I'm not giving them any instance. Otherwise we need some <code>ContravariantlyOrderedSetLike</code>. That is out of scope for my refactor.</p>",
        "id": 492921054,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736505284
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abstracting.20out.20.2Eclosure.2C.20.2Eadjoin/near/492898979\">said</a>:</p>\n<blockquote>\n<p>But still, I don't like the idea of creating more and more data out of the original <code>SetLike</code> class.</p>\n</blockquote>\n<p>I actually think that this is acceptable as long as we do this for <em>all</em> the data, but indeed as <span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> points out, the data constructed isn't right for some situations.</p>",
        "id": 492922043,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736505619
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/20638\">#20638</a> -- I've tried to make this PR minimally invasive, but it still touches a lot of files.</p>",
        "id": 492975033,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736523533
    },
    {
        "content": "<p>i've just realised, since \"ordered sets\" exist in math, maybe <code>OrderedSetLike</code> is a bad name?</p>",
        "id": 492979679,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736524981
    },
    {
        "content": "<p>because the ordering is not on the elements of the sets, like for posets (partially ordered sets), but on the collection of sets under consideration?</p>",
        "id": 492979744,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736525002
    },
    {
        "content": "<p>We have ConcreteCategory, so maybe ConcretePartialOrder?</p>",
        "id": 492984255,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736526518
    },
    {
        "content": "<p>maybe we just don't want this as a class, and instead want a <code>SetLike.toPartialOrder</code> definition which occasionally gets used for an <code>instance</code>?</p>",
        "id": 493006336,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736534610
    },
    {
        "content": "<p>(that seems like maybe a smaller PR)</p>",
        "id": 493006621,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736534708
    },
    {
        "content": "<p>Well, the followup goal was to unify all the span and closure operators... so we need a class for those. And that would be a superclass of this one.</p>",
        "id": 493013970,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736537702
    },
    {
        "content": "<p>How do we maintain the defeq of the bottom element of our lattice of substructures?</p>",
        "id": 493023384,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736542096
    },
    {
        "content": "<p>Everything apart from bot and sup is determined by the \"nice\" embedding into our powerset, so we can just define those fields  explicitly within our default instance, and sup isn't ususally given an explicit definition in favour of an induction principle, but bot isn't determined, yet is usually given an explicit definition.</p>",
        "id": 493023622,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736542211
    },
    {
        "content": "<p>eg<br>\nbot : Subsemigroup S = emptyset<br>\nbot : Subgroup G = {1}<br>\nbot : Subring R = {0,1,2,...}<br>\nbot : Subalgebra R A = range (embedding R -&gt; A)</p>",
        "id": 493023739,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736542280
    },
    {
        "content": "<p>We might have to maintain that <code>coe_sInf'</code> axiom rather than doing it via an instance heirarchy</p>",
        "id": 493023872,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736542343
    },
    {
        "content": "<p>Right now we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"s2\">\"The `AddSubsemigroup`s of an `AddMonoid` form a complete lattice.\"</span><span class=\"kd\">]</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompleteLattice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subsemigroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">completeLatticeOfInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subsemigroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">IsGLB</span><span class=\"bp\">.</span><span class=\"n\">of_image</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe_subset_coe</span><span class=\"w\"> </span><span class=\"n\">isGLB_biInf</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">bot</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⊥</span>\n<span class=\"w\">    </span><span class=\"n\">bot_le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">not_mem_bot</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"w\">    </span><span class=\"n\">top</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span>\n<span class=\"w\">    </span><span class=\"n\">le_top</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">mem_top</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">inf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">InfSet</span><span class=\"bp\">.</span><span class=\"n\">sInf</span>\n<span class=\"w\">    </span><span class=\"n\">le_inf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">inf_le_left</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">left</span>\n<span class=\"w\">    </span><span class=\"n\">inf_le_right</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>and yeah, given a proof of <code>∀ S : Set A, ∃ a₀ : A, coe a₀ = ⋂ a ∈ S, coe a</code>, all those data fields can be generated in a way that's defeq to rn.. except <code>bot</code></p>",
        "id": 493024415,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736542627
    },
    {
        "content": "<p>You can always have a constructor that takes in any data you want to preserve (e.g., bot and closure) and autogenerates the rest.</p>",
        "id": 493026077,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1736543414
    },
    {
        "content": "<p>Oh you're so right<br>\nWait that's literally how this complete lattice instance is working!</p>",
        "id": 493026181,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736543474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abstracting.20out.20.2Eclosure.2C.20.2Eadjoin/near/492975033\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/20638\">#20638</a> -- I've tried to make this PR minimally invasive, but it still touches a lot of files.</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A class to indicate that there is a canonical order preserving injection</span>\n<span class=\"sd\">between `A` and `Set B`. -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">OrderedSetLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The coercion from a term of a `SetLike` to its corresponding `Set`. -/</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">B</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The coercion from a `SetLike` type preserves the ordering. -/</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">coe_subset_coe'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">T</span>\n</code></pre></div>\n<p>Doesn't this class also kill the defeq of \"≤\" as \"coe · ⊆ coe ·\", just like my proposal? I spelled mine in that way with the technical instances just so I wouldn't have to think about the proofs I was copying. I could spell it your way, but it wouldn't get around this issue of the definitional equality being erased in the abstract.</p>",
        "id": 493027133,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736543997
    },
    {
        "content": "<p>that's up to instances to decide; see for example <a href=\"https://github.com/leanprover-community/mathlib4/pull/20638/files#diff-770c557a0ae5a944d3298b9ed5221d7a848458ed18fbe216f5b4a7cd29c83a92R197-R201\">here</a> in Johan's PR</p>",
        "id": 493028826,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736544832
    },
    {
        "content": "<p>Oh yeah for sure, every concrete instance will have the right definitional equalities<br>\nBut they won't be accessible just from the class assumption i.e. when we are proving stuff about the Galois insertion</p>",
        "id": 493029057,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736544922
    },
    {
        "content": "<p>Maybe this isn't an issue but I thought that was undesirable?<br>\nThen the \\bot thing isn't an issue either</p>",
        "id": 493029116,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736544951
    },
    {
        "content": "<p>if it's used when proving stuff, since it is propeq, it shouldn't be an issue, no?</p>",
        "id": 493029283,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736545020
    },
    {
        "content": "<p>well, the proofs have to be changed<br>\nfrom the current ones<br>\nbut yes it's not a huge deal</p>",
        "id": 493029392,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736545071
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abstracting.20out.20.2Eclosure.2C.20.2Eadjoin/near/492975033\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/20638\">#20638</a> -- I've tried to make this PR minimally invasive, but it still touches a lot of files.</p>\n</blockquote>\n<p>Why doesn't <code>OrderedSetLike</code> extend <code>SetLike</code>?</p>",
        "id": 493125388,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736627364
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 493126516,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736628568
    },
    {
        "content": "<p>OK, my new definition is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">LatticeSetLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">CompleteLattice</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">OrderedSetLike</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe_sInf'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">InfSet</span><span class=\"bp\">.</span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 493141393,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736643484
    },
    {
        "content": "<p>But when I try to use it in practice it doesn't work nicely, and I'm not sure how to fix it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LatticeSetLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subsemigroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">__</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompleteLattice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subsemigroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"bp\">__</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OrderedSetLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subsemigroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">coe_sInf'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">OrderedSetLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>(this is on top of the changes in <a href=\"https://github.com/leanprover-community/mathlib4/pull/20638\">#20638</a>)</p>",
        "id": 493141410,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736643520
    },
    {
        "content": "<p>How can I make it so the instance is just the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LatticeSetLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subsemigroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe_sInf'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 493141440,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736643562
    },
    {
        "content": "<p>never mind, fixed it all!<br>\nattempt 2: <a href=\"https://github.com/leanprover-community/mathlib4/pull/20621\">#20621</a> (building on <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>'s PR)</p>",
        "id": 493147050,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736649317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253861\">Thomas Browning</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abstracting.20out.20.2Eclosure.2C.20.2Eadjoin/near/492899894\">said</a>:</p>\n<blockquote>\n<p>Or I suppose you could include <code>closure</code> in the data of <code>SubobjectLike</code>, but have a constructor just assuming the axiom <code>foo</code>. Is that closer to what you're thinking?</p>\n</blockquote>\n<p>I've implemented this (except I didn't include closure as data, instead I included all the lattice data)</p>",
        "id": 493147182,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736649454
    },
    {
        "content": "<p>(Renamed the thread to clarify the scope -- most of the duplicated lemmas are about closures but the construction of the <code>CompleteLattice</code> instance is also duplicated.)</p>",
        "id": 493228080,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736721357
    },
    {
        "content": "<p>Linking to the parallel thread <a href=\"#narrow/channel/287929-mathlib4/topic/proposal.3A.20lattice.20operations.20on.20.60SetLike.60s.3F\">#mathlib4 &gt; proposal: lattice operations on &#96;SetLike&#96;s?</a> with a very similar proposal by <span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span></p>",
        "id": 493320882,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736766084
    },
    {
        "content": "<p>I think one downside of <code>LatticeSetLike</code> is that it will require duplicating the order hierarchy.<br>\nFor that reason, it might be better to have a mixin, on top of <code>SetLike</code> and <code>LE</code>.</p>",
        "id": 493321061,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736766144
    },
    {
        "content": "<p>Here is a rough sketch/proposal</p>\n<ul>\n<li><code>LE X</code> -- ordering</li>\n<li><code>SetLike X Y</code> -- coercion (injective)</li>\n<li><code>IsConcrete X Y</code> -- coercion is order preserving, mixin depending on <code>LE X</code> and <code>SetLike X</code></li>\n<li><code>CompleteLattice X</code> etc -- order hierarchy, extending <code>LE X</code></li>\n<li><code>HasSpan Y X</code> -- a notation typeclass for a function <code>span : Set Y -&gt; X</code></li>\n<li><code>IsConcreteWithSpan X Y</code> -- the span is a closure operator, and gives a Galois connection together with the <code>coe</code>, extending <code>IsConcrete X Y</code> and <code>HasSpan X Y</code>. (Probably needs a better name.)</li>\n</ul>",
        "id": 493321609,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736766331
    },
    {
        "content": "<p>In particular, the <code>OrderedSetLike</code> from my PR would be replaced by the <code>IsConcrete</code> mixin.</p>",
        "id": 493321757,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736766373
    },
    {
        "content": "<p>I agree that mixins would be a nice way to save us from having to duplicate the order hierarchy (at the expense of some amount of discoverability).</p>",
        "id": 493322244,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1736766529
    },
    {
        "content": "<p>How would we deal with <code>CompleteLattice</code> + <code>IsConcrete</code> together implying <code>IsConcreteWithSpan</code>? (Since we could also define the span of a set <code>s</code> in a setlike <code>S</code> as the infimum of <code>{x : S | s \\subset coe x}</code>.)</p>",
        "id": 493322604,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1736766630
    },
    {
        "content": "<p>That would be a separate constructor, right?</p>",
        "id": 493322743,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736766678
    },
    {
        "content": "<p>I suppose we would need a separate constructor anyway, since not every definition of spans would go through taking infima.</p>",
        "id": 493325657,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1736767593
    },
    {
        "content": "<p>/poll if/when we merge the \"closure\" functions, what should it be called:<br>\n<code>closure</code> (even though <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=closure#doc\">docs#closure</a> already exists)<br>\n<code>span</code><br>\n<code>adjoint</code></p>",
        "id": 493330016,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736768898
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=closure#doc\">docs#closure</a></p>",
        "id": 493330076,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736768914
    },
    {
        "content": "<p>i'd really like for this to be called <code>closure</code> if it's possible to avoid a clash with the preexisting topological <code>closure</code>. And <code>adjoint</code> is very undescript, imo.</p>",
        "id": 493330450,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736769029
    },
    {
        "content": "<p>Can we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- U+29FC ⧼ LEFT-POINTING CURVED ANGLE BRACKET and U+29FD ⧽</span>\n</code></pre></div>\n<p>as notation?</p>",
        "id": 493366763,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736778811
    },
    {
        "content": "<p>I know <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ClosureOperator#doc\">docs#ClosureOperator</a> is a thing, but all over algebra these constructions are called <code>span</code>. Hence my vote.<br>\nIt is also shorter.</p>",
        "id": 493366957,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736778855
    },
    {
        "content": "<p>Is notation going to help? How do we plan to distinguish <code>Submodule.span SomeLongRing {v}</code> and <code>Algebra.adjoin SomeLongRing {x}</code>?</p>",
        "id": 493367436,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736778979
    },
    {
        "content": "<p><code>(⧼v⧽ : Submodule SomeLongRing _)</code> I guess? But we'd end up with the annotation pretty much all the time.</p>",
        "id": 493367610,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736779030
    },
    {
        "content": "<p>I'm hoping the expected type will solve this very often.</p>",
        "id": 493367756,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736779078
    },
    {
        "content": "<p>And otherwise we can have <code>⧼v⧽_[Submodule SomeLongRing _]</code></p>",
        "id": 493367997,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736779143
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abstracting.20the.20substructure.20lattice.20construction/near/493366763\">said</a>:</p>\n<blockquote>\n<p>Can we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- U+29FC ⧼ LEFT-POINTING CURVED ANGLE BRACKET and U+29FD ⧽</span>\n</code></pre></div>\n<p>as notation?</p>\n</blockquote>\n<p>which of these do you mean?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"c1\">-- version A</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⧼</span><span class=\"n\">s</span><span class=\"bp\">⧽</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- Subring R</span>\n<span class=\"c1\">-- version B</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⧼</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">⧽</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- Subring R</span>\n</code></pre></div>",
        "id": 493368144,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736779186
    },
    {
        "content": "<p>This raises the fact that we could perhaps just use a coercion?</p>",
        "id": 493368294,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736779215
    },
    {
        "content": "<p><code>⧼x : R | P x⧽</code> seems too magic to me, but <code>⧼{x : R | P x}⧽</code> is a bit noisy</p>",
        "id": 493368442,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736779260
    },
    {
        "content": "<p>perhaps we can have a default instance depending on opened scope?</p>",
        "id": 493370350,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736779765
    },
    {
        "content": "<p>I meant both notations! And <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I don't agree it is too magic. It's notation that is very common on the literature.</p>",
        "id": 493370938,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736779892
    },
    {
        "content": "<p>Would it support the entire family of set literal notations?</p>",
        "id": 493371107,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736779925
    },
    {
        "content": "<p>we likely can't have both <code>⧼s⧽</code> (referring to the closure of a set) and <code>⧼x⧽</code> (referring to the closure of a single element)</p>",
        "id": 493371528,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736780017
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Yes. Although there might be some edge cases that I fail to think of right now.</p>",
        "id": 493371776,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736780075
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abstracting.20the.20substructure.20lattice.20construction/near/493367756\">said</a>:</p>\n<blockquote>\n<p>I'm hoping the expected type will solve this very often.</p>\n</blockquote>\n<p>Very often you want to prove things relating closures to each other, though. In particular, because explicit use of sums is discouraged, you often want to prove theorems of the form</p>\n<p><code>(SubObject1.closure s : Set G) = (SubObject2.closure (f s) : Set G)</code>.</p>",
        "id": 493373688,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736780543
    },
    {
        "content": "<p>we will have the type ascription issue anyway, since <code>HasSpan.span s</code> will also complain.</p>",
        "id": 493375854,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736781121
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> re your proposal:<br>\nPart of what I am trying to abstract out is the construction of a lattice instance on <code>Subobject</code>. Specifically, the result is that, if the coercion reflects arbitrary infima, then <code>Subobject</code> gets a <code>CompleteLattice</code> instance and a closure operator for free.</p>\n<p>I'm trying to think how this fits into your proposal. Just as we define a constructor for <code>IsConcrete</code> from <code>SetLike</code>, we can define constructors for <code>CompleteLattice</code>, <code>HasSpan</code> and <code>IsConcreteWithSpan</code> from <code>IsConcrete</code> under the additional assumption that <code>SetLike.coe</code> reflects (arbitrary) infima. Is this the intended pattern?</p>",
        "id": 493376803,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736781357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abstracting.20the.20substructure.20lattice.20construction/near/493321061\">said</a>:</p>\n<blockquote>\n<p>I think one downside of <code>LatticeSetLike</code> is that it will require duplicating the order hierarchy.<br>\nFor that reason, it might be better to have a mixin, on top of <code>SetLike</code> and <code>LE</code>.</p>\n</blockquote>\n<p>Sorry, I'm not sure what this means. What is going to be duplicated? If you have <code>closure s</code> defined as <code>sInf {l : L | s ≤ l}</code>, then you have arbitrary infima, and so a complete lattice.</p>",
        "id": 493377209,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736781473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abstracting.20the.20substructure.20lattice.20construction/near/493375854\">said</a>:</p>\n<blockquote>\n<p>we will have the type ascription issue anyway, since <code>HasSpan.span s</code> will also complain.</p>\n</blockquote>\n<p>True. In my proposal, I have the lattice type <code>L</code> as an explicit argument to <code>closure</code>. Then I introduce abbreviations</p>\n<p><code>abbrev Subsemigroup.closure = LatticeSetLike.closure (Subsemigroup S)</code></p>",
        "id": 493377525,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736781560
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abstracting.20the.20substructure.20lattice.20construction/near/493377209\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abstracting.20the.20substructure.20lattice.20construction/near/493321061\">said</a>:</p>\n<blockquote>\n<p>I think one downside of <code>LatticeSetLike</code> is that it will require duplicating the order hierarchy.<br>\nFor that reason, it might be better to have a mixin, on top of <code>SetLike</code> and <code>LE</code>.</p>\n</blockquote>\n<p>Sorry, I'm not sure what this means. What is going to be duplicated? If you have <code>closure s</code> defined as <code>sInf {l : L | s ≤ l}</code>, then you have arbitrary infima, and so a complete lattice.</p>\n</blockquote>\n<p>it means that not only will the approach use <code>LatticeSetLike</code>, but also <code>SemiLatticeSupSetLike</code>, <code>SemiLatticeInfSetLike</code>, and similar for a whole bunch of superclasses of <code>Lattice</code></p>",
        "id": 493377874,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736781651
    },
    {
        "content": "<p>I'm not sure I understand. Those subclasses appear unnecessary to me because eg a <code>SemiLatticeSup</code> and <code>SemiLatticeInf</code> <em>are</em> <code>CompleteLattice</code>s, with the rest of the operations determined uniquely. If you have a well-behaved <code>sInf</code> operation in a poset, you have a complete lattice.</p>",
        "id": 493378307,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736781758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abstracting.20the.20substructure.20lattice.20construction/near/493375854\">said</a>:</p>\n<blockquote>\n<p>we will have the type ascription issue anyway, since <code>HasSpan.span s</code> will also complain.</p>\n</blockquote>\n<p><code>span (as := Subgroup G) s</code> <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 493378733,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736781857
    },
    {
        "content": "<p>you would have to write that every time -- it can't infer the type in practice!</p>",
        "id": 493378874,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736781897
    },
    {
        "content": "<p><code>(span s : Subgroup G)</code> is shorter</p>",
        "id": 493379042,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736781940
    },
    {
        "content": "<p>Note that we actually already have notation for this in mathlib, for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IntermediateField.adjoin#doc\">docs#IntermediateField.adjoin</a> (<code>F⟮α⟯</code>)</p>",
        "id": 493379104,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736781957
    },
    {
        "content": "<p>I think that, if we are explicitly annotating the type every time, then the information allowing us to determine the type should just be an explicit argument</p>",
        "id": 493379449,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736782044
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400289\">@Artie Khovanov</span> I agree that everything will be a complete lattice, but what if I want to have a complete Boolean algebra, say? Or some other wacky combo.</p>",
        "id": 493379493,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736782057
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abstracting.20the.20substructure.20lattice.20construction/near/493367997\">said</a>:</p>\n<blockquote>\n<p>And otherwise we can have <code>⧼v⧽_[Submodule SomeLongRing _]</code></p>\n</blockquote>\n<p>We can have notation that includes the type.</p>",
        "id": 493379688,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736782098
    },
    {
        "content": "<p>Ah right, I see. I didn't think about extending upwards. I guess this way allows us to unify other closure operations as well, such as topological closure?</p>",
        "id": 493379747,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736782115
    },
    {
        "content": "<p>I'm not really a fan of notation that just reinvents type ascription</p>",
        "id": 493379754,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736782118
    },
    {
        "content": "<p><code>⧼v⧽_[Submodule SomeLongRing _]</code> is only one character shorter than <code>(⧼v⧽ : Submodule SomeLongRing _)</code></p>",
        "id": 493379851,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736782141
    },
    {
        "content": "<p>I think it's important to <em>force</em> users to specify the type, otherwise it's a massive footgun for people unfamiliar with this part of the library (as well as being confusing from a mathematical perspective).<br>\nYou can always add namespaced abbrevs</p>",
        "id": 493380018,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736782190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abstracting.20the.20substructure.20lattice.20construction/near/493379851\">said</a>:</p>\n<blockquote>\n<p><code>⧼v⧽_[Submodule SomeLongRing _]</code> is only one character shorter than <code>(⧼v⧽ : Submodule SomeLongRing _)</code></p>\n</blockquote>\n<p>removing the underscore inbetween, 2 characters <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 493380158,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736782218
    },
    {
        "content": "<p>I don't think forcing it is really a notation question, users can still not specify it by writing <code>⧼v⧽_[_]</code></p>",
        "id": 493380301,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736782253
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abstracting.20the.20substructure.20lattice.20construction/near/493321609\">said</a>:</p>\n<blockquote>\n<ul>\n<li><code>IsConcrete X Y</code> -- coercion is order preserving, mixin depending on <code>LE X</code> and <code>SetLike X</code></li>\n</ul>\n</blockquote>\n<p>We could call this <code>IsConcreteLE</code>?<br>\nSorry this is getting a bit bikeshed, I'll go ahead and write this proposal up tonight probably so we have something concrete to look at.</p>",
        "id": 493381111,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736782452
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> not sure how to prove <code>IsConcrete</code> for the default <code>SetLike</code> order nicely. Right now I have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A class to indicate that the canonical injection between `A` and `Set B` is order-preserving. -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsConcreteLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The coercion from a `SetLike` type preserves the ordering. -/</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">coe_subset_coe'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">x</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">K</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">__</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">toLE</span>\n<span class=\"w\">  </span><span class=\"bp\">__</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">coe_injective</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">IsConcreteLE</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 493479587,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736813743
    },
    {
        "content": "<p>Is the problem that you have to specify <code>toLE</code> explicitly here? You can use <code>attribute [local instance]</code> to add it to the available instances in the current scope, for example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.SetLike.Basic</span>\n\n<span class=\"sd\">/-- A class to indicate that the canonical injection between `A` and `Set B` is order-preserving. -/</span>\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">IsConcreteLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The coercion from a `SetLike` type preserves the ordering. -/</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">coe_subset_coe'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetLike.coe</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">SetLike.coe</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">SetLike</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/--</span>\n\n<span class=\"sd\">This is an `abbrev` so that it can reduce when it is a local instance.</span>\n<span class=\"sd\">See note [reducible non-instances].</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">x</span><span class=\"o\">⦄,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">K</span>\n\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">__</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">toLE</span>\n<span class=\"w\">  </span><span class=\"n\">__</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PartialOrder.lift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SetLike.coe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">coe_injective</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kd\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">toPartialOrder</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsConcreteLE</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">⟨</span><span class=\"n\">Iff.rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">end</span><span class=\"w\"> </span><span class=\"n\">SetLike</span>\n</code></pre></div>",
        "id": 493535933,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1736844082
    },
    {
        "content": "<p>(It's also a good idea to make <code>def</code>s that will act like instances into <code>abbrev</code>s, because declaring instances makes them more reducible than default.)</p>",
        "id": 493536240,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1736844209
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> by the way, my editor cannot ever find the note <code>[reducible non-instances]</code>. How do I get it to appear?<br>\nAlso, what is the difference between <code>abbrev</code> and <code>@[reducible] def</code>?</p>",
        "id": 493572340,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736856979
    },
    {
        "content": "<p>The note lives in <code>Mathlib/Algebra/HierarchyDesign.lean</code>. Maybe it's not found because it's not imported?</p>",
        "id": 493572540,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1736857054
    },
    {
        "content": "<p><code>abbrev</code> does slightly more than <code>@[reducible]</code>, I think it at least adds <code>@[inline]</code> as well. But I don't recall the details. Mostly I use it because it's somewhat nicer to read than <code>@[reducible]</code> def.</p>",
        "id": 493572793,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1736857145
    },
    {
        "content": "<p>OK, the design has now been implemented (for one example) in <a href=\"https://github.com/leanprover-community/mathlib4/pull/20836\">#20836</a>, feel free to check it out and give feedback</p>",
        "id": 494480140,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1737175089
    },
    {
        "content": "<p>didn't implement the notation because I don't know how to do that</p>",
        "id": 494481707,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1737176604
    },
    {
        "content": "<p>hm<br>\nterminological question: I would naively interpret <code>HasClosure</code> as referring to a closure operator cl:A -&gt; A<br>\nof course, such operators are precisely the ones arising from a Galois insertion (eg from (cl '' A) to A), but maybe we should have a different name for what is just the property of SetLike.coe having an adjoint<br>\nI still think the adjoint map should be called \"closure\", of course</p>",
        "id": 494532765,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1737217478
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>, I think you and I came to basically this exact conclusion a few years ago!</p>",
        "id": 494692475,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1737330075
    },
    {
        "content": "<p>Yes, I have been silently following this discussion and I didn't really want to intervene, because what I have to say is that I think the solutions that were offered here are overengineered and will each fail to capture some subtleties of various subobjects and their associated closure operator. Eg</p>\n<ul>\n<li>Does the closure operator return <code>Set α</code> or <code>Subobject α</code>?</li>\n<li>How is the closure operator usually called?</li>\n<li>How to name lemmas describing the interaction of several closure operators?</li>\n</ul>",
        "id": 494735372,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1737357653
    },
    {
        "content": "<ul>\n<li>We are trying to to abstract all the different <code>span : Set \\a -&gt; Subobject \\a</code>. So that should be the type of the abstraction.</li>\n<li>I don't care too much. We had a vote upstairs.</li>\n<li>Depends on <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> but I'm sure we can solve this, just like with lemmas describing the interaction of several <code>Add</code>s or <code>Mul</code>s.</li>\n</ul>",
        "id": 494784898,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1737372410
    },
    {
        "content": "<p>I don't see why we can't use the existing naming conventions for interaction of different closure operators<br>\nlike <code>subgroup_closure</code> etc</p>",
        "id": 494824169,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1737383224
    }
]