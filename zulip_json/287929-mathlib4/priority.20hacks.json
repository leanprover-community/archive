[
    {
        "content": "<p>I've been fiddling with priorities. There are two PRs I'd like to flag here.</p>\n<p>The first is <a href=\"https://github.com/leanprover-community/mathlib4/pull/34077\">#34077</a>. Core lean has <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instSMulOfMul#doc\">docs#instSMulOfMul</a> which is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">910</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">smul</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"bp\">.</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>In particular, core has explicitly lowered the priority of this instance (recall that the default priority is 1000, so this is less than the default). On the other hand, in mathlib we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.id#doc\">docs#Algebra.id</a> which is <code>Algebra.id [CommSemiring R] : Algebra R R</code> (which includes <code>instSMulOfMul</code> as a component) and we give it a priority of 1100, i.e. we are saying \"actually we think the priority of this instance should be higher than default\". The priority of <code>Algebra.id</code> was increased in <a href=\"https://github.com/leanprover-community/mathlib4/pull/13032\">#13032</a> , saving over 100G instructions, and the Zulip discussion is here <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/erw.20and.20IsDedekindDomain.2EHeightOneSpectrum.2EadicCompletion/near/439380909\">#mathlib4 &gt; erw and IsDedekindDomain.HeightOneSpectrum.adicCompletion @ ðŸ’¬</a>  . The tl;dr is, I think, that <code>Algebra.id [CommSemiring R] : Algebra R R</code> is likely to be (a) correct when it applies and (b) quick to fail when it doesn't, and there is an example in the linked thread about how not applying it until too late can be costly.</p>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/34077\">#34077</a> I want to argue analogously: <code>instance [Mul Î±] : SMul Î± Î±</code> is likely to be correct when it applies and quick to fail, so why not raise the priority to 1100 despite the fact that core wants it at 910 (for reasons which I don't know)? This instance priority change produces this diff <a href=\"https://github.com/leanprover-community/mathlib4/pull/34077#issuecomment-3916045908\">https://github.com/leanprover-community/mathlib4/pull/34077#issuecomment-3916045908</a> and a saving of 290G instructions but slows down a Kaehler differentials file because of the defeq universe issue <a href=\"https://github.com/leanprover/lean4/issues/12102\">https://github.com/leanprover/lean4/issues/12102</a> here ; one declaration in that file is already really horrible because <code>max u v</code> isn't syntactically <code>max v u</code> and this mul-to-smul change for some reason makes it even more horrible. The universe hack <a href=\"https://github.com/leanprover-community/mathlib4/pull/34088\">#34088</a> fixes the Kaehler differentials file with a universe renaming hack and with that hack the prio increase of instSMulToMul saves 463G as can be seen here <a href=\"https://github.com/leanprover-community/mathlib4/pull/34077#issuecomment-3856115722\">https://github.com/leanprover-community/mathlib4/pull/34077#issuecomment-3856115722</a> . </p>\n<p>Right now the trail has kind of gone cold on this one; I wanted to bring up the discussion of <a href=\"https://github.com/leanprover-community/mathlib4/pull/34077\">#34077</a> earlier but was derailed by the universe issue, which I note is currently marked <code>P-high</code> by the FRO, so I've been adopting a wait and see approach. But notwithstanding the universe issue I think it's still meaningful to ask whether we want <a href=\"https://github.com/leanprover-community/mathlib4/pull/34088\">#34088</a>.</p>\n<hr>\n<p>The second hack is <a href=\"https://github.com/leanprover-community/mathlib4/pull/35446\">#35446</a> , which is a hack in the opposite direction. This was inspired by Artie's example of <code>#synth Mul (R[X] â§¸ (âŠ¥ : Ideal R[X]))</code> timing out, which was traced back in this thread <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Typeclass.20Synthesis.20Regression/near/564374449\">#mathlib4 &gt; Typeclass Synthesis Regression @ ðŸ’¬</a>  to be a case of <code>GradedMonoid.GradeZero.mul</code> being applied in a situation where it was mathematically irrelevant and taking a long time to fail. Mathlib has both internally and externally graded objects, and the problem with externally-graded objects is that they eat <code>(A : Î¹ â†’ Type*)</code> which are the graded pieces <code>A i</code>, and Lean can sometimes try to use results of the form \"If A is an externally-graded monoid then <code>A 0</code> inherits a multiplication\" to try and find a multiplication on an object which is coincidentally of the form <code>A 0</code> for some <code>A</code>, for example <code>R[X] â§¸ (âŠ¥)</code>. This bad choice can take a long time to fail. In <a href=\"https://github.com/leanprover-community/mathlib4/pull/35446\">#35446</a> we lower the priority of all of the instances on <code>A 0</code> in situations where <code>A : Î¹ â†’ Type*</code> is part of an externally graded object. For me the argument is the converse of <code>instSMulToMul</code>: here the instances might apply accidentally and can be very slow to fail. Benchmarking is here <a href=\"https://github.com/leanprover-community/mathlib4/pull/35446#issuecomment-3916019036\">https://github.com/leanprover-community/mathlib4/pull/35446#issuecomment-3916019036</a> and shows a decrease of 151G instructions.</p>\n<p>I am really unclear about whether \"messing around with priorities in such a way to make mathlib faster\" is actually something we should be doing (and how to document it if we do it), or whether they are hacks which are actually racking up technical debt. Both the PRs being discussed here have come from genuine user issues whether things were slow and the changes solve their problems and seem not to create other problems. I guess what I am asking is: is fiddling with instance priorities something which we should definitely not be doing because we should be looking for better solutions, or something which we should be taking on board because it is solving problems? I should be clear: I am not actively arguing \"we should merge my PRs\", I am saying \"look what these changes (which seem to me to be reasonably motivated) can do; but should we be doing this at all?\"</p>",
        "id": 574353616,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1771350961
    },
    {
        "content": "<p>I don't have a coherent answer, so here are some disjointed thoughts on the subject.</p>\n<p>As far as performance hacks go, instance priorities are quite innocent ones: morally, the order in which instances are tried should not give observable results except the speed at which the right instance is found. So I have few objections to a few well-reasoned-out priority bumps/nerfs spread out across Mathlib. (Especially if they have a clear test case, like <code>#synth Mul (R[X] â§¸ (âŠ¥ : Ideal R[X]))</code>.)</p>\n<p>Taking this to the extreme to get ten thousand PRs that each twiddle the priority of an individual instance would be a waste of time though. So we should prefer to find patterns that are useful globally. We already have rules like \"instances that always apply get lower priority\", or \"CancellativeWhatever to Whatever gets lower priority\", and so \"GradedWhatever to Whatever gets lower priority\" would fit neatly in that rule too.</p>\n<p>One thing we can do for future-proofing and documenting is, instead of writing <code>instance (priority := low)</code>, we'd have a bunch of our own keywords so we can write instead <code>instance (priority := gradedToUngraded)</code>. So if we later realize that graded stuff needs higher priority, we can change it all at once. We probably have so many annotations that it'd be a huge hassle to group them all though (I certainly wouldn't volunteer to do the whole job myself).</p>\n<p>Finally a warning: I have heard that the FRO is planning to do some redesign of what the typeclass system can do (beyond the upcoming <code>v4.29.0</code> changes), although I don't know any details. So this might render a lot of the priority twiddling obsolete.</p>",
        "id": 574373853,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1771357976
    },
    {
        "content": "<p>I previously experimented with some adjustments in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7873\">#7873</a>. I wanted to revisit this after decoupling the algebra and the normed hierarchy, but it's currently blocked by <a href=\"https://github.com/leanprover/lean4/pull/8279\">lean4#8279</a>.</p>",
        "id": 575219419,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1771817353
    }
]