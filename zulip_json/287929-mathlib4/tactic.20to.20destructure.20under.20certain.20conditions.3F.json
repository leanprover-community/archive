[
    {
        "content": "<p>Often, if you have a certain fact about something, you can decompose it in a certain way. For instance, if you have a hypothesis which says that a list <code>l</code> satisfies <code>0 &lt; l.length</code>, you can find <code>x</code> and <code>xs</code> to rewrite <code>l</code> as <code>x :: xs</code>. It'd be convenient to target some such <code>l</code> in the goal type and rewrite it directly to this form (<em>without</em> knowing the lemma name)—something like <code>write l as x :: xs</code> (name pending). Ideally these sorts of decomposition lemmas would be tagged as such so that this tactic could search through all lemmas that enabled such a rewrite and try to find hypotheses to apply them.</p>\n<p>So, kind of like <code>rw</code> or <code>simp</code>, but you specify what you want to rewrite part of your expression <em>to</em> instead of how to rewrite it, and in a way that lets us introduce and name local decls in the process. (Not like <code>set</code>(<code>m</code>), since we want to expand something using a nontrivial fact instead of condense something.)</p>\n<p>Does this exist already in some form? (I might be blanking.)</p>",
        "id": 403681393,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700696574
    },
    {
        "content": "<p>No, it doesn't.</p>",
        "id": 403682792,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700697653
    },
    {
        "content": "<p>Perhaps it could be <code>obtain! x :: xs := l</code>, as in \"I want to destructure <code>l</code> as <code>x :: xs</code>, and if that's not a thing you can do, please try harder!\"</p>",
        "id": 403682876,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700697693
    },
    {
        "content": "<p>Note that Lean Verbose does that.</p>",
        "id": 403684235,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1700698637
    },
    {
        "content": "<p>Hmm, interesting! Does <code>obtain</code> rewrite the goal? I'm imagining it'd be useful to replace <code>l</code> everywhere in the goal in one fell swoop! (Maybe not, though.) (<code>obtain_rw</code>?)</p>",
        "id": 403684251,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700698646
    },
    {
        "content": "<p>See <a href=\"https://github.com/PatrickMassot/verbose-lean4/blob/master/Verbose/English/Examples.lean#L41-L42\">here</a> for instance. <code>|u n - l| ≤ l / 2</code> is not literally  an inductive type with fields <code>-(l/2) ≤ u n - l</code> and <code>u n - l ≤ l / 2</code>.</p>",
        "id": 403684358,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1700698726
    },
    {
        "content": "<p>Nice! How does it figure out which lemmas to use? Does it use <code>simp</code> or something under the hood?</p>",
        "id": 403684516,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700698823
    },
    {
        "content": "<p>Lemmas are registered using an attribute.</p>",
        "id": 403684576,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1700698898
    },
    {
        "content": "<p>The tactic doing that is very simple: <a href=\"https://github.com/PatrickMassot/verbose-lean4/blob/master/Verbose/Tactics/By.lean#L36-L44\">https://github.com/PatrickMassot/verbose-lean4/blob/master/Verbose/Tactics/By.lean#L36-L44</a>. Sorry about the total lack of documentation. I had a deadline to get a version good enough to write the examples files, so documentation wasn't a priority.</p>",
        "id": 403684695,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1700698993
    },
    {
        "content": "<p>The tactic elaborator is at <a href=\"https://github.com/PatrickMassot/verbose-lean4/blob/master/Verbose/English/By.lean#L6-L7\">https://github.com/PatrickMassot/verbose-lean4/blob/master/Verbose/English/By.lean#L6-L7</a> for the English version.</p>",
        "id": 403684731,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1700699034
    },
    {
        "content": "<p>Gotcha, nice, thanks for the links! Re: documentation, that's ok—at a glance, the code looks clear and nicely organized. :)</p>",
        "id": 403684841,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700699114
    },
    {
        "content": "<p>You can see that <code>By stuff we get new stuff</code> first tries to call <code>rcases</code> but if it fails then it calls lemmas that are registered as anonymous split lemmas.</p>",
        "id": 403684942,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1700699191
    },
    {
        "content": "<p>Here's an example of using <code>obtain</code> for your original use case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">List.ne_nil_iff_exists</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">xs</span> <span class=\"bp\">≠</span> <span class=\"o\">[]</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">as</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">xs</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">List.length_pos_iff_exists</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">xs.length</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">as</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">List.length_pos</span><span class=\"o\">,</span> <span class=\"n\">List.ne_nil_iff_exists</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">l.head</span><span class=\"bp\">!</span> <span class=\"o\">::</span> <span class=\"n\">l.tail</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">List.length_pos_iff_exists.mp</span> <span class=\"n\">h</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  x : ℕ</span>\n<span class=\"cm\">  xs : List ℕ</span>\n<span class=\"cm\">  h : 0 &lt; List.length (x :: xs)</span>\n<span class=\"cm\">  ⊢ x :: xs = List.head! (x :: xs) :: List.tail (x :: xs)</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>That's one way these lemmas could be phrased, as lemmas that conclude in a nested existential that ends in an equality. Another way could be using lemmas that are more like eliminators.</p>",
        "id": 403685440,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700699630
    },
    {
        "content": "<p>Nice! (I am ofc specifically curious about tagging lemmas for automatic use and having \"nice\" syntax (i.e. we're destructuring <code>l</code>, not the <code>∃</code>), but this encourages the notion that <code>obtain</code> can be a big part of the solution, one way or another.)</p>",
        "id": 403686499,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700700521
    },
    {
        "content": "<p>The existential phrasing was the one I had in mind for these lemmas; but I'm curious, what would an eliminator-style one look like?</p>",
        "id": 403686562,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700700595
    },
    {
        "content": "<p>The <code>elab_as_elim</code> here is just to get <code>refine</code> to calculate the <code>motive</code> argument. Otherwise you tend to have to pass one in yourself explicitly.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">List.length_pos_elim</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">xs.length</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">as</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">xs</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">l.head</span><span class=\"bp\">!</span> <span class=\"o\">::</span> <span class=\"n\">l.tail</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">h'</span>\n  <span class=\"n\">refine</span> <span class=\"n\">List.length_pos_elim</span> <span class=\"n\">h</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"n\">h'</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  l : List ℕ</span>\n<span class=\"cm\">  h : 0 &lt; List.length l</span>\n<span class=\"cm\">  p : List ℕ → Prop</span>\n<span class=\"cm\">  x : ℕ</span>\n<span class=\"cm\">  xs : List ℕ</span>\n<span class=\"cm\">  h' : p (x :: xs)</span>\n<span class=\"cm\">  ⊢ x :: xs = List.head! (x :: xs) :: List.tail (x :: xs)</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>",
        "id": 403686986,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700700910
    },
    {
        "content": "<p>The whole \"rewriting everywhere\" is an illusion. The way it works (even in <code>obtain</code>) is you revert everything that can be rewritten, you compute a motive that cuts out the thing being \"rewritten\", and then you pass that motive to the eliminator.</p>",
        "id": 403687027,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700700962
    },
    {
        "content": "<p>The <code>a :: as</code> in the theorem is what gets pasted in.</p>",
        "id": 403687069,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700700977
    },
    {
        "content": "<p>I guess that <code>theorem</code> should be a <code>def</code>, oops.</p>",
        "id": 403687078,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700700991
    },
    {
        "content": "<p>I think this could be likened to a continuation passing style version of the one that returns an existential. Though doing <code>obtain</code> on the existential is just deferring to the <code>Exists</code> and <code>Eq</code> eliminators.</p>",
        "id": 403687185,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700701121
    }
]