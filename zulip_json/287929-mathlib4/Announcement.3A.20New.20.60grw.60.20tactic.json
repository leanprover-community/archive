[
    {
        "content": "<p>This is an announcement that the <code>grw</code> tactic is now available in mathlib. It allows rewriting with any relation, usually a transitive relation, if the relevant lemmas are tagged with <code>@[gcongr]</code>. Some examples are:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ZMOD</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ZMOD</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h₂</span>\n</code></pre></div>\n<p><code>grw</code> has been designed to have the same syntax and the same features as <code>rw</code>. This means that there is also an <code>nth_grw</code> tactic. And it means that <code>grw</code> cannot rewrite bound variables.</p>\n<p>The original PR was opened 2 years ago. I took up this task one week ago, and thanks to the in-person review by <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>, it got merged this week.</p>\n<p>I'm making this thread to list some more features that I'd like to have for <code>gcongr</code> and <code>grw</code> (and some of which I'll try to do soon). But I'd also appreciate feedback on the tactic. Although many lemmas have already been tagged with <code>@[gcongr]</code>, I'm sure there will be new use cases for which the lemmas haven't been tagged.</p>",
        "id": 523970524,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749829392
    },
    {
        "content": "<p>(I think there is a typo in your last example)</p>",
        "id": 523972897,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1749830235
    },
    {
        "content": "<p>I remember this tactic being proposed during the PFR project (where it would have come in handy).  Great to see it finally over the finish line!</p>",
        "id": 523974092,
        "sender_full_name": "Terence Tao",
        "timestamp": 1749830677
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>, thanks for pointing that out. I'll have to fix the doc-string of <code>grw</code>. But now I'm actually not sure which relation should be used inside the RHS of a divisibility:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">gcongr</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ a ≡ b [ZMOD p]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ a ∣ b</span>\n</code></pre></div>\n<p>Which of the two possible goals do we expect?<br>\nA solution allowing both would be to get <code>a ∣ b</code> if the goal is <code>p ∣ a → p ∣ b</code>, and get <code>a ≡ b [ZMOD p]</code> if the goal is <code>p ∣ a ↔ p ∣ b</code>.<br>\nAnd <code>grw</code> could implement the heuristic that if the relation used for rewriting is symmetric, then it runs <code>gcongr</code> on an <code>↔</code> goal instead of an <code>→</code> goal.</p>",
        "id": 523974920,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1749831003
    },
    {
        "content": "<p>Imagine how many more tactics we would have in mathlib if we just lock Jovan and Floris in a dungeon for a month.</p>",
        "id": 523987357,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1749835855
    },
    {
        "content": "<p>Is there a way to obtain a list of all lemmas marked <code>@[gcongr]</code>?</p>",
        "id": 523994147,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1749838732
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"n\">run_meta</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">GCongr</span><span class=\"bp\">.</span><span class=\"n\">gcongrExt</span><span class=\"bp\">.</span><span class=\"n\">getState</span><span class=\"w\"> </span><span class=\"n\">env</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">map</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">flatMap</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">MessageData</span><span class=\"bp\">.</span><span class=\"n\">ofConstName</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">declName</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 523995570,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749839339
    },
    {
        "content": "<p>There's 610 of them right now and two duplicates for some reason so actually only 608 unique ones</p>",
        "id": 523995694,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749839391
    },
    {
        "content": "<p>The duplicates are <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Sublist.drop#doc\">docs#List.Sublist.drop</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.succ_le_succ#doc\">docs#Nat.succ_le_succ</a></p>",
        "id": 523996356,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749839654
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 523996472,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1749839703
    },
    {
        "content": "<p>Follow up question: how did you come up with the numbers &amp; duplicates? Do they show up in your infoview (they don't in mine) or have you used some external tool?</p>",
        "id": 523997444,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1749840120
    },
    {
        "content": "<p>For the number I did a <code>List.length</code></p>",
        "id": 523997938,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749840360
    },
    {
        "content": "<p>For the duplicates I just filtered for duplicates</p>",
        "id": 523997968,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749840371
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/25928\">#25928</a> defines the <code>gcongr 2</code> syntax for limiting the depth of <code>gcongr</code>. This is analogous to the <code>congr</code> tactic. It is in addition to the pattern syntax <code>gcongr x + ?_ * _</code> which also allows you to limit the depth.</p>",
        "id": 524143614,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750006409
    },
    {
        "content": "<p>If you're playing with gcongr, I think it'd be nice to have gcongr? which gives you the pattern it used, analogous to simp?</p>",
        "id": 524145055,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1750007885
    },
    {
        "content": "<p>Actually, <code>gcongr?</code> already exists. But it is an interactive widget tactic. And it is really poorly implemented. I agree with your  suggestion (which means replacing the current one).</p>",
        "id": 524145176,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750008022
    },
    {
        "content": "<p>Is the inability to rewrite bound variables an intentional part of matching the <code>rw</code> behavior, or could <code>grw</code> eventually get support for it?</p>",
        "id": 524173285,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1750044110
    },
    {
        "content": "<p>From the moment we had <code>simp_rw</code> which seemed to be \"<code>rw</code> but works\" I've always regarded \"<code>rw</code> can't rewrite bound variables\" as a bug rather than a feature. However <code>rw</code> has never been \"fixed\" in years. What is the logic here?</p>",
        "id": 524184841,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750054445
    },
    {
        "content": "<p>Wasn't the point that rewriting bound variables requires some sort of functional extensionality?</p>",
        "id": 524191488,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1750057832
    },
    {
        "content": "<p>And maybe we don't want a very basic tactic to use additional axioms (this is less of a problem for a mathlib tactic).</p>",
        "id": 524191585,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1750057873
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Announcement.3A.20New.20.60grw.60.20tactic/near/524184841\">schrieb</a>:</p>\n<blockquote>\n<p>From the moment we had <code>simp_rw</code> which seemed to be \"<code>rw</code> but works\" I've always regarded \"<code>rw</code> can't rewrite bound variables\" as a bug rather than a feature. However <code>rw</code> has never been \"fixed\" in years. What is the logic here?</p>\n</blockquote>\n<p>I believe there is hope that it will be fixed this year :-)</p>",
        "id": 524194942,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1750059325
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Announcement.3A.20New.20.60grw.60.20tactic/near/524191585\">said</a>:</p>\n<blockquote>\n<p>And maybe we don't want a very basic tactic to use additional axioms (this is less of a problem for a mathlib tactic).</p>\n</blockquote>\n<p>Thought so too, but then <code>split</code> was using choice for the longest time :-)</p>",
        "id": 524199512,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750060797
    },
    {
        "content": "<p>(Is it not anymore?)</p>",
        "id": 524200936,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1750061295
    },
    {
        "content": "<p>No! That was fixed alongside another bug</p>",
        "id": 524201359,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750061460
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"753178\">Aaron Hill</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Announcement.3A.20New.20.60grw.60.20tactic/near/524173285\">said</a>:</p>\n<blockquote>\n<p>Is the inability to rewrite bound variables an intentional part of matching the <code>rw</code> behavior, or could <code>grw</code> eventually get support for it?</p>\n</blockquote>\n<p>I agree it would be better if <code>grw</code> would rewrite bound variables. However, the current version is a lot simpler to implement, which is why I went with this implementation (for now).</p>",
        "id": 524222509,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750068940
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/25942\">#25942</a> fixes a bug in the <code>grw</code> tactic: <code>grw</code> currently doesn't work if the goal contains syntheticOpaque metavariables.</p>",
        "id": 524243725,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750076455
    },
    {
        "content": "<p>Btw, for easy acccess, the <code>grw</code> PR is <a href=\"https://github.com/leanprover-community/mathlib4/pull/8167\">#8167</a>.</p>",
        "id": 525566600,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1750786995
    },
    {
        "content": "<p>I just used the tactic for the first time, it's amazing! Thanks a lot for this <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 525567281,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750787301
    },
    {
        "content": "<p>This looks great! Could it rewrite inside integrals with almost everywhere equalities? Or more generally rewrite with <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Defs.html#Filter.EventuallyEq\">Filter.EventuallyEq</a></p>",
        "id": 525568600,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750787847
    },
    {
        "content": "<p>There are 2 limitations:</p>\n<ul>\n<li>we need to tag more lemmas with <code>@[gcongr]</code> (e.g. for <code>Filter.EventuallyEq</code>)</li>\n<li><code>grw</code> currently cannot rewrite bound variables. If you do need to rewrite terms containing bound variables, you can use the <code>gcongr</code> tactic directly, which is a bit less convenient, because it requires you to write out the new expression (e.g. in a <code>calc</code> block).</li>\n</ul>\n<p>So feel free to try some examples, and report which ones need tagging.</p>",
        "id": 525569530,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1750788192
    },
    {
        "content": "<p>Isn't a third limitation that if the relation is <code>=</code>, one or both of {<code>gcongr</code>, <code>grw</code>} currently have a special case to call {<code>congr,</code> <code>rw</code>}, which means that if you want these tactics to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.integral_congr_ae#doc\">docs#MeasureTheory.integral_congr_ae</a> and then recursively call <code>gcongr</code> on the (now non-<code>=</code>) goal, you're out of luck?</p>",
        "id": 525579647,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1750792152
    },
    {
        "content": "<p>I was searching for grw in <a href=\"https://leanprover-community.github.io/mathlib-manual/html-multi/Tactics/All-tactics/#all_tactics\">https://leanprover-community.github.io/mathlib-manual/html-multi/Tactics/All-tactics/#all_tactics</a> and didn't find it. <span class=\"user-mention\" data-user-id=\"385895\">@Jon Eugster</span> What's the procedure to make a new tactic appear there?</p>",
        "id": 528538038,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1752421846
    },
    {
        "content": "<p>probably just need to bump the repo again, i.e. update it to the newest mathlib. I'll try to do that later today</p>",
        "id": 528587941,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1752471669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Announcement.3A.20New.20.60grw.60.20tactic/near/528538038\">said</a>:</p>\n<blockquote>\n<p>I was searching for grw in <a href=\"https://leanprover-community.github.io/mathlib-manual/html-multi/Tactics/All-tactics/#all_tactics\">https://leanprover-community.github.io/mathlib-manual/html-multi/Tactics/All-tactics/#all_tactics</a> and didn't find it. <span class=\"user-mention silent\" data-user-id=\"385895\">Jon Eugster</span> What's the procedure to make a new tactic appear there?</p>\n</blockquote>\n<p>I've bumped the manual to <code>v4.21.0</code> over lunch, so the tactic is now here:<br>\n<a href=\"https://leanprover-community.github.io/mathlib-manual/html-multi//Tactics/All-tactics/#grw\">https://leanprover-community.github.io/mathlib-manual/html-multi//Tactics/All-tactics/#grw</a></p>\n<p>I'll bump it again to v4.22 tonight</p>",
        "id": 528654750,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1752497447
    },
    {
        "content": "<p>If bumping the repo is just a matter of running a script or something, I could try and throw together some automation for it.</p>",
        "id": 528655233,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1752497589
    },
    {
        "content": "<p>An update on the progress for <code>grw</code> and <code>gcongr</code>:</p>\n<ul>\n<li>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/26907\">#26907</a> will hopefully  be merged soon, and adds a few features to <code>gcongr</code>:</p>\n<ol>\n<li>Instead of having to tag all of <code>add_le_add</code>, <code>add_le_add_left</code> and <code>add_le_add_right</code>, it will suffice to just tag <code>add_le_add</code>; any extra reflexive subgoals will be closed using <code>rfl</code>. This will make future tagging of lemmas easier, (e.g. I'll do <code>mul_dvd_mul</code>, <code>neg_dvd_neg</code>, <code>pow_dvd_pow</code>and <code>Int.ModEq.of_dvd</code>/<code>Nat.ModEq.of_dvd</code>)</li>\n<li><code>@[gcongr]</code> lemmas can have a priority (just like with <code>@[simp]</code>). This will allow to fix <a href=\"https://github.com/leanprover-community/mathlib4/pull/27058\">#27058</a></li>\n<li><code>gcongr</code> operates in the <code>reducible</code> transparency instead of <code>reducible_and_instances</code>. This helps to avoid applying the wrong lemma. This will help to revive <a href=\"https://github.com/leanprover-community/mathlib4/pull/14739\">#14739</a>.</li>\n</ol>\n</li>\n<li>\n<p><a href=\"https://github.com/leanprover/lean4/pull/9304\">lean#9304</a> extends the <code>rfl</code> tactic to close goals of the form <code>p → p</code>. This matches the fact that <code>gcongr</code> treats <code>→</code> as a binary relation. (unfortunately I can't anymore push directly to the mathlib adaptation branch, so I've made a PR to fix it <a href=\"https://github.com/leanprover-community/mathlib4-nightly-testing/pull/13\">https://github.com/leanprover-community/mathlib4-nightly-testing/pull/13</a>)</p>\n</li>\n<li>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/27135\">#27135</a> I've started to write the <code>gconvert</code> tactic. This is the generalized version of the <code>convert</code> tactic, and this is similarly built upon <code>gcongr</code>. For example in</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span>\n</code></pre></div>\n<p>writing <code>gconvert h</code> will give you the new subgoals <code>a ≤ b</code> and <code>d ≤ c</code>.<br>\nAdditionally, <code>gconvert</code> will be able to replace the <code>peel</code> tactic.</p>\n<p>Future work may include:</p>\n<ul>\n<li>If a <code>gcongr</code> lemma applies successfully, but it has unsolved side goals, try to find another <code>gcongr</code> lemma that can satisfy all of its side goals. This would allow to rewrite under multiplication with a negative number (by tagging lemmas like <code>mul_le_mul_of_nonpos_left</code>)</li>\n<li>Let <code>gcongr</code> call the congruence prodedure of <code>congr!</code> on equality and iff goals if no <code>gcongr</code> lemmas apply.</li>\n<li>Let <code>gcongr with x y z</code> take <code>rintro</code> patterns instead of just variable names (just like <code>congr!</code>)</li>\n<li>Allow <code>gcongr</code> to go into a lambda e.g. using <code>Pi.le_def.mpr</code>. Maybe we need a <code>@[gext]</code> tag for this.</li>\n<li>Allow <code>gcongr</code>to go into function applications, e.g. using <code>Pi.le_def.mp</code></li>\n<li>Make it easier to tag lemmas like <code>ENat.coe_le_coe</code>, or <code>Filter.Eventually.mono</code> that aren't quite in the right shape to be a <code>gcongr</code>lemma.</li>\n</ul>",
        "id": 528840495,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1752579857
    },
    {
        "content": "<p>One question I've never understood about <code>gcongr</code> is why it fails on \"basic\" relations (and I suppose that the answer is that \"it must\", but I am not sure and at any rate I do not know why):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">congrm</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">gcongr</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"c1\">--works</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">gcongr</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"c1\">--fails</span>\n</code></pre></div>",
        "id": 528845251,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1752581413
    },
    {
        "content": "<p>Yes, this is one of the \"Future work\" points: currently no <code>=</code> or <code>↔</code> lemmas have been tagged with <code>gcongr</code>. But instead of going around tagging equality lemmas with <code>gcongr</code>, it would be better to call the <code>congr!</code> tactic internally in the <code>gcongr</code> tactic on <code>=</code> and <code>↔</code> goals.</p>",
        "id": 528845960,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1752581634
    },
    {
        "content": "<p>The motivation for supporting <code>=</code> and <code>↔</code> in <code>gcongr</code> (instead of simply calling the <code>congr!</code> tactic) is that there may be cases where we can move from an <code>=</code> or <code>↔</code> goal into a more general relation.</p>\n<p>Some motivating example are</p>\n<ul>\n<li><code>↔</code> and proposition<code>a ≡ b [ZMOD n]</code>, which moves into the  <code>[ZMOD n]</code> relation.</li>\n<li><code>=</code> and the operation <code>% n</code>, which moves into the  <code>[ZMOD n]</code> relation.</li>\n<li><code>↔</code> and proposition<code>∀ᶠ x in l, p x</code>/<code>∃ᶠ x in l, p x</code>, which moves into the <code>=ᶠ[l]</code> relation. (Although the lemma <code>f =ᶠ[l] g → (l.Eventually f ↔ l.Eventually g)</code>seems to be missing in mathlib).</li>\n<li><code>=</code> and the operation <code>∫ (a : α), f a ∂μ</code>, which moves into the <code>=ᶠ[ae μ]</code> relation</li>\n</ul>",
        "id": 528853031,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1752583815
    },
    {
        "content": "<p>Ping for <a href=\"https://github.com/leanprover-community/mathlib4/pull/26907\">#26907</a>. Could someone review the <code>@[gcongr]</code> tag updates? The meta code has already been approved.</p>",
        "id": 531007688,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1753565869
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Announcement.3A.20New.20.60grw.60.20tactic/near/528853031\">said</a>:</p>\n<blockquote>\n<p>The motivation for supporting <code>=</code> and <code>↔</code> in <code>gcongr</code> (instead of simply calling the <code>congr!</code> tactic) is that there may be cases where we can move from an <code>=</code> or <code>↔</code> goal into a more general relation.</p>\n</blockquote>\n<p>Another -- somewhat dangerous but occasionally useful -- transformation is going from a difficult <code>=</code> involing casts, to a <code>HEq</code> where the casts can be eliminated and the remaining expression solved using <code>congr!</code>. I am not at all sure how one would build heuristics for when this is a good idea (perhaps 'matches <code>_ = _ ∘ _root_.cast _</code>' or similar might be a good first step, though in e.g. category theory it's less clear how to handle expressions involving <code>eqToHom</code>), but it should probably be on the dock for consideration at least.</p>",
        "id": 533396512,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1754628565
    },
    {
        "content": "<p>Going from = to HEq sounds like a job for the <code>congr!</code> tactic. I'm not sure to what extent it does this already.</p>\n<p>(And when I add the <code>congr!</code> steps to <code>gcongr</code>, then it can also be a job for <code>gcongr</code>)</p>",
        "id": 533412630,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1754638764
    },
    {
        "content": "<p>One obstacle to getting the <code>congr!</code> steps into <code>gcongr</code> is the fact that <code>gcongr</code> can work with a pattern and <code>congr!</code> doesn't. So the <code>congr!</code> steps first need to be made compatible with using a pattern.</p>",
        "id": 533412829,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1754638868
    },
    {
        "content": "<p>Could <code>grw</code> support lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=le_of_le_of_antisymmRel#doc\">docs#le_of_le_of_antisymmRel</a> ? <code>grw</code> can be used in <a href=\"https://github.com/vihdzp/combinatorial-games/pull/194\">https://github.com/vihdzp/combinatorial-games/pull/194</a>, but seems it can only be written as <code>grw [(...).le]</code>. In some worse cases, there are only lemmas about operations and <code>AntisymmRel</code>, but no lemmas about operations and <code>\\le</code>.</p>",
        "id": 534752659,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1755338180
    },
    {
        "content": "<p><code>gcongr</code> usually tries to use the most general relation (so <code>≤</code> instead of <code>&lt;</code>/<code>AntisymmRel (· ≤ ·)</code>), and then tries to close the goal with possibly a stronger relation. For example we have special support for concluding <code>≤</code> from a <code>&lt;</code> hypothesis using <code>le_of_lt</code>. In the same way <code>AntisymmRel</code> can be specially  supported.</p>\n<p>I've opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/28514\">#28514</a> that implements this. In the meantime, you could copy this code into your project, to see if it works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">GCongr</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">AntisymmRel</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AntisymmRel</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">AntisymmRel</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AntisymmRel</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">gcongr_forward</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">exactAntisymmRelLeft</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ForwardExt</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"bp\">.</span><span class=\"n\">assignIfDefEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``AntisymmRel.left</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">gcongr_forward</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">exactAntisymmRelRight</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ForwardExt</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"bp\">.</span><span class=\"n\">assignIfDefEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``AntisymmRel.right</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">GCongr</span>\n</code></pre></div>",
        "id": 534754527,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1755340822
    },
    {
        "content": "<p>If there are lemmas about operations and <code>AntisymmRel</code>, but no lemmas about operations and <code>≤</code>, then simply tagging the lemmas with <code>@[gcongr]</code> should be sufficient to allow rewriting with <code>AntisymmRel</code>. (Even without <a href=\"https://github.com/leanprover-community/mathlib4/pull/28514\">#28514</a>)</p>",
        "id": 534754675,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1755341020
    },
    {
        "content": "<p>This is very helpful, thank you! But it still doesn't make the last <code>grw</code> work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kn\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"s2\">\" ≈ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">AntisymmRel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">gcongr</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">f_congr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 534765351,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1755353999
    },
    {
        "content": "<p>In this case, you can make it work by adding another <code>@[gcongr]</code> lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">gcongr</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">f_congr'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I've also been thinking about a heuristic to make this work out of the box, which is to have the <code>grw</code> check if the hypothesis relation is symmetric, and if so, call <code>gcongr</code> with the <code>↔</code> relation instead of <code>→</code>. But that might want to wait until <code>↔</code> is better supported in <code>gcongr</code>.</p>",
        "id": 534770952,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1755360148
    },
    {
        "content": "<p>In order to work towards supporting <code>=</code>/<code>↔</code> in <code>gcongr</code>/<code>grw</code> in the way I described above, we need to have a version of <code>congr!</code> which (in some combination with <code>gcongr</code>) applies congruences until it reaches a certain subexpression. It is already possible to limit the depth (with <code>congr! 3</code>), but that isn't specific enough. Recall that <code>gcongr</code> can also take a pattern (with <code>gcongr 2 * ?_</code>). From what I understand, the new <code>rw</code> tactic that is on the roadmap may come with such a congruence tactic.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/Introduction.20to.20tactic.20programming/near/525749521\">said</a>:</p>\n<blockquote>\n<p>The rough idea @Jovan Gerbscheid is that it will do the rewrite and then do a post-hoc congruence construction</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, is this right? And do you know approximately when this development will happen?</p>",
        "id": 540595526,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758384601
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Announcement.3A.20New.20.60grw.60.20tactic/near/540595526\">said</a>:</p>\n<blockquote>\n<p>we need to have a version of <code>congr!</code> which (in some combination with <code>gcongr</code>) applies congruences until it reaches a certain subexpression. It is already possible to limit the depth (with <code>congr! 3</code>), but that isn't specific enough. Recall that <code>gcongr</code> can also take a pattern (with <code>gcongr 2 * ?_</code>). </p>\n</blockquote>\n<p>This already exists right? The <code>congrm</code> tactic.</p>",
        "id": 540619742,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1758412430
    },
    {
        "content": "<p>The <code>congrm</code> tactic is a thin wrapper around the <code>congr(...)</code> term elaborator (which is why I had originally discarded this option).</p>\n<p>Looking more closely at <code>congr(...)</code>, it elaborates the lhs and rhs into a form where the holes are annotated with some metadata, so that <code>congr(...)</code> knows up to where to do congruences. This seems like a reasonable approach to also take in <code>gcongr</code>. This would mean that in the implementation of <code>gcongr</code>, instead of keeping track of the pattern while doing the congruences, we would keep track of these metadata annotations.</p>",
        "id": 540641790,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758443374
    },
    {
        "content": "<p>And if want, we could also allow passing proofs directly in the pattern, in the same way that <code>congrm</code> allows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">gcongr</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 540641798,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758443385
    },
    {
        "content": "<p>I have now reimplemented how patterns work in <code>gcongr</code>, so that they work with metadata, just like in <code>congrm</code>. This is a necessary step for supporting equality reasoning in <code>gcongr</code>, as I discussed above. (<a href=\"https://github.com/leanprover-community/mathlib4/pull/30739\">#30739</a>)</p>\n<p>There is also still the open PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/28339\">#28339</a> which will allow tagging lemmas whose conclusion is <code>Monotone _</code>.</p>",
        "id": 546801467,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761275107
    },
    {
        "content": "<p>The <code>grw</code> tactic allows for</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ht</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsMeagre</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsMeagre</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hst</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ht</span>\n</code></pre></div>\n<p>It would be nice if it could also do the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsMeagre</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsMeagre</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hst</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n</code></pre></div>\n<p>I tried adding a new <code>@[gcongr] lemma</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">gcongr</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">--error</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">not_isMeagre_mono</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsMeagre</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsMeagre</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsMeagre</span><span class=\"bp\">.</span><span class=\"n\">mono</span><span class=\"w\"> </span><span class=\"n\">hst</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mt</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n</code></pre></div>\n<p>I also tried defining a new predicate.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NonMeagre</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsMeagre</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">gcongr</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">NonMeagre</span><span class=\"bp\">.</span><span class=\"n\">mono</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NonMeagre</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">NonMeagre</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsMeagre</span><span class=\"bp\">.</span><span class=\"n\">mono</span><span class=\"w\"> </span><span class=\"n\">hst</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mt</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NonMeagre</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NonMeagre</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hst</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">--error</span>\n</code></pre></div>\n<p>In this last snippet, I do not understand why the <code>gcongr</code> attribute is added without error, but not used correctly in the <code>example</code>.</p>",
        "id": 563179399,
        "sender_full_name": "Lara Toledano",
        "timestamp": 1765457585
    },
    {
        "content": "<p>In your second example, you want to rewrite from right to left. So, just like in <code>rw</code>, you should use the left arrow: <code>grw [← hst]</code></p>",
        "id": 563230120,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1765469825
    },
    {
        "content": "<p>Thank you so much!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsMeagre</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsMeagre</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">hst</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n</code></pre></div>",
        "id": 563230551,
        "sender_full_name": "Lara Toledano",
        "timestamp": 1765469939
    }
]