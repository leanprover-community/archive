[
    {
        "content": "<p>Hi all, CS researcher from Denmark here. <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>\n<p>I'm looking for feedback on a potential mathlib contribution.</p>\n<p>As part of a larger CS project , I made a library for labelled transition systems (LTSs). These are used a lot in theory of CS, especially in concurrency theory, programming languages, and logic. They come with interesting relations, like 'bisimulations', which relate states that are behaviourally equivalent. You can think of them as  state machines or directed graphs with minimal assumptions (the set of states doesn't need to be finite, the transition relation doesn't need to be deterministic, etc.).</p>\n<p>You can see my current attempt at integrating it with mathlib here: <a href=\"https://github.com/leanprover-community/mathlib4/compare/master...fmontesi:mathlib4:lts\">https://github.com/leanprover-community/mathlib4/compare/master...fmontesi:mathlib4:lts</a></p>\n<p>Essentially, I've formalised the fundamental concepts of LTSs and bisimulation (arguably the most established equivalence relation for them) from the reference textbook [Introduction to Bisimulation and Coinduction, Sangiorgi, 2011].</p>\n<p>I tried my best to understand and follow the guidelines, but it's my first time navigating all of this. Hopefully I managed. :-)</p>",
        "id": 524255270,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750079946
    },
    {
        "content": "<p>One convention that I'm not following on purpose is that I'm calling a couple of type parameters State and Label respectively, instead of \\alpha and \\beta. I find the resulting code easier to read because I have a clear intuition as to what each type represents, but if this is not ok for mathlib contribs I'm happy to talk about it ofc.</p>",
        "id": 524260513,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750081377
    },
    {
        "content": "<p>Hello Fabrizio,</p>\n<p>I'm glad to see someone formalising Labelled Transition Systems in Lean! I have a brief suggestion that might interest you.</p>\n<p>I'm currently working part-time on a project to support coinductive predicates and relations in Lean. It uses lattice theory under the hood but allows you to automatically derive sound coinduction proof principles for a given predicate.</p>\n<p>Here's an example of defining language equivalence on DFAs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">))</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">language_equivalent</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">automaton</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q₁</span><span class=\"w\"> </span><span class=\"n\">q₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">o₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">automaton</span><span class=\"w\"> </span><span class=\"n\">q₁</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">o₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">automaton</span><span class=\"w\"> </span><span class=\"n\">q₂</span>\n<span class=\"w\">    </span><span class=\"n\">o₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">o₂</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">language_equivalent</span><span class=\"w\"> </span><span class=\"n\">automaton</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n<span class=\"n\">greatest_fixpoint</span>\n</code></pre></div>\n<p>This automatically gives you a proof principle for language equivalence:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">info: language_equivalent.fixpoint_induct {Q A : Type} (automaton : DFA Q A) (x : Q → Q → Prop)</span>\n<span class=\"sd\"> (y :</span>\n<span class=\"sd\">   ∀ (x_1 x_2 : Q),</span>\n<span class=\"sd\">     x x_1 x_2 →</span>\n<span class=\"sd\">       (automaton x_1).fst = (automaton x_2).fst ∧ ∀ (a : A), x ((automaton x_1).snd a) ((automaton x_2).snd a))</span>\n<span class=\"sd\"> (x✝ x✝¹ : Q) : x x✝ x✝¹ → language_equivalent automaton x✝ x✝¹</span>\n<span class=\"sd\">-/</span>\n</code></pre></div>\n<p>I'm fairly confident you could use this to define bisimulations for LTSes and get the corresponding proof principles for free. The feature is under active development—mutual and mixed (co)induction aren't supported yet (which could help with things like weak bisimulation). Also, the autogenerated lemma name <code>fixpoint_induct</code> may change soon to avoid clashes with <code>partial_fixpoint</code>.</p>\n<p>For simple cases, the <code>greatest_fixpoint</code> hint could already be helpful in your setting.</p>\n<p>Let me know if you have any questions—I’d be happy to share more details or hear your feedback about the feature!</p>",
        "id": 524281938,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1750087853
    },
    {
        "content": "<p>Do you have mathematical applications in mind?</p>",
        "id": 524284873,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1750088852
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"644702\">Wojciech Różowski</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Labelled.20Transition.20Systems.20.28LTS.29/near/524281938\">said</a>:</p>\n<blockquote>\n<p>Hello Fabrizio,</p>\n<p>I'm glad to see someone formalising Labelled Transition Systems in Lean! I have a brief suggestion that might interest you.</p>\n<p>I'm currently working part-time on a project to support coinductive predicates and relations in Lean. It uses lattice theory under the hood but allows you to automatically derive sound coinduction proof principles for a given predicate.</p>\n<p>Here's an example of defining language equivalence on DFAs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">))</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">language_equivalent</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">automaton</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DFA</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q₁</span><span class=\"w\"> </span><span class=\"n\">q₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">o₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">automaton</span><span class=\"w\"> </span><span class=\"n\">q₁</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">o₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">automaton</span><span class=\"w\"> </span><span class=\"n\">q₂</span>\n<span class=\"w\">    </span><span class=\"n\">o₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">o₂</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">language_equivalent</span><span class=\"w\"> </span><span class=\"n\">automaton</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n<span class=\"n\">greatest_fixpoint</span>\n</code></pre></div>\n<p>This automatically gives you a proof principle for language equivalence:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">info: language_equivalent.fixpoint_induct {Q A : Type} (automaton : DFA Q A) (x : Q → Q → Prop)</span>\n<span class=\"sd\"> (y :</span>\n<span class=\"sd\">   ∀ (x_1 x_2 : Q),</span>\n<span class=\"sd\">     x x_1 x_2 →</span>\n<span class=\"sd\">       (automaton x_1).fst = (automaton x_2).fst ∧ ∀ (a : A), x ((automaton x_1).snd a) ((automaton x_2).snd a))</span>\n<span class=\"sd\"> (x✝ x✝¹ : Q) : x x✝ x✝¹ → language_equivalent automaton x✝ x✝¹</span>\n<span class=\"sd\">-/</span>\n</code></pre></div>\n<p>I'm fairly confident you could use this to define bisimulations for LTSes and get the corresponding proof principles for free. The feature is under active development—mutual and mixed (co)induction aren't supported yet (which could help with things like weak bisimulation). Also, the autogenerated lemma name <code>fixpoint_induct</code> may change soon to avoid clashes with <code>partial_fixpoint</code>.</p>\n<p>For simple cases, the <code>greatest_fixpoint</code> hint could already be helpful in your setting.</p>\n<p>Let me know if you have any questions—I’d be happy to share more details or hear your feedback about the feature!</p>\n</blockquote>\n<p>Hey Wojciech, that looks interesting indeed! I haven't encountered particular problems while doing the metatheory of LTSs yet, but your work might simplify some proofs and be of great help with proving results about particular LTSs in the future (e.g., bisimilarity laws on given languages/semantics).</p>\n<p>I'd be happy to see more when you like. :⁠-⁠)</p>\n<p>In the meantime, regarding my specific LTS modules, do you see anything that'd prevent using your methods in the future?</p>",
        "id": 524285587,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750089065
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Labelled.20Transition.20Systems.20.28LTS.29/near/524284873\">said</a>:</p>\n<blockquote>\n<p>Do you have mathematical applications in mind?</p>\n</blockquote>\n<p>Are you asking about the usefulness of LTSs or Wojciech's work on coinduction?</p>",
        "id": 524286981,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750089499
    },
    {
        "content": "<p>Hey Fabrizio,</p>\n<p>Thanks—that sounds great! From what I’ve seen, your current setup looks good, and I think it could be adapted to use the <code>greatest_fixpoint</code> machinery without major issues. That's why your post got my attention :) </p>\n<p>Personally, I’d find it particularly interesting to eventually see the feature used for bisimulations <em>up to</em>, where you could get stronger proof principles by incorporating algebraic structure. That seems like a promising direction!</p>\n<p>By the way, are you planning to eventually formalise something like the semantics of CCS?</p>",
        "id": 524287092,
        "sender_full_name": "Wojciech Różowski",
        "timestamp": 1750089531
    },
    {
        "content": "<p>I meant LTSs. The question is why do you want this in mathlib. This is a honest question, I don't know the answer.</p>",
        "id": 524287720,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1750089712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"644702\">Wojciech Różowski</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Labelled.20Transition.20Systems.20.28LTS.29/near/524287092\">said</a>:</p>\n<blockquote>\n<p>Hey Fabrizio,</p>\n<p>Thanks—that sounds great! From what I’ve seen, your current setup looks good, and I think it could be adapted to use the <code>greatest_fixpoint</code> machinery without major issues. That's why your post got my attention :) </p>\n<p>Personally, I’d find it particularly interesting to eventually see the feature used for bisimulations <em>up to</em>, where you could get stronger proof principles by incorporating algebraic structure. That seems like a promising direction!</p>\n<p>By the way, are you planning to eventually formalise something like the semantics of CCS?</p>\n</blockquote>\n<p>We are formalising choreographic programming and other calculi in Lean, where this might be pretty useful, I'll get in touch when we get there.</p>\n<p>I thought of formalising CCS. Maybe if I did, it'd be a good example to try your methods on and sync?</p>",
        "id": 524288473,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750089955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Labelled.20Transition.20Systems.20.28LTS.29/near/524287720\">said</a>:</p>\n<blockquote>\n<p>I meant LTSs. The question is why do you want this in mathlib. This is a honest question, I don't know the answer.</p>\n</blockquote>\n<p>LTSs are used widely in concurrency theory (including probabilistic models) and programming languages (to prove, e.g., the correctness of compilers, program optimisations, program equivalences when state transition systems have different structures). So I thought it'd make sense to have a common lib, since a lot of results about LTSs are general and heavily reused in a lot of work. LTSs can also be seen as generalisations of the transition functions you see in DFA and NFA (as already in mathlib). Finite graphs, DFAs, NFAs, etc. could be converted into LTSs and then checked for equivalence, for example (I still have to get to the plumbing for this, but it seems straightforward). You can also see bisimulation as a generalisation of graph isomorphism (the structures need not be isomorphic, just the observable behaviour given by the transitions).</p>",
        "id": 524289643,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750090362
    },
    {
        "content": "<p>I know they're also used to reason about equivalences in modal logic, but I haven't touched that too much yet.</p>",
        "id": 524289734,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750090399
    },
    {
        "content": "<p>Here a pretty nice read about bisimilarity if you're interested:</p>\n<p><a href=\"https://www.cs.unibo.it/~sangio/DOC_public/history_bis_coind.pdf\">https://www.cs.unibo.it/~sangio/DOC_public/history_bis_coind.pdf</a></p>",
        "id": 524290377,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750090645
    },
    {
        "content": "<p>See for example section 5 about set theory. There are applications to type theory and systems as well IIRC.</p>",
        "id": 524290580,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750090716
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Labelled.20Transition.20Systems.20.28LTS.29/near/524255270\">said</a>:</p>\n<blockquote>\n<p>Hi all, CS researcher from Denmark here. <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>\n<p>I'm looking for feedback on a potential mathlib contribution.</p>\n<p>As part of a larger CS project , I made a library for labelled transition systems (LTSs). These are used a lot in theory of CS, especially in concurrency theory, programming languages, and logic. They come with interesting relations, like 'bisimulations', which relate states that are behaviourally equivalent. You can think of them as  state machines or directed graphs with minimal assumptions (the set of states doesn't need to be finite, the transition relation doesn't need to be deterministic, etc.).</p>\n<p>You can see my current attempt at integrating it with mathlib here: <a href=\"https://github.com/leanprover-community/mathlib4/compare/master...fmontesi:mathlib4:lts\">https://github.com/leanprover-community/mathlib4/compare/master...fmontesi:mathlib4:lts</a></p>\n<p>Essentially, I've formalised the fundamental concepts of LTSs and bisimulation (arguably the most established equivalence relation for them) from the reference textbook [Introduction to Bisimulation and Coinduction, Sangiorgi, 2011].</p>\n<p>I tried my best to understand and follow the guidelines, but it's my first time navigating all of this. Hopefully I managed. :-)</p>\n</blockquote>\n<p>Hello there, this is really great to hear . My first ever project was formalising LTS concepts for my Lean seminar project , but sadly I got caught up with lots of other stuff and did not add really much to it , but always wanted to do more..it was my first steps into actually learning lean (natural numbers game and mathematics-in-lean aside)</p>",
        "id": 524304737,
        "sender_full_name": "Bashar Hamade",
        "timestamp": 1750095499
    },
    {
        "content": "<p>here is what I did in collaboration with <span class=\"user-mention\" data-user-id=\"580947\">@Rida Hamadani</span> :<br>\n<a href=\"https://github.com/Calculean/LeanCCS\">https://github.com/Calculean/LeanCCS</a><br>\nLike I mentioned, I barely did any work , but would love to work with fellow researchers further in the future</p>",
        "id": 524305215,
        "sender_full_name": "Bashar Hamade",
        "timestamp": 1750095631
    },
    {
        "content": "<p>Nice! My library is intended to provide rails for works like that.</p>",
        "id": 524308102,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750096449
    },
    {
        "content": "<p>Fabrizio : If I had to guess, Patrick wants to know how mathematicians would use the library. I think those of us who work on and use automata should try to build this library outside mathlib. Much of this theory is of interest to TCS folks and not necessarily math department folks.</p>",
        "id": 524325454,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750104216
    },
    {
        "content": "<p>I'd say so too , like it is nice to have a formalized library for LTS and its applications, but it does not necessarily tie in with mathlib .</p>",
        "id": 524326235,
        "sender_full_name": "Bashar Hamade",
        "timestamp": 1750104623
    },
    {
        "content": "<p>Perhaps another way to put it is like this : if another part of mathlib might eventually depend on LTS, then it might be sensible to add it to mathlib. I don’t see that as particularly likely.</p>",
        "id": 524327106,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750104995
    },
    {
        "content": "<p>This is indeed a very important criterion. But there is also a very pragmatic one: I guess no Mathlib maintainer will be competent to review contributions in this area.</p>",
        "id": 524334173,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1750108211
    },
    {
        "content": "<p>And really there is a lot of room for a computer science lib. You can do great work with Lean outside of mathematics and Mathlib.</p>",
        "id": 524334260,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1750108255
    },
    {
        "content": "<p>I would go so far as to say that track B theorists* should have a library of their own.</p>\n<p>*for those out of the loop: that’s the logic, model checking, and automata side of CS theory according to European TCS conferences</p>",
        "id": 524341327,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750112057
    },
    {
        "content": "<p>Oh, I thought logic and computation were in scope of mathlib because of the many things already in (see pic).<a href=\"/user_uploads/3121/no8XQcN0Yiu9c2p4IrsxO7kI/5b290aab-2032-45f8-8c7f-693726f08110.jpg\">5b290aab-2032-45f8-8c7f-693726f08110.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/no8XQcN0Yiu9c2p4IrsxO7kI/5b290aab-2032-45f8-8c7f-693726f08110.jpg\" title=\"5b290aab-2032-45f8-8c7f-693726f08110.jpg\"><img data-original-content-type=\"image/jpeg\" data-original-dimensions=\"1440x1908\" src=\"/user_uploads/thumbnail/3121/no8XQcN0Yiu9c2p4IrsxO7kI/5b290aab-2032-45f8-8c7f-693726f08110.jpg/840x560.webp\"></a></div>",
        "id": 524370618,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750135323
    },
    {
        "content": "<p>I'd be happy to start or contribute to a cslib, so that's not a problem. I just wanna figure out the best plan, library-organisation wise.</p>",
        "id": 524371360,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750135949
    },
    {
        "content": "<p>The many CS science things in mathlib is a historical accident. There used to be no other library at all, and it's currently very difficult to remove anything from Mathlib.</p>",
        "id": 524378060,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1750140531
    },
    {
        "content": "<p>I see, thanks for the info. Is this noted anywhere? I couldn't find anything about this when I first searched. It might be good to have a note for newcomers to read.</p>",
        "id": 524378670,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750140910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Labelled.20Transition.20Systems.20.28LTS.29/near/524327106\">said</a>:</p>\n<blockquote>\n<p>Perhaps another way to put it is like this : if another part of mathlib might eventually depend on LTS, then it might be sensible to add it to mathlib. I don’t see that as particularly likely.</p>\n</blockquote>\n<p>I mean, graph theory might somewhat use it in the future, but I honestly think that if a cslib existed, it'd be a better place for this.</p>",
        "id": 524379397,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750141371
    },
    {
        "content": "<p>I disagree, graph theory definitely belongs to mathlib instead of a cslib, if you prove any graph theory results please PR them (feel free to request my review for any graph theory), we have a very active graph theory library in mathlib.</p>",
        "id": 524413875,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1750154083
    },
    {
        "content": "<p>I think the computability library of mathlib can be ported to a cslib however</p>",
        "id": 524414205,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1750154202
    },
    {
        "content": "<p>A small portion of computability library might be useful to other areas of math. At least recursively enumerable functions are useful to Hilbert 10th problem.</p>",
        "id": 524423675,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1750157611
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Labelled.20Transition.20Systems.20.28LTS.29/near/524413875\">said</a>:</p>\n<blockquote>\n<p>I disagree, graph theory definitely belongs to mathlib instead of a cslib, if you prove any graph theory results please PR them (feel free to request my review for any graph theory), we have a very active graph theory library in mathlib.</p>\n</blockquote>\n<p>Good point. I've been thinking a bit about graph theory.</p>\n<p>Here's a mini summary of the connections I see:</p>\n<ul>\n<li>Any labelled digraph (directed graph with labelled edges) is also an LTS.</li>\n<li>Any DFA is also a labelled digraph, and thus an LTS; plus information on start and accepting states, which an LTS doesn't necessarily have.</li>\n<li>Any NFA is also an LTS, with the same remark as above.</li>\n<li>Any Turing Machine is also an LTS, with the same remark.</li>\n<li>Instantiate the Label type for LTS and you can get machines with weighted transitions, probabilistic processes, etc. (For some probabilistic processes/objects, a generalisation of LTSs is needed.)</li>\n</ul>\n<p>There are probably more connections.</p>\n<p>So LTSs can provide a sort of very general interface for many definitions and results. Things like defining paths, equivalences that ignore structure (like the bisimulation and trace equivalence included in my PR), etc.</p>\n<p>I don't know if they'll be used elsewhere in mathlib yet. But if I put them in a 'cslib' instead, that cslib will surely depend on mathlib, and mathlib will thus not be able to use cslib. I don't know where that would leave graph theory.</p>",
        "id": 524434755,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750161121
    },
    {
        "content": "<p>I wouldn’t call it cslib either. I prefer “Model Checking Lib” or something similar. All the connections you describe are firmly within the realm of Theoretical CS</p>",
        "id": 524437993,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750162205
    },
    {
        "content": "<p>Model Checking would be too narrow. I for one am not using LTSs for model checking in Lean (yet!), but primarily for semantics and certified compilers for now.</p>",
        "id": 524439844,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750162854
    },
    {
        "content": "<p>Also, I'd expect a variety of logics (modal logic, linear logic), other equivalences, and calculi (lambda, pi, etc.) to be in the same lib.</p>",
        "id": 524443738,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750164031
    },
    {
        "content": "<p>I think that’s included in model checking theory</p>",
        "id": 524449017,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750165604
    },
    {
        "content": "<p>It would include various logics, automata, and formulations of games for bisimulations</p>",
        "id": 524449185,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750165662
    },
    {
        "content": "<p>i think <code>blib</code>(for theory b) would be a cute name!</p>",
        "id": 524449422,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1750165726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Labelled.20Transition.20Systems.20.28LTS.29/near/524449017\">said</a>:</p>\n<blockquote>\n<p>I think that’s included in model checking theory</p>\n</blockquote>\n<p>Model checking is usually about verification, and also against finite-state models. It'd be too surprising/specific for people working in some of the topics I mentioned.</p>",
        "id": 524450989,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750166152
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Labelled.20Transition.20Systems.20.28LTS.29/near/524449422\">said</a>:</p>\n<blockquote>\n<p>i think <code>blib</code>(for theory b) would be a cute name!</p>\n</blockquote>\n<p>Hehe, nice :⁠-⁠)</p>",
        "id": 524451087,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750166187
    },
    {
        "content": "<p>Could also be plib (pl theory lib). Although I'm not sure yet as to why one would keep algo theory separate from pl theory? There are important interplays, no?</p>",
        "id": 524451630,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750166359
    },
    {
        "content": "<p>PL theory and algo theory are researched by two entirely different communities with \\epsilon intersection between them. They don't even speak the same language.</p>",
        "id": 524453575,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750166872
    },
    {
        "content": "<p>Also, I doubt that there will be appetite for a PL-Lib, primarily because there are already a bazillion formalisations for every tiny variant of lambda calculi and semantics in  Coq and Agda.</p>",
        "id": 524453763,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750166927
    },
    {
        "content": "<p>LTSlib would be a good idea.</p>",
        "id": 524454062,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750167007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Labelled.20Transition.20Systems.20.28LTS.29/near/524453763\">said</a>:</p>\n<blockquote>\n<p>Also, I doubt that there will be appetite for a PL-Lib, primarily because there are already a bazillion formalisations for every tiny variant of lambda calculi and semantics in  Coq and Agda.</p>\n</blockquote>\n<p>Many of those are very frustrating for pl researchers because they're incompatible, at least in Coq/Rocq.</p>\n<p>I could definitely make an ltslib, but then I'll create a series of libraries in the near future... Mmmh...</p>",
        "id": 524454482,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750167134
    },
    {
        "content": "<p>Case in point : There is already an effort underway to port all of iris to lean (not just the Mosel proof mode as was the case before)</p>",
        "id": 524455014,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750167286
    },
    {
        "content": "<p>I don't think we're on topic anymore. But to be brief, you won't be able to please PL researchers with a uniform library if they haven't already invented one in Rocq/Coq. That's essentially what Iris did for separation logics. There are so many libraries for PL because there are correspondingly many conceptually different ideas, even if the difference is not vast. There is sufficient common ground on LTSes among PL and model checking communities to justify a library.</p>",
        "id": 524455225,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750167343
    },
    {
        "content": "<p>Also since we are on the topic of coinduction, have you checked out what mathlib already has in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Computation.corec#doc\">docs#Computation.corec</a> ?</p>",
        "id": 524455924,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750167532
    },
    {
        "content": "<p>There are definitions of even <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Seq/Computation.html#Computation.IsBisimulation\">bisimulations</a>. I would suggest not reinventing these  definitions unless strictly necessary</p>",
        "id": 524456406,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750167636
    },
    {
        "content": "<p>you can use them by defining runs of LTSes in terms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Computation#doc\">docs#Computation</a></p>",
        "id": 524456699,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750167712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Labelled.20Transition.20Systems.20.28LTS.29/near/524453763\">said</a>:</p>\n<blockquote>\n<p>Also, I doubt that there will be appetite for a PL-Lib, primarily because there are already a bazillion formalisations for every tiny variant of lambda calculi and semantics in  Coq and Agda.</p>\n</blockquote>\n<p>It is a niche, but I am personally very interested in formalizing lambda calculi in Lean! I am currently working on formalizing various categorical and denotational semantics. One appeal to me of this is that there is already a lot of mathematical machinery (categories, CPOs, etc.) built up in a central location with Mathlib.</p>",
        "id": 524466368,
        "sender_full_name": "Chris Henson",
        "timestamp": 1750170340
    },
    {
        "content": "<p>Some of it is already there. Scott continuity for example</p>",
        "id": 524467718,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750170725
    },
    {
        "content": "<p>Here are \\omega-CPOs :  <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/OmegaCompletePartialOrder.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/OmegaCompletePartialOrder.html</a></p>",
        "id": 524467908,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750170773
    },
    {
        "content": "<p>Scott Continuity : <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/ScottContinuity.html#ScottContinuous\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/ScottContinuity.html#ScottContinuous</a></p>",
        "id": 524467977,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750170789
    },
    {
        "content": "<p>But I don't think there is anything that takes these pieces to build a comprehensive library for denotational semantics</p>",
        "id": 524468166,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1750170832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Labelled.20Transition.20Systems.20.28LTS.29/near/524467718\">said</a>:</p>\n<blockquote>\n<p>Some of it is already there. Scott continuity for example</p>\n</blockquote>\n<p>Yes, I've been using these alongside my own definitions of lambda calculi to formalize some semantics. I also am planning to work on some metaprogramming to allow an easier time producing the boilerplate for locally nameless formalizations.</p>",
        "id": 524470058,
        "sender_full_name": "Chris Henson",
        "timestamp": 1750171404
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> thanks for all your thoughts. I reply in a single mesg here. I think I see what you mean. I also think that there's space for a foundational pl library, since I wouldn't aim at covering use cases like Iris but more general definitions that are well established. LTS and behavioural equivalences are some of those. They spin off a big formalisation project in our group, and I imagine similarly things could spin off of iris to more general libs.</p>\n<p>I just think that there should be some place where LTS and other general definitions about semantics, languages, and related pl topics (and I agree model checking would be a very good part) are kept compatible. Model checking is an important part, but not all. To be clear, I'm not trying to exclude it: I'd love a collab with ppl interested in model checking on this!</p>\n<p>I agree we're getting off topic, and a bit into speculation land. I'll open another thread for this later.</p>\n<p>Regarding your pointers: yes, I'd checked for similar things in mathlib. I don't think they're what I'm formulating here. A key point of my defs and theorems is that they're minimal and basically as in the pen-and-paper presentation (modulo the expected mods for a mechanisation). For a few things one can make appropriate 'to'-functions.</p>",
        "id": 524494605,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750179520
    },
    {
        "content": "<p>And all this discussion proves Mathlib is not a good place: Mathlib maintainers are simply not competent to handle those challenges. We need people who understand all those things maintaining a library about all that. PRing to Mathlib would simply need to tons of stalled PRs frustrating everybody.</p>",
        "id": 524594946,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1750193762
    },
    {
        "content": "<p>I definitely agree regarding the off-topic stuff (lambda calcs, model checking, logics, ...), which I think belongs to a separate CS lib of some sort.</p>\n<p>I'm still in doubt about the main topic here, though (LTSs). Btw, I'm really appreciating this discussion, which I think contains the questions that should always be asked in such cases (thanks!).</p>\n<p>In essence, I'm still uncertain that what I've formalised here is confined to CS. So I ask a few questions below, with the intent of excluding that we're not being blindsided by a nomenclature issue here. As an outsider and CS person, I was under the impression that contributions to 'Computability' were welcome, so I phrased my contribution in related terms. Maybe that's not good. (What I describe below might require renaming some symbols in my code and/or some additional work. That'd be fine.)</p>\n<p>An LTS is essentially a ternary relation where the first and third sets are the same:</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>S</mi><mo>×</mo><mi>L</mi><mo>×</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S \\times L \\times S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span></p>\n<p>So forget about the name 'LTS' for a second.<br>\nIt is essentially a labelled digraph (potentially infinite, and with potentially many edges with different labels between the same two nodes). I see there is already a specialised definition for unlabelled digraphs (Digraph). This would be a straight-up generalisation (provide an type L with a single element, and any Digraph can be transformed into an LTS).</p>\n<p>Q1: Are such graphs not interesting in math?</p>\n<p>Q2: Shouldn't we provide a common API in mathlib for them, which people who use such graphs to model whatever they're interested in can use? (And thus enable them contributing to mathlib general results they develop about such graphs.)</p>\n<p>Another pov is extending mathlib to deal with ternary relations (I couldn't find much, but maybe I've missed something?). Here some of the things done in LTSs, like considering the binary relations that come out of fixing the second element of the triple (see, e.g., the 'congruence relation' here: <a href=\"https://en.wikipedia.org/wiki/Ternary_relation\">https://en.wikipedia.org/wiki/Ternary_relation</a>), could be easily made into a more general API.</p>\n<p>Q3: Are ternary relations and the binary relations that arise from them already formalised, or not interesting in math?</p>\n<p>The bisimulation and trace equivalence code I have are the first examples of equivalences one can define on such graphs/ternary relations.</p>\n<p>Of course, if these needs/features are already covered by other parts of mathlib or there's agreement that they're not useful in this lib, I'm very happy to make another library. I just don't want this to get lost in a much broader discussion.</p>",
        "id": 524659601,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750237169
    },
    {
        "content": "<p>I've received plenty of feedback here and in private mesg/convos. Both for and against, both with good reasons.  For info here: for now I'm leaning against. I'll try to think about what kind of cs library this should go in or kickstart. Thank you all for the feedback so far. :)</p>",
        "id": 524676379,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1750243004
    }
]