[
    {
        "content": "<p>Just ran into some annoyances with missing API with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.max#doc\">docs#Finset.max</a>, only to realize that this is actually just a thin wrapper around <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sup#doc\">docs#Finset.sup</a>, which does have the API I want.</p>",
        "id": 536972149,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756634682
    },
    {
        "content": "<p>I could go ahead and add said API, but I think it's worth asking, why have both definitions?</p>",
        "id": 536972175,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756634705
    },
    {
        "content": "<p>I get the logic behind having both <code>max</code> and <code>sup</code>, it being that Lean also caters to programmers. But does this logic go all the way up to <code>Finset</code>?</p>",
        "id": 536972327,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756634858
    },
    {
        "content": "<p>(Also, why does <code>Finset.sup</code> take an extra function argument, while <code>Finset.max</code> doesn't?)</p>",
        "id": 536972398,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756634933
    },
    {
        "content": "<p>Because sup is like sum.</p>",
        "id": 536983034,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1756646688
    },
    {
        "content": "<p>And max withBots for the user. There are also sup' and max'</p>",
        "id": 536983091,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1756646741
    },
    {
        "content": "<p>Max is specialized for linear orders. And there is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.max_eq_sup_coe#doc\">docs#Finset.max_eq_sup_coe</a></p>",
        "id": 536983148,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1756646794
    },
    {
        "content": "<p>I think both are worth having. What api would you like to add?</p>",
        "id": 536983189,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1756646834
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finset.2Emax/near/536983091\">said</a>:</p>\n<blockquote>\n<p>And max withBots for the user. There are also sup' and max'</p>\n</blockquote>\n<p>I don't really understand the asymmetry here. Why can't <code>sup</code> do the same? Why can't <code>max</code> take in an extra function argument? What is the benefit of specializing to linear orders?</p>",
        "id": 537025584,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756695199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finset.2Emax/near/536983189\">said</a>:</p>\n<blockquote>\n<p>I think both are worth having. What api would you like to add?</p>\n</blockquote>\n<p>I noticed we don't have a <code>max</code> analog of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sup%27_eq_sup#doc\">docs#Finset.sup'_eq_sup</a></p>",
        "id": 537025679,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756695269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finset.2Emax/near/537025584\">said</a>:</p>\n<blockquote>\n<p>What is the benefit of specializing to linear orders?</p>\n</blockquote>\n<p>E.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.mem_of_max#doc\">docs#Finset.mem_of_max</a> is not true for <code>sup</code>.</p>",
        "id": 537028391,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1756698336
    },
    {
        "content": "<p>Although, I've noticed that there's instance of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Max#doc\">docs#Max</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SemilatticeSup.toMax#doc\">docs#SemilatticeSup.toMax</a>, which is defined in terms of <code>SemilatticeSup.sup</code>. The documentation of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Max#doc\">docs#Max</a> says \"Returns the greater of its two arguments.\", which is not true for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SemilatticeSup.toMax#doc\">docs#SemilatticeSup.toMax</a> (because, it can return neither of its two arguments). There seems to be inconsistency with max vs sup terminology in mathlib.</p>",
        "id": 537028808,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1756698795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">MrQubo</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finset.2Emax/near/537028391\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finset.2Emax/near/537025584\">said</a>:</p>\n<blockquote>\n<p>What is the benefit of specializing to linear orders?</p>\n</blockquote>\n<p>E.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.mem_of_max#doc\">docs#Finset.mem_of_max</a> is not true for <code>sup</code>.</p>\n</blockquote>\n<p>What do you mean? It is true, if you take a <code>LinearOrder</code> assumption.</p>",
        "id": 537184147,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1756770276
    },
    {
        "content": "<p>Ah, you're right.<br>\nIsn't putting more assumption than necessary at the definition an anti-pattern in lean? Even if there is a reason to have both max and sup, there is no need for <code>LinearOrder</code> assumption at the definition of max. Though, sup also doesn't need <code>SemilatticeSup</code> at the definition. Just <code>Max</code>. Although, as I've stated previously, <code>SemilatticeSup</code> shouldn't implement <code>Max</code> in the first place.</p>",
        "id": 537190978,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1756775166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">MrQubo</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finset.2Emax/near/537190978\">said</a>:</p>\n<blockquote>\n<p>Ah, you're right.<br>\nIsn't putting more assumption than necessary at the definition an anti-pattern in lean? Even if there is a reason to have both max and sup, there is no need for <code>LinearOrder</code> assumption at the definition of max. Though, sup also doesn't need <code>SemilatticeSup</code> at the definition. Just <code>Max</code>. Although, as I've stated previously, <code>SemilatticeSup</code> shouldn't implement <code>Max</code> in the first place.</p>\n</blockquote>\n<p>it works with any commutative associative operation</p>",
        "id": 537193335,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756777004
    },
    {
        "content": "<p>Well, yes, it's just sum. But you might want to have multiple different operations on your type, like addition, multiplication etc, so we have different classes for those. We need to refer to one of these classes, Max/Sup in this case.</p>",
        "id": 537193632,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1756777211
    },
    {
        "content": "<p>so do we just put <code>[m : Max α] [Std.Commutative m.max] [Std.Associative m.max]</code></p>",
        "id": 537193884,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756777391
    },
    {
        "content": "<p>You don't need Commutative and Associative in the definition I think? Only <code>Max</code> and <code>OrderBot</code>.</p>",
        "id": 537194006,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1756777479
    },
    {
        "content": "<p><code>Max</code> means an arbitrary binary operation which is called \"max\"</p>",
        "id": 537194230,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756777657
    },
    {
        "content": "<p>Yes.</p>",
        "id": 537194288,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1756777704
    },
    {
        "content": "<p>and I think commutativity and associativity are necessary</p>",
        "id": 537194291,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756777706
    },
    {
        "content": "<p>Anyway, it doesn't matter, because I doubt there are any interesting properties without assuming relation between max and partial order.</p>\n<p>Back to main topic, I think there are use cases to have max. It's I think similar to like we have e.g. Monoid and Semigroup. Like, Monoid is just Semigroup with additional properties, but we still have it, duplicating some of the API of Semigroup with it. We should probably just mirror the api from sup to max, all the proofs should be trivial as <code>LinearOrder</code> implements <code>SemilatticeSup</code>.</p>",
        "id": 537199950,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1756781244
    },
    {
        "content": "<p>I think we already do that?</p>",
        "id": 537253486,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756808281
    },
    {
        "content": "<p>Probably yes, just not the whole api apparently.</p>",
        "id": 537339568,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1756836209
    }
]