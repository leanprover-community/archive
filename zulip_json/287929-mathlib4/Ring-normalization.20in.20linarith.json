[
    {
        "content": "<p>I noticed that the current implementation of linarith effectively ring-normalizes twice.</p>\n<p>Example: suppose we are running the core method <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Linarith.proveFalseByLinarith#doc\">docs#Linarith.proveFalseByLinarith</a> on the comparisons-with-zero <code>y * (x + z) &lt; 0</code>, <code>1 - y * x &lt; 0</code>, <code>- z * y &lt; 0</code>.</p>\n<p>First this list is sent through the method <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Linarith.linearFormsAndMaxVar#doc\">docs#Linarith.linearFormsAndMaxVar</a>, which parses each LHS as a linear combination of monomials in atoms -- here the atoms are <code>x</code>, <code>y</code>, <code>z</code> and the monomials which appear are 1, <code>x * y</code> and <code>y * z</code>, so we get <code>(&lt;, [0, 1, 1])</code>, <code>(&lt;, [1, -1, 0])</code>, <code>(&lt;, [0, 0, -1])</code> .  This method is basically a custom, proof-free implementation of <code>ring</code> within the <code>linarith</code> tactic code.</p>\n<p>Then later, once the oracle has returned the right combination of these inequalities to produce a contradiction, <code>1 *  (y * (x + z)) + 1 * (1 - y * x) + 1 * (- z * y) &lt; 0</code>, the tactic <code>ring</code> is run directly on the LHS (to check that it ring-normalizes to zero).</p>",
        "id": 481029678,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730943751
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Did you ever consider sharing more code between <code>ring</code> and <code>linarith</code>?  One could use <code>ring</code> directly for the parsing of each LHS in <code>linearFormsAndMaxVar</code>, saving the proofs, and then adapt the final <code>ring</code> call so that it used this information -- do you have an estimate of how much this might improve performance?</p>",
        "id": 481029690,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730943759
    },
    {
        "content": "<p>this could be improved by having linarith call the ring internal function rather than the frontend on that contradiction</p>",
        "id": 481029816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730943846
    },
    {
        "content": "<p>(Cross-ref: Pretty sure <a href=\"#narrow/channel/187764-Lean-for-teaching/topic/Real.20analysis/near/197390635\">this discussion</a> between Rob and Mario is contemporary with the existing implementation)</p>",
        "id": 481029837,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730943868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Ring-normalization.20in.20linarith/near/481029816\">said</a>:</p>\n<blockquote>\n<p>this could be improved by having linarith call the ring internal function rather than the frontend on that contradiction</p>\n</blockquote>\n<p>That makes sense, but I think what I was trying to propose is different?  Namely, you could save the list of normalized LHSs as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Tactic.Ring.ExSum#doc\">docs#Mathlib.Tactic.Ring.ExSum</a> objects, and then the final normalization step only consists of a single layer of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Tactic.Ring.evalMul#doc\">docs#Mathlib.Tactic.Ring.evalMul</a> and a single layer of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Tactic.Ring.evalAdd#doc\">docs#Mathlib.Tactic.Ring.evalAdd</a>.</p>",
        "id": 481030219,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730944196
    },
    {
        "content": "<p>yes we're saying the same thing; skip the call to <code>eval</code> and instead call the internal functions</p>",
        "id": 481030508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730944432
    },
    {
        "content": "<p>meaning that you would be storing atoms as <code>ExProd</code> objects most likely (not <code>ExSum</code> since linarith breaks down the additive structure of expressions)</p>",
        "id": 481030580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730944469
    },
    {
        "content": "<p>Ah, got it, I thought you were just proposing to switch from the current method (calling <code>evalTactic (← `(tactic| ring1))</code> on a generated <code>stuff = 0</code> goal) to directly calling <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Tactic.Ring.eval#doc\">docs#Mathlib.Tactic.Ring.eval</a> ... which might indeed save a bit of time but not as much</p>",
        "id": 481030638,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730944527
    },
    {
        "content": "<p>(I think they would also be monic monomials but ring doesn't have a dedicated type for that)</p>",
        "id": 481030719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730944578
    },
    {
        "content": "<p>It might be problematic that ring is strongly typed and linarith is not as much</p>",
        "id": 481030773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730944622
    },
    {
        "content": "<p>I think there's already a step where linarith groups hypotheses by their ambient type, so you could keep around the type information from that step onwards.</p>",
        "id": 481030821,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730944661
    },
    {
        "content": "<p>Anyway ... any estimate of how much this deduplication might affect performance?</p>",
        "id": 481030961,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730944752
    },
    {
        "content": "<p>not really, it could be significant but probably not too much</p>",
        "id": 481031151,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730944840
    },
    {
        "content": "<p>There are some expensive steps in the part that would be skipped here, like defeq checking every subterm against every atom</p>",
        "id": 481031208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730944887
    },
    {
        "content": "<p>By \"skipped here\" do you mean in the \"before\" or the \"after\"?</p>",
        "id": 481031287,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730944941
    },
    {
        "content": "<p>after</p>",
        "id": 481031292,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730944951
    },
    {
        "content": "<p>the delta is the running of the match expression in <code>eval</code>, which is moderately expensive because it calls into lean unification</p>",
        "id": 481031332,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945004
    },
    {
        "content": "<p>whether it dominates the run time or not depends a lot on the goal itself</p>",
        "id": 481031431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945072
    },
    {
        "content": "<p>it can be the most expensive part if you have a lot of definitions that are expensive to compare</p>",
        "id": 481031462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945094
    },
    {
        "content": "<p>It also has to ring-normalize twice, right?  So if say <code>(x + y) ^ 4</code> appears and it has to expand that out twice (once without proof and once with proof), shouldn't that also be expensive?</p>",
        "id": 481031507,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730945124
    },
    {
        "content": "<p>ah that's true, ring doesn't cache subterm evaluation, maybe it should</p>",
        "id": 481031577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945164
    },
    {
        "content": "<p>and doing this would indeed skip that cost</p>",
        "id": 481031665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945249
    },
    {
        "content": "<p>But would that help?  In the current implementation, the first time of expanding out is done by linarith's internal \"ring-like\" function, not by ring itself.</p>",
        "id": 481031667,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730945250
    },
    {
        "content": "<p>well with your proposal linarith would call ring's normalization function on each atom early in the process</p>",
        "id": 481031726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945285
    },
    {
        "content": "<p>on the other hand, maybe that's wasted work if the atom doesn't participate in the final contradiction</p>",
        "id": 481031748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945306
    },
    {
        "content": "<p>Ah, good point!</p>",
        "id": 481031768,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730945325
    },
    {
        "content": "<p>you could have a thunk there to compute it lazily but not recompute it</p>",
        "id": 481031802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945353
    },
    {
        "content": "<p>At that point, I guess you have to re-implement <code>ring</code> too, to be flexible to whether you want a proof-ful or proof-less ring call.</p>",
        "id": 481031850,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730945392
    },
    {
        "content": "<p>how do you figure?</p>",
        "id": 481031898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945407
    },
    {
        "content": "<p>Hmm, did I misunderstand your proposal?</p>",
        "id": 481031924,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730945427
    },
    {
        "content": "<p>For each atom, you would store it as an expression as currently, but also store a function to compute it to an <code>ExProd</code> on demand and cache the result</p>",
        "id": 481031970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945465
    },
    {
        "content": "<p>or just work it out manually with an <code>Option ExProd</code></p>",
        "id": 481031979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945481
    },
    {
        "content": "<p>By \"atom\" you mean what linarith calls a \"monomial\", right?  Like <code>x^3 * y</code> or <code>x * y * z</code> -- so an atom for linarith but not an atom for ring?</p>",
        "id": 481032073,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730945531
    },
    {
        "content": "<p>yes</p>",
        "id": 481032075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945539
    },
    {
        "content": "<p>I guess I was thinking that there are expensive parts even before you get to monomials: expanding <code>(x + y) ^ 4</code> into monomials (even before normalizing those monomials) would be expensive, right?</p>",
        "id": 481032141,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730945611
    },
    {
        "content": "<p>hm, when does that happen currently?</p>",
        "id": 481032160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945638
    },
    {
        "content": "<p>Oh, I guess my assertion was false, linarith atoms are in general <code>ExSum</code> not <code>ExProd</code> because of things like that</p>",
        "id": 481032224,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945668
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/e8818a7d64e68e8ecc8c15bafc7964cb471fd2fb/Mathlib/Tactic/Linarith/Parsing.lean#L158\">https://github.com/leanprover-community/mathlib4/blob/e8818a7d64e68e8ecc8c15bafc7964cb471fd2fb/Mathlib/Tactic/Linarith/Parsing.lean#L158</a></p>",
        "id": 481032258,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730945702
    },
    {
        "content": "<p>I think linarith does the expanding out into \"monomials\" (which are effectively <code>ExProd</code>s) and then runs the oracle using those as the atoms.</p>",
        "id": 481032313,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730945749
    },
    {
        "content": "<p>but if you had <code>(x + y) ^ 4</code> in a linarith goal, it would treat it as an atom, no?</p>",
        "id": 481032380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945784
    },
    {
        "content": "<p>it would not be expanded until it got to <code>ring</code></p>",
        "id": 481032400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945800
    },
    {
        "content": "<p>and in fact it should probably never be expanded, since linarith has reason to believe it has a contradiction without expanding it</p>",
        "id": 481032443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945837
    },
    {
        "content": "<p>No, IIUC it is treated as a linear combination of the atoms x^4, x^3y, x^2y^2, etc.</p>",
        "id": 481032461,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730945861
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n</code></pre></div>",
        "id": 481032541,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730945905
    },
    {
        "content": "<p>interesting</p>",
        "id": 481032553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945921
    },
    {
        "content": "<p>okay so I take back my assertion that my previous assertion was false</p>",
        "id": 481032607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730945969
    },
    {
        "content": "<p>it does make you wonder if that function couldn't just be <code>eval</code> itself</p>",
        "id": 481032700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730946018
    },
    {
        "content": "<p>unfortunately linarith hasn't gotten much love in a while, it's pretty much just a direct port of the lean 3 version, while ring was a complete rewrite</p>",
        "id": 481032762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730946073
    },
    {
        "content": "<p>Now I am remembering that we had plans for a sum of squares tactic in bonn that didn't go anywhere :(</p>",
        "id": 481032874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730946155
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Ring-normalization.20in.20linarith/near/481032762\">said</a>:</p>\n<blockquote>\n<p>unfortunately linarith hasn't gotten much love in a while, it's pretty much just a direct port of the lean 3 version, while ring was a complete rewrite</p>\n</blockquote>\n<p>Yes, I've been looking a bit more closely at it since I want to share some code between it and <code>linear_combination</code>-for-inequalities.  There are a few other places where I have (naive?) questions about the implementation -- like, for example, there's a lot of <code>mkApp ....</code> and I wonder about switching all that stuff over to <code>q(...)</code>.</p>",
        "id": 481033661,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730946749
    },
    {
        "content": "<p>yes I would like to do that, it's just a lot of code and by the time it was ported it was too late to suggest starting afresh</p>",
        "id": 481033733,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730946840
    },
    {
        "content": "<p>Never too late to start afresh. :-)</p>",
        "id": 481042554,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1730953595
    },
    {
        "content": "<p>I wish we didn't use identifying-atoms-up-to-defeq, which is potentially super slow, and just ran <code>CanonM</code>.</p>",
        "id": 481042636,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1730953656
    },
    {
        "content": "<p>Much better performance, and not much loss of capability.</p>",
        "id": 481042724,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1730953699
    },
    {
        "content": "<p>Why not make <code>CanonM</code>  have a reducibility flag? I'd be happy to switch the default but I don't want to sacrifice the capability</p>",
        "id": 481042799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1730953768
    },
    {
        "content": "<p>It does already, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Meta/Canonicalizer.html#Lean.Meta.Canonicalizer.CanonM.run'\"><code>CanonM.run'</code></a>.</p>",
        "id": 481044265,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1730954777
    }
]