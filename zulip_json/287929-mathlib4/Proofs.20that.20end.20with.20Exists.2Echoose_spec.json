[
    {
        "content": "<p>I seem to keep writing proofs relying on <code>Exists.choose</code>, whose final line turn out to be essentially <code>Exists.choose_spec</code>, except that the existential hypothesis has either been transformed into something ugly, or I've simply lost the original name. Currently, I handle this with </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">...</span>\n<span class=\"n\">simp</span>\n<span class=\"n\">generalize_proofs</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n</code></pre></div>\n<p>or the like; but this is of course a non-terminal simp. Is there a systematically better way to handle this I don't know about?</p>",
        "id": 514021580,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1745475721
    },
    {
        "content": "<p>(The main issue here, I believe, is that there's no nice way to address the existential hypothesis; I've tried <code>simpa using Exists.choose_spec _</code>, for example, but unless it's simple enough that I can just fill in the name myself that doesn't seem to work.)</p>",
        "id": 514021800,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1745475810
    },
    {
        "content": "<p>I <em>could</em> use <code>generalize_proofs</code> before the <code>simp</code>, but then I end up with many proofs I would have to separately combine, probably with another <code>simp</code> anyway.</p>",
        "id": 514021947,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1745475861
    },
    {
        "content": "<p>It surprises me that you end up in this situation. Would it not be easier to do <code>obtain \\&lt;x, hx\\&gt; := h_exists</code> rather than <code>let x := Exists.choose h_exists</code>?</p>",
        "id": 514024417,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1745476891
    },
    {
        "content": "<p>Instead of using <code>Exists.choose</code>, can you use the <code>choose</code> tactic, which is much more user-friendly?</p>",
        "id": 514024471,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1745476916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Proofs.20that.20end.20with.20Exists.2Echoose_spec/near/514024417\">said</a>:</p>\n<blockquote>\n<p>It surprises me that you end up in this situation. Would it not be easier to do <code>obtain \\&lt;x, hx\\&gt; := h_exists</code> rather than <code>let x := Exists.choose h_exists</code>?</p>\n</blockquote>\n<p>I usually don't do either, actually; I just have e.g. <code>hom | ‚ü®x, hx‚ü© =&gt; (hx (ùüô _)).choose</code></p>",
        "id": 514024597,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1745476954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Proofs.20that.20end.20with.20Exists.2Echoose_spec/near/514024471\">said</a>:</p>\n<blockquote>\n<p>Instead of using <code>Exists.choose</code>, can you use the <code>choose</code> tactic, which is much more user-friendly?</p>\n</blockquote>\n<p>Hm. Let's find out.</p>",
        "id": 514024654,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1745476979
    },
    {
        "content": "<p>Nope; or, well, certainly I can write <code>hom | ‚ü®x, hx‚ü© =&gt; by choose y hy using hx (ùüô _); exact y</code> instead, but when I then have to interact with that definition later <code>simpa using (Classical.choose_spec _)</code> doesn't work</p>",
        "id": 514025036,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1745477130
    },
    {
        "content": "<p>I see</p>",
        "id": 514025162,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1745477185
    },
    {
        "content": "<p>... I suppose I should probably have been more specific: the issue is with defining <em>data</em> at one point in a definition with <code>Exists.choose</code>, where later I need to access that data with <code>Exists.choose_spec</code></p>",
        "id": 514025220,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1745477214
    },
    {
        "content": "<p>... I <em>could</em> use <code>Classical.indefiniteDescription</code> everywhere instead; that would be ugly but might be more compatible with automation...</p>",
        "id": 514025299,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1745477242
    },
    {
        "content": "<p>In that case it might be easier to create an auxiliary <code>def</code> with the result of <code>Exists.choose</code> and add a specialized lemma about that <code>def</code> with <code>Exists.choose_spec</code></p>",
        "id": 514025332,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1745477254
    },
    {
        "content": "<p>I'm reasonably sure <code>Classical.indefiniteDescription</code> would be more painful</p>",
        "id": 514025372,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1745477269
    },
    {
        "content": "<p>Well, it'd mean that the last line of my data generation is <code>Subtype.val _</code>, which <em>sometimes</em> <code>simp</code> seems to be able to exploit automatically via <code>Subtype.coe_prop</code>.</p>",
        "id": 514025598,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1745477365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Proofs.20that.20end.20with.20Exists.2Echoose_spec/near/514025332\">said</a>:</p>\n<blockquote>\n<p>In that case it might be easier to create an auxiliary <code>def</code> with the result of <code>Exists.choose</code> and add a specialized lemma about that <code>def</code> with <code>Exists.choose_spec</code></p>\n</blockquote>\n<p>Mm. That would be somewhat unpleasant as this is occurring in a rather deeply nested series of definitions, but that itself probably isn't great practice... I'll think about it.</p>",
        "id": 514025663,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1745477392
    },
    {
        "content": "<p>Do you have a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 514026878,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1745477846
    },
    {
        "content": "<p>BTW, I think that we should have an attribute version of the <code>choose</code> tactic. It should take a lemma claiming <code>\\forall a b, \\ex x, p x \\and q x</code> and output <code>def</code> with lemmas.</p>",
        "id": 514143430,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1745505128
    },
    {
        "content": "<p>(both <code>choose</code> and <code>choose!</code> versions can be useful)</p>",
        "id": 514143517,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1745505155
    },
    {
        "content": "<p>Maybe <code>@[split]</code> could in general destruct the target type and make new declarations, using some list of types that we'd normally split (curry) if they were arguments to a function or lemma. What come to mind: and, exists, sigma, subtype, maybe prod.</p>\n<p>Ah, maybe the syntax is <code>@[split ‚ü®thm1, ‚ü®thm2, thm3‚ü©, thm4‚ü©]</code> and there does not need to be a list of \"blessed\" types. There would be an implicit <code>intro</code> for this destruct syntax, so for example the <code>‚ü®thm2, thm3‚ü©</code> could be parameterized by more arguments if it's a forall there.</p>",
        "id": 514157825,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1745508383
    },
    {
        "content": "<p>(Somewhat related: the discussion about <a href=\"#narrow/channel/239415-metaprogramming-.2F-tactics/topic/mutual.20induction.20tactic/near/504421657\">mutual induction</a>. This link is to joint theorem definitions.)</p>",
        "id": 514158443,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1745508541
    },
    {
        "content": "<p>Should it be a superset of <code>alias</code>?</p>",
        "id": 514169961,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1745511868
    }
]