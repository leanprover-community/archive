[
    {
        "content": "<p>What's the fix for this?:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">synthesized</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">expression</span> <span class=\"n\">inferred</span> <span class=\"kd\">by</span> <span class=\"n\">typing</span> <span class=\"n\">rules</span><span class=\"o\">,</span> <span class=\"n\">synthesized</span>\n  <span class=\"n\">PseudoMetricSpace.toUniformSpace</span>\n<span class=\"n\">inferred</span>\n  <span class=\"n\">AbsoluteValue.uniformSpace</span> <span class=\"n\">AbsoluteValue.abs</span>\n</code></pre></div>\n<p>Maybe hide the mistaken instance?</p>",
        "id": 340205552,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678220530
    },
    {
        "content": "<p>Nope:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">PseudoMetricSpace.toUniformSpace</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">PseudoEMetricSpace.toUniformSpace</span>\n</code></pre></div>\n<p>changes the message to 'failed to synthesize instance<br>\n  UniformSpace ℚ'</p>",
        "id": 340206726,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678220942
    },
    {
        "content": "<p>Can you add a PR comment on the relevant line of <a href=\"https://github.com/leanprover-community/mathlib4/pull/2702\">!4#2702</a>?</p>",
        "id": 340206802,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678220968
    },
    {
        "content": "<p>Done</p>",
        "id": 340208893,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678221707
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.UniformSpace.AbstractCompletion</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Order.AbsoluteValue</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.UniformSpace.AbsoluteValue</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Instances.Rat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">rationalCauSeqPkg</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">AbstractCompletion</span> <span class=\"n\">ℚ</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">AbsoluteValue.abs</span> <span class=\"n\">ℚ</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">uniformSpace</span>\n    <span class=\"n\">where</span>\n</code></pre></div>\n<p>demonstrates the issue</p>",
        "id": 340209485,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678221893
    },
    {
        "content": "<p>You can't use <code>where</code> for constructors relating to non-canonical instances</p>",
        "id": 340209672,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678221958
    },
    {
        "content": "<p>You have to use <code>@AbstractCompletion.mk</code>, and pass <code>(_)</code> as the instance argument</p>",
        "id": 340209825,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678222001
    },
    {
        "content": "<p>Lean3 was happy to use unification here, Lean4 will use typeclass search (and then complain that it doesn't unify), unless you force it to not be able to use typeclass search</p>",
        "id": 340210134,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678222096
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">rationalCauSeqPkg</span> <span class=\"o\">:</span> <span class=\"n\">AbstractCompletion</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">AbstractCompletion.mk</span>\n  <span class=\"o\">(</span><span class=\"n\">space</span> <span class=\"o\">:=</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">RatCast.ratCast</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">uniformStruct</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">separation</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">uniformInducing</span> <span class=\"o\">:=</span> <span class=\"n\">Rat.uniformEmbedding_coe_real.toUniformInducing</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">dense</span> <span class=\"o\">:=</span> <span class=\"n\">Rat.denseEmbedding_coe_real.dense</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 340214518,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678223384
    },
    {
        "content": "<p>Wanted the instance named...</p>",
        "id": 340214633,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678223423
    },
    {
        "content": "<p>I think for now you just have to use underscores...</p>",
        "id": 340218557,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678224915
    },
    {
        "content": "<p>Lean yells if you do that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">infer</span> <span class=\"kd\">definition</span> <span class=\"n\">type</span>\n<span class=\"n\">when</span> <span class=\"n\">the</span> <span class=\"n\">resulting</span> <span class=\"n\">type</span> <span class=\"n\">of</span> <span class=\"n\">a</span> <span class=\"n\">declaration</span> <span class=\"n\">is</span> <span class=\"n\">explicitly</span> <span class=\"n\">provided</span><span class=\"o\">,</span> <span class=\"n\">all</span> <span class=\"n\">holes</span> <span class=\"o\">(</span><span class=\"n\">e.g.</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">_</span><span class=\"bp\">`</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">header</span> <span class=\"n\">are</span> <span class=\"n\">resolved</span> <span class=\"n\">before</span> <span class=\"n\">the</span> <span class=\"n\">declaration</span> <span class=\"n\">body</span> <span class=\"n\">is</span> <span class=\"n\">processed</span>\n</code></pre></div>",
        "id": 340233728,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678231184
    },
    {
        "content": "<p>Now the <code>def</code> compiles, has the expected type, but Lean yells later on when it's used. I think it's an implicit issue, but can't figure out how to supply implicits with dotted notation.</p>",
        "id": 340234642,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678231598
    },
    {
        "content": "<p>Got it, and it doesn't help. This is the exact analogue of the type on the Lean 3 side:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">compareEquiv</span> <span class=\"o\">:</span> <span class=\"n\">Bourbakiℝ</span> <span class=\"bp\">≃ᵤ</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">AbstractCompletion.uniformContinuous_compareEquiv</span> <span class=\"n\">Q</span> <span class=\"n\">uniformSpace</span> <span class=\"n\">bourbakiPkg</span> <span class=\"n\">rationalCauSeqPkg</span>\n</code></pre></div>\n<p>And errors on <code>rationalCauSeqPkg</code> with: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">argument</span>\n  <span class=\"n\">rationalCauSeqPkg</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">AbstractCompletion</span> <span class=\"n\">ℚ</span> <span class=\"n\">PseudoMetricSpace.toUniformSpace</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">AbstractCompletion</span> <span class=\"n\">Q</span> <span class=\"n\">uniformSpace</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 340237390,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678233157
    },
    {
        "content": "<p>Getting one step closer:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">rationalCauSeqPkg</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">AbstractCompletion</span> <span class=\"n\">ℚ</span> <span class=\"n\">uniformSpace</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">AbstractCompletion.mk</span>\n  <span class=\"o\">(</span><span class=\"n\">space</span> <span class=\"o\">:=</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">RatCast.ratCast</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">uniformStruct</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">separation</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">uniformInducing</span> <span class=\"o\">:=</span> <span class=\"n\">Rat.uniformEmbedding_coe_real.toUniformInducing</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">dense</span> <span class=\"o\">:=</span> <span class=\"n\">Rat.denseEmbedding_coe_real.dense</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>fixes the typing errors later down, but fails on the <code>uniformInducing</code> and <code>dense</code> steps, the former with our friend:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">synthesized</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">expression</span> <span class=\"n\">inferred</span> <span class=\"kd\">by</span> <span class=\"n\">typing</span> <span class=\"n\">rules</span><span class=\"o\">,</span> <span class=\"n\">synthesized</span>\n  <span class=\"n\">uniformSpace</span>\n<span class=\"n\">inferred</span>\n  <span class=\"n\">PseudoMetricSpace.toUniformSpace</span>\n</code></pre></div>\n<p>The latter with the very confusing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">synthesized</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">expression</span> <span class=\"n\">inferred</span> <span class=\"kd\">by</span> <span class=\"n\">typing</span> <span class=\"n\">rules</span><span class=\"o\">,</span> <span class=\"n\">synthesized</span>\n  <span class=\"n\">toTopologicalSpace</span>\n<span class=\"n\">inferred</span>\n  <span class=\"n\">toTopologicalSpace</span>\n</code></pre></div>",
        "id": 340238806,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678233821
    },
    {
        "content": "<p>I've gone so far as doing:</p>\n<p><code> (uniformInducing := @UniformEmbedding.toUniformInducing ℚ ℝ uniformSpace _ RatCast.ratCast Rat.uniformEmbedding_coe_real)</code></p>\n<p>which still gives me...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">pplication</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">Rat.uniformEmbedding_coe_real.toUniformInducing</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">Rat.uniformEmbedding_coe_real</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">UniformEmbedding</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℝ</span> <span class=\"n\">PseudoMetricSpace.toUniformSpace</span> <span class=\"n\">PseudoMetricSpace.toUniformSpace</span> <span class=\"n\">RatCast.ratCast</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">UniformEmbedding</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℝ</span> <span class=\"n\">uniformSpace</span> <span class=\"n\">PseudoMetricSpace.toUniformSpace</span> <span class=\"n\">RatCast.ratCast</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">````</span>\n</code></pre></div>",
        "id": 340247930,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678238728
    },
    {
        "content": "<p>When I turn <code>pp.all true</code></p>\n<p>I get as the type of <code>Rat.uniformEmbedding_coe_real</code></p>\n<p><code>Rat.uniformEmbedding_coe_real :\n  @UniformEmbedding.{0, 0} Rat Real\n    (@PseudoMetricSpace.toUniformSpace.{0} Rat (@MetricSpace.toPseudoMetricSpace.{0} Rat Rat.instMetricSpaceRat))\n    (@PseudoMetricSpace.toUniformSpace.{0} Real Real.pseudoMetricSpace) (@RatCast.ratCast.{0} Real Real.ratCast)</code></p>",
        "id": 340248060,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678238818
    },
    {
        "content": "<p>The types check out the same on the Lean3 side but it doesn't seem to cause trouble there,</p>",
        "id": 340254662,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678241582
    },
    {
        "content": "<p>The <code>toTopologicalSpace</code> issue is similar under the microscope of <code>pp.all true</code></p>\n<p>I don't understand the machinery well enough here, but is there a coercion between <code>PseudoMetricSpace.toUniformSpace</code> and <code>ℝ.uniformSpace</code> wanting?</p>",
        "id": 340255766,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678242386
    },
    {
        "content": "<p>Or something something defeq?</p>",
        "id": 340264937,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678249159
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542196\">Arien Malec</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Issue.20in.20!4.232702.20.28Topology.2EUniformSpace.2ECompareReals.29/near/340247930\">said</a>:</p>\n<blockquote>\n<p>I've gone so far as doing:</p>\n<p><code> (uniformInducing := @UniformEmbedding.toUniformInducing ℚ ℝ uniformSpace _ RatCast.ratCast Rat.uniformEmbedding_coe_real)</code></p>\n<p>which still gives me...</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">Rat.uniformEmbedding_coe_real.toUniformInducing</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">Rat.uniformEmbedding_coe_real</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">UniformEmbedding</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℝ</span> <span class=\"n\">PseudoMetricSpace.toUniformSpace</span> <span class=\"n\">PseudoMetricSpace.toUniformSpace</span> <span class=\"n\">RatCast.ratCast</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">UniformEmbedding</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℝ</span> <span class=\"n\">uniformSpace</span> <span class=\"n\">PseudoMetricSpace.toUniformSpace</span> <span class=\"n\">RatCast.ratCast</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Are these terms defeq? If so it's lean's problem, if not it's our problem.</p>",
        "id": 340371853,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1678284834
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542196\">Arien Malec</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Issue.20in.20!4.232702.20.28Topology.2EUniformSpace.2ECompareReals.29/near/340233728\">said</a>:</p>\n<blockquote>\n<p>Lean yells if you do that</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">infer</span> <span class=\"kd\">definition</span> <span class=\"n\">type</span>\n<span class=\"n\">when</span> <span class=\"n\">the</span> <span class=\"n\">resulting</span> <span class=\"n\">type</span> <span class=\"n\">of</span> <span class=\"n\">a</span> <span class=\"n\">declaration</span> <span class=\"n\">is</span> <span class=\"n\">explicitly</span> <span class=\"n\">provided</span><span class=\"o\">,</span> <span class=\"n\">all</span> <span class=\"n\">holes</span> <span class=\"o\">(</span><span class=\"n\">e.g.</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">_</span><span class=\"bp\">`</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">header</span> <span class=\"n\">are</span> <span class=\"n\">resolved</span> <span class=\"n\">before</span> <span class=\"n\">the</span> <span class=\"n\">declaration</span> <span class=\"n\">body</span> <span class=\"n\">is</span> <span class=\"n\">processed</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>The underscores belong after the <code>:=</code> not before</p>",
        "id": 340389571,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678288560
    },
    {
        "content": "<p>That leads to a different set of issues.</p>",
        "id": 340402718,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678291440
    },
    {
        "content": "<p>I note that right before this definition we have:</p>\n<p><code>theorem Rat.uniformSpace_eq :\n    (AbsoluteValue.abs : AbsoluteValue ℚ ℚ).uniformSpace = PseudoMetricSpace.toUniformSpace</code> which answers the defeq question</p>",
        "id": 340403835,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678291682
    },
    {
        "content": "<p>I'm really sorry I don't have time to help with this. I will have time this week-end if you are still stuck by then.</p>",
        "id": 340404430,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1678291813
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542196\">Arien Malec</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Issue.20in.20!4.232702.20.28Topology.2EUniformSpace.2ECompareReals.29/near/340402718\">said</a>:</p>\n<blockquote>\n<p>That leads to a different set of issues.</p>\n</blockquote>\n<p>I think these issues are the ones you should address. This isn't an unexpected instance diamond or anything, this is just an unusual theorem which mathport doesn't port correctly due to a conscious decision by lean4 to make you spell things the long/ugly way</p>",
        "id": 340404862,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678291922
    },
    {
        "content": "<p>We've hit this problem in multiple places before</p>",
        "id": 340405002,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678291951
    },
    {
        "content": "<p>The issues are worse to be clear. The definition doesn’t compile &amp; doesn’t typecheck in use. I think I just need to tell Lean about the defeq in proof.</p>",
        "id": 340409347,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678293008
    },
    {
        "content": "<p>They're not defeq and that's the point of the lemmas I think</p>",
        "id": 340409948,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678293127
    },
    {
        "content": "<p>I pushed a fix; the solution was to not change the statement of the <code>def</code>, and do roughly what I described above</p>",
        "id": 340411965,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678293613
    },
    {
        "content": "<p>Thanks for finding a better way to force unification than using <code>@foo _ _ (_) x</code> for instance arguments! It seems that using <code>@foo (x := x)</code> has the same effect.</p>",
        "id": 340413872,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678294095
    },
    {
        "content": "<p>(as a reminder, <code>@foo _ _ _ x</code> is not the same as <code>@foo _ _ (_) x</code> when it comes to elaborating the last underscore)</p>",
        "id": 340414424,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678294233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Issue.20in.20!4.232702.20.28Topology.2EUniformSpace.2ECompareReals.29/near/340413872\">said</a>:</p>\n<blockquote>\n<p>Thanks for finding a better way to force unification than using <code>@foo _ _ (_) x</code> for instance arguments! It seems that using <code>@foo (x := x)</code> has the same effect.</p>\n</blockquote>\n<p>I just borrowed the usual lawful monad fixes. Even a blind squirrel finds a nut.</p>",
        "id": 340415401,
        "sender_full_name": "Arien Malec",
        "timestamp": 1678294476
    }
]