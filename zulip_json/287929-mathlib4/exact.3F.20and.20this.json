[
    {
        "content": "<p>Hi, I'm doing a little course on lean4, and we think we might have found a bug in one of our exercises: the two examples below should work identically, but line 18 (the last this in the first example) produces an error, even though <code>exact?</code> suggested exactly this code - in the second <code>example</code> I explicitly named the hypotheses along the way, and then there isn't an error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n <span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.FieldSimp</span>\n <span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.LibrarySearch</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">x_pos</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">):</span>\n  <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">sq_nonneg</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span><span class=\"mi\">2</span> <span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">·</span> <span class=\"n\">convert</span> <span class=\"n\">this</span>\n    <span class=\"n\">ring</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span><span class=\"n\">x</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Iff.mp</span> <span class=\"n\">sub_nonneg</span> <span class=\"n\">this</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">/</span><span class=\"n\">x</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Iff.mpr</span> <span class=\"o\">(</span><span class=\"n\">div_le_div_right</span> <span class=\"n\">x_pos</span><span class=\"o\">)</span> <span class=\"n\">this</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Iff.mpr</span> <span class=\"o\">(</span><span class=\"n\">le_div_iff</span> <span class=\"n\">x_pos</span><span class=\"o\">)</span> <span class=\"n\">this</span> <span class=\"c1\">-- &lt;- what exact? suggested</span>\n  <span class=\"gr\">sorry</span>\n\n\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">x_pos</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">):</span>\n  <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">sq_nonneg</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span><span class=\"mi\">2</span> <span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">·</span> <span class=\"n\">convert</span> <span class=\"n\">h1</span>\n    <span class=\"n\">ring</span>\n  <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span><span class=\"n\">x</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Iff.mp</span> <span class=\"n\">sub_nonneg</span> <span class=\"n\">h2</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">/</span><span class=\"n\">x</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Iff.mpr</span> <span class=\"o\">(</span><span class=\"n\">div_le_div_right</span> <span class=\"n\">x_pos</span><span class=\"o\">)</span> <span class=\"n\">h3</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Iff.mpr</span> <span class=\"o\">(</span><span class=\"n\">le_div_iff</span> <span class=\"n\">x_pos</span><span class=\"o\">)</span> <span class=\"n\">h3</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(also on the web version: <a href=\"https://lean.math.hhu.de/#code=%20import%20Mathlib.Data.Real.Basic%0A%20import%20Mathlib.Tactic.FieldSimp%0A%20import%20Mathlib.Tactic.LibrarySearch%0A%0Aexample%20(x%3A%20%E2%84%9D)%20%20(x_pos%20%3A%20x%20%3E%200)%3A%0A%20%20x%20%2B%201%2Fx%20%E2%89%A5%202%20%3A%3D%0Aby%0A%20%20have%20%3A%20(x-1)%5E2%20%E2%89%A5%200%0A%20%20%C2%B7%20exact%20sq_nonneg%20(x-1)%0A%20%20have%20%3A%20x%5E2%20%2B%201%20-2%20*x%20%E2%89%A5%200%0A%20%20%C2%B7%20convert%20this%0A%20%20%20%20ring%0A%20%20have%20%3A%20x%5E2%20%2B%201%20%E2%89%A5%202%20*x%20%0A%20%20%C2%B7%20exact%20Iff.mp%20sub_nonneg%20this%0A%20%20have%20%3A%20(x%5E2%20%2B%201)%2Fx%20%E2%89%A5%202%20*%20x%20%2Fx%0A%20%20%C2%B7%20exact%20Iff.mpr%20(div_le_div_right%20x_pos)%20this%0A%20%20have%20%3A%20(x%5E2%20%2B%201)%2Fx%20%E2%89%A5%202%20%0A%20%20%C2%B7%20exact%20Iff.mpr%20(le_div_iff%20x_pos)%20this%0A%20%20sorry%0A%0A%0A%20%20%0Aexample%20(x%3A%20%E2%84%9D)%20%20(x_pos%20%3A%20x%20%3E%200)%3A%0A%20%20x%20%2B%201%2Fx%20%E2%89%A5%202%20%3A%3D%0Aby%0A%20%20have%20h1%3A%20(x-1)%5E2%20%E2%89%A5%200%0A%20%20%C2%B7%20exact%20sq_nonneg%20(x-1)%0A%20%20have%20h2%20%3A%20x%5E2%20%2B%201%20-2%20*x%20%E2%89%A5%200%0A%20%20%C2%B7%20convert%20h1%0A%20%20%20%20ring%0A%20%20have%20h3%20%3A%20x%5E2%20%2B%201%20%E2%89%A5%202%20*x%20%0A%20%20%C2%B7%20exact%20Iff.mp%20sub_nonneg%20h2%0A%20%20have%20h4%3A%20(x%5E2%20%2B%201)%2Fx%20%E2%89%A5%202%20*%20x%20%2Fx%0A%20%20%C2%B7%20exact%20Iff.mpr%20(div_le_div_right%20x_pos)%20h3%0A%20%20have%20%3A%20(x%5E2%20%2B%201)%2Fx%20%E2%89%A5%202%20%0A%20%20%C2%B7%20exact%20Iff.mpr%20(le_div_iff%20x_pos)%20h3%0A%20%20sorry%0A%0A\">https://lean.math.hhu.de/#code=%20import%20Mathlib.Data.Real.Basic%0A%20import%20Mathlib.Tactic.FieldSimp%0A%20import%20Mathlib.Tactic.LibrarySearch%0A%0Aexample%20(x%3A%20%E2%84%9D)%20%20(x_pos%20%3A%20x%20%3E%200)%3A%0A%20%20x%20%2B%201%2Fx%20%E2%89%A5%202%20%3A%3D%0Aby%0A%20%20have%20%3A%20(x-1)%5E2%20%E2%89%A5%200%0A%20%20%C2%B7%20exact%20sq_nonneg%20(x-1)%0A%20%20have%20%3A%20x%5E2%20%2B%201%20-2%20*x%20%E2%89%A5%200%0A%20%20%C2%B7%20convert%20this%0A%20%20%20%20ring%0A%20%20have%20%3A%20x%5E2%20%2B%201%20%E2%89%A5%202%20*x%20%0A%20%20%C2%B7%20exact%20Iff.mp%20sub_nonneg%20this%0A%20%20have%20%3A%20(x%5E2%20%2B%201)%2Fx%20%E2%89%A5%202%20*%20x%20%2Fx%0A%20%20%C2%B7%20exact%20Iff.mpr%20(div_le_div_right%20x_pos)%20this%0A%20%20have%20%3A%20(x%5E2%20%2B%201)%2Fx%20%E2%89%A5%202%20%0A%20%20%C2%B7%20exact%20Iff.mpr%20(le_div_iff%20x_pos)%20this%0A%20%20sorry%0A%0A%0A%20%20%0Aexample%20(x%3A%20%E2%84%9D)%20%20(x_pos%20%3A%20x%20%3E%200)%3A%0A%20%20x%20%2B%201%2Fx%20%E2%89%A5%202%20%3A%3D%0Aby%0A%20%20have%20h1%3A%20(x-1)%5E2%20%E2%89%A5%200%0A%20%20%C2%B7%20exact%20sq_nonneg%20(x-1)%0A%20%20have%20h2%20%3A%20x%5E2%20%2B%201%20-2%20*x%20%E2%89%A5%200%0A%20%20%C2%B7%20convert%20h1%0A%20%20%20%20ring%0A%20%20have%20h3%20%3A%20x%5E2%20%2B%201%20%E2%89%A5%202%20*x%20%0A%20%20%C2%B7%20exact%20Iff.mp%20sub_nonneg%20h2%0A%20%20have%20h4%3A%20(x%5E2%20%2B%201)%2Fx%20%E2%89%A5%202%20*%20x%20%2Fx%0A%20%20%C2%B7%20exact%20Iff.mpr%20(div_le_div_right%20x_pos)%20h3%0A%20%20have%20%3A%20(x%5E2%20%2B%201)%2Fx%20%E2%89%A5%202%20%0A%20%20%C2%B7%20exact%20Iff.mpr%20(le_div_iff%20x_pos)%20h3%0A%20%20sorry%0A%0A</a>)</p>",
        "id": 392277001,
        "sender_full_name": "Max Cairney-Leeming",
        "timestamp": 1695286265
    },
    {
        "content": "<p>(also  <span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span> , since he's teaching us this course and is also wondering what's gone wrong)</p>",
        "id": 392277069,
        "sender_full_name": "Max Cairney-Leeming",
        "timestamp": 1695286299
    },
    {
        "content": "<p>(No need to provide links to the web version: every code block has a button in the top right that takes you there!</p>",
        "id": 392278515,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695286818
    },
    {
        "content": "<p>Yes, this is a known problem. <code>exact?</code> can use all of the shadowed versions of <code>this</code>, yet when offering a suggestion it doesn't have a way of disambiguating for the human which one it used!</p>",
        "id": 392278743,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695286894
    },
    {
        "content": "<p>Actually <code>exact?</code> suggested <code>exact Iff.mpr (le_div_iff x_pos) this✝</code>, which will not work because <code>this✝</code> is an inaccessible term</p>",
        "id": 392278761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695286902
    },
    {
        "content": "<p>Not quite Kevin:</p>\n<p><a href=\"/user_uploads/3121/89F2lMFM3biNKgJrqMagSs8s/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/89F2lMFM3biNKgJrqMagSs8s/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/89F2lMFM3biNKgJrqMagSs8s/image.png\"></a></div>",
        "id": 392278962,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695286956
    },
    {
        "content": "<p>It suggested the <code>✝</code>, but the <code>try this</code> removed it</p>",
        "id": 392278999,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695286968
    },
    {
        "content": "<p>We need to implement <code>try this✝</code></p>",
        "id": 392279058,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695286986
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"652165\">@Max Cairney-Leeming</span> a quick fix is <code>exact Iff.mpr (le_div_iff x_pos) (by assumption)</code> -- Lean is suggesting you use a term which doesn't have an (accessible) name, but <code>by assumption</code> will find it.</p>",
        "id": 392279384,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695287095
    },
    {
        "content": "<p>Another fix would be to not keep writing <code>have : ...</code> -- all you're doing here is naming more and more hypotheses <code>this</code> and when you have two hypotheses with the same name, you can't ever mention one of them again; its name is \"lost\". If you use this approach then the problem goes away:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">x_pos</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">):</span>\n  <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">sq_nonneg</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span><span class=\"mi\">2</span> <span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">·</span> <span class=\"n\">convert</span> <span class=\"n\">h1</span>\n    <span class=\"n\">ring</span>\n  <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span><span class=\"n\">x</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Iff.mp</span> <span class=\"n\">sub_nonneg</span> <span class=\"n\">h2</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">/</span><span class=\"n\">x</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Iff.mpr</span> <span class=\"o\">(</span><span class=\"n\">div_le_div_right</span> <span class=\"n\">x_pos</span><span class=\"o\">)</span> <span class=\"n\">h3</span>\n  <span class=\"k\">have</span> <span class=\"n\">h5</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span><span class=\"bp\">?</span> <span class=\"c1\">-- suggestion now works</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 392279795,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695287222
    },
    {
        "content": "<p>Ah, I see - it was being more clever than me, and ignoring  one of my <code>have</code> blocks, so the simplest is just to remove the superfluous one</p>",
        "id": 392279841,
        "sender_full_name": "Max Cairney-Leeming",
        "timestamp": 1695287237
    },
    {
        "content": "<p><del>If you use <code>haveI</code> you get unique names for free</del> (oh, this only worked in Lean 3)</p>",
        "id": 392279878,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695287251
    },
    {
        "content": "<p>Can \"try this\" use dot notation? I.e., <code>(le_div_iff x_pos).mpr ...</code> in place of <code>Iff.mpr (le_div_iff x_pos) ...</code>.</p>",
        "id": 392280282,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1695287396
    },
    {
        "content": "<p>Another issue with this work is that mathlib has essentially no lemmas about <code>≥</code>, basically the symbol is banned in mathlib because it means the same thing as <code>≤</code> modulo a permutation of inputs. So you would find your life easier if you used <code>≤</code> everywhere.</p>",
        "id": 392280358,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695287411
    },
    {
        "content": "<p>We could probably automate the fix! Replace any inaccessible names with <code>‹_›</code> on whatever level is convenient, try that, and see if it works—otherwise be explicit with the type, and if that doesn't work, prepend something like <code>rename_i</code> with appropriate arguments and a unique name.</p>",
        "id": 392281066,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1695287661
    },
    {
        "content": "<p>Here is how I teach my students to solve that kind of goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">x_pos</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">):</span>\n    <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span>\n  <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">field_simp</span><span class=\"bp\">;</span> <span class=\"n\">ring</span>\n  <span class=\"n\">_</span>       <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ring</span>\n  <span class=\"n\">_</span>       <span class=\"bp\">≥</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">gcongr</span><span class=\"bp\">;</span> <span class=\"n\">nlinarith</span>\n  <span class=\"n\">_</span>       <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">field_simp</span>\n</code></pre></div>\n<p>Note that I never used <code>exact?</code>, I never need to know the names of any lemmas, and the same few tactics do all the heavy lifting. I learnt this proof strategy from <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> (who also developed tactics to make this approach viable, and advocates for it in her undergrad Lean course).</p>",
        "id": 392281081,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695287668
    },
    {
        "content": "<p>(Note that <code>‹_›</code> is a shortcut for <code>by assumption</code>.)</p>",
        "id": 392281098,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1695287674
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392280282\">said</a>:</p>\n<blockquote>\n<p>Can \"try this\" use dot notation? I.e., <code>(le_div_iff x_pos).mpr ...</code> in place of <code>Iff.mpr (le_div_iff x_pos) ...</code>.</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">pp_dot</span><span class=\"o\">]</span> <span class=\"n\">Iff.mpr</span>\n</code></pre></div>",
        "id": 392281412,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695287783
    },
    {
        "content": "<p>tbh, I'm not sure why we don't already have that somewhere low down in Mathlib.</p>",
        "id": 392281466,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695287800
    },
    {
        "content": "<p>because it's now opt-in and we're still slowly opting everything in?</p>",
        "id": 392281558,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695287840
    },
    {
        "content": "<p>I would vote for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">pp_dot</span><span class=\"o\">]</span> <span class=\"n\">Iff.mpr</span> <span class=\"n\">Iff.mp</span> <span class=\"n\">False.elim</span> <span class=\"n\">Eq.symm</span> <span class=\"n\">Eq.trans</span>\n</code></pre></div>",
        "id": 392281624,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695287861
    },
    {
        "content": "<p>I'll use this as an excuse to plug <a href=\"https://github.com/leanprover-community/mathlib4/pull/7239\">#7239</a>, which adds <code>pp_dot</code> to <code>LinearMap.comp</code> and <code>LinearEquiv.comp</code> too</p>",
        "id": 392281895,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695287953
    },
    {
        "content": "<p>but we can't just add it to <code>*</code>?</p>",
        "id": 392281930,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695287967
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392278999\">said</a>:</p>\n<blockquote>\n<p>It suggested the <code>✝</code>, but the <code>try this</code> removed it</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>, do you know if this is deliberate?</p>",
        "id": 392282049,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695288002
    },
    {
        "content": "<p>There's nothing about this in Try this.</p>",
        "id": 392282146,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695288025
    },
    {
        "content": "<p>More <code>@[pp_dot]</code>s in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7288\">#7288</a>.</p>",
        "id": 392283211,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695288398
    },
    {
        "content": "<p>What's the relationship between the two \"Try this\" messages in my screenshot?</p>",
        "id": 392283417,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695288468
    },
    {
        "content": "<p>One (the logged info) is <code>MessageData</code> <del>direct from syntax</del> from an Expr (<code>exact?</code> doesn't use the default, turns out!), the other is pretty-printed into a <code>Format</code> then a string—I'm not exactly sure how <code>MessageData</code> gets pretty-printed, but I imagine the difference is in there somewhere.</p>",
        "id": 392284022,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1695288661
    },
    {
        "content": "<p>The first one is generated from an Expr via <code>delabToRefinableSyntax</code> and then <code>PrettyPrint.ppCategory</code>. The second is generated by interpolating the Expr into a MessageData. It's in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Tactic.TryThis.addExactSuggestion#src\">src#Std.Tactic.TryThis.addExactSuggestion</a></p>",
        "id": 392284187,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695288720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392280358\">said</a>:</p>\n<blockquote>\n<p>Another issue with this work is that mathlib has essentially no lemmas about <code>≥</code>, basically the symbol is banned in mathlib because it means the same thing as <code>≤</code> modulo a permutation of inputs. So you would find your life easier if you used <code>≤</code> everywhere.</p>\n</blockquote>\n<p>Yeah, I am definitely guilty of this. In my defense, I tested (before my class) that everything worked with <code>≥</code> and I opted for it because reading <code>x + 1/x ≥ 2</code> is better than reading <code>2 ≤ x + 1/x</code> for my mental model.</p>",
        "id": 392285873,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1695289334
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392278743\">said</a>:</p>\n<blockquote>\n<p>Yes, this is a known problem. <code>exact?</code> can use all of the shadowed versions of <code>this</code>, yet when offering a suggestion it doesn't have a way of disambiguating for the human which one it used!</p>\n</blockquote>\n<p>In my personal opinion, tactics like <code>exact?</code> should work only with accessible terms.<br>\nI avoid shadowing most of the time, and when I do shadow something, it is absolutely deliberate.</p>",
        "id": 392286316,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1695289507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392285873\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392280358\">said</a>:</p>\n<blockquote>\n<p>Another issue with this work is that mathlib has essentially no lemmas about <code>≥</code>, basically the symbol is banned in mathlib because it means the same thing as <code>≤</code> modulo a permutation of inputs. So you would find your life easier if you used <code>≤</code> everywhere.</p>\n</blockquote>\n<p>Yeah, I am definitely guilty of this. In my defense, I tested (before my class) that everything worked with <code>≥</code> and I opted for it because reading <code>x + 1/x ≥ 2</code> is better than reading <code>2 ≤ x + 1/x</code> for my mental model.</p>\n</blockquote>\n<p>This was somewhat of an issue in Lean 3 but to be honest I'm just repeating the mantra here -- my tactic proof didn't seem to care at all that the inequalities were \"the wrong way around\". It might be the case that we can get away with more in Lean 4; one reason I tried the tactic proof without reversing the inequality (which was my instinct) was to see if it worked, and it worked first time.</p>",
        "id": 392287238,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695289887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392286316\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392278743\">said</a>:</p>\n<blockquote>\n<p>Yes, this is a known problem. <code>exact?</code> can use all of the shadowed versions of <code>this</code>, yet when offering a suggestion it doesn't have a way of disambiguating for the human which one it used!</p>\n</blockquote>\n<p>In my personal opinion, tactics like <code>exact?</code> should work only with accessible terms.<br>\nI avoid shadowing most of the time, and when I do shadow something, it is absolutely deliberate.</p>\n</blockquote>\n<p>I'm on the other side of the fence here: there's a good chance when using <code>exact?</code> that I don't know exactly what hypotheses I need (LE vs LT, for example), so I might throw in <code>have := h1.le; have := h2.le; ...</code> before the call. It would be unnecessarily annoying to have to give those all unique names</p>",
        "id": 392291767,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1695291555
    },
    {
        "content": "<p>Would you also scale it up for more than one shadowing?<br>\nFor example, is <code>Try this: exact foo this✝¹</code> a valid thing for <code>exact?</code> to suggest?</p>",
        "id": 392295912,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1695293210
    },
    {
        "content": "<p>Something like <code>by assumption</code> would be better, but I actually would prefer <code>this✝¹</code> over <code>this</code>, because that makes it more obvious what's wrong and which assumption it used</p>",
        "id": 392296395,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1695293417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392291767\">said</a>:</p>\n<blockquote>\n<p>I'm on the other side of the fence here: there's a good chance when using <code>exact?</code> that I don't know exactly what hypotheses I need (LE vs LT, for example), so I might throw in <code>have := h1.le; have := h2.le; ...</code> before the call.</p>\n</blockquote>\n<p>I am on my side of the fence for a reason.</p>\n<p>I never use unnamed <code>have</code> because I am too lazy to write down a name.<br>\nFYI, you can always let your cat run over the keyboards and, if given <code>have</code> happens to be actually useful, you can properly name it later.</p>\n<p>My laziness comes into the picture in a different manner:<br>\nI intentionally use shadowing when I am too lazy to write <code>clear this</code> and continue with a fresh identifier.</p>",
        "id": 392296861,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1695293643
    },
    {
        "content": "<p>I'm unconvinced as yet, and don't intend to change <code>exact?</code> to not use shadowed hypotheses.</p>",
        "id": 392297387,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1695293862
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392287238\">said</a>:</p>\n<blockquote>\n<p>This was somewhat of an issue in Lean 3 but to be honest I'm just repeating the mantra here -- my tactic proof didn't seem to care at all that the inequalities were \"the wrong way around\". It might be the case that we can get away with more in Lean 4; one reason I tried the tactic proof without reversing the inequality (which was my instinct) was to see if it worked, and it worked first time.</p>\n</blockquote>\n<p>Unfortunately, that are still situations where Lean 4 cares whether I write <code>b ≤ a</code> or <code>a ≥ b</code> there.<br>\nCould <code>a ≥ b</code> be defined as a syntactic sugar for <code>b ≤ a</code> that gets replaced by the compiler before elaboration?</p>\n<p>Are there any mathematical structures where we don't want <code>b ≤ a</code> and <code>a ≥ b</code> to be definitionally equivalent?<br>\nI hope not...</p>",
        "id": 392298336,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1695294247
    },
    {
        "content": "<p>it could, but that's not how it is defined right now</p>",
        "id": 392298496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695294312
    },
    {
        "content": "<p>For example <code>$</code> and <code>&lt;|</code> are defined as macros which expand to applications, so you never have to deal with downstream consequences of using one over the other</p>",
        "id": 392298617,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695294361
    },
    {
        "content": "<p>one drawback of using macro expansion for <code>≥</code> is that if you write that your goal is <code>a ≥ b</code> it will be pretty printed as <code>|- b ≤ a</code></p>",
        "id": 392298857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695294440
    },
    {
        "content": "<p>my guess is that this is the main reason it is an abbrev instead of a macro</p>",
        "id": 392298891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695294453
    },
    {
        "content": "<p>Makes sense.</p>",
        "id": 392299057,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1695294518
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392296395\">said</a>:</p>\n<blockquote>\n<p>Something like <code>by assumption</code> would be better</p>\n</blockquote>\n<p>It would be for <code>exact this✝¹</code> but not for <code>exact foo this✝¹</code> as I wrote.</p>",
        "id": 392299950,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1695294854
    },
    {
        "content": "<p>Why not? What's wrong with <code>exact foo (by assumption)</code>?</p>",
        "id": 392300961,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1695295229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392280358\">said</a>:</p>\n<blockquote>\n<p>Another issue with this work is that mathlib has essentially no lemmas about <code>≥</code>, basically the symbol is banned in mathlib because it means the same thing as <code>≤</code> modulo a permutation of inputs. So you would find your life easier if you used <code>≤</code> everywhere.</p>\n</blockquote>\n<p>Should there not be a high priority simp set that normalizes all gt and ge to the lt and lte forms?</p>",
        "id": 392307771,
        "sender_full_name": "Matthew Pocock",
        "timestamp": 1695297723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392281930\">said</a>:</p>\n<blockquote>\n<p>but we can't just add it to <code>*</code>?</p>\n</blockquote>\n<p>No, not the way it's implemented unfortunately (I'll spare you the details). Something that requires human intervention is checking that whatever you add <code>pp_dot</code> to has its first explicit argument being the thing that gets the dot notation.</p>\n<p>I think making it be more reliable and global would need more help from the core pretty printer for function applications.</p>",
        "id": 392309800,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695298575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392281081\">said</a>:</p>\n<blockquote>\n<p>Here is how I teach my students to solve that kind of goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">x_pos</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">):</span>\n    <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span>\n  <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">field_simp</span><span class=\"bp\">;</span> <span class=\"n\">ring</span>\n  <span class=\"n\">_</span>       <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ring</span>\n  <span class=\"n\">_</span>       <span class=\"bp\">≥</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">gcongr</span><span class=\"bp\">;</span> <span class=\"n\">nlinarith</span>\n  <span class=\"n\">_</span>       <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">field_simp</span>\n</code></pre></div>\n<p>Note that I never used <code>exact?</code>, I never need to know the names of any lemmas, and the same few tactics do all the heavy lifting. I learnt this proof strategy from <span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> (who also developed tactics to make this approach viable, and advocates for it in her undergrad Lean course).</p>\n</blockquote>\n<p>I am really conflicted on whether to show <code>calc</code> to beginners.<br>\nThe clear advantage is that <code>calc</code> proofs read really nicely.<br>\nA disadvantage is that, when writing a <code>calc</code> proof, there is a long time between having a syntactically-correct code before writing the calculation and having a syntactically-correct code again. Or is there a shortcut in VS Code that would generate a <code>calc</code> template?</p>",
        "id": 392310821,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1695299017
    },
    {
        "content": "<p>Yes, when I was a beginner this put me off <code>calc</code> a lot. However I think the syntax is now easier in Lean 4 and, even better, check out Patrick's recent video on the community website (the calc part is <a href=\"https://youtu.be/8MFGhOWeCNE?feature=shared&amp;t=1835\">here</a>) and also a recent gif he posted to see some really good new ways of interacting with <code>calc</code>. Unfortunately they're not yet in <code>master</code>, but they're well on the way.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"8MFGhOWeCNE\" href=\"https://youtu.be/8MFGhOWeCNE?feature=shared&amp;t=1835\"><img src=\"https://uploads.zulipusercontent.net/3ef9e5370b6b30aa5a771f7edf1d42500673edff/68747470733a2f2f692e7974696d672e636f6d2f76692f384d4647684f5765434e452f64656661756c742e6a7067\"></a></div>",
        "id": 392311619,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695299346
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> annoyingly I can't find that gif you posted recently where you were showing off several new widget-related things including calc bells and whistles.</p>",
        "id": 392312276,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695299576
    },
    {
        "content": "<p><a href=\"#narrow/stream/287929-mathlib4/topic/Select.20and.20insert.20widgets/near/391992032\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Select.20and.20insert.20widgets/near/391992032</a></p>",
        "id": 392312568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1695299694
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392311619\">said</a>:</p>\n<blockquote>\n<p>Yes, when I was a beginner this put me off <code>calc</code> a lot. However I think the syntax is now easier in Lean 4 and, even better, check out Patrick's recent video on the community website (...)</p>\n</blockquote>\n<p>Oh, that's really neat! I love how it generates the <code>calc</code> lines with the correct syntax!</p>",
        "id": 392319483,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1695302208
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392310821\">said</a>:</p>\n<blockquote>\n<p>when writing a <code>calc</code> proof, there is a long time between having a syntactically-correct code before writing the calculation and having a syntactically-correct code again.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> This was definitely an issue in Lean 3, but have you tried the Lean 4 version?  Since <a href=\"https://github.com/gebner/lean4/commit/5e877b115b617d072ba28a3db57f3fcce777519b\">this change last July</a> partially finished calcs are syntactically correct.</p>",
        "id": 392401243,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1695333232
    },
    {
        "content": "<p>I've been thinking a little bit about how to solve this, since <code>exact?</code> isn't the only time we'll want to use suggestions involving inaccessible hypotheses.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/287929-mathlib4/topic/exact.3F.20and.20this/near/392281066\">said</a>:</p>\n<blockquote>\n<p>Replace any inaccessible names with <code>‹_›</code> on whatever level is convenient, try that, and see if it works—otherwise be explicit with the type</p>\n</blockquote>\n<p>The \"type-explicit\" version of this seems doable—just make an <code>fvar</code> delaborator which inserts <code>‹type›</code>:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> In the real deal we'd probably register an option and check for it, or use a scoped delaborator,</span>\n<span class=\"cm\">but that's a bit clunky to show on zulip -/</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter.Delaborator</span> <span class=\"n\">SubExpr</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[delab fvar]</span>\n<span class=\"kd\">def</span> <span class=\"n\">delabInaccessible</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"n\">whenPPOption</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span> <span class=\"c\">/-</span><span class=\"cm\"> get option here -/</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">fvar</span> <span class=\"n\">i</span> <span class=\"bp\">←</span> <span class=\"n\">getExpr</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n  <span class=\"n\">guard</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">i.getUserName</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isInaccessibleUserName</span>\n  <span class=\"c1\">-- only somewhat sure about the next two lines:</span>\n  <span class=\"k\">let</span> <span class=\"n\">tStx</span> <span class=\"bp\">←</span> <span class=\"n\">withType</span> <span class=\"n\">delab</span>\n  <span class=\"bp\">`</span><span class=\"o\">(‹</span><span class=\"bp\">$</span><span class=\"n\">tStx</span><span class=\"o\">›)</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">annotateCurPos</span>\n</code></pre></div>\n</div></div>\n<p>and then use that when delaborating. We could make it safer by roundtripping the assumption in the middle, to make sure we get the fvarId back:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">j</span> <span class=\"bp\">←</span> <span class=\"n\">findLocalDeclWithType</span><span class=\"bp\">?</span> <span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n  <span class=\"n\">guard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">i</span> <span class=\"bp\">==</span> <span class=\"n\">j</span>\n</code></pre></div>\n<p>but that's a lot of <code>isDefEq</code> checks, potentially.</p>\n<p>I'm guessing we want the ability to insert <code>‹_›</code> when possible, though, since some types might be very verbose. I'm not sure how to do this without roundtripping—we don't currently roundtrip the delaborated syntax in <code>exact?</code> suggestions (I'd guess because it's just too expensive). Maybe we could roundtrip only in cases where we need to check <code>‹_›</code>.</p>\n<p>Another option is to use some kind of elaborator which lets us access inaccessible names in the suggestion itself, but to have this elaborator suggest to replace itself with something better when inserted: with <code>‹_›</code> if that works, <code>‹type›</code> if necessary, or an English-language instruction to manually rename the hypothesis. (This elaborator would be banned from committed Mathlib code.) Do we have something like this already? (<code>rename_i</code> and <code>rename</code> are not what I'm thinking of—I'm thinking of something like (up to syntax) <code>inaccessible% x</code> which elaborates to the fvar which we see as <code>x†</code> in the infoview.)</p>",
        "id": 392430573,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1695351374
    },
    {
        "content": "<p>I had also thinking about the possibility of making an elaborator that lets you refer to inaccessible names, but it would probably be better to have the <code>exact?</code> suggestion be something like <code>rename_i x y z; exact foo</code>. That way (1) it doesn't require custom elaboration/delaboration, (2) it doesn't require any fixing for mathlib, and (3) it's more likely to round trip than <code>‹_›</code> (what if it's <code>‹Nat›</code> and there are multiple Nats? or what if it's replacing an fvar that's in an argument that's solved by unification, causing <code>‹ty›</code> to fail with a \"no goals\" once <code>assumption</code> finally gets called?)</p>",
        "id": 392434435,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1695354044
    }
]