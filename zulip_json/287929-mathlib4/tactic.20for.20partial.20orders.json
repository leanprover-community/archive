[
    {
        "content": "<p>Would it be useful to have a tactic in Mathlib that can solve goals in partial order theory? It is easy to implement, and I'd like to create one to practice metaprogramming.</p>",
        "id": 499185617,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739352876
    },
    {
        "content": "<p>What goals would this tactic solve?</p>",
        "id": 499194080,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739355346
    },
    {
        "content": "<p>Those that can be closed by applying reflexivity, transitivity, or antisymmetry to local hypotheses and the goal. It would also use the linearity of the order when applicable.</p>\n<p>In both cases (partial order and linear order), the quantifier-free theory is decidable in linear time.</p>",
        "id": 499197257,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739356226
    },
    {
        "content": "<p>Is it <a href=\"#narrow/channel/287929-mathlib4/topic/lattice.20tactics/near/453896967\">this</a> ?</p>",
        "id": 499221493,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739363868
    },
    {
        "content": "<p>Hmm, I'm not sure if an <code>aesop</code>-based approach is the best here because it <em>searches</em> for the proof using tree search by guessing proof steps, whereas in this case, it can be done without guessing.</p>\n<p>By the way, it's easy to add support for lattices in the tactic I have in mind.</p>",
        "id": 499229153,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739365999
    },
    {
        "content": "<p>Heather and I have discussed this a bit - I agree this would be nice to have. For the tactic you have in mind, would it be able to prove that a &lt;= b &lt;= c &lt;= d &lt;= e and b != d implies a != e in a partial order?</p>",
        "id": 499274798,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739377163
    },
    {
        "content": "<p>It would be nice to have something work for lattices, as well, even if it is just as simple as adding all the trivial inequalities that come from <code>le_sup_iff</code>,  <code>sup_le_iff</code>, <code>le_sup_left</code>, <code>le_sup_right</code> and similar for <code>inf</code>.</p>",
        "id": 499357878,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1739408789
    },
    {
        "content": "<p>(The thread that Kevin links to does this, but I think Vasily's idea would perform better than the aesop approach. It might work to just preprocess like nlinarith does to add all those inequalities, then running the partial/linear order version)</p>",
        "id": 499358310,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739409044
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/499274798\">said</a>:</p>\n<blockquote>\n<p>Heather and I have discussed this a bit - I agree this would be nice to have. For the tactic you have in mind, would it be able to prove that a &lt;= b &lt;= c &lt;= d &lt;= e and b != d implies a != e in a partial order?</p>\n</blockquote>\n<p>Thank you for this example! Everything turned out to be more complicated than I initially thought. Anyway, it seems that the problem can be solved in quadratic time (not linear as I promised).</p>\n<p>Let me describe my algorithm for partial orders. </p>\n<ol>\n<li>First, we negate the goal, so our new goal is to prove <code>False</code>.  </li>\n<li>We collect all facts in the form of <code>x = y</code>, <code>x ≤ y</code>, <code>x &lt; y</code>, <code>x ≠ y</code>, <code>¬(x ≤ y)</code>, and <code>¬(x &lt; y)</code> from the context. Here, we split conjunctions. Splitting disjunctions would result in exponential blow-up, and I guess we can't do anything smart about it here. However, there should be an option to enable this splitting if needed.</li>\n<li>We replace each fact of the form <code>x &lt; y</code> with two equivalent facts: <code>x ≤ y</code> and <code>x ≠ y</code>.  </li>\n<li>We replace each fact of the form <code>¬(x ≤ y)</code> with two equivalent facts: <code>¬(x &lt; y)</code> and <code>x ≠ y</code>.  </li>\n<li>\n<p>We define the <code>≤</code>-graph as a directed graph whose vertices are variables and whose edges correspond to facts of the form <code>x ≤ y</code>. Similarly, we define (undirected) <code>=</code>-graph.<br>\nWe then find all connected components in <code>=</code>-graph. Variables within the same component are be provably equal. Thus, we can \"compress\" them into a single vertex. During this process, we check that no fact of the form <code>x ≠ y</code> leads to a contradiction — otherwise, we have found a contradiction, and the goal is accomplished. After this step, we may assume that the remaining facts are in one of three forms: <code>x ≤ y</code>, <code>x ≠ y</code>, and <code>¬(x &lt; y)</code>.  </p>\n</li>\n<li>\n<p>We identify all (directed) cycles in the <code>≤</code>-graph. All variables within such a cycle must be equal, so we perform compression as before. After this step, we can assume that the <code>≤</code>-graph is acyclic.  </p>\n</li>\n<li>For each fact of the form <code>¬(x &lt; y)</code>, we check whether <code>y</code> is reachable from <code>x</code> in the <code>≤</code>-graph. If it is, then <code>x ≤ y</code>, which implies <code>x = y</code>, allowing us to compress the graph further.  </li>\n</ol>\n<p>At each step, we replace our set of facts with an equisatisfiable one. If no contradiction is found by the end, then there exists a model satisfying the final set of facts: one can use the set of variables with <code>x R y</code> holds iff <code>y</code> is reachable from <code>x</code> in the <code>≤</code>-graph. In this case, it is impossible to derive a contradiction from the theory of partial orders.</p>",
        "id": 499415917,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739437596
    },
    {
        "content": "<p>In your example, after negation, we would have <code>a ≤ b ≤ c ≤ d ≤ e</code>, <code>b ≠ d</code>, and <code>a = e</code>. After step 5, <code>a</code> and <code>e</code> would be compressed into a single variable, say <code>s</code>. Then, in step 6, we would detect the cycle <code>s ≤ b ≤ c ≤ d ≤ s</code>, and compressing it would lead to a contradiction with <code>b ≠ d</code>.</p>",
        "id": 499419660,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739438469
    },
    {
        "content": "<p>Nice, I can see this working! Indeed the reason I shared that example is that we'd also come up with the \"do search in the directed graph on <code>≤</code>\" approach, but I didn't get time to think about how to make this example work (ie I just had a preorder tactic), I'm glad to hear it helped you figure out your algorithm!</p>",
        "id": 499426102,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739440099
    },
    {
        "content": "<p>Here is the PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/21877\">#21877</a>.</p>",
        "id": 499769123,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739546774
    },
    {
        "content": "<p>While coding I simplified the algorithm and also added a <code>Preorder</code> version.</p>",
        "id": 499770033,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739547010
    },
    {
        "content": "<p>feature request:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">order</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h3</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Allow the user to supply inequalities.</p>",
        "id": 499779044,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1739549593
    },
    {
        "content": "<p>Second feature request (which can and maybe should be a secondary PR to make this one easier to review): a preprocessing step which runs the lemmas that Peter mentions first, and then does <code>order</code>. I don't think this will be complete for lattices, but it could be convenient nonetheless (similar to how linarith is complete for linear arithmetic and nlinarith is not complete for nonlinear arithmetic, but it's still sometimes pretty useful!)</p>",
        "id": 499845345,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739573333
    },
    {
        "content": "<p>Yes, I plan to do this in the next PR.</p>",
        "id": 499845546,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739573414
    },
    {
        "content": "<p>I extended the tactic to <code>Lattice</code> (<a href=\"https://github.com/leanprover-community/mathlib4/pull/21966\">#21966</a>), and it seems to be complete for them as well. I wonder if it would be useful to make it complete for <code>DistribLattice</code>. In any case, it seems to be an interesting and nontrivial task (maybe I should use the M3-N5 theorem somehow).</p>\n<p>Btw, the cases of <code>HeytingAlgebra</code> and <code>BooleanAlgebra</code> can be handled by reducing them to intuitionistic or classical logic and then calling <code>itauto</code> or <code>tauto</code> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> .</p>",
        "id": 500170799,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739795049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"552388\">Vasily Nesterov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/500170799\">said</a>:</p>\n<blockquote>\n<p>Btw, the cases of <code>HeytingAlgebra</code> and <code>BooleanAlgebra</code> can be handled by reducing them to intuitionistic or classical logic and then calling <code>itauto</code> or <code>tauto</code> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> .</p>\n</blockquote>\n<p>This was one of the motivations for getting the theory of Heyting algebras off the ground: to get to write a cool tactic <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 500171319,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1739795182
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"552388\">Vasilii Nesterov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/500170799\">said</a>:</p>\n<blockquote>\n<p>I extended the tactic to <code>Lattice</code> (<a href=\"https://github.com/leanprover-community/mathlib4/pull/21966\">#21966</a>), and it seems to be complete for them as well.</p>\n</blockquote>\n<p>I just discovered a simple example showing that it isn't complete for <code>LinearOrder</code> at least:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">habc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">min</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hcba</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">min</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">order</span><span class=\"w\"> </span><span class=\"c1\">-- No contradiction found</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">le_antisymm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">habc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"bp\">.</span><span class=\"n\">not_le</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">hcba</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The issue seems to be that <code>order</code> doesn't know about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=inf_le_iff#doc\">docs#inf_le_iff</a></p>",
        "id": 515897754,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1746277543
    },
    {
        "content": "<p>How I came across this example: This is showing that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(a) = v(a + b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span> if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>&lt;</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(a) &lt; v(b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> is a valuation</p>",
        "id": 515897951,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1746277613
    },
    {
        "content": "<p>this doesn't mean that it's not complete for <code>Lattice</code>, right?</p>",
        "id": 515899842,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1746278306
    },
    {
        "content": "<p>(just checking my understanding)</p>",
        "id": 515899903,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1746278331
    },
    {
        "content": "<p>Should the plan be to make the tactic complete for <code>LinearOrder</code>, by doing some form of case splitting, like in <code>omega</code>? Or just to let the tactic use the lemma <code>min a b &lt; b → a &lt; b</code> whenever it already knows <code>min a b &lt; b</code>?</p>",
        "id": 515904689,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1746280625
    },
    {
        "content": "<p>Yes, this tactic is complete for both <code>LinearOrder</code> without lattice operations and for <code>Lattice</code> without assuming linearity. </p>\n<p>It seems the problem for linear orders with lattice operations is NP-hard. We can model 3SAT problem like this: add a hypothesis <code>f &lt; t</code>, for each variable <code>x</code> require <code>x₀ ⊓ x₁ ≤ f</code> and <code>x₀ ⊔ x₁ ≥ t</code> and then for a clause <code>x ∨ ¬ y ∨ z</code> require <code>x₁ ⊔ y₀ ⊔ z₁ ≥ t</code>.</p>",
        "id": 515905460,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746281059
    },
    {
        "content": "<p>I'd like to solve the case of linear orders by translating the problem from an arbitrary type to <code>Nat</code>, and then running <code>omega</code>. This would save us from having to reimplement all the heuristics needed to make the procedure efficient. I wonder how hard it is to use such an approach.</p>",
        "id": 515905900,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746281289
    },
    {
        "content": "<p>That is a good idea. Although it's probably worth waiting until <code>grind</code> is ready, and then using it instead of <code>omega</code>.</p>",
        "id": 515906230,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1746281495
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"552388\">Vasilii Nesterov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515905900\">said</a>:</p>\n<blockquote>\n<p>solve the case of linear orders by translating the problem from an arbitrary type to <code>Nat</code>, and then running <code>omega</code></p>\n</blockquote>\n<p>That's a very interesting idea. How would it work, mathematically? It feels like you're claiming something model-theoretic about linear orders and <code>ℕ</code>. Something like <code>ℕ</code> is a \"generic\" model of the quantifier-free theory of linear orders? If so, is your idea to turn a proof of this fact into an effective algorithm?</p>",
        "id": 515907600,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1746282227
    },
    {
        "content": "<p>One way it could be done (I'm not sure if there is any other way) is to use the same ideas as in <code>to_additive</code> (or <code>to_dual</code>). We could make a tag <code>to_linear</code>, which turns all relevant statements about <code>ℕ</code> or <code>ℤ</code> into the equivalent statements about an arbitrary linear order <code>α</code>. Then using the <code>to_linear</code> machinery, we can transform the obtained proof about <code>ℕ</code> or <code>ℤ</code> into a proof about the given linear order.</p>\n<p>Or we can hope that <code>grind</code> will work directly on a <code>LinearOrder</code>.</p>",
        "id": 515909691,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1746283228
    },
    {
        "content": "<p>Okay, but for example <code>m + 1 ≤ n ↔ m &lt; n</code> has no analogue in an arbitrary linear order, so not all(/very few) proofs generated by <code>omega</code>/<code>grind</code> will translate to a general linear order</p>",
        "id": 515909932,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1746283345
    },
    {
        "content": "<p>You need some kind of encoding of the variables in your problem and their min/max as natural numbers</p>",
        "id": 515909991,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1746283380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515907600\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"552388\">Vasilii Nesterov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515905900\">said</a>:</p>\n<blockquote>\n<p>solve the case of linear orders by translating the problem from an arbitrary type to <code>Nat</code>, and then running <code>omega</code></p>\n</blockquote>\n<p>That's a very interesting idea. How would it work, mathematically? It feels like you're claiming something model-theoretic about linear orders and <code>ℕ</code>. Something like <code>ℕ</code> is a \"generic\" model of the quantifier-free theory of linear orders? If so, is your idea to turn a proof of this fact into an effective algorithm?</p>\n</blockquote>\n<p>i think the idea is that any first-order statement in the theory of linear orders is true iff there are no counterexamples, which are finite, so must have an equivalent in the natural numbers. As a result, it suffices to check that the natural numbers don't contain a counterexample?</p>",
        "id": 515910484,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1746283652
    },
    {
        "content": "<p>although you might need the integers instead</p>",
        "id": 515910849,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1746283836
    },
    {
        "content": "<p>because of statements like <code>(∀ a, ∃ b, b &lt; a) → False</code></p>",
        "id": 515910944,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1746283897
    },
    {
        "content": "<p>I thought we were working quantifier-free?</p>",
        "id": 515910979,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746283918
    },
    {
        "content": "<p>ah right, that's fair</p>",
        "id": 515911035,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1746283926
    },
    {
        "content": "<p>model theory was some time ago</p>",
        "id": 515911059,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1746283937
    },
    {
        "content": "<p>in that case indeed Nat is sufficient</p>",
        "id": 515911158,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1746283999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515910484\">said</a>:</p>\n<blockquote>\n<p>i think the idea is that any first-order statement in the theory of linear orders is true iff there are no counterexamples, which are finite, so must have an equivalent in the natural numbers. As a result, it suffices to check that the natural numbers don't contain a counterexample?</p>\n</blockquote>\n<p>That is indeed the idea, but I am not sure how to prove \"effectively\".</p>",
        "id": 515911889,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1746284386
    },
    {
        "content": "<p>Does Mathlib have some sort of model theory? I think it should be possible to</p>\n<ul>\n<li>define the language of lattices</li>\n<li>define the evaluation of statements in this language inside a given order</li>\n<li>define what a model is</li>\n<li>prove that a model in an arbitrary <code>LinearOrder</code> gives a model in <code>Nat</code>.</li>\n</ul>\n<p>Then we use <code>grind</code>/<code>omega</code> to prove that there is no model in <code>Nat</code>, so we conclude there is no model in the given <code>LinearOrder</code>.</p>",
        "id": 515912892,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1746284880
    },
    {
        "content": "<p>We have <a href=\"https://tqft.net/mathlib4files/ModelTheory/Order\">file#ModelTheory/Order</a></p>",
        "id": 515913075,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746284962
    },
    {
        "content": "<p>The model-theoretic language is useful, but I doubt we actually need to prove the model-theoretic statement to implement the tactic. The model theoretic statement is more like a metatheorem that guides tactic-writing.</p>",
        "id": 515913318,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1746285083
    },
    {
        "content": "<p>I'm not sure how the tactic would prove this without using the model theoretic theorem.</p>",
        "id": 515915896,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1746286405
    },
    {
        "content": "<p>Yes, by translation from an arbitrary type to <code>ℕ</code>, I mean interpreting all order operations (<code>&lt;</code>, <code>≤</code>, <code>⊓</code>, <code>⊔</code>) in terms of natural numbers. Any finite linearly ordered set can be embedded into the natural numbers in a way that preserves the order, so this is mathematically correct: if some linearly ordered set satisfies a set of conditions <code>S</code>, then its \"ℕ-version\" will also satisfy <code>S</code>. Conversely, if <code>S</code> can be satisfied in <code>ℕ</code>, then it is impossible to derive a contradiction from <code>S</code> using only order axioms.</p>\n<p>On the implementation side, I had the following idea. We need a lemma stating that for any \"valuation\" in our type <code>α</code>, we can map <code>α</code> to <code>ℕ</code> in a way that preserves the order on the image of this valuation, like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">exists_translation</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"c1\">-- maybe more conditions?</span>\n<span class=\"w\">    </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Then we take some <code>val</code> such that <code>val 0</code>, <code>val 1</code>, ... is equal to variables in the context. And using such an <code>f</code>, we can rewrite all hypotheses in the context and run <code>omega</code>.</p>",
        "id": 515917063,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746287071
    },
    {
        "content": "<p>You should have <code>val : Fin n → α</code> since this version is not provable.</p>",
        "id": 515917879,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746287541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515909932\">said</a>:</p>\n<blockquote>\n<p>Okay, but for example <code>m + 1 ≤ n ↔ m &lt; n</code> has no analogue in an arbitrary linear order, so not all(/very few) proofs generated by <code>omega</code>/<code>grind</code> will translate to a general linear order</p>\n</blockquote>\n<p>This is true, but this involves arithmetic. For theories with arithmetic Nat is not a \"universal\" (I don't remember the right model-theoretic term) model, but it's sufficient for the order theory. Maybe we should use something else and preserve some arithmetic as well.</p>",
        "id": 515917993,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746287618
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515917879\">said</a>:</p>\n<blockquote>\n<p>You should have <code>val : Fin n → α</code> since this version is not provable.</p>\n</blockquote>\n<p>Yes, indeed. <code>val 0 &gt; val 1 &gt; val 2 &gt; ...</code> is a counterexample. Maybe we can just use <code>ℤ</code> intead of <code>ℕ</code> here? <code>Fin n</code> is enough though</p>\n<p>Edit: no, <code>ℤ</code> doesn't work, <code>val 0 &gt; val 1 &gt; val 2 &gt; ... &gt; 0</code> is a counterexample :)</p>",
        "id": 515918315,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746287802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515915896\">said</a>:</p>\n<blockquote>\n<p>I'm not sure how the tactic would prove this without using the model theoretic theorem.</p>\n</blockquote>\n<p>My hope is that the model-theoretic theorem has an effective proof, and that this proof <em>is</em> the algorithm the tactic should follow.</p>",
        "id": 515918433,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1746287882
    },
    {
        "content": "<p>I think the proof of the model-theoretic theorem uses case-splits. So if you were to replay this proof in the tactic, you would be doing too much work (and probably not need to call <code>grind</code>/<code>omega</code> anymore)</p>",
        "id": 515918706,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1746288005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515918433\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515915896\">said</a>:</p>\n<blockquote>\n<p>I'm not sure how the tactic would prove this without using the model theoretic theorem.</p>\n</blockquote>\n<p>My hope is that the model-theoretic theorem has an effective proof, and that this proof <em>is</em> the algorithm the tactic should follow.</p>\n</blockquote>\n<p>I think all you get is a reduction from finite subsets of <code>α</code> to <code>ℕ</code>, not sure how you would extract an algorithm from that.</p>",
        "id": 515918978,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746288128
    },
    {
        "content": "<p>The <code>exists_translation</code> theorem (with <code>val : Fin n → α</code>) captures the essence of the model theoretic statement. The question is whether we want/need to use the model theory to prove it.</p>",
        "id": 515919108,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1746288215
    },
    {
        "content": "<p>Why would we need model theory? We can just induct on <code>n</code>.</p>",
        "id": 515919194,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746288249
    },
    {
        "content": "<p>At some point I wrote a way to construct efficient <code>Expr</code>s of type <code>ℕ → α</code> (or <code>Fin n → α</code>), using a binary tree. This can be used to construct the <code>val</code>:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>import Qq\n\nuniverse u\n\ninductive BinTree (α : Type u) where\n| leaf : α → BinTree α\n| node : Nat → BinTree α → BinTree α → BinTree α\n\nnamespace BinTree\n\nvariable {α : Type u}\n\ndef get (tree : BinTree α) (n : Nat) : α :=\n  match tree with\n  | leaf a =&gt; a\n  | node m l r =&gt; if n &lt; m then l.get n else r.get n\n\nopen Lean Qq\n\ndef mkExpr {u : Level} {α : Q(Type $u)} (atoms : Array Q($α)) : Q(BinTree $α) :=\n  if _ : atoms.size = 0 then\n    panic! &quot;empty array&quot;\n  else\n    go 0 atoms.size\nwhere\n  go (lo hi : Nat) (h_lo : lo &lt; hi := by omega) (h_hi : hi ≤ atoms.size := by omega) : Q(BinTree $α) :=\n    let mid := (lo + hi)/2\n    if h : lo = mid then\n      q(leaf $(atoms[lo]))\n    else\n      let l := go lo mid\n      let r := go mid hi\n      let n : Q(Nat) := mkNatLit mid\n      q(node $n $l $r)\n  termination_by hi - lo\n\ndef mkFun {u : Level} {α : Q(Type $u)} (atoms : Array Q($α)) : Q(Nat → $α) :=\n  let tree := BinTree.mkExpr atoms\n  q(($tree).get)\n</code></pre></div>\n</div></div>",
        "id": 515920153,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1746288766
    },
    {
        "content": "<p>I've got a working proof of <code>exists_translation</code>, with some nice properties.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Here it is</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">translation</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">translation_le_translation</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">translation</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">translation</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_univ</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_univ</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">  </span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"n\">hj</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">strongInduction</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hms</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"bp\">.</span><span class=\"n\">exists_maximal_wrt</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">finite_toSet</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"bp\">.</span><span class=\"n\">to_set</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_coe</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hms</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">ht</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">⊂</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">ssubset_def</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">constructor</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">filter_subset</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">hst</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">lt_irrefl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_filter</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hst</span><span class=\"w\"> </span><span class=\"n\">hms</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">right</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hmm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">le_total</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">hk</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">him</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">him</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">lt_or_eq_of_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hmm</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">hjm</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hjm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">lt_or_eq_of_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hmm</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">hj</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">ht</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_filter</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">hi</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">him</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_filter</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">hj</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hjm</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hjm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iff_true_right</span><span class=\"w\"> </span><span class=\"n\">him</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">card_le_card</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">image_subset_image</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">monotone_filter_right</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">hu</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hjm</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hu</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">him</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">him</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iff_false_right</span><span class=\"w\"> </span><span class=\"n\">hjm</span><span class=\"bp\">.</span><span class=\"n\">not_le</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_le</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">card_lt_card</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">him</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">ssubset_def</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">constructor</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">image_subset_image</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">monotone_filter_right</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">hu</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hu</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">hjm</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">hii</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hjj</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">        </span><span class=\"n\">hii</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_image</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_filter</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_univ</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hjm</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_image</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hjj</span>\n<span class=\"w\">      </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hk</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hkj</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hjj</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">mem_filter</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hk</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hkj</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hk</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hk</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"bp\">.</span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">him</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hjm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iff_true_right</span><span class=\"w\"> </span><span class=\"n\">le_rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">translation</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">him</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">translation</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hjm</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">translation_lt_translation</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">translation</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">translation</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">translation_le_translation</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">not</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">translation_eq_translation</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">translation</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">translation</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_antisymm_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">translation_le_translation</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">implies_true</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">translation_injective</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">inj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">translation</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">hij</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">translation_eq_translation</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hij</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">inj</span><span class=\"w\"> </span><span class=\"n\">hij</span>\n</code></pre></div>\n</div></div>",
        "id": 515931747,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746294220
    },
    {
        "content": "<p>Very nice! Would you like to write a tactic that uses this? I'd like to do this too, but I'm not that fast :)</p>",
        "id": 515932350,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746294577
    },
    {
        "content": "<p>What's the spec of this tactic? Gather up all the linear order hypotheses and convert them into <code>ℕ</code>?</p>",
        "id": 515932526,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746294682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515910484\">said</a>:</p>\n<blockquote>\n<p>i think the idea is that any first-order statement in the theory of linear orders is true iff there are no counterexamples, which are finite, so must have an equivalent in the natural numbers. As a result, it suffices to check that the natural numbers don't contain a counterexample?</p>\n</blockquote>\n<p>[probably my fault for not realizing this discussion was in the pure QF context]<br>\n<del>A counterexample doesn't necessarily have a finite model. For example, the sentence \"there is a least element and a greatest element\" has no counterexamples in finite linear orders, but the rationals are a counterexample.</del></p>\n<p>It will probably be much simpler to make a decision procedure for <em>dense</em> linear orders (whose theory has quantifier elimination, with a fairly elementary proof) or the quantifier-free theory of linear orders. The decidability of the theory of all linear orders is usually established by more sophisticated techniques. In practice, I suspect that any decision procedure would need to generate explicit proof terms (possibly using small pockets of proof-by-reflection to compress the proofs) rather than using Mathlib's development of model theory to prove a decision procedure correct outright, because even if the proof effort succeeded, the resulting procedure would run too slowly in Lean's kernel to be useful.</p>",
        "id": 515932558,
        "sender_full_name": "Cameron Zwarich",
        "timestamp": 1746294714
    },
    {
        "content": "<p>I think we were focusing on the quantifier-free case</p>",
        "id": 515932647,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746294754
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515932526\">said</a>:</p>\n<blockquote>\n<p>What's the spec of this tactic? Gather up all the linear order hypotheses and convert them into <code>ℕ</code>?</p>\n</blockquote>\n<p>Yes, I meant this</p>",
        "id": 515932654,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746294759
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"656225\">Cameron Zwarich</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515932558\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515910484\">said</a>:</p>\n<blockquote>\n<p>i think the idea is that any first-order statement in the theory of linear orders is true iff there are no counterexamples, which are finite, so must have an equivalent in the natural numbers. As a result, it suffices to check that the natural numbers don't contain a counterexample?</p>\n</blockquote>\n<p>A counterexample doesn't necessarily have a finite model. For example, the sentence \"there is a least element and a greatest element\" has no counterexamples in finite linear orders, but the rationals are a counterexample.</p>\n<p>It will probably be much simpler to make a decision procedure for <em>dense</em> linear orders (whose theory has quantifier elimination, with a fairly elementary proof) or the quantifier-free theory of linear orders. The decidability of the theory of all linear orders is usually established by more sophisticated techniques. In practice, I suspect that any decision procedure would need to generate explicit proof terms (possibly using small pockets of proof-by-reflection to compress the proofs) rather than using Mathlib's development of model theory to prove a decision procedure correct outright, because even if the proof effort succeeded, the resulting procedure would run too slowly in Lean's kernel to be useful.</p>\n</blockquote>\n<p>I’ve thought about dense linear orders as well. The problem is that quantifier elimination doesn’t seem very useful in practice and also leads to exponential blow-up.</p>",
        "id": 515932913,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746294933
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515932526\">said</a>:</p>\n<blockquote>\n<p>What's the spec of this tactic? Gather up all the linear order hypotheses and convert them into <code>ℕ</code>?</p>\n</blockquote>\n<p>Perhaps it should use <code>order</code> internals to collect variables and facts about them from the context.</p>",
        "id": 515933284,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746295154
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"552388\">Vasilii Nesterov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515932654\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515932526\">said</a>:</p>\n<blockquote>\n<p>What's the spec of this tactic? Gather up all the linear order hypotheses and convert them into <code>ℕ</code>?</p>\n</blockquote>\n<p>Yes, I meant this</p>\n</blockquote>\n<p>what should I call it</p>",
        "id": 515934314,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746295754
    },
    {
        "content": "<p>In fact, I think it should be a part of the <code>order</code> tactic. I suggest starting from <a href=\"https://github.com/leanprover-community/mathlib4/pull/21966\">#21966</a>. You can write a function</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">translateToNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idxToAtom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">facts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">AtomicFact</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">AtomicFact</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>where <code>type</code> is the original type, <code>idxToAtom</code> maps indexes to variables and <code>facts</code> contains facts about these variables extracted from the context. The function returns new <code>(idxToAtom, facts)</code> about <code>Nat</code>s. I believe it's enough to write a lemma for each type of <code>AtomicFact</code> and then just rewrite each fact using the corresponding lemma.</p>",
        "id": 515935878,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746296655
    },
    {
        "content": "<p>I'm not sure what we should do with facts of the form <code>x = ⊤</code>. In the <code>order</code>, I replace such facts with new ones of the form <code>y ≤ x</code> for all atoms <code>y</code>. We can apply the same preprocessing here, so you can assume that there are no facts of this type in <code>translateToNat</code>.</p>",
        "id": 515937018,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746297280
    },
    {
        "content": "<p>Are all the variables of the same type?</p>",
        "id": 515939298,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746298598
    },
    {
        "content": "<p>Yes</p>",
        "id": 515939334,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746298630
    },
    {
        "content": "<p>Do I just push to <a href=\"https://github.com/leanprover-community/mathlib4/tree/vasnesterov%2Forder_tactic_lattices\">branch#vasnesterov/order_tactic_lattices</a></p>",
        "id": 515939701,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746298849
    },
    {
        "content": "<p>or a new branch</p>",
        "id": 515939711,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746298857
    },
    {
        "content": "<p>New, please</p>",
        "id": 515939742,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746298873
    },
    {
        "content": "<p>I hope this one will be reviewed and merged soon (it's quite old already)</p>",
        "id": 515939767,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746298895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"552388\">Vasilii Nesterov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515932913\">said</a>:</p>\n<blockquote>\n<p>I’ve thought about dense linear orders as well. The problem is that quantifier elimination doesn’t seem very useful in practice and also leads to exponential blow-up.</p>\n</blockquote>\n<p>While in general the DEXPTIME nature of most QE procedures seems limiting, I have a suspicion (which might be a misconception on my part) that they could be made practical for Mathlib-sized problems. Maybe I should do some experiments and see how efficient I can make it. If it’s going to work out anywhere, it will be DLO.</p>",
        "id": 515939780,
        "sender_full_name": "Cameron Zwarich",
        "timestamp": 1746298906
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"552388\">Vasilii Nesterov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515935878\">said</a>:</p>\n<blockquote>\n<p>In fact, I think it should be a part of the <code>order</code> tactic. I suggest starting from <a href=\"https://github.com/leanprover-community/mathlib4/pull/21966\">#21966</a>. You can write a function</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">translateToNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idxToAtom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">facts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">AtomicFact</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">AtomicFact</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>where <code>type</code> is the original type, <code>idxToAtom</code> maps indexes to variables and <code>facts</code> contains facts about these variables extracted from the context. The function returns new <code>(idxToAtom, facts)</code> about <code>Nat</code>s. I believe it's enough to write a lemma for each type of <code>AtomicFact</code> and then just rewrite each fact using the corresponding lemma.</p>\n</blockquote>\n<p>What do I do with facts of type <code>.isSup</code> and <code>.isInf</code>?</p>",
        "id": 515942250,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746300405
    },
    {
        "content": "<p>I guess, rewrite with something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">translation_inf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">translation</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">translation</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">translation</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 515942449,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746300508
    },
    {
        "content": "<p>But they don't carry around a proof</p>",
        "id": 515942509,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746300546
    },
    {
        "content": "<p>I could modify them to carry around a proof, but then I don't know what would break, and it might take a few hours to debug.</p>",
        "id": 515942694,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746300639
    },
    {
        "content": "<p>Yes, for <code>isSup</code> and <code>isInf</code> the proof is always <code>rfl</code></p>",
        "id": 515942803,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746300722
    },
    {
        "content": "<p>But for the translation the proof isn't <code>rfl</code> anymore so it gets complicated</p>",
        "id": 515942876,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746300751
    },
    {
        "content": "<p>or, I could try to special-case them but then I would need to do something different on the <code>&lt;</code> and <code>≤</code></p>",
        "id": 515942932,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746300800
    },
    {
        "content": "<p>I could also just double all the sup and inf and add a lot of <code>.eq</code></p>",
        "id": 515943041,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746300856
    },
    {
        "content": "<p>Yes, I think <code>isSup i j k</code> which states <code>xk := xi ⊔ xj</code> should become <code>aux := ni ⊔ nj</code> plus a new fact <code>nk = aux</code></p>",
        "id": 515955690,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746308402
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"552388\">Vasilii Nesterov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/515955690\">said</a>:</p>\n<blockquote>\n<p>Yes, I think <code>isSup i j k</code> which states <code>xk := xi ⊔ xj</code> should become <code>aux := ni ⊔ nj</code> plus a new fact <code>nk = aux</code></p>\n</blockquote>\n<p>How do I generate a new index for <code>aux</code>?</p>",
        "id": 515967391,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746316434
    },
    {
        "content": "<p>At first you can map existing variables, like <code>idxToAtomNew[i] = translation val i</code> (<code>q($translation $val $i)</code> using Qq). Then when you face a fact <code>.isSup i j k</code> you add a new atom <code>idxToAtomNew[newIdx] = translation val i ⊔ translation val j</code> (where <code>newIdx = idxToAtomNew.size</code>) and two facts: <code>.isSup i j newIdx</code> and <code>.eq k newIdx</code>. For the latter you need to prove exactly that <code>translation val k = translation val i ⊔ translation val j</code>, and here you use your lemma. Does this work?</p>",
        "id": 516005609,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1746346130
    },
    {
        "content": "<p>I have this function <code>translateToNat</code>, now what do I do with it?</p>",
        "id": 516331187,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746497189
    },
    {
        "content": "<p>I'm also not entirely sure that it works correctly</p>",
        "id": 516331710,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746497511
    }
]