[
    {
        "content": "<p>Would it be useful to have a tactic in Mathlib that can solve goals in partial order theory? It is easy to implement, and I'd like to create one to practice metaprogramming.</p>",
        "id": 499185617,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739352876
    },
    {
        "content": "<p>What goals would this tactic solve?</p>",
        "id": 499194080,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739355346
    },
    {
        "content": "<p>Those that can be closed by applying reflexivity, transitivity, or antisymmetry to local hypotheses and the goal. It would also use the linearity of the order when applicable.</p>\n<p>In both cases (partial order and linear order), the quantifier-free theory is decidable in linear time.</p>",
        "id": 499197257,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739356226
    },
    {
        "content": "<p>Is it <a href=\"#narrow/channel/287929-mathlib4/topic/lattice.20tactics/near/453896967\">this</a> ?</p>",
        "id": 499221493,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739363868
    },
    {
        "content": "<p>Hmm, I'm not sure if an <code>aesop</code>-based approach is the best here because it <em>searches</em> for the proof using tree search by guessing proof steps, whereas in this case, it can be done without guessing.</p>\n<p>By the way, it's easy to add support for lattices in the tactic I have in mind.</p>",
        "id": 499229153,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739365999
    },
    {
        "content": "<p>Heather and I have discussed this a bit - I agree this would be nice to have. For the tactic you have in mind, would it be able to prove that a &lt;= b &lt;= c &lt;= d &lt;= e and b != d implies a != e in a partial order?</p>",
        "id": 499274798,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739377163
    },
    {
        "content": "<p>It would be nice to have something work for lattices, as well, even if it is just as simple as adding all the trivial inequalities that come from <code>le_sup_iff</code>,  <code>sup_le_iff</code>, <code>le_sup_left</code>, <code>le_sup_right</code> and similar for <code>inf</code>.</p>",
        "id": 499357878,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1739408789
    },
    {
        "content": "<p>(The thread that Kevin links to does this, but I think Vasily's idea would perform better than the aesop approach. It might work to just preprocess like nlinarith does to add all those inequalities, then running the partial/linear order version)</p>",
        "id": 499358310,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739409044
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/499274798\">said</a>:</p>\n<blockquote>\n<p>Heather and I have discussed this a bit - I agree this would be nice to have. For the tactic you have in mind, would it be able to prove that a &lt;= b &lt;= c &lt;= d &lt;= e and b != d implies a != e in a partial order?</p>\n</blockquote>\n<p>Thank you for this example! Everything turned out to be more complicated than I initially thought. Anyway, it seems that the problem can be solved in quadratic time (not linear as I promised).</p>\n<p>Let me describe my algorithm for partial orders. </p>\n<ol>\n<li>First, we negate the goal, so our new goal is to prove <code>False</code>.  </li>\n<li>We collect all facts in the form of <code>x = y</code>, <code>x ≤ y</code>, <code>x &lt; y</code>, <code>x ≠ y</code>, <code>¬(x ≤ y)</code>, and <code>¬(x &lt; y)</code> from the context. Here, we split conjunctions. Splitting disjunctions would result in exponential blow-up, and I guess we can't do anything smart about it here. However, there should be an option to enable this splitting if needed.</li>\n<li>We replace each fact of the form <code>x &lt; y</code> with two equivalent facts: <code>x ≤ y</code> and <code>x ≠ y</code>.  </li>\n<li>We replace each fact of the form <code>¬(x ≤ y)</code> with two equivalent facts: <code>¬(x &lt; y)</code> and <code>x ≠ y</code>.  </li>\n<li>\n<p>We define the <code>≤</code>-graph as a directed graph whose vertices are variables and whose edges correspond to facts of the form <code>x ≤ y</code>. Similarly, we define (undirected) <code>=</code>-graph.<br>\nWe then find all connected components in <code>=</code>-graph. Variables within the same component are be provably equal. Thus, we can \"compress\" them into a single vertex. During this process, we check that no fact of the form <code>x ≠ y</code> leads to a contradiction — otherwise, we have found a contradiction, and the goal is accomplished. After this step, we may assume that the remaining facts are in one of three forms: <code>x ≤ y</code>, <code>x ≠ y</code>, and <code>¬(x &lt; y)</code>.  </p>\n</li>\n<li>\n<p>We identify all (directed) cycles in the <code>≤</code>-graph. All variables within such a cycle must be equal, so we perform compression as before. After this step, we can assume that the <code>≤</code>-graph is acyclic.  </p>\n</li>\n<li>For each fact of the form <code>¬(x &lt; y)</code>, we check whether <code>y</code> is reachable from <code>x</code> in the <code>≤</code>-graph. If it is, then <code>x ≤ y</code>, which implies <code>x = y</code>, allowing us to compress the graph further.  </li>\n</ol>\n<p>At each step, we replace our set of facts with an equisatisfiable one. If no contradiction is found by the end, then there exists a model satisfying the final set of facts: one can use the set of variables with <code>x R y</code> holds iff <code>y</code> is reachable from <code>x</code> in the <code>≤</code>-graph. In this case, it is impossible to derive a contradiction from the theory of partial orders.</p>",
        "id": 499415917,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739437596
    },
    {
        "content": "<p>In your example, after negation, we would have <code>a ≤ b ≤ c ≤ d ≤ e</code>, <code>b ≠ d</code>, and <code>a = e</code>. After step 5, <code>a</code> and <code>e</code> would be compressed into a single variable, say <code>s</code>. Then, in step 6, we would detect the cycle <code>s ≤ b ≤ c ≤ d ≤ s</code>, and compressing it would lead to a contradiction with <code>b ≠ d</code>.</p>",
        "id": 499419660,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739438469
    },
    {
        "content": "<p>Nice, I can see this working! Indeed the reason I shared that example is that we'd also come up with the \"do search in the directed graph on <code>≤</code>\" approach, but I didn't get time to think about how to make this example work (ie I just had a preorder tactic), I'm glad to hear it helped you figure out your algorithm!</p>",
        "id": 499426102,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739440099
    },
    {
        "content": "<p>Here is the PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/21877\">#21877</a>.</p>",
        "id": 499769123,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739546774
    },
    {
        "content": "<p>While coding I simplified the algorithm and also added a <code>Preorder</code> version.</p>",
        "id": 499770033,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739547010
    },
    {
        "content": "<p>feature request:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">order</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h3</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Allow the user to supply inequalities.</p>",
        "id": 499779044,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1739549593
    },
    {
        "content": "<p>Second feature request (which can and maybe should be a secondary PR to make this one easier to review): a preprocessing step which runs the lemmas that Peter mentions first, and then does <code>order</code>. I don't think this will be complete for lattices, but it could be convenient nonetheless (similar to how linarith is complete for linear arithmetic and nlinarith is not complete for nonlinear arithmetic, but it's still sometimes pretty useful!)</p>",
        "id": 499845345,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739573333
    },
    {
        "content": "<p>Yes, I plan to do this in the next PR.</p>",
        "id": 499845546,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739573414
    },
    {
        "content": "<p>I extended the tactic to <code>Lattice</code> (<a href=\"https://github.com/leanprover-community/mathlib4/pull/21966\">#21966</a>), and it seems to be complete for them as well. I wonder if it would be useful to make it complete for <code>DistribLattice</code>. In any case, it seems to be an interesting and nontrivial task (maybe I should use the M3-N5 theorem somehow).</p>\n<p>Btw, the cases of <code>HeytingAlgebra</code> and <code>BooleanAlgebra</code> can be handled by reducing them to intuitionistic or classical logic and then calling <code>itauto</code> or <code>tauto</code> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> .</p>",
        "id": 500170799,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1739795049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"552388\">Vasily Nesterov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/tactic.20for.20partial.20orders/near/500170799\">said</a>:</p>\n<blockquote>\n<p>Btw, the cases of <code>HeytingAlgebra</code> and <code>BooleanAlgebra</code> can be handled by reducing them to intuitionistic or classical logic and then calling <code>itauto</code> or <code>tauto</code> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> .</p>\n</blockquote>\n<p>This was one of the motivations for getting the theory of Heyting algebras off the ground: to get to write a cool tactic <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 500171319,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1739795182
    }
]