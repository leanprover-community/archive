[
    {
        "content": "<p>Consider the situation where we have a function being applied to a constructor (think Polynomial.eval and X).</p>\n<p>The functions can have several forms depending on the generalisation (e.g. a plain function, a linear map, a ring map; and also specialisation e.g. <code>Localization</code> vs. <code>Localization.Away</code> vs. <code>Localization.AtPrime</code>).</p>\n<p>The constructors can also have several forms.</p>\n<p>Given that these are all valid simpNFs, that means that if we have <code>m</code> forms of the function and <code>n</code> forms of the constructor, then we would need <code>m * n</code> simp lemmas.</p>",
        "id": 544140147,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760093679
    },
    {
        "content": "<p>Is there any way to make this scaling easier?</p>",
        "id": 544140217,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760093698
    },
    {
        "content": "<p>90% of the time we can assume that the constructor and the function are in the same level of generalisation, which makes it linear, but that makes it harder 10% of the time where for some reason they have to be different</p>",
        "id": 544140444,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760093772
    },
    {
        "content": "<p>We simplify applications of bundled versions of functions to the unbundled versions.</p>",
        "id": 544151684,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1760097513
    },
    {
        "content": "<p>See, e.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Polynomial/Eval/Defs.html#Polynomial.coe_evalRingHom\">Polynomial.coe_evalRingHom</a></p>",
        "id": 544151837,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1760097557
    },
    {
        "content": "<p>hmm i thought we didn't do that for some reason but i can't remember what the reason was so maybe you're right</p>",
        "id": 544152067,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760097623
    },
    {
        "content": "<p>yep I think I'm convinced that this is right, with the caveat that we still want a different constructor for a different type (e.g. Localization.Away is an abbrev for Localization but it should have its own constructor); now it's not clear whether we want a simp lemma for e.g. <code>map (Away.mk x s)</code></p>",
        "id": 544161926,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760100560
    },
    {
        "content": "<p>or <code>Away.map (mk x s)</code></p>",
        "id": 544162055,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760100598
    },
    {
        "content": "<p>I think reasonably <code>map</code>, <code>Away.map</code>, <code>mk</code>, and <code>Away.mk</code> should all be simpNF</p>",
        "id": 544162165,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760100624
    },
    {
        "content": "<blockquote>\n<p>We simplify applications of bundled versions of functions to the unbundled versions.</p>\n</blockquote>\n<p>I'm not sure if this is universally true/better. If we were to use <code>evalRingHom</code> as normal form, we would avoid the need of <code>eval_add</code> <code>eval_mul</code> <code>eval_finsetSum</code> <code>eval_pow</code> <code>eval_finsetProd</code> <code>eval_finprodSum</code> <code>eval_zero</code> etc. which might be way more than the <code>n * m</code> lemmas above.</p>",
        "id": 544209959,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1760113967
    },
    {
        "content": "<p>For functions that can be bundled without extra typeclass assumptions, we can just replace the functions with the minimally bundled versions.</p>",
        "id": 544227001,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1760121094
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/544209959\">said</a>:</p>\n<blockquote>\n<p><code>eval_add</code> <code>eval_mul</code> <code>eval_finsetSum</code> <code>eval_pow</code> <code>eval_finsetProd</code> <code>eval_finprodSum</code> <code>eval_zero</code></p>\n</blockquote>\n<p>maybe we can have something like \"RingHomClass\" but instead of the whole type we just register it for one thing?</p>",
        "id": 544229117,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760122082
    },
    {
        "content": "<p>oh maybe that would be impossible to infer...</p>",
        "id": 544229133,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760122092
    },
    {
        "content": "<p>We used to have <code>is_*_hom</code> in Lean 3 and moved to <code>*_hom_class</code> because with these classes, Lean has <code>DFunLike.coe</code> to match lemmas / call inference.</p>",
        "id": 544229477,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1760122269
    },
    {
        "content": "<p>yeah, i just tested that my idea is impossible to infer:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsAddHom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">map_add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">double</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsAddHom</span><span class=\"w\"> </span><span class=\"n\">double</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">double</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">double</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsAddHom</span><span class=\"bp\">.</span><span class=\"n\">map_add</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 544229605,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760122325
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>Invalid rewrite argument: The pattern to be substituted is a metavariable (`?m.12 (?x + ?y)`) in this equality\n  ?m.12 (?x + ?y) = ?m.12 ?x + ?m.12 ?y\n</code></pre></div>",
        "id": 544229648,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760122343
    },
    {
        "content": "<p>but I definitely want a way to avoid having to prove <code>eval_sum</code> for every additive function that I define...</p>",
        "id": 544229757,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760122391
    },
    {
        "content": "<p>what if:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">generate_hom_lemmas</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsAddHom</span><span class=\"w\"> </span><span class=\"n\">eval</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 544229855,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760122429
    },
    {
        "content": "<p>what if I have an attribute <code>generate_hom_lemmas</code> that works like <code>@[simps!]</code> and automatically generates all of the lemmas about add homs?</p>",
        "id": 544229917,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760122454
    },
    {
        "content": "<p>there are a lot of lemmas about addhoms</p>",
        "id": 544230254,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760122599
    },
    {
        "content": "<p>not all of which may be imported at the moment</p>",
        "id": 544230280,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760122614
    },
    {
        "content": "<p>the addhom lemmas can be extended by an attribute, and we will only generate the lemmas that have been imported, (which is already what is happening with functions like <code>eval</code>)</p>",
        "id": 544230407,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760122679
    },
    {
        "content": "<p>e.g. <a href=\"https://github.com/leanprover-community/mathlib4/blob/1ddcdac8c47a2fe3f0f0d813a425e8a9cc951ac1/Mathlib/Algebra/Polynomial/Eval/Defs.lean#L333C9-L333C24\">eval_finset_sum</a> is proved in the same file as the definition of <a href=\"https://github.com/leanprover-community/mathlib4/blob/1ddcdac8c47a2fe3f0f0d813a425e8a9cc951ac1/Mathlib/Algebra/Polynomial/Eval/Defs.lean#L238\">eval</a></p>",
        "id": 544230600,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760122763
    },
    {
        "content": "<p>in my proposal, this lemma would be autogenerated</p>",
        "id": 544230627,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760122775
    },
    {
        "content": "<p>and the lemma exists anyway so it isn't like we're generating more lemmas than needed</p>",
        "id": 544230810,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760122846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> \"multiset_sum\"</p>",
        "id": 544230902,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760122884
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Group/Multiset/Basic.html#map_multiset_sum\">map_multiset_sum</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Group/Multiset/Basic.html#AddMonoidHom.map_multiset_sum\">AddMonoidHom.map_multiset_sum</a>, and <a href=\"https://loogle.lean-lang.org/?q=%22multiset_sum%22\">60 more</a></p>",
        "id": 544230906,
        "sender_full_name": "loogle",
        "timestamp": 1760122885
    },
    {
        "content": "<p>has 62 hits</p>",
        "id": 544230910,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760122887
    },
    {
        "content": "<p>I think that this should be an attribute on <code>evalRingHom</code>. It should specialize some lemmas to whatever <code>DFunLike.coe (evalRingHom ..)</code> simplifies to.</p>",
        "id": 544231163,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1760122994
    },
    {
        "content": "<p>in any case do you think this is a good idea?</p>",
        "id": 544231374,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760123084
    },
    {
        "content": "<p>I think that this is a good idea but I suspect there are some design decisions to make here, and I'm too sleepy to think it through rn.</p>",
        "id": 544231537,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1760123151
    },
    {
        "content": "<p>here's the full proposal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">autoImplicit</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsAddHom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">map_add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">add_lemma</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">IsAddHom</span><span class=\"bp\">.</span><span class=\"n\">multiset_sum</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsAddHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">double</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">generate_lemma</span><span class=\"kd\">]</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsAddHom</span><span class=\"w\"> </span><span class=\"n\">double</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">double</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">double_multiset_sum</span><span class=\"w\"> </span><span class=\"c1\">-- ‚àÄ m : Multiset ‚Ñï, double m.sum = (m.map double).sum</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">(secretly, it does this:)</span>\n<span class=\"cm\">lemma double_multiset_sum : ‚àÄ m : Multiset ‚Ñï, double m.sum = (m.map double).sum :=</span>\n<span class=\"cm\">  IsAddHom.multiset_sum double</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 544232153,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760123441
    },
    {
        "content": "<p>I think even without the tactics, just this one <code>IsAddHom.multiset_sum</code> might already be good</p>",
        "id": 544232284,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760123493
    },
    {
        "content": "<p>like, look at <a href=\"https://github.com/leanprover-community/mathlib4/blob/1ddcdac8c47a2fe3f0f0d813a425e8a9cc951ac1/Mathlib/Data/Rat/BigOperators.lean#L20-L34\">this file</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">norm_cast</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">cast_list_sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">‚Ñö</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üë</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üë</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">map_list_sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Rat</span><span class=\"bp\">.</span><span class=\"n\">castHom</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">norm_cast</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">cast_multiset_sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"n\">‚Ñö</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üë</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üë</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">map_multiset_sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Rat</span><span class=\"bp\">.</span><span class=\"n\">castHom</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">norm_cast</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">cast_sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñö</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">map_sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Rat</span><span class=\"bp\">.</span><span class=\"n\">castHom</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">norm_cast</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">cast_list_prod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">‚Ñö</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üë</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üë</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">map_list_prod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Rat</span><span class=\"bp\">.</span><span class=\"n\">castHom</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>",
        "id": 544232391,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760123537
    },
    {
        "content": "<p>imagine if these 4 lemmas were auto generated</p>",
        "id": 544232404,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760123543
    },
    {
        "content": "<p>I don't like <code>IsAddHom</code></p>",
        "id": 544232529,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760123599
    },
    {
        "content": "<p>I think this allows us to generate those lemmas without first haivng defined the bundled map</p>",
        "id": 544232676,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760123659
    },
    {
        "content": "<p>lest we also get <code>IsAddSubmonoid</code> etc.</p>",
        "id": 544232685,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760123662
    },
    {
        "content": "<p>but it's also possible to i guess start from the bundled lemma and either 1. tell it which unbundled function it should use, or 2. just simp the LHS and make it a simp lemma (oh wait, this wouldn't work because it would simp f 0 to 0)</p>",
        "id": 544232869,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760123746
    },
    {
        "content": "<p>so, proposal 2, the four lemmas above would be autogenerated by:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Coercion `‚Ñö ‚Üí Œ±` as a `RingHom`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">generate_hom_lemmas</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üë</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">castHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñö</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+*</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üë</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">map_one'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cast_one</span>\n<span class=\"w\">  </span><span class=\"n\">map_mul'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cast_mul</span>\n<span class=\"w\">  </span><span class=\"n\">map_zero'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cast_zero</span>\n<span class=\"w\">  </span><span class=\"n\">map_add'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cast_add</span>\n</code></pre></div>",
        "id": 544233068,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760123830
    },
    {
        "content": "<p>If you use <code>@[simps -fullyApplied]</code> on the same <code>def</code>, then it won't simplify <code>myFunHom 0</code> to <code>0</code>, because it will simplify <code>DFunLike.coe myFunHom</code> to <code>myFun</code> first.</p>",
        "id": 544257285,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1760135161
    },
    {
        "content": "<p>(not 100% sure if it will work w/o <code>-fullyApplied</code>)</p>",
        "id": 544257329,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1760135180
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/544227001\">said</a>:</p>\n<blockquote>\n<p>For functions that can be bundled without extra typeclass assumptions, we can just replace the functions with the minimally bundled versions.</p>\n</blockquote>\n<p>let's take a concrete example which is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Polynomial/Module/Basic.html#PolynomialModule.single\">PolynomialModule.single</a>, which I believe should be <code>simp</code>ed to <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Polynomial/Module/Basic.html#PolynomialModule.lsingle\">PolynomialModule.lsingle</a>? As in, should we make <code>lsingle</code> the simpNF?</p>",
        "id": 547066104,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761407126
    },
    {
        "content": "<p>actually maybe we should even delete <code>single</code>?</p>",
        "id": 547066112,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761407141
    },
    {
        "content": "<p>If the function can be bundled under the same assumptions, then we should drop the unbundled version.</p>",
        "id": 547066390,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1761407446
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"486215\">@George McNinch</span> do you want to try this?</p>",
        "id": 547066440,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761407505
    },
    {
        "content": "<p>precise task: delete single and replace it with lsingle (and also make sure the other definitions in the file have API, as we've been discovering that they lack)</p>",
        "id": 547066483,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761407561
    },
    {
        "content": "<p>i mean perhaps in a different PR maybe we should also make PolynomialModule a one-param strcuture just like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial#doc\">docs#Polynomial</a> ?</p>",
        "id": 547066572,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761407666
    },
    {
        "content": "<p>AFAIK, there is a plan to make <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddMonoidAlgebra#doc\">docs#AddMonoidAlgebra</a> a 1-field structure, then turn <code>Polynomial</code> into a <code>def</code>. So, I would change <code>PolynomialModule</code> right now.</p>",
        "id": 547068305,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1761409676
    },
    {
        "content": "<p>i'm not sure i follow, how do the two sentences relate to each other (PolynomialModule is not an algebra), and are you saying you would change the PolynomialModule into a one-param structure or some other def?</p>",
        "id": 547068360,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761409734
    },
    {
        "content": "<p><span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>",
        "id": 547072619,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1761414572
    },
    {
        "content": "<p>I'm not the one turning <code>MonoidAlgebra</code> into a structure. I saw this discussion somewhere on Zulip. I think that it makes sense to coordinate the effort even if the refactor does not apply directly.</p>",
        "id": 547072676,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1761414655
    },
    {
        "content": "<p>when should we have <code>def</code> and when should we have 1-param structs?</p>",
        "id": 547072732,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761414723
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> is working on <a href=\"https://github.com/leanprover-community/mathlib4/pull/25273\">#25273</a> to make <code>MonoidAlgebra</code> into a 1 field structure. The reasoning is that it defined in terms of  <code>M ‚Üí‚ÇÄ R</code>, i.e. <code>Finsupp</code>. We want to have a better separation between these two types, because <code>Finsupp</code> doesn't have any of the algebraic structure that we are putting on <code>MonoidAlgebra</code>.</p>",
        "id": 547072929,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1761414926
    },
    {
        "content": "<p>Both <code>G ‚Üí‚ÇÄ R</code> and <code>R[G}</code> have the same <code>AddCommGroup</code> structure, but as Jovan points out, they have a different <code>Mul</code>: <code>G ‚Üí‚ÇÄ R</code> is pointwise and <code>R[G}</code> is convolution</p>",
        "id": 547074709,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1761416832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/547066390\">said</a>:</p>\n<blockquote>\n<p>If the function can be bundled under the same assumptions, then we should drop the unbundled version.</p>\n</blockquote>\n<p>This isn't the full picture; if a function can be bundled in two different ways for which there is no type bundling both, then I'd argue that rather than picking between the bundlings you should not bundle.</p>",
        "id": 547085338,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1761429959
    },
    {
        "content": "<p>And more tenously, I'd argue that therefore we should avoid bundled definitions in simpNF API as much as possible, as these make the API unstable under availability of new bundlings combined with the rule above.</p>",
        "id": 547085428,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1761430034
    },
    {
        "content": "<p>(another more minor reason to keep bundling out of simpNF API is because <code>foo x</code> is a much smaller term than <code>@DFunLike.coe X Y (@instFunLikeFooHom X Y ...) x</code>)</p>",
        "id": 547085494,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1761430138
    },
    {
        "content": "<p>Then we need a way to specialize <code>map_sum</code> etc lemmas to those unbundled functions.</p>",
        "id": 547085592,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1761430268
    },
    {
        "content": "<p>I think the reality is that we copy the API over</p>",
        "id": 547085684,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1761430403
    },
    {
        "content": "<p>But at least prove it using the bundled version, <code>theorem foo_sum ... := map_sum fooHom ...</code> etc</p>",
        "id": 547085690,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1761430414
    },
    {
        "content": "<p>I meant something like <code>@[homLemmas] def fooHom := ...</code></p>",
        "id": 547086139,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1761431200
    },
    {
        "content": "<p>That can only do so much; lemmas like <code>map_dfinsuppSum</code> likely won't exist at the point the def is created, and I'm not sure how you'd add them latter</p>",
        "id": 547086747,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1761432097
    },
    {
        "content": "<p>Maybe we can register <code>map_</code> as an autogeneration prefix like equation lemmas, such that the lemmas are generated on the fly when used</p>",
        "id": 547086783,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1761432140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/544229917\">said</a>:</p>\n<blockquote>\n<p>what if I have an attribute <code>generate_hom_lemmas</code> that works like <code>@[simps!]</code> and automatically generates all of the lemmas about add homs?</p>\n</blockquote>\n<p>I had a similar but more general idea in another thread, which was that <code>simps</code> could be extended so that custom 'projection' lemmas that aren't actually referencing true projections could be registered<br>\nthis would then also apply to things like (at least attempting to) generate <code>Œπ_comp</code> <code>comp_lift</code> etc lemmas in category theory</p>",
        "id": 547087858,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1761433934
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/547086747\">said</a>:</p>\n<blockquote>\n<p>That can only do so much; lemmas like <code>map_dfinsuppSum</code> likely won't exist at the point the def is created, and I'm not sure how you'd add them latter</p>\n</blockquote>\n<p>see my proposal way above, we would make it an environment extension</p>",
        "id": 547111103,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761464906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"359992\">@Robert Maxton</span> that is a good idea, was there any objection the last time you mentioned it? (also could you link to the thread?)</p>",
        "id": 547111669,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761465481
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> I think <span class=\"user-mention\" data-user-id=\"359992\">@Robert Maxton</span> is referring to this message: <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/.22Missing.20Tactics.22.20list/near/523377726\">#general &gt; \"Missing Tactics\" list @ üí¨</a>. I also have a bunch of wishes for extending/improving <code>@[simps]</code> that makes me think it would be good to start a thread discussing this and coordinating with interested maintainers.</p>",
        "id": 547257481,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1761566069
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/547066440\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"486215\">George McNinch</span> do you want to try this?</p>\n</blockquote>\n<p>Whoops - not sure why I didn't see this message the other day (!). Sure, I 'm happy to take a shot at it (though I probably can't look at it until tomorrow).</p>",
        "id": 547267298,
        "sender_full_name": "George McNinch",
        "timestamp": 1761569060
    },
    {
        "content": "<p>so, to summarise this thread finally, according to Eric's guidelines (no i didn't use LLM):</p>\n<p>Let's look at a concrete example.</p>\n<ul>\n<li>Minimally bundled function: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/DirectSum/Decomposition.html#DirectSum.decompose\">DirectSum.decompose</a> <code>: M ‚âÉ ‚®Å i, ‚Ñ≥ i</code></li>\n<li>Bundled functions:<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/DirectSum/Decomposition.html#DirectSum.decomposeLinearEquiv\">DirectSum.decomposeLinearEquiv</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/DirectSum/Decomposition.html#DirectSum.decomposeAddEquiv\">DirectSum.decomposeAddEquiv</a></li>\n</ul>\n</li>\n<li>Minimally bundled constructor: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/DirectSum/Basic.html#DirectSum.of\">DirectSum.of</a> : <code>Œ≤ i ‚Üí+ ‚®Å i, Œ≤ i</code></li>\n<li>Bundled constructor: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/DirectSum/Module.html#DirectSum.lof\">DirectSum.lof</a>: <code>M i ‚Üí‚Çó[R] ‚®Å i, M i</code></li>\n</ul>\n<p>According to Eric, the simpNF of the applied forms of the function and the constructor are the <strong>minimally bundled version</strong>, and to balance this cost, we need to <strong>copy over all the hom lemmas</strong> to the unbundled version of both. In effect, there is no difference between how we treat constructors and how we treat functions (because a constructor is just a special function).</p>",
        "id": 548293362,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761990983
    },
    {
        "content": "<p>And on top of that we're (me and Robin) trying to see if the \"copy over\" step could be automated <a href=\"#narrow/channel/287929-mathlib4/topic/extend.20simps/with/547313664\">by extending <code>@[simps]</code></a></p>",
        "id": 548293398,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761991019
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/547086747\">said</a>:</p>\n<blockquote>\n<p>That can only do so much; lemmas like <code>map_dfinsuppSum</code> likely won't exist at the point the def is created, and I'm not sure how you'd add them latter</p>\n</blockquote>\n<p>there are two situations:</p>\n<ul>\n<li>if DFinsupp.sum is not defined at the current point, then right now we wouldn't have the <code>map_dfinsuppSum</code> lemma anyway</li>\n<li>if we have access to DFinsupp.sum, then according to my proposal the <code>map_dfinsuppSum</code> lemma would be automatically generated</li>\n</ul>\n<p>my proposal is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- at the definition of RingHom</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RingHom</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">hom_lemma</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">RingHom</span><span class=\"bp\">.</span><span class=\"n\">map_add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"c1\">-- in another file</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kd\">@[</span><span class=\"n\">hom_lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fooRingHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">foo_add</span><span class=\"w\"> </span><span class=\"c1\">-- foo (x + y) = foo x + foo y</span>\n\n<span class=\"c1\">-- at the definition of DFinsupp</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">hom_lemma</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">RingHom</span><span class=\"bp\">.</span><span class=\"n\">map_dfinsuppSum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"c1\">-- in another file</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kd\">@[</span><span class=\"n\">hom_lemma</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">barRingHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">bar_dfinsuppSum</span><span class=\"w\"> </span><span class=\"c1\">-- bar (x.sum f) = x.sum fun a b ‚Ü¶ bar (f a b)</span>\n</code></pre></div>",
        "id": 548293879,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761991466
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> what do you think about my proposal?</p>",
        "id": 548294067,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761991600
    },
    {
        "content": "<p>also, should we include my summary above somewhere in the official guidelines?</p>",
        "id": 548294313,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761991827
    },
    {
        "content": "<p>In the past I've considered that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DirectSum.of#doc\">docs#DirectSum.of</a> should not be bundled at all, but gave up on the PR trying to make the change</p>",
        "id": 553248722,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762093538
    },
    {
        "content": "<p>(I think it might have been motivated by broken unification in lean 3, which might no longer be relevant)</p>",
        "id": 553248760,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762093567
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Polynomial/Basic.html#Polynomial.C\">Polynomial.C</a> is bundled so this should be fine</p>",
        "id": 553248859,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1762093648
    },
    {
        "content": "<p><code>Polynomial.C</code> isn't good design imo</p>",
        "id": 553249803,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1762094711
    },
    {
        "content": "<p>What's wrong with it?</p>",
        "id": 553251171,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1762095834
    },
    {
        "content": "<p>One problem is that it fights with algebraMap for simpNF</p>",
        "id": 553251424,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762095935
    },
    {
        "content": "<p>Probably there's some issue with both relating to polynomials over non-unital rings too, but I haven't thought about that in any depth.</p>",
        "id": 553251461,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762095971
    },
    {
        "content": "<p>algebraMap is a problem on its own, i can never tell if it's meant to be simpNF or not, take for example the map from R to Localization (w : Submonoid R)</p>",
        "id": 553251469,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1762095984
    },
    {
        "content": "<p>My guess is that <code>algebraMap</code> should not be a <code>simpNF</code> because in many cases we have special names for it (<code>Nat.cast</code>, <code>Polynomial.C</code>, <code>Complex.ofReal</code> etc).</p>",
        "id": 553251881,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1762096362
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> tried to unify these all under one name in Lean 3, but it got swept away by the port</p>",
        "id": 553252138,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762096640
    },
    {
        "content": "<p>Essentially the algebraic version of <code>DFunLike.coe</code></p>",
        "id": 553252159,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1762096660
    },
    {
        "content": "<p>Where can I find more details?</p>",
        "id": 553255360,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1762099717
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> I disagree with this approach because it leads to API duplication</p>",
        "id": 553272125,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1762115823
    },
    {
        "content": "<p>Needs a reusable solution</p>",
        "id": 553272146,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1762115844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/553255360\">said</a>:</p>\n<blockquote>\n<p>Where can I find more details?</p>\n</blockquote>\n<p><a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/.22has.20canonical.20morphism.22.20class/with/281662863\">#general &gt; \"has canonical morphism\" class</a> <br>\n<a href=\"#narrow/channel/113488-general/topic/Should.20.60algebra_map.60.20be.20a.20coercion.3F\">#general &gt; Should &#96;algebra_map&#96; be a coercion?</a> <br>\n<a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Please.20stop.20adding.20generalized.20API.20around.20coercions/with/312657986\">#general &gt; Please stop adding generalized API around coercions</a></p>",
        "id": 553278921,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1762122563
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/553272125\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> I disagree with this approach because it leads to API duplication</p>\n</blockquote>\n<p>I see 2 other options:</p>\n<ul>\n<li>resurrect Lean3-time <code>coe</code> function and add typeclasses saying that coe is a morphism;</li>\n<li>make discrimination trees match some lemmas like <code>coe_add</code> on symbols marked with <code>@[coe]</code>.</li>\n</ul>",
        "id": 553279145,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1762122814
    },
    {
        "content": "<p>I thought we deprecated \"is a morphism\"</p>",
        "id": 553279178,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1762122851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/548293879\">said</a>:</p>\n<blockquote>\n<p>my proposal is this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- at the definition of RingHom</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RingHom</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">hom_lemma</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">RingHom</span><span class=\"bp\">.</span><span class=\"n\">map_add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"c1\">-- in another file</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kd\">@[</span><span class=\"n\">hom_lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fooRingHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">foo_add</span><span class=\"w\"> </span><span class=\"c1\">-- foo (x + y) = foo x + foo y</span>\n\n<span class=\"c1\">-- at the definition of DFinsupp</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">hom_lemma</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">RingHom</span><span class=\"bp\">.</span><span class=\"n\">map_dfinsuppSum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"c1\">-- in another file</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kd\">@[</span><span class=\"n\">hom_lemma</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">barRingHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚Üí+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">bar_dfinsuppSum</span><span class=\"w\"> </span><span class=\"c1\">-- bar (x.sum f) = x.sum fun a b ‚Ü¶ bar (f a b)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>What do you guys think about my proposal here?</p>",
        "id": 553279245,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1762122907
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/553249803\">said</a>:</p>\n<blockquote>\n<p><code>Polynomial.C</code> isn't good design imo</p>\n</blockquote>\n<p>Which problem are you referring to? The existence of the ring hom <code>R -&gt;+* R[X]</code>? Or the fact that it is the simpNF for constant polynomials? Or the fact that the simpNF for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><msup><mi>X</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">aX^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> is <code>C a * X ^ n</code> instead of <code>a ‚Ä¢ X ^ n</code>?</p>",
        "id": 553279429,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1762123129
    },
    {
        "content": "<p>It feels like this thread turned into discussion of several (related, but different) issues, with many posts not specifying which issue they're trying to solve. It would be nice if one of the participants writes a summary of what issues were discussed, what are the options, and how these issues are related to each other. My guess is that the issues are too Mathlib-specific to ask an AI, but I haven't tried yet.</p>",
        "id": 553283351,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1762127315
    },
    {
        "content": "<p>I think the central thread is \"how best to define a function\" where:</p>\n<ul>\n<li>bundled functions have built-in hom lemmas, but are uncanonical so they fight for simpNF</li>\n<li>unbundled functions need hom lemmas proven, but should be the default</li>\n</ul>\n<p>And then afterwards we started to discuss several bundled functions that are currently the simpNF and how they are suboptimal, such as Polynomial.C and algebraMap</p>\n<p>(I did ask LLM but i'm too afraid to trust it)</p>",
        "id": 553283925,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1762127860
    },
    {
        "content": "<p>There is also a discussion of whether we should use bundled maps for stuff like <code>Polynomial.C</code> or <code>MvPolynomial.eval</code> at all.</p>",
        "id": 553284085,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1762128053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/553279245\">said</a>:</p>\n<blockquote>\n<p>What do you guys think about my proposal [<a href=\"#narrow/channel/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/548293879\">here</a>]?</p>\n</blockquote>\n<p>What happens if <code>map_dfinsuppSum</code> and <code>barRingHom</code> are defined in files that don't know about each other? If we later import both in one file, would the lemmas be generated there?</p>",
        "id": 553344465,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1762165067
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/channel/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/553344465\">said</a>:</p>\n<blockquote>\n<p>What happens if <code>map_dfinsuppSum</code> and <code>barRingHom</code> are defined in files that don't know about each other? If we later import both in one file, would the lemmas be generated there?</p>\n</blockquote>\n<p>no, you would miss the lemma; but right now in this set up there is no way to have <code>bar_dfinsuppSum</code> anyway.</p>",
        "id": 553345182,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1762165297
    },
    {
        "content": "<p>I disagree with \"there is no way to have <code>bar_dfinsuppSum</code>.</p>\n<p>From a current user's perspective: we want to apply <code>bar_dfinsuppSum</code>, find it doesn't exist, define a new <code>lemma bar_dfinsuppSum := map_dfinsuppSum barRingHom</code> and find/create a file where it fits in the import hierarchy.</p>\n<p>With autogenerated declarations: we want to apply <code>bar_dfinsuppSum</code>, find it doesn't exist, and then we are out of luck?</p>",
        "id": 553354000,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1762167764
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> no, in that situation you would also do <code>lemma bar_dfinsuppSum := map_dfinsuppSum barRingHom</code>. What I meant by \"right now anyway\" is that right now you would also have to state the theorem manually anyway, and this wouldn't change after my proposal</p>",
        "id": 553363009,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1762170761
    },
    {
        "content": "<p>i'm not removing the map_xxx lemmas; i'm tagging them with <code>@[hom_lemma]</code></p>",
        "id": 553363063,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1762170780
    },
    {
        "content": "<p>I think that it should be possible to call <code>hom_def</code> (the attribute that specializes <code>hom_lemma</code>s; I think that we should use a different name) when some of the lemmas are already there. E.g., it's possible that <code>bar_mul</code> is defined in non-commutative settings while <code>bar_prod</code> needs a <code>CommMonoid</code> instance. The code should skip the pre-existing lemmas, possibly checking that they auto imply the new version. As a side effect, it will be possible to write <code>attribute [hom_def] barHom</code> later to generate the missing lemmas.</p>",
        "id": 553389069,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1762178756
    },
    {
        "content": "<p>I agree</p>",
        "id": 553389319,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1762178819
    },
    {
        "content": "<p>Of course, this could lead to multiple definitions of the same lemma. I'm not sure what to do about it.</p>",
        "id": 553389385,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1762178835
    },
    {
        "content": "<p>we can just look at the names and skip if there's already a lemma with the name</p>",
        "id": 553389530,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1762178880
    },
    {
        "content": "<p>I mean, if <code>B</code> and <code>C</code> import <code>A</code> and we call <code>hom_def</code> on a definition from <code>A</code> in both <code>B</code> and <code>C</code>, they can generate conflicting lemmas.</p>",
        "id": 553389778,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1762178934
    },
    {
        "content": "<p>Also, it's important to copy attributes like <code>@[simp]</code> from the original <code>hom_lemma</code>s.</p>",
        "id": 553390007,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1762178979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/553389778\">said</a>:</p>\n<blockquote>\n<p>I mean, if <code>B</code> and <code>C</code> import <code>A</code> and we call <code>hom_def</code> on a definition from <code>A</code> in both <code>B</code> and <code>C</code>, they can generate conflicting lemmas.</p>\n</blockquote>\n<p>maybe we should ban calling hom_def on a later file, and only permit more specialised lemmas such as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">generate_hom_lemmas</span><span class=\"w\"> </span><span class=\"n\">barRingHom</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">dfinsuppSum</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This should be more maintainable in the long term (consider once again the argument that in the current setup you could also have someone write <code>theorem bar_dfinsuppSum</code> twice in the file B and then the file C that both import A)</p>",
        "id": 553391292,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1762179315
    }
]