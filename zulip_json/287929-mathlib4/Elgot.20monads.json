[
    {
        "content": "<p>Hello! </p>\n<p>I've been trying to formalize some of the definitions and theorems in <a href=\"https://drops.dagstuhl.de/opus/volltexte/2019/11441/pdf/LIPIcs-CALCO-2019-13.pdf\">Coinductive Resumption Monads</a> for use in a paper of mine, and in particular Elgot monads, which are defined as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Sum.Basic</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">DaggerMonad</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">):</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">dagger</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">⊕</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">m</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ElgotMonad</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LawfulMonad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">DaggerMonad</span> <span class=\"n\">m</span>\n  <span class=\"n\">where</span>\n  <span class=\"n\">fixpoint</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">⊕</span> <span class=\"n\">α</span><span class=\"o\">)),</span>\n    <span class=\"n\">f</span> <span class=\"bp\">&gt;=&gt;</span> <span class=\"n\">Sum.elim</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">dagger</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">dagger</span> <span class=\"n\">f</span>\n  <span class=\"n\">naturality</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">⊕</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">m</span> <span class=\"n\">γ</span><span class=\"o\">),</span>\n    <span class=\"n\">dagger</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">&gt;=&gt;</span> <span class=\"n\">Sum.elim</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">&gt;=&gt;</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"bp\">∘</span> <span class=\"n\">Sum.inl</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"bp\">∘</span> <span class=\"n\">Sum.inr</span><span class=\"o\">))</span>\n      <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">dagger</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">&gt;=&gt;</span> <span class=\"n\">g</span>\n  <span class=\"c1\">-- Derivable from fixpoint + naturality + codiagonal + uniformaity</span>\n  <span class=\"c1\">-- by proposition 17 of Levy and Goncharov 2012 (Coinductive Resumption Monads: Guarded Iterative and Guarded Elgot)</span>\n  <span class=\"c1\">-- dinaturality: ∀{α β γ: Type u}</span>\n  <span class=\"c1\">--   (g: α -&gt; m (β ⊕ γ))</span>\n  <span class=\"c1\">--   (h: γ -&gt; m (β ⊕ α)),</span>\n  <span class=\"c1\">--   dagger (g &gt;=&gt; Sum.elim (pure ∘ Sum.inl) h)</span>\n  <span class=\"c1\">--     = g &gt;=&gt; Sum.elim pure (dagger (h &gt;=&gt; Sum.elim (pure ∘ Sum.inl) g))</span>\n  <span class=\"n\">codiagonal</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">m</span> <span class=\"o\">((</span><span class=\"n\">β</span> <span class=\"bp\">⊕</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">⊕</span> <span class=\"n\">α</span><span class=\"o\">)),</span>\n    <span class=\"n\">dagger</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">&gt;=&gt;</span> <span class=\"n\">Sum.elim</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"bp\">∘</span> <span class=\"n\">Sum.inr</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">dagger</span> <span class=\"o\">(</span><span class=\"n\">dagger</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"n\">uniformity</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">⊕</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">⊕</span> <span class=\"n\">γ</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n    <span class=\"n\">g</span> <span class=\"bp\">&gt;=&gt;</span> <span class=\"n\">Sum.elim</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"bp\">∘</span> <span class=\"n\">Sum.inl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">&gt;=&gt;</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"bp\">∘</span> <span class=\"n\">Sum.inr</span><span class=\"o\">))</span>\n      <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">&gt;=&gt;</span> <span class=\"n\">f</span>\n    <span class=\"bp\">-&gt;</span> <span class=\"n\">dagger</span> <span class=\"n\">g</span>\n      <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">&gt;=&gt;</span> <span class=\"n\">dagger</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IterativeMonad</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LawfulMonad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">ElgotMonad</span> <span class=\"n\">m</span>\n  <span class=\"n\">where</span>\n  <span class=\"n\">uniqueness</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">⊕</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">m</span> <span class=\"n\">β</span><span class=\"o\">),</span>\n    <span class=\"n\">f</span> <span class=\"bp\">&gt;=&gt;</span> <span class=\"n\">Sum.elim</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>\n      <span class=\"bp\">-&gt;</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">dagger</span> <span class=\"n\">f</span>\n\n<span class=\"c1\">-- Proposition 18 of Levy and Goncharov 2012 (Coinductive Resumption Monads: Guarded Iterative and Guarded Elgot)</span>\n<span class=\"c1\">-- def IterativeMonad.mk' (m: Type u -&gt; Type v) [Monad m] [LawfulMonad m]</span>\n<span class=\"c1\">--   (dagger: ∀{α β: Type u}, (α -&gt; m (β ⊕ α)) -&gt; α -&gt; m β)</span>\n<span class=\"c1\">--   (fixpoint: ∀{α β: Type u}</span>\n<span class=\"c1\">--     (f: α -&gt; m (β ⊕ α)),</span>\n<span class=\"c1\">--     f &gt;=&gt; Sum.elim pure (dagger f) = dagger f)</span>\n<span class=\"c1\">--   (uniqueness: ∀{α β: Type u}</span>\n<span class=\"c1\">--     (f: α -&gt; m (β ⊕ α))</span>\n<span class=\"c1\">--     (g: α -&gt; m β),</span>\n<span class=\"c1\">--     f &gt;=&gt; Sum.elim pure (g) = g</span>\n<span class=\"c1\">--       -&gt; g = dagger f)</span>\n<span class=\"c1\">--   : IterativeMonad m where</span>\n<span class=\"c1\">--   dagger := dagger</span>\n<span class=\"c1\">--   fixpoint := fixpoint</span>\n<span class=\"c1\">--   naturality := sorry</span>\n<span class=\"c1\">--   dinaturality := sorry</span>\n<span class=\"c1\">--   uniformity := sorry</span>\n<span class=\"c1\">--   uniqueness := uniqueness</span>\n</code></pre></div>\n<p>I was wondering if this definition, and some others surrounding iteration, might have a place in Mathlib (or if they've already been defined, which would save me a lot of work!). In particular, I'm also looking at formalizing the notion of an Elgot/iterative category (my work does not require the guarded versions, but that could be future work). Any idea where to start?</p>\n<p>Sorry if I'm doing this wrong, I'm not really sure of the correct way to do this</p>\n<p>Thanks!</p>",
        "id": 391002173,
        "sender_full_name": "Jad Ghalayini",
        "timestamp": 1694718287
    }
]