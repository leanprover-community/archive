[
    {
        "content": "<p>Sorry if this is weird, I'm a bit new with Lean. </p>\n<p>I want to perform a Finset.induction on <code>(f S)</code> for some function that maps a Set to another set. (Doing this directly on the original set is much harder because the main property I am working on comes from a Set passing through f. <br>\n(I do have the a lemma that this property <code>p</code> holds <code>\\forall e \\in (f S)</code>). </p>\n<p>I want to use this property about elements of <code>(f S)</code> inside the induction. This could either be done using the definition of the set the induction is being done on, or by somehow passing information about the base of the induction. </p>\n<p>Consider the example case below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test_finset_induction_on'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">induction_on'</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">       </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">x</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a_1</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"n\">Old</span><span class=\"w\"> </span><span class=\"n\">new_in_total</span><span class=\"w\"> </span><span class=\"n\">Old_subset_total</span><span class=\"w\"> </span><span class=\"n\">new_not_in_Old</span><span class=\"w\"> </span><span class=\"n\">h_ind</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">       </span><span class=\"c1\">-- Definition of total is lost, property of Old or Total cannot be expressed</span>\n<span class=\"w\">    </span><span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>My guess is that inductions shouldn't be done like this and that somehow, lean discards information about the Finset the induction is on. (It could also be a classic X Y Problem, I'm still quite new with lean)</p>\n<p>Is there some way to proceed here? I do know that if I can use the property inside that I can continue my proof (I introduced it with sorry and used it to complete it)</p>",
        "id": 538029724,
        "sender_full_name": "Sese Mueller",
        "timestamp": 1757190714
    },
    {
        "content": "<p><code>induction h : f S using Finset.induction_on' with</code></p>",
        "id": 538029780,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757190766
    },
    {
        "content": "<p>Two options, either what Aaron said, or use <code>generalize h : f S = x</code> first and then do <code>induction x</code>. Aaron's suggestion is the more convenient one.</p>",
        "id": 538029817,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1757190809
    },
    {
        "content": "<p>Thanks for the quick help, that looks good. I'll see whether I can use it</p>",
        "id": 538030240,
        "sender_full_name": "Sese Mueller",
        "timestamp": 1757191230
    },
    {
        "content": "<p>It doesn't do what I expected it to; I thought it would have <code>x: Finset \\alpha := f S</code> in the assumptions, but I can only get <code>f S = insert new Old</code> by declaring the hypothesis outside the induction twice.  Specifically, there doesn't seem to be a way to show <code>x = f S</code> inside, only <code>x \\subseteq f S</code>. Might be enough for me, but I'm still not that well with Lean</p>",
        "id": 538031504,
        "sender_full_name": "Sese Mueller",
        "timestamp": 1757192487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"957033\">Sese Mueller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Losing.20definition.20when.20using.20Finset.2Einduction_on'/near/538031504\">said</a>:</p>\n<blockquote>\n<p>It doesn't do what I expected it to; I thought it would have <code>x: Finset \\alpha := f S</code> in the assumptions, but I can only get <code>f S = insert new Old</code> by declaring the hypothesis outside the induction twice.  Specifically, there doesn't seem to be a way to show <code>x = f S</code> inside, only <code>x \\subseteq f S</code>. Might be enough for me, but I'm still not that well with Lean</p>\n</blockquote>\n<p>You can always do <code>let x := f S</code></p>",
        "id": 538031566,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757192547
    },
    {
        "content": "<p>I'm not sure how that could help or where I can do that, if I do it inside the induction, the old x, which the hypothesis <code>new_in_total</code> and <code>Old_subset_total</code> depend on just gets shadowed</p>",
        "id": 538031893,
        "sender_full_name": "Sese Mueller",
        "timestamp": 1757192882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"957033\">Sese Mueller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Losing.20definition.20when.20using.20Finset.2Einduction_on'/near/538031893\">said</a>:</p>\n<blockquote>\n<p>I'm not sure how that could help or where I can do that, if I do it inside the induction, the old x, which the hypothesis <code>new_in_total</code> and <code>Old_subset_total</code> depend on just gets shadowed</p>\n</blockquote>\n<p>can you write out the goal state you have in the induction step and the goal state you want to have?</p>",
        "id": 538031957,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757192953
    },
    {
        "content": "<p>Not really, it's quite long but also not the point. I want to use the property of <code>f</code> on the assumptions to, after some work, show that applying <code>f</code> to <code>new</code> and taking the union of mapping <code>f</code> on <code>Old</code> is disjoint. </p>\n<p>I would like to have the state that contains <code>h2: x = f S</code> where <code>new_in_total</code> and <code>Old_subset_total</code> refer to <code>x</code>.</p>",
        "id": 538032264,
        "sender_full_name": "Sese Mueller",
        "timestamp": 1757193308
    },
    {
        "content": "<p>I'm asking this because the thing I think you want to do is unsound</p>",
        "id": 538032326,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757193373
    },
    {
        "content": "<p>the great thing about Lean is that it's really really hard to accidentally do unsound things</p>",
        "id": 538032664,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757193749
    },
    {
        "content": "<p>Hm, yeah, that might be a possibility. But introducing <code>have h_unsound : f S = x := by sorry</code> into the example doesn't produce any false statements as far as I (or <code>exact?</code> or <code>aesop</code>) can see.<br>\nI think the gap between <code>x</code> and <code>f S</code> in the induction is that the induction, there is no limit/filter on what could be in <code>x</code>.  So Lean plays it safe and doesn't allow any hypothesis about what couldn't be in <code>x</code> and instead only gives the two hypothesis for <code>new</code> and <code>Old</code> being in <code>x</code>. (But I might be wrong)</p>",
        "id": 538033708,
        "sender_full_name": "Sese Mueller",
        "timestamp": 1757195004
    },
    {
        "content": "<p>Also, there seems to be a weird difference between using <code>induction (f S) using …</code> and <code>induction h: (f S) using ...</code>; when omitting the <code>h</code>,  <code>hind := Disjoint Old (g S)</code> but when <code>h</code> is used, <code>hind:= f S \\to Disjoint Old (g S)</code>.</p>",
        "id": 538036027,
        "sender_full_name": "Sese Mueller",
        "timestamp": 1757198052
    },
    {
        "content": "<p>This leads to it being elimated by a <code>simp_all</code> via <code>simp_all only [Finset.insert_eq_self, IsEmpty.forall_iff, Finset.disjoint_insert_left]</code>. This doesn't happen without the <code>h</code>. Weird.</p>",
        "id": 538036237,
        "sender_full_name": "Sese Mueller",
        "timestamp": 1757198321
    },
    {
        "content": "<p>Yes, including <code>h</code> changes the induction hypothesis, since you need to prove that the variable being inducted on is equal to <code>f S</code>, to justify why you could get such an equality.</p>",
        "id": 538036481,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1757198660
    }
]