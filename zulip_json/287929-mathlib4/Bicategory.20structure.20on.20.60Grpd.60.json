[
    {
        "content": "<p>I would like to also have a bicategory structure on <code>Grpd</code>, by defining the common generalization of this with the bicategory structure on <code>Cat</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ofCoeSortCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u‚ÇÅ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Bicategory</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u‚ÇÅ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">D</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">ùü≠</span><span class=\"w\"> </span><span class=\"n\">C</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">G</span>\n<span class=\"w\">  </span><span class=\"n\">homCategory</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">category</span>\n<span class=\"w\">  </span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">Œ∑</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">Œ∑</span>\n<span class=\"w\">  </span><span class=\"n\">whiskerRight</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">Œ∑</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">whiskerRight</span><span class=\"w\"> </span><span class=\"n\">Œ∑</span><span class=\"w\"> </span><span class=\"n\">H</span>\n<span class=\"w\">  </span><span class=\"n\">associator</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">associator</span>\n<span class=\"w\">  </span><span class=\"n\">leftUnitor</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">leftUnitor</span>\n<span class=\"w\">  </span><span class=\"n\">rightUnitor</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">rightUnitor</span>\n<span class=\"w\">  </span><span class=\"n\">pentagon</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">pentagon</span>\n<span class=\"w\">  </span><span class=\"n\">triangle</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">triangle</span>\n</code></pre></div>\n<p>Then we could also generalize <code>to_app</code> to cover any such bicategory, and also have a Grothendieck construction for any such category (my original motivation)</p>",
        "id": 554577073,
        "sender_full_name": "joseph hua",
        "timestamp": 1762707871
    },
    {
        "content": "<p>Arguably, the category of morphisms between two functors between groupoids could be natural isomorphisms (rather than natural transformations).<br>\nI am not doing meta-programmation, but I do not see obstacles for generalizing <code>to_app</code> for groupoids.<br>\nFor the Grothendieck construction, the easier is probably to apply the existing Grothendieck construction to the composition of a pseudofunctor and the \"forget\" pseudofunctor from <code>Grpd</code> to <code>Cat</code>.</p>",
        "id": 554580115,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1762710963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Jo√´l Riou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Bicategory.20structure.20on.20.60Grpd.60/near/554580115\">said</a>:</p>\n<blockquote>\n<p>For the Grothendieck construction, the easier is probably to apply the existing Grothendieck construction to the composition of a pseudofunctor and the \"forget\" pseudofunctor from <code>Grpd</code> to <code>Cat</code>.</p>\n</blockquote>\n<p>This is what I am currently working with. I don't like it very much because I have to either have <code>Grpd.forgetToCat</code> bloating the context, or create a new API to hide all the <code>Grpd.forgetToCat</code>, in which attributes like <code>@[simps!]</code> do not work very nicely. (essentially this means either way one has to maintain two copies of the Grothendieck API, rather than just one)</p>\n<p>Another thing this would work nicely with is taking the bicategory to be <code>LocallyDiscrete Set</code>, and getting the category of elements as a special case of the Grothendieck construction</p>",
        "id": 554581092,
        "sender_full_name": "joseph hua",
        "timestamp": 1762711836
    },
    {
        "content": "<p>Shouldn't the <code>.forgetToCat</code> bloat disappear after a use of <code>simp</code>?</p>",
        "id": 554650368,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1762766058
    },
    {
        "content": "<p>Yes that's right. But my experience is that the simp lemma <code>Grpd.forgetToCat</code> was causing performance issues because it was slowing down checking definitional equalities. I might be wrong about this, but it was certainly a less user-friendly experience</p>",
        "id": 554731102,
        "sender_full_name": "joseph hua",
        "timestamp": 1762788972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Jo√´l Riou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Bicategory.20structure.20on.20.60Grpd.60/near/554580115\">said</a>:</p>\n<blockquote>\n<p>Arguably, the category of morphisms between two functors between groupoids could be natural isomorphisms (rather than natural transformations).</p>\n</blockquote>\n<p>that should be a different definition. I wouldn't make this <code>def</code> an <code>instance</code></p>",
        "id": 554731490,
        "sender_full_name": "joseph hua",
        "timestamp": 1762789088
    },
    {
        "content": "<p>My two cents: I think this should use the existing Grothendieck construction and <code>forgetToCat</code>. While I understand that having one specific construction for each case helps with definitional equalities and therefore typechecking, this would require more glue later on. E.g. if we want to show that the Grothendieck construction has a right adjoint, we would have to make this construction <code>n</code> times for each specific case, in contrast to doing it once and then checking that the right adjoint restricts appropriately.</p>",
        "id": 554855840,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1762848512
    },
    {
        "content": "<p>I think that the performance issues of <code>.forgetToCat</code> can be mitigated by adding more <code>simp</code> lemmas. So I see the problem as a tradeoff of optimizing code now v.s. writing glue/duplicate code later, and I think that the first approach is the best in the long term. Of course there is a problem of distribution, the glue/duplication can be done at a later time by whoever needs it, while optimizing is hard and would fall mostly on you. I don't know how to solve this, other than offer my help for this specific case :)</p>",
        "id": 554856283,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1762848726
    },
    {
        "content": "<p>For visibility I opened this PR a while back defining the bicategory structure on <code>Grpd</code>: <a href=\"https://github.com/leanprover-community/mathlib4/pull/30920\">#30920</a>. However, you both seem to be thinking about this harder than I was, so I am happy to close it if you settle on a better approach.</p>",
        "id": 554970797,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1762884497
    },
    {
        "content": "<p>Maybe we should as a first step refactor the bicategory structure on <code>Cat</code> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/30920\">#30920</a> through my suggestion, and fixing <code>to_app</code> so that it works in both cases. <span class=\"user-mention\" data-user-id=\"132603\">@Calle S√∂nne</span> I haven't worked on any tactics before so definitely would like your help on the latter</p>",
        "id": 554980651,
        "sender_full_name": "joseph hua",
        "timestamp": 1762888739
    },
    {
        "content": "<p>Which refactor?</p>",
        "id": 554981433,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1762889100
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133584\">joseph hua</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Bicategory.20structure.20on.20.60Grpd.60/near/554577073\">said</a>:</p>\n<blockquote>\n<p>I would like to also have a bicategory structure on <code>Grpd</code>, by defining the common generalization of this with the bicategory structure on <code>Cat</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ofCoeSortCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u‚ÇÅ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Bicategory</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u‚ÇÅ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">D</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">ùü≠</span><span class=\"w\"> </span><span class=\"n\">C</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">G</span>\n<span class=\"w\">  </span><span class=\"n\">homCategory</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">category</span>\n<span class=\"w\">  </span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">Œ∑</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">Œ∑</span>\n<span class=\"w\">  </span><span class=\"n\">whiskerRight</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">Œ∑</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">whiskerRight</span><span class=\"w\"> </span><span class=\"n\">Œ∑</span><span class=\"w\"> </span><span class=\"n\">H</span>\n<span class=\"w\">  </span><span class=\"n\">associator</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">associator</span>\n<span class=\"w\">  </span><span class=\"n\">leftUnitor</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">leftUnitor</span>\n<span class=\"w\">  </span><span class=\"n\">rightUnitor</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">rightUnitor</span>\n<span class=\"w\">  </span><span class=\"n\">pentagon</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">pentagon</span>\n<span class=\"w\">  </span><span class=\"n\">triangle</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">triangle</span>\n</code></pre></div>\n<p>Then we could also generalize <code>to_app</code> to cover any such bicategory, and also have a Grothendieck construction for any such category (my original motivation)</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span>  this definition generalizes both the bicategory structure on <code>Cat</code> and the bicategory structure on <code>Grpd</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/30920\">#30920</a>.</p>",
        "id": 554985967,
        "sender_full_name": "joseph hua",
        "timestamp": 1762891022
    },
    {
        "content": "<p>This sounds reasonable!</p>",
        "id": 554991495,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1762893321
    },
    {
        "content": "<p>Okay if I understand correctly, essentially what's going on here is that given a type of objects you are defining a full sub-bicategory of <code>Cat</code>. In <a href=\"https://github.com/leanprover-community/mathlib4/pull/30925\">#30925</a> I define \"induced bicategories\" which is essentially this in general, with the important difference is that in your case the \"inclusion map\" is actually a coercion (and injective). Do you think that most of the API you wanted to avoid duplicating could be stated in terms of the inclusion pseudofunctor of an induced bicategory as in my PR?</p>",
        "id": 555204737,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1762975262
    },
    {
        "content": "<p>And if you think that this approach is strictly superior to one using induced bicategories, could it be possible to generalize your construction further to also deal with other similar full sub-bicategories?</p>",
        "id": 555205062,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1762975365
    },
    {
        "content": "<p>Is the main advantage to your approach in comparison to using <code>Grpd.forgetToCat</code> that the pseudofunctor gets replaced with a coercion? Could some notation help deal with this? I am just thinking because dealing with full sub-bicategories will be an issue outside of <code>Cat</code> as well.</p>",
        "id": 555205882,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1762975623
    },
    {
        "content": "<p>I think induced bicategories is probably better than what I suggested. Though, it is less obvious to me how <code>to_app</code> could be used if the bicategory structure on <code>Grpd</code> were defined using induced bicategory.</p>",
        "id": 555210729,
        "sender_full_name": "joseph hua",
        "timestamp": 1762977190
    },
    {
        "content": "<p><del>I guess you mean applying <code>to_app</code> to some lemmas about natural transformation between <code>Grpd</code>s that do not already hold in <code>Cat</code>? Because I guess applying <code>_app</code> lemmas coming from <code>Cat</code> should be fine I think if we make the right simp lemmas.</del></p>",
        "id": 555213627,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1762978112
    },
    {
        "content": "<p>Actually, so <code>to_app</code> specializes a lemma about general bicategories to <code>Cat</code>. If we have the right simp lemmas about the compatibility between <code>forgetToCat</code> and <code>.app</code> maybe we can always reuse the lemmas for <code>Cat</code>? So for example <code>.app</code> applied to a transformation between groupoids should simp to <code>.app</code> applied to the transformation between the images of <code>forgetToCat</code>?</p>",
        "id": 555214299,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1762978366
    },
    {
        "content": "<p>Yes this sounds good. Since the 2-cells of the induced bicategory should literally be 2-cells in <code>Cat</code>, we only need the lemmas for 2-cells in <code>Cat</code></p>",
        "id": 555225064,
        "sender_full_name": "joseph hua",
        "timestamp": 1762982449
    },
    {
        "content": "<p>Okay then as soon as  <a href=\"https://github.com/leanprover-community/mathlib4/pull/30132\">#30132</a> gets merged I will rewrite my bicategory of groupoids PR to use induced bicategories.</p>",
        "id": 555236166,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1762987152
    },
    {
        "content": "<p>Are bicategories whose underlying objects are categories some sort of categorification of concrete categories? If so maybe we should take some inspiration from <code>ConcreteCategory</code> to define this (although for now we only need full sub-bicategories which should make things a lot simpler).</p>",
        "id": 556946813,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1763420625
    },
    {
        "content": "<p>I am doubting the induced category approach for <code>Grpd</code> as in the 1-category library people don't seem to use e.g. <code>FullSubcategory</code> (or <code>InducedCategory</code>) very often. The most popular approach seems to be to just define the category manually and then define the corresponding forgetful functor.</p>",
        "id": 556948683,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1763421481
    },
    {
        "content": "<p>When I manage to finish <a href=\"https://github.com/leanprover-community/mathlib4/pull/26446\">#26446</a>, I would think that defining full subcategories as an abbreviation for <code>ObjectProperty.FullSubcategory</code> should be the norm rather than the exception.</p>",
        "id": 557885467,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1763460388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Jo√´l Riou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Bicategory.20structure.20on.20.60Grpd.60/near/557885467\">said</a>:</p>\n<blockquote>\n<p>When I manage to finish <a href=\"https://github.com/leanprover-community/mathlib4/pull/26446\">#26446</a>, I would think that defining full subcategories as an abbreviation for <code>ObjectProperty.FullSubcategory</code> should be the norm rather than the exception.</p>\n</blockquote>\n<p>Okay that's good to know. Do you think <code>ObjectProperty.FullSubcategory</code> is preferred to <code>InducedCategory</code>? It seems way more common in Mathlib at least.</p>\n<p>Also what's good is that what you do in your refactor is the way I have defined induced bicategories anyways (with <code>Homs</code> and even the 2-homs being structures and not type synonyms).</p>",
        "id": 557986579,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1763483713
    },
    {
        "content": "<p><code>InducedCategory</code> and <code>ObjectProperty.FullSubcategory</code> should be equally good, as <code>ObjectProperty.FullSubcategory</code> is a particular case of <code>InducedCategory</code>.</p>",
        "id": 557990897,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1763484716
    },
    {
        "content": "<p>Oh wait, <code>InducedCategory</code> is still a type synonym in your PR? Can this not lead to def-eq abuse? Or is the main problems the morphisms?</p>",
        "id": 557994356,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1763485454
    },
    {
        "content": "<p>I guess you don't want to be rewriting/adding simp lemmas about objects in a category anyways, so this does not matter? In <a href=\"https://github.com/leanprover-community/mathlib4/pull/30925\">#30925</a> I made <code>InducedBicategory</code> its own structure, do you think it is not so bad if it's simply a type synonym?</p>",
        "id": 557994823,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1763485575
    },
    {
        "content": "<p>I feel that introducing a one field structure is important only for morphisms (but I may be wrong!).</p>",
        "id": 558004637,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1763488011
    },
    {
        "content": "<p>Hmm. Maybe you are right. Since whenever you talk about <code>f.hom</code> (as in your PR) for example it is clear in what category to interpret the domain and codomains.</p>",
        "id": 558005217,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1763488163
    },
    {
        "content": "<p>So maybe for induced bicategories its only important to have a separate structure for the 2-morphisms. I also like that for 1-categories this approach means that <code>FullSubcategory</code> is a special case of <code>InducedCategory</code>.</p>\n<p>Just so I understand properly: the issue with def-eq abuse is really that it can prevent simp from firing when it should, and lead to undesirable <code>erw</code>s?</p>",
        "id": 558005747,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1763488307
    },
    {
        "content": "<p>For full subcategories, etc, one of the issues is that when Lean sees a morphism, it may not necessarily know if it is a morphism in the ambient category or in the subcategory: by making very distinct types, no such confusion is possible, and it is a fact that automation works better in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26446\">#26446</a> after doing the change.<br>\nThen, for induced 2-categories, it is probably not absolutely necessary to use a 1-field structure for objects, but a fortiori, from the experience of ordinary categories, the 1-morphisms should be a 1-field structure. I would also think that 2-morphisms should be a 1-field structure: when we consider these 2-morphisms only as morphisms in the category of morphisms, there should not be issues, but when we want to apply the bicategories operations like <code>whiskerLeft/Right</code>, it may become a problem like \"Are we trying to do <code>whiskerLeft</code> in the original bicategory or in the induced one?\". <span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> may have a more definite understanding of this?!</p>",
        "id": 558009496,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1763489264
    },
    {
        "content": "<p>Yes but in some sense lean does know if it is in the ambient category or in the subcategory! Because currently various implementations of categories using <code>InducedCategory</code> does compile, even with this ambiguous notion of morphism. I understood that we do not have issues writing lemmas about the 1-morphisms the way they are now, since lean will be able to infer in what category they should be interpreted (I might be wrong about this though). It is the automation that breaks due to this def-eq abuse, but I have not fully grasped exactly in what way the automation breaks. That was more what I meant by my question. So e.g. is the main problem that <code>simp</code> is not working the way it should for <code>InducedCategories</code> currently?</p>",
        "id": 558023274,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1763493446
    },
    {
        "content": "<p>I am not convinced that there will be issues with whiskering in that setting, since if we have a separate structure for 2-morphisms then lean should be able to infer from the 2-morphism in what bicategory we are whiskering. But possibly this will be an issue for simp.</p>",
        "id": 558024154,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1763493735
    },
    {
        "content": "<p>Could a type synonym for objects not bring issues when talking about the yoneda functors <code>Hom(-, x)</code> for <code>x</code> in the subcategory? As a priori it will not be clear if <code>x</code> is taken to be an object of the subcategory or of the category itself.</p>",
        "id": 558025502,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1763494199
    },
    {
        "content": "<p>What I was trying to say is that <code>2</code>-morphisms should also be made a <code>1</code>-field struture, because otherwise it would not be clear in which bicategory we are doing <code>whiskerLeft/Right</code>.</p>",
        "id": 558025509,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1763494201
    },
    {
        "content": "<p>Ah okay, this I definitely agree with.</p>",
        "id": 558025582,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1763494221
    },
    {
        "content": "<p>But it seems to me that if it is fine to not make objects a 1 field structure for categories, then similarly it should be fine to not make 1-morphisms a 1 field structure for bicategories. As we should not be rewriting/simping equalities of 1-morphisms anyways.</p>",
        "id": 558026072,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1763494404
    },
    {
        "content": "<p>I am not convinced by this argument: we certainly want that <code>dsimp</code> works.</p>",
        "id": 558030080,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1763495685
    },
    {
        "content": "<p>I most definitely agree that we at least want the 2-morphisms to be their own 1-field structure.</p>\n<p>For 1-morphisms, my general experience is that things just work better with categories that have type aliases as objects (e.g <code>Paths</code>, <code>Core</code>, etc.) when we wrap the objects in 1-field structures: it‚Äôs not strictly necessary, and adds arguably some verbosity, but makes it so that we can‚Äôt have a term that has <code>x : C</code> where it should be <code>x : Alias C</code> by accident (and this can happens when relying on type inference as well), as it simply refuses to type check.</p>\n<p>It‚Äôs certainly possible to have things working without 1-field structures in setup like this, by providing functions from the original type to the alias and in the other direction as well, and insert them carefully to guide type inference, but IMO this pattern is just trying to emulate (in a way that can still leads to accidental errors) what a 1-field structure gives for free (a constructor and a projection).</p>\n<p>So my gut feeling for the bicategorical case would be that sticking to \"1-morphisms are objects of a category\", we can probably get away with not making 1-morphisms their own 1-field structure here but that we should be on the much safer side (as in: probably we‚Äôll have less user error/things to think about when reviewing stuff about them) by just doing so.</p>",
        "id": 558160030,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1763546911
    },
    {
        "content": "<p>Thanks for the extensive reply! In my induced bicategory PR, I also make the objects a 1-field structure. Given that we will not be doing this for 1-categories, do you think maybe its better to copy that approach and have the objects (only) as a type synonym?</p>",
        "id": 558163723,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1763548008
    },
    {
        "content": "<p>Sorry, I‚Äôm not sure I‚Äôm getting the full proposal (do you mean that only objects are 1-field structs, say and then we have <code>x.out ‚ü∂  y.out</code> as the category of 1-cells from <code>x</code> to <code>y</code>?), can you link some code doing this so that I can be sure of what you mean?</p>",
        "id": 558167342,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1763548973
    },
    {
        "content": "<p>(In the two 1-categorical cases I cited, <code>Paths</code> and <code>Core</code>, the homs are not 1-field structure because there was a priori no way for lean to confuse <code>x.as ‚âÖ y.as</code> or <code>Paths x.as y.as</code> as homs in some other categories. For <code>DayFunctor</code>, a similar type alias in which the hom-types are already hom-type in other categories, I made the hom-types 1-field structures as well. Quite frankly, I can‚Äôt remember if this was purely out of \"let‚Äôs be safe\" or if I ran into problems by not making it so...)</p>",
        "id": 558169854,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1763549587
    },
    {
        "content": "<p>Here is the code: <a href=\"https://github.com/leanprover-community/mathlib4/pull/30925/files#diff-0ddf37b723590b6164533af42dc286d2dcf2f5db569873af30cbf12cf668abe5\">https://github.com/leanprover-community/mathlib4/pull/30925/files#diff-0ddf37b723590b6164533af42dc286d2dcf2f5db569873af30cbf12cf668abe5</a></p>\n<p>There, the objects are a 1-field structure. I am wondering if I should make it into a simple type synonym to better match the 1-categorical case. (Also note that the 2-morphisms are not yet a 1-field structure in that PR, I have not gotten around to fixing this yet since its blocked by other PRs anyway). So to be clear I want 1-homs and 2-homs to be 1-field structures, but not the objects.</p>",
        "id": 558170982,
        "sender_full_name": "Calle S√∂nne",
        "timestamp": 1763549873
    },
    {
        "content": "<p>I think that in the end it depends on how we intend to use <code>InducedBicategory</code>.</p>\n<p>It seems like the common usage of the 1-categorical pattern <code>InducedCategory</code> is to use as a step when defining instance on types which are their own structures/wrappers/aliases (e.g <code>ObjectProperty.FullSubcategory</code>, <code>CommMon</code>), instead of working directly with <code>x : InducedCategory foo</code> or phrasing things in terms of <code>InducedCategory</code> directly.</p>\n<p>For this usage, I agree that it would perhaps make less sense to have its objects be a one-field struct as this might just add extra steps/indirection at the wrongs place (instead, when defining a bicategory structure using <code>InducedBicategory</code>, if the type of objects needs to be an alias, then we can make that type a 1-field struct and induce along the projection just fine).</p>",
        "id": 558181376,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1763552912
    }
]