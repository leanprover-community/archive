[
    {
        "content": "<p>I've been thinking about non-standard analysis recently. We currently have a very bare-bones theory of hyperreals at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Hyperreal#doc\">docs#Hyperreal</a> - though note that two thirds of this file is deprecated at <a href=\"https://github.com/leanprover-community/mathlib4/pull/33650\">#33650</a>. I'm wondering if it'd be worth expanding this out, or whether the subject is too niche to have anything beyond the most basic theorems.</p>",
        "id": 572439735,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770401885
    },
    {
        "content": "<p>I guess we should ask <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> if he encountered any nonstandard analysis in the Annals :)</p>",
        "id": 572442146,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1770402807
    },
    {
        "content": "<p>To be clear, I don't want to re-do the theory of calculus that Mathlib already has using hyperreals, I think that effort would be redundant and quite naive. But I would like to at least prove some basic results: hyperreals are real-closed, there is a floor/ceiling function into the hyperintegers, they are an η₁ order, that kind of stuff.</p>",
        "id": 572442647,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770402998
    },
    {
        "content": "<p>I'd also like to point out that we probably don't even want the hyperreals themselves! We could very well define:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Hyper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">hyperfilter</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Germ</span><span class=\"w\"> </span><span class=\"n\">R</span>\n\n<span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"kn\">postfix</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"s2\">\"*\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Hyper</span>\n</code></pre></div>\n<p>And this lets us talk about hypernaturals, hyperintegers, etc. all at once. The vast majority if not all of non-standard analysis should generalize to the setting of a real-closed field.</p>",
        "id": 572443943,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770403506
    },
    {
        "content": "<p>I supervised the project which turned into the hyperreals (and I certainly didn't, and don't, have a good understanding of what we should have done, if it's not what Abhi did) but I didn't see any nonstandard analysis in the Annals. But that's not really relevant -- even though my personal view on where mathlib should be concentrating its efforts is \"towards stating recent papers in the top journals\" this is certainly not a view shared by all the maintainers, and indeed the maintainers are unable to come to a coherent position about what areas we'd like to see being developed because we have too many contradictory opinions on the matter :-)</p>",
        "id": 572450916,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770406256
    },
    {
        "content": "<p>Well, perhaps I could rephrase my question. Is there any maintainer with the domain knowledge to review my work if I started working on this?</p>",
        "id": 572453619,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770407499
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572443943\">said</a>:</p>\n<blockquote>\n<p>I'd also like to point out that we probably don't even want the hyperreals themselves! We could very well define:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Hyper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">hyperfilter</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Germ</span><span class=\"w\"> </span><span class=\"n\">R</span>\n\n<span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"kn\">postfix</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"s2\">\"*\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Hyper</span>\n</code></pre></div>\n<p>And this lets us talk about hypernaturals, hyperintegers, etc. all at once. The vast majority if not all of non-standard analysis should generalize to the setting of a real-closed field.</p>\n</blockquote>\n<p>A student (Daniel Perout) asked me recently about non-standard analysis in Lean. So I also recommended him doing something similar:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ultraFilter</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ultrafilter</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ultrafilter</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">atTop</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Converts a Type into a nonstandard Type using an ultrafilter,</span>\n<span class=\"sd\">for example `Ultra ℕ` are non-standard natural numbers. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Ultra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ultraFilter</span><span class=\"bp\">.</span><span class=\"n\">Product</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Your proposal might be more idiomatic (and working across universes, which I prefered not to start with for pedagogical reasons).</p>",
        "id": 572456001,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770408542
    },
    {
        "content": "<p>I would see as a nice test for a non-standard analysis system the proof of</p>\n<ul>\n<li>every continuous function on a closed interval has a maximum</li>\n</ul>\n<p>with the reasoning:</p>\n<ul>\n<li>subsample the interval on N points where N is nonstandard natural number, </li>\n<li>in the nonstandard world, this set of positions is finite, so we can find the position with maximal value.</li>\n<li>rounding the nonstandard value to a real value gives the maximum of the real continuous function</li>\n</ul>",
        "id": 572457090,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770409093
    },
    {
        "content": "<p>And by the way, here is a draft file of more detailed ideas of how imagined basic building blocks of the theory.<br>\n<a href=\"/user_uploads/3121/vwZHLSMSpn5-T_Ga0ZRXaE9n/Nonstandard.lean\">Nonstandard.lean</a></p>",
        "id": 572457354,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770409218
    },
    {
        "content": "<p>I don't think we have the stuff for finite types or the <code>app</code> function, but everything else should be in there.</p>",
        "id": 572457918,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770409465
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.Germ#doc\">docs#Filter.Germ</a> has a pretty good API from what I've seen and we can largely just reuse that</p>",
        "id": 572457945,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770409482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572457090\">said</a>:</p>\n<blockquote>\n<p>I would see as a nice test for a non-standard analysis system the proof of</p>\n<ul>\n<li>every continuous function on a closed interval has a maximum</li>\n</ul>\n<p>with the reasoning:</p>\n<ul>\n<li>subsample the interval on N points where N is nonstandard natural number, </li>\n<li>in the nonstandard world, this set of positions is finite, so we can find the position with maximal value.</li>\n<li>rounding the nonstandard value to a real value gives the maximum of the real continuous function</li>\n</ul>\n</blockquote>\n<p>Does this argument really work? I'm not confident you can write down \"every set of size <code>n</code> has a maximum element\" as a first-order predicate.</p>",
        "id": 572458091,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770409549
    },
    {
        "content": "<p>I would argue it works although at the same time, I didn't lay out very precisely how it is supposed to work (also depends on the exact way of building the system)</p>",
        "id": 572458298,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770409650
    },
    {
        "content": "<p>If I wanted to do this in some FOL, I just start with big enough model containing all the concepts -- functions, sets, and take the ultraproduct of that.</p>",
        "id": 572458454,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770409717
    },
    {
        "content": "<p>Of course \"every set of size <code>n</code> has a maximum element\" is true in ZFC for example (and some weaker systems too)</p>",
        "id": 572458538,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770409755
    },
    {
        "content": "<p>In a typed system, prefer to imagine what is going on. The <code>Ultra</code> type of nonempty finite sets is an infinite sequence of actual finite sets (modulo ultrafilter). The maximum of this <code>Ultra</code>-set is just the maximum taken element-wise.</p>",
        "id": 572458850,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770409910
    },
    {
        "content": "<p>By the way, I would use the nonstandard definition of \"continuous\": It is a standard function such that its lift returns infinitesimally close values at any two finitely large points that are infinitesimally close.</p>",
        "id": 572459425,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770410197
    },
    {
        "content": "<p>I'm new to Lean, though I've known of its existence for a while, but I've done research in Nonstandard Analysis.  I'll try to learn enough about Lean to look at what you want to do with this.</p>",
        "id": 572460139,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770410559
    },
    {
        "content": "<p>I'd prefer that someone include the theory of superstructures and non-standard enlargements in much more general terms than just the hyperreals.</p>",
        "id": 572460336,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770410659
    },
    {
        "content": "<p>I'd like to warn everyone that I know next-to-nothing about model theory. My interest in hyperreals is mostly just a by-product of my interest in the surreals, which have at least some surface-level similarities.</p>",
        "id": 572460392,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770410698
    },
    {
        "content": "<p>(In other words, I'll help, but I shouldn't be at the helm of any project)</p>",
        "id": 572460426,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770410721
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572459425\">said</a>:</p>\n<blockquote>\n<p>By the way, I would use the nonstandard definition of \"continuous\": It is a standard function such that its lift returns infinitesimally close values at any two finitely large points that are infinitesimally close.</p>\n</blockquote>\n<p>Is there a topology that recovers this? Or would we need a new <code>Hyper.Continuous</code> definition for this?</p>",
        "id": 572460997,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770410990
    },
    {
        "content": "<p>It can be proven equivalent to the classical definition.</p>",
        "id": 572461069,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770411028
    },
    {
        "content": "<p>Ah, then we should probably do that, rather than reinventing the theory of topology.</p>",
        "id": 572461238,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770411104
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1024662\">Matt Insall</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572460139\">said</a>:</p>\n<blockquote>\n<p>I'm new to Lean</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572460392\">said</a>:</p>\n<blockquote>\n<p>I'd like to warn everyone that I know next-to-nothing about model theory.</p>\n</blockquote>\n<p>When we are in the process of introducing ourselves <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> , I know just enough about nonstandard analysis to give a single talk about it (maybe two) -- defining hyper-reals &amp; other hyper-objects, prove Łoś's theorem, and prove the demo theorem I outlined above.</p>\n<p><span class=\"user-mention\" data-user-id=\"1024662\">@Matt Insall</span> , the difficulty is that I have seen NA usually done in FOL (Łoś's theorem in particular). Although Lean has Łoś's theorem in its model theory, it seems highly unpractical to use it because we work with different types in Lean, not in some FOL model. Do you know if there is an equivalent for Łoś in dependent type systems? Could you also look at the outline I have posted above? My idea was that first of all I want to be able to</p>\n<ul>\n<li>Lift any object of type <code>A</code> to a hyper-object <code>Hyper A</code> (with the constant sequence). This could be also done with functions, so we can lift <code>A -&gt; B</code> to <code>Hyper (A -&gt; B)</code></li>\n<li>Apply hyper-function to a hyper-object, so basically coerce <code>Hyper (A -&gt; B)</code> to <code>(Hyper A) -&gt; (Hyper B)</code></li>\n<li>In the case of finite types, un-hyper it, so get <code>A</code> from <code>Hyper A</code>. I imagine this particularly useful for <code>Prop</code>.</li>\n</ul>",
        "id": 572463327,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770412095
    },
    {
        "content": "<p>It's nice that you provide this, but I'm so new to using Lean that I don't know yet how to make use of the file Nonstandard.lean.  I downloaded it and tried to open it using my Lean extension in VS Code, but got an error message because I don't have in the folder a file called \"leantoolchain\".  This will take some getting accustomed to, because I'm not really very adept at programming...  The mathematics is my thing...</p>",
        "id": 572464202,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770412513
    },
    {
        "content": "<p>Well... There are caveats to this statement.</p>",
        "id": 572464833,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770412831
    },
    {
        "content": "<p>Ok, maybe not important to study the file, it contains some really Lean-specific constructs. What do you think about the three basic building blocks in the post just above? Also, what are your thoughts about Łoś's theorem for a system based on type theory (most importantly, DTT doesn't distinguish much propositions and types, there is no concept of FOL formula)?</p>",
        "id": 572464920,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770412874
    },
    {
        "content": "<p>Have you looked at Institution-Independent Model Theory?  (see <a href=\"https://www.google.com/url?sa=t&amp;source=web&amp;rct=j&amp;opi=89978449&amp;url=https://link.springer.com/book/10.1007/978-3-031-68854-6&amp;ved=2ahUKEwjT1vmM5sWSAxWpGlkFHfEwEEMQFnoECCYQAQ&amp;usg=AOvVaw3lcZYAxxH8zWxuABfyb1yJ\">https://www.google.com/url?sa=t&amp;source=web&amp;rct=j&amp;opi=89978449&amp;url=https://link.springer.com/book/10.1007/978-3-031-68854-6&amp;ved=2ahUKEwjT1vmM5sWSAxWpGlkFHfEwEEMQFnoECCYQAQ&amp;usg=AOvVaw3lcZYAxxH8zWxuABfyb1yJ</a>)</p>",
        "id": 572465097,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770412967
    },
    {
        "content": "<p>Those are good starts to the ideas of NSA.  To accomplish this, there are various paths in FOL, and ultrafilters provide one  such path;  Robinson originally used the compactness theorem, so any logic system (FOL or fragments of HOLs, etc) that satisfies a compactness theorem is likely to admit constructions like you suggest.</p>",
        "id": 572465535,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770413176
    },
    {
        "content": "<p>In DTT (again, I'm newish to thinking about things this way), it's my understanding that the mantra \"propositions as types\" applies.  In FOL, a proposition is a \"generic\" formula, in the sense that FOL formulas can be substituted for propositions in any propositional tautology and obtain an FOL universally valid formula.</p>",
        "id": 572465934,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770413384
    },
    {
        "content": "<p>BTW, you can get a PDF of Diaconescu's book, and in there, various institutions are investigated in terms of properties like the compactness principle, Łos Theorems, etc.  Maybe that can help you to see better whether a Łoš-type theorem holds in DTT.</p>",
        "id": 572466315,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770413593
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572463327\">said</a>:</p>\n<blockquote>\n<p>Although Lean has Łoś's theorem in its model theory, it seems highly unpractical to use it because we work with different types in Lean, not in some FOL model.</p>\n</blockquote>\n<p>What exactly is the problem? Say we want to prove every non-negative hyperreal has a square root. Then surely we can write some <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FirstOrder.Language.Sentence#doc\">docs#FirstOrder.Language.Sentence</a> in the language of ordered rings which spells this out, transfer it from ℝ into ℝ*, and then prove (likely via <code>simp</code>) that realizability of this sentence is equivalent to the actual proposition <code>∀ x ≥ 0, ∃ y, y² = x</code> that we want?</p>",
        "id": 572467039,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770413961
    },
    {
        "content": "<p>(I'm speaking from inexperience here, correct me if there's some subtlety I haven't considered)</p>",
        "id": 572467182,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770414049
    },
    {
        "content": "<p>These are not the kinds of results that non-standard analysits are trying to prove using nonstandard analysis.  A result such as \"Every  non-negative hyperreal has a square root\" are immediate results of the transfer principle, which can be viewed as either a truth-preserving syntactic transform or as a semantic transform on the hyperreal numbers.  </p>\n<p>While the transfer principle is an important tool of nonstandard analysis, one combines it with other important principles (concurrency principles or overspill principles or saturation principles) to draw new conclusions about the original standard models (the real number system with all of the objects of interest to analysts, in the case of the hyperreal numbers).</p>",
        "id": 572467762,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770414358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572467182\">said</a>:</p>\n<blockquote>\n<p>(I'm speaking from inexperience here, correct me if there's some subtlety I haven't considered)</p>\n</blockquote>\n<p>I have to confess, I have not tried to use the Model theory API myself, so I might be mistaken too.  Just the need to provide a model, theory, sentence, etc. scared me. Perhaps there is a convenient API... although when I asked in person <span class=\"user-mention\" data-user-id=\"631408\">@Jonas van der Schaaf</span>, he agreed it is not very reasonable to go through model theory.</p>",
        "id": 572467926,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770414449
    },
    {
        "content": "<p>It's not that you are wrong;  it's just that when you discuss results about real numbers holding for the hyperreals, you're only at the start of it all.</p>",
        "id": 572467938,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770414459
    },
    {
        "content": "<p>This is perhaps somewhat of a pointed question, but is this really what we want to do here? For instance, the result <span class=\"user-mention\" data-user-id=\"133339\">@Mirek Olšák</span>  mentions:</p>\n<blockquote>\n<p>every continuous function on a closed interval has a maximum</p>\n</blockquote>\n<p>Though we certainly want to build an API that's capable of proving this via hyperreal arguments, I don't think we actually want to add such an argument to Mathlib. This theorem already exists somewhere else.</p>",
        "id": 572468027,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770414509
    },
    {
        "content": "<p>I was rather thinking that we might need a dependent hyper-type (ultraproduct instead of ultra-power), so we can handle better dependent functions.</p>",
        "id": 572468035,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770414513
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.Product#doc\">docs#Filter.Product</a> ?</p>",
        "id": 572468104,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770414551
    },
    {
        "content": "<p>Even in FOL, thinking in terms of ultraproducts is important.  The theory of enlargements of superstructures really uses that.</p>",
        "id": 572468161,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770414593
    },
    {
        "content": "<p>What is that?</p>",
        "id": 572468299,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770414680
    },
    {
        "content": "<p>With filtered products, some aspects of the transfer principle become less immediate or false because (roughly) ultraproducts preserve negations and products filtered by non-maximal filters don't quite.</p>",
        "id": 572468387,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770414746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572468035\">said</a>:</p>\n<blockquote>\n<p>I was rather thinking that we might need a dependent hyper-type (ultraproduct instead of ultra-power), so we can handle better dependent functions.</p>\n</blockquote>\n<p>What sorts of things would we need dependent functions for? I was thinking that we could be able to use currying to our advantage; for instance, the statement <code>∀ x : ℝ, ∃ y : ℤ, y ≤ x &lt; y + 1</code> could first be rewritten as a statement on <code>ℝ × ℤ</code>, then transferred to <code>(ℝ × ℤ)* ≃ ℝ* × ℤ*</code>, then uncurried as <code>∀ x : ℝ*, ∃ y : ℤ*, y ≤ x &lt; y + 1</code>.</p>",
        "id": 572470044,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770415659
    },
    {
        "content": "<p>The notion of a superstructure is covered in the following texts:<br>\nHurd &amp; Loeb:  An Introduction to Nonstandard Real Analysis (<a href=\"https://books.google.com.fj/books?id=jgH3mmbs59IC&amp;printsec=frontcover#v=onepage&amp;q&amp;f=false\">https://books.google.com.fj/books?id=jgH3mmbs59IC&amp;printsec=frontcover#v=onepage&amp;q&amp;f=false</a>)<br>\nLoeb and Wolff (eds):  Nonstandard Analysis for the Working Mathematician (<a href=\"https://link.springer.com/book/10.1007/978-94-011-4168-0\">https://link.springer.com/book/10.1007/978-94-011-4168-0</a>)</p>\n<p>Briefly, begin with a set X_0, whose members are not sets (the elements of X_0 are called urelements), and recursively define, for each non-negative integer n,  </p>\n<p>X_{n+1}:=X_n\\cup P(X_n), </p>\n<p>where P is the power set operator.  </p>\n<p>The superstructure over X is the union of this tower of \"cumulative power sets\".  Denote it by S(X_0).  Then S(X_0) includes all of the set-theoretic entities of interest to analysts who want to study functions defined on X_0 and function spaces related to those, etc.  </p>\n<p>An enlargement of S(X_0) is given by forming an ultrapower of X_0 and the superstructure over that ultrapower and then the subsets of S(X_0) are \"stratified\" by a rank function in terms of where they first \"appear\" in the naturally occurring hierarchy determined by the cumulative power set construction.  Accordingly, the enlargement, denoted <em>S(</em>X_0), is not exactly an ultrapower of S(X_0), but the transfer principle applies for a fragment of FOL in which only bounded (by rank, essentially) quantifiers are allowed.</p>",
        "id": 572470118,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770415709
    },
    {
        "content": "<p>Oh, you are putting the stars on the right...  That can get confusing, but ok.</p>",
        "id": 572470203,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770415764
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1024662\">Matt Insall</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572470118\">said</a>:</p>\n<blockquote>\n<p>Briefly, begin with a set X_0, whose members are not sets (the elements of X_0 are called urelements), and recursively define, for each non-negative integer n,  </p>\n<p>X_{n+1}:=X_n\\cup P(X_n), </p>\n<p>where P is the power set operator.  </p>\n</blockquote>\n<p>What would be the Lean analogue of this? Some sigma type <code>Σ n, Set^[n] α</code>?</p>",
        "id": 572470455,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770415931
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1024662\">Matt Insall</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572470203\">said</a>:</p>\n<blockquote>\n<p>Oh, you are putting the stars on the right...  That can get confusing, but ok.</p>\n</blockquote>\n<p>Sorry, I thought this was the standard convention. What do you suggest?</p>",
        "id": 572470477,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770415943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572470455\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"1024662\">Matt Insall</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572470118\">said</a>:</p>\n<blockquote>\n<p>Briefly, begin with a set X_0, whose members are not sets (the elements of X_0 are called urelements), and recursively define, for each non-negative integer n,  </p>\n<p>X_{n+1}:=X_n\\cup P(X_n), </p>\n<p>where P is the power set operator.  </p>\n</blockquote>\n<p>What would be the Lean analogue of this? Some sigma type <code>Σ n, Set^[n] α</code>?</p>\n</blockquote>\n<p>not quite, since that doesn't contain <code>{a,{}}</code> for <code>a</code> a member of the X_0</p>",
        "id": 572470775,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770416123
    },
    {
        "content": "<p>In Hurd &amp;Loeb's text, and in the Loeb &amp; Wolff text, and in Robinson's work, the syntactic transform of a formula s is denoted by *s.  For the corresponding semantic transform (an elementary embedding between superstructures), an object a of type S(X_0) is mapped to an object *a of type *S(X_0), and this mapping is a morphism in the category of superstructures;  model theoretically, it's an embedding that preserves truth both ways -- an elementary embedding.</p>",
        "id": 572470933,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770416203
    },
    {
        "content": "<p>what you get are the finite rank ZFA sets with atoms from X_0</p>",
        "id": 572471013,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770416255
    },
    {
        "content": "<p>Yup</p>",
        "id": 572471047,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770416278
    },
    {
        "content": "<p>Finally an actual use for this: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lists#doc\">docs#Lists</a></p>",
        "id": 572471135,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770416318
    },
    {
        "content": "<p>doesn't contain infinite sets</p>",
        "id": 572471230,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770416360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572470044\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572468035\">said</a>:</p>\n<blockquote>\n<p>I was rather thinking that we might need a dependent hyper-type (ultraproduct instead of ultra-power), so we can handle better dependent functions.</p>\n</blockquote>\n<p>What sorts of things would we need dependent functions for? I was thinking that we could be able to use currying to our advantage; for instance, the statement <code>∀ x : ℝ, ∃ y : ℤ, y ≤ x &lt; y + 1</code> could first be rewritten as a statement on <code>ℝ × ℤ</code>, then transferred to <code>(ℝ × ℤ)* ≃ ℝ* × ℤ*</code>, then uncurried as <code>∀ x : ℝ*, ∃ y : ℤ*, y ≤ x &lt; y + 1</code>.</p>\n</blockquote>\n<p>Yes, I was first thinking of (as automatically as possible) translating proofs to the hyper-world. Applying theorem to a specific instance is a dependent function application. The basics I have so far only covers applying simple functions.</p>\n<p>But I can imagine this being extended to any dependent function. Say the function that takes a natural number <code>n</code>, and returns a zero matrix <code>n × n</code> Or we could have say nonstandard-large <code>x</code> of the (kind of) type <code>Fin N</code> for nonstandard <code>N</code>...</p>",
        "id": 572471239,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770416364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572471230\">said</a>:</p>\n<blockquote>\n<p>doesn't contain infinite sets</p>\n</blockquote>\n<p>haha nevermind then</p>",
        "id": 572471318,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770416405
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572471239\">said</a>:</p>\n<blockquote>\n<p>Yes, I was first thinking of (as automatically as possible) translating proofs to the hyper-world. Applying theorem to a specific instance is a dependent function application. The basics I have so far only covers applying simple functions.</p>\n<p>But I can imagine this being extended to any dependent function. Say the function that takes a natural number <code>n</code>, and returns a zero matrix <code>n × n</code> Or we could have say nonstandard-large <code>x</code> of the (kind of) type <code>Fin N</code> for nonstandard <code>N</code>...</p>\n</blockquote>\n<p>It's probably too early to think of automation, when we don't even have results to automate!</p>",
        "id": 572471969,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770416755
    },
    {
        "content": "<p>I'm not sure if we need a dependent function of Łos for this, though. Instead of translating a theorem <code>∀ n, ∀ x : Fin n, P x</code> via Łos, you could instead just translate <code>∀ n, ∀ x &lt; n, P x</code>, and hopefully in practice this is sufficient?</p>",
        "id": 572472615,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770417051
    },
    {
        "content": "<p>On the other hand, I don't see why I would want to limit myself to not using dependent types.</p>",
        "id": 572472931,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770417193
    },
    {
        "content": "<p>Well, if there's some easily provable version of Łos that allows for dependent types then we should just use that, yes</p>",
        "id": 572473045,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770417246
    },
    {
        "content": "<p>I was half-assuming this wasn't the case</p>",
        "id": 572473116,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770417284
    },
    {
        "content": "<p>And my intention was that rather than proving Łos, I would like it to come out as a result of the type system.</p>",
        "id": 572473130,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770417288
    },
    {
        "content": "<p>In what sense?</p>",
        "id": 572473369,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770417433
    },
    {
        "content": "<p>I half-recall similar conversations where people discussed a hypothetical tactic to automatically prove a function computable by translating its Lean code into a proof. Given that this hasn't happened, I imagine it's generally difficult to achieve this sort of behavior. </p>\n<p>But maybe this is unrelated to your idea.</p>",
        "id": 572473583,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770417566
    },
    {
        "content": "<p>It's perhaps a good idea to get the opinon of other people working in model theory in Lean before doing any big changes to that infrastructure.</p>",
        "id": 572473740,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770417664
    },
    {
        "content": "<p>Just to be clear, I don't want to change model theory in Lean. I was rather thinking of doing hyper-objects using different basics. I just thought it could be possible to avoid touching model theory's Łoś by going through the type system.</p>",
        "id": 572474013,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770417843
    },
    {
        "content": "<p>If you only want to study analysis of the real numbers using nonstandard methods, then you take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">X_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> to be a set equipollent to the real line.  If you only want to study number theory and combinatorics using nonstandard methods, take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">X_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> to be a countably infinite set.  In the first case, the structure of interest may be, say, the Archimedean ordered ring consisting of the real numbers, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo separator=\"true\">;</mo><mo>≤</mo><mo separator=\"true\">;</mo><mo>+</mo><mo separator=\"true\">,</mo><mo>⋅</mo><mo separator=\"true\">;</mo><mo>−</mo><mo separator=\"true\">;</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(R; \\leq; +, \\cdot; -; 0, 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">⋅</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, and the point of using superstructures for this is that this object is an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo stretchy=\"false\">(</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S(X_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, and the corresponding hyperreal number system, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∗</mo><mo stretchy=\"false\">(</mo><mi>R</mi><mo separator=\"true\">;</mo><mo>≤</mo><mo separator=\"true\">;</mo><mo>+</mo><mo separator=\"true\">,</mo><mo>⋅</mo><mo separator=\"true\">;</mo><mo>−</mo><mo separator=\"true\">;</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mo>∗</mo><mi>R</mi><mo separator=\"true\">;</mo><mo>∗</mo><mo>≤</mo><mo separator=\"true\">;</mo><mo>∗</mo><mo>+</mo><mo separator=\"true\">,</mo><mo>∗</mo><mo>⋅</mo><mo separator=\"true\">;</mo><mo>∗</mo><mo>−</mo><mo separator=\"true\">;</mo><mo>∗</mo><mn>0</mn><mo separator=\"true\">,</mo><mo>∗</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">*(R; \\leq; +, \\cdot; -; 0, 1)=(*R; *\\leq; *+, *\\cdot; *-; *0, *1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∗</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">⋅</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∗</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∗</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∗</span><span class=\"mord\">+</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∗</span><span class=\"mord\">⋅</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∗</span><span class=\"mord\">−</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∗</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∗</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> is an element of the enlargement, but also, if you want to study in the same context the real line as a topological space, then the set theoretic object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo separator=\"true\">;</mo><mi>τ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(R; \\tau)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"mclose\">)</span></span></span></span> is in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo stretchy=\"false\">(</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S(X_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> as well, and its nonstandard analog, the hyperreal line, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∗</mo><mo stretchy=\"false\">(</mo><mi>R</mi><mo separator=\"true\">;</mo><mi>τ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">*(R; \\tau)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∗</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"mclose\">)</span></span></span></span> is in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∗</mo><mi>S</mi><mo stretchy=\"false\">(</mo><mo>∗</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">*S(*X_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∗</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord\">∗</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, and the function spaces consisting of continuous functions on the line are objects of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo stretchy=\"false\">(</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S(X_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, and so they have analogues in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∗</mo><mi>S</mi><mo stretchy=\"false\">(</mo><mo>∗</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">*S(*X_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∗</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord\">∗</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, etc, etc, etc...</p>\n<p>The function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span></span></span></span> that maps an ordered ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>F</mi><mo separator=\"true\">;</mo><mo>≤</mo><mo separator=\"true\">;</mo><mo>+</mo><mo separator=\"true\">,</mo><mo>⋅</mo><mo separator=\"true\">;</mo><mo>−</mo><mo separator=\"true\">;</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(F; \\leq; +, \\cdot; -; 0, 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">⋅</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> to its ring reduct <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>F</mi><mo separator=\"true\">;</mo><mo>+</mo><mo separator=\"true\">,</mo><mo>⋅</mo><mo separator=\"true\">;</mo><mo>−</mo><mo separator=\"true\">;</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(F;+, \\cdot; -; 0, 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">⋅</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> is a forgetful functor with domain the superstructure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo stretchy=\"false\">(</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S(X_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>.  It is an example of a functor that is not an element of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo stretchy=\"false\">(</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S(X_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, because its domain is (of course) not an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo stretchy=\"false\">(</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S(X_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>.  Thus it does not strictly have a transform \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∗</mo><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">*\\phi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">∗</span><span class=\"mord mathnormal\">ϕ</span></span></span></span>\";  However, we can create one on the enlarged superstructure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∗</mo><mi>S</mi><mo stretchy=\"false\">(</mo><mo>∗</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">*S(*X_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∗</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord\">∗</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, because the set of all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo>∗</mo><mi>a</mi><mo separator=\"true\">,</mo><mo>∗</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(*a,*b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∗</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∗</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span> for which <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(a,b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span> is on the graph of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span></span></span></span> is a subset of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∗</mo><mi>S</mi><mo stretchy=\"false\">(</mo><mo>∗</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">*S(*X_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∗</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord\">∗</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> that happens to be a binary relation on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∗</mo><mi>S</mi><mo stretchy=\"false\">(</mo><mo>∗</mo><msub><mi>X</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">*S(*X_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∗</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord\">∗</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> with the function property.  </p>\n<p>The issue illustrated above is both a bug and a feature.  We cannot immediately apply the transfer principle to \\phi because it is not in the domain of the elementary embedding used for nonstandard methods on the universe constructed from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">X_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, but if we are careful in a manner similar to type theories, we can \"fudge\" it, as is done by many authors of nonstandard analysis articles.</p>",
        "id": 572474095,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770417904
    },
    {
        "content": "<p>(you can use double dollar signs $$ to write down LaTeX)</p>",
        "id": 572474130,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770417932
    },
    {
        "content": "<p>That is likely to depend upon which type system you are using.  Again, I point to Diaconescu and his rather informative text on institution independent model theory.</p>",
        "id": 572474188,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770417975
    },
    {
        "content": "<p>Thanks...  When I clicked on the math symbol in the toolbar, I was confused by what I saw...</p>",
        "id": 572474337,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770418084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572473369\">said</a>:</p>\n<blockquote>\n<p>In what sense?</p>\n</blockquote>\n<p>First, let's see, how a general dependent application should work. Let me denote <code>H A : Sort u</code> the hyper-type (ultrapower) of <code>A : Sort u</code>, and a dependent hyper-type <code>dH B : Sort u</code> for <code>B : H (Sort u)</code>. Recall that a non-dependent function <code>H (A → C)</code> can be lifted to <code>(H A) → (H C)</code>.</p>\n<p>Now, let's say, I have <code>A : Type</code>, <code>B : A → Type</code>, and a dependent hyper-function <code>f : H ((a : A) → B a)</code>. How does the hyper-lifting works here?</p>\n<p>The lifted <code>⇑f</code> should take <code>a : H A</code>, and return <code>b : dH (⇑B a)</code>.</p>\n<p>Now, let's consider the case of <code>B : A → Prop</code> being a proposition, and <code>f</code> being a theorem stating that <code>B</code> holds for every standard <code>a : A</code>. The same dependent function application gives us a function that takes <code>a : H A</code>, and returns <code>b : dH (⇑B a)</code>.</p>\n<p>My claim is that this is almost Łoś's Theorem, except we need to simplify the type of <code>b : dH (⇑B a)</code> into just <code>b' : (⇑B a).toBase : Prop</code>.</p>\n<p>That looks somewhat technical but doesn't seem impossible. Since <code>(⇑B a) : H Prop</code>, and <code>Prop</code> is finite, there is an isomorphism <code>H Prop ≅ Prop</code> translating <code>(⇑B a)</code> to the appropriate <code>B' : Prop := (⇑B a).toBase</code>. Under such circumstances, also the dependent hyper-object is not necessary because the type is not really a hyper-object, and should be able to simplify to <code>b' : H B'</code>.</p>",
        "id": 572484787,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770425492
    },
    {
        "content": "<p>One thing I've been wondering about (unrelated to the discussion thus far): <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Hyperreal#doc\">docs#Hyperreal</a> uses an ultrafilter on <code>ℕ</code>, but what if you want a higher level of saturation?</p>",
        "id": 572490928,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1770430471
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572468104\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.Product#doc\">docs#Filter.Product</a> ?</p>\n</blockquote>\n<p>I wonder if this definition is correct. If I understand correctly, whenever one of the factors is empty, the result is empty as well, even though a single item should not have an effect on the entire structure. I would expect the underlying type to be a partial function from an element of the filter to the types.</p>\n<p>Anyway, in the dependent  hyper-type I envision, we don't even have an explicit function <code>Nat -&gt; Type</code> but a <code>Hyper Type</code>, which makes the individual type elements even more irrelevant.</p>",
        "id": 572530042,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770469221
    },
    {
        "content": "<p>See also <a href=\"https://mathoverflow.net/questions/11261/is-the-ultraproduct-concept-fundamentally-category-theoretic\">https://mathoverflow.net/questions/11261/is-the-ultraproduct-concept-fundamentally-category-theoretic</a></p>",
        "id": 572565081,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1770495879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572443943\">said</a>:</p>\n<blockquote>\n<p>The vast majority if not all of non-standard analysis should generalize to the setting of a real-closed field.</p>\n</blockquote>\n<p>My understanding is that non-standard analysis needs more than just a real-closed field.</p>",
        "id": 572565360,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770496187
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572530042\">said</a>:</p>\n<blockquote>\n<p>I wonder if this definition is correct. If I understand correctly, whenever one of the factors is empty, the result is empty as well, even though a single item should not have an effect on the entire structure. I would expect the underlying type to be a partial function from an element of the filter to the types.</p>\n</blockquote>\n<p>You're right. The definition as written does not correctly handle empty types, although for many applications it really isn't an issue.</p>",
        "id": 572566940,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770498087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572566940\">said</a>:</p>\n<blockquote>\n<p>You're right. The definition as written does not correctly handle empty types, although for many applications it really isn't an issue.</p>\n</blockquote>\n<p>Then the question is: should someone fix it? If so, who should fix it? Could changing the definition cause complications in the uses so far?</p>\n<p>I can imagine that it should not make much difference in model theory which require each model to be non-empty. On the other hand, it could help in more native uses of ultraproducts, as discussed here.</p>",
        "id": 572567832,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770499121
    },
    {
        "content": "<p>It does make a little difference, see my answer at <a href=\"https://mathoverflow.net/questions/105397/there-are-two-slightly-different-notions-of-ultraproduct-why-is-one-said-to-be\">https://mathoverflow.net/questions/105397/there-are-two-slightly-different-notions-of-ultraproduct-why-is-one-said-to-be</a></p>",
        "id": 572568062,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1770499364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572567832\">said</a>:</p>\n<blockquote>\n<p>I can imagine that it should not make much difference in model theory which require each model to be non-empty. On the other hand, it could help in more native uses of ultraproducts, as discussed here.</p>\n</blockquote>\n<p>For what it's worth, not all model theorists agree about that convention.</p>",
        "id": 572568289,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770499647
    },
    {
        "content": "<p>I'm not sure \"agree\" is the right word, I believe all model theorists agree that <a href=\"https://en.wikipedia.org/wiki/Free_logic\">Free Logics</a> are a thing, but many don't use them, if only for the sake of simplicity.</p>",
        "id": 572568493,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1770499948
    },
    {
        "content": "<p>What I mean is that there are model theorists who think that allowing empty structures should be standard.</p>",
        "id": 572568523,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770499983
    },
    {
        "content": "<p>If I am looking correctly into Lean's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FirstOrder.Language.Theory.Model#doc\">docs#FirstOrder.Language.Theory.Model</a>, it allows empty domain.</p>",
        "id": 572568723,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770500207
    },
    {
        "content": "<p>Yes, it's not requiring that structures be non-empty.</p>",
        "id": 572568791,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770500292
    },
    {
        "content": "<p>but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FirstOrder.Language.Theory.ModelType#doc\">docs#FirstOrder.Language.Theory.ModelType</a> does bundle nonemptyness</p>",
        "id": 572568854,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770500363
    },
    {
        "content": "<p>If the theory T proves <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∃</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\exists x(x=x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> then it does not allow empty models.</p>",
        "id": 572568878,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1770500392
    },
    {
        "content": "<p>So it really depends on the definition of theory used there.</p>",
        "id": 572568915,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1770500426
    },
    {
        "content": "<p>well if the theory proves nonempty I would expect all its models to be nonempty</p>",
        "id": 572568944,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770500463
    },
    {
        "content": "<p>Oh, nonemptiness is explicitly assumed in Lean's Los theorem: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FirstOrder.Language.Ultraproduct.sentence_realize#doc\">docs#FirstOrder.Language.Ultraproduct.sentence_realize</a>, that's why it doesn't mind wrong ultraproduct <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 572568980,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770500511
    },
    {
        "content": "<p>In classical first-order logic with equality, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∃</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\exists x(x=x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> is provable from the empty theory.</p>",
        "id": 572568985,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1770500522
    },
    {
        "content": "<p>no I don't think so?</p>",
        "id": 572569002,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770500544
    },
    {
        "content": "<p>It depends on the particular proof system you use. In most treatments though, it is provable.</p>",
        "id": 572569031,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770500578
    },
    {
        "content": "<p>so we have different ideas about what \"classical first-order logic with equality\" means</p>",
        "id": 572569074,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770500640
    },
    {
        "content": "<p>my version doesn't prove nonempty</p>",
        "id": 572569116,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770500658
    },
    {
        "content": "<p>There is only one thing called \"classical first-order logic with equality\". The key is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">∃</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\lnot \\exists x(x = x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">¬∃</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> is equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo mathvariant=\"normal\">≠</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall x(x\\neq x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and this leads to a contradiction with the generalization rule and the reflexivity axiom. To avoid this, free logics impose restriction on generalization.</p>",
        "id": 572569317,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1770500909
    },
    {
        "content": "<p>An unrelated point: One thing to keep in mind is that there's really two applications in logic where you might want to 'take an ultrapower of the whole universe'. There's non-standard analysis, which we're already discussing, but then there's also certain things involving large cardinals.</p>\n<p>Like, if one ever wanted to formalize the fact that the existence of a measurable cardinal is equivalent to the existence of an exact functor from Set to Set that is not naturally isomorphic to the identity, having this kind of machinery would be useful.</p>",
        "id": 572569381,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770500965
    },
    {
        "content": "<p>That relates a bit to <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> question. My attitude is that ideally, the ultraproduct API should be developed so that it can deal with arbitrary ultrafilters, and the non-standard analysis should be not so large layer on top of it.<br>\nThere is one difference, in small ultraproducts, we only preserve finite types. For the use of large cardinals, this should be generalized based on the ultrafilter properties (as they preserve much more).</p>",
        "id": 572569553,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770501217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572473116\">said</a>:</p>\n<blockquote>\n<p>I was half-assuming this wasn't the case</p>\n</blockquote>\n<p>There should be a version of Łoś's theorem for (classical) DTT relative to Henkin semantics, because the Henkin semantics of DTT can be encoded faithfully in a first-order theory.</p>",
        "id": 572569984,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770501844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572569317\">said</a>:</p>\n<blockquote>\n<p>There is only one thing called \"classical first-order logic with equality\". The key is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">∃</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\lnot \\exists x(x = x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">¬∃</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> is equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo mathvariant=\"normal\">≠</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall x(x\\neq x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and this leads to a contradiction with the generalization rule and the reflexivity axiom. To avoid this, free logics impose restriction on generalization.</p>\n</blockquote>\n<p>I think you get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo separator=\"true\">,</mo><mtext>False</mtext></mrow><annotation encoding=\"application/x-tex\">\\forall x, \\text{False}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">False</span></span></span></span></span> but you can't conclude <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>False</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{False}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">False</span></span></span></span></span> from this unless you can prove nonempty.</p>",
        "id": 572570128,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770501994
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572570128\">said</a>:</p>\n<p>I think you get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo separator=\"true\">,</mo><mtext>False</mtext></mrow><annotation encoding=\"application/x-tex\">\\forall x, \\text{False}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">False</span></span></span></span></span> but you can't conclude <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>False</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{False}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">False</span></span></span></span></span> from this unless you can prove nonempty.</p>\n<hr>\n<p>That's true in Lean, but in classical first-order logic, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo separator=\"true\">,</mo><mtext>False</mtext></mrow><annotation encoding=\"application/x-tex\">\\forall x, \\text{False}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">False</span></span></span></span></span> implies False since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> does not occur free in False.</p>",
        "id": 572571023,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1770503091
    },
    {
        "content": "<p>then whatever rule says you can do that my version doesn't have that rule</p>",
        "id": 572571382,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770503598
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572569984\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572473116\">said</a>:</p>\n<blockquote>\n<p>I was half-assuming this wasn't the case</p>\n</blockquote>\n<p>There should be a version of Łoś's theorem for (classical) DTT relative to Henkin semantics, because the Henkin semantics of DTT can be encoded faithfully in a first-order theory.</p>\n</blockquote>\n<p>I can't recall whether they get to Łoś's theorem but Makkai and Reyes <a href=\"https://reyes-reyes.com/wp-content/uploads/2018/04/makkai-reyes-book.pdf\">First Order Categorical Logic</a> work through most of the framework to get there in a context that is similar to DTT.</p>",
        "id": 572571557,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1770503824
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572571382\">said</a>:</p>\n<blockquote>\n<p>then whatever rule says you can do that my version doesn't have that rule</p>\n</blockquote>\n<p>Your \"version\" is some kind of Free Logic then, not classical first-order logic with equality. By definition of classical first-order logic: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∃</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\exists x(x = x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> is a tautology of classical first-order logic with equality and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi mathvariant=\"normal\">∃</mi><mi>x</mi><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall x \\phi(x) \\to \\exists x \\phi(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> is a theorem of classical first-order logic (with or without equality).</p>",
        "id": 572571610,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1770503917
    },
    {
        "content": "<p>I wonder if rather than discussing model-theoretic terminology &amp; proof systems, we could agree (or not):</p>",
        "id": 572572470,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770505056
    },
    {
        "content": "<p>(1) That the ultra-product definition should be changed</p>",
        "id": 572572477,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770505062
    },
    {
        "content": "<p>(2) To add API to translate a <code>Germ</code> back to the original type in case of a finite type</p>",
        "id": 572572486,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770505068
    },
    {
        "content": "<p>(3) To add another product-like API to allow <code>T : Germ filter Type</code> as the base type for the ultra-product</p>",
        "id": 572572490,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770505072
    },
    {
        "content": "<p>(4) That we don't want Lean-level Łoś's theorem explicitly (because inducting on the size of Lean term doesn't make much sense), and rather just support well propagating dependent function applications through the ultra-products.</p>",
        "id": 572572494,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770505076
    },
    {
        "content": "<p>The way to unify the two ultraproduct definitions is to take a classical ultraproduct of <code>Option A_i</code> instead of just <code>A_i</code> but then you need to throw out elements that are <code>none</code> almost always according to the ultrafilter.</p>",
        "id": 572572658,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1770505253
    },
    {
        "content": "<p>or you could take a colimit over functions defined on sets in the filter</p>",
        "id": 572572782,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770505374
    },
    {
        "content": "<p>I think you missed the word \"unify\".</p>",
        "id": 572572808,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1770505407
    },
    {
        "content": "<p>The \"free\" ultraproduct is <code>Equiv</code> to the subtype of the classical ultraproduct as I explained above. The <code>Equiv</code> can be used to transfer theorems.</p>",
        "id": 572572986,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1770505613
    },
    {
        "content": "<p>Do you think it is worth it to keep the more basic definition?</p>",
        "id": 572573009,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770505638
    },
    {
        "content": "<p>By the way, Lean also has <code>Part</code> which is very similar to <code>Option</code>. I am not exactly sure what is better here.</p>",
        "id": 572573071,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770505691
    },
    {
        "content": "<p>I don't know. But \"more basic\" is unclear. The reason Model Theory uses the \"less basic\" definition is that very early on, when he initiated what became Model Theory, Tarski showed that multiple sorts and empty domains could be faithfully interpreted in classical first-order logic (which is single-sorted and doesn't allow an empty universe). Tarski also explained that this simplifies many logical rules.</p>\n<p>That was around 90 years ago. Does it need to be revised today? I'm not sure but I'm fine with updating archaic definitions and decisions. I personally think reconsidering established ideas and definitions should happen periodically. Tarski's realization still remains:  multi-sorted, empty sorts, and even dependent types can be faithfully interpreted in first-order logic.</p>",
        "id": 572573783,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1770506311
    },
    {
        "content": "<p>The stars usually go on the left in the literature, but I saw today in the Mathlib that there the stars are on the right, like you’re doing. What is used for complex numbers, conjugation, and in  complex hole spaces, the conjugate transpose?  In that literature, one often sees a star on the right, so this can be confusing when working on the nonstandard complex numbers and related structures.</p>",
        "id": 572574219,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770506821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572490928\">said</a>:</p>\n<blockquote>\n<p>One thing I've been wondering about (unrelated to the discussion thus far): <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Hyperreal#doc\">docs#Hyperreal</a> uses an ultrafilter on <code>ℕ</code>, but what if you want a higher level of saturation?</p>\n</blockquote>\n<p>I’m new enough to not know how best to discuss how you’d do this in LEAN, but in practice, instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, you use an indexing set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> of higher cardinality than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">ℵ</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\aleph_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">ℵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> for this. A related notion is <strong>polysaturation</strong>, and I would hope to see in LEAN someday an implementation of that. I guess that means I hope for a type named something like “polysaturated enlargement”.</p>",
        "id": 572574693,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770507376
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572530042\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572468104\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.Product#doc\">docs#Filter.Product</a> ?</p>\n</blockquote>\n<p>I wonder if this definition is correct. If I understand correctly, whenever one of the factors is empty, the result is empty as well, even though a single item should not have an effect on the entire structure. I would expect the underlying type to be a partial function from an element of the filter to the types.</p>\n<p>Anyway, in the dependent  hyper-type I envision, we don't even have an explicit function <code>Nat -&gt; Type</code> but a <code>Hyper Type</code>, which makes the individual type elements even more irrelevant.</p>\n</blockquote>\n<p>Even for direct product, if any factor is empty, the product should be empty, and hence for filtered products, that would happen as well, because a filtered product in a concrete category is a quotient of a direct product. In more general categories, while I’ve not delved into the details, I expect that the same would hold. </p>\n<p>It can help to keep in mind that many constructs like sum and product, a special case is addition of natural numbers and multiplication in natural numbers. Consequently, in the natural numbers, multiplication of cardinal numbers can be modeled in terms of direct products, so that a direct product involving a finite sequence of finite sets of certain cardinalities will have as its cardinality the product of the individual cardinalities of its factors, so if one of them is empty (and hence of zero cardinality), then the direct product has zero cardinality. This carries over to general direct products (e.g. with infinitely many factors), and then for filtered products even more-so, since surjections cannot increase cardinality, and quotients can be realized as ranges of canonical surjections.</p>",
        "id": 572575262,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770508161
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"1024662\">@Matt Insall</span>  I know that if you use the definition: \"Build the standard product, and then factor out by an ultrafilter\" (which is exactly what Lean does), then a single empty type collapses this construction. The question rather was if this is intended -- I would rather expect it is not. So I am asking if there is any need for this current definition as opposed to:</p>\n<ul>\n<li>We are building ultraproduct based on a function <code>T : Nat -&gt; Type</code></li>\n<li>The base type will be partial functions <code>x : (n : Nat) -&gt; T n</code> such that their domain is in the filter (the current definition would use full functions).</li>\n<li>We take the quotient of the base type as usual</li>\n</ul>",
        "id": 572576487,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770509291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572565360\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572443943\">said</a>:</p>\n<blockquote>\n<p>The vast majority if not all of non-standard analysis should generalize to the setting of a real-closed field.</p>\n</blockquote>\n<p>My understanding is that non-standard analysis needs more than just a real-closed field.</p>\n</blockquote>\n<p>Most of nonstandard mathematics needs much more than enlargements of a real-closed field. To find out more, I’d suggest that you read the book by Loeb and Wolff, but even as early as the 1960s, Abraham Robinson was discussing the use of nonstandard analysis to study Lie groups, which aren’t fields at all.</p>",
        "id": 572577237,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770510489
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572566940\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572530042\">said</a>:</p>\n<blockquote>\n<p>I wonder if this definition is correct. If I understand correctly, whenever one of the factors is empty, the result is empty as well, even though a single item should not have an effect on the entire structure. I would expect the underlying type to be a partial function from an element of the filter to the types.</p>\n</blockquote>\n<p>You're right. The definition as written does not correctly handle empty types, although for many applications it really isn't an issue.</p>\n</blockquote>\n<p>I’m not sure what’s wrong with the definition, probably just because I’ve not yet learnt enough of LEAN.</p>",
        "id": 572577589,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770510845
    },
    {
        "content": "<p>Here is one option how we could build a better ultra-product on top of the existing one. Perhaps the proof could be improved (I feel a bit cumbersome whenever proving something with quotients...)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">Product</span><span class=\"bp\">.</span><span class=\"n\">satisfies</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">Product</span><span class=\"w\"> </span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">filter</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">setoid</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">productSetoid</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">one_side</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">sets_of_superset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">inter_sets</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"n\">elem</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">elem_x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">elem_eq</span><span class=\"bp\">⟩</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_setOf_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">elem_x</span><span class=\"w\"> </span><span class=\"n\">elem_eq</span><span class=\"w\"> </span><span class=\"bp\">⊢</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">elem_eq</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">elem_x</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">eq</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq_iff_iff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">constructor</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">one_side</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">eq</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">one_side</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">BetterProduct</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">Product</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Part</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">satisfies</span><span class=\"w\"> </span><span class=\"n\">Part</span><span class=\"bp\">.</span><span class=\"n\">Dom</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 572577987,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770511319
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572568062\">said</a>:</p>\n<blockquote>\n<p>It does make a little difference, see my answer at <a href=\"https://mathoverflow.net/questions/105397/there-are-two-slightly-different-notions-of-ultraproduct-why-is-one-said-to-be\">https://mathoverflow.net/questions/105397/there-are-two-slightly-different-notions-of-ultraproduct-why-is-one-said-to-be</a></p>\n</blockquote>\n<p>Thanks for linking that. Accordingly, I suggest that the more categorical version be adopted (Type 2 in the linked mathoverflow question).</p>",
        "id": 572580824,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770514923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572568523\">said</a>:</p>\n<blockquote>\n<p>What I mean is that there are model theorists who think that allowing empty structures should be standard.</p>\n</blockquote>\n<p>I recall that when I was learning model theory I was at some point forgetting that it was assumed that empty structures weren’t allowed, and I became concerned that this meant that there were issues with universal quantification, in that an empty model of FOL would vacuously satisfy both <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo mathvariant=\"normal\">≠</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\forall x)(x\\neq x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>  and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\forall x)(x=x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, but reviewing and finding that structures are nonempty calmed me down about that. Now, the issue seems to be resurfacing…</p>\n<p>Of course, it is possible to construct an alternative approach that allows empty structures but avoid semantic discombobulation, but I didn’t see the need to concern myself with that, since I expected that results can be “ported over” between them…. </p>\n<p>Shouldn’t a system like LEAN and its mathlib be built with flexibility in mind?</p>\n<p>Regarding some issues raised in the mathoverflow linked by Francois, in universal algebra, algebras are presumed to be nonempty (“inhabited types”?), but I was at a universal algebra workshop attended by a number of computer scientists and category theorists who wanted to allow empty algebras;  in any case, universal algebraic call a one element algebra “trivial”, as is done in group theory for singleton groups. In topology, the empty space is available, but in my experience is typically avoided more for a lack of interesting results than anything else. In continuum theory (a branch of topology), it’s typical to require all continua to be nonempty, and a continuum having only one element is called “degenerate”.</p>",
        "id": 572581776,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770516252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1024662\">Matt Insall</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572581776\">said</a>:</p>\n<blockquote>\n<p>Shouldn’t a system like LEAN and its mathlib be built with flexibility in mind?</p>\n</blockquote>\n<p>Lean's logical basis is not first-order logic and it does treat the empty domain issue correctly. The issue is a technical one: do you want to formalize classical model theory à la Tarski or a more permissive model theory with multiple sorts, including empty sorts? The latter is more difficult but it is manageable. For example, I formalized basics of multi-sorted equational logic a long time ago in Lean 3 &lt;<a href=\"https://github.com/fgdorais/lean-universal\">https://github.com/fgdorais/lean-universal</a>&gt;. (I think I have an old attempt at a Lean 4 update for that but I lost interest so its at best very dusty by now.)</p>",
        "id": 572582743,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1770517798
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1024662\">Matt Insall</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572574693\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572490928\">said</a>:</p>\n<blockquote>\n<p>One thing I've been wondering about (unrelated to the discussion thus far): <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Hyperreal#doc\">docs#Hyperreal</a> uses an ultrafilter on <code>ℕ</code>, but what if you want a higher level of saturation?</p>\n</blockquote>\n<p>but in practice, instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, you use an indexing set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> of higher cardinality than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">ℵ</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\aleph_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">ℵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> for this.</p>\n</blockquote>\n<p>Right, I know.  This was my question. I should have asked more it directly as \"why isn't the definition of hyperreal parameterized over the index set?\"</p>",
        "id": 572583021,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1770518310
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572568878\">said</a>:</p>\n<blockquote>\n<p>If the theory T proves <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∃</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\exists x(x=x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> then it does not allow empty models.</p>\n</blockquote>\n<p>I would like to agree, IF by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∃</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">(\\exists x)\\phi </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∃</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">ϕ</span></span></span></span>, one means the classical semantic interpretation (e.g. Tarskian semantics).</p>\n<p>However, here’s a conundrum I alluded to a little while ago:  if empty models are allowed, then in the Tarskian inductive definition of satisfaction, any empty model satisfies both <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\forall x)(x=x) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo mathvariant=\"normal\">≠</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\forall x)(x\\neq x) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> vacuously, as there’s no member of the domain to falsify either one. The usual FOL axiom scheme makes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">(\\forall x)\\phi </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">ϕ</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>ϕ̸</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\forall x)(\\not\\phi) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mclose\">)</span></span></span></span> incompatible, as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(̸</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\not(\\forall x)\\phi </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">ϕ</span></span></span></span> is derivable from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>ϕ̸</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\forall x)(\\not\\phi) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mclose\">)</span></span></span></span>. Thus empty structures have a theory that proves every formula—from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo mathvariant=\"normal\">≠</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\forall x)(x\\neq x) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> derive <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(̸</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\not(\\forall x)(x=x) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\forall x)(x=x) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(̸</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\not(\\forall x)(x=x) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, derive all FOL formulas. But this means that such a theory proves also <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∃</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\exists x)(x=x) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∃</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, so that it has no empty models. </p>\n<p>Thus I think that by allowing empty models, you implicitly don’t use classical FOL.</p>",
        "id": 572602732,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770539461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572583021\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"1024662\">Matt Insall</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572574693\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572490928\">said</a>:</p>\n<blockquote>\n<p>One thing I've been wondering about (unrelated to the discussion thus far): <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Hyperreal#doc\">docs#Hyperreal</a> uses an ultrafilter on <code>ℕ</code>, but what if you want a higher level of saturation?</p>\n</blockquote>\n<p>but in practice, instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, you use an indexing set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> of higher cardinality than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">ℵ</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\aleph_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">ℵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> for this.</p>\n</blockquote>\n<p>Right, I know.  This was my question. I should have asked more it directly as \"why isn't the definition of hyperreal parameterized over the index set?\"</p>\n</blockquote>\n<p>Parametrizing only over the index set doesn't make much sense (an ultrafilter on <code>Nat</code> can be always trivially extended to larger sets without changing the hyper-reals). If something, it could be parametrized by the filter (together with the index set).</p>\n<p>For the elementary non-standard analysis I know, any non-principal ultrafilter on any set (so for example Nat) is good enough (okay, as long as it is not ω₁-complete), so not having to carry the filter around is just a matter of convenience.  As I <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572569553\">already wrote</a>, I agree that building most of the background theory on general <code>Filter.Germ</code> and <code>Filter.Product</code> is desirable but to showcase nonstandard analysis, I don't think we need the flexibility.</p>",
        "id": 572604220,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770541197
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572604220\">said</a>:</p>\n<blockquote>\n<p>(an ultrafilter on <code>Nat</code> can be always trivially extended to larger sets without changing the hyper-reals)</p>\n</blockquote>\n<p>What do you mean by this? You can get different hyperreals by using different ultrafilters in the ultraproduct.</p>",
        "id": 572623533,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770559695
    },
    {
        "content": "<p>For every ultrafilter F1 on Nat, and for every infinite set X, there exists an ultrafilter F2 on X such that hyperreals constructed from F1 are isomorphic to hyperreals constructed from F2.</p>",
        "id": 572623641,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770559796
    },
    {
        "content": "<p>Sure but really the question is why is it not parameterized over the ultrafilter.</p>",
        "id": 572623688,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770559847
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572604220\">said</a>:</p>\n<blockquote>\n<p>If something, it could be parametrized by the filter</p>\n</blockquote>",
        "id": 572623731,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770559895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1024662\">Matt Insall</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572602732\">said</a>:</p>\n<blockquote>\n<p>The usual FOL axiom scheme makes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">(\\forall x)\\phi </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">ϕ</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>ϕ̸</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\forall x)(\\not\\phi) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mclose\">)</span></span></span></span> incompatible, as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(̸</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\not(\\forall x)\\phi </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">ϕ</span></span></span></span> is derivable from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>ϕ̸</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\forall x)(\\not\\phi) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mclose\">)</span></span></span></span>.</p>\n</blockquote>\n<p>It sounds to me that there's an axiom (or axioms) in this FOL axiom scheme which is equivalent to assuming your domain is nonempty, so to allow empty models you can just remove this axiom.</p>",
        "id": 572624982,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770561133
    },
    {
        "content": "<p>I think it’s important for LEAN to be accessible to people doing mathematics the way mathematicians do it, and classical FOL was built accordingly by Tarski, et. al., as mentioned previously in this thread. Otherwise, formalizing nonstandard analysis and standard mathematics are less attractive to practicing mathematicians or their students. </p>\n<p>I programmed in Fortran and Basic, and avoided programming for years because it showed me down in thinking about mathematics, then I taught myself some prolog and a tiny bit of pascal, but they didn’t help more than reading and thinking and writing, but they took away time from those more productive activities. I’ve hoped for a while to learn of some prof assistants that I could use, so I’m hopeful that LEAN would perhaps be such, but if it takes more hours of programming and correcting syntax or typos than actual thinking about mathematics, I expect that I may stop finding it to be a worthwhile investment of time.   </p>\n<p>I know many other mathematicians who find the idea of trying to get computers to help with pure mathematics to not be a good use of their time, so if the implementation is far away from what they use, I don’t see them helping too popularize LEAN, especially among their most promising students. Already, I went through the pain of learning LaTeX after being abandoned by the whysiwig editor ChiWriter, and I probably was delayed enough by that time sink that I’m a dozen articles shy of where I would have been if ChiWriter had survived the transition from dos to windows. </p>\n<p>I’d rather do BASH programming than go through that kind of thing again.</p>",
        "id": 572628386,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770563967
    },
    {
        "content": "<p>If you want to assume your models are nonempty you can add <code>Nonempty</code> assumptions and if you want to assume your theory is nonempty you union with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FirstOrder.Language.nonemptyTheory#doc\">docs#FirstOrder.Language.nonemptyTheory</a>. But I don't want to make it harder to talk about theories which don't prove nonemptiness.</p>",
        "id": 572628818,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770564389
    },
    {
        "content": "<p>Just catching up on the discussion now. IIUC, a <em>better</em> version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.Product#doc\">docs#Filter.Product</a> should be something along the following lines:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">sets</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">betterProductSetoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">f</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"n\">g</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ht</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ht</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">iseqv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">betterProduct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">betterProductSetoid</span><span class=\"w\"> </span><span class=\"n\">ε</span>\n</code></pre></div>",
        "id": 572631934,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1770567373
    },
    {
        "content": "<p>Yes, that should be isomorphic to <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572577987\">this construction</a>.</p>",
        "id": 572632152,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770567616
    },
    {
        "content": "<p>“an ultrafilter on <code>Nat</code> can be always trivially extended to larger sets without changing the hyper-reals”</p>\n<p>I’m not sure what this means. In model theory (not just in nonstandard analysis), to use ultrafilters (or even just filters that aren’t maximal, for that matter) for specific purposes, one often needs to choose the indexing set in a way that is closely related to the problem at hand, and then carefully select a filter base, so that the filter or ultrafilter obtained eventually has properties that make the constructed ultraproduct (or more generally, filtered product)  accomplish certain desired higher order properties. Saturation and polysaturation are such properties.</p>",
        "id": 572644758,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770579374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1024662\">Matt Insall</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572644758\">said</a>:</p>\n<blockquote>\n<p>Saturation and polysaturation are such properties.</p>\n</blockquote>\n<p>What do you mean by 'polysaturation'?</p>",
        "id": 572644916,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770579579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572623641\">said</a>:</p>\n<blockquote>\n<p>For every ultrafilter F1 on Nat, and for every infinite set X, there exists an ultrafilter F2 on X such that hyperreals constructed from F1 are isomorphic to hyperreals constructed from F2.</p>\n</blockquote>\n<p>If you switch the roles of <code>X</code> and <code>Nat</code> here I think this is false, which is why I was talking about parameterizing over the index set (and yes, also the filter).</p>",
        "id": 572646384,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1770581064
    },
    {
        "content": "<p>there are <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><msup><mn>2</mn><mi mathvariant=\"fraktur\">c</mi></msup></msup></mrow><annotation encoding=\"application/x-tex\">2^{2^\\mathfrak{c}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9024em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9024em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7705em;\"><span style=\"top:-2.931em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathfrak mtight\">c</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> many ultrafilters on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> only has <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"fraktur\">c</mi></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{c}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4753em;\"></span><span class=\"mord mathfrak\">c</span></span></span></span> many countable subsets and each subset has at most <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi mathvariant=\"fraktur\">c</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^\\mathfrak{c}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6957em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6957em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathfrak mtight\">c</span></span></span></span></span></span></span></span></span></span></span> ultrafilters on it, so there must be ultrafilters not coming from a countable subset.</p>",
        "id": 572646783,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770581462
    },
    {
        "content": "<p>My point was, if we use the proposed</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Hyper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">hyperfilter</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Germ</span><span class=\"w\"> </span><span class=\"n\">R</span>\n</code></pre></div>\n<p>and only change <code>ℕ</code> to be a parameter, it doesn't help much because <code>Filter.hyperfilter</code> can be arbitrary cofinite filter, so it could be one coming from a countable subset.</p>\n<p>If not, and are parametrizing over the filter, then we are not building any new definition, the definition is already called <code>Germ</code>.</p>",
        "id": 572647159,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770581877
    },
    {
        "content": "<p>Incidentally, where did the term <code>hyperfilter</code> come from? I don't feel like it's in common use.</p>",
        "id": 572647361,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770582075
    },
    {
        "content": "<p>I'm a little confused by this discussion. We do have general ultraproducts over ultrafilters c.f. <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/Ultraproducts.html#FirstOrder.Language.Ultraproduct.structure\">FirstOrder.Language.Ultraproduct.structure</a> (this would require fixing <code>Filter.Product</code> as discussed above)</p>",
        "id": 572647997,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1770582652
    },
    {
        "content": "<p>Saturation in nonstandard methods is describable in terms of the cardinality of the subsets of the original model or its enlargement to which a variant of the concurrency principle can be applied. When constructing enlargements only using a denumerable indexing set, one obtains the concurrency principle for subsets of the original model. Given a concurrent binary relation r in the original superstructure S (a relation such that for any finite subset F of dom(r), there exists an element b in range(r) such that arb for every a in F), there a single element y in the enlargement *S that inhabits <em>range(</em>r) such that for all a in dom(r), <em>a</em>rb.  This is a path to yield the overspill principle in nonstandard mathematics, and that’s one of the ways we can prove that a proper enlargement of a superstructure constructed over the reals includes positive infinitesimals. This kind of concurrency principle is available because of countable saturation. It’s the weakest form of concurrency used in nonstandard analysis. Stronger forms allow consideration of binary relations that are entities in the enlargement *S rather than just in the original superstructure S. The books by Hurd and Loeb give careful definitions that I’ll reproduce below, but I wanted to start with the way nonstandard analysts use saturated models before getting to how they use polysaturated enlargements. </p>\n<p>From the book by Hurd &amp; Loeb:  <br>\n“ 8.1 Definition <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo stretchy=\"false\">(</mo><mo>∗</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">V(*X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mopen\">(</span><span class=\"mord\">∗</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>-saturated if, for each internal binary relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>∈</mo><mi>V</mi><mo stretchy=\"false\">(</mo><mo>∗</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P\\in V(*X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mopen\">(</span><span class=\"mord\">∗</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> which is concurrent (Definition 5.9) on some (not necessarily internal) set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo stretchy=\"false\">(</mo><mo>∗</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">V(*X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mopen\">(</span><span class=\"mord\">∗</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mi>a</mi><mi>r</mi><mi>d</mi><mi>A</mi><mo>&lt;</mo><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">card A &lt; \\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>, there exists an element <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">y \\in range P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> so that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">(x,y) \\in P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">x \\in A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>. ”</p>\n<p>Accordingly, the kind of saturation that is enough to get infinitesimals via the concurrency principle or overspill is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">ℵ</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\aleph_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">ℵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> saturation. </p>\n<p>From the book by Loeb &amp; Wolff:  <br>\n“For-saturation, the cardinal number should be determined by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">V(X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span>; it must not depend on objects in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo stretchy=\"false\">(</mo><mo>∗</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">V(* X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mopen\">(</span><span class=\"mord\">∗</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span>, because these can change depending on the monomorphism. It is sufficient, therefore, to fix <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> as the first cardinal number larger than the cardinality of the original superstructure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">V(X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span>. One then says that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">V( X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> is polysaturated.”</p>\n<p>What is often most useful is to assume in a given work that all nonstandard enlargements are polysaturated, so that one can neglect checking cardinalities of the domains, as long as they’re chosen from the original superstructure.</p>",
        "id": 572648034,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770582676
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572647997\">said</a>:</p>\n<blockquote>\n<p>I'm a little confused by this discussion. We do have general ultraproducts over ultrafilters c.f. <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/Ultraproducts.html#FirstOrder.Language.Ultraproduct.structure\">FirstOrder.Language.Ultraproduct.structure</a> (this would require fixing <code>Filter.Product</code> as discussed above)</p>\n</blockquote>\n<p><a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572568980\">#mathlib4 &gt; Non-standard analysis @ 💬</a></p>",
        "id": 572648079,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770582729
    },
    {
        "content": "<p>Okay, even better!</p>",
        "id": 572648121,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1770582753
    },
    {
        "content": "<p>Sorry, this thread is quite long and I haven't been following it from the beginning :)</p>",
        "id": 572648133,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1770582772
    },
    {
        "content": "<p>no worry</p>",
        "id": 572648172,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770582820
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572647361\">said</a>:</p>\n<blockquote>\n<p>Incidentally, where did the term <code>hyperfilter</code> come from? I don't feel like it's in common use.</p>\n</blockquote>\n<p>Where does this term occur?  In nonstandard mathematics, if I start with a lattice L contained in a set X whose elements are urelements (not sets), and form a superstructure S(X), and then an enlargement <em>S(</em>X) of that original superstructure, then I would call an entity f in <em>V(</em>X) a <strong>hyperfilter</strong> provided that it is a member of *filt(K) for some member K of *Latt_j, where Latt_j is the collection of all lattices in S(X) of rank j or less for some natural number j.</p>\n<p>An equivalent terminology would be “f is an internal filter in the enlargement <em>V(</em>S)”.</p>",
        "id": 572648774,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770583338
    },
    {
        "content": "<p>Ok, so I looked again and I see that your comment, James, was about the proposal mentioned by Mirek. I’m not sure yet if Mirek’s usage matches mine…</p>\n<p>Note that my usage is consonant with the usual usage in NSA (nonstandard analysis) of the prefix “hyper- “.  The hyperfinite subsets are the members of the enlargement of the collection of finite subsets of a superstructure.</p>",
        "id": 572651014,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770585326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572647361\">said</a>:</p>\n<blockquote>\n<p>Incidentally, where did the term <code>hyperfilter</code> come from? I don't feel like it's in common use.</p>\n</blockquote>\n<p>Apparently, it is in Mathlib since its first construction of hyper-reals: <a href=\"https://github.com/leanprover-community/mathlib3/commit/e8bdc7fc14c6d56d4040892d16929f310e9d03d5\">a923247</a>, by <span class=\"user-mention\" data-user-id=\"130500\">@Abhimanyu Pallavi Sudhir</span> . I would name it just <code>Filter.ultrafilter</code>.</p>",
        "id": 572652704,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770586827
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ultrafilter.of#doc\">docs#Ultrafilter.of</a></p>",
        "id": 572652761,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1770586901
    },
    {
        "content": "<p>We are discussing</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">hyperfilter</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ultrafilter</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ultrafilter</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">cofinite</span>\n</code></pre></div>\n<p>in mathlib <a href=\"https://github.com/leanprover-community/mathlib4/blob/4994494bf98173a5175569e85b6f5241e0c6085c/Mathlib/Order/Filter/Ultrafilter/Basic.lean#L93-L95\">here</a></p>",
        "id": 572652932,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770587098
    },
    {
        "content": "<p>I realize that, and I'm suggesting that we don't need the definition at all (leastways because it is poorly named).</p>",
        "id": 572653074,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1770587212
    },
    {
        "content": "<p>I can work on a PR to deprecate this definition, but I'd like to get <a href=\"https://github.com/leanprover-community/mathlib4/pull/33650\">#33650</a> out of the way first.</p>",
        "id": 572653291,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770587455
    },
    {
        "content": "<p>I guess the psychological reason for that definition is that it feels more \"fixed\" than constructing each time an ultrafilter out of the cofinite one (although it is fixed in Lean as well). We want to fix an arbitrary non-principal ultrafilter, and then do something with it. But I don't mind removing it.</p>",
        "id": 572653371,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770587561
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572653074\">said</a>:</p>\n<blockquote>\n<p>I realize that, and I'm suggesting that we don't need the definition at all (leastways because it is poorly named).</p>\n</blockquote>\n<p>Being poorly named seems to be not enough to deprecate it. I’m still working to understand it, but I would agree that the name isn’t great. If I’m starting to understand it well enough, it appears to perhaps be defining ultrafilters that contain the Frechet filter (the filter of cofinite subsets of the indexing set).  There already is a name for these…. Such an ultrafilter is a <strong>free ultrafilter</strong>.</p>",
        "id": 572653885,
        "sender_full_name": "Matt Insall",
        "timestamp": 1770588051
    },
    {
        "content": "<p>Well, the idea is that we can just write <code>.of cofinite</code> throughout. We're barely saving any characters, and there's not much API we can give for <code>hyperfilter</code> that we can't more generally put on <code>Ultrafilter.of</code> or <code>cofinite</code>.</p>",
        "id": 572653980,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770588120
    },
    {
        "content": "<p>In 2017 the world was a very different place, and if an undergraduate decided to call something a hyperfilter because he'd read it on the internet (or maybe even just made it up), I was fine with that. This stuff is very old code and also an undergraduate project supervised by a non-expert, I'm sure it could do with some spring cleaning. At the time I was just encouraging undergraduates to do any kind of mathematics and PR it.</p>",
        "id": 572700717,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770624209
    },
    {
        "content": "<p>I just realized it is probably not called <code>ultrafilter</code> because back then, types were lowercase, so the name would collide with the type <code>Ultrafilter</code>.</p>",
        "id": 572752636,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770637485
    },
    {
        "content": "<p>my in-progress nsa stuff: <a href=\"https://github.com/alok/mathlib4/tree/experiment-heq-nsa\">https://github.com/alok/mathlib4/tree/experiment-heq-nsa</a></p>",
        "id": 572940727,
        "sender_full_name": "Alok Singh",
        "timestamp": 1770697425
    },
    {
        "content": "<p>Unfortunately, this is a typical example of why AI is not yet at the human level of contributing to mathlib. It created a lot of extra definitions (<code>Hyperrational</code>, etc.) that we should not have (because the intention is a general solution). On the other hand, it didn't even fix the wrong definition of <code>Filter.Product</code> we were discussing here.</p>\n<p>Here, I proposed some principled steps for building the basics:<br>\n<a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572484787\">#mathlib4 &gt; Non-standard analysis @ 💬</a> <br>\n<a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572572470\">#mathlib4 &gt; Non-standard analysis @ 💬</a> <br>\nyou can feed them to claude, to see what happens.</p>\n<p>In general, we are not asking for spreading nonstandard analysis across mathlib, rather for solid foundations.</p>\n<p>By the way, could it prove the testing theorem here?<br>\n<a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572457090\">#mathlib4 &gt; Non-standard analysis @ 💬</a> <br>\nI am rather lost in all of the edits in that repo.</p>",
        "id": 572969343,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770711171
    },
    {
        "content": "<p>By the way, does it compile?</p>",
        "id": 572973885,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1770712395
    }
]