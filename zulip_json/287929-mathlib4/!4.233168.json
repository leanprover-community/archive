[
    {
        "content": "<p>In line 143, the code fails to synthesize an instance <code>TopologicalSemiring R</code>. However, even after manually adding it in the definition, the code doesn't recognize the declared instance. How should I fix it?</p>",
        "id": 345339197,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1680081218
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"598052\">@Jeremy Tan</span> beat me to it; this is <a href=\"https://github.com/leanprover/lean4/pull/2074\">lean4#2074</a></p>",
        "id": 345349556,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680083850
    },
    {
        "content": "<p>i.e. you need <code>set_option synthInstance.etaExperiment true</code> (as Jeremy has already commited).</p>",
        "id": 345350386,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1680084117
    },
    {
        "content": "<p>Is it time to make our base algebra structures flat by hand (by extending <code>hasZero</code>, <code>hasOne</code> and so on) until <code>CommRing</code>, say? (This should solve most of our issues with <a href=\"https://github.com/leanprover/lean4/pull/2074\">lean4#2074</a>, if I understand correctly). Or should we wait for a more proper fix (for instance based on the <code>flat</code> modifier proposed by <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> in <a href=\"#narrow/stream/287929-mathlib4/topic/eta.20ftw/near/337950035*\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/eta.20ftw/near/337950035*</a>)?</p>",
        "id": 345352670,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1680084740
    },
    {
        "content": "<p>If we do it manually, do the lean maintainers have anything left to test any fix on?</p>",
        "id": 345353125,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1680084885
    },
    {
        "content": "<p>Let's not flatten <em>during</em> porting at the very least. We can use <code>etaExperiment</code> to finish porting and then afterwards decide how to fix it.</p>",
        "id": 345397972,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1680095790
    },
    {
        "content": "<p>If we had a <code>flat</code> modifier then I think doing it during porting would be fine</p>",
        "id": 345400105,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680096342
    },
    {
        "content": "<p>Because that makes it more similar to the Lean 3 version, not less</p>",
        "id": 345400173,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680096359
    },
    {
        "content": "<p>I agree with Eric -- such a flat modifier would be essentially a way to simulate \"old_structure_cmd\".</p>",
        "id": 345401311,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1680096565
    },
    {
        "content": "<p>I'll make a PR quickly outlining the other approach</p>",
        "id": 345402673,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680096855
    },
    {
        "content": "<p>My worry with this approach is that I thought that recently we were actually beginning to see the disadvantages of flattening structures which Leo had predicted years ago and which many of us in the maths community had fought against.</p>",
        "id": 345406730,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680097624
    },
    {
        "content": "<p>On the other hand we're also beginning to understand the disadvantages of new structures too...</p>",
        "id": 345407062,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680097686
    },
    {
        "content": "<p>Our choices are either eta for TC (which has performance problems in Lean 4), old-style classes, or we redesign all our dependent typeclasses like <code>module</code> and <code>star_ring</code></p>",
        "id": 345407151,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680097710
    },
    {
        "content": "<p>I still find it very hard to explain to mathematicians that \"a topological field is an additive group\" is actually something which causes us problems.</p>",
        "id": 345407305,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680097738
    },
    {
        "content": "<p>I don't understand your comment, that's not even possible to state in Lean with mathlib</p>",
        "id": 345407505,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680097775
    },
    {
        "content": "<p>I am extremely grateful and happy that there are clearly several people in the community who have a profound understanding of these typeclass issues by the way, it's the thing which convinces me that the issues will ultimately be resolved.</p>",
        "id": 345407750,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680097823
    },
    {
        "content": "<p>My example of the field and the group is just a generic statement trying to explain that typeclass inference solves problems which do not exist as far as mathematicians are concerned</p>",
        "id": 345407927,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680097864
    },
    {
        "content": "<p>I think more knobs on the existing machine is probably better than wholesale revamp. At least as a first pass.</p>",
        "id": 345408058,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1680097898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.233168/near/345402673\">said</a>:</p>\n<blockquote>\n<p>I'll make a PR quickly outlining the other approach</p>\n</blockquote>\n<p>Done: <a href=\"https://github.com/leanprover-community/mathlib4/pull/3171\">https://github.com/leanprover-community/mathlib4/pull/3171</a></p>",
        "id": 345409331,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680098170
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Feel free to use <code>!bench</code> on the PR as soon as the build passes (or if it has already passed locally)</p>",
        "id": 345409826,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1680098271
    },
    {
        "content": "<p>I doubt it will pass as is</p>",
        "id": 345409864,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680098281
    },
    {
        "content": "<p>Why does extending <code>FlatHack</code> flatten things?</p>",
        "id": 345409976,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1680098297
    },
    {
        "content": "<p>I was just fed up of trying to explain the hack in the meeting, and figured an incomplete PR would be clearer</p>",
        "id": 345409980,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680098299
    },
    {
        "content": "<p>Because it causes all the other base classes to overlap</p>",
        "id": 345410055,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680098312
    },
    {
        "content": "<p>Note that <code>One</code>, <code>Zero</code>, <code>Add</code>, and <code>Mul</code> don't have this base class, but their non-overlap shouldn't matter</p>",
        "id": 345410208,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680098344
    },
    {
        "content": "<p>Unfortunately it seems that I'm not allowed to set default value for fields</p>",
        "id": 345411570,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680098597
    },
    {
        "content": "<p>Lean complains (in yellow)  if two flattened ancestors try to set a default for the same fields. Can I silence the complaint?</p>",
        "id": 345414907,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680099211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.233168/near/345407151\">said</a>:</p>\n<blockquote>\n<p>Our choices are either eta for TC (which has performance problems in Lean 4), old-style classes, or we redesign all our dependent typeclasses like <code>module</code> and <code>star_ring</code></p>\n</blockquote>\n<p>Isn't there also the option to have very carefully crafted classes to make sure that all diamonds are definitional without eta? For instance, there is a diamond from <code>Ring</code> to <code>AddCommMonoid</code> going through <code>Semiring</code> or <code>AddCommGroup</code> which is not definitional without eta currently, if I am not mistaken. </p>\n<p>But we could make it definitional by defining <code>Ring</code> to extend <code>Semiring</code> and <code>hasNeg</code>, and letting <code>AddCommGroup</code> extend <code>AddCommMonoid</code> and <code>hasNeg</code>, and letting <code>Semiring</code> extend <code>AddCommMonoid</code> and registering by hand an instance from <code>Ring</code> to <code>AddCommGroup</code> for which the <code>AddCommGroup</code> fields would be<code>Ring.tohasNeg</code> and <code>Ring.toSemiring.toAddCommMonoid</code>. But getting this right everywhere would be extremely hard -- isn't it what Hierarchy Builder is trying to do in Coq?</p>",
        "id": 345415549,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1680099326
    },
    {
        "content": "<p>I think as your heirarchy grows the only way to simultaneously satisfy everything is to make everything flat.</p>",
        "id": 345416452,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680099490
    },
    {
        "content": "<p>Note that the actual problem is brought on by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module#doc\">docs4#Module</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=StarRing#doc\">docs4#StarRing</a></p>",
        "id": 345416655,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680099528
    },
    {
        "content": "<p>These force particular typeclass resolution paths for their <code>*Ring</code> arguments, and the path taken is encoded in the instances</p>",
        "id": 345416821,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680099562
    },
    {
        "content": "<p>I wouldn't be surprised at all if writing a huge hierarchy becomes impossible to do by hand and some tool is needed. It doesn't have to be precisely Hierarchy Builder but it would certainly share a number of goals with this system.</p>",
        "id": 345416980,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1680099594
    },
    {
        "content": "<p>I do not support flattening the hierarchy. I do support a computer-made hierarchy, Hierarchy Builder-style</p>",
        "id": 345417513,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1680099679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.233168/near/345416452\">said</a>:</p>\n<blockquote>\n<p>I think as your heirarchy grows the only way to simultaneously satisfy everything is to make everything flat.</p>\n</blockquote>\n<p>I'm not convinced by this. Rather, I'm convinced it's possible, but much more painful than the \"everything flat\" solution. So if performance are comparable, we should definitely go with everything flat.</p>",
        "id": 345417624,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1680099697
    },
    {
        "content": "<p>After all, the ugly details will be hidden from the enduser</p>",
        "id": 345417806,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1680099724
    },
    {
        "content": "<p>There is another rather strange way to solve the problem here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Module</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 345418618,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680099860
    },
    {
        "content": "<p>This means that the argument to <code>Module</code> is always a projection right to the bottom of the lattice of diamonds, so the unification during TC search never needs eta</p>",
        "id": 345419072,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680099943
    },
    {
        "content": "<p>I'd be surprised if this approach works everywhere though</p>",
        "id": 345419132,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680099953
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 345419350,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1680099988
    },
    {
        "content": "<p>I wonder if an explanation of all these options is worth a CICM paper...</p>",
        "id": 345419721,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680100056
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"598052\">Jeremy Tan</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.233168/near/345417513\">said</a>:</p>\n<blockquote>\n<p>I do not support flattening the hierarchy. I do support a computer-made hierarchy, Hierarchy Builder-style</p>\n</blockquote>\n<p>We're not talking about flattening the hierarchy. We're talking about flattening the inheritance.</p>",
        "id": 345424540,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1680100866
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.233168/near/345406730\">said</a>:</p>\n<blockquote>\n<p>My worry with this approach is that I thought that recently we were actually beginning to see the disadvantages of flattening structures which Leo had predicted years ago and which many of us in the maths community had fought against.</p>\n</blockquote>\n<p>This is exactly my concern as well. It's my understanding that preferring new structures over old was to reduce term size and increase performance. It would be a shame to give this up if we can avoid it in other ways (e.g., making TC eta work without being slow), especially if it means we have to do a major redesign to the hierarchy (like the <code>Ring R extends One R, Zero R, Add R, Mul R, Neg R, NatCast R, IntCast R, ...</code> proposal). However, if Eric's <code>FlatHack</code> works and is relatively easy to remove (modulo <code>etaExperiment</code> changes), then it would be nice to know what the performance differences truly are.</p>",
        "id": 345473957,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1680111607
    }
]