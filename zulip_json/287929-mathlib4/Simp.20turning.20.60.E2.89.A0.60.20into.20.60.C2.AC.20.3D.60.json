[
    {
        "content": "<p>I'm working on making the projective space <code>ℙ(n; S)</code> and it's taking longer than I thought. One intermediate object involved is <code>MvPolynomial { k // k ≠ i } R</code>, which occurs naturally as the correct thing to consider in the basic open defined by <code>X i ≠ 0</code>.</p>\n<p>I haven't PR'ed anything yet, but I can already see that the simp linter will complain a lot about me not turning <code>k ≠ i</code> into <code>¬ k = i</code>, so I wonder what yall think about this.</p>",
        "id": 523268712,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749555196
    },
    {
        "content": "<p>basically i see three pathways:</p>\n<ol>\n<li>remove that simp lemma (basically impossible, i can see how <code>¬ a = b</code> is in fact better for the whole context of simp.</li>\n<li>make a separate type instead of just using <code>{ k // k ≠ i }</code> all the time.</li>\n<li>convert all occurrences of <code>k ≠ i</code> into <code>¬ k = i</code>, which actually the only reason I haven't done this is artistic</li>\n</ol>",
        "id": 523269115,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749555330
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> I wonder what you think about this</p>",
        "id": 523269298,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749555388
    },
    {
        "content": "<p>(To give some context for this discussion: the FRO is very much aware that this is a pain point and  we have decided that we want to make <code>≠</code> and <code>¬ =</code> the same thing, for example by making the former a notation for the latter. It's unclear when we will get to this.)</p>",
        "id": 523270078,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1749555649
    },
    {
        "content": "<p>Thanks a lot!</p>",
        "id": 523270861,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749555845
    },
    {
        "content": "<p>Does that mean we would need special elaborator support for the <code>Ne</code> namespace, so that <code>h.symm</code> still works?</p>",
        "id": 523270877,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749555848
    },
    {
        "content": "<p>This is why we haven't done it yet: it's unclear what the best approach is, and it's easy to break things, so careful testing and experiments will be needed before we can pull the trigger.</p>",
        "id": 523271136,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1749555927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Simp.20turning.20.60.E2.89.A0.60.20into.20.60.C2.AC.20.3D.60/near/523270877\">said</a>:</p>\n<blockquote>\n<p>Does that mean we would need special elaborator support for the <code>Ne</code> namespace, so that <code>h.symm</code> still works?</p>\n</blockquote>\n<p>would <code>abbrev</code> work for this?</p>",
        "id": 523271217,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749555958
    },
    {
        "content": "<p>It would be nice to consider decoupling namespaces and dot notation anyways, as currently dot notation is sometimes encouraging people to put lemmas in the wrong namespace. But this is probably a way harder design decision to get right.</p>",
        "id": 523271653,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1749556098
    },
    {
        "content": "<p>My 2 cents: make <code>Ne</code> an <code>abbrev</code>, remove <code>@[simp]</code> from <code>ne_eq</code> (this should not break things? since if <code>Ne</code> is an <code>abbrev</code> then <code>rw</code> can pass through it), but keep <code>ne_eq</code> in case that if one want to rewrite <code>¬ =</code> to <code>≠</code> to use results in <code>Ne</code> namespace.</p>",
        "id": 523276107,
        "sender_full_name": "Jz Pan",
        "timestamp": 1749557471
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Simp.20turning.20.60.E2.89.A0.60.20into.20.60.C2.AC.20.3D.60/near/523276107\">said</a>:</p>\n<blockquote>\n<p>(this should not break things? since if <code>Ne</code> is an <code>abbrev</code> then <code>rw</code> can pass through it)</p>\n</blockquote>\n<p>I'm pretty sure this is actually <em>not</em> how <code>rw</code> works. In particular if you're rewriting with a statement <code>_ ≠ _ ↔ _</code> then it will not find anything that not exactly <code>≠</code>, even if <code>Ne</code> is an abbrev.</p>",
        "id": 523276702,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749557677
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"366779\">@Jz Pan</span> Indeed, Aaron is correct here. I've made a way to experiment with ideas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Ne'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Ne'</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ne'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ne'</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ne</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ne'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ne'</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">simp</span><span class=\"bp\">.</span><span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ne'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq_self</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ne'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">ne_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">eq_self</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ne'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- succeeds</span>\n<span class=\"c1\">-- (these are all `False`, so by \"succeed\" I mean that it successfully simplifies to `False`)</span>\n</code></pre></div>",
        "id": 523277120,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749557799
    },
    {
        "content": "<p>(the reason why <code>simp</code> can use <code>ne_eq</code> at all is beyond me)</p>",
        "id": 523277208,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749557829
    },
    {
        "content": "<p>How about this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">TypeStar</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Not</span><span class=\"bp\">.</span><span class=\"n\">esymm</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Ne</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">esymm</span>\n</code></pre></div>",
        "id": 523282455,
        "sender_full_name": "Miyahara Kō",
        "timestamp": 1749559370
    },
    {
        "content": "<p>Maybe we could already have today the more general <code>Not.symm {α : Type*} {r : α → α → Prop} [IsSymm α r] {a b : α} (hab : ¬ r a b) : ¬ r b a</code></p>",
        "id": 523287486,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1749560752
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Thank you. Without realizing it, I was applying Cunningham's Law (the best way to get the right answer on the internet is to post something incorrect).:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">TypeStar</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Defs</span><span class=\"bp\">.</span><span class=\"n\">Unbundled</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Not</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsSymm</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">mt</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>",
        "id": 523314466,
        "sender_full_name": "Miyahara Kō",
        "timestamp": 1749568042
    },
    {
        "content": "<p>The only problem is that <code>@[symm]</code> wouldn't work anymore. But maybe we can simply teach <code>symm</code> in core to treat <code>Not</code> specially.</p>",
        "id": 523494978,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1749626474
    },
    {
        "content": "<p>And for other <code>Ne</code> lemmas we could perhaps just use a <code>{r : α → α → Prop} [IsRefl α r] (h : ¬r a b)</code> construction</p>",
        "id": 523495232,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1749626572
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Simp.20turning.20.60.E2.89.A0.60.20into.20.60.C2.AC.20.3D.60/near/523269115\">said</a>:</p>\n<blockquote>\n<ol>\n<li>remove that simp lemma (basically impossible, i can see how <code>¬ a = b</code> is in fact better for the whole context of simp.</li>\n</ol>\n</blockquote>\n<p>what if we do this, and add simprocs instead?</p>",
        "id": 523515591,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1749633297
    },
    {
        "content": "<p>i.e. a simproc which, when simplifying <code>a ≠ b</code> tries to simplify <code>¬ a = b</code>, then convert back to <code>a ≠ b</code> wherever possible?</p>",
        "id": 523515870,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1749633389
    },
    {
        "content": "<p>(because i suspect that that's basically the only reason why <code>ne_eq</code> is a simp lemma?)</p>",
        "id": 523516030,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1749633450
    },
    {
        "content": "<p>It should be some sort of <code>simp</code> post-processor.</p>",
        "id": 523521120,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749635054
    },
    {
        "content": "<p>What about add an <code>instance {α : Type*} {r : α → α → Prop} [IsSymm α r] : IsSymm α fun a b =&gt; ¬r a b</code>?</p>",
        "id": 523521962,
        "sender_full_name": "Jz Pan",
        "timestamp": 1749635331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Simp.20turning.20.60.E2.89.A0.60.20into.20.60.C2.AC.20.3D.60/near/523521120\">said</a>:</p>\n<blockquote>\n<p>It should be some sort of <code>simp</code> post-processor.</p>\n</blockquote>\n<p><del>i wonder if it's as simple as adding <code>attribute [-simp, simp↓, simp ←] ne_eq</code> somewhere?</del> spoiler: it's not</p>",
        "id": 523535654,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1749640084
    },
    {
        "content": "<p>What about stuff like <code>not_not</code> not working on <code>≠</code>?</p>",
        "id": 523535950,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749640205
    },
    {
        "content": "<p>that's plainly not true, i think?</p>",
        "id": 523536271,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1749640336
    },
    {
        "content": "<p>since <code>Ne</code> is reducible</p>",
        "id": 523536290,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1749640343
    },
    {
        "content": "<p>i.e.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">not_not</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>works</p>",
        "id": 523536356,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1749640368
    },
    {
        "content": "<p>neat</p>",
        "id": 523536577,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749640450
    },
    {
        "content": "<p>TIL <code>Ne</code> is reducible</p>",
        "id": 523536640,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749640471
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Simp.20turning.20.60.E2.89.A0.60.20into.20.60.C2.AC.20.3D.60/near/523521962\">schrieb</a>:</p>\n<blockquote>\n<p>What about add an <code>instance {α : Type*} {r : α → α → Prop} [IsSymm α r] : IsSymm α fun a b =&gt; ¬r a b</code>?</p>\n</blockquote>\n<p>Doesn't work, since for <code>Not (Eq a b)</code> it expects something of the form <code>r _ _</code> but only finds one parameter.</p>",
        "id": 523591701,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1749657259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Simp.20turning.20.60.E2.89.A0.60.20into.20.60.C2.AC.20.3D.60/near/523515591\">schrieb</a>:</p>\n<blockquote>\n<p>what if we do this, and add simprocs instead?</p>\n</blockquote>\n<p>I'd rather prefer if <code>≠</code> was just notation because otherwise we'd have some weird special casing for <code>simp</code> and putting things into the <code>Not</code> namespace seems like a reasonable solution.</p>",
        "id": 523594049,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1749657993
    },
    {
        "content": "<p>Also I'm getting annoyed at the fact that once again, we have <code>Std.Refl</code> / <code>IsRefl</code>, <code>Std.Irrefl</code> / <code>IsIrrefl</code>, <code>Std.Antisymm</code> / <code>IsAntisymm</code> etc. (mathlib + core having the same things with different names!)</p>",
        "id": 523594837,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1749658245
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Simp.20turning.20.60.E2.89.A0.60.20into.20.60.C2.AC.20.3D.60/near/523594837\">said</a>:</p>\n<blockquote>\n<p>Also I'm getting annoyed at the fact that once again, we have <code>Std.Refl</code> / <code>IsRefl</code>, <code>Std.Irrefl</code> / <code>IsIrrefl</code>, <code>Std.Antisymm</code> / <code>IsAntisymm</code> etc. (mathlib + core having the same things with different names!)</p>\n</blockquote>\n<p>Also <code>Nat.repeat</code> / <code>Nat.iterate</code></p>",
        "id": 523599502,
        "sender_full_name": "Jz Pan",
        "timestamp": 1749659764
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Simp.20turning.20.60.E2.89.A0.60.20into.20.60.C2.AC.20.3D.60/near/523494978\">said</a>:</p>\n<blockquote>\n<p>The only problem is that <code>@[symm]</code> wouldn't work anymore. But maybe we can simply teach <code>symm</code> in core to treat <code>Not</code> specially.</p>\n</blockquote>\n<p>I think it would be reasonable to have some behavior like, \"if the top level expression has only a single explicit argument (and it doesn't have an applicable @symm itself), then recurse into that argument\".</p>\n<p>So \"Not Iff a b\" would become \"Not Iff b a\", but also e.g. \"Set.Infinite (setOf (fun n -&gt; x^n = y))\" would become \"Set.Infinite (setOf (fun n -&gt; y = x^n))\"</p>",
        "id": 523780441,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1749741526
    },
    {
        "content": "<p>Because in 99% of cases where symm is used it's some kind of binary connective, and so if that's wrapped in some number of unary operators it's pretty reasonable to call the first binary connective you find the canonical one</p>",
        "id": 523780829,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1749741622
    },
    {
        "content": "<p>Hmm I'm not sure how I should feel about <code>symm</code> recursing into deep arguments; at that point it becomes more of a commutativity tactic than a symmetry tactic (since it then actually needs symmetry for all a, b instead of just two of the parameters that are provided)</p>",
        "id": 523782693,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1749742196
    },
    {
        "content": "<p>I mean we certainly don't want <code>Monotone (fun a =&gt; a + 1)</code> to turn into <code>Monotone (fun a =&gt; 1 + a)</code>, do we?</p>",
        "id": 523782854,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1749742245
    },
    {
        "content": "<p>Just allowing <code>Not</code> would mean supporting \"apply mt symm\" instead of \"apply symm\" which is more reasonable I'd think</p>",
        "id": 523783203,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1749742358
    },
    {
        "content": "<p>I'm not sure I follow - maybe I've misunderstood the purpose of <code>symm</code>, then, but in my head it <em>is</em> precisely the \"commutativity tactic\" (that doesn't require me knowing name of the relevant commutativity theorem). Every @symm theorem I can find is of the form <code>f x y -&gt; f y x</code>, and this is clearly enough to construct <code>f x y &lt;-&gt; f y x</code> and then do a <code>simp_rw [the iff version]</code>.</p>",
        "id": 523791021,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1749744891
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Simp.20turning.20.60.E2.89.A0.60.20into.20.60.C2.AC.20.3D.60/near/523782854\">said</a>:</p>\n<blockquote>\n<p>I mean we certainly don't want <code>Monotone (fun a =&gt; a + 1)</code> to turn into <code>Monotone (fun a =&gt; 1 + a)</code>, do we?</p>\n</blockquote>\n<p>I agree that would be be pretty surprising. But in my head, I don't think there's anything <em>else</em> I would reasonably expect <code>symm</code> to do on that goal, so if a user wants to do that, I don't _mind_ the behavioral <em>possibility</em>.</p>",
        "id": 523791174,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1749744946
    },
    {
        "content": "<p>My feelings on this would certainly change if there's an argument that allowing this will lead to e.g. less readable or less maintainable proofs</p>",
        "id": 523791258,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1749744980
    },
    {
        "content": "<p>Well my point is mostly that <code>symm</code> is currently more of an <code>apply</code>-like tactic and making it <code>rw</code> or <code>simp</code>-like would require significant changes and I'm not sure that there is enough of a use case to justify such a shift.</p>",
        "id": 523798003,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1749747701
    }
]