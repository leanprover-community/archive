[
    {
        "content": "<p>All formally real rings are semireal. A semireal field is formally real. Do I have to choose one of these to register as an instance, and manually pass the other in whenever I need to use it? Or is there some way around this?</p>",
        "id": 492241224,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736223944
    },
    {
        "content": "<p>You can register both as instances.</p>",
        "id": 492253806,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1736233576
    },
    {
        "content": "<p>The rule is that instance loops are allowed, as long as it loops back to an exactly syntactically equal goal. So <code>IsFormallyReal R -&gt; Semireal R -&gt; IsFormallyReal R</code> is allowed, but something like <code>Finite a -&gt; Finite (Sum a b) -&gt; Finite (Sum (Sum a b) b) -&gt; ...</code> would loop forever.</p>",
        "id": 492277889,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1736244173
    },
    {
        "content": "<p>Perhaps not directly related to your question: For performance reasons it might not be a good idea to have all of these \"upgrading\" instances as global instances in Mathlib. With an upgrading instance I mean an instance where a stronger class is inferred from a weaker class in special cases. </p>\n<p>An example of this is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=littleWedderburn#doc\">docs#littleWedderburn</a>. Suppose I write <code>x * y</code>, where <code>x</code> and <code>y</code> are in some type <code>A</code> without multiplication. Before Lean raises can raise an error, it has to navigate all instances that involve multiplication, including <code>littleWedderburn</code>. I'm not quite sure about the instantiation order for that instance, but unless we're very careful (and in general, we're not careful at all), type class inference will now try to infer <code>Finite A</code> to find out whether <code>A</code> has a multiplication. When I investigated some very slow type-class inference failures a year ago, to figure out whether some type was a subsingleton, it would basically navigate all algebraic, topological, order-theoretic and some categorical classes before it could conclude whether the type was a subsingleton.</p>\n<p>I think scoping some well-chosen instances in Mathlib could lead to significant speed-ups, at the cost of requiring users to open namespaces more often (and unfortunately getting unhelpful error messages if they don't).</p>",
        "id": 492322630,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1736261013
    }
]