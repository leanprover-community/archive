[
    {
        "content": "<p>Many theorems about polynomials can be stated equally well in terms of <code>degree</code> or <code>natDegree</code> (e.g., a theorem with assumption <code>deg ≤ 1</code>. In <a href=\"https://github.com/leanprover-community/mathlib4/pull/32103\">#32103</a>, <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> suggested that both version be kept (<a href=\"https://github.com/leanprover-community/mathlib4/pull/32103#discussion_r2569201618\">https://github.com/leanprover-community/mathlib4/pull/32103#discussion_r2569201618</a>), but on <a href=\"https://github.com/leanprover-community/mathlib4/pull/34656\">#34656</a>, <span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> rightfully points out that keeping around two versions of every such lemma is a lot of duplication (<a href=\"https://github.com/leanprover-community/mathlib4/pull/34656#discussion_r2750133092\">https://github.com/leanprover-community/mathlib4/pull/34656#discussion_r2750133092</a>).</p>\n<p>Is there a preferred option, or should both be kept?</p>",
        "id": 571239077,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1769901255
    },
    {
        "content": "<p>/poll Here's an informal poll to gague opinion:<br>\nKeep degree variant<br>\nKeep natDegree variant<br>\nKeep both</p>",
        "id": 571239156,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1769901349
    },
    {
        "content": "<p>If we do decide to keep both, then there's the further question of what to do about lemmas that lean one way or the other. E.g., a <code>deg = 0</code> hypothesis is best stated in terms of <code>natDegree</code> for maximum generality.</p>",
        "id": 571239277,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1769901473
    },
    {
        "content": "<p><code>degree</code> carries more useful information than <code>natDegree</code> does. Saying that <code>natDegree p = n</code> really means that either the degree of <code>p</code> is <code>n</code>, or <code>n = 0</code> and <code>p</code> is the zero polynomial. So I believe we should prefer <code>degree</code> everywhere, unless we legitimately need a natural number in order to state a theorem (as in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.leadingCoeff_comp#doc\">docs#Polynomial.leadingCoeff_comp</a>, to give an example).</p>",
        "id": 571239949,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769902152
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253861\">Thomas Browning</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Stating.20theorems.20in.20terms.20of.20degree.20vs.20natDegree/near/571239277\">said</a>:</p>\n<blockquote>\n<p>E.g., a <code>deg = 0</code> hypothesis is best stated in terms of <code>natDegree</code> for maximum generality.</p>\n</blockquote>\n<p>For this specific question I guess <code>p.degree ≤ 0</code> is a good replacement for <code>p.natDegree = 0</code>, no need to use <code>natDegree</code> here</p>",
        "id": 571240667,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1769903064
    },
    {
        "content": "<p>I think it's naive to say \"we should prefer <code>degree</code> everywhere\". I've seen plenty of situations where <code>natDegree</code> made life easier (that's why it's there in the first place!) and I think that having two versions of every lemma makes our formalizing lives easier. We have two definitions and we should have lots of API for both, simply because we should have lots of API for every definition we have, that's a basic principle which mathlib has been built on from the start.</p>",
        "id": 571240721,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769903125
    },
    {
        "content": "<p>I'm not arguing against <code>natDegree</code> here. But I do believe that instead of having N many theorems which only differ in a single hypothesis e.g. <code>0 &lt; p.degree</code> vs <code>0 &lt; p.natDegree</code>, we should choose one and use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.natDegree_pos_iff_degree_pos#doc\">docs#Polynomial.natDegree_pos_iff_degree_pos</a> when we have the other hypothesis.</p>",
        "id": 571240832,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769903281
    },
    {
        "content": "<p>I think that saying \"we should remove API from a definition\" is a retrograde step. More API makes formalisation easier. \"We should remove a theorem and make the user figure out how to prove it themselves (remark: I know how to do this exercise myself)\" is something which I think you'll find it very hard to sell.</p>",
        "id": 571240909,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769903366
    },
    {
        "content": "<p>If discoverability is a problem, we could take the more extreme approach of making <code>0 &lt; p.degree</code> the simp-normal form of <code>0 &lt; p.natDegree</code>. Then the user only needs to type <code>by simpa</code>.</p>",
        "id": 571241030,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769903544
    },
    {
        "content": "<p>I think that this also will cause problems. If you are doing a calculation in nats with <code>p.natDegree</code> embedded in the term (which definitely happens), then you don't want <code>0 &lt; p.natDegree</code> normalised to something else not mentioning <code>natDegree</code> because this will break things like <code>linarith</code>. </p>\n<p>I feel like that your argument \"it's code duplication so it's bad\" can be applied to essentially any declaration which is easily built from an older definition, followed by API for the new declaration which is built from the old one. But that's the mathlib way.</p>",
        "id": 571241529,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769904107
    },
    {
        "content": "<p>Note that the vote above is not binding, because it's a responsibility of the maintainers team to make decisions like this. If someone will want to start a big refactor based on the vote, then the maintainers team should agree on this first.</p>",
        "id": 571241653,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769904232
    },
    {
        "content": "<p>E.g., we have <code>Set.encard</code> and <code>Set.ncard</code> which is just <code>(Set.encard s).toNat</code>. Moreover, they're just <code>(Cardinal.mk s).toENat</code>/<code>(Cardinal.mk s).toNat</code>, but we have APIs for these definitions anyway.</p>",
        "id": 571241804,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769904323
    },
    {
        "content": "<p>Again, I'm not arguing for removing <code>natDegree</code> or its API. I'm arguing that, if we have some condition in a larger theorem that can be equivalently stated using <code>degree</code> or <code>natDegree</code>, then we should just choose one, rather than having both variants.</p>",
        "id": 571241875,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769904398
    },
    {
        "content": "<p>I believe there's precedent for this. For instance, we generally prefer to state theorems about non-zero naturals using <code>n ≠ 0</code> rather than <code>0 &lt; n</code>.</p>",
        "id": 571241925,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769904430
    },
    {
        "content": "<p>How large is the theorem?</p>",
        "id": 571241933,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769904441
    },
    {
        "content": "<p>One difference between <code>degree</code>/<code>natDegree</code> and your example is that the terms live in different types.</p>",
        "id": 571241956,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769904473
    },
    {
        "content": "<p>The theorem that sparked this discussion is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.exists_irreducible_of_degree_pos#doc\">docs#Polynomial.exists_irreducible_of_degree_pos</a>.</p>",
        "id": 571242017,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769904525
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Stating.20theorems.20in.20terms.20of.20degree.20vs.20natDegree/near/571241925\">said</a>:</p>\n<blockquote>\n<p>I believe there's precedent for this. For instance, we generally prefer to state theorems about non-zero naturals using <code>n ≠ 0</code> rather than <code>0 &lt; n</code>.</p>\n</blockquote>\n<p>In this case, you can get from <code>0 &lt; n</code> to <code>n ≠ 0</code> by appending <code>.ne'</code>, but converting between <code>degree</code> and <code>natDegree</code> is a little more painful.</p>",
        "id": 571242054,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1769904564
    },
    {
        "content": "<p>Converting from <code>degree</code> to <code>natDegree</code> is easier than converting from <code>natDegree</code> to <code>degree</code>, in my experience. So I think the same reasoning applies.</p>",
        "id": 571242085,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769904604
    },
    {
        "content": "<p>The value of <code>degree</code> entirely characterizes the value of <code>natDegree</code>, but not the other way around.</p>",
        "id": 571242121,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769904634
    },
    {
        "content": "<p>Same applies to <code>Set.encard</code> vs <code>Set.ncard</code>. Of course, one difference is that <code>ENat.toNat</code> is not a monotone map.</p>",
        "id": 571242182,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769904710
    },
    {
        "content": "<p>Well, if we had multiple theorems in Mathlib that were duplicated except one had a hypothesis <code>s.encard = 1</code> but the other had <code>s.ncard = 1</code>, I'd probably be making a thread about that as well.</p>",
        "id": 571242282,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769904824
    },
    {
        "content": "<p>In my opinion duplication in basic theorem is fine, but I agree that having both <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/Polynomial/UniqueFactorization.html#Polynomial.exists_irreducible_of_degree_pos\">Polynomial.exists_irreducible_of_degree_pos</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/Polynomial/UniqueFactorization.html#Polynomial.exists_irreducible_of_natDegree_pos\">Polynomial.exists_irreducible_of_natDegree_pos</a> is strange.</p>",
        "id": 571387540,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1770026054
    },
    {
        "content": "<p>Is it unreasonable to add a couple of lemma to <code>grind</code> (or some other tactic) to make it able to prove <code>0 &lt; p.degree</code> having <code>0 &lt; p.natDegree</code> and similar stuff?</p>",
        "id": 571387908,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1770026158
    },
    {
        "content": "<p>Perhaps even a custom <code>@[grind]</code> set (enabled by default) so we can write <code>theorem (hf : 0 &lt; f.degree := by assumption_mod_unbot)</code> or similar?</p>",
        "id": 571405721,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1770031115
    },
    {
        "content": "<p>It's a shame that we can't have dot notation as a slick way of switching from one to the other (like we do to switch between n \\not= 0 and 0&lt;n in nat)</p>",
        "id": 571441752,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770041509
    },
    {
        "content": "<p>We already have a <code>compute_degree</code> tactic, maybe we could beef it up so it can do conversions like these?</p>",
        "id": 571447926,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770042936
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Stating.20theorems.20in.20terms.20of.20degree.20vs.20natDegree/near/571441752\">said</a>:</p>\n<blockquote>\n<p>It's a shame that we can't have dot notation as a slick way of switching from one to the other (like we do to switch between n \\not= 0 and 0&lt;n in nat)</p>\n</blockquote>\n<p>In theory you could define <code>LT.lt.degree_pos</code> and <code>LT.lt.natDegree_pos</code> in the root namespace <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 571459618,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1770045668
    },
    {
        "content": "<p>In my experience the <code>natDegree</code> versions are much more useful. In fact, I was planning to PR a bunch of them in from my project! It's very annoying to constantly rewrite between <code>degree</code> and <code>natDegree</code>. The issue is that there isn't a clear normal form.</p>",
        "id": 571491138,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1770054011
    },
    {
        "content": "<p>I agree that the rewrite is annoying, and for that same reason I wanted to PR more lemmas on <code>degree</code>...</p>\n<p>I'd rather just decide on one or another rather than be playing tug of war.</p>",
        "id": 571491282,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770054057
    },
    {
        "content": "<p>I get the point that moving from <code>degree</code> to <code>natDegree</code> is easier than the other way around. So maybe: <code>natDegree</code> in assumptions, <code>degree</code> in conclusions? Where it makes sense, of course: sometimes you have to use <code>degree</code> in both.</p>",
        "id": 571491478,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1770054118
    },
    {
        "content": "<p>What's wrong with \"lots of API for both\"? It just seems to me like the simplest solution, easiest for other people to use etc.</p>",
        "id": 571491558,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770054146
    },
    {
        "content": "<p>From my POV, it's annoying to maintain and entails a lot of duplication. Also sometimes people won't add one or the other version, so you have to go from <code>natDegree</code> to <code>degree</code> a lot. However I worry the alternative is too restrictive.</p>",
        "id": 571491908,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1770054266
    },
    {
        "content": "<p>The advantage of writing everything using <code>natDegree</code> is that it's easy to chain facts with <code>lia</code>. Working with <code>WithBot</code> is pain. Same reason we use <code>finrank</code>, <code>fincard</code>, etc.</p>",
        "id": 571492226,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1770054365
    },
    {
        "content": "<p>I have the following lemmas in my project; they are very convenient.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib.Algebra.Polynomial.Degree.Definitions</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">degree_eq_one_iff_natDegree_eq_one</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">degree</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">natDegree</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">degree_eq_iff_natDegree_eq_of_pos</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_lt_one</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Mathlib.Algebra.Polynomial.Degree.Definitions</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">degree_eq_iff_natDegree_eq_of_atLeastTwo</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">AtLeastTwo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">degree</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">natDegree</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">degree_eq_iff_natDegree_eq_of_pos</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pos_of_neZero</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 571492344,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1770054401
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Stating.20theorems.20in.20terms.20of.20degree.20vs.20natDegree/near/571492226\">said</a>:</p>\n<blockquote>\n<p>The advantage of writing everything using <code>natDegree</code> is that it's easy to chain facts with <code>lia</code>. Working with <code>WithBot</code> is pain. Same reason we use <code>finrank</code>, <code>fincard</code>, etc.</p>\n</blockquote>\n<p>Perhaps that points to a lack of API/automation, rather than something to be swept under the rug.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Stating.20theorems.20in.20terms.20of.20degree.20vs.20natDegree/near/571492344\">said</a>:</p>\n<blockquote>\n<p>I have the following lemmas in my project; they are very convenient.</p>\n</blockquote>\n<p>Case in point, huh</p>",
        "id": 571492728,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770054533
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Stating.20theorems.20in.20terms.20of.20degree.20vs.20natDegree/near/571492728\">said</a>:</p>\n<blockquote>\n<p>Perhaps that points to a lack of API/automation, rather than something to be swept under the rug.<br>\n</p>\n</blockquote>\n<p>Maybe, but these are pretty stable patterns by now. I would lean towards <code>natDegree</code> everywhere unless necessary, acknowledging it's the more annoying direction to transfer in.</p>",
        "id": 571493020,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1770054628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Stating.20theorems.20in.20terms.20of.20degree.20vs.20natDegree/near/571491908\">said</a>:</p>\n<blockquote>\n<p>From my POV, it's annoying to maintain and entails a lot of duplication.</p>\n</blockquote>\n<p>Yup. But it makes users happier, because the exact lemma they want is <em>just there</em>.</p>",
        "id": 571493182,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770054668
    },
    {
        "content": "<p>What I argue is that if we had a canonical way of writing this down, then the users would be happy, because the canonical form would just be there, rather than them having to hope someone remembered to add both variants.</p>",
        "id": 571493354,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770054722
    },
    {
        "content": "<p>What I am concerned about is that the amount of times <code>degree</code> and <code>natDegree</code> are used in general is going to be a lot more than the amount of times that you have the specific hypothesis <code>h : 0 &lt; f.degree</code> or <code>h : 0 &lt; f.natDegree</code>. My experience with using these types is that for a typical argument (which may be long) one choice  of degree function is often better than the other, so you make that choice (perhaps even in the statement of the result) at the beginning and then run the entire argument through with that choice, and then prove the other variant in 2 lines by reducing one choice of degree to the other. This idea that for some specific arguments we want the library to force you to use one of the choices sounds to me like it is going to degrade that user experience, and the way to keep/enhance that experience is code duplication.</p>",
        "id": 571494469,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770055100
    },
    {
        "content": "<p>I have no dog in this fight as this isn't my end of the library, but I suspect we indeed want some small tactic. However, I'm also not terribly opposed to living with the duplication; but that duplication is also easier to maintain with attributes that autogenerate the other version (using this small tactic).</p>\n<p>In short, I think there is some useful automation missing, regardless of which approach we eventually decide upon.</p>",
        "id": 571495776,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1770055507
    },
    {
        "content": "<p>I can agree with the centrist position. It's definitely too soon to do any major refactoring one way or the other.</p>\n<p>As for the PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/34656\">#34656</a> that started this. Can we at least agree on removing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.exists_irreducible_of_natDegree_ne_zero#doc\">docs#Polynomial.exists_irreducible_of_natDegree_ne_zero</a> in favor of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.exists_irreducible_of_natDegree_pos#doc\">docs#Polynomial.exists_irreducible_of_natDegree_pos</a> ? Converting <code>n ≠ 0</code> to <code>0 &lt; n</code> for <code>n : ℕ</code> is entirely trivial.</p>",
        "id": 571496352,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770055688
    },
    {
        "content": "<p>Is something like this possible?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_unbot</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">-- magic ✨</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Splits</span><span class=\"bp\">.</span><span class=\"n\">comp_of_degree_le_one</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">Splits</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">degree</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Splits</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>That won't work for everything, e.g. a statement with a <code>degree = 0</code> hypothesis can't be translated to <code>natDegree = 0</code>, but maybe the translation macro can try calling <code>grind</code> to translate?</p>",
        "id": 571496596,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770055762
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Stating.20theorems.20in.20terms.20of.20degree.20vs.20natDegree/near/571496352\">said</a>:</p>\n<blockquote>\n<p>Can we at least agree on removing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.exists_irreducible_of_natDegree_ne_zero#doc\">docs#Polynomial.exists_irreducible_of_natDegree_ne_zero</a> in favor of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.exists_irreducible_of_natDegree_pos#doc\">docs#Polynomial.exists_irreducible_of_natDegree_pos</a> ?</p>\n</blockquote>\n<p>I prefer the other way around, <code>n ≠ 0</code> everywhere. I also remember seeing a PR that replaced a bunch of <code>0 &lt; n</code> with <code>n ≠ 0</code>, but idk how to find it.<br>\nEdit: <a href=\"https://github.com/leanprover-community/mathlib4/pull/33131\">#33131</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/29988\">#29988</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/27647\">#27647</a></p>",
        "id": 571497326,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770056008
    },
    {
        "content": "<p>We prefer <code>n ≠ 0</code> in hypotheses and <code>0 &lt; n</code> in conclusions of theorems</p>",
        "id": 571497533,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770056081
    },
    {
        "content": "<p>There's also the <code>≠ 0</code> vs <code>NeZero</code> duplication <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span><br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ArithmeticFunction.carmichael_eq_exponent#doc\">docs#ArithmeticFunction.carmichael_eq_exponent</a> vs <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ArithmeticFunction.carmichael_eq_exponent%27#doc\">docs#ArithmeticFunction.carmichael_eq_exponent'</a></p>",
        "id": 571498428,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1770056411
    },
    {
        "content": "<p>Oh yeah sorry, we should do this the other way around. Deprecate <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.exists_irreducible_of_natDegree_pos#doc\">docs#Polynomial.exists_irreducible_of_natDegree_pos</a> in favor of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.exists_irreducible_of_natDegree_ne_zero#doc\">docs#Polynomial.exists_irreducible_of_natDegree_ne_zero</a>.</p>",
        "id": 571498631,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770056485
    },
    {
        "content": "<p>The \"<code>n ≠ 0</code> in hypotheses and <code>0 &lt; n</code> in conclusions\" rule was made before the dot-notation theorems needed to make it trivial to convert between them were added, and nowadays I am not entirely clear about the logic of this rule.</p>",
        "id": 571505175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770058910
    },
    {
        "content": "<p>(how does one convert from <code>n ≠ 0</code> to <code>0 &lt; n</code> using dot notation?)</p>",
        "id": 571508819,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1770060370
    },
    {
        "content": "<p>I wouldn't be opposed to adding <code>NE.ne.pos</code> as an alias for the converse of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=pos_iff_ne_zero#doc\">docs#pos_iff_ne_zero</a></p>",
        "id": 571508961,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770060423
    },
    {
        "content": "<p>works for ordinals works for me</p>",
        "id": 571509041,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770060451
    },
    {
        "content": "<p>you mean <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NE.ne.pos#doc\">docs#NE.ne.pos</a> ? i don't think that would work with dot notation though?</p>",
        "id": 571509111,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1770060474
    },
    {
        "content": "<p>This is news to me</p>",
        "id": 571509271,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770060531
    },
    {
        "content": "<p>that should probably be <code>Ne.pos</code></p>",
        "id": 571509452,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770060598
    },
    {
        "content": "<p>since the declaration is called <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ne#doc\">docs#Ne</a></p>",
        "id": 571509497,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770060611
    },
    {
        "content": "<p>indeed, <code>Ne</code> is not a notation class like <code>LT</code> and the like</p>",
        "id": 571509544,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1770060632
    },
    {
        "content": "<p>Yikes, I hope someone gets fired for that blunder<br>\n(It was me, I added this a year ago...)</p>",
        "id": 571509647,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770060662
    },
    {
        "content": "<p>i suppose i personally was surprised by the fact there's a nontrivial set of classes which allows one to conclude this implication</p>",
        "id": 571510287,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1770060883
    },
    {
        "content": "<p>I've been wishing for a <code>⊥ = 0</code> typeclass for a long time, but yeah canonically ordered addition is the next best thing</p>",
        "id": 571510440,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770060930
    }
]