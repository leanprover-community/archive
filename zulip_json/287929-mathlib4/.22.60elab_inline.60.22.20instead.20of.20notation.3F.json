[
    {
        "content": "<p>I was experimenting with an alternative to the way mathlib uses notation for creating completely transparent abbreviations (for example, <code>local notation \"reC\" =&gt; @IsROrC.re ℂ _</code>). Here's what an interface could look like with a silly example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[elab_inline]</span>\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">f</span> <span class=\"mi\">37</span>\n<span class=\"c1\">-- 2 * 37 : Nat</span>\n</code></pre></div>\n<p>The idea is that after any application of <code>f</code> is elaborated, it immediately gets unfolded.</p>",
        "id": 362271150,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1685471977
    },
    {
        "content": "<p>I have a partial implementation of this that I'll leave here. One gap is that it's not able to handle zero-argument abbreviations, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[elab_inline]</span>\n<span class=\"kd\">def</span> <span class=\"n\">random</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">37</span>\n</code></pre></div>\n<p>For some reason the macro <code>macro_rules | `(random) =&gt; `(unfold% random)</code> never seems to fire.</p>\n<p>Another gap is that it doesn't leave any terminfo on the function after it gets unfolded, but that should be easily fixable.</p>\n<p>It would also be nice if it created an unexpander like <code>notation</code> would.</p>\n<p>The attribute and <code>unfold%</code> term elaborator that drives it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Lean.Command</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">unfold</span><span class=\"o\">)</span> <span class=\"s2\">\"unfold% \"</span> <span class=\"n\">ident</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">@[term_elab unfold]</span> <span class=\"kd\">def</span> <span class=\"n\">elabUnfold</span> <span class=\"o\">:</span> <span class=\"n\">Elab.Term.TermElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">unfold</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">args</span><span class=\"o\">]</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">f</span> <span class=\"bp\">←</span> <span class=\"n\">Term.resolveId</span><span class=\"bp\">?</span> <span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">throwUnknownConstant</span> <span class=\"n\">f.getId</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">Term.elabAppArgs</span> <span class=\"n\">f</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">args.map</span> <span class=\"bp\">.</span><span class=\"n\">stx</span><span class=\"o\">)</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n      <span class=\"o\">(</span><span class=\"n\">explicit</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ellipsis</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n    <span class=\"n\">unfoldDefinition</span> <span class=\"n\">e</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"sd\">/-- Causes the definition to be unfolded during elaboration. -/</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">elab_inline</span><span class=\"o\">)</span> <span class=\"s2\">\"elab_inline\"</span> <span class=\"o\">:</span> <span class=\"n\">attr</span>\n\n<span class=\"n\">initialize</span> <span class=\"n\">registerBuiltinAttribute</span> <span class=\"o\">{</span>\n  <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">elab_inline</span>\n  <span class=\"n\">descr</span> <span class=\"o\">:=</span> <span class=\"s2\">\"\"</span>\n  <span class=\"n\">applicationTime</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">afterCompilation</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">src</span> <span class=\"n\">ref</span> <span class=\"n\">kind</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"bp\">!=</span> <span class=\"n\">AttributeKind.global</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"`elab_inline` can only be used as a global attribute\"</span>\n    <span class=\"n\">liftCommandElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">withRef</span> <span class=\"n\">ref</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Command.elabCommand</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span>\n      <span class=\"n\">macro_rules</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">src</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">unfold</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">src</span><span class=\"o\">))</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">src</span><span class=\"o\">)</span> <span class=\"bp\">$$</span><span class=\"n\">args</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">unfold</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">src</span><span class=\"o\">)</span> <span class=\"bp\">$$</span><span class=\"n\">args</span><span class=\"bp\">*</span><span class=\"o\">)))</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 362271467,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1685472059
    },
    {
        "content": "<p>Something I like about this over using notation is that it doesn't cause the names used in notation to become reserved keywords. They're just functions like any other.</p>",
        "id": 362271762,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1685472142
    },
    {
        "content": "<p>cc: <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> on whether this is a good idea</p>",
        "id": 362274308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685472847
    },
    {
        "content": "<p>Patterns like <code> `(random $args*) </code> do not work with namespaces and <code>open</code>. At this point you may as well override the application elaborator. And/or open a feature request in core.</p>",
        "id": 362358818,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1685515333
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> I created an RFC <a href=\"https://github.com/leanprover/lean4/pull/2248\">lean4#2248</a></p>",
        "id": 362381212,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1685521542
    }
]