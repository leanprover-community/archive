[
    {
        "content": "<p>Picking back up some discussion <a href=\"#narrow/stream/113488-general/topic/Commands.20for.20canonical.20variables.20declarations.20.28was.3A.20Under.2E.2E.2E/near/260869839\">from while ago</a>, this morning I was looking at how to automatically introduce all the dependencies you need to introduce a typeclass, or really anything that depends on a typeclass.</p>",
        "id": 345211079,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680028459
    },
    {
        "content": "<p>I've just done a few tests, but it looks promising:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.18467</span>\n<span class=\"cm\">M: Type ?u.18470</span>\n<span class=\"cm\">inst✝²: Semiring R</span>\n<span class=\"cm\">inst✝¹: AddCommMonoid M</span>\n<span class=\"cm\">inst✝: Module R M</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.18767</span>\n<span class=\"cm\">A: Type ?u.18770</span>\n<span class=\"cm\">inst✝²: CommSemiring R</span>\n<span class=\"cm\">inst✝¹: Semiring A</span>\n<span class=\"cm\">inst✝: Algebra R A</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">S</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">M'</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.20902</span>\n<span class=\"cm\">M: Type ?u.20905</span>\n<span class=\"cm\">S: Type ?u.20932</span>\n<span class=\"cm\">M': Type ?u.20935</span>\n<span class=\"cm\">inst✝⁵: Semiring R</span>\n<span class=\"cm\">inst✝⁴: AddCommMonoid M</span>\n<span class=\"cm\">inst✝³: Module R M</span>\n<span class=\"cm\">inst✝²: Semiring S</span>\n<span class=\"cm\">inst✝¹: AddCommMonoid M'</span>\n<span class=\"cm\">inst✝: Module S M'</span>\n<span class=\"cm\">σ: R →+* S</span>\n<span class=\"cm\">f: M →ₛₗ[σ] M'</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 345211111,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680028465
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Module.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Algebra.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Module.LinearMap</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Mathlib.Command</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Lean.Elab</span> <span class=\"n\">Lean.Elab.Command</span> <span class=\"n\">Lean.Parser.Term</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">bracketedBinderType</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">term</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">_</span><span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"o\">[:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"bp\">?</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">_annot</span><span class=\"bp\">?</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ty</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">{</span><span class=\"bp\">$</span><span class=\"n\">_</span><span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"o\">[:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"bp\">?</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">})</span>             <span class=\"bp\">=&gt;</span> <span class=\"n\">ty</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">_</span> <span class=\"o\">:]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">])</span>               <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">ty</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">])</span>                        <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">ty</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>                                                <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">«</span><span class=\"kd\">variable</span><span class=\"bp\">!»</span><span class=\"o\">)</span> <span class=\"s2\">\"variable!\"</span> <span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"o\">)</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"sd\">/-- Try to elaborate `binders`, adding  -/</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">expandBinder</span> <span class=\"o\">(</span><span class=\"n\">depth</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">binder</span> <span class=\"o\">:</span> <span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.bracketedBinder</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">TermElabM</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.bracketedBinder</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"n\">depth</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n    <span class=\"n\">throwError</span> <span class=\"s2\">\"Maximum recursion depth for variables! reached.\"</span>\n  <span class=\"n\">withTheReader</span> <span class=\"n\">Term.Context</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">ctx</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">ctx</span> <span class=\"k\">with</span> <span class=\"n\">ignoreTCFailures</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">})</span>\n    <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.withAutoBoundImplicit</span>\n    <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.withSynthesize</span> <span class=\"o\">(</span><span class=\"n\">mayPostpone</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n    <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.elabBinders</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">binder</span><span class=\"o\">]</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">binders</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n      <span class=\"n\">for</span> <span class=\"n\">mvarId</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pendingMVars.reverse</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">decl</span> <span class=\"bp\">←</span> <span class=\"n\">Term.getSyntheticMVarDecl</span><span class=\"bp\">?</span> <span class=\"n\">mvarId</span> <span class=\"bp\">|</span> <span class=\"n\">continue</span>\n        <span class=\"k\">match</span> <span class=\"n\">decl.kind</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">typeClass</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">←</span> <span class=\"n\">PrettyPrinter.delab</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvarId.getType</span><span class=\"o\">)</span>\n          <span class=\"k\">let</span> <span class=\"n\">bi</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span> <span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">])</span>\n          <span class=\"k\">let</span> <span class=\"n\">binders'</span> <span class=\"bp\">←</span> <span class=\"n\">expandBinder</span> <span class=\"o\">(</span><span class=\"n\">depth</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">bi</span>\n          <span class=\"n\">binders</span> <span class=\"o\">:=</span> <span class=\"n\">binders</span> <span class=\"bp\">++</span> <span class=\"n\">binders'</span>\n        <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n      <span class=\"n\">return</span> <span class=\"n\">binders.push</span> <span class=\"n\">binder</span>\n\n<span class=\"kd\">@[command_elab «variable!»]</span> <span class=\"kd\">def</span> <span class=\"n\">elabVariables</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"bp\">$</span><span class=\"n\">binders</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">for</span> <span class=\"n\">binder</span> <span class=\"k\">in</span> <span class=\"n\">binders</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">bracketedBinderType</span> <span class=\"n\">binder</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isNone</span> <span class=\"k\">then</span>\n        <span class=\"n\">throwErrorAt</span> <span class=\"n\">binder</span> <span class=\"s2\">\"variable! cannot update pre-existing variables\"</span>\n      <span class=\"k\">let</span> <span class=\"n\">binders'</span> <span class=\"bp\">←</span> <span class=\"n\">runTermElabM</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">expandBinder</span> <span class=\"mi\">50</span> <span class=\"n\">binder</span>\n      <span class=\"n\">for</span> <span class=\"n\">binder</span> <span class=\"k\">in</span> <span class=\"n\">binders'</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">varUIds</span> <span class=\"bp\">←</span> <span class=\"n\">getBracketedBinderIds</span> <span class=\"n\">binder</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">mapM</span> <span class=\"o\">(</span><span class=\"n\">withFreshMacroScope</span> <span class=\"bp\">∘</span> <span class=\"n\">MonadQuotation.addMacroScope</span><span class=\"o\">)</span>\n        <span class=\"n\">modifyScope</span> <span class=\"k\">fun</span> <span class=\"n\">scope</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">scope</span> <span class=\"k\">with</span> <span class=\"n\">varDecls</span> <span class=\"o\">:=</span> <span class=\"n\">scope.varDecls.push</span> <span class=\"n\">binder</span><span class=\"o\">,</span> <span class=\"n\">varUIds</span> <span class=\"o\">:=</span> <span class=\"n\">scope.varUIds</span> <span class=\"bp\">++</span> <span class=\"n\">varUIds</span> <span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kd\">@[unused_variables_ignore_fn]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ignoreVariable</span><span class=\"bp\">!</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Linter.IgnoreFunction</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">stack</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">stack.matches</span> <span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">null</span><span class=\"o\">,</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">null</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">Mathlib.Command.variable</span><span class=\"bp\">!</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Mathlib.Command</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"c1\">-- works like `variable`</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">Nat</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"c1\">-- fails (intentionally doesn't support updating)</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"c1\">-- fails (same reason)</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.18467</span>\n<span class=\"cm\">M: Type ?u.18470</span>\n<span class=\"cm\">inst✝²: Semiring R</span>\n<span class=\"cm\">inst✝¹: AddCommMonoid M</span>\n<span class=\"cm\">inst✝: Module R M</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.18767</span>\n<span class=\"cm\">A: Type ?u.18770</span>\n<span class=\"cm\">inst✝²: CommSemiring R</span>\n<span class=\"cm\">inst✝¹: Semiring A</span>\n<span class=\"cm\">inst✝: Algebra R A</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">S</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">M'</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.20902</span>\n<span class=\"cm\">M: Type ?u.20905</span>\n<span class=\"cm\">S: Type ?u.20932</span>\n<span class=\"cm\">M': Type ?u.20935</span>\n<span class=\"cm\">inst✝⁵: Semiring R</span>\n<span class=\"cm\">inst✝⁴: AddCommMonoid M</span>\n<span class=\"cm\">inst✝³: Module R M</span>\n<span class=\"cm\">inst✝²: Semiring S</span>\n<span class=\"cm\">inst✝¹: AddCommMonoid M'</span>\n<span class=\"cm\">inst✝: Module S M'</span>\n<span class=\"cm\">σ: R →+* S</span>\n<span class=\"cm\">f: M →ₛₗ[σ] M'</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>\n<p>(v2 below)</p>",
        "id": 345211189,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680028495
    },
    {
        "content": "<p>Can it do unique factorization domains? :-) (I ask because I had no clue how to say \"let R be a unique factorization domain\" until a few weeks ago)</p>",
        "id": 345211462,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680028590
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I think you'll have to give me a hint, since I'm at least a few weeks behind you there</p>",
        "id": 345211845,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680028714
    },
    {
        "content": "<p>My understanding is that right now you have to say <code>variables (R : Type) [comm_ring R] [is_domain R] [unique_factorization_monoid R]</code></p>",
        "id": 345221862,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680031520
    },
    {
        "content": "<p>Ah, for that we could have a fake typeclass that implies those typeclasses and which doesn't itself appear in the final variables list.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"c1\">-- Imagine this is marked in some way as being an alias for `variables!` purposes</span>\n<span class=\"kd\">class</span> <span class=\"n\">UniqueFactorizationDomain</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsDomain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniqueFactorizationMonoid</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">UniqueFactorizationDomain</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.26397</span>\n<span class=\"cm\">inst✝³: CommRing R</span>\n<span class=\"cm\">inst✝²: IsDomain R</span>\n<span class=\"cm\">inst✝¹: UniqueFactorizationMonoid R</span>\n<span class=\"cm\">inst✝: UniqueFactorizationDomain R -- imagine it doesn't include this</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 345230215,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680033379
    },
    {
        "content": "<p>Here's a version that seems to be more robust. I was having a hard time juggling the pending metavariables and getting into the right local contexts, so instead this keeps inserting missing variables and re-elaborating until there are no more failures.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code v2</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Module.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Algebra.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Module.LinearMap</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.UniqueFactorizationDomain</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Mathlib.Command</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Lean.Elab</span> <span class=\"n\">Lean.Elab.Command</span> <span class=\"n\">Lean.Parser.Term</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">bracketedBinderType</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">term</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">_</span><span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"o\">[:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"bp\">?</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">_annot</span><span class=\"bp\">?</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ty</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">{</span><span class=\"bp\">$</span><span class=\"n\">_</span><span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"o\">[:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"bp\">?</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">})</span>             <span class=\"bp\">=&gt;</span> <span class=\"n\">ty</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">_</span> <span class=\"o\">:]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">])</span>               <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">ty</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">])</span>                        <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">ty</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>                                                <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">«</span><span class=\"kd\">variable</span><span class=\"bp\">!»</span><span class=\"o\">)</span> <span class=\"s2\">\"variable!\"</span> <span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"o\">)</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"sd\">/-- Tries elaborating binders, inserting new binders whenever typeclass inference fails.</span>\n<span class=\"sd\">`i` is the index of the next binder that needs to be checked. -/</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">completeBinders</span> <span class=\"o\">(</span><span class=\"n\">gas</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">binders</span> <span class=\"o\">:</span> <span class=\"n\">TSyntaxArray</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.bracketedBinder</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">TermElabM</span> <span class=\"o\">(</span><span class=\"n\">TSyntaxArray</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.bracketedBinder</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"n\">gas</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n    <span class=\"n\">throwError</span> <span class=\"s2\">\"Maximum recursion depth for variables! reached, likely due to a bug.\"</span>\n  <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">binders.size</span> <span class=\"k\">then</span>\n    <span class=\"c1\">-- Try elaborating the binders so far and see if there are any pending metavariables</span>\n    <span class=\"n\">withTheReader</span> <span class=\"n\">Term.Context</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">ctx</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">ctx</span> <span class=\"k\">with</span> <span class=\"n\">ignoreTCFailures</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">})</span>\n    <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.withAutoBoundImplicit</span>\n    <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.withSynthesize</span> <span class=\"o\">(</span><span class=\"n\">mayPostpone</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n    <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.elabBinders</span> <span class=\"o\">(</span><span class=\"n\">binders.extract</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">binders'</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n      <span class=\"n\">for</span> <span class=\"n\">mvarId</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pendingMVars.reverse</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">decl</span> <span class=\"bp\">←</span> <span class=\"n\">Term.getSyntheticMVarDecl</span><span class=\"bp\">?</span> <span class=\"n\">mvarId</span> <span class=\"bp\">|</span> <span class=\"n\">continue</span>\n        <span class=\"k\">match</span> <span class=\"n\">decl.kind</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">typeClass</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">←</span> <span class=\"n\">PrettyPrinter.delab</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvarId.getType</span><span class=\"o\">))</span>\n          <span class=\"k\">let</span> <span class=\"n\">bi</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span> <span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">])</span>\n          <span class=\"n\">binders'</span> <span class=\"o\">:=</span> <span class=\"n\">binders'.push</span> <span class=\"n\">bi</span>\n        <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n      <span class=\"k\">if</span> <span class=\"n\">binders'.isEmpty</span> <span class=\"k\">then</span>\n        <span class=\"n\">completeBinders</span> <span class=\"n\">gas</span> <span class=\"n\">binders</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n      <span class=\"k\">else</span>\n        <span class=\"k\">let</span> <span class=\"n\">binders</span> <span class=\"o\">:=</span> <span class=\"n\">binders.extract</span> <span class=\"mi\">0</span> <span class=\"n\">i</span> <span class=\"bp\">++</span> <span class=\"n\">binders'</span> <span class=\"bp\">++</span> <span class=\"n\">binders.extract</span> <span class=\"n\">i</span> <span class=\"n\">binders.size</span>\n        <span class=\"n\">completeBinders</span> <span class=\"o\">(</span><span class=\"n\">gas</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">binders</span> <span class=\"n\">i</span>\n  <span class=\"k\">else</span>\n    <span class=\"c1\">-- One last check with the correct configuration.</span>\n    <span class=\"n\">Term.withAutoBoundImplicit</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.elabBinders</span> <span class=\"n\">binders</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"n\">return</span> <span class=\"n\">binders</span>\n\n<span class=\"kd\">@[command_elab «variable!»]</span> <span class=\"kd\">def</span> <span class=\"n\">elabVariables</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"bp\">$</span><span class=\"n\">binders</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">for</span> <span class=\"n\">binder</span> <span class=\"k\">in</span> <span class=\"n\">binders</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">bracketedBinderType</span> <span class=\"n\">binder</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isNone</span> <span class=\"k\">then</span>\n        <span class=\"n\">throwErrorAt</span> <span class=\"n\">binder</span> <span class=\"s2\">\"variable! cannot update pre-existing variables\"</span>\n    <span class=\"k\">let</span> <span class=\"n\">binders'</span> <span class=\"bp\">←</span> <span class=\"n\">runTermElabM</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">completeBinders</span> <span class=\"mi\">50</span> <span class=\"n\">binders</span> <span class=\"mi\">0</span>\n    <span class=\"n\">for</span> <span class=\"n\">binder</span> <span class=\"k\">in</span> <span class=\"n\">binders'</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">varUIds</span> <span class=\"bp\">←</span> <span class=\"n\">getBracketedBinderIds</span> <span class=\"n\">binder</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">mapM</span> <span class=\"o\">(</span><span class=\"n\">withFreshMacroScope</span> <span class=\"bp\">∘</span> <span class=\"n\">MonadQuotation.addMacroScope</span><span class=\"o\">)</span>\n      <span class=\"n\">modifyScope</span> <span class=\"k\">fun</span> <span class=\"n\">scope</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">scope</span> <span class=\"k\">with</span> <span class=\"n\">varDecls</span> <span class=\"o\">:=</span> <span class=\"n\">scope.varDecls.push</span> <span class=\"n\">binder</span><span class=\"o\">,</span> <span class=\"n\">varUIds</span> <span class=\"o\">:=</span> <span class=\"n\">scope.varUIds</span> <span class=\"bp\">++</span> <span class=\"n\">varUIds</span> <span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kd\">@[unused_variables_ignore_fn]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ignoreVariable</span><span class=\"bp\">!</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Linter.IgnoreFunction</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">stack</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">stack.matches</span> <span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">null</span><span class=\"o\">,</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">null</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">Mathlib.Command.variable</span><span class=\"bp\">!</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Mathlib.Command</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"c1\">-- works like `variable`</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">Nat</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"c1\">-- fails (intentionally doesn't support updating)</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"c1\">-- fails (same reason)</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.18467</span>\n<span class=\"cm\">M: Type ?u.18470</span>\n<span class=\"cm\">inst✝²: Semiring R</span>\n<span class=\"cm\">inst✝¹: AddCommMonoid M</span>\n<span class=\"cm\">inst✝: Module R M</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.18767</span>\n<span class=\"cm\">A: Type ?u.18770</span>\n<span class=\"cm\">inst✝²: CommSemiring R</span>\n<span class=\"cm\">inst✝¹: Semiring A</span>\n<span class=\"cm\">inst✝: Algebra R A</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">S</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">M'</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.20902</span>\n<span class=\"cm\">M: Type ?u.20905</span>\n<span class=\"cm\">S: Type ?u.20932</span>\n<span class=\"cm\">M': Type ?u.20935</span>\n<span class=\"cm\">inst✝⁵: Semiring R</span>\n<span class=\"cm\">inst✝⁴: AddCommMonoid M</span>\n<span class=\"cm\">inst✝³: Module R M</span>\n<span class=\"cm\">inst✝²: Semiring S</span>\n<span class=\"cm\">inst✝¹: AddCommMonoid M'</span>\n<span class=\"cm\">inst✝: Module S M'</span>\n<span class=\"cm\">σ: R →+* S</span>\n<span class=\"cm\">f: M →ₛₗ[σ] M'</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">S</span> <span class=\"n\">M'</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Limitation:</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.24671</span>\n<span class=\"cm\">S: Type ?u.24674</span>\n<span class=\"cm\">M: Type ?u.24695</span>\n<span class=\"cm\">M': Type ?u.24727</span>\n<span class=\"cm\">inst✝⁷: NonAssocSemiring R</span>\n<span class=\"cm\">inst✝⁶: NonAssocSemiring S</span>\n<span class=\"cm\">σ: R →+* S</span>\n<span class=\"cm\">inst✝⁵: Semiring R</span>\n<span class=\"cm\">inst✝⁴: AddCommMonoid M</span>\n<span class=\"cm\">inst✝³: Module R M</span>\n<span class=\"cm\">inst✝²: Semiring S</span>\n<span class=\"cm\">inst✝¹: AddCommMonoid M'</span>\n<span class=\"cm\">inst✝: Module S M'</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsDomain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniqueFactorizationMonoid</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.23587</span>\n<span class=\"cm\">inst✝²: CommRing R</span>\n<span class=\"cm\">inst✝¹: IsDomain R</span>\n<span class=\"cm\">inst✝: UniqueFactorizationMonoid R</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>\n<p>(edit: <a href=\"#narrow/stream/287929-mathlib4/topic/Introducing.20all.20dependent.20variables/near/345257734\">v3 below</a>)</p>",
        "id": 345230435,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680033453
    },
    {
        "content": "<p>There's a limitation with this approach, though, where it doesn't do any computations to see whether some typeclasses imply others</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">S</span> <span class=\"n\">M'</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.24671</span>\n<span class=\"cm\">S: Type ?u.24674</span>\n<span class=\"cm\">M: Type ?u.24695</span>\n<span class=\"cm\">M': Type ?u.24727</span>\n<span class=\"cm\">inst✝⁷: NonAssocSemiring R</span>\n<span class=\"cm\">inst✝⁶: NonAssocSemiring S</span>\n<span class=\"cm\">σ: R →+* S</span>\n<span class=\"cm\">inst✝⁵: Semiring R</span>\n<span class=\"cm\">inst✝⁴: AddCommMonoid M</span>\n<span class=\"cm\">inst✝³: Module R M</span>\n<span class=\"cm\">inst✝²: Semiring S</span>\n<span class=\"cm\">inst✝¹: AddCommMonoid M'</span>\n<span class=\"cm\">inst✝: Module S M'</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 345230607,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680033494
    },
    {
        "content": "<p>oh man, I want to change the defaults to make everything a <code>comm_ring</code>. Would that be possible? Heh, maybe I'm just asking for <code>variable</code> :-)</p>",
        "id": 345231336,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680033704
    },
    {
        "content": "<p>Putting some <code>CommRing</code> instances first definitely fixes this last problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">S</span> <span class=\"n\">M'</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.30154</span>\n<span class=\"cm\">S: Type ?u.30157</span>\n<span class=\"cm\">M: Type ?u.30320</span>\n<span class=\"cm\">M': Type ?u.30490</span>\n<span class=\"cm\">inst✝⁵: CommRing R</span>\n<span class=\"cm\">inst✝⁴: CommRing S</span>\n<span class=\"cm\">σ: R →+* S</span>\n<span class=\"cm\">inst✝³: AddCommMonoid M</span>\n<span class=\"cm\">inst✝²: Module R M</span>\n<span class=\"cm\">inst✝¹: AddCommMonoid M'</span>\n<span class=\"cm\">inst✝: Module S M'</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 345231936,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680033871
    },
    {
        "content": "<p>I could imagine there being a configuration option where you can give rules like \"if you need a NonAssocSemiring, add a CommRing instead\"</p>",
        "id": 345232027,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680033908
    },
    {
        "content": "<p>Really nice! For the syntax, I wonder: should it use <code>[[]]</code> (or whatever brackets we end up using for that) instead of <code>variable!</code>? E.g. <code>variable [[Module R M]]</code>? This would be consistent with doing the same thing inside <code>def</code>s and <code>theorem</code>s. Or is that impractical for some reason?</p>",
        "id": 345232345,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1680034022
    },
    {
        "content": "<p>This has wider scope than a <code>[[...]]</code> binder:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.30490</span>\n<span class=\"cm\">S: Type ?u.30493</span>\n<span class=\"cm\">inst✝¹: NonAssocSemiring R</span>\n<span class=\"cm\">inst✝: NonAssocSemiring S</span>\n<span class=\"cm\">σ: R →+* S</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 345232564,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680034098
    },
    {
        "content": "<p>Also, we can't define our own binders, unfortunately.</p>",
        "id": 345232611,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680034112
    },
    {
        "content": "<p>Ah, it also introduces dependencies for non-typeclass variables, got it!</p>",
        "id": 345232756,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1680034156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Introducing.20all.20dependent.20variables/near/345232611\">said</a>:</p>\n<blockquote>\n<p>Also, we can't define our own binders, unfortunately.</p>\n</blockquote>\n<p>Oh, that is unfortunate…!</p>",
        "id": 345233027,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1680034229
    },
    {
        "content": "<p>But I want <code>AddCommGroup</code>s! This is why I realise that I should probably just stick to <code>variable</code>. How about analysis?  Does <code>[normed_space 𝕜 E]</code> fill in the right gaps? What about <code>[normed_space ℝ E]</code>?</p>",
        "id": 345233223,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680034307
    },
    {
        "content": "<p>What about differential geometry? How much more do I have to give than <code>[smooth_manifold_with_corners I M]</code>?</p>",
        "id": 345233605,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680034433
    },
    {
        "content": "<p>It doesn't seem that <code>NormedSpace</code> is ported yet.</p>",
        "id": 345233609,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680034435
    },
    {
        "content": "<p>What's your objection about <code>AddCommGroup</code>?</p>",
        "id": 345233651,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680034443
    },
    {
        "content": "<p>your M was a monoid.</p>",
        "id": 345233708,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680034456
    },
    {
        "content": "<p>Then you can add that it's an additive commutative group:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">M: Type ?u.31767</span>\n<span class=\"cm\">R: Type ?u.31770</span>\n<span class=\"cm\">inst✝²: AddCommGroup M</span>\n<span class=\"cm\">inst✝¹: Semiring R</span>\n<span class=\"cm\">inst✝: Module R M</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 345233970,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680034557
    },
    {
        "content": "<p>But now R isn't a commutative ring -- what I'm saying is that I'm now understanding that actually I'd be better off with <code>variable</code> because tyipcally I do <em>not</em> want the minimal assumptions for which <code>module</code> makes sense (in fact I never want these assumptions)</p>",
        "id": 345234146,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680034613
    },
    {
        "content": "<p>Of course, others might.</p>",
        "id": 345234187,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680034628
    },
    {
        "content": "<p>Maybe we don't want <code>variable!</code> in mathlib code, but it at least shows you everything you need to address on your way to a complete <code>variable</code> line.</p>",
        "id": 345234212,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680034636
    },
    {
        "content": "<p>You can use <code>variable!</code> everywhere <code>variable</code> already works.</p>",
        "id": 345234259,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680034658
    },
    {
        "content": "<p>But also <code>R</code> was explicitly given as a commutative ring in the first example but not the second.</p>",
        "id": 345234412,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1680034705
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> maybe you want that sort of abbreviation typeclass mentioned earlier to use in place of <code>Module</code> here (which would add all the assumptions you <em>do</em> want)?</p>",
        "id": 345234581,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1680034782
    },
    {
        "content": "<p>There could be configuration options to help you deal with specific situations, like a commutative algebra setting where whenever there is a request for something <code>CommRing</code> implies then use <code>CommRing</code>, etc.</p>",
        "id": 345234683,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680034812
    },
    {
        "content": "<p>I don't really know what I want, I'm just wondering where these ideas are going. For me I always want R to be a commutative ring and M an R-module but I would imagine that the non-commutative guys always want R to be a ring. If semiring people actually exist (something I'm slightly skeptical about) then they'll want something else. I don't have a clear idea about how to support all these competing \"canonical\" assumptions.</p>",
        "id": 345234794,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680034875
    },
    {
        "content": "<p>Aah, yeah maybe switch on \"commutative algebra mode\" and then try it :-)</p>",
        "id": 345234827,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680034901
    },
    {
        "content": "<p>it could be <code>variable! (config := commAlg) ...</code> for you</p>",
        "id": 345234882,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680034918
    },
    {
        "content": "<p>Another example to show possible scope (introducing Decidable assumptions):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Nat.find</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">p: ℕ → Prop</span>\n<span class=\"cm\">h✝: ∃ k, p k</span>\n<span class=\"cm\">inst✝: DecidablePred fun n =&gt; p n</span>\n<span class=\"cm\">h: 0 &lt; Nat.find h✝</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 345235354,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680035089
    },
    {
        "content": "<p>Isn't the answer to Kevin's requrest just to adapt your</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Imagine this is marked in some way as being an alias for `variables!` purposes</span>\n<span class=\"kd\">class</span> <span class=\"n\">UniqueFactorizationDomain</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsDomain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniqueFactorizationMonoid</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>example above, but for <code>VectorSpace</code>?</p>",
        "id": 345235813,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680035275
    },
    {
        "content": "<p>Do we actually want to make this class?</p>",
        "id": 345235993,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680035343
    },
    {
        "content": "<p>I mean, it would be handy for maths undergraduates but would it clog up the system somehow? I remember trying to make vector space just to mean \"module over a field\" and then this was reverted later because it somehow caused trouble. (I have a poor understanding of these sorts of issues)</p>",
        "id": 345236074,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680035384
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Introducing.20all.20dependent.20variables/near/345235993\">said</a>:</p>\n<blockquote>\n<p>Do we actually want to make this class?</p>\n</blockquote>\n<p>Imagine classes that are used only for <code>variables!</code> and which would otherwise show a warning if you try to use them, and where they don't actually appear after they get expanded.</p>",
        "id": 345236963,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680035726
    },
    {
        "content": "<p>I don't think we want to make a class, but I think we could make it a macro of some kind</p>",
        "id": 345236979,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680035733
    },
    {
        "content": "<p><del>I don't think we want to make a class, but I think we could make it a macro of some kind</del> (edit: bad train internet)</p>",
        "id": 345236984,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680035736
    },
    {
        "content": "<p>Presumably we can override the parser for <code>theorem</code> in mathlib to handle <code>[[foo X]]</code> or <code>[!foo X]</code> or similar so that we're not limited to <code>variables</code> lines</p>",
        "id": 345237251,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680035844
    },
    {
        "content": "<p>(Off topic, but I do like e.g. <code>![foo X]</code> or <code>[foo X]!</code> better than <code>[[foo X]]</code>; all those square brackets are a bit busy imo :) )</p>",
        "id": 345237741,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1680036065
    },
    {
        "content": "<p>The other option is of course introducing an analogous <code>theorem!</code></p>",
        "id": 345238161,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1680036227
    },
    {
        "content": "<p><code>![foo X]</code> might conflict with vector notation; if not to Lean, then perhaps still to the reader</p>",
        "id": 345238247,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680036249
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Introducing.20all.20dependent.20variables/near/345235813\">said</a>:</p>\n<blockquote>\n<p>Isn't the answer to Kevin's requrest just to adapt your [...]</p>\n</blockquote>\n<p>That's one answer, but it might be nice to be able to write <code>variable! (σ : R →+* S)</code> and have it introduce <code>CommRing</code>s instead of  <code>NonAssocSemiring</code>s, if things are in commutative algebraist mode. The class alias idea is just for packaging up some common notions, when it's not obvious what you're supposed to introduce.</p>\n<p>One reason using <code>class</code> for this is convenient (rather than creating macros) is that you get things like documentation on mouseover for free, and it'd be easier for non-macro-ologists to write their own. You also can see that your alias is type correct, which you don't get with macros. Still, I wonder if there are examples where macros would be more flexible.</p>",
        "id": 345245564,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680039264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Introducing.20all.20dependent.20variables/near/345237251\">said</a>:</p>\n<blockquote>\n<p>Presumably we can override the parser for <code>theorem</code> in mathlib to handle <code>[[foo X]]</code> or <code>[!foo X]</code> or similar so that we're not limited to <code>variables</code> lines</p>\n</blockquote>\n<p>Ideally we would find some way to do this under binders as well... What if I want to write <code>forall R S [[Module R S]], ...</code>?</p>",
        "id": 345246112,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1680039487
    },
    {
        "content": "<p>Maybe more generally <code>forall (! σ : R →+* S), ...</code> and <code>forall R S [! Module R S], ...</code></p>",
        "id": 345246438,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680039620
    },
    {
        "content": "<p>Is that possible? I thought Mario said it was not on some other thread.</p>",
        "id": 345246501,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1680039653
    },
    {
        "content": "<p>I mean, <code>forall R S [[Module R S]], ...</code> isn't possible either, right?</p>",
        "id": 345246601,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680039692
    },
    {
        "content": "<p>right</p>",
        "id": 345246613,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1680039697
    },
    {
        "content": "<p>that's why I'm asking the expert :)</p>",
        "id": 345246631,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1680039705
    },
    {
        "content": "<p>I'm just dreaming. Maybe one day Lean 4 devs will create hooks for our own binder types.</p>",
        "id": 345246733,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680039743
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Introducing.20all.20dependent.20variables/near/345246112\">said</a>:</p>\n<blockquote>\n<p>Ideally we would find some way to do this under binders as well... What if I want to write <code>forall R S [[Module R S]], ...</code>?</p>\n</blockquote>\n<p>That feels like a very niche case where it probably pays to be explicit</p>",
        "id": 345254620,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680043146
    },
    {
        "content": "<p>But this is a general idea... somehow <code>[[Module R S]]</code> should expand to <code>[Semiring R] [AddMonoid S] [Module R S]</code> in all places where this can apply.</p>",
        "id": 345254790,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1680043205
    },
    {
        "content": "<p>And it's not too niche. For example it's certainly reasonable to imagine something like this being used in the definition of some universal property or something.</p>",
        "id": 345254928,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1680043270
    },
    {
        "content": "<p>I suppose if we had such a general feature, we would end up using a lot more mixins, making it even more common.</p>",
        "id": 345255029,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1680043310
    },
    {
        "content": "<blockquote>\n<p>For example it's certainly reasonable to imagine something like this being used in the definition of some universal property or something.</p>\n</blockquote>\n<p>I would claim this probably happens no more than 10 times in mathlib, but maybe I'm not familiar with the parts that do this</p>",
        "id": 345255423,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680043486
    },
    {
        "content": "<p>maybe it happens so few times because it's not convenient to do (yet)?</p>",
        "id": 345255839,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1680043665
    },
    {
        "content": "<p>It certainly was not convenient in lean3 not just because of the topic of this thread, but also because the instances didn't register (without using introsI and friends). But now that's been fixed in lean4, and I can imagine it becoming more commonplace.</p>",
        "id": 345256085,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1680043761
    },
    {
        "content": "<p>What's the argument here Eric? I'm not sure why it matters if it's a niche use -- if we had the ability to make our own binders that seems like the right way to implement this feature everywhere.</p>",
        "id": 345256270,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680043836
    },
    {
        "content": "<p>Mainly just that custom binders in <code>theorem</code>/<code>def</code>/<code>variable</code> is probably possible to do without core changes, and that the benefit of supporting <code>forall</code> on top of that is pretty marginal.</p>",
        "id": 345256541,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680043952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Introducing.20all.20dependent.20variables/near/345234882\">said</a>:</p>\n<blockquote>\n<p>it could be <code>variable! (config := commAlg) ...</code> for you</p>\n</blockquote>\n<p>i wonder if this should be file-wide</p>",
        "id": 345256924,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1680044113
    },
    {
        "content": "<p>Ok, I think saying <code>forall</code> is a niche use is completely independent of whether in the short term (i.e., before the hypothetical time when Lean supports custom binders) we might have custom <code>theorem</code>/<code>def</code>/<code>variable</code>s for mathlib that support additional binder types. The only reason why it would matter is if someone were to suggest making a custom <code>forall</code> too.</p>",
        "id": 345257010,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680044153
    },
    {
        "content": "<p>Here's a v3, now with \"Try this\" and hopefully more robust binder insertion. Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span><span class=\"bp\">!?</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Try this: variable [CommSemiring R] [Semiring A] [Algebra R A]</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code v3</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Module.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Algebra.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Module.LinearMap</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.UniqueFactorizationDomain</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Mathlib.Command</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Lean.Elab</span> <span class=\"n\">Lean.Elab.Command</span> <span class=\"n\">Lean.Parser.Term</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">bracketedBinderType</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">term</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">_</span><span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"o\">[:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"bp\">?</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">_annot</span><span class=\"bp\">?</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ty</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">{</span><span class=\"bp\">$</span><span class=\"n\">_</span><span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"o\">[:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"bp\">?</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">})</span>             <span class=\"bp\">=&gt;</span> <span class=\"n\">ty</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">_</span> <span class=\"o\">:]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">])</span>               <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">ty</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">])</span>                        <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">ty</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>                                                <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">«</span><span class=\"kd\">variable</span><span class=\"bp\">!»</span><span class=\"o\">)</span> <span class=\"s2\">\"variable!\"</span> <span class=\"s2\">\"?\"</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">bracketedBinder</span><span class=\"o\">)</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n<span class=\"n\">macro</span> <span class=\"s2\">\"variable!?\"</span> <span class=\"n\">binders</span><span class=\"o\">:</span><span class=\"n\">bracketedBinder</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span> <span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"n\">binders</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Tries elaborating binders, inserting new binders whenever typeclass inference fails.</span>\n<span class=\"sd\">`i` is the index of the next binder that needs to be checked. -/</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">completeBinders</span> <span class=\"o\">(</span><span class=\"n\">gas</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">binders</span> <span class=\"o\">:</span> <span class=\"n\">TSyntaxArray</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.bracketedBinder</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">CommandElabM</span> <span class=\"o\">(</span><span class=\"n\">TSyntaxArray</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.bracketedBinder</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">gas</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">binders.size</span> <span class=\"k\">then</span>\n    <span class=\"c1\">-- Try elaborating the binders so far and see if they create any pending metavariables.</span>\n    <span class=\"k\">let</span> <span class=\"n\">info</span> <span class=\"bp\">←</span> <span class=\"n\">getInfoState</span>\n    <span class=\"k\">let</span> <span class=\"n\">binders'</span> <span class=\"bp\">←</span> <span class=\"n\">runTermElabM</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"n\">withTheReader</span> <span class=\"n\">Term.Context</span>\n          <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">ctx</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">ctx</span> <span class=\"k\">with</span> <span class=\"n\">ignoreTCFailures</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">})</span>\n      <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.withAutoBoundImplicit</span>\n      <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.withSynthesize</span> <span class=\"o\">(</span><span class=\"n\">mayPostpone</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n      <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.elabBinders</span> <span class=\"o\">(</span><span class=\"n\">binders.extract</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">binders'</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n        <span class=\"k\">let</span> <span class=\"n\">pendingSet</span> <span class=\"o\">:</span> <span class=\"n\">MVarIdSet</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pendingMVars.foldl</span> <span class=\"n\">MVarIdSet.insert</span> <span class=\"n\">RBMap.empty</span>\n        <span class=\"n\">for</span> <span class=\"n\">mvarId</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pendingMVars.reverse</span> <span class=\"k\">do</span>\n          <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">decl</span> <span class=\"bp\">←</span> <span class=\"n\">Term.getSyntheticMVarDecl</span><span class=\"bp\">?</span> <span class=\"n\">mvarId</span> <span class=\"bp\">|</span> <span class=\"n\">continue</span>\n          <span class=\"k\">match</span> <span class=\"n\">decl.kind</span> <span class=\"k\">with</span>\n          <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">typeClass</span> <span class=\"bp\">=&gt;</span>\n            <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvarId.getType</span><span class=\"o\">)</span>\n            <span class=\"c1\">-- Only want to consider those that don't have natural metavariables, which helps</span>\n            <span class=\"c1\">-- prevent infinite regress.</span>\n            <span class=\"k\">let</span> <span class=\"n\">nonSynthMVar</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"n\">ty.findMVar</span><span class=\"bp\">?</span> <span class=\"k\">fun</span> <span class=\"n\">mvar</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">not</span> <span class=\"o\">(</span><span class=\"n\">RBMap.contains</span> <span class=\"n\">pendingSet</span> <span class=\"n\">mvar</span><span class=\"o\">)</span>\n            <span class=\"k\">if</span> <span class=\"n\">nonSynthMVar</span><span class=\"bp\">?.</span><span class=\"n\">isNone</span> <span class=\"k\">then</span>\n              <span class=\"k\">let</span> <span class=\"n\">bi</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span> <span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">PrettyPrinter.delab</span> <span class=\"n\">ty</span><span class=\"o\">)])</span>\n              <span class=\"n\">binders'</span> <span class=\"o\">:=</span> <span class=\"n\">binders'.push</span> <span class=\"n\">bi</span>\n          <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n        <span class=\"n\">return</span> <span class=\"n\">binders'</span>\n    <span class=\"n\">setInfoState</span> <span class=\"n\">info</span>\n    <span class=\"k\">if</span> <span class=\"n\">binders'.isEmpty</span> <span class=\"k\">then</span>\n      <span class=\"n\">completeBinders</span> <span class=\"n\">gas</span> <span class=\"n\">binders</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span>\n      <span class=\"k\">let</span> <span class=\"n\">binders</span> <span class=\"o\">:=</span> <span class=\"n\">binders.extract</span> <span class=\"mi\">0</span> <span class=\"n\">i</span> <span class=\"bp\">++</span> <span class=\"n\">binders'</span> <span class=\"bp\">++</span> <span class=\"n\">binders.extract</span> <span class=\"n\">i</span> <span class=\"n\">binders.size</span>\n      <span class=\"n\">completeBinders</span> <span class=\"o\">(</span><span class=\"n\">gas</span> <span class=\"bp\">-</span> <span class=\"n\">binders'.size</span><span class=\"o\">)</span> <span class=\"n\">binders</span> <span class=\"n\">i</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">if</span> <span class=\"n\">gas</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n      <span class=\"n\">logError</span> <span class=\"s2\">\"Maximum recursion depth for variables! reached, likely due to a bug.\"</span>\n    <span class=\"c1\">-- One last check with the correct configuration.</span>\n    <span class=\"n\">runTermElabM</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Term.withAutoBoundImplicit</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.elabBinders</span> <span class=\"n\">binders</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"n\">return</span> <span class=\"n\">binders</span>\n\n<span class=\"kd\">@[command_elab «variable!»]</span> <span class=\"kd\">def</span> <span class=\"n\">elabVariables</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">?%$</span><span class=\"n\">info</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"n\">binders</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">for</span> <span class=\"n\">binder</span> <span class=\"k\">in</span> <span class=\"n\">binders</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">bracketedBinderType</span> <span class=\"n\">binder</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isNone</span> <span class=\"k\">then</span>\n        <span class=\"n\">throwErrorAt</span> <span class=\"n\">binder</span> <span class=\"s2\">\"variable! cannot update pre-existing variables\"</span>\n    <span class=\"k\">let</span> <span class=\"n\">binders'</span> <span class=\"bp\">←</span> <span class=\"n\">completeBinders</span> <span class=\"mi\">50</span> <span class=\"n\">binders</span> <span class=\"mi\">0</span>\n    <span class=\"k\">if</span> <span class=\"n\">info.isSome</span> <span class=\"k\">then</span>\n      <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"Try this: {← `(variable $binders'*)}\"</span>\n    <span class=\"n\">for</span> <span class=\"n\">binder</span> <span class=\"k\">in</span> <span class=\"n\">binders'</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">varUIds</span> <span class=\"bp\">←</span> <span class=\"n\">getBracketedBinderIds</span> <span class=\"n\">binder</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">mapM</span> <span class=\"o\">(</span><span class=\"n\">withFreshMacroScope</span> <span class=\"bp\">∘</span> <span class=\"n\">MonadQuotation.addMacroScope</span><span class=\"o\">)</span>\n      <span class=\"n\">modifyScope</span> <span class=\"k\">fun</span> <span class=\"n\">scope</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">scope</span> <span class=\"k\">with</span> <span class=\"n\">varDecls</span> <span class=\"o\">:=</span> <span class=\"n\">scope.varDecls.push</span> <span class=\"n\">binder</span><span class=\"o\">,</span> <span class=\"n\">varUIds</span> <span class=\"o\">:=</span> <span class=\"n\">scope.varUIds</span> <span class=\"bp\">++</span> <span class=\"n\">varUIds</span> <span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kd\">@[unused_variables_ignore_fn]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ignoreVariable</span><span class=\"bp\">!</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Linter.IgnoreFunction</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">stack</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">stack.matches</span> <span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">null</span><span class=\"o\">,</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">null</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">Mathlib.Command.variable</span><span class=\"bp\">!</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Mathlib.Command</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"c1\">-- works like `variable`</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">Nat</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"c1\">-- fails (intentionally doesn't support updating)</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"c1\">-- fails (same reason)</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.18467</span>\n<span class=\"cm\">M: Type ?u.18470</span>\n<span class=\"cm\">inst✝²: Semiring R</span>\n<span class=\"cm\">inst✝¹: AddCommMonoid M</span>\n<span class=\"cm\">inst✝: Module R M</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.18767</span>\n<span class=\"cm\">A: Type ?u.18770</span>\n<span class=\"cm\">inst✝²: CommSemiring R</span>\n<span class=\"cm\">inst✝¹: Semiring A</span>\n<span class=\"cm\">inst✝: Algebra R A</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!?</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Try this: variable [CommSemiring R] [Semiring A] [Algebra R A]</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"c1\">-- Bug: doesn't report error unless you uncomment the `#check`.</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">S</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">M'</span><span class=\"o\">)</span>\n<span class=\"c1\">--#check 1</span>\n\n<span class=\"c1\">-- This is a bug in variables, too.</span>\n<span class=\"c1\">-- variable [Semiring R] [AddCommMonoid M] [Module R M] [Semiring S]</span>\n<span class=\"c1\">--   [AddCommMonoid M'] [Module S M'] (f : M →ₛₗ[σ] M')</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">S</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">M'</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.20902</span>\n<span class=\"cm\">M: Type ?u.20905</span>\n<span class=\"cm\">S: Type ?u.20932</span>\n<span class=\"cm\">M': Type ?u.20935</span>\n<span class=\"cm\">inst✝⁵: Semiring R</span>\n<span class=\"cm\">inst✝⁴: AddCommMonoid M</span>\n<span class=\"cm\">inst✝³: Module R M</span>\n<span class=\"cm\">inst✝²: Semiring S</span>\n<span class=\"cm\">inst✝¹: AddCommMonoid M'</span>\n<span class=\"cm\">inst✝: Module S M'</span>\n<span class=\"cm\">σ: R →+* S</span>\n<span class=\"cm\">f: M →ₛₗ[σ] M'</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">S</span> <span class=\"n\">M'</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Limitation:</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.24671</span>\n<span class=\"cm\">S: Type ?u.24674</span>\n<span class=\"cm\">M: Type ?u.24695</span>\n<span class=\"cm\">M': Type ?u.24727</span>\n<span class=\"cm\">inst✝⁷: NonAssocSemiring R</span>\n<span class=\"cm\">inst✝⁶: NonAssocSemiring S</span>\n<span class=\"cm\">σ: R →+* S</span>\n<span class=\"cm\">inst✝⁵: Semiring R</span>\n<span class=\"cm\">inst✝⁴: AddCommMonoid M</span>\n<span class=\"cm\">inst✝³: Module R M</span>\n<span class=\"cm\">inst✝²: Semiring S</span>\n<span class=\"cm\">inst✝¹: AddCommMonoid M'</span>\n<span class=\"cm\">inst✝: Module S M'</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsDomain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniqueFactorizationMonoid</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.23587</span>\n<span class=\"cm\">inst✝²: CommRing R</span>\n<span class=\"cm\">inst✝¹: IsDomain R</span>\n<span class=\"cm\">inst✝: UniqueFactorizationMonoid R</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"c1\">-- Imagine this is marked in some way as being an alias for `variables!`</span>\n<span class=\"kd\">class</span> <span class=\"n\">UniqueFactorizationDomain</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsDomain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniqueFactorizationMonoid</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">UniqueFactorizationDomain</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.26397</span>\n<span class=\"cm\">inst✝³: CommRing R</span>\n<span class=\"cm\">inst✝²: IsDomain R</span>\n<span class=\"cm\">inst✝¹: UniqueFactorizationMonoid R</span>\n<span class=\"cm\">inst✝: UniqueFactorizationDomain R -- imagine it doesn't include this</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">S</span> <span class=\"n\">M'</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.30154</span>\n<span class=\"cm\">S: Type ?u.30157</span>\n<span class=\"cm\">M: Type ?u.30320</span>\n<span class=\"cm\">M': Type ?u.30490</span>\n<span class=\"cm\">inst✝⁵: CommRing R</span>\n<span class=\"cm\">inst✝⁴: CommRing S</span>\n<span class=\"cm\">σ: R →+* S</span>\n<span class=\"cm\">inst✝³: AddCommMonoid M</span>\n<span class=\"cm\">inst✝²: Module R M</span>\n<span class=\"cm\">inst✝¹: AddCommMonoid M'</span>\n<span class=\"cm\">inst✝: Module S M'</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">R: Type ?u.30490</span>\n<span class=\"cm\">S: Type ?u.30493</span>\n<span class=\"cm\">inst✝¹: NonAssocSemiring R</span>\n<span class=\"cm\">inst✝: NonAssocSemiring S</span>\n<span class=\"cm\">σ: R →+* S</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">M: Type ?u.31767</span>\n<span class=\"cm\">R: Type ?u.31770</span>\n<span class=\"cm\">inst✝²: AddCommGroup M</span>\n<span class=\"cm\">inst✝¹: Semiring R</span>\n<span class=\"cm\">inst✝: Module R M</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Nat.find</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">p: ℕ → Prop</span>\n<span class=\"cm\">h✝: ∃ k, p k</span>\n<span class=\"cm\">inst✝: DecidablePred fun n =&gt; p n</span>\n<span class=\"cm\">h: 0 &lt; Nat.find h✝</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 345257734,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680044445
    },
    {
        "content": "<p>I spent a while trying to track down a bug in what I thought was my own code, but I guess <code>variable</code> has the same bug.</p>\n<p>This doesn't report any errors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n   <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">S</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">M'</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This does:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n   <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">S</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">M'</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"mi\">1</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Error on f's type:</span>\n<span class=\"cm\">typeclass instance problem is stuck, it is often due to metavariables</span>\n<span class=\"cm\">  Module ?m.34167 M'</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 345258201,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680044633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Introducing.20all.20dependent.20variables/near/345257010\">said</a>:</p>\n<blockquote>\n<p>Ok, I think saying <code>forall</code> is a niche use is completely independent of whether in the short term (i.e., before the hypothetical time when Lean supports custom binders) we might have custom <code>theorem</code>/<code>def</code>/<code>variable</code>s for mathlib that support additional binder types. The only reason why it would matter is if someone were to suggest making a custom <code>forall</code> too.</p>\n</blockquote>\n<p>I am generally dubious of approaches that require replacing <code>theorem</code>/<code>def</code> etc. I think there will be a lot of unintended side effects of doing that across mathlib, e.g. some stuff hard coded in the server looking for a certain syntax kind, syntax kinds being referred to in mathport (or choice nodes!)</p>",
        "id": 345268704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1680050419
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Is the problem that you didn't specify <code>σ</code>, and Lean is telling you this in a somewhat opaque way?</p>",
        "id": 345281177,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1680058152
    },
    {
        "content": "<p>Yeah, that's why there's an error (when it decides to actually report it). The autoimplicit feature adds <code>σ : ?R1 -&gt;*+ ?R2</code> to the context, and then it tries to infer <code>Module ?R1 M</code> and <code>Module ?R2 M'</code>, but it can't make any progress on these (and they definitely don't follow from <code>Module R M</code> or <code>Module S M'</code>).</p>",
        "id": 345282889,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1680059185
    },
    {
        "content": "<p>Can we have this in core? <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>",
        "id": 345287477,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1680062266
    }
]