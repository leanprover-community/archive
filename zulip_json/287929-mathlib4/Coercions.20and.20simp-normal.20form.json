[
    {
        "content": "<p>Short question: when there are multiple \"paths\" to coerce a complicated object into a simpler one, how should one go about determining which is preferred either by <code>coe</code> or by <code>simp</code>?</p>\n<p>I've hit this issue working with equivalences of algebras over a ring. If <code>A, B</code> are two algebras over <code>R</code>, then we can form the type <code>A ≃ₐ[R] B</code> of R-algebra equivs. I want to take one of these, and regard it as an R-linear map (forgetting the ring structure and the bijectivity). </p>\n<p>Mathematically this is completely straightforward: one class of maps is trivially a subset of the other. In Mathlib, however, to get from the bundled algebra-equiv type <code>A ≃ₐ[R] B</code> to the bundled linear-map type <code>A →ₗ[R] B</code>, there are many ways of walking through the type hierarchy (I found at least five). Confusingly, which one gets picked for the <code>(↑)</code> coercion depends on which subset of mathlib you're importing, since maps defined in later files seem to take priority over earlier ones; if you import the whole of mathlib, then it takes you on a rather unexpected detour via <code>LieHom</code>.</p>\n<p>The problem is that while all these are defeq, they are not <em>reducibly</em> defeq, so <code>simp</code>doesn't recognise them as being the same, and we need to add simp lemmas (proved by <code>rfl</code>) to tell it so. However, I tried to do this and got into an awful muddle trying to assign a direction to the lemmas! Ideally we'd want to do this in such a way that all paths through the digraph of types from <code>A ≃ₐ[R] B</code> to <code>A →ₗ[R] B</code> get simp-ed to a unique preferred simp-normal form. However, my head started to spin trying to do this in a \"minimal\" way without creating infinite simp loops; and there seems to be no way to guarantee that the simp-normal path is also the one that's picked up by the coercion framework.</p>\n<p>Surely there must be a better way?</p>",
        "id": 576084066,
        "sender_full_name": "David Loeffler",
        "timestamp": 1772127181
    },
    {
        "content": "<p>I think this is made worse by the fact that in some places were have three coercions for such diamonds; <code>e.toLinearEquiv.toLinearMap</code>, <code>e.toAlgHom.toLinearMap</code>, and something like <code>LinearMapClass.mk e</code>.</p>",
        "id": 576092864,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772129761
    },
    {
        "content": "<p>I think consensus is forming that we should drop the last one</p>",
        "id": 576092891,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772129772
    },
    {
        "content": "<p>I hadn't considered until now that the problem of deciding which way to flip these diamonds in simp lemmas cannot be solved by a totally arbitrary choice; indeed if you have a cube of conversions (with arrows forgetting continuity, inverses, and multiplicative properties), then misconfiguration of simp lemmas that flip each face could send your three-edge path in a cyclic walk around the cube.</p>",
        "id": 576093270,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772129912
    },
    {
        "content": "<p>Maybe the choice should be an ordering of the forgettable things, and then you could simp to put the forgettings in the right order. Example: to get from a continuous AlgEquiv to a linear map you really do need to forget three things (and indeed if you make a random simp lemma choice for each of the 6 faces of the cube you seem to be able to get it circling forever)</p>",
        "id": 576107729,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1772134403
    },
    {
        "content": "<p>I have argued in the past that the data of an inverse should be the last thing you forget</p>",
        "id": 576116025,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1772137225
    },
    {
        "content": "<p>I suspect that deciding that there will be a global order of forgetting is more important than what the order is</p>",
        "id": 576116440,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772137352
    },
    {
        "content": "<p>But to enforce this order with a linter, we'd need to tag edges with what they are forgetting.</p>",
        "id": 576116493,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772137370
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Coercions.20and.20simp-normal.20form/near/576116440\">said</a>:</p>\n<blockquote>\n<p>I suspect that deciding that there will be a global order of forgetting is more important than what the order is</p>\n</blockquote>\n<p>I tend to agree, except for simplifications of the form <code>e o e.symm</code></p>",
        "id": 576117019,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1772137541
    },
    {
        "content": "<p>Totally half-baked idea: some of these shouldn't be <code>simp</code> lemmas? Only <code>grind</code> lemmas so that you get equality saturation instead of directionality? This may be total garbage, but I wanted to say it before I stop thinking about it.</p>",
        "id": 576310358,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1772211894
    }
]