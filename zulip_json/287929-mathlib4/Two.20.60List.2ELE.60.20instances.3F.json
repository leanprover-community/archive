[
    {
        "content": "<p>The latest version of Mathlib seems to have introduced an unfortunate phenomenon: there are now two instances <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.instLE#doc\">docs#List.instLE</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.LE%27#doc\">docs#List.LE'</a>, and they're not def-eq:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Lex</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">type mismatch</span>\n<span class=\"cm\">  List.cons_le_cons_iff</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  @LE.le (List ?m.48) List.instLE (?m.55 :: ?m.57) (?m.56 :: ?m.58) ↔</span>\n<span class=\"cm\">    ?m.55 &lt; ?m.56 ∨ ?m.55 = ?m.56 ∧ ?m.57 ≤ ?m.58 : Prop</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  @LE.le (List ℕ) List.LE' (a :: l) (b :: m) ↔ a &lt; b ∨ a = b ∧ l ≤ m : Prop</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons_le_cons_iff</span>\n</code></pre></div>",
        "id": 497241115,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1738486583
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span></p>",
        "id": 497241232,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1738486695
    },
    {
        "content": "<p>I think the fix is to set the correct def-eq in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.instLinearOrder#doc\">docs#List.instLinearOrder</a>, and remove the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.LE%27#doc\">docs#List.LE'</a> override (along with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.LT%27#doc\">docs#List.LT'</a> while we're at it, though that's not problematic since both instances are def-eq)</p>",
        "id": 497242041,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1738487522
    },
    {
        "content": "<p>Although, I think a better fix might be not to define <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.le#doc\">docs#List.le</a> to begin with. It doesn't mean what you'd expect when the list type isn't linearly ordered, and when it is, we should probably go through the linear order instance instead.</p>",
        "id": 497242373,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1738487844
    },
    {
        "content": "<p>(While we're at it, something I find unfortunate with the new <code>List.Lex</code> file is that it uses the <code>Std</code> relation classes instead of those defined in Mathlib. Unifying these would be a worthwhile endeavor.)</p>",
        "id": 497242629,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1738488106
    },
    {
        "content": "<p>I've opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/21339\">#21339</a> which provides a quick and dirty fix</p>",
        "id": 497244073,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1738489583
    },
    {
        "content": "<p>I don't think we should touch the  override instance in mathlib; rather, we should ensure any downstream instances are compatible with the override.</p>",
        "id": 497253847,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738498794
    },
    {
        "content": "<p>Keeping the override makes any of the new <code>List.le</code> theorems in code unusable in Mathlib.</p>",
        "id": 497288956,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1738528683
    },
    {
        "content": "<p>I think that's fine, don't we have all those theorems for List.Lex anyway?</p>",
        "id": 497290238,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738529883
    },
    {
        "content": "<p>I think we upstreamed a lot of them to core. In fact, I updated my personal project to v4.16 precisely to be able to use these theorems (and ended up not being able to...)</p>",
        "id": 497290502,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1738530103
    },
    {
        "content": "<p>For instance I can't find Mathlib variants of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.nil_le#doc\">docs#List.nil_le</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.cons_le_cons_iff#doc\">docs#List.cons_le_cons_iff</a></p>",
        "id": 497290576,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1738530157
    },
    {
        "content": "<p>I'd like Kim to comment on this, I think they're the one who added <code>List.le</code> in the latest release.</p>",
        "id": 497294546,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1738533168
    },
    {
        "content": "<p>Well, this is still an issue.</p>",
        "id": 547303804,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1761577992
    },
    {
        "content": "<p>Could we just remove <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.le#doc\">docs#List.le</a> from core? This is very misleading in the case where α is something like a preorder. Besides, we can literally just write <code>¬ y &lt; x</code> if that is what we want.</p>",
        "id": 547304027,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1761578045
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span></p>",
        "id": 547304476,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1761578154
    },
    {
        "content": "<p>I agree, but I have no power over this</p>",
        "id": 547304562,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1761578169
    },
    {
        "content": "<p>I'd PR this myself but last time I tried making a core PR I made a total mess</p>",
        "id": 547305337,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1761578336
    },
    {
        "content": "<p>No, there definitely needs to be an LE instance in core.</p>",
        "id": 547391314,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761610478
    },
    {
        "content": "<p>Why?</p>",
        "id": 547404401,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1761622013
    },
    {
        "content": "<p>Talking about lexicographic ≤ only really makes sense in the context of a linear order. If we mean <code>x = y or x &lt; y</code> or <code>not y &lt; x</code>, I think that should be made explicit.</p>",
        "id": 547404483,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1761622089
    },
    {
        "content": "<ol>\n<li>Currently, Mathlib instance is defined for linear orders only. We can fix the diamond by changing the <code>le</code> field.</li>\n<li>If we care about partial orders (or preorders), then we can define an inductive predicate similar to <code>List.Lex</code> so that it gives the right answer in these cases.</li>\n</ol>",
        "id": 547405789,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1761623296
    },
    {
        "content": "<ol>\n<li>Is there any simple mechanism for changing just the order def-eqs? Or would we have to do the entire instance from the ground up?</li>\n<li>Does such a definition exist? In my experience when I've had to prove theorems about lexicographic ≤ it ends up being easier restating them as one or the two alternatives I gave.</li>\n</ol>",
        "id": 547477970,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1761653763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Two.20.60List.2ELE.60.20instances.3F/near/547391314\">said</a>:</p>\n<blockquote>\n<p>No, there definitely needs to be an LE instance in core.</p>\n</blockquote>\n<p>Incidentally, presumably that <code>LE</code> instance could use <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Order/Factories.html#LE.ofLT\">LE.ofLT</a> to make it...</p>",
        "id": 547499365,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1761659520
    },
    {
        "content": "<p>Anyway: it looks like the <code>LE</code> instances here are defined as, for <code>x &lt;= y</code>, as<br>\n<code>x = y ∨ List.Lex x y fun a b =&gt; (a &lt; b)</code> (Mathlib one) and <code>¬ List.Lex y x fun a b =&gt; (a &lt; b)</code> (core one).</p>",
        "id": 547500240,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1761659733
    },
    {
        "content": "<p>I am a bit bemused as to why core uses the latter when it only really makes sense in a total order.</p>",
        "id": 547501002,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1761659919
    },
    {
        "content": "<p>From memory it would be quite a big change to switch to the Mathlib one in lean4. I'm open to someone investigating, however.</p>",
        "id": 547620438,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761706455
    },
    {
        "content": "<p>It might be simpler to have some kind of typeclass restriction?</p>",
        "id": 547665843,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1761730156
    },
    {
        "content": "<p>I'm not that keen on having typeclass restrictions for this sort of thing. It might make sense for verification users, but it's annoying for programming applications to have to provide these \"useless\" typeclass instances for a new type you define.</p>",
        "id": 547687203,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1761735952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Two.20.60List.2ELE.60.20instances.3F/near/547405789\">said</a>:</p>\n<blockquote>\n<ol>\n<li>Currently, Mathlib instance is defined for linear orders only. We can fix the diamond by changing the <code>le</code> field.</li>\n</ol>\n</blockquote>\n<p>I think this is the best short-term fix. <br>\nAnd probably we should wait with fixing the definition of <code>List.le</code> for partial orders until someone has a good use case for it.</p>",
        "id": 547689142,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1761736620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Two.20.60List.2ELE.60.20instances.3F/near/547477970\">said</a>:</p>\n<blockquote>\n<ol>\n<li>Is there any simple mechanism for changing just the order def-eqs? Or would we have to do the entire instance from the ground up?</li>\n</ol>\n</blockquote>\n<p>This is not hard. You just define the Mathlib <code>LinearOrder</code> instance so that it uses the existing <code>LE</code> instance. It does require you to prove the axioms for a LinearOrder, but that shouldn't be hard (perhaps you can even reuse the existing proof if you first show that the two orders are equivalent).</p>",
        "id": 547689883,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1761736891
    },
    {
        "content": "<p>sure, my question was moreso whether there's some <code>LinearOrder.copy</code> or similar constructor that allows easily changing the def-eqs</p>",
        "id": 547713476,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1761743859
    },
    {
        "content": "<p>not yet</p>",
        "id": 547791861,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761764280
    }
]