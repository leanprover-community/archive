[
    {
        "content": "<p>I'd like to discuss an issue that arose from the recent <code>Mon_</code> and <code>Mon_Class</code> refactor. The problem concerns whether <code>IsMon_Hom.one_hom</code> and <code>IsMon_Hom.mul_hom</code> should have the <code>simp</code> attribute.</p>\n<h2>Problem</h2>\n<p>We say that an object <code>M</code> in a monoidal category is a monoid object if it is equipped with a unit morphism <code>Î·[M] : ğŸ™_ C âŸ¶ M</code> and a multiplication morphism <code>Î¼[M] : M âŠ— M âŸ¶ M</code> satisfying the monoid axioms. In Mathlib, we write <code>[Mon_Class M]</code> to represent <code>M</code> is a monoid object.</p>\n<p>The problem involves the type class</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsMon_Hom</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mon_Class</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mon_Class</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">âŸ¶</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">Â  </span><span class=\"n\">one_hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î·</span><span class=\"o\">[</span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">â‰«</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Î·</span><span class=\"o\">[</span><span class=\"n\">N</span><span class=\"o\">]</span>\n<span class=\"w\">Â  </span><span class=\"n\">mul_hom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î¼</span><span class=\"o\">[</span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">â‰«</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">âŠ—â‚˜</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â‰«</span><span class=\"w\"> </span><span class=\"n\">Î¼</span><span class=\"o\">[</span><span class=\"n\">N</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>where we put <code>simp</code> attributes to these two equalities, and the instance like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mon_Class</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mon_Class</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">â‰…</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsMon_Hom</span><span class=\"w\"> </span><span class=\"n\">f.hom</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">   </span><span class=\"n\">IsMon_Hom</span><span class=\"w\"> </span><span class=\"n\">f.inv</span>\n</code></pre></div>\n<p>This creates issues because:</p>\n<ul>\n<li>Whether LHS or RHS is \"simpler\" depends on whether <code>M</code> or <code>N</code> is considered simpler.</li>\n<li>The instance assumes <code>N</code> is simpler than <code>M</code> (from <code>[IsMon_Hom f.hom]</code>), but <code>IsMon_Hom f.inv</code> asserts the opposite.</li>\n</ul>\n<p>This issue manifests concretely with <code>one_hom</code> for <code>IsMon_Hom (Î»_ N).inv</code>, where the left unitor inverse creates a simp loop. Here, the left unitor inverse <code>(Î»_ N).inv</code> has a type <code>N âŸ¶ ğŸ™_ C âŠ— N</code>, and <code>ğŸ™_ C âŠ— N</code> is a monoid object due to the instance <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mon_Class.tensorObj.instTensorObj#doc\">docs#Mon_Class.tensorObj.instTensorObj</a>. Expanding the definition of <code>Î·[ğŸ™_ C âŠ— N]</code> leads to a simp loop.</p>\n<h2>Proposed Solutions</h2>\n<ol>\n<li><strong>Remove the instance</strong>: For example, the fact <code>IsMon_Hom f.inv</code> is stated with <code>theorem</code> without <code>instance</code> attribute. This would fix simp loops but we need these instances as they build complex terms for <code>Mon_.Hom.mk</code>.</li>\n<li><strong>Create two versions</strong>: Have <code>IsMon_HomWithSimp</code> and <code>IsMon_HomWithoutSimp</code> with identical definitions but different simp attributes.</li>\n<li><strong>Remove simp attribute</strong>: Keep <code>IsMon_Hom.mul_hom</code> without simp and call it explicitly when needed.</li>\n</ol>\n<p>I've discussed this problem withÂ <span class=\"user-mention\" data-user-id=\"387244\">@YaÃ«l Dillies</span> , but we wanted to open it up for broader discussion.</p>",
        "id": 527293747,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1751735965
    },
    {
        "content": "<p>I would prefer 3.</p>",
        "id": 527298284,
        "sender_full_name": "JoÃ«l Riou",
        "timestamp": 1751741469
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"387244\">@YaÃ«l Dillies</span>  agreed for 3. For me, I'm not sure yet. I think 2 is complete, but it's a bit cumbersome.</p>",
        "id": 528325836,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1752235824
    },
    {
        "content": "<p>The idea behind 3 in my understanding is that the simp at <code>one_hom</code> and <code>mul_hom</code> help us in the early stages of building the API, but maybe not so much after that.</p>",
        "id": 528325863,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1752235833
    },
    {
        "content": "<p>I think starting relevant sections with <code>attribute [local simp] IsMon_Hom.one_hom IsMon_Hom.mul_hom</code> is not too bad of a trade-off.</p>",
        "id": 528334054,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1752238452
    }
]