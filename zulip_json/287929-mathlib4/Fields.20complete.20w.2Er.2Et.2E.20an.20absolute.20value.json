[
    {
        "content": "<p>What is the idiomatic way to say that a <code>Field</code> <code>F</code> is complete with respect to a given <code>v : AbsoluteValue F ℝ</code>?</p>",
        "id": 491990729,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1736104204
    },
    {
        "content": "<p>Maybe <code>CompleteSpace (WithAbs v)</code>?</p>",
        "id": 491999258,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1736111836
    },
    {
        "content": "<p>I can't say if it's idiomatic, but building upon what Andrew said, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AbsoluteValue.Completion#doc\">docs#AbsoluteValue.Completion</a> looks promising</p>",
        "id": 492011815,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1736123752
    },
    {
        "content": "<p>Oh wait, never mind, you're talking about a field that's already complete.</p>",
        "id": 492011896,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1736123795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Fields.20complete.20w.2Er.2Et.2E.20an.20absolute.20value/near/491999258\">said</a>:</p>\n<blockquote>\n<p>Maybe <code>CompleteSpace (WithAbs v)</code>?</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithAbs#doc\">docs#WithAbs</a> gives me the following poroblem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">Normed</span><span class=\"bp\">.</span><span class=\"n\">Ring</span><span class=\"bp\">.</span><span class=\"n\">WithAbs</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AbsoluteValue</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> fun x =&gt; x : WithAbs v → WithAbs v -/</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithAbs</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithAbs</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">WithAbs</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithAbs</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">WithAbs</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I.e., the implementation of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithAbs#doc\">docs#WithAbs</a> as a type synonym seems to make it impossible to meaningfully talk about the normed field structures induced by <em>two different</em> absolute values on <em>the same</em> field. E.g., I would like to say that two absolute values induce the same topology; my attempt was <code>IsHomeomorph (fun x ↦ x : WithAbs v → WithAbs w)</code>, but this runs into the problem above.</p>\n<p>Should <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithAbs#doc\">docs#WithAbs</a> be refactored to bundle the absolute value instead? Or what would be the \"correct\" way of solving the problem within the existing framework?</p>",
        "id": 492105864,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1736170518
    },
    {
        "content": "<p>That's because you didn't use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithAbs.equiv#doc\">docs#WithAbs.equiv</a></p>",
        "id": 492106088,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1736170588
    },
    {
        "content": "<p>Where should I use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithAbs.equiv#doc\">docs#WithAbs.equiv</a> in the above?</p>",
        "id": 492106174,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1736170624
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">Normed</span><span class=\"bp\">.</span><span class=\"n\">Ring</span><span class=\"bp\">.</span><span class=\"n\">WithAbs</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AbsoluteValue</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">WithAbs</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">WithAbs</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithAbs</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">WithAbs</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 492106225,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1736170648
    },
    {
        "content": "<p>While we are at it: Is there a simple way to get <code>DiscreteTopology Y</code> from <code>DiscreteTopology X</code> and a homeomorphism <code>X \\to Y</code>?</p>",
        "id": 492106500,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1736170753
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> DiscreteTopology, Homeomorph</p>",
        "id": 492106546,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1736170772
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> nothing found</p>",
        "id": 492106548,
        "sender_full_name": "loogle",
        "timestamp": 1736170773
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> DiscreteTopology, IsHomeomorph</p>",
        "id": 492106709,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1736170815
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> nothing found</p>",
        "id": 492106711,
        "sender_full_name": "loogle",
        "timestamp": 1736170816
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Order.html#DiscreteTopology.of_continuous_injective\">DiscreteTopology.of_continuous_injective</a></p>",
        "id": 492108597,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1736171493
    },
    {
        "content": "<p>Yes, this is the canonical trick: if you want to push something along a bijection, ask first whether it pushes along an injection or surjection.</p>",
        "id": 492127086,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1736177609
    }
]