[
    {
        "content": "<p>I am considering implementing the depth-first search algorithm for finite quivers and proving a few related properties. This may be useful in graph theory or geometric group theory, where one may want to produce a spanning tree of a connected graph or decide whether two vertices of a graph are connected by a (directed) path. Ideally the implementation should run reasonably fast on small graphs to allow testing of examples, while also being transparent enough to allow proofs.</p>\n<p>I am thinking of implementing something along the lines of the code snippet below (perhaps rewritten to avoid  loops and mutable variables if that makes the proofs easier). I would like to know whether this kind of algorithm with proofs is suitable for <code>Mathlib</code>. I would also appreciate feedback on whether and in what form definitions and constructions such as <code>Listable</code>, <code>Quiver.neighbourhood</code> and the union of <code>WideSubquiver</code>s should be integrated into <code>Mathlib</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.Quiver.Subquiver</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Basic</span>\n\n<span class=\"sd\">/-- A version of `Fintype α` which not only expresses the</span>\n<span class=\"sd\">  fact that the type is finite but also gives a way of enumerating the elements. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">Listable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">elems</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n  <span class=\"n\">complete</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">elems</span>\n  <span class=\"c1\">-- may be unnecessary</span>\n  <span class=\"n\">nodup</span> <span class=\"o\">:</span> <span class=\"n\">elems.Nodup</span>\n\n<span class=\"kd\">notation</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">α</span> <span class=\"s2\">\"]ₗ\"</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Listable.elems</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Listable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨⟨</span><span class=\"bp\">.</span><span class=\"n\">mk'</span> <span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"bp\">ₗ</span><span class=\"o\">,</span> <span class=\"n\">Listable.nodup</span><span class=\"o\">⟩,</span> <span class=\"n\">Listable.complete</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Ord</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Listable</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">Listable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Listable</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Listable</span> <span class=\"o\">(</span><span class=\"n\">Sigma</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">elems</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">join</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"bp\">ₗ.</span><span class=\"n\">map</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">ₗ.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">Sigma.mk</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n    <span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"n\">nodup</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Listable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Listable</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">elems</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"bp\">ₗ.</span><span class=\"n\">filterMap</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n  <span class=\"o\">,</span> <span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"n\">nodup</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">Quiver.star</span> <span class=\"o\">[</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">Quiver</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"bp\">⟶</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">Quiver</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Listable</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">Listable</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">⟶</span> <span class=\"n\">w</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">Listable</span> <span class=\"o\">(</span><span class=\"n\">Quiver.star</span><span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">inferInstanceAs</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Listable</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Sigma</span> <span class=\"n\">_</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">WideSubquiver</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Union</span> <span class=\"o\">(</span><span class=\"n\">WideSubquiver</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">Q</span> <span class=\"n\">Q'</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Q</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">∪</span> <span class=\"n\">Q'</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ofEdge</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">⟶</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">WideSubquiver</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quiver.wideSubquiverEquivSetTotal.invFun</span> <span class=\"o\">{⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">⟩}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">WideSubquiver</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">Quiver</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Listable</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">Listable</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">⟶</span> <span class=\"n\">w</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">depthFirstTraversal</span> <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">visited</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">WideSubquiver</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">discovered</span> <span class=\"o\">:=</span> <span class=\"n\">root</span> <span class=\"o\">::</span> <span class=\"n\">visited</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">WideSubquiver</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"bp\">⊥</span>\n  <span class=\"n\">for</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">⟩</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"n\">Quiver.star</span> <span class=\"n\">root</span><span class=\"o\">]</span><span class=\"bp\">ₗ</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"n\">w</span> <span class=\"bp\">∉</span> <span class=\"n\">discovered</span> <span class=\"k\">then</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"bp\">ₗ.</span><span class=\"n\">length</span> <span class=\"bp\">-</span> <span class=\"n\">discovered.length</span> <span class=\"bp\">&lt;</span> <span class=\"o\">[</span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"bp\">ₗ.</span><span class=\"n\">length</span> <span class=\"bp\">-</span> <span class=\"n\">visited.length</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n      <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">discovered'</span><span class=\"o\">,</span> <span class=\"n\">Q'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">depthFirstTraversal</span> <span class=\"n\">w</span> <span class=\"n\">discovered</span>\n      <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"n\">Q</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">WideSubquiver.ofEdge</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"n\">Q'</span>\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">discovered</span><span class=\"o\">,</span> <span class=\"n\">Q</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"bp\">ₗ.</span><span class=\"n\">length</span> <span class=\"bp\">-</span> <span class=\"n\">visited.length</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">visited_of_edge</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">⟶</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">depthFirstTraversal</span> <span class=\"n\">u</span> <span class=\"o\">[])</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">→</span> <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">depthFirstTraversal</span> <span class=\"n\">u</span> <span class=\"o\">[])</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">depthFirstTraversal</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 327572961,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1676301125
    },
    {
        "content": "<p>Not very important, but in <a href=\"https://github.com/leanprover-community/mathlib/pull/17828/files\">PR 17828</a> we call your <code>Neighborhood</code> <code>Star</code>.</p>",
        "id": 327575535,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1676301757
    },
    {
        "content": "<p>Thanks, I think <code>star</code> sounds better. I've updated my code snippet.</p>",
        "id": 327579208,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1676302584
    },
    {
        "content": "<p>This is nice. May I ask  why you would like to remove mutable variables? There is much to be gained from being able to reason about mutable variables in the algorithms world, at least complexity-theory-wise.</p>",
        "id": 327580055,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1676302819
    },
    {
        "content": "<p>How do you even reason about those (mutables) in lean?  Is it translated to some monad?</p>",
        "id": 327580644,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1676302967
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Depth-first.20search.20on.20quivers.2C.20with.20proof/near/327580644\">said</a>:</p>\n<blockquote>\n<p>How do you even reason about those (mutables) in lean?  Is it translated to some monad?</p>\n</blockquote>\n<p>I don't know yet. My idea was to use restricted mutations. But this is a slightly different context.</p>",
        "id": 327583724,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1676303736
    },
    {
        "content": "<p>Thanks. I believe the code in the <code>Id</code> monad is compiled down to <code>fold</code> and <code>map</code> internally. I prefer the mutable variable and loop syntax too, but I am not sure how easy it will be to analyse in a proof. </p>\n<p>I am not having very good results trying to prove this test lemma about the <code>depthFirstTraversal</code> function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">visited_of_edge</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">⟶</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">depthFirstTraversal</span> <span class=\"n\">u</span> <span class=\"o\">[])</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">→</span> <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">depthFirstTraversal</span> <span class=\"n\">u</span> <span class=\"o\">[])</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">depthFirstTraversal</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 327585871,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1676304223
    },
    {
        "content": "<p>Am I correct to assume that you are not using this to make complexity claims? We will probably be doing something similar for complexity and algorithms. I am checking to avoid duplication of effort and names of defs</p>",
        "id": 327586225,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1676304303
    },
    {
        "content": "<p>We recently found <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin_enum\">docs#fin_enum</a> / <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FinEnum#doc\">docs4#FinEnum</a> and no file import it, I think we should choose one between it and <code>Listable</code> to keep in mathlib (of course, maybe make some small changes).</p>",
        "id": 327587266,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1676304552
    },
    {
        "content": "<p>Yes, you're right - I am mainly concerned with using this implementation to perform small-scale computations with graphs and using it with proofs to automatically decide properties like connectedness and reachability. However I'd be happy to coordinate and work on implementing it in a way that's useful to both complexity analysis and decision procedures/proofs.</p>",
        "id": 327590516,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1676305454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"455791\">Yuyang Zhao</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Depth-first.20search.20on.20quivers.2C.20with.20proof/near/327587266\">said</a>:</p>\n<blockquote>\n<p>We recently found <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin_enum\">docs#fin_enum</a> / <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FinEnum#doc\">docs4#FinEnum</a> and no file import it, I think we should choose one between it and <code>Listable</code> to keep in mathlib (of course, maybe make some small changes).</p>\n</blockquote>\n<p>Thanks. <code>FinEnum</code> seems to already have a large number of useful lemmas and constructions associated with it.  One thing that seems to be missing, but may be useful while trying out computations, is the <code>for ... in </code> notation through the <code>ForIn</code> typeclass.</p>",
        "id": 327591967,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1676305830
    },
    {
        "content": "<p>(As an experienced <a href=\"https://en.wikipedia.org/wiki/Competitive_programming\">competitive programmer</a> I can't wait to use lean to write some algorithms (with correctness proofs), but I'm still trying to convince some Online Judge owners to add lean4 to their OJ <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span> )</p>",
        "id": 327592541,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1676306010
    },
    {
        "content": "<p>(Indeed - with the Std4 library, competitive programming in Lean4 seems very much a possibility.)</p>",
        "id": 327593566,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1676306303
    }
]