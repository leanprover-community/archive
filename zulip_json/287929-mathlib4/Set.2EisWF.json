[
    {
        "content": "<p>Does it make sense to keep <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.isWF#doc\">docs#Set.isWF</a> now that we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFoundedLT%3F#doc\">docs#WellFoundedLT?</a> Specifically, for <code>s : Set α</code>, the predicates <code>s.isWF</code> and <code>WellFoundedLT s</code> should be completely equivalent.</p>",
        "id": 493945103,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736952666
    },
    {
        "content": "<p>Likewise, we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.isPWO#doc\">docs#Set.isPWO</a>, but I've really been wanting a type version of this; partially well-ordered types are precisely the posets for which the <a href=\"https://en.wikipedia.org/wiki/Poset_game\">poset game</a> is guaranteed to end. Sure, I could write <code>(@Set.univ α).isPWO</code>, but that's somewhat awkward and doesn't really fit with our usual design.</p>",
        "id": 493946448,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736952997
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span></p>",
        "id": 493946611,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736953037
    },
    {
        "content": "<p>I think the <code>IsWF</code> spelling is quite a bit more convenient, since it doesn't involve a coercion from sets to types. For instance, <code>WellFoundedLT</code> is reducible and inline, and it seems to me that the rhs <code>WellFoundedLT s</code> isn't even in simp-normal form. So I'd instead say that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFoundedLT#doc\">docs#WellFoundedLT</a> is the one that should change here.</p>",
        "id": 493946892,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1736953092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Set.2EisWF/near/493946448\">said</a>:</p>\n<blockquote>\n<p>Likewise, we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.isPWO#doc\">docs#Set.isPWO</a>, but I've really been wanting a type version of this; partially well-ordered types are precisely the posets for which the <a href=\"https://en.wikipedia.org/wiki/Poset_game\">poset game</a> is guaranteed to end. Sure, I could write <code>(@Set.univ α).isPWO</code>, but that's somewhat awkward and doesn't really fit with our usual design.</p>\n</blockquote>\n<p>I'm in favour of having a typeclass for partially well-ordered types, perhaps defined as <code>(@Set.univ α).isPWO</code></p>",
        "id": 493947028,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1736953123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Set.2EisWF/near/493946892\">said</a>:</p>\n<blockquote>\n<p>For instance, <code>WellFoundedLT</code> is reducible and inline, and it seems to me that the rhs <code>WellFoundedLT s</code> isn't even in simp-normal form.</p>\n</blockquote>\n<p>Oh yeah, that's a good point. We would end up with the same problem that happened with <code>Subrel</code>, where e.g. <code>WellFoundedLT {x | p x}</code> gets simped into <code>WellFoundedLT {x // p x}</code> which then causes all other <code>simp</code> lemmas to break.</p>",
        "id": 493947386,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736953211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Set.2EisWF/near/493947028\">said</a>:</p>\n<blockquote>\n<p>I'm in favour of having a typeclass for partially well-ordered types, perhaps defined as <code>(@Set.univ α).isPWO</code></p>\n</blockquote>\n<p>This seems a bit backwards in design to me, surely we'd want <code>IsPWO</code> to be defined in terms of <code>PartiallyWellOrderedLT</code> instead? But I guess that's a minor concern.</p>\n<p>By the way, the typeclass should really be called something like <code>WellQuasiOrderedLT</code> instead. PWO means WQO + partial order.</p>",
        "id": 493947806,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736953316
    },
    {
        "content": "<p>I'll try to get this new typeclass into Mathlib <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> and I'll leave these existing set predicates alone for the most part</p>",
        "id": 493948261,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736953438
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Set.2EisWF/near/493947806\">said</a>:</p>\n<blockquote>\n<p>By the way, the typeclass should really be called something like <code>WellQuasiOrderedLT</code></p>\n</blockquote>\n<p>And also partially well-ordered is less standard and more confusing than well quasi-order!</p>",
        "id": 493955216,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1736955319
    },
    {
        "content": "<p>I think \"well quasi-order\" is also confusing, but that ship has already sailed <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 493956173,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736955594
    },
    {
        "content": "<p>Question: does it make sense to have the unbundled version <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.PartiallyWellOrderedOn#doc\">docs#Set.PartiallyWellOrderedOn</a> ?</p>",
        "id": 493973835,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736960072
    },
    {
        "content": "<p>Or more generally, an unbundled predicate for a relation being a well quasi-order</p>",
        "id": 493973956,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736960110
    },
    {
        "content": "<p>Keeping the relative version (ie not univ) is definitely useful</p>",
        "id": 493973995,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1736960124
    },
    {
        "content": "<p>Yeah I agree, I'm talking about the version that takes an arbitrary relation instead of a preorder</p>",
        "id": 493974062,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736960148
    },
    {
        "content": "<p>IMO that's useful too, eg for the divisibility relation on nat or the subset relation on finsets or sets</p>",
        "id": 493974167,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1736960173
    },
    {
        "content": "<p>It is a bit annoying that you'd like to prove a wqo is well-founded and has no infinite antichains. But the well-founded relation is <code>&lt;</code> and the no infinite antichains conditions is on <code>≤</code> instead!</p>",
        "id": 493974475,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736960268
    },
    {
        "content": "<p>But the definition that is currently in Lean is correct on preorders and needs only one of the two relations, so maybe we don't need to fix anything. Just introduce the necessary API in the preorder case.</p>",
        "id": 493974819,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736960379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Set.2EisWF/near/493974475\">said</a>:</p>\n<blockquote>\n<p>It is a bit annoying that you'd like to prove a wqo is well-founded and has no infinite antichains. But the well-founded relation is <code>&lt;</code> and the no infinite antichains conditions is on <code>≤</code> instead!</p>\n</blockquote>\n<p>In fact, the current API has some pretty awkward theorems as a consequence of this</p>",
        "id": 494006577,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736971545
    },
    {
        "content": "<p>Like, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PartiallyWellOrderedOn.wellFoundedOn#doc\">docs#PartiallyWellOrderedOn.wellFoundedOn</a></p>",
        "id": 494006594,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736971555
    },
    {
        "content": "<p>\"If <code>r</code> is a preorder and a WQO, then the relation <code>r a b ∧ ¬ r b a</code> is well-founded\"<br>\nIs this ever going to be useful outside of when <code>r = ≤</code> and the resulting relation is <code>&lt;</code>?</p>",
        "id": 494006728,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736971603
    },
    {
        "content": "<p>I'm not sure if we have e.g. a strict divisibility relation where this could be used</p>",
        "id": 494006941,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736971684
    },
    {
        "content": "<p>And as for subsets, we could just use <code>≤</code> and <code>&lt;</code> in that case</p>",
        "id": 494006987,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736971703
    },
    {
        "content": "<p>And also, what's the deal with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=partiallyWellOrderedOn_iff_finite_antichains#doc\">docs#partiallyWellOrderedOn_iff_finite_antichains</a> ?</p>",
        "id": 494062132,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736999967
    },
    {
        "content": "<p>This is true - obviously, it's in Lean. But is it really meaningful? The \"intended\" use case for the predicate is <code>r</code> a reflexive and transitive relation, and if you add the symmetric condition you end up with <code>r</code> being the always true relation, which seems unintended.</p>",
        "id": 494062376,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737000118
    },
    {
        "content": "<p>To me, this reads like a corruption of the statement connection wqos to well-founded orders: if <code>≤</code> is a preorder, then it's a wqo iff all antichains are finite <strong>and</strong> if <code>&lt;</code> is well-founded</p>",
        "id": 494062482,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737000190
    },
    {
        "content": "<p>(which I don't think we currently have in Mathlib!)</p>",
        "id": 494062503,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737000221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Set.2EisWF/near/494062482\">said</a>:</p>\n<blockquote>\n<p>To me, this reads like a corruption of the statement connection wqos to well-founded orders: if <code>≤</code> is a preorder, then it's a wqo iff all antichains are finite <strong>and</strong> if <code>&lt;</code> is well-founded</p>\n</blockquote>\n<p>Judging by the docstring just above <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.PartiallyWellOrderedOn#doc\">docs#Set.PartiallyWellOrderedOn</a>, that seems to be the case.</p>",
        "id": 494068177,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737004358
    },
    {
        "content": "<p>Another theorem I'd classify as nonsense is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsAntichain.finite_of_partiallyWellOrderedOn#doc\">docs#IsAntichain.finite_of_partiallyWellOrderedOn</a>. A preordered antichain is just a singleton.</p>",
        "id": 494071112,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737006224
    },
    {
        "content": "<p>Is there any interesting about WQOs that aren't preorders, or is this just Mathlib overgeneralization?</p>",
        "id": 494071201,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737006278
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span></p>",
        "id": 494071754,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737006710
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Set.2EisWF/near/494071112\">said</a>:</p>\n<blockquote>\n<p>Another theorem I'd classify as nonsense is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsAntichain.finite_of_partiallyWellOrderedOn#doc\">docs#IsAntichain.finite_of_partiallyWellOrderedOn</a>. A preordered antichain is just a singleton.</p>\n</blockquote>\n<p>You can have antichains of any size in preorders- <code>IsAntichain</code> is defined in terms of pairs of <em>distinct</em> elements being incomparable, so it doesn't matter if you're looking at ≤ or &lt;.</p>",
        "id": 494140516,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1737032467
    },
    {
        "content": "<p>That particular theorem is just half of the characterization you want that \"if <code>≤</code> is a preorder, then it's a wqo iff all antichains are finite <strong>and</strong> if <code>&lt;</code> is well-founded\"</p>",
        "id": 494141201,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1737032652
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Set.2EisWF/near/494062132\">said</a>:</p>\n<blockquote>\n<p>And also, what's the deal with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=partiallyWellOrderedOn_iff_finite_antichains#doc\">docs#partiallyWellOrderedOn_iff_finite_antichains</a> ?</p>\n</blockquote>\n<p>I agree this one's weird - essentially this is a theorem about graphs, and it's not used anywhere in the library.</p>",
        "id": 494141848,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1737032841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Set.2EisWF/near/494071201\">said</a>:</p>\n<blockquote>\n<p>Is there any interesting about WQOs that aren't preorders, or is this just Mathlib overgeneralization?</p>\n</blockquote>\n<p>My use case working on this stuff was Hahn series, for which we just care about partially ordered monoids, so preorders are definitely a good enough use case as far as I'm concerned.</p>",
        "id": 494142173,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1737032938
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Set.2EisWF/near/494140516\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Set.2EisWF/near/494071112\">said</a>:</p>\n<blockquote>\n<p>Another theorem I'd classify as nonsense is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsAntichain.finite_of_partiallyWellOrderedOn#doc\">docs#IsAntichain.finite_of_partiallyWellOrderedOn</a>. A preordered antichain is just a singleton.</p>\n</blockquote>\n<p>You can have antichains of any size in preorders- <code>IsAntichain</code> is defined in terms of pairs of <em>distinct</em> elements being incomparable, so it doesn't matter if you're looking at ≤ or &lt;.</p>\n</blockquote>\n<p>Indeed, this theorem is useful, and there are many preordered antichains: just consider the discrete poset on n elements, which is always an antichain.</p>",
        "id": 494159341,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1737037596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Set.2EisWF/near/494062376\">said</a>:</p>\n<blockquote>\n<p>This is true - obviously, it's in Lean. But is it really meaningful? The \"intended\" use case for the predicate is <code>r</code> a reflexive and transitive relation, and if you add the symmetric condition you end up with <code>r</code> being the always true relation, which seems unintended.</p>\n</blockquote>\n<p>I think this is massively unfair. Firstly, there are reflexive symmetric transitive relations other than the always true relation, for example equality. More generally, any equivalence relation would work, and there are many of these on a given type! As Aaron says, this is essentially a theorem about graphs (notice it doesn't assume transitivity), and it says that the edge relation on a graph is a pwo iff there are no infinite independent sets. To me, this is a meaningful statement!</p>",
        "id": 494161644,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1737038185
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Set.2EisWF/near/494140516\">said</a>:</p>\n<blockquote>\n<p>You can have antichains of any size in preorders- <code>IsAntichain</code> is defined in terms of pairs of <em>distinct</em> elements being incomparable, so it doesn't matter if you're looking at ≤ or &lt;.</p>\n</blockquote>\n<p>Oh yeah I had something wrong in my logic. But, a preordered antichain should just be the equality relation, right? So I think what we're actually missing is the result that says that, and the result that said relation is wqo.</p>",
        "id": 494216853,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737054831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Set.2EisWF/near/494161644\">said</a>:</p>\n<blockquote>\n<p>I think this is massively unfair. Firstly, there are reflexive symmetric transitive relations other than the always true relation, for example equality.</p>\n</blockquote>\n<p>Yeah, that's another mistake of mine. I must have been thinking about total orders instead.</p>",
        "id": 494217355,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737055028
    },
    {
        "content": "<p>(glad we have Lean, or people like me could just say whatever <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span>)</p>",
        "id": 494218030,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737055317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Set.2EisWF/near/494216853\">said</a>:</p>\n<blockquote>\n<p>But, a preordered antichain should just be the equality relation, right?</p>\n</blockquote>\n<p>Technically yes, but this is kind of missing the point: it's very rare to talk about the entire preorder being an antichain, instead what's usual is to consider subsets which are antichains</p>",
        "id": 494223484,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1737057511
    },
    {
        "content": "<p>In particular the theorem in question here - that you called nonsense - actually plays an important role in my disproof of fishbone mentioned elsewhere! It's half of the proof that the first of the two alternatives fails.</p>",
        "id": 494223656,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1737057596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Set.2EisWF/near/494223484\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Set.2EisWF/near/494216853\">said</a>:</p>\n<blockquote>\n<p>But, a preordered antichain should just be the equality relation, right?</p>\n</blockquote>\n<p>Technically yes, but this is kind of missing the point: it's very rare to talk about the entire preorder being an antichain, instead what's usual is to consider subsets which are antichains</p>\n</blockquote>\n<p>Fair enough. But since I'm writing the API for the \"full preorder\" version of this predicate I'm also trying to figure out what lemmas to port and how to port them.</p>",
        "id": 494230423,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737060688
    },
    {
        "content": "<p>Sorry for calling it nonsense! I was misunderstanding the hypotheses.</p>",
        "id": 494230463,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737060707
    },
    {
        "content": "<p>I've got a few more questions about the WQO design. I already have a sorry-free proof of the main characterization of WQOs, i.e.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">wellQuasiOrderedLE_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">WellQuasiOrderedLE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">WellFoundedLT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsAntichain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Question 1: is it worth having the more verbose form for unbundled relations? Namely</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">wellQuasiOrdered_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsPreorder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">WellQuasiOrdered</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">WellFounded</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsAntichain</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In my opinion, if you're in a preorder where both <code>&lt;</code> and <code>≤</code> are relevant, you really should just build an actual <code>Preorder</code> instance.</p>\n<p>Question 2: what about the corollary</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">wellQuasiOrdered_iff_of_isSymm</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsPreorder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsSymm</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">WellQuasiOrdered</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsAntichain</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(which is the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.partiallyWellOrderedOn_iff_finite_antichains#doc\">docs#Set.partiallyWellOrderedOn_iff_finite_antichains</a> lemma I brought up earlier). Surely that's not really worth having, is it?</p>",
        "id": 494277405,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737085287
    },
    {
        "content": "<p>I've decided to open <a href=\"https://github.com/leanprover-community/mathlib4/pull/21008\">#21008</a>, which defines the new type predicates for WQOs but doesn't yet link them to the existing set predicates in any way. This way, I can parallelize my work on combinatorial games which depends on WQOs, with the work of linking both APIs together.</p>",
        "id": 495625384,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737688734
    },
    {
        "content": "<p>There's some preliminary merging work in <a href=\"https://github.com/leanprover-community/mathlib4/pull/20786\">#20786</a>, which isn't yet complete but should at least show both APIs are compatible.</p>",
        "id": 495625507,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737688803
    },
    {
        "content": "<p>For your earlier two questions - I agree for Question 1, for Question 2 note that your version assumes transitivity where the original doesn't. So you don't need to keep it, but the actual \"full\" version of the lemma is potentially useful</p>",
        "id": 495697010,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1737719759
    }
]