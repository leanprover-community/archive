[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">instDecidableRelLe</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">instDecidableLe_mathlib</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">instDecidableRelLe</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>For some reason lean doesn't try <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instDecidableLe_mathlib#doc\">docs#instDecidableLe_mathlib</a> after trying <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instDecidableRelLe#doc\">docs#instDecidableRelLe</a>.</p>",
        "id": 473519044,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1727659141
    },
    {
        "content": "<p>I'm not sure what is going on there.</p>\n<p>In any case, <code>FirstOrder.Language.instDecidableRelLeOfRelMapLeSymbVecConsVecEmpty</code> certainly shouldn't be a global instance.</p>",
        "id": 473529129,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1727662551
    },
    {
        "content": "<p>Should <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instDecidableRelLe#doc\">docs#instDecidableRelLe</a> be an instance? Does Lean try to apply it to any <code>LE</code> and <code>Ord</code> instances, then try to unify them?</p>",
        "id": 473542303,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1727664892
    },
    {
        "content": "<p>It usually synthesizes successfully for other types, but lean still tries this instance.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">[Meta.synthInstance] ✅️ DecidableRel fun x1 x2 =&gt; x1 ≤ x2 ▼</span>\n<span class=\"cm\">  [] new goal (a b : ℕ+) → Decidable ((fun x1 x2 =&gt; x1 ≤ x2) a b) ▶</span>\n<span class=\"cm\">  [] ❌️ apply FirstOrder.Language.instDecidableRelLeOfRelMapLeSymbVecConsVecEmpty to (a b : ℕ+) →</span>\n<span class=\"cm\">      Decidable ((fun x1 x2 =&gt; x1 ≤ x2) a b) ▶</span>\n<span class=\"cm\">  [] ❌️ apply @instDecidableRelLe to (a b : ℕ+) → Decidable ((fun x1 x2 =&gt; x1 ≤ x2) a b) ▶</span>\n<span class=\"cm\">  [] ✅️ apply @instDecidableLe_mathlib to (a b : ℕ+) → Decidable ((fun x1 x2 =&gt; x1 ≤ x2) a b) ▶</span>\n<span class=\"cm\">  [] result instDecidableLe_mathlib</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 473545401,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1727665543
    },
    {
        "content": "<p>Anyone have a theory why there's a difference in behaviour between NNRat and PNat here? In both cases there are highly suspicious metavariables in trace, but for PNat that just causes the search branch to fail, while for NNRat it blows up and stops the search.</p>",
        "id": 473604288,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1727678146
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/synth.20.60DecidableRel.20.28.CE.B1.20.3A.3D.20.E2.84.9A.E2.89.A50.29.20.28.C2.B7.20.E2.89.A4.20.C2.B7.29.60.20fails/near/473529129\">said</a>:</p>\n<blockquote>\n<p>In any case, <code>FirstOrder.Language.instDecidableRelLeOfRelMapLeSymbVecConsVecEmpty</code> certainly shouldn't be a global instance.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/17271\">#17271</a></p>",
        "id": 473605713,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1727678542
    },
    {
        "content": "<p>What makes those instances bad but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instDecidableRelLe#doc\">docs#instDecidableRelLe</a> ok?</p>",
        "id": 473868060,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727733546
    },
    {
        "content": "<p>I thought it was fine to have these kinds of instances about other non-instances, because they never actually match unless you're working with the non-instance they are about</p>",
        "id": 473868285,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727733611
    },
    {
        "content": "<p>They don't match but they aren't rejected by the discrimination tree, and sometimes (not for these instances, but I saw a discussion about some <code>Fintype</code> non-instances) take a long time to fail defeq test.</p>",
        "id": 473880371,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1727737279
    },
    {
        "content": "<p>E.g., if you're working with a large finite type and Lean tries to unfold everything to verify if they're defeq.</p>",
        "id": 473880530,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1727737333
    }
]