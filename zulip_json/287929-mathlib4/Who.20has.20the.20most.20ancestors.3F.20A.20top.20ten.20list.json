[
    {
        "content": "<p>Each of the numbers in the first column is the total number of ancestors of the structure in the second column plus one:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>69 RCLike\n68 ConditionallyCompleteLinearOrderedField\n63 NormedLinearOrderedField\n60 CanonicallyLinearOrderedSemifield\n60 CommCStarAlgebra\n58 CStarAlgebra\n58 LinearOrderedField\n55 LinearOrderedSemifield\n51 DenselyNormedField\n51 NontriviallyNormedField\n</code></pre></div>",
        "id": 480109220,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730490555
    },
    {
        "content": "<p>Here's the histogram of these numbers for all of mathlib:</p>\n<p>[0, 2963, 349, 138, 86, 49, 25, 31, 19, 10, 13, 9, 6, 10, 11, 4, 6, 7, 8, 2, 5, 2, 5, 6, 0, 2, 5, 2, 3, 3, 1, 1, 3, 2, 2, 0, 1, 3, 4, 5, 2, 0, 1, 0, 2, 5, 0, 0, 0, 1, 1, 2, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 1, 0, 0, 0, 0, 1, 1]</p>",
        "id": 480109310,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730490602
    },
    {
        "content": "<p>I don't understand how <code>RCLike</code> can have so many ancestors. Shouldn't it just have two, the reals and the complexes?</p>\n<p>Or by ancestors do you mean the number of fields, and subfields of fields, and so on?</p>",
        "id": 480112439,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1730491979
    },
    {
        "content": "<p>A \"parent\" is a structure that appears in the <code>extends</code> clause, and an \"ancestor\" is the transitive closure</p>",
        "id": 480113210,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730492376
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RCLike#doc\">docs#RCLike</a> has four parents</p>",
        "id": 480113347,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730492434
    },
    {
        "content": "<p>out of curiosity, does something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingEquiv#doc\">docs#RingEquiv</a> have 2 or 3 <del>ancestors</del> parents? because it uses <code>extends</code> with 3, but in a sense one of those is also a proper ancestor, and therefore not something you're interested in?</p>",
        "id": 480113897,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1730492741
    },
    {
        "content": "<p>for those who don't want to look it up, <code>structure RingEquiv A B .... extends Equiv A B, AddEquiv A B, MulEquiv A B</code></p>",
        "id": 480114073,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1730492864
    },
    {
        "content": "<p>I'm not sure I understand the question, RingEquiv has three direct parents (yes, one is implied by the other two), but you need to walk the whole graph of parents to find the set of ancestors.</p>",
        "id": 480114169,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730492909
    },
    {
        "content": "<p>Here's the list: <code>#[`RingEquiv, `Equiv, `MulEquiv, `AddEquiv, `MulHom, `AddHom]</code></p>",
        "id": 480114231,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730492952
    },
    {
        "content": "<p>i guess it's not relevant to the number of ancestors, i was just wondering if this is something that is relevant to whatever you're interested in analysing...</p>",
        "id": 480114660,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1730493192
    },
    {
        "content": "<p>i just noticed i meant to write <code>parent</code> where i wrote <code>ancestor</code> in my question...</p>",
        "id": 480114718,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1730493232
    },
    {
        "content": "<p>Yeah, that was my confusion about your question. I even looked at a dutch&lt;-&gt;english dictionary to see if that explained it :-)</p>",
        "id": 480114824,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730493292
    },
    {
        "content": "<p>sorry about that <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 480114917,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1730493360
    },
    {
        "content": "<p>If you collapse<code>Prop</code>-valued fields/structures, what does that look like?</p>",
        "id": 480115103,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1730493456
    },
    {
        "content": "<p>But no, that's not something I'm analyzing currently <span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span>, I was just trying to estimate a performance impact of a new algorithm. Though it's interesting that the parents are out of order. I don't see why we want Equiv to come first.</p>",
        "id": 480115122,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730493472
    },
    {
        "content": "<p>i seem to recall it is in order to make it symmetric in some way?</p>",
        "id": 480115224,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1730493528
    },
    {
        "content": "<p>Does anything go wrong having <code>structure RingEquiv A B .... extends MulEquiv A B, AddEquiv A B</code> instead?</p>",
        "id": 480115239,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730493536
    },
    {
        "content": "<p>I was hoping that we would make all <code>extends</code> lists eventually satisfy a locally consistent ordering condition, and this goes directly against it.</p>",
        "id": 480115328,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730493594
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span> Can I interpret \"collapse\" as \"throw out from the ancestor lists\"?</p>",
        "id": 480115442,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730493641
    },
    {
        "content": "<p>If <code>A</code> extends <code>B</code> by only prop fields, then identify them</p>",
        "id": 480115483,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1730493670
    },
    {
        "content": "<p>Ah, interesting. That's doable of course, but it'll take a bit of coding.</p>",
        "id": 480115740,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730493824
    },
    {
        "content": "<p>Or impose a penalty for each data carrying field.</p>",
        "id": 480116094,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1730493998
    },
    {
        "content": "<p>If I want to unify two structure instances by expanding them along a constructor, then the more data carrying fields I expose the worse the score is.</p>",
        "id": 480116824,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1730494385
    },
    {
        "content": "<p>Perhaps what <span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> was getting at, but there are some classes which are morally parents of one another (there is a <code>Foo.toBar</code> instance that constructs no new data), but for whatever reason this is not registered with <code>Foo _ extends Bar _</code></p>",
        "id": 480117854,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1730494942
    }
]