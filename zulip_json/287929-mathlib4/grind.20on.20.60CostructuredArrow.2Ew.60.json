[
    {
        "content": "<p>I was experimenting with grind and was very surprised to see the result of annotating <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.CostructuredArrow.w#doc\">docs#CategoryTheory.CostructuredArrow.w</a> with grind.</p>\n<p>as a reminder, the lemma has type</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₁</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u₁</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₂</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u₂</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CostructuredArrow</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n</code></pre></div>\n<p>and the generated pattern is</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">info: w: [@CategoryStruct.comp #6 _ (@Functor.obj #8 #7 _ #5 #3 (@Comma.left _ _ `[Discrete</span>\n<span class=\"sd\">     PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">     PUnit.{1}] _ _ #3 (@Functor.obj _ _ (Functor `[Discrete</span>\n<span class=\"sd\">       PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">       PUnit.{1}] _ _) _ (Functor.const `[Discrete</span>\n<span class=\"sd\">       PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">       PUnit.{1}] _ _) #4) #2)) (@Functor.obj _ _ _ _ #3 (@Comma.left _ _ `[Discrete</span>\n<span class=\"sd\">     PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">     PUnit.{1}] _ _ #3 (@Functor.obj _ _ (Functor `[Discrete</span>\n<span class=\"sd\">       PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">       PUnit.{1}] _ _) _ (Functor.const `[Discrete</span>\n<span class=\"sd\">       PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">       PUnit.{1}] _ _) #4) #1)) (@Functor.obj `[Discrete</span>\n<span class=\"sd\">    PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">    PUnit.{1}] _ _ (@Functor.obj _ _ (Functor `[Discrete</span>\n<span class=\"sd\">      PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">      PUnit.{1}] _ _) _ (Functor.const `[Discrete</span>\n<span class=\"sd\">      PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">      PUnit.{1}] _ _) #4) (@Comma.right _ _ `[Discrete</span>\n<span class=\"sd\">     PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">     PUnit.{1}] _ _ #3 (@Functor.obj _ _ (Functor `[Discrete</span>\n<span class=\"sd\">       PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">       PUnit.{1}] _ _) _ (Functor.const `[Discrete</span>\n<span class=\"sd\">       PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">       PUnit.{1}] _ _) #4) #1)) (@Functor.map _ _ _ _ #3 (@Comma.left _ _ `[Discrete</span>\n<span class=\"sd\">     PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">     PUnit.{1}] _ _ #3 (@Functor.obj _ _ (Functor `[Discrete</span>\n<span class=\"sd\">       PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">       PUnit.{1}] _ _) _ (Functor.const `[Discrete</span>\n<span class=\"sd\">       PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">       PUnit.{1}] _ _) #4) #2) (@Comma.left _ _ `[Discrete</span>\n<span class=\"sd\">     PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">     PUnit.{1}] _ _ #3 (@Functor.obj _ _ (Functor `[Discrete</span>\n<span class=\"sd\">       PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">       PUnit.{1}] _ _) _ (Functor.const `[Discrete</span>\n<span class=\"sd\">       PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">       PUnit.{1}] _ _) #4) #1) (@CommaMorphism.left _ _ `[Discrete</span>\n<span class=\"sd\">     PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">     PUnit.{1}] _ _ #3 (@Functor.obj _ _ (Functor `[Discrete</span>\n<span class=\"sd\">       PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">       PUnit.{1}] _ _) _ (Functor.const `[Discrete</span>\n<span class=\"sd\">       PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">       PUnit.{1}] _ _) #4) #2 #1 #0)) (@Comma.hom _ _ `[Discrete</span>\n<span class=\"sd\">    PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">    PUnit.{1}] _ _ #3 (@Functor.obj _ _ (Functor `[Discrete</span>\n<span class=\"sd\">      PUnit.{1}] `[discreteCategory</span>\n<span class=\"sd\">      PUnit.{1}] _ _) _ (Functor.const `[Discrete PUnit.{1}] `[discreteCategory PUnit.{1}] _ _) #4) #1)]</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">grind?</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">CostructuredArrow</span><span class=\"bp\">.</span><span class=\"n\">w</span>\n</code></pre></div>\n</div></div>\n<p>which looks like a problem for making it trigger in nice situations</p>\n<p>I suspect <code>grind</code> is trying to unfold the definitions for CostructuredArrows and their morphisms (which under the hood are morphisms in Comma categories with functors involving <code>Discrete PUnit</code>), where it clearly shouldn’t (perhaps because calling <code>left</code> and <code>hom</code> on objects leave no choice but to infer them as objects /homs in commas, and the underlying problem is in fact that we abuse the defeq between CostructuredArrows and Commas?). <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> do you have an idea of the culprit/know how to fix this?</p>",
        "id": 546172390,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1761035467
    },
    {
        "content": "<p>The culprit is that <code>Functor.fromPUnit</code> is an <code>abbrev</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">fromPUnit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Discrete</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Functor.const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span>\n</code></pre></div>\n<p>While <code>CostructuredArrow</code> itself is a <code>def</code> (not reducible), <code>Functor.fromPUnit</code> is reducible. When grind's pattern preprocessing calls <code>unfoldReducible</code> (<a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/Tactic/Grind/EMatchTheorem.lean#L284\">EMatchTheorem.lean:284</a>), it expands <code>Functor.fromPUnit T</code> → <code>(Functor.const (Discrete PUnit)).obj T</code>, exposing all the <code>Discrete PUnit</code> machinery.</p>\n<p>Do you want to experiment with changing <code>fromPUnit</code> from <code>abbrev</code> to <code>def</code>?</p>",
        "id": 566635633,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1767741391
    },
    {
        "content": "<p>Thanks for the explanation!<br>\nI won't have time to experiment seriously with this in the immediate future, but I'll keep in in the backburner and come back to it the next time I'll try to improve the <code>grind</code> experience in category theory (probably around April) if no one beats me to it.</p>",
        "id": 566671996,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1767769086
    }
]