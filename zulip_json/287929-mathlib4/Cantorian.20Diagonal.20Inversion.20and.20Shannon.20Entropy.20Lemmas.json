[
    {
        "content": "<p>I‚Äôve been working on a small project formalizing Cantor style diagonal inversion in Lean 4. </p>\n<p>Here are the core defs/lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">binmat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">N</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">diagonal_inversion</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">binmat</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Vector.ofFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Œª</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"bp\">!</span><span class=\"o\">(</span><span class=\"n\">S.get</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin.castLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min_le_left</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin.castLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min_le_right</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">bernoulli</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">p</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">bit_inversion</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"n\">b</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">bernoulli_inversion</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bernoulli</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">bernoulli</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bit_inversion</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">bernoulli</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bit_inversion</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">all_goals</span><span class=\"w\"> </span><span class=\"n\">ring</span>\n</code></pre></div>\n<p>It compiles fine, but I‚Äôd really appreciate feedback: <br>\nIs this idiomatic Lean 4? <br>\nAre there mathlib lemmas I should be using instead? <br>\nAny advice on structuring this kind of project?</p>",
        "id": 541732448,
        "sender_full_name": "Luke Miller",
        "timestamp": 1758914740
    },
    {
        "content": "<p>can you edit your message to use <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a></p>",
        "id": 541732614,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758914829
    },
    {
        "content": "<p>Done, thank you Aaron</p>",
        "id": 541732791,
        "sender_full_name": "Luke Miller",
        "timestamp": 1758914910
    },
    {
        "content": "<p>The full build:</p>\n<p>EDA.lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">EDA.Basics</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">EDA.Diagonal</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">EDA.MainTheorem</span>\n</code></pre></div>\n<p>EDA.Diagonal</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.Nat.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">EDA.Basics</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">diagonal_inversion</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">binmat</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Vector.ofFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Œª</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"bp\">!</span><span class=\"o\">(</span><span class=\"n\">S.get</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin.castLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min_le_left</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin.castLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min_le_right</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">)</span>\n</code></pre></div>\n<p>EDA.Basics</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.Vector.Basic</span>\n\n<span class=\"c1\">-- A binary dataset: N sequences, each of length L</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">binmat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">N</span>\n</code></pre></div>\n<p>EDA.MainTheorem</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.Bool.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Algebra.Ring.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Tactic.Ring</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">Bernoulli distribution on a single bit:</span>\n<span class=\"cm\">returns the probability (as a ring element).</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">bernoulli</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">p</span>\n\n<span class=\"c1\">-- Bit inversion is just Boolean negation</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">bit_inversion</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"n\">b</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">Lemma: flipping a Bernoulli(p) bit</span>\n<span class=\"cm\">is the same as sampling a Bernoulli(1 - p) bit.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">bernoulli_inversion</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bernoulli</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">bernoulli</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bit_inversion</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">bernoulli</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bit_inversion</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">all_goals</span><span class=\"w\"> </span><span class=\"n\">ring</span>\n</code></pre></div>",
        "id": 541733625,
        "sender_full_name": "Luke Miller",
        "timestamp": 1758915198
    },
    {
        "content": "<p>This is what I‚Äôm trying to capture:</p>\n<p><strong>Cantorian Diagonal Inversion (informal):</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">S‚ÇÅ</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">S‚ÇÇ</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">S‚Çò</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Take the i-th bit from the i-th sequence, flip it, collect into D.</p>\n<p>Has anyone formalized Shannon Entropy or Cantorian Diagonalization in lean/mathlib yet?</p>",
        "id": 541734698,
        "sender_full_name": "Luke Miller",
        "timestamp": 1758915717
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Feedback.20on.20operator.20definitions.20.28EDA.20project.29\">#mathlib4 &gt; Feedback on operator definitions (EDA project)</a> by <span class=\"user-mention silent\" data-user-id=\"969906\">Luke Miller</span>.</p>",
        "id": 541744571,
        "sender_full_name": "Notification Bot",
        "timestamp": 1758920186
    },
    {
        "content": "<p>Shannon entropy can be formalized a few different ways depending on what you want to do. One version is <a href=\"https://github.com/teorth/pfr/blob/f80f70ec4b1c8566660ed770ddeb96e84c8645e1/PFR/ForMathlib/Entropy/Measure.lean#L36\">here</a>, which extends the definition to an arbitrary measure. There's a lot of work on <em>relative</em> entropies <a href=\"https://github.com/RemyDegenne/testing-lower-bounds\">here</a>. I have my own very limited version <a href=\"https://github.com/Timeroot/Lean-QuantumInfo/blob/a27e5347b90f824683a7fc2eddefdb0ed2762d5c/ClassicalInfo/Entropy.lean#L77\">here</a>.</p>\n<p>Mathlib has <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.binEntropy#doc\">docs#Real.binEntropy</a>, which is the binary entropy function. (The Shannon entropy of a Bernoulli variable.)</p>",
        "id": 541859380,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1759032200
    },
    {
        "content": "<p>Cantor's diagonal argument has been done in Lean, indeed it's often one of the first theorems to be done in a new theorem proving setting. :) The version in Mathlib may look a bit dense to newcomers, though: <a href=\"https://github.com/leanprover-community/mathlib4/blob/bf35bd39a069f06cd32685a267702d145efc544a/Mathlib/Logic/Function/Basic.lean#L242\">https://github.com/leanprover-community/mathlib4/blob/bf35bd39a069f06cd32685a267702d145efc544a/Mathlib/Logic/Function/Basic.lean#L242</a></p>",
        "id": 541859427,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1759032273
    },
    {
        "content": "<p>The code you wrote is pretty idiomatic Lean4, but it looks like \"Lean4 for actual programming\", as opposed to \"Lean4 for theorem proving\" -- the two often take different design choices for a number of reasons.</p>\n<p>For instance, you use <code>Bool</code>, which is actual data you can store in a variable; Mathlib generally prefers <code>Prop</code>, which can be any mathematical claim, regardless of whether you can compute the answer. You use <code>Vector T</code>, which is a variable-length array; Mathlib would often prefer <code>List T</code> (for better inductive proofs) or maybe a function <code>x -&gt; T</code> (where <code>x</code> is a <code>Fintype</code>).</p>",
        "id": 541859656,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1759032544
    },
    {
        "content": "<p>What is your main goal with this project? I see you've titled it \"EDA\", are you looking at Electronic Design Automation?</p>",
        "id": 541859705,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1759032617
    },
    {
        "content": "<p>I appreciate you getting back to me with that information that is really awesome, I needed them specifically because of a mathematical theorem that I have under review at the Journal of computational science testing the randomness of time indexed data sets using cantor's diagonal argument and Shannon entropy. it actually led to the development of the encryption scheme that I posted in another thread. I wasn't familiar with lean before I got started so everything that I've learned I've pretty much learned just from looking it up, I didn't really look for any sort of documentation or anything like that. if you have any further recommendations let me know, I'll take a look at those specific libraries and see if they work better in my lean than what I already have.</p>",
        "id": 541859724,
        "sender_full_name": "Luke Miller",
        "timestamp": 1759032646
    },
    {
        "content": "<p>and it's called entropy diagonalization analysis. we're looking for structure in time indexed data sets, we tested it on bitcoin and on seismographs and frb bursts. on bitcoin we found a .02 difference in randomness versus regular Sha hashes because of the proof of work scheme. in seismology there are additional signals that you can pick up whenever the scores drop, but that is under review and I'm not willing to share additional information because of potential impacts it may have later on if the research ends up being true. for frb, we looked for a ton of different fil files from seti and something like 100 candidates it may have been 97 and only two of them came back multi-band where we could process them so we processed them and correctly identified 8 chunks out of something like 16,000 in two different fil files that contained fast radio bursts with no error. chunks next to the bursts did not contain any information and background noise was the expected ratio in quiet time. once again all of this is under review so take it with a grain of salt</p>",
        "id": 541859909,
        "sender_full_name": "Luke Miller",
        "timestamp": 1759032893
    },
    {
        "content": "<p>I think it'll be pretty hard to help you more without more details. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> But if you run into issues let us know. Are you using an LLM to help you write the code?</p>",
        "id": 541904287,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1759077178
    },
    {
        "content": "<p>to assist with code &gt; lean, yes. cross referencing and checking work over and over, not letting a single instance give us a final answer. it helps iterate quickly without having to sift through mass amounts of data. basically checking that, even though we validated the work empirically, that it can be machine checked. but I know that it's not giving me the best I could do for this. I used it to learn how lean works and how to structure documents and builds essentially, and asked questions to fix compile errors whenever I ran into them. But that also leaves me in the position of not knowing Bitvec has xor operations, or that Shannon entropy and Cantor have already been encoded, or how to look for specific libraries and information. I would hope that doesn't put me in a bad position with you guys, I am genuinely trying to learn very complicated things and only recently learned about lean in the process of peer review. I want to take it seriously.</p>",
        "id": 541904708,
        "sender_full_name": "Luke Miller",
        "timestamp": 1759077607
    },
    {
        "content": "<p>What do you mean, that you learned about Lean in the process of peer review...?</p>",
        "id": 541906141,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1759079172
    },
    {
        "content": "<p>I learned in the process of trying to find a coding language that would help me absolutely check my logic that lean existed and I decided that I was going to start using it</p>",
        "id": 541906199,
        "sender_full_name": "Luke Miller",
        "timestamp": 1759079223
    },
    {
        "content": "<p>if you guys want to scrutinize anymore you can go right ahead I won't hide anything from you</p>",
        "id": 541906247,
        "sender_full_name": "Luke Miller",
        "timestamp": 1759079266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"969906\">Luke Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Cantorian.20Diagonal.20Inversion.20and.20Shannon.20Entropy.20Lemmas/near/541859724\">said</a>:</p>\n<blockquote>\n<p>it actually led to the development of the encryption scheme that I posted in another thread.</p>\n</blockquote>\n<p>Which thread? Are you ban evading?</p>",
        "id": 542002261,
        "sender_full_name": "Yan Yablonovskiy üá∫üá¶",
        "timestamp": 1759142811
    },
    {
        "content": "<p>Luke's presumably referring to <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/encryption.20scheme/with/541838667\">#general &gt; encryption scheme</a> , which is the only other topic they've posted in. (Why did you think ban evading...?)</p>",
        "id": 542060000,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1759157080
    },
    {
        "content": "<p>? I haven't done anything to be banned although I will admit I have no idea how this place works beyond what I've read and am just doing my best so if you have any advice just say so. I've been here for like 3 days</p>",
        "id": 542060533,
        "sender_full_name": "Luke Miller",
        "timestamp": 1759157194
    },
    {
        "content": "<p>It seems to be a bit more intense than I expected</p>",
        "id": 542060768,
        "sender_full_name": "Luke Miller",
        "timestamp": 1759157250
    },
    {
        "content": "<p>I think you will encounter some confusion/skepticism around your goals, until you can spell some things out more clearly.</p>\n<p>Lately there's been a particular trend -- I will spell out what's been happening, but please understand that I'm not describing you. People will come in with some extraordinary \"breakthrough\" ideas, typically cutting-edge research for a field that they weren't an expert in to begin with. Often they have have come to their ideas after some very independent work, aided by ChatGPT or similar. (The ideas, it turn out, make very little sense -- I mean stuff like \"Time is a spiral fractal and we can resonate with morality in the 13th dimension\" kind of stuff) They encounter resistance disseminating their ideas, precisely because they don't make sense. They interpret this as \"other people don't understand my idea because it's too new\". After some arguing with others, someone tells them, \"well why don't you go prove your big new ideas in some theorem prover like Lean, then show us that!\", expecting this will get them to leave them alone for a while. The person, not knowing Lean and recognizing that it's a difficult language, gets an LLM to help them write Lean. They make some amount of progress, and then come here to the Zulip chat. If they had a lot of progress, they will come in saying \"Look, I have these breakthrough ideas and they're all proved in Lean!\". If they had little progress, they will come in saying, \"Look, I have these breakthrough ideas, but I'm having trouble proving them in Lean, can someone help?\".</p>",
        "id": 542125517,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1759174664
    },
    {
        "content": "<p>But simply because that has happened enough times, I think people are now sort of <em>on edge</em> about anything where (1) someone has not-very-tested-sounding research ideas, (2) sounds like they're new to Lean, but are more interested in proving something dramatic than learning the details of the language itself, and (3) it sounds like an AI was heavily involved.</p>",
        "id": 542125713,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1759174733
    },
    {
        "content": "<p>I understand, I don't intend on bringing anything crazy in here, you guys saw the encryption scheme and this conversation and thats all I was checking. They both compile, I wouldn't want to bother anyone with anything I hadn't already previously checked. Everything I shared is either under active peer review or has gone through review. This thread is at jocsci and has been for a few months and the encryption got refused at rebuttal at a symposium because it would have been too big of a rewrite, development took off after the paper was submitted. I won't do anything else. Im going to be careful either way, you guys mean it and the opportunity to have community is too good to pass up. I won't bother anyone with anything that hasn't been at least looked at by a professional editor to be taken up for review.</p>",
        "id": 542126692,
        "sender_full_name": "Luke Miller",
        "timestamp": 1759175058
    },
    {
        "content": "<p>Again -- not necessarily true of you! So, until there's some evidence to the contrary, I will assume that whatever you're doing is reasonable good science. :)</p>",
        "id": 542126742,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1759175079
    },
    {
        "content": "<p>I might edit that comment I messed up a sentence! I appreciate you guys no matter what happens, if I'm outta line just smack me</p>",
        "id": 542126853,
        "sender_full_name": "Luke Miller",
        "timestamp": 1759175116
    },
    {
        "content": "<p>In order to help you achieve your goals, some questions/tips:</p>\n<ul>\n<li>\"Entropy Diagonalization Analysis\" is your own term. It might be a meaningful term to you, but it's not standard, and so people won't be able to go off that at all. Typically you should start communication in terms of <em>established</em> language, and then as needed introduce your own vocabulary. Can you describe this as \"entropy-based data analysis\", e.g. work like <a href=\"https://www.sciencedirect.com/science/article/pii/S2214212624001029\">this one</a>? Is that accurate? What does diagonalization have to do with it?</li>\n<li>You've mentioned an encryption scheme, and also what sounds like a data analysis framework. Can we pick one and focus on that first? These two, on the face of it, have nothing at all to do with each other.</li>\n<li>Formally proving things about encryption schemes is, generally speaking, quite hard. (Most results about encryption also have some \"security assumptions\" in place.) This would be a very high goal, and I would honestly avoid that unless you've got a very solid math+cryptography background.</li>\n<li>As for something like data analysis, you'll have to be pretty clear what your goal with formal verification. Are you trying to <em>program</em> some data analysis pipeline in Lean and verify it? Are you trying to <em>prove</em> a theorem abstractly about how something performs? What kind of properties are you hoping to prove?</li>\n<li>Are you set on just beelining for one thing, or are you generally looking to get in to Lean? If you want to learn about cryptography in Lean, for instance, there's projects like <a href=\"https://github.com/Verified-zkEVM/ArkLib\">https://github.com/Verified-zkEVM/ArkLib</a> . There's also not much \"classical statistics\" (like, Student's t-test) in Mathlib, so that kind of \"data analysis\"-y stuff would be very welcome, and people here would be happy to help you learn how to prove + contribute such stuff.</li>\n</ul>",
        "id": 542127342,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1759175307
    },
    {
        "content": "<p>Its a little different, its for time series datasets. We take slices, for instance with bitcoin it was the block chain, from 86,000 to I believe ~450,000 or so, it was 330,000 total blocks. You take a diagonal at a n+1 position across the data stream and calculate n1, n2, n3 to 256, and take the Shannon entropy of the diagonal. For bitcoin the cleanroom was pure SHA-256 hashes. we took the same diagonal from them as we did the block chain and found that the PoW scheme was imposing a .02 difference in the randomness of the hash consistently across those 330,000 or so blocks. Does that mean anything? Not really. But it was cool! So we tested in some other areas too and sent it in to comp sci after. Once that was done, we thought if it was a randomness test we can develop to beat it and specifically developed an encryption scheme to do so and that encryption scheme passed Big Crush, Practrand to a TB, Dieharder etc. So thats the sitch. The cipher was a secondary confirmation of the experiments results, but once again both are under review</p>",
        "id": 542128710,
        "sender_full_name": "Luke Miller",
        "timestamp": 1759175740
    },
    {
        "content": "<p>And to answer your other questions: Lean seems to be something I'm going to genuinely need to know in the future. I shared to I suppose introduce myself to the community, but you do not owe me your attention.  If someone chooses to help great, if not I understand. My problems are solved and my lean compiles, everything from there is semantics</p>",
        "id": 542129810,
        "sender_full_name": "Luke Miller",
        "timestamp": 1759176140
    }
]