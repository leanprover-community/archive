[
    {
        "content": "<p>I made a simple linter that tries to find type class assumptions that can be generalized.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>import Mathlib\n\nsection\nopen Lean Meta\n\nunsafe def extractAux (root : Bool) (excluded : FVarIdSet) (e : Expr) : StateRefT (Std.HashMap FVarId (Option Expr)) (StateT (PtrSet Expr) IO) Unit := do\n  if (← getThe (PtrSet Expr)).contains e then\n    return\n  else\n  -- if !root then\n  modifyThe (PtrSet Expr) (·.insert e)\n  for arg in e.getAppArgs do\n    if let .fvar fvarId := arg then\n      if !excluded.contains fvarId then\n        if e.hasLooseBVars || root then\n          modify (·.insert fvarId none)\n        else\n          modify (·.alter fvarId fun | none =&gt; e | some none =&gt; some none | some (some e&#39;) =&gt; if e == e&#39; then e else some none)\n  match e with\n  | .app ..          =&gt; extractAux false excluded e.getAppFn; e.getAppArgs.forM (extractAux false excluded)\n  | .forallE _ d b _\n  | .lam _ d b _     =&gt; extractAux false excluded d; extractAux false excluded b\n  | .letE _ t v b _  =&gt; extractAux false excluded t; extractAux false excluded v; extractAux false excluded b\n  | .mdata _ expr    =&gt; extractAux false excluded expr\n  | .proj _ _ struct =&gt;\n    if !root then\n      if let .fvar fvarId := struct then\n        modify (·.alter fvarId fun | none =&gt; e | some e&#39; =&gt; if e == e&#39; then e else some none)\n    extractAux false excluded struct\n  | _ =&gt; return\n\n\nunsafe def extract (binderTypes : Array Expr) (type value : Expr) : StateRefT (Std.HashMap FVarId (Option Expr)) (StateT (PtrSet Expr) IO) Unit := do\n  let excluded := binderTypes.foldl (init := {}) fun s binderType =&gt; collectFVars s binderType\n  let excluded := excluded.fvarSet\n  extractAux false excluded type\n  extractAux true excluded value\n\n\ndef getTypeClass (e : Expr) : MetaM (Option Name) := do\n  let .const n _ := e.getAppFn | return none\n  if isClass (← getEnv) n then\n    return n\n  else\n    return none\n\n\ndef excludedPairs : Std.HashSet (Name × Name) := .ofList [\n  (``Monad, ``Alternative), (``Monad, ``Applicative),\n  (``EquivBEq, ``PartialEquivBEq), (``EquivBEq, ``ReflBEq),\n  (``IsEmpty, ``Unique), (``Subsingleton, ``Unique), (``Subsingleton, ``IsEmpty), (``Finite, ``Nonempty), (``Finite, ``Fintype), (``Finite, ``IsEmpty),\n  (``Nontrivial, ``NeZero),\n  (``Algebra.IsAlgebraic, ``Algebra.IsIntegral),\n  (``SecondCountableTopology, ``SecondCountableTopologyEither),\n  (``NoZeroDivisors, ``NoZeroSMulDivisors),\n\n  (``Add, ``HAdd), (``Sub, ``HSub), (``Mul, ``HMul), (``Div, ``HDiv), (``Pow, ``HPow), (``SMul, ``HSMul), (``VAdd, ``HVAdd),\n  (``Zero, ``OfNat), (``One, ``OfNat),\n\n  (``NoMinOrder, ``NoMaxOrder), (``NoMaxOrder, ``NoMinOrder),\n  (``IsPredArchimedean, ``IsSuccArchimedean), (``IsSuccArchimedean, ``IsPredArchimedean),\n  (``IsStronglyCoatomic, ``IsStronglyAtomic), (``IsStronglyAtomic, ``IsStronglyCoatomic),\n  (``IsCoatomic, ``IsAtomic), (``IsAtomic, ``IsCoatomic),\n  (``IsUpperModularLattice, ``IsLowerModularLattice), (``IsLowerModularLattice, ``IsUpperModularLattice),\n  (``OrderTop, ``OrderBot), (``OrderBot, ``OrderTop),\n  (``BoundedGENhdsClass, ``BoundedLENhdsClass), (``BoundedLENhdsClass, ``BoundedGENhdsClass),\n  (``ClosedIicTopology, ``ClosedIciTopology), (``ClosedIciTopology, ``ClosedIicTopology),\n  (``ContinuousInf, ``ContinuousSup), (``ContinuousSup, ``ContinuousInf),\n  (``Topology.IsLower, ``Topology.IsUpper), (``Topology.IsUpper, ``Topology.IsLower),\n  (``Topology.IsLowerSet, ``Topology.IsUpperSet), (``Topology.IsUpperSet, ``Topology.IsLowerSet),\n  (``InfConvergenceClass, ``SupConvergenceClass), (``SupConvergenceClass, ``InfConvergenceClass),\n  (``NoTopOrder, ``NoBotOrder), (``NoBotOrder, ``NoTopOrder),\n\n  (``IsLeftCancelMul, ``IsRightCancelMul), (``IsRightCancelMul, ``IsLeftCancelMul),\n\n  (``CategoryTheory.RepresentablyCoflat, ``CategoryTheory.RepresentablyFlat), (``CategoryTheory.RepresentablyFlat, ``CategoryTheory.RepresentablyCoflat),\n  (``CategoryTheory.Epi, ``CategoryTheory.Mono), (``CategoryTheory.Mono, ``CategoryTheory.Epi),\n  (``CategoryTheory.IsCofiltered, ``CategoryTheory.IsFiltered), (``CategoryTheory.IsFiltered, ``CategoryTheory.IsCofiltered),\n  (``CategoryTheory.IsCofilteredOrEmpty, ``CategoryTheory.IsFilteredOrEmpty), (``CategoryTheory.IsFilteredOrEmpty, ``CategoryTheory.IsCofilteredOrEmpty),\n  (``CategoryTheory.Functor.Initial, ``CategoryTheory.Functor.Final), (``CategoryTheory.Functor.Final, ``CategoryTheory.Functor.Initial),\n  (``CategoryTheory.MorphismProperty.HasRightCalculusOfFractions, ``CategoryTheory.MorphismProperty.HasLeftCalculusOfFractions), (``CategoryTheory.MorphismProperty.HasLeftCalculusOfFractions, ``CategoryTheory.MorphismProperty.HasRightCalculusOfFractions),\n  (``ComplexShape.Embedding.IsTruncLE, ``ComplexShape.Embedding.IsTruncGE), (``ComplexShape.Embedding.IsTruncGE, ``ComplexShape.Embedding.IsTruncLE),\n  (``CategoryTheory.Limits.HasFiniteColimits, ``CategoryTheory.Limits.HasFiniteLimits), (``CategoryTheory.Limits.HasFiniteLimits, ``CategoryTheory.Limits.HasFiniteColimits),\n  (``CategoryTheory.Limits.HasFiniteCoproducts, ``CategoryTheory.Limits.HasFiniteProducts), (``CategoryTheory.Limits.HasFiniteProducts, ``CategoryTheory.Limits.HasFiniteCoproducts),\n  (``CategoryTheory.Limits.HasColimitsOfSize, ``CategoryTheory.Limits.HasLimitsOfSize), (``CategoryTheory.Limits.HasLimitsOfSize, ``CategoryTheory.Limits.HasColimitsOfSize),\n  (``CategoryTheory.Limits.HasFilteredColimitsOfSize, ``CategoryTheory.Limits.HasCofilteredLimitsOfSize), (``CategoryTheory.Limits.HasCofilteredLimitsOfSize, ``CategoryTheory.Limits.HasFilteredColimitsOfSize),\n  (``CategoryTheory.EnoughProjectives, ``CategoryTheory.EnoughInjectives), (``CategoryTheory.EnoughInjectives, ``CategoryTheory.EnoughProjectives),\n]\ndef excludedOld : List Name := [\n  ``Nonempty, ``Countable\n]\ndef excludedNew : List Name := [\n  ``CovariantClass, ``ContravariantClass\n]\n\n\nunsafe def replace (e k r : Expr) : (StateT (PtrMap Expr Expr) IO) Expr :=\n  let rec visit (e : Expr) : (StateT (PtrMap Expr Expr) IO) Expr := do\n    if e == k then\n      return r\n    else\n      if let some e&#39; := (← get).find? e then\n        return e&#39;\n      else\n        match e with\n        | .app f a         =&gt; return e.updateApp! (← visit f) (← visit a)\n        | .mdata _ b       =&gt; return e.updateMData! (← visit b)\n        | .proj _ _ b      =&gt; return e.updateProj! (← visit b)\n        | .letE _ t v b _  =&gt; return e.updateLet! (← visit t) (← visit v) (← visit b)\n        | .lam _ d b _     =&gt; return e.updateLambdaE! (← visit d) (← visit b)\n        | .forallE _ d b _ =&gt; return e.updateForallE! (← visit d) (← visit b)\n        | e                =&gt; return e\n  visit e\n\ndef checkAbstraction (type value k kType : Expr) : MetaM Bool := do\n  withLocalDeclD `_a kType fun fvar =&gt; do\n    let type ← unsafe ((replace type k fvar).run&#39; mkPtrMap)\n    unless ← isTypeCorrect type do\n      return false\n    let value ← unsafe ((replace value k fvar).run&#39; mkPtrMap)\n    unless ← isTypeCorrect value do\n      return false\n    isDefEq type (← inferType value)\n\ndef generalizations (type value : Expr) : MetaM (Option MessageData) := do\n  forallTelescope type fun fvars type =&gt; do\n    let types ← fvars.mapM (inferType ·)\n    let value := value.beta fvars\n    let (_, map) ← unsafe ((extract types type value).run {}).run&#39; mkPtrSet\n    let mut msgs := #[]\n    for (fvarId, term) in map do\n      if let some term := term then\n        if !term.isProj then\n          let some instName := term.getAppFn.constName? | continue\n          if !(← isInstance instName) then\n            continue\n        let newType ← inferType term\n        let decl ← fvarId.getDecl\n        let oldType := decl.type\n        let some oldCls ← getTypeClass oldType | continue\n        let some newCls ← getTypeClass newType | continue\n        if oldCls != newCls &amp;&amp; !excludedPairs.contains (oldCls, newCls) &amp;&amp; !excludedOld.contains oldCls &amp;&amp; !excludedNew.contains newCls then\n          if ← checkAbstraction type value term newType then\n            msgs := msgs.push (← AddMessageContext.addMessageContext\n              m! &quot;[{oldType}] can be generalized to [{newType}]&quot;)\n    if msgs.isEmpty then return none else\n      return MessageData.ofArray msgs\n\n\nnamespace Batteries.Tactic.Lint\n\n/-- A linter for commutativity lemmas that are marked simp. -/\n@[env_linter]\ndef myLinter : Linter where\n  noErrorsFound := &quot;No error found&quot;\n  errorsFound := &quot;Error found&quot;\n  test := fun declName =&gt; do\n    -- throwError declName\n    unless ← isAutoDecl declName do\n      let .thmInfo c ← getConstInfo declName | return none\n      return ← generalizations c.type c.value\n    return none\n\nend Batteries.Tactic.Lint\nend\n\n#lint only myLinter in Mathlib\n</code></pre></div>\n</div></div>\n<p>It works by asking whether a hypothesis <code>inst</code> always appears inside the same application or projection. If so, then replace this expression by a new free variable, and check if the result is still type correct. So far it only looks at hypotheses that don't appear in other hypotheses. It also won't necessarily give the most general generalization.</p>\n<p>This is similar to <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Elab.20to.20generalize.20type.20classes.20for.20theorems/with/501288855\">#mathlib4 &gt; Elab to generalize type classes for theorems</a> , except this looks at the underlying expressions, instead of modifying the syntax.</p>\n<p>Running it on Lean and Batteries yields a few theorems that can be generalized (<a href=\"https://github.com/leanprover/lean4/pull/7611\">lean#7611</a> and <a href=\"https://github.com/leanprover-community/batteries/pull/1171\">batteries#1171</a>)</p>\n<p>Running it on Mathlib gives an enormous ~2500 results, after filtering out most unwanted results. Here they are in a file:</p>\n<p><a href=\"/user_uploads/3121/oelerO2EhHhNXg27PwTk2CTi/Generalizable_hypotheses.md\">Generalizable_hypotheses.md</a></p>\n<p>The filtering is necessary because not everying that the linter finds is a reasonable generalization, such as replacing <code>Nonempty _</code> by <code>Inhabited _</code> or by <code>NeZero 1</code>, or replacing <code>NoMaxOrder α</code> by <code>NoMinOrder αᵒᵈ</code></p>",
        "id": 507102487,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742518731
    },
    {
        "content": "<p>Cool! I think an approach working on Exprs has a lot of advantages, speed being a very important one, and I had begun to regret my original Syntax approach for how slow it was. This seems to be strictly more general than my implementation, since it also covers type classes in <code>variable</code> blocks, and finds about ~3x as many as mine does. One thing I had found I needed was to add some filtering for what generalizations are performed since some generalizations are not meaningful (this was specifically to cover Algebra, Module, and IsTopological* classes, though there may be more.)</p>",
        "id": 507202401,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1742539666
    },
    {
        "content": "<blockquote>\n<p>It also won't necessarily give the most general generalization.</p>\n</blockquote>\n<p>Could you give an example when this is the case?</p>",
        "id": 507202473,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1742539687
    },
    {
        "content": "<p>Based on just skimming through the list, some of the following look to me like generalizations that should be excluded:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">measurableSet_lineDifferentiableAt_uncurry</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> [[SecondCountableTopology</span>\n<span class=\"cm\">   E] can be generalized to [SecondCountableTopologyEither E E]] -/</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">instNoZeroDivisors</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> [[NoZeroDivisors α] can be generalized to [NoZeroSMulDivisors α α]] -/</span>\n</code></pre></div>\n<p>Applying this didn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Isometric</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">isometry_cfcHom</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> [[IsometricContinuousFunctionalCalculus R A</span>\n<span class=\"cm\">   p] can be generalized to [ContinuousFunctionalCalculus R A p]] -/</span>\n</code></pre></div>\n<p>It may be worth trying to apply all of these and see if something breaks to find bugs. In my experience, I found that you may want to exclude Mathlib/Tactic, Mathlib/Algebra/Field/IsField.lean, and Mathlib/Data/Int/Cast/Field.lean</p>",
        "id": 507207325,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1742542044
    },
    {
        "content": "<p>This also works on instances which is cool, though the volume of hard-to-tell-if-its-useful generalizations with the added difficulty of generalizing type class assumptions in <code>variable</code> blocks led me to not get very far when I tried to see if I could split any out from your list.</p>",
        "id": 507207571,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1742542156
    },
    {
        "content": "<p>One example of not giving the most general generalization is where <code>Monad m</code> can be replaced by <code>Functor m</code>, but it suggests to replace it with <code>Applicative m</code>.</p>",
        "id": 507233567,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742550805
    },
    {
        "content": "<p>It's not immediately clear to me why that would be the case, e.g. what is the reason why a less general class may be picked?</p>",
        "id": 507238819,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1742552447
    },
    {
        "content": "<p>I could change the code to also look for the more general one, but currently it just looks for type classes that are \"one step away\"</p>",
        "id": 507238992,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742552505
    },
    {
        "content": "<p>The code doesn't actually use anything about type classes. It is more of a hypothesis generalizer. And at the end it checks that it generalized a type class to a type class.</p>",
        "id": 507239184,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742552572
    },
    {
        "content": "<p>Here's an updated version of the document, now with 2092 theorems.</p>\n<p><a href=\"/user_uploads/3121/PF-MrOifOmYNvOyldajSBcNR/Generalizable_hypotheses.md\">Generalizable_hypotheses.md</a></p>",
        "id": 507247536,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1742554942
    }
]