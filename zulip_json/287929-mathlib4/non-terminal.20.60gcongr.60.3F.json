[
    {
        "content": "<p>When <code>simp</code> is used in the middle of a proof, it is recommended <a href=\"https://leanprover-community.github.io/extras/simp.html#non-terminal-simps\">here</a> to squeeze it. What about other tacics with similar behaviours (that is, they change as more lemmas with <code>attrib</code> are added), such as <code>gcongr</code>?<br>\nShould one squeeze it/replace it with explicit terms in the middle of a proof? If not, why?</p>",
        "id": 520007674,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1747992326
    },
    {
        "content": "<p><code>gcongr</code> is not meant to be always finishing, so I would say you can use it.</p>",
        "id": 520025921,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1747998099
    },
    {
        "content": "<p>You're asking a sharp question here! This has been discussed before (but is not documented elsewhere yet), the keyword is \"flexible linter\" or \"flexible\" and \"rigid\" tactics.</p>",
        "id": 520028244,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1747998801
    },
    {
        "content": "<p>This has been implemented as a linter, use <code>set_option linter.flexible true</code> to enable it.</p>",
        "id": 520028379,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1747998851
    },
    {
        "content": "<p>(Mathlib doesn't enable that linter by default yet, but complying with it is usually a good idea.)</p>",
        "id": 520028882,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1747999018
    },
    {
        "content": "<p>My opinion (which isn't shared by everyone) is that nonterminal <code>gcongr</code> should have an explicit pattern, since otherwise it's fairly common for it to break if new gcongr lemmas (and positivity extensions) are added</p>",
        "id": 520039432,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1748002434
    },
    {
        "content": "<p>When it breaks, it's often because it has become more powerful and that one of the steps of the proof is not necessary anymore. That's good news, and a good occasion to cleanup the proof!</p>",
        "id": 520041909,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1748003153
    },
    {
        "content": "<p>My experience is quite the opposite, it's more common for me that the breakage is of the same form you get with nonterminal simp: the tactic is going further than is useful in a particular application! And so, in my projects, I view unqualified gcongr similarly to nonterminal simp (and I think this is consistent with what the flexible linter thinks)</p>",
        "id": 520043154,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1748003472
    },
    {
        "content": "<p>Ah, it's funny we had different feelings. Maybe it's domain-related...</p>",
        "id": 520043488,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1748003558
    },
    {
        "content": "<p>Thanks to you all for your answers. I understood that, while there's no clear guideline and <code>gcongr</code> can be used in the middle, maybe there are cases where it's reasonable to write explicit terms</p>",
        "id": 520057436,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1748007802
    },
    {
        "content": "<p>I don't read Bhavik as saying \"write explicit terms\", but \"use a pattern with gcongr\". That should keep some of the robustness, but allows the benefits of using a more powerful tactic (such as, having to write out fewer lemma names by hand).</p>",
        "id": 520060655,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1748008719
    },
    {
        "content": "<p>Does this mean we want a <code>gcongr?</code> tactic like <code>simp?</code> that spits out the pattern that was actually used? I find it quite annoying typing out an explicit pattern.</p>",
        "id": 520062221,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1748009127
    },
    {
        "content": "<p>You there is already a <code>gcongr?</code> that will help you write the pattern, right?</p>",
        "id": 520071158,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1748011758
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Widget/GCongr.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Widget/GCongr.html</a></p>",
        "id": 520071285,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1748011793
    },
    {
        "content": "<p>Ah, so there is! Turns out I wasn't importing that tactic when I tested <code>gcongr?</code> earlier.</p>",
        "id": 520073118,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1748012268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/stream/287929-mathlib4/topic/non-terminal.20.60gcongr.60.3F/near/520060655\">said</a>:</p>\n<blockquote>\n<p>I don't read Bhavik as saying \"write explicit terms\", but \"use a pattern with gcongr\". That should keep some of the robustness, but allows the benefits of using a more powerful tactic (such as, having to write out fewer lemma names by hand).</p>\n</blockquote>\n<p>Yes, this is exactly what I mean!</p>",
        "id": 520073389,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1748012360
    },
    {
        "content": "<p>You can always go <code>suffices [what you want]</code> and then use gcongr of course; this (suffices ... by simpa) used to be a common pattern for \"make simp do what you want it to do in a non-fragile way\" before we got all the fancy <code>simp?</code> stuff.</p>",
        "id": 520087232,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748016745
    },
    {
        "content": "<p>I liked the idea that the outcome of such nonfinishing tactics was stored in some way (like <code>says…</code>). This allowed to leave some trace of the expected result that could be useful when some lemmas were added or generalized.</p>",
        "id": 520218098,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1748109651
    },
    {
        "content": "<p>That's exactly what a <code>gcongr</code> pattern would do in this case</p>",
        "id": 520218198,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1748109699
    },
    {
        "content": "<p><code>gcongr? says gcongr _ * ?_</code> is more informative than <code>gcongr _ * ?_</code>, because it also says \"notify me in the CI if <code>gcongr</code> tries to do more\".</p>",
        "id": 520220387,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1748111401
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/non-terminal.20.60gcongr.60.3F/near/520028882\">said</a>:</p>\n<blockquote>\n<p>(Mathlib doesn't enable that linter by default yet, but complying with it is usually a good idea.)</p>\n</blockquote>\n<p>Now that it is enabled by default, what should we do about nonterminal <code>gcongr</code> after <code>simp</code>? Can we register it (or at least <code>gcongr</code>-with-pattern) as a flexible tactic?</p>",
        "id": 563358920,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1765524945
    },
    {
        "content": "<p><code>gcongr</code> is quite particular about the goal it expects, right? <em>Especially</em> if you give a pattern.</p>",
        "id": 563379137,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1765525783
    },
    {
        "content": "<p>Not especially, and depends on the pattern. Unlike, say, <code>rw</code>, where a very specific LHS must appear in the target, <code>gcongr</code> will trigger fine as long as the target is a vaguely symmetric expression with some head it recognizes; within a proof one will likely rewrite many times for every time one changes the head of the proof. For example, if I start the lemma trying to prove, say, <code>s ⊆ t</code>, there's a decent chance that I'll end the lemma still proving something of the form <code>_ ⊆ _</code>.</p>",
        "id": 563456595,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1765540571
    },
    {
        "content": "<p>In that regard, there's a lot of room for various <code>simp</code> lemmas to trigger or not trigger, but unless a specific 'injectivity'/'monoticity'/etc lemma is added <code>gcongr</code> will continue to work fine; that sounds like a flexible tactic to me.</p>",
        "id": 563456831,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1765540640
    },
    {
        "content": "<p>From a maintenance pov, I want to know whether it is predictable what the goals will look like. Even if <code>gcongr</code> still succeeds on the new goal, it's unclear whether it still creates the same subgoals as before.<br>\nIf it suddenly creates 3 subgoals instead of 2, or vice versa, then I wouldn't want to be the person that has to fix that proof.</p>",
        "id": 563459222,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1765541377
    }
]