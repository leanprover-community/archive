[
    {
        "content": "<p>Would the following two results be worth adding to Mathlib?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hasDerivAtFilter_zero</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">HasDerivAtFilter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">isLittleOTVS</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Asymptotics</span><span class=\"bp\">.</span><span class=\"n\">isLittleOTVS_iff_isLittleO</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hasDerivAt_zero</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">HasDerivAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hasDerivAtFilter_zero</span>\n</code></pre></div>\n<p>These have come up relatively naturally in what I'm doing, but I'm not sure how useful they would be given that  there are already very similar results, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=hasDerivWithinAt_const#doc\">docs#hasDerivWithinAt_const</a></p>",
        "id": 508053099,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1742915787
    },
    {
        "content": "<p>I think this comes down to the same thing as whether to write <code>Continuous (f * g)</code> or <code>Continuous (fun x =&gt; f x * g x)</code>, and what to name them if we have both</p>",
        "id": 508056774,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742916596
    },
    {
        "content": "<p>Indeed, if we decide we only want the one with <code>fun</code>, then there is no need for your lemma as it's a syntactic specialization of the <code>const</code> one you mention</p>",
        "id": 508056934,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742916624
    },
    {
        "content": "<p>Both conventions seem to be used here, since there is also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=derivWithin_zero#doc\">docs#derivWithin_zero</a></p>",
        "id": 508062732,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1742918030
    },
    {
        "content": "<p>I guess following every <code>_const</code> result with <code>_zero</code>, <code>_one</code>, and <code>_ofNat</code> would be reasonable then</p>",
        "id": 508065232,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742918597
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/23310\">#23310</a></p>",
        "id": 508075571,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1742920956
    },
    {
        "content": "<p>Turns out this adds a <em>lot</em> of lemmas. Would we prefer to just write them all manually as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hasDerivAtFilter_zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasDerivAtFilter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">hasDerivAtFilter_const</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hasDerivAtFilter_one</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasDerivAtFilter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">hasDerivAtFilter_const</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hasDerivAtFilter_natCast</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasDerivAtFilter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">hasDerivAtFilter_const</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hasDerivAtFilter_intCast</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IntCast</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„¤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasDerivAtFilter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">hasDerivAtFilter_const</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hasDerivAtFilter_ofNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasDerivAtFilter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ofNat</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">hasDerivAtFilter_const</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>or have something more mechanical like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">run_cmd</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"ss\">`hasDerivAtFilter_zero</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"bp\">#</span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"ss\">`hasDerivAtFilter_one</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">])],</span><span class=\"w\"> </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"ss\">`hasDerivAtFilter_natCast</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]),</span><span class=\"w\"> </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">))],</span><span class=\"w\"> </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"ss\">`hasDerivAtFilter_intCast</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IntCast</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]),</span><span class=\"w\"> </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„¤</span><span class=\"o\">))],</span><span class=\"w\"> </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">)),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"ss\">`hasDerivAtFilter_ofNat</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">bracketedBinderF</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">])],</span><span class=\"w\"> </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">ofNat</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)))</span>\n<span class=\"w\">  </span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">elabCommandTopLevel</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">      </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span>\n<span class=\"w\">      </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">args</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">        </span><span class=\"n\">HasDerivAtFilter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">          </span><span class=\"n\">hasDerivAtFilter_const</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 508933017,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743262859
    },
    {
        "content": "<p>If the mechanical code is longer than the copy/pasted code... :)</p>",
        "id": 508941315,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1743268422
    },
    {
        "content": "<p>I think that we should have a tactic that specializes \"const\" results to</p>\n<ul>\n<li><code>OfNat.ofNat</code>;</li>\n<li>zero and one</li>\n<li><code>Nat.cast</code>;</li>\n<li><code>Int.cast</code>.</li>\n</ul>",
        "id": 508950446,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1743275980
    },
    {
        "content": "<p>This appears in many contexts, not only <code>HasDerivAt</code>.</p>",
        "id": 508950453,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1743275991
    },
    {
        "content": "<p>I can have a go at writing that:)</p>",
        "id": 508950853,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1743276318
    },
    {
        "content": "<p>Not a tactic, but an attribute / command, right?</p>",
        "id": 508968707,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743291995
    },
    {
        "content": "<p>Yes, I meant \"meta program\".</p>",
        "id": 508974709,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1743297009
    },
    {
        "content": "<p>Is the proposal that we write this <em>before</em> merging <a href=\"https://github.com/leanprover-community/mathlib4/pull/23310\">#23310</a>, or that we attempt it as a follow up?</p>",
        "id": 509008889,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743327482
    },
    {
        "content": "<p>I was thinking of doing this as a follow up</p>",
        "id": 509013373,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1743330953
    },
    {
        "content": "<p>Another related proposal is to have an attribute and/or command that turns a <code>Nat.cast</code> lemma into zero, one, and <code>ofNat</code> lemmas.</p>",
        "id": 509055257,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1743361077
    },
    {
        "content": "<p>I think that for zero and one that probably ends up discarding generality</p>",
        "id": 509066653,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743370532
    },
    {
        "content": "<p>For ofNat we could certainly make lots use of that, but I wouldn't work for the PR mentioned above.</p>",
        "id": 509066729,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743370574
    }
]