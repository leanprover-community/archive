[
    {
        "content": "<p>tl;dr: I don't understand the <code>cannot find synthesization order for instance</code> error.</p>\n<p>When diagnosing a timeout in an FLT PR I ran into the following thing. If S,R are commutative rings and R is an S-algebra, and if A and B are R-modules (and hence S-modules via IsScalarTower), then any R-linear map from A to B is S-linear. Typeclass inference was timing out when trying to prove an instance of this unless synthInstance.maxheartbeats were bumped. So I figured I'd try and add the instance myself. The general case felt like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulActionHomClass</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MulActionHomClass</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">map_smulₛₗ</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"bp\">.</span><span class=\"n\">algebraMap_smul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">map_smul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"bp\">.</span><span class=\"n\">algebraMap_smul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">id_def</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>which works fine as a <code>def</code> but Lean won't buy it as an instance, moaning that it can't find a good synthesization order. Well on the face of it this weems reasonable: when faced with a goal of <code>MulActionHomClass F S A B</code> Lean cannot really guess an <code>R</code>. So I figured that instead of working with a general LinearMapClass F I should just work with linear maps, and tried this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">MulActionHomClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">map_smulₛₗ</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"bp\">.</span><span class=\"n\">algebraMap_smul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">map_smul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"bp\">.</span><span class=\"n\">algebraMap_smul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">id_def</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Again this compiles fine as a def but fails as an instance. This one I was more surprised by because surely all of the type information is in <code> MulActionHomClass (A →ₗ[R] B) S A B</code> this time? The error is</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>cannot find synthesization order for instance instMulActionHomClassLinearMapIdOfIsScalarTower_fLT with type\n  ∀ (S : Type u_5) (R : Type u_6) (A : Type u_7) (B : Type u_8) [inst : CommSemiring S] [inst_1 : CommSemiring R]\n    [inst_2 : Algebra S R] [inst_3 : AddCommMonoid A] [inst_4 : Module R A] [inst_5 : Module S A]\n    [inst_6 : IsScalarTower S R A] [inst_7 : AddCommMonoid B] [inst_8 : Module R B] [inst_9 : Module S B]\n    [inst_10 : IsScalarTower S R B], MulActionHomClass (A →ₗ[R] B) S A B\nall remaining arguments have metavariables:\n  CommSemiring ?S\n  @Algebra ?S R ?inst✝ CommSemiring.toSemiring\n  @Module ?S A CommSemiring.toSemiring inst✝⁷\n  @IsScalarTower ?S R A Algebra.toSMul SMulZeroClass.toSMul SMulZeroClass.toSMul\n  @Module ?S B CommSemiring.toSemiring inst✝³\n  @IsScalarTower ?S R B Algebra.toSMul SMulZeroClass.toSMul SMulZeroClass.toSMul\n</code></pre></div>\n<p>And then I tried it with the specific case which was causing the slowdown in FLT:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MulActionHomClass</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">adicCompletion</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Extension</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">adicCompletion</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">B</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">adicCompletion</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Extension</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">adicCompletion</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">map_smulₛₗ</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"bp\">.</span><span class=\"n\">algebraMap_smul</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">map_smul</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">IsScalarTower</span><span class=\"bp\">.</span><span class=\"n\">algebraMap_smul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">id_def</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and it worked fine :-) So clearly I'm giving Lean enough clues with my convoluted special case. I am wondering what the big difference is between my convoluted special case and my attempt to make a general instance. The algebra version of the general also fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">MulActionHomClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">map_smulₛₗ</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"bp\">.</span><span class=\"n\">algebraMap_smul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">map_smul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"bp\">.</span><span class=\"n\">algebraMap_smul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">id_def</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 512394119,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744743592
    },
    {
        "content": "<p>the issue is that other than the first argument, <code>MulActionHomClass</code>s arguments are <code>outParams</code>, meaning that since <code>S</code> does not occur in <code>A →ₐ[R] B</code> or <code>A →ₗ[R] B</code>, lean is unable to choose a value</p>",
        "id": 512412821,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744750886
    },
    {
        "content": "<p>(i think)</p>",
        "id": 512412865,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744750909
    },
    {
        "content": "<p>indeed, the first argument to <code>MulActionHomClass</code> in the instance from the FLT slowdown mentions all of <code>L,K,v,B</code>, so it does not complain</p>",
        "id": 512414468,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744751595
    },
    {
        "content": "<p>Yeah that sounds like a plausible explanation! Thanks!</p>",
        "id": 512415886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744752228
    },
    {
        "content": "<p>Oops, I feel responsible for this design of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MulActionHomClass#doc\">docs#MulActionHomClass</a>, which was indeed borrowed from what existed for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMapClass#doc\">docs#LinearMapClass</a>… Is there any suggestion to make?</p>",
        "id": 512489896,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1744790947
    },
    {
        "content": "<p>Slightly off-topic, I had resisted defining <code>MulActionEquiv</code>, on which <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearEquiv#doc\">docs#LinearEquiv</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgEquiv#doc\">docs#AlgEquiv</a> could build. Should I try?</p>",
        "id": 512490062,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1744791003
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/channel/287929-mathlib4/topic/MulActionHomClass.20cannot.20find.20synthesization.20order/near/512489896\">said</a>:</p>\n<blockquote>\n<p>Oops, I feel responsible for this design of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MulActionHomClass#doc\">docs#MulActionHomClass</a>, which was indeed borrowed from what existed for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMapClass#doc\">docs#LinearMapClass</a>… Is there any suggestion to make?</p>\n</blockquote>\n<p>i don't think there's an issue with this design at all?</p>",
        "id": 512496667,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744793046
    },
    {
        "content": "<p>The design question is whether <em>typeclass inference</em> should be able to figure out that an R-linear map is S-linear, and you can see that in general this is a very risky idea because given a map which typeclass inference conjectures is S-linear for some S which is easily discoverable by looking at the context, using such an instance would now mean that typeclass inference has to try and prove it's R-linear but it doesn't know what R is, which sounds bad. I'm happy with the design -- I was just confused about why it was working in one case but not in another, and now I understand this (the key point is that in my case everything including R can be read from F, by coincidence).</p>",
        "id": 512508778,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744796515
    },
    {
        "content": "<p>I noticed some unification issues in the current design. E.g. <code>MulActionSemiHomClass F ⇑f M N ≟ MulActionHomClass F R M N</code> for <code>f : R →+* R</code>.</p>",
        "id": 512758685,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1744875341
    },
    {
        "content": "<p>that doesn't make sense? <code>⇑f</code> is not a type?</p>",
        "id": 512771741,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744879630
    },
    {
        "content": "<p>oh wait, nvm</p>",
        "id": 512772000,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744879707
    },
    {
        "content": "<p>i missed the <code>Semi</code> in <code>MulActionSemiHomClass F ⇑f M N</code></p>",
        "id": 512772051,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744879727
    },
    {
        "content": "<p>I experimented with a refactor that replaced <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMapClass#doc\">docs#LinearMapClass</a> with more basic typeclasses several months ago. It was completely blocked by unification issues like this.</p>",
        "id": 512779390,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1744882070
    }
]