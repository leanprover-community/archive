[
    {
        "content": "<p>I'd like to contribute these two short list operations--assuming they don't exist already in some form, and that I haven't just missed them. :)</p>\n<ol start=\"0\">\n<li>Do these belong in mathlib at all?</li>\n<li>If so, where should they go?</li>\n<li>Should they be named something else?</li>\n<li>Is it good etiquette to contribute them along with lemmas, either proving expectations about these or relating them to other things (e.g. <code>rdropWhile</code>)? Or should that come later?</li>\n<li>Variations: there are of course similar versions of these one can come up with to flesh out the API, usually to do with reversal or negation (<code>lengthWhile</code> or <code>lengthUntil</code> on the reversed list, <code>insertBeforeAny</code>, etc.); do those belong somewhere too, or do we try to minimize things like \"reversed variants\"?</li>\n</ol>\n<p>Thanks. :)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">Finds the length of the smallest prefix of `l` that contains all elements `a` of `l` for which</span>\n<span class=\"sd\">`p a` is `true`. The result satisfies `0 ≤ result ≤ l.length`.</span>\n\n<span class=\"sd\">Examples:</span>\n<span class=\"sd\">* `[0, 1, 2, 1, 3].prefixLengthContaingAll (· == 1)` returns `4`</span>\n<span class=\"sd\">* `[5].prefixLengthContainingAll (· == 1)` returns `0`</span>\n<span class=\"sd\">* `[7, 8, 1].prefixLengthContaingAll (· == 1)` returns `3`</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">prefixLengthContainingAll</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">current</span><span class=\"w\"> </span><span class=\"n\">lengthSoFar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">lengthSoFar</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">current</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">current</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">lengthSoFar</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">l</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Inserts `a` immediately after the last element `x` in `l` for which `p x` is `true`. If there is no</span>\n<span class=\"sd\">element `x` in `l` for which `p x` is `true`, inserts `a` at the beginning of the list.</span>\n\n<span class=\"sd\">Examples:</span>\n<span class=\"sd\">* `[0, 1, 2, 1, 3].insertAfterAll (· == 1) a` returns `[0, 1, 2, 1, a, 3]`</span>\n<span class=\"sd\">* `[5].insertAfterAll (· == 1) a` returns `[a, 5]`</span>\n<span class=\"sd\">* `[1, 5, 1].insertAfterAll (· == 1) a` returns `[1, 5, 1, a]`</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">insertAfterAll</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">insertIdx</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">prefixLengthContainingAll</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>",
        "id": 556636621,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763241747
    },
    {
        "content": "<ol start=\"0\">\n<li>They seem pretty niche, and using <code>Bool</code> is somewhat unexpected in mathlib</li>\n<li>Maybe they'd fit better in batteries</li>\n<li>No better suggestions</li>\n<li>If they would go into mathlib, I'd strongly encourage adding basic API lemmas</li>\n</ol>",
        "id": 556638428,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1763243674
    },
    {
        "content": "<p>Can you clarify why you need these? Because as list operations these don't seem very useful, at least not as general list operations.</p>\n<p>Here's the first function implemented with existing list operations:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">prefixLengthContainingAll</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"bp\">.</span><span class=\"n\">idxOf</span><span class=\"w\"> </span><span class=\"n\">true</span>\n</code></pre></div>\n<p>I also think reusing existing definitions is better than writing a separate recursive function.</p>\n<blockquote>\n<p>Is it good etiquette to contribute them along with lemmas, either proving expectations about these or relating them to other things (e.g. <code>rdropWhile</code>)? Or should that come later?</p>\n</blockquote>\n<p>AFAIK mathlib won't accept new definitions without  a few basic API lemmas</p>",
        "id": 556638667,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1763243952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Where.20to.20put.20these.20List.20operations.3F/near/556638667\">said</a>:</p>\n<blockquote>\n<p>Here's the first function implemented with existing list operations:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">prefixLengthContainingAll</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"bp\">.</span><span class=\"n\">idxOf</span><span class=\"w\"> </span><span class=\"n\">true</span>\n</code></pre></div>\n<p>I also think reusing existing definitions is better than writing a separate recursive function.</p>\n</blockquote>\n<p>I appreciate the motivation, but isn't this quite inefficient, traversing the list ~2-3 times in all? Ime most list definitions are written recursively, and using a <code>go</code> is quite standard, but maybe I'm most familiar with the ones from core...</p>\n<p>These came up while reviewing <code>Category*</code>, where we want to insert a new level name into a list of existing level names after all level names in that list which satisfy a certain property (in that case, being contained in some other array of collected level names).</p>",
        "id": 556639007,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763244323
    },
    {
        "content": "<p>To be  clear I am happy to see if this can be rewritten! :) But imo it should only involve one traversal of the list to count, and two to insert.</p>",
        "id": 556639143,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763244488
    },
    {
        "content": "<p>Is the first one not equivalent to <code>List.findIdx (fun a =&gt; !p a) l</code>?</p>",
        "id": 556693668,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1763307116
    },
    {
        "content": "<p>Wait no I misunderstood</p>",
        "id": 556693766,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1763307193
    },
    {
        "content": "<p>Actually it would be more something like <code>(List.findRevIdx? p l).elim 0 (· + 1)</code> (if we had <code>findRevIdx?</code>)</p>",
        "id": 556694004,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1763307407
    },
    {
        "content": "<p>I'm pretty skeptical about putting operations like this on <code>List</code>. Just converting to <code>Array</code> early on and working there seems both more ergonomic, and possibly more efficient anyway (e.g., if you start from the back, you need to evaluate <code>p</code> less often).</p>",
        "id": 556718209,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1763330600
    },
    {
        "content": "<p>How cheap is converting to Array and back? It obviously makes sense if there <em>is</em> an “early on”, but what if you’re forced by circumstance to receive, manipulate, and send a List many times? Is converting to Array not as big a deal as my intuition makes it seem? <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>\n<p>(I guess these might be micro optimizations, but it still helps build some intuition for more general cases. I always feel on slightly shaky ground around performance…)</p>",
        "id": 556718841,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1763331088
    },
    {
        "content": "<p>FWIW, I'm in a slow, long-term process to upstream, cleanup and upgrade selected parts <code>Mathlib.Data</code> to <code>Batteries.Data</code>. However, my selection process is focused on Batteries: \"Would this be useful in Batteries?\" is what I ask myself. That being said, I'm open to recommendations if anything seems it would be suitable for Batteries. Batteries will also consider upstreaming PRs but beware that these are sometimes tricky to get right.</p>",
        "id": 556719383,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1763331791
    },
    {
        "content": "<p>I think adding reversed versions of <code>idxOf</code> and <code>findIdx</code> is useful, and they exist in other languages</p>",
        "id": 556727623,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1763340669
    },
    {
        "content": "<p>Maybe a litle out of topic question, but how do you decide to upstream to batteries and not core Std ? what should be the mental questions one should ask themselves to decide ? Is there a clear guideline ?</p>",
        "id": 556931954,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1763414177
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Where.20to.20put.20these.20List.20operations.3F/near/556727623\">said</a>:</p>\n<blockquote>\n<p>I think adding reversed versions of <code>idxOf</code> and <code>findIdx</code> is useful, and they exist in other languages</p>\n</blockquote>\n<p>It would be helpful to have reference to these, specifically on singly linked lists.</p>\n<p>Remember that we <em>don't</em> want to \"complete the API\" with operations that are not \"natural\" to types because of performance patterns. Just because some function exists on <code>Array</code> does not mean that it should exist on <code>List</code>.</p>",
        "id": 556948764,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1763421531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"942100\">Alfredo Moreira-Rosa</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Where.20to.20put.20these.20List.20operations.3F/near/556931954\">said</a>:</p>\n<blockquote>\n<p>Maybe a litle out of topic question, but how do you decide to upstream to batteries and not core Std ? what should be the mental questions one should ask themselves to decide ? Is there a clear guideline ?</p>\n</blockquote>\n<p>Mostly this is \"Do Markus and Kim want it? If yes, then Std. Does François want it? If yes, then Batteries.\"</p>\n<p>Std is also gradually converging towards \"completeness\", i.e. we only want operations with complete lemma APIs, whereas to my knowledge Batteries doesn't have the aspiration.</p>",
        "id": 556949012,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1763421667
    },
    {
        "content": "<p>Alright, maybe we don't need something like <code>findIdxRev?</code> on lists but it seems like it's missing on arrays too</p>",
        "id": 556949171,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1763421778
    },
    {
        "content": "<p><code>findIdxRev?</code> on arrays would definitely be appreciated!</p>",
        "id": 556949308,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1763421864
    },
    {
        "content": "<p>Note actually that the <code>find</code> family of functions still doesn't have as complete API as it should: contributions welcome there as well.</p>",
        "id": 556949343,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1763421889
    },
    {
        "content": "<p>Yeah I have been doing a bunch of work there recently.</p>",
        "id": 557919524,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1763469259
    },
    {
        "content": "<p>I note that <code>List.idxsOf</code> sort of gives you what you'd want from a <code>findIdxRev?</code> in the sense that <code>(l.idxsOf a).getLast?</code> is precisely <code>findIdxRev?</code>, and this has the advantage that <code>idxsOf</code> <em>is</em> natural on List (because you traverse left-to-right when finding them - if you were defining <code>findIdxRev?</code> you'd <em>also</em> have to traverse the whole list because List does not naturally go right-to-left.</p>",
        "id": 557920027,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1763469404
    },
    {
        "content": "<p>(I have a currently open PR to give idxsOf better API which you can find here: <a href=\"https://github.com/leanprover-community/batteries/pull/1500\">batteries#1500</a>)</p>",
        "id": 557920524,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1763469554
    },
    {
        "content": "<p>And indeed I intend to get to defining it on Arrays also.</p>",
        "id": 557920684,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1763469601
    },
    {
        "content": "<p>What <em>is</em> the cost of List-to-Array? Is it O(l.length) (i.e. you traverse the list and load in all the elements once)?</p>",
        "id": 557920794,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1763469630
    },
    {
        "content": "<p>My understanding is that after that, computationally speaking Array doesn't have a preference in terms of how it is accessed? But adding elements is expensive on the left and cheap on the right?</p>",
        "id": 557921017,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1763469692
    },
    {
        "content": "<p>(Wheras for List it's cheap on the left and expensive on the right?)</p>",
        "id": 557921061,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1763469707
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Where.20to.20put.20these.20List.20operations.3F/near/557920794\">said</a>:</p>\n<blockquote>\n<p>What <em>is</em> the cost of List-to-Array? Is it O(l.length) (i.e. you traverse the list and load in all the elements once)?</p>\n</blockquote>\n<p>The docstring here <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#List.toArray\">https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#List.toArray</a> answers: yes, it's linear in the length</p>",
        "id": 557924940,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1763470688
    },
    {
        "content": "<p>My further question is \"why isn't <code>List.toArrayImpl xs</code> implemented as <code>xs.foldl Array.push Array.empty</code>\"?</p>",
        "id": 557946068,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1763475431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Where.20to.20put.20these.20List.20operations.3F/near/557946068\">said</a>:</p>\n<blockquote>\n<p>My further question is \"why isn't <code>List.toArrayImpl xs</code> implemented as <code>xs.foldl Array.push Array.empty</code>\"?</p>\n</blockquote>\n<p>The original code for List.toArrayImpl stems from Init.Prelude where it used to be in a position where List.foldl wasn't defined yet. Though not much point to change it now.</p>",
        "id": 557952805,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1763476823
    },
    {
        "content": "<p>Aye - well, I would argue for it on aesthetic grounds.</p>",
        "id": 557955916,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1763477481
    },
    {
        "content": "<p>Is there a <code>csimp</code> theorem that links <code>toArrayImpl</code> to <code>toArray</code> or is it assumed?</p>",
        "id": 557956636,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1763477631
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Data/List/ToArrayImpl.lean#L32-L33\">https://github.com/leanprover/lean4/blob/master/src/Init/Data/List/ToArrayImpl.lean#L32-L33</a> the documentation here explains how the linking works</p>",
        "id": 557968437,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1763480071
    },
    {
        "content": "<p>toArrayImpl never occurs in user written code</p>",
        "id": 557968609,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1763480103
    },
    {
        "content": "<p>Right I see.</p>",
        "id": 558167391,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1763548987
    },
    {
        "content": "<p>It is a bit odd that we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/List/ToArray.html#List.size_toArrayAux\">List.size_toArrayAux</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Array/Basic.html#Array.toArrayAux_eq\">Array.toArrayAux_eq</a> then.</p>",
        "id": 558168030,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1763549138
    }
]