[
    {
        "content": "<p>I have two functionally equivalent PRs. I want to transfer <code>SuccOrder</code> across an order isomorphism. </p>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/15950\">#15950</a>, I do so using <code>OrderIsoClass</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EquivLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OrderIsoClass</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SuccOrder</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SuccOrder</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SuccOrder</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/16490\">#16490</a>, I do so using <code>OrderIso</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SuccOrder</span><span class=\"bp\">.</span><span class=\"n\">of_orderIso</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SuccOrder</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">SuccOrder</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>I had closed <a href=\"https://github.com/leanprover-community/mathlib4/pull/16490\">#16490</a> because I thought there is a preference for class based lemmas. <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> indicated that the class pattern might be worse. What is the more appropriate solution?</p>",
        "id": 468906033,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1725912440
    },
    {
        "content": "<p>Sorry, I think you misunderstood my comment. What I meant to say is that the following looks like a bad idea:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">OrderIsoClass</span><span class=\"bp\">.</span><span class=\"n\">toOrderIsoClassOrderDual</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">EquivLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OrderIsoClass</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OrderIsoClass</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">ᵒᵈ</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"bp\">ᵒᵈ</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">map_le_map_iff</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">map_le_map_iff</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>",
        "id": 468906461,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725912590
    },
    {
        "content": "<p>I see. Still, to transfer <code>PredOrder</code>, I'd like to work through a dualized setup, so something of that instance would be necessary. I could make it an explicit def, or rely on concrete <code>OrderIso</code>s in total.</p>",
        "id": 468908732,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1725913306
    }
]