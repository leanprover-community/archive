[
    {
        "content": "<p>Does someone want to bump <a href=\"https://github.com/leanprover-community/mathlib4/pull/4200\">!4#4200</a> on the queue. I'm very happy but they're big enough changes that I thought maybe someone else would want a look as well.</p>",
        "id": 360729348,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1684918873
    },
    {
        "content": "<p>I'm not too sure about the original presupposition of the PR, that lean 4 doesn't handle overloaded notation. Is there a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> demonstration of the issue?</p>",
        "id": 360733309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684919935
    },
    {
        "content": "<p>I suspect the problem is that if you use <code>notation</code> to introduce the notation multiple times, you will introduce overlapping syntax and the parser will not be able to differentiate them, but if you have one syntax and multiple <code>macro_rules</code> then it should be resolved in a type-directed way as desired</p>",
        "id": 360733622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684920011
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"569722\">@Pol'tta / Miyahara Kō</span></p>",
        "id": 360733837,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684920065
    },
    {
        "content": "<p>This is MFE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Set.prod</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">82</span> <span class=\"s2\">\" ×ˢ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Set.prod</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Finset.product</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">82</span> <span class=\"s2\">\" ×ˢ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Finset.product</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">Finset.toSet</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">CoeTC</span> <span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Finset.toSet</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"c1\">-- ambiguous, possible interpretations</span>\n<span class=\"c1\">--   s ×ˢ t : Finset (α × β)</span>\n<span class=\"c1\">--   ?m.15525 ×ˢ ?m.15619 : Set (?m.15430 × ?m.15431)</span>\n</code></pre></div>",
        "id": 360779900,
        "sender_full_name": "Pol'tta / Miyahara Kō",
        "timestamp": 1684932600
    },
    {
        "content": "<p>I'm not sure if it breaks anything, but giving the <code>Finset</code> notation a higher priority fixes the ambiguity:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">82</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"s2\">\" ×ˢ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Finset.product</span>\n</code></pre></div>\n<p>It seems the problem is that the <code>Set.prod</code> notation <em>does</em> apply due to the coercion (though for some reason only on the LHS of the equality, so I had to write <code>s ×ˢ t = (s : Set α) ×ˢ (t : Set β)</code> if I comment out the <code>Finset.product</code> notation)</p>",
        "id": 360784271,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684933567
    },
    {
        "content": "<p>We switched to the notation solution in mathlib3 from a typeclass solution because it avoids type ascriptions -- adding these type ascriptions back in <a href=\"https://github.com/leanprover-community/mathlib4/pull/4200\">mathlib4#4200</a> is sort of undoing the work from just a year or so ago (though I do appreciate how it turns <code>×ᶠ</code> back into <code>×ˢ</code>!).</p>",
        "id": 360784994,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684933724
    },
    {
        "content": "<p>Maybe typeclasses are the right solution in the end, but I'd like to see it done where you don't need additional type ascriptions.</p>",
        "id": 360785234,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684933783
    },
    {
        "content": "<p>Can we write an elaboration helper that is able to solve for the correct type? sort of like how <code>binop%</code> helps with arithmetic, but we'd have <code>prod%</code> for helping to resolve the prod using the types of the arguments and the expected type all together?</p>",
        "id": 360785627,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684933862
    },
    {
        "content": "<p>I think I got a design that works and avoids the type ascriptions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Prod</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Prod</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"sd\">/-- Notation type class for the set product `×ˢ`. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">HSProd</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- The cartesian product `s ×ˢ t` is the set of `(a, b)` such that `a ∈ s` and `b ∈ t`. -/</span>\n  <span class=\"n\">hSprod</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">SProd</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u'</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u'</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">s''</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">u'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">u'</span><span class=\"o\">)))</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- The cartesian product `s ×ˢ t` using explicit type constructors (see also `HSProd.hSprod`). -/</span>\n  <span class=\"n\">sprod</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">s'</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">s''</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- This notation binds more strongly than (pre)images, unions and intersections.</span>\n<span class=\"kd\">@[inherit_doc HSProd.hSprod]</span> <span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">82</span> <span class=\"s2\">\" ×ˢ' \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">HSProd.hSprod</span>\n<span class=\"c1\">-- *Edit:* This line apparently doesn't do anything in this case. Commenting it out</span>\n<span class=\"c1\">-- macro_rules | `($x ×ˢ' $y)   =&gt; `(binop% HSProd.hSprod $x $y)</span>\n\n<span class=\"kd\">@[default_instance]</span> <span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">SProd</span> <span class=\"n\">s</span> <span class=\"n\">s'</span> <span class=\"n\">s''</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">HSProd</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s''</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">SProd.sprod</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[default_instance]</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">SProd</span> <span class=\"n\">Set</span> <span class=\"n\">Set</span> <span class=\"n\">Set</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Set.prod</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">SProd</span> <span class=\"n\">Finset</span> <span class=\"n\">Finset</span> <span class=\"n\">Finset</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Finset.product</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">×ˢ'</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"bp\">×ˢ'</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">×ˢ'</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"bp\">×ˢ'</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">s.InjOn</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">×ˢ'</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">InjOn</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">×ˢ'</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">InjOn</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">×ˢ'</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">InjOn</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set.InjOn</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">×ˢ'</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 360793911,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684935759
    },
    {
        "content": "<p>Hmm, I could have sworn that I did a test where the <code>macro_rules</code> line was necessary, but it doesn't seem to be in any of these examples...</p>",
        "id": 360794584,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684935922
    },
    {
        "content": "<p>(And maybe <code>binop%</code> doesn't work for something quite as heterogeneous as set products)</p>",
        "id": 360794886,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684935988
    },
    {
        "content": "<p>This is likely still not as good as it can be. Ideally the <code>HSProd</code> default instance could constrain <code>s</code>, <code>s'</code>, and <code>s''</code> to be the same constant modulo universe variables, so perhaps a <code>prod%</code> elaborator is still in order.</p>",
        "id": 360796436,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684936300
    },
    {
        "content": "<p>Also it would be great if we could unify the <code>Prod</code> notation with all the other products. The superscript is particularly annoying for me to enter and there isn't really any reason it's there besides \"We couldn't make the notation work in Lean 3\"</p>",
        "id": 360805201,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1684938081
    },
    {
        "content": "<p>This idea can be implemented using the new attribute <code>prod_notaion</code>.</p>",
        "id": 360810589,
        "sender_full_name": "Pol'tta / Miyahara Kō",
        "timestamp": 1684939272
    },
    {
        "content": "<p>I made a <code>binop%</code>-like elaborator for \"functorial\" types (<code>Set</code>, <code>Finset</code>, etc.) and coercions between them. The <code>binop%</code> elaborator tries to solve for a single type that everything can be coerced to, but that doesn't work here since the product operator is inherently inhomogeneous. Instead, <code>fbinop%</code> tries to find coercions while swapping out <code>Set</code>, <code>Finset</code>, etc. for another such \"functor.\" (I'm calling these functors in a loose sense, functions <code>Type u -&gt; Type v</code>.)</p>",
        "id": 360869916,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684953327
    },
    {
        "content": "<p>If anyone would be kind and test it out, it's at <a href=\"https://github.com/leanprover-community/mathlib4/pull/4308\">mathlib4#4308</a></p>",
        "id": 360869943,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684953341
    },
    {
        "content": "<p>Here are a few things it lets you do without type ascriptions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat.card</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">t</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"c1\">-- After elaboration: Nat.card ↑(↑s ×ˢ t ×ˢ ↑u) with the Finsets as Sets</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">×ˢ</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">t</span>\n<span class=\"c1\">-- The {1, 2, 3} is a Set</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">×ˢ</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">t</span>\n<span class=\"c1\">-- The {1, 2, 3} is a Finset</span>\n</code></pre></div>",
        "id": 360870010,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684953363
    },
    {
        "content": "<p>Just like other core operators, it pushes coercions inward among a tree of <code>fbinop%</code> expressions. Here's another example with that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">InjOn</span> <span class=\"n\">f</span>\n<span class=\"c1\">-- Set.InjOn f (↑s ×ˢ ↑t) with the Finsets as Sets</span>\n</code></pre></div>",
        "id": 360870649,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684953546
    },
    {
        "content": "<p>Pinging <span class=\"user-mention\" data-user-id=\"569722\">@Pol'tta / Miyahara Kō</span></p>",
        "id": 360871318,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684953755
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234200/near/360784994\">said</a>:</p>\n<blockquote>\n<p>adding these type ascriptions back in <a href=\"https://github.com/leanprover-community/mathlib4/pull/4200\">mathlib4#4200</a> is sort of undoing the work from just a year or so ago</p>\n</blockquote>\n<p>I take this back -- I didn't look at all 56 files of changes carefully enough. Now I think every type ascription that was added are fine and justified, and this PR is a definite improvement. I'm not comfortable merging it myself though because I don't really understand what ramifications it has on the porting effort -- is there any reason not to?</p>\n<p>This <code>fbinop%</code> (or something like it) would just be nice to have, and I don't think <a href=\"https://github.com/leanprover-community/mathlib4/pull/4200\">mathlib4#4200</a> should wait for it.</p>",
        "id": 360881901,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684957159
    }
]