[
    {
        "content": "<p>I have checked the filter docs and found three lemmas, that seem to have inconsistent naming conventions and appear to be missing a lemma.</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Map.html#Filter.map_comap\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Map.html#Filter.map_comap</a><br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Map.html#Filter.comap_map\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Map.html#Filter.comap_map</a><br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Map.html#Filter.map_comap_of_surjective\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Map.html#Filter.map_comap_of_surjective</a></p>\n<p>Filter.comap_map should be called Filter.comap_map_of_injective and an unconditional Filter.comap_map should be added akin to Filter.map_comap. I'd like to add the unconditional lemma but I'm not sure what the RHS is supposed to be. Does anyone have ideas?</p>",
        "id": 554474299,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1762600071
    },
    {
        "content": "<p>The corresponding lemmas for <code>Set</code> are</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.image_preimage_eq_inter_range#doc\">docs#Set.image_preimage_eq_inter_range</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.preimage_image_eq#doc\">docs#Set.preimage_image_eq</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.image_preimage_eq#doc\">docs#Set.image_preimage_eq</a></li>\n</ul>",
        "id": 554474627,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762600433
    },
    {
        "content": "<p>If you can find the <code>Set</code> version of the filter lemma you want I will gladly help you translate it into filter</p>",
        "id": 554474695,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762600517
    },
    {
        "content": "<p>It could be that it's impossible to define in an easier way. I tried to find it in the docs but couldn't find it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">preimage_image_eq_question</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">     </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It appears that taking preimages before images is way better behaved that taking images before preimages. I tried it with sin. If you take the image of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mclose\">}</span></span></span></span> with sin you get all the multiple of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span> but there is no way to describe this fact elementary other than take the image and then the preimage. Taking preimages of a set means you can split whether an element is in the image or not. If x is in the image then it will be included by the preimage-image operation. If x is not in the image then we have to exclude it by intersecting with Set.range f.</p>\n<p>This is precisely what <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Image.html#Set.image_preimage_eq_inter_range\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Image.html#Set.image_preimage_eq_inter_range</a> states.</p>\n<p>Do I see that correctly that there can't be an elementary Set.preimage_image_eq_question because the question can't be answered in an elementary fashion? If so, that would also conclude the same result for filters.</p>\n<p><del>Well I mean technically you can look at the union of singleton sets and take the union of the preimages of those singleton sets. Not sure if that makes it any simpler. </del></p>",
        "id": 554476685,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1762602738
    },
    {
        "content": "<p>The correct statement would be that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f^{-1}(f(T))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">))</span></span></span></span> is the closure of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> under the equivalence relation induced by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></p>",
        "id": 554477988,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1762604048
    },
    {
        "content": "<p>How would I write that one down?</p>",
        "id": 554478442,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1762604533
    },
    {
        "content": "<p>I’m afraid the most concise way of saying it is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f^{-1}(f(T))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">))</span></span></span></span>.</p>",
        "id": 554479520,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1762605618
    },
    {
        "content": "<p>And I agree the names of those conditional lemmas are not great.</p>",
        "id": 554479543,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1762605638
    }
]