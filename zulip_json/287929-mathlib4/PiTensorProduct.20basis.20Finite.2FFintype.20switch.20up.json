[
    {
        "content": "<p>In the LinearAlgebra.PiTensorProduct.Basis file, a switch up between <code>[Finite Œπ]</code> and <code>[Fintype Œπ]</code> has happened. In particular, in the <code>Basis.piTensorProduct </code>and <code>Basis.piTensorProduct_repr_tprod_apply</code>.</p>\n<p>This, in turn has made the proof of <code>Basis.piTensorProduct_repr_tprod_apply</code> very long, ending with rather unusual <code>convert rfl</code>.  I can instead safely prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Basis</span><span class=\"bp\">.</span><span class=\"n\">piTensorProduct_repr_tprod_apply</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Basis</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ∫</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Œ∫</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"w\"> </span><span class=\"n\">Œπ</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Basis</span><span class=\"bp\">.</span><span class=\"n\">piTensorProduct</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tprod</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚àè</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">piTensorProduct</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>In fact, I can see the same pattern in Dual file: (dualDistrib vs dualDistrib_apply).  Can you please let me know how is beneficial to assume different instances here?</p>",
        "id": 564362353,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766016735
    },
    {
        "content": "<p>I have a shorter proof of <code>Basis.piTensorProduct_repr_tprod_apply</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Basis</span><span class=\"bp\">.</span><span class=\"n\">piTensorProduct_repr_tprod_apply</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Basis</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ∫</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Œ∫</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Basis</span><span class=\"bp\">.</span><span class=\"n\">piTensorProduct</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tprod</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚àè</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">piTensorProduct</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Äπ_‚Ä∫</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 564365625,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766019233
    },
    {
        "content": "<p>fits in the file</p>",
        "id": 564365651,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766019250
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/33023\">#33023</a></p>",
        "id": 564365942,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766019514
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> , well my problem is not the long proof per se, but the switch up itself. What is its purpose? In particular, what problem does it address?</p>",
        "id": 564366612,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766020088
    },
    {
        "content": "<p>ask the author maybe?</p>",
        "id": 564366694,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766020176
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"622397\">@Daniel Morrison</span></p>",
        "id": 564366727,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766020208
    },
    {
        "content": "<p>the relevant PR is <a href=\"https://github.com/leanprover-community/mathlib4/pull/32613\">#32613</a></p>",
        "id": 564366772,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766020247
    },
    {
        "content": "<p>Yeah that theorem looks bad: probably <code>[Fintype Œπ]</code> is the right assumption if you need it to make the theorem statement compile. Of course a better fix would be to fix things so that you didn't need Fintype to make the statement compile, but still...</p>",
        "id": 564366877,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1766020358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564366694\">said</a>:</p>\n<blockquote>\n<p>ask the author maybe?</p>\n</blockquote>\n<p>I thought I am missing something very obvious. As an end-user it either forces me two create two instances, or to construct one instance from another which is painful.</p>",
        "id": 564366924,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766020403
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"900949\">Paradoxy</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564362353\">said</a>:</p>\n<blockquote>\n<p>In fact, I can see the same pattern in Dual file: (dualDistrib vs dualDistrib_apply).</p>\n</blockquote>\n<p>Oh no, that sounds bad</p>",
        "id": 564367149,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766020596
    },
    {
        "content": "<p>The switch was suggested in review to avoid propagating the <code>Fintype</code> instance and continuing to require decidability. I think the idea is that <code>Finite</code> is the better one to use long term and is capping off the decidability conditions there. So short term its harder to use but long term this way is better. It doesn't really matter to me and I had initially just used <code>Fintype</code> since that was what was there. I was also reviving old work that never got merged so tbh I mainly used what other people had used or recommended.</p>",
        "id": 564367168,
        "sender_full_name": "Daniel Morrison",
        "timestamp": 1766020617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564367149\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"900949\">Paradoxy</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564362353\">said</a>:</p>\n<blockquote>\n<p>In fact, I can see the same pattern in Dual file: (dualDistrib vs dualDistrib_apply).</p>\n</blockquote>\n<p>Oh no, that sounds bad</p>\n</blockquote>\n<p>Wait no I misunderstood what you were saying, <code>dualDistrib_apply</code> is fine.</p>",
        "id": 564367233,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766020658
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564367233\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564367149\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"900949\">Paradoxy</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564362353\">said</a>:</p>\n<blockquote>\n<p>In fact, I can see the same pattern in Dual file: (dualDistrib vs dualDistrib_apply).</p>\n</blockquote>\n<p>Oh no, that sounds bad</p>\n</blockquote>\n<p>Wait no I misunderstood what you were saying, <code>dualDistrib_apply</code> is fine.</p>\n</blockquote>\n<p>How is it fine? dualDistrib uses Finite instance, dualDistrib_apply uses Fintype instance. Also in the proof of dualDistrib_apply we again have convert rfl. I mean sure, one can fix it by rewriting instances, but the design decision itself is something that I cannot understand.</p>",
        "id": 564367300,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766020737
    },
    {
        "content": "<p>the idea is that we want to use the lemma to rewrite into whatever <code>Fintype</code> instance we have lying around, not just <code>Fintype.ofFinite</code>.</p>",
        "id": 564367362,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766020796
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span>  then why can't we define dualDistrib with Fintype instance in the first place?</p>",
        "id": 564367450,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766020864
    },
    {
        "content": "<p>we can definitely do that</p>",
        "id": 564367464,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766020878
    },
    {
        "content": "<p>this is where I ask the author why didn't you do that</p>",
        "id": 564367478,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766020896
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"622397\">Daniel Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564367168\">said</a>:</p>\n<blockquote>\n<p>The switch was suggested in review to avoid propagating the <code>Fintype</code> instance and continuing to require decidability. I think the idea is that <code>Finite</code> is the better one to use long term and is capping off the decidability conditions there. So short term its harder to use but long term this way is better. It doesn't really matter to me and I had initially just used <code>Fintype</code> since that was what was there. I was also reviving old work that never got merged so tbh I mainly used what other people had used or recommended.</p>\n</blockquote>\n<p>Hmm, I see classical instances are being used in both definitions and theorems with either <code>open Classical in</code> or <code>classical</code> tactic. So decidableEq instances are provided for free. What other decidability instance exists here?</p>",
        "id": 564367587,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766021020
    },
    {
        "content": "<p>My understanding is that right now some basic parts of the API for these kinds of things, like finite sums, is written in terms of <code>Fintype</code> and using <code>DecidableEq</code> when they technically shouldn't require anything more than <code>Finite</code>. So at the moment <code>Fintype</code> and <code>DecidableEq</code> is an implicit requirement in lots of these structures when it probably shouldn't be long term. These are written in an awkward way to try to cut off that propagation of instances so future stuff can be build on top of it only using <code>Finite</code>. My understanding is the long term plan is to move everything over to <code>Finite</code>, and making the switch here can hopefully cut down the amount of stuff that needs to be rewritten in the future.</p>\n<p>Like I said, this was suggested in review and I'm not really an expert on these kinds of issues and had initially written the PR using <code>Fintype</code> and <code>DecidableEq</code> for exactly the reason you are saying. Perhaps <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> can explain more. But the short answer is that I guess there are long-term design goals at play that make some short-term additions a bit strange.</p>",
        "id": 564368383,
        "sender_full_name": "Daniel Morrison",
        "timestamp": 1766021704
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"622397\">@Daniel Morrison</span>,  <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> <br>\nI think with <code>haveI := Fintype.ofFinite Œπ</code> instance (as already used in <code>dualDistrib</code>), we can change all theorems to require only <code>Finite</code> and not a <code>Fintype</code>. This also simplifies some proofs, like the one I wrote in my first post.  In future, when other parts of library are re-written with <code>Finite</code>, we can just remove <code>haveI := Fintype.ofFinite Œπ</code> line from all theorems.</p>",
        "id": 564368761,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766022129
    },
    {
        "content": "<p>I really hope we don't get rid of <code>Fintype</code></p>",
        "id": 564368845,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766022231
    },
    {
        "content": "<p>There are probably ways to clean up some of the instance switching and if you do feel free to make changes. I added these as a part of reviving older work moving toward exterior powers so if you want to spend more time on the Multilinear stuff feel free!</p>",
        "id": 564369437,
        "sender_full_name": "Daniel Morrison",
        "timestamp": 1766022832
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"900949\">@Paradoxy</span> Here's an example of why we don't want to author lemmas using <code>haveI := Fintype.ofFinite Œπ</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">myMax</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚®Ü</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span>\n\n<span class=\"c1\">-- Good</span>\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">myMax_eq</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">myMax</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Finset.sup</span><span class=\"w\"> </span><span class=\"n\">Finset.univ</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Finset.sup_univ_eq_ciSup</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"c1\">-- Bad</span>\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">myMax_eq'</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype.ofFinite</span><span class=\"w\"> </span><span class=\"n\">Œπ</span>\n<span class=\"w\">    </span><span class=\"n\">myMax</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Finset.sup</span><span class=\"w\"> </span><span class=\"n\">Finset.univ</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset.sup_univ_eq_ciSup</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">myMax</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Finset.sup</span><span class=\"w\"> </span><span class=\"n\">Finset.univ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">myMax_eq'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Fails üò±</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">myMax</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Finset.sup</span><span class=\"w\"> </span><span class=\"n\">Finset.univ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">myMax_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Succeeds</span>\n</code></pre></div>",
        "id": 564433830,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1766056663
    },
    {
        "content": "<p>The point is that if you use <code>haveI := Fintype.ofFinite Œπ</code> to make your lemma statement, then your lemma is a lemma <em>about this instance</em> but <code>Fintype</code> contains data and so your lemma may fail to apply in situations where a different <code>Fintype</code> instance has been provided.</p>",
        "id": 564434251,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1766056779
    },
    {
        "content": "<p>The issue is that <code>Fintype</code> tells us <em>how</em> a type is finite (analogous to a chosen numbering of its elements) whereas <code>Finite</code> merely tells us <em>that</em> a type is finite and there is a choice of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">!</mo></mrow><annotation encoding=\"application/x-tex\">n!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span></span></span></span> ways for describing how something is finite.</p>",
        "id": 564434873,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1766056981
    },
    {
        "content": "<p>The advantage of <code>Fintype</code> is that it is computable. The disadvantage is the diamond issue. In many circumstances in Mathlib, computability is irrelevant and so we are slowly changing things so that statements can be built using only <code>Finite</code> rather than <code>Fintype</code>.</p>\n<p>For example if <code>Finset.sup</code> demanded <code>[Finite Œπ]</code> rather than <code>[Fintype Œπ]</code> then the issue would not arise.</p>",
        "id": 564435113,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1766057073
    },
    {
        "content": "<p>This question comes up again and again (as does its <code>DecidableEq</code> variant) we should probably write a blog post about this, which starts with a cheat sheet for newcomers.</p>",
        "id": 564435206,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1766057111
    },
    {
        "content": "<p>Or we could just fix it by making a nonconstructive finsupp and then ripping finsupp out of tensor products and group cohomology (where constructivity has found 0 uses so far)</p>",
        "id": 564436405,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1766057507
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> </p>\n<p>So is this preferred?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Dual</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">dualDistrib</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚®Ç‚Çú</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚®Ç‚Çú</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Error: because Finset.prod univ requires Fintype</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚àè</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"c1\">-- Super ugly</span>\n<span class=\"w\">  </span><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"w\"> </span><span class=\"n\">Œπ</span>\n<span class=\"w\">  </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚àè</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"w\"> </span><span class=\"n\">Œπ</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">test</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dualDistrib_apply</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"c1\">-- Works, but now Œπ is assumed to be both Finite and Fintype!</span>\n<span class=\"w\">  </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚àè</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">test</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dualDistrib_apply</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The situation above is avoidable by assuming <code>[Fintype Œπ]</code> from the beginning. But if we are going to use <code>[Fintype Œπ]</code> anyways, then we might as well define <code>dualDistrib</code> with <code>Fintype</code>. Not only does it make all relevant proofs much easier, but also if the computability is concerned, it should be formalized with the <code>Fintype</code> in the first place as you said (same logic / example can be applied to basis file).</p>",
        "id": 564466611,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766066520
    },
    {
        "content": "<p>I can only write a very brief message because I‚Äôm at a Christmas lunch but <code>Finite</code> for definitions and <code>Fintype</code> for lemmas whose statement requires it is approximately the rule.</p>",
        "id": 564479010,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1766069368
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"900949\">@Paradoxy</span> you can <code>omit [Finite \\iota] in</code> before that example.</p>",
        "id": 564497312,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1766073338
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564497312\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"900949\">Paradoxy</span> you can <code>omit [Finite \\iota] in</code> before that example.</p>\n</blockquote>\n<p>As an end user, I cannot fix \\iota to be a specific type, I have to keep it generic. With this restriction, what makes sense to me is to either assume Finite \\iota or Fintype \\iota and develop the rest of library based on that. What I would not like to do is to assume Finite \\iota at the beginning and then use Fintype \\iota whenever I get stuck, like in that example. </p>\n<p>Just like <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span>  said, the purpose of Fintype is to make things computable. To begin with, <code>dualDistrib</code> is made noncomputable by opening classical. Would it not better to make all corresponding lemmas require Finite as well? In my original post, I have provided this lemma as an example. If the end user has a Fintype, then it is their responsibility to make a Finite instance for it to use this part of library. Alternatively, if everything is Fintype based no issue would arise as well. It is this mixture that makes things hard.</p>",
        "id": 564521634,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766079188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"900949\">Paradoxy</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564521634\">said</a>:</p>\n<blockquote>\n<p>As an end user, I cannot fix \\iota to be a specific type, I have to keep it generic. With this restriction, what makes sense to me is to either assume Finite \\iota or Fintype \\iota and develop the rest of library based on that.</p>\n</blockquote>\n<p>I don't follow this claim. <code>Fintype</code> implies <code>Finite</code>. So just like with other theorems, you try to weaken your hyps and strengthen your conclusions where possible. So for the definition of <code>test</code> you only need <code>Finite</code>. But then you relate it to a <code>Finset.prod univ</code> which require <code>Fintype</code>, so for that result you assume <code>Fintype</code>.</p>\n<p>You might argue that <code>Finset.prod univ</code> should only require <code>Finite</code>. But that is a separate discussion.</p>",
        "id": 564532348,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1766082500
    },
    {
        "content": "<p>Interesting conversation. Thanks everybody.</p>\n<p>Let me try my hand at a lurker's summary.</p>\n<p>There's competing visions about the long-term role of constructivism in the library, though \"less of that\" seems to command a majority. But however things might be in the future, for now, there's plenty of code that requires [Fintype] instances. The recommendation is to \"contain further spread\" of Fintype, by having new definitions depend on [Finite]. Necessarily this will lead to some boilerplate code when crossing the boundary from Finite to Fintype (see Daniel's code post-review). This isn't perfect, but generally seen as an acceptable way of handling the present situation. Finally, lemmas that expose the existing Fintype API should take the instance as an argument, rather than creating it locally, to avoid diamonds, as demonstrated by Oliver.</p>\n<p>If I got this very wrong, then <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> , I'd be <em>very</em> much looking forward to that blog post. <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 564571135,
        "sender_full_name": "David Gross",
        "timestamp": 1766093574
    },
    {
        "content": "<p>Thanks David, this captures my thoughts on this matter extremely well!</p>",
        "id": 564637378,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1766131114
    },
    {
        "content": "<p>I think for new definitions, it should be considered on a case-by-case basis, whether the computational aspects of <code>Fintype</code> over <code>Finite</code> are useful.<br>\nBut certainly, one lesson that we didn't appreciate N years ago, but that we are well aware of now, is: if only a proof needs <code>Fintype</code>, but the statement doesn't, then the assumption should be <code>Finite</code>, and it should upgrade to <code>Fintype</code> in the proof.</p>",
        "id": 564639162,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1766131844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564436405\">said</a>:</p>\n<blockquote>\n<p>Or we could just fix it by making a nonconstructive finsupp and then ripping finsupp out of tensor products and group cohomology (where constructivity has found 0 uses so far)</p>\n</blockquote>\n<p>Note that Finsupp is already nonconstructive, and this is explicitly mentioned here: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finsupp/Defs.html#Implementation-notes\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finsupp/Defs.html#Implementation-notes</a></p>",
        "id": 564754400,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1766168480
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564639162\">said</a>:</p>\n<blockquote>\n<p>I think for new definitions, it should be considered on a case-by-case basis, whether the computational aspects of <code>Fintype</code> over <code>Finite</code> are useful.<br>\nBut certainly, one lesson that we didn't appreciate N years ago, but that we are well aware of now, is: if only a proof needs <code>Fintype</code>, but the statement doesn't, then the assumption should be <code>Finite</code>, and it should upgrade to <code>Fintype</code> in the proof.</p>\n</blockquote>\n<p>Neither of Basis.piTensorProduct, ofFinsuppEquiv, or ofDFinsuppEquiv require Fintype in the statement. However, only Basis.piTensorProduct requires Finite in the signature and upgrade it to Fintype in its proof. Both ofFinsuppEquiv and ofDFinsuppEquiv require Fintype in their signature as opposed to Finite. (The only use of ofFinsuppEquiv / ofDFinsuppEquiv  is in Basis.piTensorProduct currently). Can you please tell me what makes ofFinsuppEquiv and ofDFinsuppEquiv  exceptional?</p>\n<p>On the other hand, the reason the current lemmas require Fintype in the statement itself is the use of BigOperators like <code>Finset.prod</code>. <code>\\Prod i</code> is understood as product over <code>Finset.univ i</code>and <code>Finset.univ i</code> requires <code>Fintype</code>. However, one can define </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">univ'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n<span class=\"w\">  </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span>\n</code></pre></div>\n<p>and take product over <code>Finset.univ' </code>. This way, one would not need <code>Fintype</code> in the statement of the lemmas anymore. Sorry if I am misunderstanding. But still I cannot see why everything is not <code>Finite</code> based when computability is of no concern.</p>",
        "id": 564773718,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766177337
    },
    {
        "content": "<p>You will have to replace <code>Finset.univ</code> with <code>Finset.univ'</code> everywhere or this discrepancy will just show up somewhere else.</p>",
        "id": 564775037,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766178044
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564775037\">said</a>:</p>\n<blockquote>\n<p>You will have to replace <code>Finset.univ</code> with <code>Finset.univ'</code> everywhere or this discrepancy will just show up somewhere else.</p>\n</blockquote>\n<p>Why do we need to change it everywhere? Some places may actually want computable definitions. I imagine both <code>univ</code> and <code>univ'</code> can coexists, they are also propositionally equal.</p>",
        "id": 564775621,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766178350
    },
    {
        "content": "<p>Then you will need to switch between them in proofs if you want to use theorems stated about both of them. And this will still amount to the same yoga that you are asking about here.</p>",
        "id": 564775924,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766178535
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564775924\">said</a>:</p>\n<blockquote>\n<p>Then you will need to switch between them in proofs if you want to use theorems stated about both of them? And this will still amount to the same yoga that you are asking about here.</p>\n</blockquote>\n<p>I am not sure if I am following. I can prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">univ'_eq_univ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">univ'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">¬† </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">univ'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Äπ_‚Ä∫</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Now, if I state all relevant lemmas of PiTensorProduct files with <code>Finset.univ' </code> and only <code>Finite</code> in the signature, I can simply do a simp inside the proof to get the usual univ lemmas. What is the extra work here?</p>",
        "id": 564776731,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766179015
    },
    {
        "content": "<p>The extra work is the use of <code>univ'_eq_univ</code>.</p>",
        "id": 564777032,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766179215
    },
    {
        "content": "<p>By containing the \"univ'_eq_univ\" problem locally in the proof of these lemmas, you avoid asking users to do this in downstream applications.</p>",
        "id": 564777172,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766179303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564777032\">said</a>:</p>\n<blockquote>\n<p>The extra work is the use of <code>univ'_eq_univ</code>.</p>\n</blockquote>\n<p>Is it not marginally better to have a unified Finite based lemmas/defs at the cost of this single extra lemma?</p>",
        "id": 564777351,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766179406
    },
    {
        "content": "<p>The cost is not \"having this lemma\", but requiring users to rewrite back and forth with this lemma when you can just avoid this problem by stating your lemmas more generally.</p>",
        "id": 564777546,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766179516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564777546\">said</a>:</p>\n<blockquote>\n<p>The cost is not \"having this lemma\", but requiring users to rewrite back and forth with this lemma when you can just avoid this problem by stating your lemmas more generally.</p>\n</blockquote>\n<p>I believe a lemma based on Finite is more general than the current lemmas based on Fintype. Fintype imlplies Finite, but not the otherway around. So a user who uses a Finite type cannot apply the current Fintype based lemmas. But a user that uses Fintype, may use the lemmas I am suggesting. But yes, it will come at the cost of using <code>univ'_eq_univ</code>.</p>",
        "id": 564777908,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766179738
    },
    {
        "content": "<p>the argument is that it's not as expensive to just write <code>have := Fintype.ofFinite E</code> when you need it than to have another definition</p>",
        "id": 564778101,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766179870
    },
    {
        "content": "<p>The point is that a user who uses a <code>Finite</code> type cannot possibly even write down the statement so this is not a concern. If it is possible for a user with only a <code>Finite</code> assumption to write down a hypothesis then yes you should use <code>Finite</code> in the <code>theorem</code>.</p>",
        "id": 564778145,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766179905
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564778101\">said</a>:</p>\n<blockquote>\n<p>the argument is that it's not as expensive to just write <code>have := Fintype.ofFinite E</code> when you need it than to have another definition</p>\n</blockquote>\n<p>Well I wish it was just <code>have := Fintype.ofFinite E</code>. But in practice one needs to deal with diamonds, like the PR you commented at the beginning of the current thread. <code>univ'_eq_univ</code> on the other hand, takes care of diamonds by itself.  </p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <br>\nThe point is that a user who uses a <code>Finite</code> type cannot possibly even write down the statement so this is not a concern. If it is possible for a user with only a <code>Finite</code> assumption to write down a hypothesis then yes you should use <code>Finite</code> in the <code>theorem</code>.</p>\n</blockquote>\n<p>Well, I can write the statements of relevant lemmas with univ', since it only requires Finite.</p>",
        "id": 564778813,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766180272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"900949\">Paradoxy</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564778813\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564778101\">said</a>:</p>\n<blockquote>\n<p>the argument is that it's not as expensive to just write <code>have := Fintype.ofFinite E</code> when you need it than to have another definition</p>\n</blockquote>\n<p>Well I wish it was just <code>have := Fintype.ofFinite E</code>. But in practice one needs to deal with diamonds, like the PR you commented at the beginning of the current thread.</p>\n</blockquote>\n<p>The argument is that if you <code>have := Fintype.ofFinite E</code>, then that implies there is no diamonds, since you have no <code>Fintype</code> instance in scope</p>",
        "id": 564779044,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766180419
    },
    {
        "content": "<blockquote>\n<p>Fintype imlplies Finite, but not the otherway around.</p>\n</blockquote>\n<p>The correct picture is that there is a surjection (up-to-defeq) <code>Fintype I -&gt; Finite I</code> and a section <code>Fintype.ofFinite : Finite I -&gt; Fintype I</code>. Rather than stating theorems about the range of <code>Fintype.ofFinite</code>, you should state theorems about an arbitrary <code>Fintype I</code>. In this sense, theorems about <code>Fintype.ofFinite</code> are less general than theorems about arbitrary fintypes.</p>",
        "id": 564779207,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766180543
    },
    {
        "content": "<blockquote>\n<p>But in practice one needs to deal with diamonds, like the PR you commented at the beginning of the current thread.</p>\n</blockquote>\n<p>A key point is that this messyness is self-contained. You don't need to worry about these when you are just using the API. On the contrary your <code>univ'</code> trick requires users of the API to also be aware of these nastiness and need to work around it.</p>",
        "id": 564779605,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766180807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564779207\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Fintype imlplies Finite, but not the otherway around.</p>\n</blockquote>\n<p>The correct picture is that there is a surjection (up-to-defeq) <code>f : Fintype I -&gt; Finite I</code> and a section <code>Fintype.ofFinite : Finite I -&gt; Fintype I</code>. Rather than stating theorems about the range of <code>Fintype.ofFinite</code>, you should state theorems about an arbitrary <code>Fintype I</code>. In this sense, theorems about <code>Fintype.ofFinite</code> are less general than theorems about arbitrary fintypes.</p>\n</blockquote>\n<p>Yes, this much I understood from yesterday's conversation. So I tried to use univ' to avoid the need of <code>have := Fintype.ofFinite E</code> in the statement of the lemma, which makes it less general and limited to a particular Fintype instance. </p>\n<p>Now, I have a purely Finite based lemma, that never uses <code>have := Fintype.ofFinite E</code>in the statement but has a univ' in its statement will be used as follows:</p>\n<p>If the end user have <code>Finite</code> type, when they apply my lemma, in their proof they get a univ'. If they like, they can make <code>have := Fintype.ofFinite E</code> first, and then apply the lemma, automatically <code>univ'_eq_univ</code> will be also applied, so they get a normal product.</p>\n<p>For the end user who have <code>Fintype</code>, once they apply the lemma, `univ'_eq_univ will be also applied, so they also get a normal product. No diamonds, defeq abuse, etc would happen.</p>",
        "id": 564779749,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766180876
    },
    {
        "content": "<p>There are also no diamonds, defeq abuse, etc happening for downstream users in this current setup.</p>",
        "id": 564779852,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766180946
    },
    {
        "content": "<p>Okay I maybe get some of your point now. In the titular lemma, only the RHS requires <code>Fintype</code>, but when using it as a simp lemma you might want it to fire even if you haven't upgraded your <code>Finite</code> to a <code>Fintype</code> yet.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">Basis</span><span class=\"bp\">.</span><span class=\"n\">piTensorProduct</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tprod</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚àè</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 564780131,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766181113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564779852\">said</a>:</p>\n<blockquote>\n<p>There are also no diamonds, defeq abuse, etc happening for downstream users in this current setup.</p>\n</blockquote>\n<p>Diamonds do not happen for the end-users in either of two setups. But it does happen for API developers. For example in this PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/33023\">33023</a> relevant to Basis file, a diamond is addressed by  rw [Subsingleton.elim (Fintype.ofFinite Œπ) ‚Äπ_‚Ä∫]. Now, following the current rule of keeping definitions Finite and theorems Fintype when needed means, constantly doing rw [Subsingleton.elim (Fintype.ofFinite Œπ) ‚Äπ_‚Ä∫]. Whereas the existence of univ' somehow addresses the problem. Even though, it is very ugly indeed.</p>",
        "id": 564780544,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766181366
    },
    {
        "content": "<p>If you have <code>univ'</code> you now have to duplicate all the lemmas about <code>univ</code></p>",
        "id": 564780737,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766181491
    },
    {
        "content": "<p>I don't think it \"addresses the problem\". It is still the same problem but you add <code>Finset.univ'_eq_univ</code> instead of <code>Subsingleton.elim (Fintype.ofFinite Œπ) ‚Äπ_‚Ä∫</code> to the simp lemmas, which is basically the same thing to me.</p>",
        "id": 564780945,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766181622
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564780131\">said</a>:</p>\n<blockquote>\n<p>Okay I maybe get some of your point now. In the titular lemma, only the RHS requires <code>Fintype</code>, but when using it as a simp lemma you might want it to fire even if you haven't upgraded your <code>Finite</code> to a <code>Fintype</code> yet.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">Basis</span><span class=\"bp\">.</span><span class=\"n\">piTensorProduct</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tprod</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚àè</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>But back to this point which I am now sympathetic to, I guess the point is that if you state it in terms of <code>Finite</code>, then this is a \"weaker lemma\", but a \"stronger simp lemma\". So then the question becomes: do we care about this extra strength? If so maybe we could have a <code>Finite</code> form as a simp lemma, i.e.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Basis</span><span class=\"bp\">.</span><span class=\"n\">piTensorProduct_repr_tprod_apply</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Basis</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ∫</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Œ∫</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Basis</span><span class=\"bp\">.</span><span class=\"n\">piTensorProduct</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tprod</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"bp\">‚àè</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">piTensorProduct</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and keep the old one without a simp tag.</p>",
        "id": 564781397,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766181865
    },
    {
        "content": "<p>does this do anything though?</p>",
        "id": 564781474,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766181905
    },
    {
        "content": "<p>I feel like for this to be really useful you have to have that product on the rhs simplify further</p>",
        "id": 564781525,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766181927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564780737\">said</a>:</p>\n<blockquote>\n<p>If you have <code>univ'</code> you now have to duplicate all the lemmas about <code>univ</code></p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564780945\">said</a>:</p>\n<blockquote>\n<p>I don't think it \"addresses the problem\". It is still the same problem but you add <code>Finset.univ'_eq_univ</code> instead of <code>Subsingleton.elim (Fintype.ofFinite Œπ) ‚Äπ_‚Ä∫</code> to the simp lemmas, which is basically the same thing to me.</p>\n</blockquote>\n<p>Fair enough. But if the plan is to migrating to Finite, and avoiding Fintype whenever possible, is it not the starting point anyways? For every definition with Finite we have several Fintype lemmas. At least the evil I am suggesting makes all lemmas Finite based too, less lemmas will be polluted by Fintype. But the current plan of mixing Finite with Fintype, well, I cannot see how it is helpful in this migration.</p>",
        "id": 564781686,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766182010
    },
    {
        "content": "<p>and the fintype prod lemmas have <code>[Fintype Œ±]</code> as assumption so they won't fire</p>",
        "id": 564781736,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766182031
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PiTensorProduct.20basis.20Finite.2FFintype.20switch.20up/near/564781397\">said</a>:</p>\n<blockquote>\n<p>&gt; </p>\n<p>But back to this point which I am now sympathetic to, I guess the point is that if you state it in terms of <code>Finite</code>, then this is a \"weaker lemma\", but a \"stronger simp lemma\". So then the question becomes: do we care about this extra strength? If so maybe we could have a <code>Finite</code> form as a simp lemma, i.e.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Basis</span><span class=\"bp\">.</span><span class=\"n\">piTensorProduct_repr_tprod_apply</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Basis</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ∫</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Œ†</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Œ∫</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Basis</span><span class=\"bp\">.</span><span class=\"n\">piTensorProduct</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tprod</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">haveI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"bp\">‚àè</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">piTensorProduct</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and keep the old one without a simp tag.</p>\n</blockquote>\n<p>Well this one is not good, as you said, it won't fire for arbitrary Fintypes. univ' solution though does fire, and will be simplified further by <code>univ'_eq_univ</code></p>",
        "id": 564781933,
        "sender_full_name": "Paradoxy",
        "timestamp": 1766182152
    },
    {
        "content": "<blockquote>\n<p>But if the plan is to migrating to Finite, and avoiding Fintype whenever possible, is it not the starting point anyways?</p>\n</blockquote>\n<p>I'm not sure if there is such a plan. We are avoiding <code>Fintype</code> whenever unnecessary, but I think the current consensus is to deem <code>Fintype</code> appearing in <code>Finset.prod</code> as necessary.</p>",
        "id": 564782017,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766182203
    },
    {
        "content": "<blockquote>\n<p>Well this one is not good, as you said, it won't fire for arbitrary Fintypes. univ' solution though does fire, and will be simplified further by¬†<code>univ'_eq_univ</code></p>\n</blockquote>\n<p>No it does fire because the LHS does not contain <code>Fintype.ofFinite Œπ</code>. But I'm also not saying it is good. I'm just saying it might not be totally out of the picture.</p>",
        "id": 564782149,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766182273
    },
    {
        "content": "<p>Also <code>Subsingleton.elim (Fintype.ofFinite Œπ) ‚Äπ_‚Ä∫</code> probably is a good idea as a simproc.</p>",
        "id": 564782254,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766182328
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"900949\">@Paradoxy</span> You might hear people say \"Mathlib does not care about computability\" as some sort of slogan. But with these short slogans, there are usually footnotes. For something like <code>Finset.prod</code> we do care about computability. At least until there is a tactic that takes over all the finite computations that the kernel currently does for us.<br>\nWe just care much much less about computability than other formalization efforts.</p>",
        "id": 564806850,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1766212361
    }
]