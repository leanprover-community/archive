[
    {
        "content": "<p>I'm currently porting <code>Algebra.Ring.Prod</code>which starts of with a giant header of declarations of this style:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Product of two distributive types is distributive. -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Distrib</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Distrib</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Distrib</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">×</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">Prod.hasAdd</span><span class=\"o\">,</span> <span class=\"n\">Prod.hasMul</span> <span class=\"k\">with</span>\n    <span class=\"n\">left_distrib</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mk.inj_iff.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">left_distrib</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">left_distrib</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">right_distrib</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mk.inj_iff.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">right_distrib</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">right_distrib</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Product of two `non_unital_non_assoc_semiring`s is a `non_unital_non_assoc_semiring`. -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">NonUnitalNonAssocSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NonUnitalNonAssocSemiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">NonUnitalNonAssocSemiring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">×</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">Prod.addCommMonoid</span><span class=\"o\">,</span> <span class=\"n\">Prod.mulZeroClass</span><span class=\"o\">,</span> <span class=\"n\">Prod.distrib</span> <span class=\"k\">with</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Product of two `non_unital_semiring`s is a `non_unital_semiring`. -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">NonUnitalSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NonUnitalSemiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">NonUnitalSemiring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">×</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">Prod.nonUnitalNonAssocSemiring</span><span class=\"o\">,</span> <span class=\"n\">Prod.semigroup</span> <span class=\"k\">with</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>I'm assuming Lean 3 had some unhygienic instance naming mechanism that made this type of stuff possible? How am I supposed to deal with it in the port, I guess I could just move through the responsible prod files and make the names explicit but having an explicit <code>nonUnitalNonAssocSemiring</code> seems a little over the top?</p>",
        "id": 317987860,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1672076720
    },
    {
        "content": "<p>Use inferInstanceAs?</p>",
        "id": 317989201,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1672077619
    },
    {
        "content": "<p>Lean 4 also has implicit instance names, but they're even longer. We've not settled on a preferred approach yet</p>",
        "id": 317991073,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1672078719
    },
    {
        "content": "<p>yeah, instance names are not hygienic (unless you declare them in a macro, but that's probably an issue of its own)</p>",
        "id": 317991830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672079201
    },
    {
        "content": "<p>You can also drop some (sometimes all) dependencies and let Lean automatically find projections from existing instances.</p>",
        "id": 317994072,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1672080823
    },
    {
        "content": "<p>In the port of Algebra.Ring.Pi we just give explicit names to all the instances</p>",
        "id": 318012314,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1672094648
    },
    {
        "content": "<p>I think we should do the same for Prod</p>",
        "id": 318012324,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1672094656
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/instance.20names/near/317991830\">said</a>:</p>\n<blockquote>\n<p>yeah, instance names are not hygienic (unless you declare them in a macro, but that's probably an issue of its own)</p>\n</blockquote>\n<p>They're actively anti-hygienic, even when you have the instance command in a macro.  If you give the instance command accessible names, then it will generate an accessible inaccessible instance name:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span>\n<span class=\"n\">macro</span> <span class=\"s2\">\"foo_inst\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨⟩⟩)</span>\n<span class=\"n\">foo_inst</span>\n<span class=\"k\">#check</span> <span class=\"n\">instNonemptyFoo</span> <span class=\"c1\">-- works (no comment on the prettiness/usefulness of the name)</span>\n</code></pre></div>\n<p>That seems reasonable enough.  But the automatically generated name will always be accessible, even if the names contain macro scopes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"bar_inst\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">structure</span> <span class=\"n\">Bar</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"n\">Bar</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨⟩⟩)</span>\n<span class=\"n\">bar_inst</span>\n<span class=\"k\">#check</span> <span class=\"n\">instNonemptyBar</span> <span class=\"c1\">-- works too ?!?</span>\n</code></pre></div>",
        "id": 318013546,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1672095517
    },
    {
        "content": "<p>I assume the instance is hygienic if you actually give it a name though like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Foo</span>\n<span class=\"n\">macro</span> <span class=\"s2\">\"foo_inst\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">instance</span> <span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨⟩⟩)</span>\n<span class=\"n\">foo_inst</span>\n</code></pre></div>",
        "id": 318014605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1672096402
    },
    {
        "content": "<p>Yes, of course.  That's the same as <code>@[instance] def</code>.</p>",
        "id": 318019774,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1672101550
    },
    {
        "content": "<p>What \"hygienic\" means in this context?</p>",
        "id": 318035315,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1672116832
    },
    {
        "content": "<p>\"Hygienic\" means that you can only access it from the the same macro scope where you defined it.  Or put differently, if you have two macros that generate the same name, it won't clash.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"foo\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">def</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">42</span>\n    <span class=\"k\">#print</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"n\">foo</span> <span class=\"c1\">-- 42</span>\n<span class=\"n\">foo</span> <span class=\"c1\">-- 42</span>\n<span class=\"k\">#print</span> <span class=\"n\">n</span> <span class=\"c1\">-- unknown constant n</span>\n</code></pre></div>",
        "id": 318038470,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1672119747
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/287929-mathlib4/topic/instance.20names/near/317991073\">said</a>:</p>\n<blockquote>\n<p>Lean 4 also has implicit instance names, but they're even longer. We've not settled on a preferred approach yet</p>\n</blockquote>\n<p>Any news on that front? <a href=\"/user_uploads/3121/-dWSYUPXIfbAaKYpz-mtvWAk/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/-dWSYUPXIfbAaKYpz-mtvWAk/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/-dWSYUPXIfbAaKYpz-mtvWAk/image.png\"></a></div>",
        "id": 343529245,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1679436030
    },
    {
        "content": "<p>Can we have a <code>mathlib_instance</code> keyword that uses the old naming heuristic? These long names aren't helpful when debugging typeclass diamonds</p>",
        "id": 343530303,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679436476
    },
    {
        "content": "<p>I recently made a (now-merged) PR that added manual names to a lot of <code>Prod</code> algebra instances, because the generated names were so mangled they were actively misleading!</p>",
        "id": 343530748,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679436708
    },
    {
        "content": "<p>An \"unnamed instance\" lint would also be helpful...</p>",
        "id": 343552430,
        "sender_full_name": "Arien Malec",
        "timestamp": 1679446406
    },
    {
        "content": "<p>Something to consider here; In lean3 <code>instance some_name : some_class</code> was the same as <code>@[instance] protected some_name : some_class</code>.  In lean4, it seems the result is no longer <code>protected</code>...</p>",
        "id": 343642929,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679483327
    },
    {
        "content": "<p>If we add <code>mathlib_instance</code>, then it should make the definition <code>protected</code>.</p>",
        "id": 344704144,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1679857383
    },
    {
        "content": "<p>It's easy to get a list of all the <code>X.Y.instZ</code> declarations in mathlib4. How about we just go through and give them sensible names?</p>",
        "id": 344794969,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679905694
    },
    {
        "content": "<p>We could additionally have a linter that forbids giant names under <code>Mathlib.</code>.</p>",
        "id": 344795119,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679905733
    },
    {
        "content": "<p>By \"under <code>Mathlib.</code>\" I assume you mean \"in files under <code>Mathlib/</code>\" as opposed to \"in namespaces under <code>Mathlib.</code>\"</p>",
        "id": 344818092,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679911827
    },
    {
        "content": "<p>Yes</p>",
        "id": 344818182,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679911845
    },
    {
        "content": "<p>The relevant code for looking up where a declaration is defined treats the module as a <code>Name</code>, so you get the dot-separated names you'd use to import the file. Hence <code>Mathlib.</code>.</p>",
        "id": 344818409,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679911917
    },
    {
        "content": "<p>Okay <a href=\"https://github.com/leanprover-community/mathlib4/pull/3122\">!4#3122</a> adds commands <code>#long_instances</code>, which shows you instances with excessively long names, grouped according to the file they are in. It also begins cleaning up some of the &gt;80 character names!</p>",
        "id": 344825253,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679913763
    },
    {
        "content": "<p>Before we <del>start</del> expend much more effort manually naming everything; which convention do we prefer?</p>",
        "id": 344827598,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679914391
    },
    {
        "content": "<p>/poll What names should we pick for instances?</p>\n<ul>\n<li><code>MyType.fooBar</code> for <code>FooBar MyType</code>, to match what we did in Lean 3</li>\n<li><code>MyType.instFooBar</code> for <code>FooBar MyType</code>, to match what Lean 4 does automatically</li>\n</ul>",
        "id": 344827837,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679914442
    },
    {
        "content": "<p>One argument for the latter is that after dropping the <code>has</code> prefix on typeclass names, we end up with things called <code>MyType.one</code> which are probably confusing for newcomers who assume that's the spelling of <code>1</code>.</p>",
        "id": 344827983,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679914482
    },
    {
        "content": "<p>is the issue with automatically protecting instances resolved?</p>",
        "id": 344829039,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1679914794
    },
    {
        "content": "<p>Not yet</p>",
        "id": 344829672,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679914949
    },
    {
        "content": "<p>Arguably the need for it disappears with an <code>inst</code> prefix</p>",
        "id": 344829728,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679914969
    },
    {
        "content": "<p>I am very much in favor of the first option, but I am afraid that version runs into serious problems without <code>@[protected]</code></p>",
        "id": 344829821,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1679915000
    },
    {
        "content": "<p>It's much less problematic than it was in Lean3, because at least the instance name is no longer the same as the instance type</p>",
        "id": 344829938,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679915038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> <a href=\"#narrow/stream/287929-mathlib4/topic/instance.20names/near/344829821\">said</a>:</p>\n<blockquote>\n<p>I am very much in favor of the first option, but I am afraid that version runs into serious problems without <code>@[protected]</code></p>\n</blockquote>\n<p>Yes, I already ran into this once for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Star#doc\">docs4#Star</a>, because then it gets named <code>MyType.star</code> (unprotected), which is a problem in the <code>MyType</code> namespace because <code>Star.star</code> is exported.</p>",
        "id": 344936317,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1679940848
    },
    {
        "content": "<p>Okay, so it does look like we like the <code>inst</code> prefix (and the porting meeting just now seemed in favour, as well).</p>",
        "id": 344957958,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679947436
    },
    {
        "content": "<p>I'm finding plenty of examples where I don't know what the best name is (leaving aside the <code>inst</code> prefix). Here are some examples. I've added the namespaces by hand, even though they are not always immediately visible in the source.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">TrivSqZeroExt.addSemigroup</span> <span class=\"o\">[</span><span class=\"n\">AddSemigroup</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddSemigroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">AddSemigroup</span> <span class=\"o\">(</span><span class=\"n\">TrivSqZeroExt</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">Subalgebra.toSemiring</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Subalgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Semiring</span> <span class=\"n\">S</span>\n<span class=\"kd\">instance</span> <span class=\"n\">Associates.uniqueUnits</span> <span class=\"o\">:</span> <span class=\"n\">Unique</span> <span class=\"o\">(</span><span class=\"n\">Associates</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span>\n<span class=\"kd\">instance</span> <span class=\"n\">Multiset.fintypeCoe</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">m</span>\n<span class=\"kd\">instance</span> <span class=\"n\">addGroupIsAddTorsor</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AddGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">AddTorsor</span> <span class=\"n\">G</span> <span class=\"n\">G</span>\n<span class=\"kd\">instance</span> <span class=\"n\">Rack.oppositeRack</span> <span class=\"o\">:</span> <span class=\"n\">Rack</span> <span class=\"n\">R</span><span class=\"bp\">ᵐᵒᵖ</span>\n<span class=\"kd\">instance</span> <span class=\"n\">AlgEquiv.applyMulSemiringAction</span> <span class=\"o\">:</span> <span class=\"n\">MulSemiringAction</span> <span class=\"o\">(</span><span class=\"n\">A₁</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A₁</span><span class=\"o\">)</span> <span class=\"n\">A₁</span>\n<span class=\"kd\">instance</span> <span class=\"n\">AlgHom.coeOutRingHom</span> <span class=\"o\">:</span> <span class=\"n\">CoeOut</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">→+*</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">AlgHom.coeOutMonoidHom</span> <span class=\"o\">:</span> <span class=\"n\">CoeOut</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">→*</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">NeZero.one</span> <span class=\"o\">:</span> <span class=\"n\">NeZero</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">PartENat</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">Finite.Set.finite_union</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Finite</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">Sigma.Lex.denselyOrdered_of_noMaxOrder</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Preorder</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">DenselyOrdered</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">NoMaxOrder</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">DenselyOrdered</span> <span class=\"o\">(</span><span class=\"bp\">Σₗ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 344958189,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679947535
    },
    {
        "content": "<p>The first two, <code>TrivSqZeroExt.addSemigroup</code> and <code>Subalgebra.toSemiring</code> seem uncontroversial to me.</p>",
        "id": 344958259,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679947563
    },
    {
        "content": "<p>(Although noting that I think we would plan to add <code>inst</code> to the first but not the second!)</p>",
        "id": 344958329,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679947579
    },
    {
        "content": "<p>The next two, <code>Associates.uniqueUnits</code> and <code>Multiset.fintypeCoe</code> I <em>think</em> are correct?</p>",
        "id": 344958371,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679947601
    },
    {
        "content": "<p>After that I'm not at all sure.</p>",
        "id": 344958397,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679947612
    },
    {
        "content": "<p>If anyone would like to propose preferred names for these, either with or without a rubric that justifies them, that might be useful. :-)</p>",
        "id": 344958451,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679947642
    },
    {
        "content": "<p><code>addGroupIsAddTorsor</code> -&gt; <code>AddGroup.toAddTorsor</code> to match <code>Semiring.toModule</code></p>",
        "id": 344975884,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679954934
    },
    {
        "content": "<p><code>Rack.oppositeRack</code> -&gt; <code>MulOpposite.(inst)Rack</code> to match <code>MulOpposite.(inst)Monoid</code></p>",
        "id": 344975948,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679954964
    },
    {
        "content": "<p><code>applyMulSemiringAction</code> is part of a collection of similar names, so whatever we pick all should be renamed together.</p>",
        "id": 344976223,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679955112
    },
    {
        "content": "<p>Actually, is <code>Subalgebra.toSemiring</code> correct? It's not really a \"should have come from an <code>extends</code> clause\" case at all, and arguably would be better as <code>Subalgebra.semiringCoe</code>?</p>",
        "id": 344982145,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679957691
    },
    {
        "content": "<p>Not sure how I feel about the <code>Coe</code> suffix, but I agree that the current pattern is bad</p>",
        "id": 344982508,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679957860
    },
    {
        "content": "<p>I think elsewhere we insert the word <code>subtype</code> in the instance name (maybe for coerced sets?)</p>",
        "id": 344982540,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679957875
    },
    {
        "content": "<p>Maybe this one should just be <code>Subalgebra.semiring</code>. The invisible coercion can be invisible in the name.</p>",
        "id": 344982758,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679957957
    },
    {
        "content": "<p>A better example might be to consider the semiring of submodules vs the additive group of submodule subtypes</p>",
        "id": 344983868,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679958402
    },
    {
        "content": "<p>I guess the former could be <code>submodule.instSemiring</code> while the latter <code>submodule.addCommGroup</code>, which at least makes them obviously distinct</p>",
        "id": 344983943,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679958451
    },
    {
        "content": "<p>Sorry, I don't understand that pair of examples. What is \"the additive group of submodule subtypes\"?</p>",
        "id": 345005372,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679966925
    },
    {
        "content": "<p>Do you just mean the AddCommGroup structure on an individual submodule? (Whereas the first is an instance where the \"points\" are themselves submodules?)</p>",
        "id": 345005492,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1679967001
    },
    {
        "content": "<p>Oh, I forgot to refer to this thread.<br>\nI have been following this convention from now.</p>",
        "id": 355362122,
        "sender_full_name": "Pol'tta / Miyahara Kō",
        "timestamp": 1683103564
    },
    {
        "content": "<p>I've stumbled upon quite a few instances that are not named in the <code>Foo.instBar</code> style. Is there an easy way to find all named instances? They are probably quite a lot but hopefully less than the ~4000 unnamed instances</p>",
        "id": 379130977,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1690459724
    },
    {
        "content": "<p>I would imagine it's straightforward to find all instances with names that don't start with <code>inst</code>. I don't know if you can inspect whether the name was autogenerated.</p>",
        "id": 379131650,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690459847
    },
    {
        "content": "<p>I wrote a bit about different potential naming schemes at <a href=\"https://github.com/leanprover/lean4/issues/2343#issuecomment-1652005640\">https://github.com/leanprover/lean4/issues/2343#issuecomment-1652005640</a>. At this point I have two main questions to users on my mind:</p>\n<ul>\n<li>Do we consider referencing unnamed (and more broadly, even named) instances a necessary evil due to various technical limitations? Should we work on lifting these limitations even if we still keep a way to reference these instances as a fallback?</li>\n<li>When a reference is necessary, how do people actually discover the name of an unnamed instance? Is it mostly through the info view/<code>pp.explicit</code> of a working term?</li>\n</ul>",
        "id": 379142819,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1690461729
    },
    {
        "content": "<blockquote>\n<p>a necessary evil due to various technical limitations?</p>\n</blockquote>\n<p>It's not really even a technical limitation. If I want to tell someone \"yes, mathlib knows the fact that endomorphisms form a ring\", I would like to be able to link to the instance in the docs, which means I need to know its name.</p>",
        "id": 379148035,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690462597
    },
    {
        "content": "<p>\"How do we want to link to unnamed things\" is also a great general question. I assume that apart from instances, notations are our most prevalent source of unnamed declarations, which use an entirely different naming heuristic that fortunately does not seem to have led to issues... so far</p>",
        "id": 379150638,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1690463041
    },
    {
        "content": "<p>It would be great to have a \"Copy docgen URL/shortlink\" context menu action in the editor that lets us skip the manual name lookup step</p>",
        "id": 379152323,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1690463294
    },
    {
        "content": "<p>Linking to notations can probably be resolved by having doc-gen show info about a notation under the head symbol of the thing it generates</p>",
        "id": 379152554,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690463342
    },
    {
        "content": "<blockquote>\n<p>When a reference is necessary, how do people actually discover the name of an unnamed instance? Is it mostly through the info view/pp.explicit of a working term?</p>\n</blockquote>\n<p>Putting the cursor over the word <code>instance</code> does the job.</p>",
        "id": 379152739,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690463374
    },
    {
        "content": "<p>Ok, if you've already located the instance. I wasn't sure from which end people usually trace back their search to the name of an instance.</p>",
        "id": 379153325,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1690463471
    },
    {
        "content": "<p>In Lean3 we'd go via the infoview as you suggest with <code>example : Foo := by show_term { apply_instance }</code>. This is useless in Lean 4 since it just prints <code>inferInstance</code>, but obviously <code>#synth</code> works instead.</p>",
        "id": 379154055,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690463592
    },
    {
        "content": "<p>At that point aren't you one more hover away from the instance name?</p>",
        "id": 379154278,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1690463638
    },
    {
        "content": "<p>Yes; though I'd argue that the <code>infer_instance</code> tactic would be more useful if it unfolded the <code>inferInstance</code> term like Lean3 did.</p>",
        "id": 379154855,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690463744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/287929-mathlib4/topic/instance.20names/near/379142819\">said</a>:</p>\n<blockquote>\n<ul>\n<li>When a reference is necessary, how do people actually discover the name of an unnamed instance? Is it mostly through the info view/<code>pp.explicit</code> of a working term?</li>\n</ul>\n</blockquote>\n<p>Mostly I read instance names while debugging with <code>set_option Meta.trace.synthInstance true</code> (or sth like that) trying to figure out why and where the wrong instances were used or why it couldnt find one at all.<br>\nFor that it's very useful if the instances have a short, manageable name as the debugging is already hard enough to read as is<span aria-label=\"face with monocle\" class=\"emoji emoji-1f9d0\" role=\"img\" title=\"face with monocle\">:face_with_monocle:</span></p>\n<p>I think in any case where I ever needed to use an unamed instance I would rather just explicitely name it instead</p>",
        "id": 379699238,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1690610937
    },
    {
        "content": "<p>As \"naming things\" famously is one of the hardest problems of CS and I really don't want to commit to a solution that affects hundreds of lines of mathlib before making sure we never have to do that again, how about attacking a simpler end of the issue first? <br>\n<a href=\"/user_uploads/3121/u9DDSUKHqQ1zFjKxspGS3w4Z/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/u9DDSUKHqQ1zFjKxspGS3w4Z/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/u9DDSUKHqQ1zFjKxspGS3w4Z/image.png\"></a></div>",
        "id": 381734431,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691138264
    },
    {
        "content": "<p>Even with the better rendering, that still gives a tonne of irrelevant matches just due to the sheer name length</p>",
        "id": 381735190,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1691138382
    },
    {
        "content": "<p>The matching algorithm really should not consider these relevant matches but I don't know enough about it to judge the complexity of changing it in that way</p>",
        "id": 381739482,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691139018
    },
    {
        "content": "<p>Alternatively, anonymous instance names could be hidden from display and search completely in doc-gen if there is agreement that their named use should at least be minimized. That is, they should be displayed closer to how they're actually written down in the source.</p>",
        "id": 381742053,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691139407
    },
    {
        "content": "<p>What's our current policy about instance names: use the autogenerated names? overwrite them with something more readable?</p>",
        "id": 389884683,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1694180503
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> told me to rename instances in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7028\">#7028</a>. I think that we should have some policy and implement it everywhere.</p>",
        "id": 389888003,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1694181679
    },
    {
        "content": "<p>My personal policy is to rename them if they are bad enough</p>",
        "id": 389896644,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1694184737
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>'s policy was \"if you're ever going to refer to them by name, give them an explicit name\"</p>",
        "id": 389901051,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694186148
    },
    {
        "content": "<p>I think we should just fix the name generator. (to behave more like Lean 3)</p>",
        "id": 389907368,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694188144
    },
    {
        "content": "<p>I'm personally naming all my instances to <code>Type.instTypeclass</code> (for which that pattern applies).</p>",
        "id": 389911834,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1694189834
    },
    {
        "content": "<p>I think we already established that was the preferred naming</p>",
        "id": 389911907,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694189864
    },
    {
        "content": "<p>It would be nice if the name generator used <code>Type.instTypeclass</code> unless a definition with this name exists.</p>",
        "id": 389917092,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1694192013
    },
    {
        "content": "<p>You should add your comments to the open lean 4 issue about this <a href=\"https://github.com/leanprover/lean4/pull/2343\">lean4#2343</a></p>",
        "id": 389941965,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694203155
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/instance.20names/near/389917092\">said</a>:</p>\n<blockquote>\n<p>It would be nice if the name generator used <code>Type.instTypeclass</code> unless a definition with this name exists.</p>\n</blockquote>\n<p>Checking \"does this exist already\" doesn't work, because two files that don't import each other would use the same name, and then you'd get an error when you import both</p>",
        "id": 389942747,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694203471
    },
    {
        "content": "<p>So, what should I do in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7028\">#7028</a>: rename or not? Autogenerated names are long.</p>",
        "id": 389946675,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1694205330
    },
    {
        "content": "<p>Renamed.</p>",
        "id": 389958395,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1694212306
    },
    {
        "content": "<p>I was looking at a relatively short long instance name, and it seems to be very redundant:</p>\n<p><a href=\"/user_uploads/3121/qfLUx7B0DwfJ6pbklJiEIawZ/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/qfLUx7B0DwfJ6pbklJiEIawZ/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/qfLUx7B0DwfJ6pbklJiEIawZ/image.png\"></a></div><p>then I found this topic and <a href=\"https://github.com/leanprover/lean4/pull/2343\">lean4#2343</a> , am I reading it correctly that such a long name is only for avoiding name clash? So I made a suggestion on the issue, to auto-generate names like <code>doc#LinearMap.instModuleLinearMap_3e71a6e</code> which should remain readable and search-friendly for its prefix and much less likely to clash due to the cryptographic properties of the hash algorithm. Am I missing something?</p>",
        "id": 395668249,
        "sender_full_name": "Utensil Song",
        "timestamp": 1696847715
    },
    {
        "content": "<p>BTW. I'm curious about where is this name generator implemented, and is this naming convention already started to grow into people's (manual) naming habits?</p>",
        "id": 395668954,
        "sender_full_name": "Utensil Song",
        "timestamp": 1696847983
    },
    {
        "content": "<p>I think that the convention is that if you want to refer to the instance by name, then you name it explicitly and you bypass the auto-named monsters.</p>\n<p>As you can see from the thread, there are longer term, more automated plans, but human-naming is currently the best automation!</p>",
        "id": 395669769,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1696848304
    },
    {
        "content": "<blockquote>\n<p>and is this naming convention already started to grow into people's (manual) naming habits?</p>\n</blockquote>\n<p>Definitely not! The extent is that we agreed that instance names should start with <code>inst</code>. After the word <code>inst</code>, we've been using the lean3 heuristics by hand.</p>",
        "id": 395670579,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696848629
    },
    {
        "content": "<p>It's just it seems that anywhere I go into a doc or perform a search, the marvelous long names appear. I thought there is a good reason but avoiding name clash is too technically a reason versus quality of life.</p>",
        "id": 395671510,
        "sender_full_name": "Utensil Song",
        "timestamp": 1696848971
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/doc-gen4/pull/156\">leanprover/doc-gen4#156</a></p>",
        "id": 395717931,
        "sender_full_name": "Utensil Song",
        "timestamp": 1696863602
    },
    {
        "content": "<p>Yeah, if you misspell or fail to fully-quality something in docs (e.g. Anatole wrote  <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Metrizable#doc\">docs#Metrizable</a> recently) then the output is heavily polluted right now; this is one of the reasons that prompted me to open <a href=\"https://github.com/leanprover/lean4/pull/2343\">lean4#2343</a> .</p>",
        "id": 395733480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696869106
    }
]