[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> mentioned in his review for <a href=\"https://github.com/leanprover-community/mathlib4/pull/23399\">#23399</a> that mathlib is moving to preferring <code>Finite</code> over <code>Fintype</code> in hypotheses, often accompanied by <code>Nat.card</code> over <code>Fintype.card</code> in statements. I'm a huge fan of this! </p>\n<p>One annoyance, though, is that because the actual proof will often involve <code>Fintype</code> and sometimes <code>Fintype.card</code> for subtypes, proofs often open with the multi-line fluff  <code>have := Fintype.ofFinite a</code> (for one or more types) as well as <code>classical</code>. </p>\n<p>I think a one-line tactic that takes care of this invisibly would be nice. But also, one of the features I remember being touted with lean4 was loops in typeclass search. Could <code>Fintype.ofFinite</code> be an instance?</p>",
        "id": 508758056,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743169345
    },
    {
        "content": "<p>We definitely don't want <code>Fintype.ofFinite</code> to be a global instance, but inside of proofs you should be able to write <code>have := Fintype.ofFinite</code> rather than doing it per-type.</p>",
        "id": 508759154,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743169652
    },
    {
        "content": "<p>It looks like that doesn't always work; if you remove the <code>V</code> on line 227 of <code>Acyclic.lean</code> in the above PR,  it breaks two lines after. (I unfortunately don't have the time to minimize this right now)</p>",
        "id": 508760812,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743170053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Fintype.20and.20Finite/near/508759154\">said</a>:</p>\n<blockquote>\n<p>We definitely don't want <code>Fintype.ofFinite</code> to be a global instance, but inside of proofs you should be able to write <code>have := Fintype.ofFinite</code> rather than doing it per-type.</p>\n</blockquote>\n<p>I guess, you need at least one <code>have</code> per universe.</p>",
        "id": 508771760,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1743172796
    },
    {
        "content": "<p>Yes, test-case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 508784957,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743176131
    },
    {
        "content": "<p>Here is a somewhat minimized example where the type is needed, with just one universe in play.  </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edgeSet</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edgeFinset</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edgeSet</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"n\">G</span>\n<span class=\"w\">  </span><span class=\"c1\">-- succeeds</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edgeSet</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">ofFinite</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"n\">G</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> Fails</span>\n<span class=\"cm\">    type mismatch, term</span>\n<span class=\"cm\">      bar G</span>\n<span class=\"cm\">    after simplification has type</span>\n<span class=\"cm\">      Fintype.card ↑G.edgeSet = 5 : Prop</span>\n<span class=\"cm\">    but is expected to have type</span>\n<span class=\"cm\">      Nat.card ↑G.edgeSet = 5 : Prop -/</span>\n</code></pre></div>",
        "id": 508786358,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743176509
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> Nat.card, Fintype.card</p>",
        "id": 508786516,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743176559
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/SetTheory/Cardinal/Finite.html#Fintype.card_eq_nat_card\">Fintype.card_eq_nat_card</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/SetTheory/Cardinal/Finite.html#Nat.card_eq_fintype_card\">Nat.card_eq_fintype_card</a>, and <a href=\"https://loogle.lean-lang.org/?q=Nat.card%2C%20Fintype.card\">13 more</a></p>",
        "id": 508786520,
        "sender_full_name": "loogle",
        "timestamp": 1743176560
    },
    {
        "content": "<p>I don't understand the point of this loogle.</p>",
        "id": 508786724,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743176626
    },
    {
        "content": "<p>Sorry, I wanted to check if there was a simp lemma to go from the first to the second</p>",
        "id": 508787260,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743176761
    },
    {
        "content": "<p>And indeed there is, so its strange that it isn't firing</p>",
        "id": 508787341,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743176776
    },
    {
        "content": "<p>Yes - and it fires just fine in the proof of <code>foo</code>.</p>",
        "id": 508787405,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743176792
    },
    {
        "content": "<p><code>have := Fintype.ofFinite.{u_1}</code> suffices</p>",
        "id": 508787638,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743176867
    },
    {
        "content": "<p>Would streamlining this kind of thing with a tactic be reasonable? So the tactic invokes <code>classical</code>, then <code>Fintype.ofFinite.{u}</code> for every universe in the context?</p>",
        "id": 508791619,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743177819
    },
    {
        "content": "<p>What about universes like <code>max u v + 1</code>?</p>",
        "id": 508812283,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1743183304
    },
    {
        "content": "<p>Maybe we could make a <code>finite</code> tactic instead that does what <code>classical</code> does, but locally adds the instance (with general universe parameter)</p>",
        "id": 508812519,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743183382
    },
    {
        "content": "<p>what is the cardinality function for Finite?</p>",
        "id": 508812925,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1743183537
    },
    {
        "content": "<p><code>Nat.card</code> - it takes a junk value of zero for infinite types.</p>",
        "id": 508813024,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743183572
    },
    {
        "content": "<p>Is there an encard?</p>",
        "id": 508813197,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1743183625
    },
    {
        "content": "<p>I am dealing with finite structures where maximum cardinality of some type being 0 is not very helpful</p>",
        "id": 508813286,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1743183653
    },
    {
        "content": "<p>Yes, in the form of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENat.card#doc\">docs#ENat.card</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.encard#doc\">docs#Set.encard</a></p>",
        "id": 508813334,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743183670
    },
    {
        "content": "<p>Ah okay. That's very helpful. Thanks</p>",
        "id": 508813373,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1743183683
    },
    {
        "content": "<p>I use it a lot! Also, the new <code>enat_to_nat</code> tactic is wonderful for calculations.</p>",
        "id": 508813448,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743183711
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Fintype.20and.20Finite/near/508812519\">said</a>:</p>\n<blockquote>\n<p>Maybe we could make a <code>finite</code> tactic instead that does what <code>classical</code> does, but locally adds the instance (with general universe parameter)</p>\n</blockquote>\n<p>If this is technically feasible, that would be great for readability.</p>",
        "id": 508813665,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743183783
    },
    {
        "content": "<p>For almost all discrete math problems, encard appears to be the natural cardinality function. (for example think graph distance algorithms that initially assign distance infinity to unexplored vertices).</p>",
        "id": 508813878,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1743183853
    },
    {
        "content": "<p>Moving between Finset and Set is much more painful.</p>",
        "id": 508813908,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1743183862
    },
    {
        "content": "<blockquote>\n<p>If this is technically feasible</p>\n</blockquote>\n<p>Yes, take a look at the definition of the <code>classical</code> tactic. There's very little code. You'd just have to replace the part that has <code>Classical.propDecidable</code></p>",
        "id": 508814385,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743184010
    },
    {
        "content": "<p>My <a href=\"https://github.com/apnelson1/Matroid\">matroid repo</a> uses <code>ENat</code> heavily, for exactly this reason. </p>\n<p><code>ENat</code> has a less full API than <code>Nat</code>, and in particular arguments that involve something resembling subtraction are very awkward, but this is made a lot better with <code>enat_to_nat</code>.</p>",
        "id": 508814412,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1743184024
    }
]