[
    {
        "content": "<p>Just for fun I wanted to knock out one of the 1000 theorems so I formalized Dilworth's (and Mirsky's) theorems on decomposition of finite posets into chains/antichains. About a third of the <a href=\"https://github.com/vlad902/misc-lean-proofs/blob/main/MiscLeanProofs/Dilworth.lean\">formalization</a> is just helper lemmas that I've PR'd. Another third is definitions + basic API for heights/widths of chains/antichains (e.g. maximum chain/antichain sizes) and (minimal) chain/antichain partitions.</p>\n<p>I know that some generalizations of Dilworth's theorem like Greene-Kleitman don't directly use these definitions, e.g.  G-K is stated in terms of sizes of unions of a specific number of chains/antichains, so I wasn't sure if these definitions were worth contributing to mathlib. (I assume the proofs themselves are in the wrong generality for Mathlib given the existence of e.g. Greene-Kleitman.) I wanted to see if anyone knew of other cases where these definitions might be useful, otherwise i'll just keep them in my repository.</p>",
        "id": 541645071,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1758886154
    },
    {
        "content": "<p>Amusingly I found this thread <a class=\"message-link\" href=\"/#narrow/channel/442935-Carleson/topic/Task.2052/near/455126149\">#Carleson &gt; Task 52 @ ðŸ’¬</a> and there are already at least 2 competing notions of maximum chain heights in Mathlib, though they both depend on <code>[LT]</code> rather than taking arbitrary relations which is concise but I dislike that it's hard to then usem with anything that's spelled otherwise.</p>",
        "id": 542323222,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1759250626
    },
    {
        "content": "<p>I was looking because I also realized that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.indepNum#doc\">docs#SimpleGraph.indepNum</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.cliqueNum#doc\">docs#SimpleGraph.cliqueNum</a> are also just minimum chain heights/antichain widths in Mathlib. Partially duplicate definitions abound.</p>",
        "id": 542323870,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1759250836
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> Do you know if Mathlib.Order.Height is in use anywhere outside of Mathlib? In mathlib it's not included anywhere, and perhaps that's a good opportunity to generalize it to arbitrary relations</p>",
        "id": 542347491,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1759258638
    },
    {
        "content": "<p>Unless I'm mistaken, commutative algebra uses this notion of height for the poset of prime ideals (to define height, dimension, etc.).</p>",
        "id": 542431098,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1759305866
    },
    {
        "content": "<p>Yes <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.height#doc\">docs#Order.height</a> is used a lot in commutative algebra. A generalization would not be hard (by replacing <code>LTSeries</code> by a general <code>RelSeries</code>), but it would be better to have this as a new definition <code>SetRel.height</code> and make <code>Order.height</code> an abbreviation for <code>SetRel.height</code> for the most common case of preorders.</p>",
        "id": 542435085,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759307074
    },
    {
        "content": "<p>Is there a reason why the RelSeries spelling is prefered over <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.IsChain%3F#doc\">docs#List.IsChain?</a> I saw that recently it was changed to take a relation spelled as SetRel for some reason I have not looked into yet, but otherwise it is morally identical to List.IsChain right?</p>",
        "id": 542435342,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1759307150
    },
    {
        "content": "<p>See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RelSeries.Equiv#doc\">docs#RelSeries.Equiv</a>. I have advocated for redefining <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RelSeries#doc\">docs#RelSeries</a> for a while. But not in the direction you propose, but rather in the direction of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quiver.Path#doc\">docs#Quiver.Path</a>. I would introduce a <code>SetRel.Path</code> as an inductive type with head and last element as a parameter. A <code>RelSeries</code> would be a structure bundling a head, a last element and a <code>SetRel.Path head last</code>.<br>\nIf instead of <code>r : SetRel X X</code> we take a general <code>r : X -&gt; X -&gt; Sort*</code>, this could be used to define <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quiver.Path#doc\">docs#Quiver.Path</a>.</p>\n<p>Most of the <code>RelSeries</code> API would be developed for <code>SetRel.Path</code> instead, only providing simple wrapping operations in the last step when <code>RelSeries</code> are needed.</p>",
        "id": 542436996,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759307574
    },
    {
        "content": "<p>The reason for this is that working with an inductive type is much smoother than with a subtype of an inductive type.</p>",
        "id": 542437124,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759307612
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> has made some significant progress on this in a branch, but I don't know what the status of this is.</p>",
        "id": 542437199,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759307633
    },
    {
        "content": "<p>Interesting, this would be the equivalent of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk#doc\">docs#SimpleGraph.Walk</a> for a general relation</p>",
        "id": 542437511,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1759307736
    },
    {
        "content": "<p>Yes, there is a lot of deduplication potential here.</p>",
        "id": 542437625,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759307774
    },
    {
        "content": "<p>Anyways, I would like to take a stab at upstreaming the chain height/antichain width definitions in terms of general relations and then re-defining Order.height in terms of it. I am prototyping that now locally now. (Set.chainHeight is unused and close enough in meaning that I think it could be deprecated/absorbed into the other definition)</p>",
        "id": 542438151,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1759307948
    },
    {
        "content": "<p>I'm putting this down for now. Though I have an API I'm happy with for working with chain heights, trying to prove equivalence with Order.height is very unergonomic. <code>RelSeries</code> not accepting empty lists and the use of <code>Fin</code> makes proving tedious, and this seems like the type of large scale change that may flounder in the review queue for lack of interest.</p>",
        "id": 542787136,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1759423110
    },
    {
        "content": "<p>Can you sketch what you'd like changed? I might be able to help with getting this in</p>",
        "id": 542818352,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1759434015
    },
    {
        "content": "<p>The overall idea is that it would be nice to have a general definition of chain heights/antichain widths since this idea comes up in multiple places. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.height#doc\">docs#Order.height</a> is one instance of a chain height definition that should not be generalized but could possibly be subsumed by a more general definiton. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.chainHeight#doc\">docs#Set.chainHeight</a> is an implementation of chain heights but it appears unused and in my opinion:</p>\n<ul>\n<li>should be stated for arbitrary relations instead of LT. For example, clique/independence numbers in graph theory are chain heights/antichain widths for G.Adj and this should be supported without having to resort to <code>have : LT V := { lt := ... </code> everywhere</li>\n<li>should use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsChain#doc\">docs#IsChain</a> instead of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.IsChain#doc\">docs#List.IsChain</a>, e.g. all elements are comparable instead of just consecutive elements. I think this is the more common mathematical definition--the two cases are equivalent for transitive relations, but they have a different meaning in the case given above.</li>\n<li>from some of my experimentation locally, I think the definition of chain heights should also probably be for Types and not for Sets, e.g. <code>chainHeight type rel</code> instead of  <code>set.chainHeight rel</code>. Some of the proofs go through more cleanly and it's a bit more flexible.</li>\n</ul>\n<p>The disadvantages I can think of with my approach are:</p>\n<ul>\n<li>Carrying around a <code>(Â· &lt; Â·)</code> term, though this is likely to be hidden by defs wrapping the API</li>\n<li>Dealing with set subtypes in some places, but in my experience it's not so bad to write <code>chainHeight â†‘s rel</code> instead of <code>s.chainHeight rel</code>.</li>\n</ul>\n<p>I think 1) Set.chainHeight should be replaced by a more general definition with comparable API [and also add an antichainWidth analog], and 2) Order.height could then be re-defined using that definition (in a non-breaking equivalent way.) I think the first step is something I could polish and achieve fairly easily, I've already developed most of it and just need to expand and polish. The second will require more time to develop some API to make the transition smooth.</p>\n<p>I think just doing step <a href=\"https://github.com/leanprover-community/mathlib4/pull/1\">#1</a> is a good step since it replaces an unused definition with a more general version, and I am also interested in going through with step <a href=\"https://github.com/leanprover-community/mathlib4/pull/2\">#2</a> if there's interest in having me do this--I just think it's too big an undertaking to do speculatively.</p>",
        "id": 542823244,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1759435847
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"761203\">Vlad Tsyrklevich</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definitions.20for.20chain.20height.2Fpartitions/near/542823244\">said</a>:</p>\n<blockquote>\n<p>I think this is the more common mathematical definition--the two cases are equivalent for transitive relations, but they have a different meaning in the case given above.</p>\n</blockquote>\n<p>i don't feel this is true? i'm pretty sure the equivalent notion of \"chain\" for a graph would be a <em>path</em>, not a clique?</p>",
        "id": 542823767,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759436063
    },
    {
        "content": "<p>I agree <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=chainHeight#doc\">docs#chainHeight</a> should be stated for arbitrary relations, but I don't think it's useful to redefine <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.cliqueNum#doc\">docs#SimpleGraph.cliqueNum</a> in terms of it, since the current definition is more workable in practice. I'm in favour of a lemma linking them though.<br>\nI agree using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsChain#doc\">docs#IsChain</a> is more reasonable than <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.IsChain#doc\">docs#List.IsChain</a> (although note that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Pairwise#doc\">docs#List.Pairwise</a> gives a non-transitive version).<br>\nIt's not clear to me that the types version is better than the sets version here, it might be reasonable to have both? Note that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsChain#doc\">docs#IsChain</a> is for sets, and many order-theoretic things are in general.</p>",
        "id": 542824046,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1759436174
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definitions.20for.20chain.20height.2Fpartitions/near/542823767\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"761203\">Vlad Tsyrklevich</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definitions.20for.20chain.20height.2Fpartitions/near/542823244\">said</a>:</p>\n<blockquote>\n<p>I think this is the more common mathematical definition--the two cases are equivalent for transitive relations, but they have a different meaning in the case given above.</p>\n</blockquote>\n<p>i don't feel this is true? i'm pretty sure the equivalent notion of \"chain\" for a graph would be a <em>path</em>, not a clique?</p>\n</blockquote>\n<p>If chain uses consecutive elements, then it's a path, but if it's arbitrary (as Vlad wants to change it to) then it's a clique.</p>",
        "id": 542824122,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1759436199
    },
    {
        "content": "<p>I'd like to hear <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span>'s opinion here, since he wrote <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.chainHeight#doc\">docs#Set.chainHeight</a>, did you have a particular use-case in mind? If so, we should make sure to support it.</p>",
        "id": 542824227,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1759436255
    },
    {
        "content": "<p>indeed <em>if it's arbitrary</em>. however, saying that \"chains correspond to cliques, therefore chains should use arbitrary elements\" is a non-argument to me because <em>chains don't correspond to cliques</em></p>",
        "id": 542824302,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759436284
    },
    {
        "content": "<p>We don't use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.chainHeight#doc\">docs#Set.chainHeight</a> anywhere I think. Andrew introduced it back in 2022 to do heights of ideals in commutative algebra, but since then we got <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.height#doc\">docs#Order.height</a> and when all of Andrew's height theory was ported to Lean4, it got all converted to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.height#doc\">docs#Order.height</a>.</p>",
        "id": 542824308,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759436289
    },
    {
        "content": "<p>I think we should either remove <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.chainHeight#doc\">docs#Set.chainHeight</a> or redefine it via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.height#doc\">docs#Order.height</a> (my opinion without reading what happened above).</p>",
        "id": 542824421,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1759436354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definitions.20for.20chain.20height.2Fpartitions/near/542824302\">said</a>:</p>\n<blockquote>\n<p>indeed <em>if it's arbitrary</em>. however, saying that \"chains correspond to cliques, therefore chains should use arbitrary elements\" is a non-argument to me because <em>chains don't correspond to cliques</em></p>\n</blockquote>\n<p>Note that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsChain#doc\">docs#IsChain</a> is arbitrary, and so it does correspond to clique.</p>",
        "id": 542824470,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1759436379
    },
    {
        "content": "<p>this (to me) is just a consequence of there not being another way to define \"IsChain\" on sets, and not because this is the ideal version of what it means to be a chain.</p>",
        "id": 542824672,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759436467
    },
    {
        "content": "<p>I'm not really sure what you mean, the definition of chain is between arbitrary elements: <a href=\"https://en.wikipedia.org/wiki/Total_order#Chains\">https://en.wikipedia.org/wiki/Total_order#Chains</a></p>",
        "id": 542824798,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1759436519
    },
    {
        "content": "<p>it's the definition that makes sense for transitive relations.</p>",
        "id": 542824801,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759436521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definitions.20for.20chain.20height.2Fpartitions/near/542824046\">said</a>:</p>\n<blockquote>\n<p>It's not clear to me that the types version is better than the sets version here, it might be reasonable to have both? Note that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsChain#doc\">docs#IsChain</a> is for sets, and many order-theoretic things are in general.</p>\n</blockquote>\n<p>I should play with it more--I think the difficulty I found is that by stating the definition purely in terms of sets working with RelHom/RelEmbedding/RelIsos becomes more difficult. Proofs that were trivial in the typed version become a bit of a quagmire since you can't escape to Types to e.g. deal with some coercions. Most of theory goes through just fine and mostly the exact same proofs, I was just wary of the few that became more difficult</p>",
        "id": 542825067,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1759436638
    },
    {
        "content": "<p>To repeat what I already said above:</p>\n<ul>\n<li>We should define a general inductive type <code>Path</code> that is identical to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quiver.Path#doc\">docs#Quiver.Path</a>, but instead of taking a typeclass argument <code>Quiver V</code>, it should take a general relation <code>r : V -&gt; V -&gt; Sort*</code>.</li>\n<li>Then we redefine <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RelSeries#doc\">docs#RelSeries</a> to be</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RelSeries</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"n\">path</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">last</span>\n</code></pre></div>\n<ul>\n<li>We define <code>Rel.height</code> in the same way as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.height#doc\">docs#Order.height</a>, but taking an explicit <code>r : X -&gt; X -&gt; Sort*</code> argument.</li>\n</ul>",
        "id": 542825141,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759436670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definitions.20for.20chain.20height.2Fpartitions/near/542824801\">said</a>:</p>\n<blockquote>\n<p>it's the definition that makes sense for transitive relations.</p>\n</blockquote>\n<p>I think that's a valid point, chains are usually discussed for transitive relations. It's unfortunate that IsChain/List.IsChain differ in meaning here, but I was working under the idea that chains specify total orders, so the natural definition for non-transitive relations is that everything is comparable.</p>",
        "id": 542825466,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1759436805
    },
    {
        "content": "<p>Finally, we can</p>\n<ul>\n<li>deprecate <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.chainHeight#doc\">docs#Set.chainHeight</a></li>\n<li>define <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quiver.Path#doc\">docs#Quiver.Path</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk#doc\">docs#SimpleGraph.Walk</a> as specializations of <code>Path</code></li>\n<li>naturally define relative heights (i.e. between two terms <code>x y : X</code>) to be the suprema of lengths of <code>Path</code>s between <code>x</code> and <code>y</code></li>\n</ul>",
        "id": 542825468,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759436806
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definitions.20for.20chain.20height.2Fpartitions/near/542825468\">said</a>:</p>\n<blockquote>\n<p>Finally, we can</p>\n<ul>\n<li>deprecate <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.chainHeight#doc\">docs#Set.chainHeight</a></li>\n</ul>\n</blockquote>\n<p>The issue I have with this is that the height of a chain is a useful notion in order theory, and either RelSeries formulation of it is super awkward for order theory.</p>",
        "id": 542825647,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1759436867
    },
    {
        "content": "<p>i almost completely agree with Christian's opinion, with the technical exception that i think it should be for <code>r : V -&gt; V -&gt; Type*</code> because of unification issues between <code>Sort (max m (n + 1))</code> and <code>Type w</code>, and when you need it for <code>Prop</code> you use <code>PLift</code></p>",
        "id": 542825881,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759436965
    },
    {
        "content": "<p>in particular, having <code>Path r head last : Type u</code> always unify allows us to make use of a bunch of useful notation.</p>",
        "id": 542826104,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759437046
    },
    {
        "content": "<p>(like appending and such)</p>",
        "id": 542826146,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759437062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definitions.20for.20chain.20height.2Fpartitions/near/542825647\">said</a>:</p>\n<blockquote>\n<p>The issue I have with this is that the height of a chain is a useful notion in order theory, and either RelSeries formulation of it is super awkward for order theory.</p>\n</blockquote>\n<p>I don't understand this, we don't use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.chainHeight#doc\">docs#Set.chainHeight</a> currently. Do you mean that we should still have a notion of \"maximal height in a set\" notion? This could just be defined in terms of <code>Rel.height</code> of the set coerced to a type.</p>",
        "id": 542826163,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759437066
    },
    {
        "content": "<p>Wouldn't this limit it to Finsets? Or rather, wouldn't it limit it to finite chains.</p>",
        "id": 542826332,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1759437118
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definitions.20for.20chain.20height.2Fpartitions/near/542825881\">said</a>:</p>\n<blockquote>\n<p>i almost completely agree with Christian's opinion, with the technical exception that i think it should be for <code>r : V -&gt; V -&gt; Type*</code> because of unification issues between <code>Sort (max m (n + 1))</code> and <code>Type w</code>, and when you need it for <code>Prop</code> you use <code>PLift</code></p>\n</blockquote>\n<p>Using <code>PLift</code> would be quite annoying I think? (Note, still the most used case will be the one of orders).</p>",
        "id": 542826335,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759437119
    },
    {
        "content": "<p>true, but i imagine that we can have a facade to hide the API behind, making it much more usable i think</p>",
        "id": 542826433,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759437151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definitions.20for.20chain.20height.2Fpartitions/near/542826163\">said</a>:</p>\n<blockquote>\n<p>I don't understand this, we don't use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.chainHeight#doc\">docs#Set.chainHeight</a> currently. </p>\n</blockquote>\n<p>Sure, but we do want a notion of chain height of a poset, the notion shows up fairly often but just isn't in mathlib in a nice form yet. And Vlad's proof of Dilworth is a good opportunity to get it in.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definitions.20for.20chain.20height.2Fpartitions/near/542826163\">said</a>:</p>\n<blockquote>\n<p>This could just be defined in terms of <code>Rel.height</code> of the set coerced to a type.</p>\n</blockquote>\n<p>Right, but the inductive definition is really annoying to use in order theory, and limits us to finiteness as well as transitivity</p>",
        "id": 542826522,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1759437176
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span>  Can you point to a unification problem that is not related to notation?</p>",
        "id": 542826527,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759437179
    },
    {
        "content": "<p>not at the moment... but i don't think this is an irrelevant consideration. this has also been a consideration for the category theory library, i believe?</p>",
        "id": 542826747,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759437267
    },
    {
        "content": "<p>i.e. <code>Quiver.Hom : C -&gt; C -&gt; Type w</code> rather than <code>C -&gt; C -&gt; Sort w</code></p>",
        "id": 542826954,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759437353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definitions.20for.20chain.20height.2Fpartitions/near/542826522\">said</a>:</p>\n<blockquote>\n<p>Right, but the inductive definition is really annoying to use in order theory, and limits us to finiteness as well as transitivity</p>\n</blockquote>\n<p>Sorry, why does it limit us to finiteness? Are you saying <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.chainHeight#doc\">docs#Set.chainHeight</a> is not equal to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.krullDim#doc\">docs#Order.krullDim</a> of the coerced set?</p>",
        "id": 542827203,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759437460
    },
    {
        "content": "<p>I guess you cannot say that the height is some arbitrary ordinal (which you cannot with <code>Order.krullDim</code> either)</p>",
        "id": 542827371,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1759437523
    },
    {
        "content": "<p>Cardinal, but yeah</p>",
        "id": 542827713,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1759437665
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definitions.20for.20chain.20height.2Fpartitions/near/542826335\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definitions.20for.20chain.20height.2Fpartitions/near/542825881\">said</a>:</p>\n<blockquote>\n<p>i almost completely agree with Christian's opinion, with the technical exception that i think it should be for <code>r : V -&gt; V -&gt; Type*</code> because of unification issues between <code>Sort (max m (n + 1))</code> and <code>Type w</code>, and when you need it for <code>Prop</code> you use <code>PLift</code></p>\n</blockquote>\n<p>Using <code>PLift</code> would be quite annoying I think? (Note, still the most used case will be the one of orders).</p>\n</blockquote>\n<p>Yeah, and the simple graph case would also need PLift</p>",
        "id": 542828210,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1759437857
    },
    {
        "content": "<p>I think there's a middle ground here, which is adopting Vlad and Christian's plans, except not removing Set.chainHeight. Then we can show that both heights are the same, and it's valuable to have both since the inductive vs Set formulations seem genuinely both useful</p>",
        "id": 542828534,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1759437969
    },
    {
        "content": "<p>The current Set.chainHeight is also an inductive definition as it is the supremum of all monotone lists.</p>",
        "id": 542828875,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1759438096
    },
    {
        "content": "<p>Sorry I should have been clearer: Vlad's plan includes changing that to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsChain#doc\">docs#IsChain</a>, so it wouldn't be inductive any more</p>",
        "id": 542829165,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1759438209
    },
    {
        "content": "<p>I was missing this piece of information, now I understand and agree that we should have both notions.</p>",
        "id": 542831068,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759439043
    },
    {
        "content": "<p>Also I just realized that though the current definition of Set.chainHeight has been stated in terms of <code>LT</code> as an arbitrary relation it is not well-defined for arbitrary relations. For example with the relation that is always true, the chain height of a singleton is infinite because there is an infinitely long list forming a chain, but this doesn't match my intuition about what a chain is.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Height</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">ENatToNat</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_well_defined</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">x</span><span class=\"bp\">âŸ©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">N</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">chainHeight</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">âŠ¤</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">chainHeight</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">eq_top_iff_forall_gt</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">lt_biSup_iff</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">constructor</span>\n<span class=\"w\">    </span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">subchain</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">      </span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">      </span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">isChain_replicate_of_rel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n<span class=\"w\">    </span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"n\">enat_to_nat</span>\n<span class=\"w\">      </span><span class=\"n\">grind</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>To be fair the doc comment does say the definition is for chain heights in a preorder, but it's been stated using LT since at least the port from mathlib3.</p>",
        "id": 543773907,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1759936274
    }
]