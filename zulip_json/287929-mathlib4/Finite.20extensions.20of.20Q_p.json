[
    {
        "content": "<p>Right now mathlib has <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NumberField#doc\">docs#NumberField</a> for finite field extensions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span> (a poorly-named Prop), and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RCLike#doc\">docs#RCLike</a> for finite field extensions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> (although for reasons I've never understood, the analysts also want to fix a square root of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>‚àí</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">‚àí</span><span class=\"mord\">1</span></span></span></span> in the degree 2 case, so it's not a Prop, meaning that it can't really be used for archimedean completions of number fields). For FLT I am becoming convinced that I need some way of talking about finite field extensions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>, with the examples I care about being nonarchimedean completions of number fields, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> itself. <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> s for these:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">IsDedekindDomain</span>\n\n<span class=\"c1\">-- note [NumberField K]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDedekindDomain</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NumberField</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsFractionRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HeightOneSpectrum</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- this</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">adicCompletion</span><span class=\"w\"> </span><span class=\"n\">K</span>\n\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- and this</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">‚Ñö_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I've just knocked up the following proposal: what do people think?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">TypeTags</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">Normed</span><span class=\"bp\">.</span><span class=\"n\">Field</span><span class=\"bp\">.</span><span class=\"n\">Lemmas</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">ValuationTopology</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Multiplicative</span>\n\n<span class=\"sd\">/-- A field with a discrete valuation is said to be a ùìπ-adic field if</span>\n<span class=\"sd\">it's characteristic zero, complete, locally compact, and |p|&lt;1. -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsPadicField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Valued</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">‚Ñ§‚Çò‚ÇÄ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">isCompleteSpace</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">K</span>\n<span class=\"w\">  </span><span class=\"n\">isCharZero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CharZero</span><span class=\"w\"> </span><span class=\"n\">K</span>\n<span class=\"w\">  </span><span class=\"n\">isPadic</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">isLocallyCompact</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LocallyCompactSpace</span><span class=\"w\"> </span><span class=\"n\">K</span>\n</code></pre></div>\n<p>The <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>-algebra structure is data which I am reluctant to include (although I guess there will be a def which could be promoted to an instance when appropriate).</p>",
        "id": 501393664,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740331391
    },
    {
        "content": "<p>Shouldn't we show that for a given degree, the fields satisfying this are isomorphic? As in, there is only one unique extension for each degree</p>",
        "id": 501393979,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1740331681
    },
    {
        "content": "<p>LocallyCompact already implies discreteness of valuation iiuc</p>",
        "id": 501394048,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1740331734
    },
    {
        "content": "<p>A local field is a non-discrete locally compact field (which I think can be made into a prop). The p-adic case is a <code>Prop</code>erty on top of that, although we may want to add data to the class for convenience as Kevin suggests.</p>",
        "id": 501394186,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740331841
    },
    {
        "content": "<p>And it‚Äôs not the case that the degree determines the field up to isomorphism</p>",
        "id": 501394270,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740331912
    },
    {
        "content": "<p>Ah sorry, I think I interpolated unramified into the statement</p>",
        "id": 501394403,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1740332038
    },
    {
        "content": "<p>Aha, so I could remove <code>Valued</code> and just ask for the uniform space instance (and maybe that p^n tends to zero)</p>",
        "id": 501395172,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740332761
    },
    {
        "content": "<p>It's not true at all that there's a unique extension of each degree, the absolute Galois group of the p-adic numbers is a very complicated thing. In fact what started me off on this is that the thing I really need for FLT if I don't want to sorry data is the Artin map from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>F</mi><mo>√ó</mo></msup></mrow><annotation encoding=\"application/x-tex\">F^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">√ó</span></span></span></span></span></span></span></span></span></span></span> to the abelianisation of the absolute Galois group of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> and I was contemplating how to do this which led me to the thoughts above</p>",
        "id": 501395419,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740332951
    },
    {
        "content": "<p>There are now at least three projects that are interested in LCFT. Should we try to coordinate? Deciding on the definition of <code>IsLocalField</code> would be a good start :)</p>",
        "id": 501401803,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740338016
    },
    {
        "content": "<p>I only started thinking about this today so deciding to collaborate now would be optimal!</p>",
        "id": 501401891,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740338074
    },
    {
        "content": "<p>My proposal for <code>IsLocalField</code> is to say that the type of topologies which make the field into a locally compact nondiscrete topological field is nonempty (so really a prop!). <code>NonArch</code> could be done by saying e.g. that the image of <code>Nat</code> is contained in a compact subset.</p>",
        "id": 501402021,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740338180
    },
    {
        "content": "<p>Although from that point of view maybe IsLocalField should take a topology and a topologicaldivisionring instance as mixins?</p>",
        "id": 501402085,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740338243
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsLocallyCompact#doc\">docs#IsLocallyCompact</a></p>",
        "id": 501402115,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740338275
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LocallyCompactSpace#doc\">docs#LocallyCompactSpace</a></p>",
        "id": 501402185,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740338320
    },
    {
        "content": "<p>Regarding nonarchimedean topologies, I've been reading references like <a href=\"https://arxiv.org/abs/2111.09722\">https://arxiv.org/abs/2111.09722</a> that discuss the generalization of nonarchimedean norms to uniform spaces -- that the uniformity has a basis of equivalence relations. So that would apply to <code>UniformSpace.Completion</code> without having to establish a norm (there is no <code>UniformRing</code>, unlike <code>Uniform(Add)Group</code>)</p>",
        "id": 501404454,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1740339914
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> , do you want this type to be nonempty, or unique?</p>",
        "id": 501530444,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1740400379
    },
    {
        "content": "<p>I think uniqueness is a theorem? E.g. we know that for p-adic fields the valuation ring is uniformly definable in the ring language, so if a field is p-adic then it's p-adic in a way that's determined by the isomorphism type of the field.</p>",
        "id": 501586625,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740413672
    },
    {
        "content": "<p><a href=\"https://www.sciencedirect.com/science/article/pii/S0168007213000791\">https://www.sciencedirect.com/science/article/pii/S0168007213000791</a></p>",
        "id": 501586935,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740413740
    },
    {
        "content": "<p>These sorts of things are true but it's not clear to me that we want to assume them when making the definition. For example when do you ever get a p-adic field which doesn't come with a topology (and also with a prime p)?</p>",
        "id": 501609215,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740419034
    },
    {
        "content": "<p>Yeah, I agree. I think <code>IsLocalField</code> should take <code>NontriviallyNormedField</code> as a parameter.</p>",
        "id": 501609656,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740419149
    },
    {
        "content": "<p>Note that <code>NontriviallyNormedField</code> includes a uniform space structure.</p>",
        "id": 501609829,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740419185
    },
    {
        "content": "<p>But it also includes a real-valued norm, so if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mi mathvariant=\"normal\">/</mi><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">K/\\mathbb{Q}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> is finite then the two standard norms on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> (one satisfying <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚à£</mi><mi>p</mi><mi mathvariant=\"normal\">‚à£</mi><mo>=</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">|p|=1/p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\">p</span><span class=\"mord\">‚à£</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\">p</span></span></span></span> (i.e. compatible with inclusions) and the other satisfying <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚à£</mi><mi>œñ</mi><mi mathvariant=\"normal\">‚à£</mi><mo>=</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">|\\varpi|=1/q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">œñ</span><span class=\"mord\">‚à£</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span></span></span></span> (i.e. compatible with additive Haar measure)) will give two \"different\" p-adic fields?</p>",
        "id": 501610316,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740419307
    },
    {
        "content": "<p>Right, with this approach it wouldn't be a p-adic field, but rather a p-adic field together with a choice of normalization.</p>",
        "id": 501610529,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740419367
    },
    {
        "content": "<p>But I get the point -- if we want to go between two normalizations this would get annoying.</p>",
        "id": 501610616,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740419395
    },
    {
        "content": "<p>For nonarchimedean fields, it would still difficult if one said <code>Valued K G0</code> on its own, because a p-adic field can have a variety of <code>G0</code>s : Zm0, NNReal, Real, and in each, it might not be \"normalized\". To this end, Maria Ines and Filippo recently added <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Valuation.IsDiscrete#doc\">docs#Valuation.IsDiscrete</a>, a class which works only on Zm0 valuations, and requires that is surjective (when over a field). Still, that would then limit you to always discuss _the_ normalization, in other words.</p>",
        "id": 501611207,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1740419546
    },
    {
        "content": "<p>Is there an equivalent of <code>MetrizableSpace</code> for normed spaces?</p>",
        "id": 501611422,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1740419605
    },
    {
        "content": "<p>Does <code>WithAbs</code> help in moving between normalizations?</p>",
        "id": 501611993,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1740419730
    },
    {
        "content": "<p>I guess that a p-adic field has a canonical equivalence class of norms and two norms are equivalent iff they induce the same topology, so I'm led to the same question! The topology must be normable!</p>",
        "id": 501615879,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740420733
    },
    {
        "content": "<p>Maybe that's the same as metrizable?</p>",
        "id": 501616001,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740420775
    },
    {
        "content": "<p>So the question is: if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> is a topological field and it's known that the topology is metrizable, i.e. is induced by a metric <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mo>:</mo><msup><mi>K</mi><mn>2</mn></msup><mo>‚Üí</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">d:K^2\\to\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, then is the topology also \"normable\", in the sense that it is induced from a norm <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚à£</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">‚à£</mi><mo>:</mo><mi>K</mi><mo>‚Üí</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">|.|:K\\to\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à£.‚à£</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> satisfying the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NormedField#doc\">docs#NormedField</a> axioms? Note that a norm on a space gives a topology because it gives a metric defined by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi mathvariant=\"normal\">‚à£</mi><mi>x</mi><mo>‚àí</mo><mi>y</mi><mi mathvariant=\"normal\">‚à£</mi></mrow><annotation encoding=\"application/x-tex\">d(x,y)=|x-y|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord\">‚à£</span></span></span></span>.</p>",
        "id": 501617257,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740421133
    },
    {
        "content": "<p>An attempt?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">NormalizableField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"bp\">.</span><span class=\"n\">MetrizableSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">norm_mul'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TopologicalSpace</span><span class=\"bp\">.</span><span class=\"n\">metrizableSpaceMetric</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toDist</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">TopologicalSpace</span><span class=\"bp\">.</span><span class=\"n\">metrizableSpaceMetric</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toDist</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">TopologicalSpace</span><span class=\"bp\">.</span><span class=\"n\">metrizableSpaceMetric</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toDist</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">non_trivial</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TopologicalSpace</span><span class=\"bp\">.</span><span class=\"n\">metrizableSpaceMetric</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toDist</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">dist_sub_eq</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TopologicalSpace</span><span class=\"bp\">.</span><span class=\"n\">metrizableSpaceMetric</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toDist</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">TopologicalSpace</span><span class=\"bp\">.</span><span class=\"n\">metrizableSpaceMetric</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toDist</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NormalizableField</span><span class=\"bp\">.</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NormalizableField</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">norm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">__</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"bp\">.</span><span class=\"n\">metrizableSpaceMetric</span><span class=\"w\"> </span><span class=\"n\">K</span>\n<span class=\"w\">  </span><span class=\"n\">dist_eq</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">dist_sub_eq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">    </span><span class=\"c1\">-- have : IsometricVAdd K·µÉ·µí·µñ K := by</span>\n<span class=\"w\">    </span><span class=\"c1\">--   refine ‚ü®fun c ‚Ü¶ Isometry.of_dist_eq fun x y ‚Ü¶ ?_‚ü©</span>\n<span class=\"w\">    </span><span class=\"c1\">--   sorry</span>\n<span class=\"w\">    </span><span class=\"c1\">-- rw [eq_comm, ‚Üê dist_add_right _ _ y]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- simp</span>\n<span class=\"w\">  </span><span class=\"n\">norm_mul'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">norm_mul'</span>\n<span class=\"w\">  </span><span class=\"n\">non_trivial</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">non_trivial</span>\n</code></pre></div>",
        "id": 501622819,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1740422806
    },
    {
        "content": "<p>I got into a circular argument issue in the <code>IsometricVAdd K·µÉ·µí·µñ K</code> proof, so I yanked out the <code>dist_sub_eq</code> as a separate axiom</p>",
        "id": 501623003,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1740422863
    },
    {
        "content": "<p>Right now I'd be interested to see a maths strategy rather than launching into Lean. Is it even true?</p>",
        "id": 501623022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740422871
    },
    {
        "content": "<p>Not all metrizable spaces are normalizable. Frechet spaces can have a translation invariant metric, but not a scaling one. cf: <a href=\"https://math.stackexchange.com/a/3335507\">https://math.stackexchange.com/a/3335507</a></p>",
        "id": 501625199,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1740423510
    },
    {
        "content": "<p>This doesn't surprise me at all, which is why I specifically asked about topological fields.</p>",
        "id": 501626039,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740423752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/501586625\">said</a>:</p>\n<blockquote>\n<p>I think uniqueness is a theorem? E.g. we know that for p-adic fields the valuation ring is uniformly definable in the ring language, so if a field is p-adic then it's p-adic in a way that's determined by the isomorphism type of the field.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/501609215\">said</a>:</p>\n<blockquote>\n<p>These sorts of things are true but it's not clear to me that we want to assume them when making the definition. For example when do you ever get a p-adic field which doesn't come with a topology (and also with a prime p)?</p>\n</blockquote>\n<p>One benefit of the approach that Adam suggests is that it avoids the questions about have a distinguished norm etc... as part of the definition. Parts of the API could then assume a norm compatible with the p-adic field structure. But it won't be forced by the definition.</p>",
        "id": 501627750,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1740424320
    },
    {
        "content": "<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> is a finite extension of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> for some prime <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> then the topology is intrinsic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>. You can characterise <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"script\">O</mi><mi>K</mi><mo>√ó</mo></msubsup></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_K^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.105em;vertical-align:-0.2935em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8115em;\"><span style=\"top:-2.4065em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">K</span></span></span><span style=\"top:-3.1031em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">√ó</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2935em;\"><span></span></span></span></span></span></span></span></span></span> as the elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>K</mi><mo>√ó</mo></msup></mrow><annotation encoding=\"application/x-tex\">K^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">√ó</span></span></span></span></span></span></span></span></span></span></span> which have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> th roots for infinitely many positive integers <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> and then you can get arbitrarily small neighbourhoods of 1 by raising this set to the power <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo stretchy=\"false\">!</mo></mrow><annotation encoding=\"application/x-tex\">N!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">!</span></span></span></span> and now you have a basis of neighbourhoods of any point, by translation. You can figure out which <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> you're talking about by looking at the indices of these <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>U</mi><mrow><mi>N</mi><mo stretchy=\"false\">!</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">U^{N!}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose mtight\">!</span></span></span></span></span></span></span></span></span></span></span></span> subgroups within each other as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> increases. From this I suspect that you can reconstruct the norm without too much trouble. But all this seems like a bit of a crazy detour.</p>",
        "id": 501630654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740425296
    },
    {
        "content": "<p>I'm not saying the norm should be <em>defined</em> that way. Just that it shouldn't be part of the definition. If the definition can be a <code>Prop</code>, then I think that is a win.</p>",
        "id": 501633443,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1740426232
    },
    {
        "content": "<p>(Just like we should have a Prop-version of <code>RCLike</code>.)</p>",
        "id": 501633546,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1740426255
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsRCLikeNormedField#doc\">docs#IsRCLikeNormedField</a></p>",
        "id": 501634338,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740426517
    },
    {
        "content": "<p>Sorry, <span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> and I just saw this discussion. We have indeed several definitions of local fields that we are working with. First, in our paper <a href=\"https://dl.acm.org/doi/abs/10.1145/3636501.3636942?casa_token=PiUVC-8MQbUAAAAA%3AB8kdVfmlgWZCjkzqg75uxSMKyO-jTwFfLbGR2RTqG9NJ99ZCNlJ7WuoGhtnJPOn_53SwJwBEhQupzqVS\">A Formalization of Complete Discrete Valuation Rings and Local Fields</a> we defined mixed and equal characteristic local fields as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Q_p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">adicCompletion</span><span class=\"w\"> </span><span class=\"n\">‚Ñö</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pHeightOneIdeal</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- A mixed characteristic local field is a field which has characteristic zero and is finite</span>\n<span class=\"sd\">dimensional over `Q_p p`, for some prime `p`. -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MixedCharLocalField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n<span class=\"w\">    </span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q_p</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">to_finiteDimensional</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q_p</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FpXCompletion</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">idealX</span><span class=\"w\"> </span><span class=\"n\">ùîΩ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">adicCompletion</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RatFunc</span><span class=\"w\"> </span><span class=\"n\">ùîΩ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span>\n\n<span class=\"sd\">/-- An equal characteristic local field is a field which is finite</span>\n<span class=\"sd\">dimensional over `ùîΩ_p((X))`, for some prime `p`. -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">EqCharLocalField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n<span class=\"w\">    </span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FpXCompletion</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">to_finiteDimensional</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FpXCompletion</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>We also provide a <code>ValuedLocalField</code> class and prove that mixed and equal characteristic local fields are <code>ValuedLocalField</code>s. In this class, we are endowing the field with its normalized <code>Z_m0</code>-valued valuation.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">ValuedLocalField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Valued</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">‚Ñ§‚Çò‚ÇÄ</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">complete</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">K</span>\n<span class=\"w\">  </span><span class=\"n\">isDiscrete</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsDiscrete</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">‚Ñ§‚Çò‚ÇÄ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">finiteResidueField</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsLocalRing</span><span class=\"bp\">.</span><span class=\"n\">ResidueField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">‚Ñ§‚Çò‚ÇÄ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">valuationSubring</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>We have recently been experimenting with how best to define a local field without fixing a valuation, as well as adding (non)archimedean versions. Our current definitions are as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">LocalField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">UniformSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">UniformAddGroup</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">,</span>\n<span class=\"w\">  </span><span class=\"n\">TopologicalDivisionRing</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">LocallyCompactSpace</span><span class=\"w\"> </span><span class=\"n\">K</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">NonarchLocalField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">LocalField</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">isNonarchimedean</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsNonarchimedean</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">haarFunction</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">ArchLocalField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">LocalField</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Archimedean</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">haarFunction</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The <code>haarFunction</code> is the multiplier function defined in Serre's \"Local Fields\" Chapter 2, Proposition 2.</p>",
        "id": 509393084,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1743496919
    },
    {
        "content": "<p>I'm not sure I will be very helpful, but Bourbaki, General Topology, Chapter 9, Exercise ¬ß4.12 gives a topological characterization topological fields whose topology is defined by an absolute value. <br>\nIt applies in particular for locally compact fields. So one could imagine setting topological assumptions, and picking up whatever absolute value fits your needs.</p>\n<p><a href=\"/user_uploads/3121/tApvHjgiZchWIDPewYqZtxrY/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/tApvHjgiZchWIDPewYqZtxrY/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"367x152\" src=\"/user_uploads/thumbnail/3121/tApvHjgiZchWIDPewYqZtxrY/image.png/840x560.webp\"></a></div>",
        "id": 509558785,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1743546530
    },
    {
        "content": "<p>I like Serre's taste and in Cassels-Froehlich he defines a local field to be a field equipped with a discrete valuation such that it's complete and the residue field is finite, so I like <code>ValuedLocalField</code>. I'm wondering whether we should just get this definition into mathlib, and then all the other stuff like proving that certain locally compact fields have this property or proving that the valuation can be recovered from the topology or whatever can come later; my feeling is that <code>ValuedLocalField</code> is a good \"middle ground\". </p>\n<p>Maria Ines is your <code>haarFunction</code> the same as FLT's <code>distrbHaarChar</code>? <a href=\"https://github.com/ImperialCollegeLondon/FLT/blob/main/FLT/HaarMeasure/DistribHaarChar/Basic.lean\">https://github.com/ImperialCollegeLondon/FLT/blob/main/FLT/HaarMeasure/DistribHaarChar/Basic.lean</a> We should also try and get something like this into mathlib because we don't want to duplicate work. I wrote a chunk of blueprint about these characters: <a href=\"https://imperialcollegelondon.github.io/FLT/blueprint/Haar_char_project.html\">https://imperialcollegelondon.github.io/FLT/blueprint/Haar_char_project.html</a></p>",
        "id": 509563090,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743548694
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> I am happy with Maria Ines' definition of <code>ValuedLocalField</code> as a proposed definition for mathlib, so we can get the ball rolling. Are you?</p>\n<p>In the Class Field Theory workshop in Oxford Richard Hill and I are going to try and define the Artin map via the group cohomology approach (and not touch Lubin-Tate formal groups).</p>",
        "id": 509563327,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743548809
    },
    {
        "content": "<p>I don't absolutely agree with the definition taken for local fields in prime characteristic, because it requires to choose an <code>X</code> to view it as a finite extension of <code>k((X))</code>.<br>\nAlso, does the valuation have to be normalized? If yes, what happens for extensions?</p>",
        "id": 509571571,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1743553217
    },
    {
        "content": "<p>I would rather have a definition that uses minimal data, and use that in all statements that don't need the data. And then also have definitions or tactics that easily allow you to scale up the amount of data inside a proof, when needed.</p>\n<p>A similar thing is done with Polish spaces in mathlib, and it seems to work well. Whenever you need a metric, it's a 1-line step at the start of the proof.</p>\n<p>Having minimal data will avoid all sorts of nasty diamond issues, for example about extensions.</p>",
        "id": 509595042,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1743566140
    },
    {
        "content": "<p>Dear All, thanks for your comments on our work. Some more detailed answers:</p>\n<ul>\n<li><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> : we thought about starting off with nilpotent elements, and live without a predetermined uniformity, but this ended up creating more diamonds than other, because a commutative topological group comes with a uniformity, and this is unique. So, following the suggestion <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Algebra/IsUniformGroup/Defs.html#Uniform-structure-on-topological-groups\">here</a> we decided to put the uniformity structure in the definition of <code>LocalField</code>. This should also address the first of <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> 's question: our definition only contains the data of the uniformity (and of a field...) but all the other extended fields are <code>Prop</code>-valued.</li>\n<li><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> again: concerning your objection about <code>K((X))</code>, we agree that fixing the place at infinity in this way is really not optimal. But the right way of doing it would be to develop a sensible notion of <code>K</code>-curves and to work with the field of rational functions on them, I believe. Since most of the results one might have in mind should be provable irrespectively that the field be of equal/mixed characteristic, we provide the class mainly so that if someone encounters a finite extension of <code>K((X))</code>, the API for local fields becomes accessible, but I agree this will need to change on the long run.</li>\n<li><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> beyond your point of avoiding data as much as possible, we agree but the comparison with Polish spaces is not 100% accurate: for a local field, there exists a preferred valuation, coming from the maximal ideal (and normalized so as to send generators of this to <code>1</code>). That being said, we can think at removing some data even from <code>ValuedLocalField</code>, but this definition turns out in our experience to work quite well both for finite/infinite extensions and we think that the way we set up things is quite diamond-safe.</li>\n<li><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Our definition of <code>ValuedLocalField</code>  is <em>almost</em> ready to go: in the sense that the definition itself can enter mathlib, but for the API we built around it we need some basic theory of (complete) DVR's, for which there are open PR's that are not yet merged. Concerning the Haar multiplier, I'll have a look later but I think it is indeed the same.</li>\n</ul>\n<p>All in all, our strategy was to set up an abstract notion (<code>LocalField</code>) that is pretty general, and almost data-free, but not terribly useful; and an accompanying one <code>ValuedLocalField</code>, that contains more data but is very useful and plays well with the API for DVR's; and of course to show they're equivalent. The classes <code>MixedChar.LocalField</code>, and <code>EqualChar.LocalField</code> are there mainly to show that the <code>ValuedLocalField</code> definition makes sense and it is a workable one; and<code>NonarchimedeanLocalField</code> and <code>ArchimedeanLocalField</code>  are there with a view towards Ostrowski.</p>\n<p>Concerning the PR process, as said, the definition is ready, but to provide a nice API we are opening the PR's to first set up a good theory for complete DVR's (and extensions theoreof).</p>",
        "id": 509620342,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743578784
    },
    {
        "content": "<p>Sounds like a good plan to me.</p>",
        "id": 509620994,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1743579007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/509563090\">said</a>:</p>\n<blockquote>\n<p>Maria Ines is your <code>haarFunction</code> the same as FLT's <code>distrbHaarChar</code>? <a href=\"https://github.com/ImperialCollegeLondon/FLT/blob/main/FLT/HaarMeasure/DistribHaarChar/Basic.lean\">https://github.com/ImperialCollegeLondon/FLT/blob/main/FLT/HaarMeasure/DistribHaarChar/Basic.lean</a> We should also try and get something like this into mathlib because we don't want to duplicate work.</p>\n</blockquote>\n<p>Sorry I dropped the ball there. Let me PR more stuff now</p>",
        "id": 509626528,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1743580709
    },
    {
        "content": "<p>Note that we also have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure.modularCharacterFun#doc\">docs#MeasureTheory.Measure.modularCharacterFun</a> with the same flavor (which is not in the right namespace because it does not depend on the choice of a measure, by the way)</p>",
        "id": 509631436,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1743582147
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> This was the first thing I tried, but it turns out this is not really what we need, because it only treats <em>translation by an element in the group</em>. In our case, it is the units of a (comm) ring acting (multiplicatively) on the additive group of the ring, so what I was doing was to adapt the argument to a <code>HasMeasurableSMul</code> setting.</p>",
        "id": 509635337,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743583236
    },
    {
        "content": "<p>Yes, it's definitely not the same thing! But it has the same flavor, so I wonder if there is a common generalisation, or at least if the API or constructions should be parallel.</p>",
        "id": 509636141,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1743583503
    },
    {
        "content": "<p>Yes, this is what I did for FLT too</p>",
        "id": 509636150,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1743583504
    },
    {
        "content": "<p>My hope was to deduce the <code>modularCharacterFun</code> from a general <code>MeasureableSMul</code> setting, in the special case when a group acts on itself. Perhaps I should coordinate with <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> if they've already thought about this (aka: if they've already finished doing all the work <span aria-label=\"smirk\" class=\"emoji emoji-1f60f\" role=\"img\" title=\"smirk\">:smirk:</span> )</p>",
        "id": 509636542,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743583615
    },
    {
        "content": "<p>I believe <a href=\"https://imperialcollegelondon.github.io/FLT/docs/FLT/HaarMeasure/DistribHaarChar/Basic.html#MeasureTheory.Measure.distribHaarChar\"><code>distribHaarChar</code> from FLT</a> is already more general than <code>modularCharacterFun</code></p>",
        "id": 509636745,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1743583671
    },
    {
        "content": "<p>(up to possible mismatches in convention)</p>",
        "id": 509636827,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1743583684
    },
    {
        "content": "<p>I'll have a look later today and will come back to you (but will be happy to hear from <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> if he agrees with <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> that we can move on as planned insofar <code>ValuedLocalField</code> is concerned).</p>",
        "id": 509637136,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743583791
    },
    {
        "content": "<p>In <code>modularCharacterFun</code>, there is only a multiplicative group, no additive group, so I don't see how it follows from <code>distribHaarChar</code>.</p>",
        "id": 509637234,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1743583811
    },
    {
        "content": "<p>Ah yes sorry I misremembered. The crucial difference is the use of <code>DistribMulAction</code> instead of <code>MulAction</code></p>",
        "id": 509637712,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1743583924
    },
    {
        "content": "<p>Would <a href=\"https://github.com/leanprover-community/mathlib4/pull/16733\">#16733</a> still be applicable here? It's sat around for a couple of months now.</p>",
        "id": 509702019,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1743601444
    },
    {
        "content": "<p>Yes definitely! At some point someone is going to have to PR a definition and my main desire is that this happens quickly, despite the fact that different people seem to have different ideas about what that definition should be. Once the decision is made, we will then have to prove that it's the same as all the other definitions, and your PR will definitely be helpful at this point!</p>",
        "id": 509704228,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743602012
    },
    {
        "content": "<p>Yes, I agree. I think that <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> 's PR will be extremely useful to prove the equivalence <code>LocalField iff ValuedLocalField</code>. On the other hand, we take a slightly different approach, so what I'd suggest is that once everything is ready to PR the definition of<code>ValuedLocalFields</code>, we merge both PR's and use his to prove the equivalence. This should not take long, and I am happy to take a look at your PR in the meanwhile.</p>",
        "id": 509705289,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743602254
    },
    {
        "content": "<p>Great, thanks for the info! Is there anything I can do to help prepare/align on approaches? For example, I'm working on generalizing nonarchimedean metric spaces to nonarchimedean uniformities, which would allow us to have a common prop typeclass <code>IsUltraUniformity</code> that applies to rank-not-necessarily-one valued fields, and such that no particular normalization is required.</p>",
        "id": 509706066,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1743602417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/509706066\">said</a>:</p>\n<blockquote>\n<p>Great, thanks for the info! Is there anything I can do to help prepare/align on approaches? For example, I'm working on generalizing nonarchimedean metric spaces to nonarchimedean uniformities, which would allow us to have a common prop typeclass <code>IsUltraUniformity</code> that applies to rank-not-necessarily-one valued fields, and such that no particular normalization is required.</p>\n</blockquote>\n<p>Sure, let's discuss this in a DM with also <span class=\"user-mention\" data-user-id=\"406490\">@Mar√≠a In√©s de Frutos Fern√°ndez</span> .</p>",
        "id": 509706365,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743602475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/509704228\">said</a>:</p>\n<blockquote>\n<p>Yes definitely! At some point someone is going to have to PR a definition and my main desire is that this happens quickly, despite the fact that different people seem to have different ideas about what that definition should be. Once the decision is made, we will then have to prove that it's the same as all the other definitions, and your PR will definitely be helpful at this point!</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I do not have the impression that there are many different points of view: my take of the above discussion is that there was some consensus in what <span class=\"user-mention\" data-user-id=\"406490\">@Mar√≠a In√©s de Frutos Fern√°ndez</span> and myself are doing, no? Did I misunderstand it? Unfortunately most of our work needs PR's that have been waiting for weeks to be reviewed.</p>",
        "id": 509706718,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743602550
    },
    {
        "content": "<p>I do not look at the queueboard, but if you believe some of your PRs are within my competence then request my review and they shall be reviewed</p>",
        "id": 509707037,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1743602631
    },
    {
        "content": "<p>OK, thanks!</p>",
        "id": 509707727,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743602769
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/509626528\">said</a>:</p>\n<blockquote>\n<p>Sorry I dropped the ball there. Let me PR more stuff now</p>\n</blockquote>\n<p>First PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/23595\">#23595</a></p>",
        "id": 509746922,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1743612332
    },
    {
        "content": "<p>and now <a href=\"https://github.com/leanprover-community/mathlib4/pull/23596\">#23596</a></p>",
        "id": 509757438,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1743615626
    },
    {
        "content": "<p>By the way, I mentioned this work to another number theorist last week and they pointed out that Weil developed the basic theory in his \"Basic number theory\". I've just looked up what he calls this character (because we just made up <code>distribHaarChar</code> and I thought it was better to switch to the name in the literature) but unfortunately Weil calls it the \"module\" of the automorphism!</p>\n<p><a href=\"/user_uploads/3121/_IxDjtuyKzCajVOcFcznOV9x/Screenshot-from-2025-04-02-21-49-25.png\">Screenshot from 2025-04-02 21-49-25.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/_IxDjtuyKzCajVOcFcznOV9x/Screenshot-from-2025-04-02-21-49-25.png\" title=\"Screenshot from 2025-04-02 21-49-25.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"745x426\" src=\"/user_uploads/thumbnail/3121/_IxDjtuyKzCajVOcFcznOV9x/Screenshot-from-2025-04-02-21-49-25.png/840x560.webp\"></a></div><p>I think we might be better off sticking to our name :-/</p>",
        "id": 509791169,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743626990
    },
    {
        "content": "<p>Iirc the module terminology is also used in Bushnell Henniart</p>",
        "id": 509861707,
        "sender_full_name": "Micha≈Ç Mruga≈Ça",
        "timestamp": 1743664835
    },
    {
        "content": "<p>Modulus would be a reasonable alternative</p>",
        "id": 509903060,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1743677244
    },
    {
        "content": "<p>Back to the point, can someone propose a definition of <code>LocalField</code> or <code>IsLocalField</code> which we agree is the one we want in mathlib?</p>",
        "id": 510009499,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743704652
    },
    {
        "content": "<p>how about </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">LocalField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kd\">extends</span>\n<span class=\"w\">  </span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">LocallyCompactSpace</span><span class=\"w\"> </span><span class=\"n\">F</span>\n</code></pre></div>\n<p>(or just use those two existing classes as mixins?).</p>",
        "id": 510010839,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1743705075
    },
    {
        "content": "<p>Yeah, no need to have a new class there (especially since the second class is just a Prop mixin)</p>",
        "id": 510012951,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1743705728
    },
    {
        "content": "<p>We proposed</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">LocalField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">UniformSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">UniformAddGroup</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">,</span>\n<span class=\"w\">  </span><span class=\"n\">TopologicalDivisionRing</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">LocallyCompactSpace</span><span class=\"w\"> </span><span class=\"n\">K</span>\n</code></pre></div>\n<p>above to avoid having to pick a norm.</p>",
        "id": 510014746,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1743706327
    },
    {
        "content": "<p>It‚Äôs not clear to me that we would want to pick a topology without picking a norm.</p>",
        "id": 510018538,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1743707502
    },
    {
        "content": "<p>If <code>IsLocalField</code> means <code>Nonempty LocalField</code>, then I think we would want <code>LocalField</code> to have a norm.</p>",
        "id": 510018954,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1743707642
    },
    {
        "content": "<p>Actually with my proposal <code>IsLocalField</code> can‚Äôt just be <code>Nonempy LocalField</code> because NontriviallyNormedField bundles the field structure.</p>",
        "id": 510019373,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1743707775
    },
    {
        "content": "<p>So the two definitions are equivalent; from an instance of Adam's class you can get an instance of Maria Ines', and then by this Bourbaki exercise which Antoine posted you can get an instance of Adam's from an instance of Maria Ines'. Have I got this right? And so the question basically is whether we want to demand a metric or a topology.</p>",
        "id": 510044200,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743717556
    },
    {
        "content": "<p>Yes the two are equivalent, and the norm is uniquely determined (up to equivalence) by the field structure alone!</p>",
        "id": 510047133,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1743719165
    },
    {
        "content": "<p>My perspective is that in practice we won‚Äôt ever want the topology without the norm, and if we have the norm, the topology is included as well.</p>",
        "id": 510047193,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1743719211
    },
    {
        "content": "<p>I guess one thing which the topology definition has which the norm doesn't have is that isomorphic local fields really will be isomorphic, but you might have two equivalent-but-not-equal norms on the same field. Do we have equivalence of norms?</p>",
        "id": 510048324,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743719855
    },
    {
        "content": "<p>I'm not sure this bothers me really though, and indeed for finite extensions of Q_p there are two equally \"canonical\" but distinct norms, depending on whether you want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚à£</mi><mi>œñ</mi><mi mathvariant=\"normal\">‚à£</mi><mo>=</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">|\\varpi|=1/q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">œñ</span><span class=\"mord\">‚à£</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span></span></span></span> (the \"module\") or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚à£</mi><mi>p</mi><mi mathvariant=\"normal\">‚à£</mi><mo>=</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">|p|=1/p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\">p</span><span class=\"mord\">‚à£</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\">p</span></span></span></span> (the one giving compatibility with the usual norm on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>). So probably it would be nice to be able to talk about both rather than \"the norm constructed by the Bourbaki exercise probably also using some random choice\"</p>",
        "id": 510048492,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743719944
    },
    {
        "content": "<p>Do we even have a type of isomorphisms of normed fields?</p>",
        "id": 510051024,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1743721334
    },
    {
        "content": "<p>As soon as the norm defines its topology (and/or its uniform structure), you'll be fine with it.</p>",
        "id": 510056596,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1743724629
    },
    {
        "content": "<p>Even on the complex numbers you have various equivalent norms. (You can take the standard norm to the power <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Œµ</mi></mrow><annotation encoding=\"application/x-tex\">\\varepsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">Œµ</span></span></span></span>, for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>Œµ</mi><mo>‚â§</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0&lt;\\varepsilon\\leq 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">Œµ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚â§</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>.)</p>",
        "id": 510056883,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1743724767
    },
    {
        "content": "<p>The module has <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Œµ</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\varepsilon=2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">Œµ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>!</p>",
        "id": 510106220,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743750333
    },
    {
        "content": "<p>One of the mathematical reasons we did not want to pick a norm is what <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> mentioned, about two possible reasonable normalisations, both with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚à£</mi><mi>p</mi><mi mathvariant=\"normal\">‚à£</mi><mo>=</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">\\vert p\\vert=1/p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\">p</span><span class=\"mord\">‚à£</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\">p</span></span></span></span> or with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚à£</mi><mi>œñ</mi><mi mathvariant=\"normal\">‚à£</mi><mo>=</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">\\vert \\varpi\\vert = 1/p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">œñ</span><span class=\"mord\">‚à£</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\">p</span></span></span></span>. One \"mathlib\"-reason we wanted to avoid the norm is that we might want to speak about general complete non-archimedean fields (like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">C</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>) and to be able to upgrade them to locals field as soon as they are locally compact, eg when their residue field is finite. With <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> 's definition this seems more complicated.</p>",
        "id": 510112090,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743752488
    },
    {
        "content": "<p>Your first point I think boils down to whether you want the two copies of same field with two distinct equivalent norms to be equal or not, and I'm not sure in practice if we're going to care about this because equality of types isn't really a thing. A general nonarchimedean field has a real-valued norm so I don't understand your second point</p>",
        "id": 510113897,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743753094
    },
    {
        "content": "<p>A general nonarch field is not locally compact unless the residue field is finite; now, if you want to have a general class <code>Nonarch</code> of which <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">C</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> is an instance, and then to prove the </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonarch</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ResidueField</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LocalField</span><span class=\"w\"> </span><span class=\"n\">F</span>\n</code></pre></div>\n<p>how can you do this if <code>LocalField</code> is as in Adam's definition?</p>",
        "id": 510114493,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743753289
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/510113897\">said</a>:</p>\n<blockquote>\n<p>Your first point I think boils down to whether you want the two copies of same field with two distinct equivalent norms to be equal or not, and I'm not sure in practice if we're going to care about this because equality of types isn't really a thing. A general nonarchimedean field has a real-valued norm so I don't understand your second point</p>\n</blockquote>\n<p>Yes, I understand your \"equality of types is not a thing\", but I find it slightly awkward to have two types for the same field, it worries me that it can create troubles if we prove things for one and not for the other. In particular, if you define a valuation using the norm, and then you want to say that the valuation of a uniformiser is <code>-1</code> (in Multiplicative Z), this is only true for one of the two definitions and not the other.</p>",
        "id": 510114959,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743753440
    },
    {
        "content": "<p>Do you <em>really</em> need a definition of local fields? Why not just develop the theory assuming <code>[NontriviallyNormedField k] [LocallyCompactSpace k]</code> (which should be the right assumptions 99% of the time), and if you want to apply such a theorem to a field which doesn't have a norm, then apply the theorem saying there is a compatible norm on the field?</p>",
        "id": 510116030,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1743753782
    },
    {
        "content": "<p>In particular, the example with <code>Nonarch</code> would just be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonarch</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ResidueField</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LocallyCompactSpace</span><span class=\"w\"> </span><span class=\"n\">K</span>\n</code></pre></div>",
        "id": 510116391,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1743753893
    },
    {
        "content": "<p>I can think about it, but what is the downside of the definition we propose with <span class=\"user-mention\" data-user-id=\"406490\">@Mar√≠a In√©s de Frutos Fern√°ndez</span> ? Just to compare pros and cons.</p>",
        "id": 510117389,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743754195
    },
    {
        "content": "<p>If you don't have a norm, a bunch of analysis is not available (including calculus, or good behavior of the space of continuous linear maps or continuous bilinear maps). And just using Prop mixins on top of <code>[NontriviallyNormedField K]</code> ensures you will never get any kind of diamond.</p>",
        "id": 510118304,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1743754443
    },
    {
        "content": "<p>I see, but I wonder if there is any analytical result we want to prove about general local fields, irrespectively of them being archimedean or nonarchimedean. But I understand your point.</p>",
        "id": 510118756,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743754584
    },
    {
        "content": "<p>Re: \"why define local fields at all?\": The reason I want a definition of local fields is that local fields are a thing. Serre wrote an entire book called \"Corps locaux\". I'm running a summer school in October where we will develop the class field theory of local fields. More to the point, I am scared that Adam will start developing some API using one definition and Filippo will start developing API using another one, and then it's the representation theory car crash all over again. </p>\n<p>If our conventions are fighting against having a definition of local fields (just as they fight against us having a definition of vector spaces and of unique factorisation domains) then I think this is a little sad. I do take your point that this is what the conventions are pushing us to do. But I can see downsides to this.</p>",
        "id": 510126674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743756870
    },
    {
        "content": "<p>Filippo, the downside of your definition is that the entire theory is developed assuming that a norm exists.</p>",
        "id": 510126963,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743756960
    },
    {
        "content": "<p>And I still don't understand your Nonarch question. Firstly there is a (probably irrelevant) mathematical point that it's not true that a nonarch field with finite residue field is locally compact (think about the completion of the cyclotomic extension of Qp). But secondly I don't see the problem at all in using Adam's definition once the theorem is correctly stated. What are you worried about? You just have to prove a theorem in topological ring theory. It's much harder to construct the norm from the topology and also very artificial.</p>",
        "id": 510127877,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743757199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/510126963\">said</a>:</p>\n<blockquote>\n<p>Filippo, the downside of your definition is that the entire theory is developed assuming that a norm exists.</p>\n</blockquote>\n<p>Well, this is why we provide the class <code>ValuedLocalField</code>, which is the one we suggest to work with most of the time in the nonarch case. This <code>LocalField</code> only serves at unifying archimedean and nonarchimedean fields, but I'd say that 90% of Serre's book focuses on the nonarchimedean case, for which <code>ValuedLocalField</code> (with its valuation &lt;-&gt; norm) does the job.</p>",
        "id": 510128082,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743757243
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/510127877\">said</a>:</p>\n<blockquote>\n<p>And I still don't understand your Nonarch question. Firstly there is a (probably irrelevant) mathematical point that it's not true that a nonarch field with finite residue field is locally compact (think about the completion of the cyclotomic extension of Qp). But secondly I don't see the problem at all in using Adam's definition once the theorem is correctly stated. What are you worried about? You just have to prove a theorem in topological ring theory. It's much harder to construct the norm from the topology and also very artificial.</p>\n</blockquote>\n<p>For the math question, it depends on what you call nonarch (I thought it also have discrete in it), but that's not the point, I believe we agree on the math. All in all, I certainly agree we do not want to develop two different concurrent works, so I'd take a moment to reflect upon all this and to discuss with Mar√≠a In√©s.</p>",
        "id": 510128685,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743757421
    },
    {
        "content": "<p>I think I should just note the bottom line here: I don't care what the definition is or even if we have a definition. What I care about is that we do <em>not</em> have a bunch of API written for two or more competing definitions and this is why I think it's important that the community at least decides which definition will have the API built for it. I should say to Filippo that yes I only care about the nonarch case, the people interested in reals and complexes will just use \\R and \\C anyway, and the small amount of work necessary to extend this stuff to the third Archimedean local field, namely an algebraic closure of R with no preferred square root of -1, won't be too hard.</p>",
        "id": 510128946,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743757490
    },
    {
        "content": "<p>Concerning multiple definitions: as long as there is a hierarchy, it shouldn't be a problem. An instance from one to the other is good. But if they are <em>competing</em>, and it cause a bifurcation, then that is bad.</p>",
        "id": 510129820,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1743757756
    },
    {
        "content": "<p>So let me give a concrete example so that we have something concrete to talk about rather than classes like <code>Nonarch</code> which don't actually exist. Right now I need: given <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> a nonarch local field and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> a positive natural, I want the degree <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> unramified extension of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, equipped with the canonical isomorphism of its Galois group with the Galois group of the residue field (i.e. existence), I want uniqueness (given two unramified extensions of the same degree, they're isomorphic) and I want the theory to apply to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>, to Filippo/Maria-Ines' definition, to Adam's definition, and to $$k((X))$ for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> a finite field. Obviously that will take a while. But what I want to <em>avoid</em> is someone saying they've \"done the construction\" but the construction not being applicable in every possible case where people might want to use it. So what should the <em>existence</em> part of this claim look like?</p>",
        "id": 510139017,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743760341
    },
    {
        "content": "<p>Need to run now, but either <span class=\"user-mention\" data-user-id=\"406490\">@Mar√≠a In√©s de Frutos Fern√°ndez</span> or myself will answer soon with what we've currently got in mind, on which we've been working the last two weeks, so we have a bit of code to share.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/510139017\">said</a>:</p>\n<blockquote>\n<p>So let me give a concrete example so that we have something concrete to talk about rather than classes like <code>Nonarch</code> which don't actually exist. Right now I need: given <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> a nonarch local field and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> a positive natural, I want the degree <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> unramified extension of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, equipped with the canonical isomorphism of its Galois group with the Galois group of the residue field (i.e. existence), I want uniqueness (given two unramified extensions of the same degree, they're isomorphic) and I want the theory to apply to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>, to Filippo/Maria-Ines' definition, to Adam's definition, and to $$k((X))$ for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> a finite field. Obviously that will take a while. But what I want to <em>avoid</em> is someone saying they've \"done the construction\" but the construction not being applicable in every possible case where people might want to use it. So what should the <em>existence</em> part of this claim look like?</p>\n</blockquote>",
        "id": 510139887,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743760575
    },
    {
        "content": "<p>Is this what it should look like?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">LocallyCompactSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">NonarchimedeanRing</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ResidueCharacteristic</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- get p from K</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">UnramifiedExtension</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">UnramifiedExtension</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">UnramifiedExtension</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 510140707,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743760835
    },
    {
        "content": "<p>We actually use the language of Galois insertions, but if you can wait until this afternoon there will be more details (I am really sorry, I am running... <span aria-label=\"runner\" class=\"emoji emoji-1f3c3\" role=\"img\" title=\"runner\">:runner:</span> )</p>",
        "id": 510141214,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743760991
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , I'm finally back. So: most of our results with <span class=\"user-mention\" data-user-id=\"406490\">@Mar√≠a In√©s de Frutos Fern√°ndez</span>  are <a href=\"https://github.com/mariainesdff/LocalClassFieldTheory/blob/master/LocalClassFieldTheory/LocalField/GaloisConnection.lean\">in this file</a> but we must warn you that is is <strong>very much</strong> WIP.</p>\n<p>What we're doing is to</p>\n<ol>\n<li>set up a Galois insertion+coinsertion between the intermediate fields in a tower <code>L/K</code> and and integrally closed <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>K</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">K</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-subalgebras of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>L</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">L</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, where <code>K</code> is a <code>ValuedLocalField</code> (in our mind, the structure really representing nonarchimedean local fields); and <code>L</code> is a (complete?) topological field with a valuation extending that of <code>K</code>.</li>\n<li>Set up a Galois coinsertion between extensions of the residue field of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> and integrally closed <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>K</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">K</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-subalgebras of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>L</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">L</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</li>\n<li>Show that the above is also a Galois <em>insertion</em> when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>L</mi></msub><mi mathvariant=\"normal\">/</mi><msub><mi mathvariant=\"script\">O</mi><mi>K</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_L/\\mathcal{O}_K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">L</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">K</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.Etale#doc\">docs#Algebra.Etale</a>.</li>\n</ol>\n<p>As you observe, we systematically work in the setting where we've fixed an ambient extensions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, and this for two reasons:</p>\n<ol>\n<li>The unramified extensions will at any rate be unique only once we fix a separable/algebraic extension of the base field</li>\n<li>From a more mathlib-point of view: it would be highly desirable that finite extensions of (valued) local fields are again local fields. This can clearly be a <code>theorem</code> (or <code>def</code> depending on what we end up with as a class, for the time being our <code>ValuedLocalField</code> carries data, so rather a <code>def</code>); but it cannot be an instance for the same reason as finite extensions of number fields don't have an instance of number field. We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NumberField.of_module_finite#doc\">docs#NumberField.of_module_finite</a> showing this is the case (as a <code>theorem</code>) but to have a nice instance we need to live in a pre-fixed ambient extension, as in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NumberField.of_intermediateField#doc\">docs#NumberField.of_intermediateField</a>. The reason is the type-class inference cannot pick up <code>K</code> from the mere knowledge of <code>L</code>, so it cannot start looking for a <code>Finite K L</code> instance; whereas if the gadget has type <code>IntermediateField K L</code>, both <code>K</code> and <code>L</code> are known to type-class inference, and everything goes smoothly.</li>\n</ol>\n<p>To reconnect all this with the previous discussion, one of the reasons we want to be able to have nice classes describing fields like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">C</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> that yield instances of <code>ValuedLocalField</code> when adding the assumption <code>FiniteResidueField</code> is that we'd like to apply the above setting to (the completion of) a separable/algebraic closure, so that for every finite extension of the residue field of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> the Galois coinsertion yields your unramified extension contained in the fixed separable/algebraic closure. If you really want to get this for a specified degree you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/FieldTheory/Finite/GaloisField.html#GaloisField.algEquivGaloisFieldOfFintype\">GaloisField.algEquivGaloisFieldOfFintype</a> or some variation thereof.</p>",
        "id": 510213936,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743776016
    },
    {
        "content": "<p>Surely the relationship between the intermediate fields and the integrally-closed subalgebras in (1) is an order-preserving bijection, which is much stronger than a Galois insertion. Or am I missing something? Again finite residue field is not enough to give a local field, you need discreteness of the valuation. </p>\n<p>If you want to do it this way you will presumably need some way of saying \"I am the residue field of you\" for abstract fields <code>k</code> and <code>K</code>, so it applies for <code>ZMod p</code> and the p-adic numbers, or for a finite field and the field of fractions of its Witt vectors. How are you doing this?</p>",
        "id": 510216742,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743776707
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/510216742\">said</a>:</p>\n<blockquote>\n<p>Surely the relationship between the intermediate fields and the integrally-closed subalgebras in (1) is an order-preserving bijection, which is much stronger than a Galois insertion. Or am I missing something? Again finite residue field is not enough to give a local field, you need discreteness of the valuation. </p>\n<p>If you want to do it this way you will presumably need some way of saying \"I am the residue field of you\" for abstract fields <code>k</code> and <code>K</code>, so it applies for <code>ZMod p</code> and the p-adic numbers, or for a finite field and the field of fractions of its Witt vectors. How are you doing this?</p>\n</blockquote>\n<p>You're right that this is an order-preserving bijection, which will <em>give us</em> the coinsertion (and of course we'd implement first the order-preserving bijection); the second part is only a Galois (co)-insertion, so for the whole business of going from intermediate extensions of the local field and those of the residue field, that's the only bit that matters. Concerning finite residue fields vs. discreteness, again: we agree on the math, and currently our definition of <code>ValuedLocalField</code>  contains <code>IsDiscrete</code> for the valuation (see the above code posted by Mar√≠a In√©s).</p>",
        "id": 510217525,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743776918
    },
    {
        "content": "<p>For your second question: our way to speak about the residue field of a local field is to take the unit ball (= valuation subring) and the residue field of this (since it has a local ring instance); but I feel this is not really your question, so I haven't probably understood it.</p>",
        "id": 510217722,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743776984
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/510216742\">said</a>:</p>\n<blockquote>\n<p>an order-preserving bijection, which is much stronger than a Galois insertion.</p>\n</blockquote>\n<p>These are incomparable? Unless you actually meant¬†<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderIso#doc\">docs#OrderIso</a>, which is stronger than a monotone bijection.</p>",
        "id": 510218969,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743777305
    },
    {
        "content": "<p>Oh so we are now talking about <code>ValuedLocalField</code> not <code>NonarchLocalField</code>?</p>\n<p>These two classes represent the same mathematical objects, right? Are you developing API for both of them? This is exactly what I want to avoid.</p>",
        "id": 510218978,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743777307
    },
    {
        "content": "<p>No: we're developing API only for ValuedLocalField; we are <em>defining</em> the structure <code>NonarchLocalField</code>(which we don't even know whether we want to promote to a class) simply to be able to state some nice form of Ostrowsky. But as said the only gadget that we study (vis. that we consider the \"right/useful\" formalisation of what Serre calls local fields) is <code>ValuedLocalField</code>.</p>",
        "id": 510219321,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743777398
    },
    {
        "content": "<p>In which case can you PR the definition so that we can establish that this is the definition the community is happy with? Otherwise things are going to get really complicated. I personally don't like the name, for example; nobody in the real world calls these things \"valued local fields\", they all call them \"nonarchimedean local fields\".</p>",
        "id": 510220129,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743777625
    },
    {
        "content": "<p>Oh, for that matter we're more than happy to change the name <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 510220288,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743777665
    },
    {
        "content": "<p>I will reiterate what I've already said several times before; there are now three groups of people independently working on local fields (although me and Richard Hill are \"working on local fields\" in the sense that we are just about to start developing API and want to work fast in preparation for July; I don't know how far Adam has got) and I am really concerned that if we keep working independently rather than in mathlib (and unfortunately our repo is private right now so we can release it for the workshop, although it is also completely empty) then there will be a huge mess.</p>",
        "id": 510220695,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743777758
    },
    {
        "content": "<p>We have the same fear, and we're trying to PR things; but you know the process is slow. We are currently refactoring the definition of <code>IsDiscrete</code>, which is needed in our definition. We hope it will be done and PR'd soon (say next week?).</p>",
        "id": 510221052,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743777843
    },
    {
        "content": "<p>At first, we wanted to PR the def once we also had some API's for extensions of such gadgets, but if you tell us that you prefer the definition to land immediately and to postpone the API for extensions, let be it.</p>",
        "id": 510221196,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743777885
    },
    {
        "content": "<p>For example, we thought that the community would not accept the definition of <code>NonarchimedeanLocalField</code> if there is no def of <code>LocalField</code>, so we were trying to have a complete set of things to PR.</p>",
        "id": 510221943,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743778075
    },
    {
        "content": "<p>Yes we all know that PRing is slow. One positive thing is that FLT is my job right now and I need this stuff for FLT so I am keen to review PRs. I know that Maria Ines requested my review on <a href=\"https://github.com/leanprover-community/mathlib4/pull/23184\">#23184</a> but this is blocked on <a href=\"https://github.com/leanprover-community/mathlib4/pull/23178\">#23178</a> which is awaiting-author . If we can just get definitions in then we can start writing API and marking it <code>proof_wanted</code>; this is an underused functionality in mathlib and I think that if we want to harmonise our approach then this might be a really good use case for it. The definition will go through the usual discussion and you didn't answer the question about whether you're going to have a predicate for \"you are a nonarch local field and I am your residue field\" (like we have <code>IsLocalization</code> etc, but this seems to need more thought) which will also need some discussion, but once we have definitions in place it seems to me that we can race through a bunch of <code>proof_wanted</code> API and get it in quickly so we can see where we're going.</p>",
        "id": 510222531,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743778236
    },
    {
        "content": "<p>OK, how does it sound if we finish our refactor of what <code>IsDiscrete</code> means, we PR it and once this is done we PR the def of <code>ValuedLocalField</code> (called <code>NonarchimedeanLocalField</code>)?</p>",
        "id": 510223046,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743778391
    },
    {
        "content": "<p>Concerning the question about \" hey, I'm your residue field!\",</p>",
        "id": 510223139,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743778416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300245\">Filippo A. E. Nuccio</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/510217722\">said</a>:</p>\n<blockquote>\n<p>For your second question: our way to speak about the residue field of a local field is to take the unit ball (= valuation subring) and the residue field of this (since it has a local ring instance); but I feel this is not really your question, so I haven't probably understood it.</p>\n</blockquote>",
        "id": 510223178,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743778428
    },
    {
        "content": "<p>Furthermore if you have code then you will be well-informed about how well various definitions work. But above Maria-Ines mentioned a function <code>haarFunction</code> and the FLT version of this is already being PRed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/23603\">#23603</a> and that is going to cause you problems. The longer we wait to get down the <em>plan</em> the more times problems like this will occur. And it seems to me that you two have written far more code than anyone else so you should be writing the plan or you will be experiencing most of the pain :-/</p>",
        "id": 510223323,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743778457
    },
    {
        "content": "<p>Yes, I agree... we weren't just aware that there were many people around working on this. We are more than happy to coordinate the effort and to speed up. I hope the <code>Nonarchimedean</code> def to be PR somewhen next week, with a link to this Zulip discussion.</p>",
        "id": 510223836,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743778595
    },
    {
        "content": "<p>By \"working on it\" in my case I mean \"started thinking about it a week ago and have no code\" :-) But I think <span class=\"user-mention\" data-user-id=\"699016\">@Edison Xie</span> might also be thinking about this?</p>",
        "id": 510225967,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743779119
    },
    {
        "content": "<p>We coordinated with him and he's using the definition from our repo (but I'll let him add whatever he feels to).</p>",
        "id": 510226212,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743779178
    },
    {
        "content": "<p>Oh nice! That's one less thing to worry about then :-)</p>",
        "id": 510226331,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743779209
    },
    {
        "content": "<p>Filippo and Kevin, I think you should have a video call about that. That thread seems pretty inefficient.</p>",
        "id": 510241600,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1743783228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300245\">Filippo A. E. Nuccio</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/510226212\">said</a>:</p>\n<blockquote>\n<p>We coordinated with him and he's using the definition from our repo (but I'll let him add whatever he feels to).</p>\n</blockquote>\n<p>I'm not currently copying the definition (i.e I don't need local compact), but I think mine should just adapt to yours :)) Also not working on this tight now because I've got exams to revise and research project report to worry and after that I will adapt whatever definition that's in mathlib (if there isn't then I'm sticking to complete normed field with finite residue) <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 510303698,
        "sender_full_name": "Edison Xie",
        "timestamp": 1743807215
    },
    {
        "content": "<p>OK, I have advanced in opening some PR's getting to the definition of nonarchimedean local fields. In detail:</p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/23725\">#23725</a> contains generalities about generators of cyclic linearly ordered commutative groups.</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/23726\">#23726</a> defines non-trivial valuations.</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> refactors the definition of discrete valuation to go beyond the special case where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi><mo>=</mo><msub><mi mathvariant=\"double-struck\">Z</mi><mrow><mi>m</mi><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\Gamma=\\mathbb{Z}_{m0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, extending to more general targets.</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a> contains the definition of <code>ValuedLocalField</code>. I have well noted that <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> does not like the name, and prefers <code>NonarchLocalField</code> (say): my point in keeping this name is that I would use <code>NonarchLocalField</code> for a non-trivially normed locally compact field whose norm is non-archimedean; but for many practical purposes we have found with <span class=\"user-mention\" data-user-id=\"406490\">@Mar√≠a In√©s de Frutos Fern√°ndez</span> that the easiest class to work with is one extending <code>Valued Œì K</code>, together with the assumption that the field is complete, the valuation discrete, the residue field finite, which motivates introducing two structures and making the \"valued\"  one our \"preferred\" class.  Whether the other structure (the normed version) should also be updated to a class can be discussed later, at any rate it is not introduced in any of the above PR's. </li>\n</ul>\n<p>We're of course open to discussion and to change the name <code>ValuedLocalField</code> to something else, but in case we want to change it to <code>NonarchLocalField</code> we'd need a suggestion for a name for the other, normed structure.</p>",
        "id": 510499929,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743958302
    },
    {
        "content": "<p>Looking at</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">ValuedLocalField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Valued</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">complete</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">K</span>\n<span class=\"w\">  </span><span class=\"n\">isDiscrete</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsDiscrete</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">finiteResidueField</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">IsLocalRing</span><span class=\"bp\">.</span><span class=\"n\">ResidueField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">valuationSubring</span>\n</code></pre></div>\n<p>in <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a> , all of the fields are Props. I'm wondering whether we're digging ourselves into a hole here. Currently there is a huge effort being made to remove classes like <code>OrderedRing</code>, <code>OrderedCommRing</code>, <code>LinearOrderedRing</code> and <code>LinearOrderedCommRing</code> and replace them all with <code>IsOrderedRing</code>, a predicate which you put on top of the algebra assumption (<code>Ring</code> or <code>CommRing</code>) and the order assumption (<code>PartialOrder</code> or <code>LinearOrder</code>). This has led to a huge speedup in typeclass inference. Here things are different because Gamma is involved, but I'm wondering whether we want the algebra (<code>Field K</code>), the norm (<code>Valued K \\Gamma</code>) and then the predicate (<code>IsValuedLocalField</code>, although I think I'd rather call it <code>IsNonarchimedeanLocalField</code> or even just <code>IsLocalField</code> given that the analysts won't care about this sort of thing and the adeles has separated the arch and nonarch cases instead of trying to unify things). </p>\n<p>Here's a concrete question for an expert in typeclass inference (<span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> ?). With the above definition we have the instance</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ValuedLocalField</span><span class=\"bp\">.</span><span class=\"n\">complete</span>\n</code></pre></div>\n<p>Is this going to send typeclass inference off on some wild goose chase whenever it wants to prove that something is a complete space, looking for some ?Gamma and Valued K ?Gamma and then looking for <code>LinearOrderedCommGroupWithZero ?Gamma</code>?</p>",
        "id": 511441302,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744298733
    },
    {
        "content": "<p>The final point about sending type class inference on goose chase is a good one, haven't thought about it. I have also seen the discussion about the new efforts but haven't had time to dig into it yet. Thanks <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> for the feedback, I'll think about it while waiting for Eric's opinion.</p>",
        "id": 511452442,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1744301400
    },
    {
        "content": "<p>I think it's safe only if the second argument to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Valued#doc\">docs#Valued</a> is an outParam</p>",
        "id": 511486918,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744310819
    },
    {
        "content": "<p>Which it is! So probably it's fine, though I don't fully know the details.</p>",
        "id": 511487032,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744310864
    },
    {
        "content": "<p><code>attribute [instance] ValuedLocalField.complete</code> would be better style than making a copy as an <code>instance</code></p>",
        "id": 511487177,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744310892
    },
    {
        "content": "<p>Unfortunately outParam on Valued has a bit of an impedance mismatch because, iiuc, outParam assumes that the param is wholly determined by the other parameters, but we often have Valued K Zm0 and also Valued K NNReal, etc.</p>",
        "id": 511525488,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1744327093
    },
    {
        "content": "<p>So Filippo and Maria Ines are encouraging us away from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mrow><mi>m</mi><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\Z_{m0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and towards a general totally ordered group with zero, and Yakov is pointing out that for a nontrivial finite extension of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> one might even want to consider two different <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">R</mi><mrow><mo>‚â•</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\R_{\\geq0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9341em;vertical-align:-0.2452em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">‚â•</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2452em;\"><span></span></span></span></span></span></span></span></span></span>-valued norms (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚à£</mi><mi>p</mi><mi mathvariant=\"normal\">‚à£</mi><mo>=</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">|p|=1/p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\">p</span><span class=\"mord\">‚à£</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\">p</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚à£</mi><mi>œñ</mi><mi mathvariant=\"normal\">‚à£</mi><mo>=</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">|\\varpi|=1/q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">œñ</span><span class=\"mord\">‚à£</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span></span></span></span>) calling into question the entire <code>[Valued K Gamma]</code> set-up. But one thing I learnt from the perfectoid project was that different but equivalent valuations induce the same <em>preorder</em> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>. So how about this for a definition. It keeps the algebra and order heirarchy completely separate and joins them with a Prop-valued mixin.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsNonarchPreorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le_total</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">add_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h‚ÇÅ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"n\">mul_le_mul_right</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"n\">zero_lt_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>Then K inherits a canonical valuation to K/A, the set of cosets of A in K, where A is the element of K such that 1&lt;=a and a&lt;=1, a subgroup of K.</p>",
        "id": 511742539,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744409379
    },
    {
        "content": "<p>First of all, just to explain why we're advocating for more general things rather than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mrow><mi>m</mi><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_{m0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>: this is related, although not really the same thing, to Yakov's point. When considering arbitrary complete, separable extensions of a local field (irrespective of this very definition), it might be handy to have a general set-up to treat finite and infinite ones on an equal footing, postponing the analysis of the finite case when needed. But for things like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">C</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> the valuation is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">R</mi><mrow><mo>‚â•</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}_{\\geq 0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9341em;vertical-align:-0.2452em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">‚â•</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2452em;\"><span></span></span></span></span></span></span></span></span></span>-valued, and even for finite extensions the definition of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mrow><mi>m</mi><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_{m0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-valued one goes through a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">R</mi><mrow><mo>‚â•</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}_{\\geq 0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9341em;vertical-align:-0.2452em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">‚â•</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2452em;\"><span></span></span></span></span></span></span></span></span></span>-valued one, that actually lands in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>p</mi><mi mathvariant=\"double-struck\">Z</mi></msup></mrow><annotation encoding=\"application/x-tex\">p^\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0397em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8452em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathbb mtight\">Z</span></span></span></span></span></span></span></span></span></span></span> and we can \"chose a log\". So, in this respect, the flexibility of allowing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œì</span></span></span></span> to be whatever it should, is much handy.</p>",
        "id": 511800208,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1744455214
    },
    {
        "content": "<p>Concerning <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> 's suggestion: I suppose that then the point is to endow <code>K</code> with the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Order/Basic.html#Preorder.topology\">Preorder.topology</a> (as a local/scoped instance), right? In principle I agree, but what I am not still sure about is the \"canonical\" valuation: if you start with a Dedekind domain (local or not local), and pick a prime, you have the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/DedekindDomain/AdicValuation.html#IsDedekindDomain.HeightOneSpectrum.valuation\">IsDedekindDomain.HeightOneSpectrum.valuation</a>, which is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mrow><mi>m</mi><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_{m0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-valued: we could in principle make it <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mi mathvariant=\"normal\">/</mi><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">K/A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">A</span></span></span></span>-valued, but this requires a whole refactor. Is this what you suggest? And how would you treat extensions? If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mi mathvariant=\"normal\">/</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">L/K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> is an extension and the unit ball in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, saying that a valuation on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> extends that on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> seems a bit nasty, since the former is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mi mathvariant=\"normal\">/</mi><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">L/B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>-valued, the latter is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mi mathvariant=\"normal\">/</mi><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">K/A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">A</span></span></span></span>-valued. But perhaps I am too scary and things will play out nice, I am just wondering whether you have already thought about this.</p>",
        "id": 511800222,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1744455220
    },
    {
        "content": "<p>What you write suggests me that ‚ÄúValued fields‚Äù (possibly ‚ÄúValuation Rings‚Äù) should be ‚Äúrings with a lot of stuff ‚Äî¬†topology and algebra ‚Äî that is enough to imply that there is a valuation that can define this stuff‚Äù, and then we need properties that say that ‚Äúthis valuation is admissible‚Äù. In this way, you could use any valuation you like, normalize it, compare it to some other (in extensions, to compositions, etc.).</p>",
        "id": 511802615,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1744457046
    },
    {
        "content": "<p>Well, the class <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Valued#doc\">docs#Valued</a> is indeed what you suggest: a ring with a lot of stuff, including a valuation, a topology and a compatibility between the topology and the valuation. When you say \" admissible\" do you mean \"compatible with the topology\"? This is basic the field <code>is_topological_valuation</code> in <code>Valued</code>, and it is indeed the way we use to come up with a <code>Valued</code> instance when we have a valuation as in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Valued.mk#doc\">docs#Valued.mk</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Valued.mk%27#doc\">docs#Valued.mk'</a>. Or am I misunderstanding what you mean?</p>",
        "id": 511803695,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1744457788
    },
    {
        "content": "<p>Yes I'm suggesting that <code>Valued</code> is a bad idea because it's like <code>OrderedRing</code>. We had eight ordered ring classes, for each pair of ring/semiring, non-commutative/commutative and partial order/total order. Now we have <code>IsOrderedRing</code> which covers all of them. This is both a simplification of the typeclass system and also it resulted in a 20% speedup in typeclass inference. </p>\n<p>I'm suggesting that Filippo's proposal is going back down the old route. We have <code>Valued</code> which I think dates back to the perfectoid days when we were using lean 3 with a different typeclass algorithm. Filippo is suggesting that then <code>ValuedLocalField</code> extends this and these are both Type-valued, it feels like exactly the same path and I'm suggesting that we don't go down it at all. </p>\n<p>I'm proposing <code>IsValuableField</code> which can be Prop-valued and will eat <code>[Field K] [Preorder K] [UniformSpace K]</code> and will say that the preorder and uniform space both come from a valuation (the preorder is a&lt;=b iff v(a) &lt;= v(b)), and we demand <code>IsUniformAddGroup</code> and <code>is_topological_valuation</code>. The point is that then we can drop Gamma completely. If you want an explicit Gamma and v then you can have another Prop-valued class <code>IsValuation K v</code> extending <code>IsValuableField K</code> which just says that v a &lt;= v b iff a &lt;= b.Then you can drop <code>Valued.v</code> and just have <code>v : K -&gt; Gamma</code> for whatever Gamma you like.</p>",
        "id": 511806936,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744460355
    },
    {
        "content": "<p>I was meaning everything <em>without</em> a specified valuation.</p>",
        "id": 511809399,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1744462483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/511806936\">said</a>:</p>\n<blockquote>\n<p>Yes I'm suggesting that <code>Valued</code> is a bad idea because it's like <code>OrderedRing</code>. We had eight ordered ring classes, for each pair of ring/semiring, non-commutative/commutative and partial order/total order. Now we have <code>IsOrderedRing</code> which covers all of them. This is both a simplification of the typeclass system and also it resulted in a 20% speedup in typeclass inference. </p>\n<p>I'm suggesting that Filippo's proposal is going back down the old route. We have <code>Valued</code> which I think dates back to the perfectoid days when we were using lean 3 with a different typeclass algorithm. Filippo is suggesting that then <code>ValuedLocalField</code> extends this and these are both Type-valued, it feels like exactly the same path and I'm suggesting that we don't go down it at all. </p>\n<p>I'm proposing <code>IsValuableField</code> which can be Prop-valued and will eat <code>[Field K] [Preorder K] [UniformSpace K]</code> and will say that the preorder and uniform space both come from a valuation (the preorder is a&lt;=b iff v(a) &lt;= v(b)), and we demand <code>IsUniformAddGroup</code> and <code>is_topological_valuation</code>. The point is that then we can drop Gamma completely. If you want an explicit Gamma and v then you can have another Prop-valued class <code>IsValuation K v</code> extending <code>IsValuableField K</code> which just says that v a &lt;= v b iff a &lt;= b.Then you can drop <code>Valued.v</code> and just have <code>v : K -&gt; Gamma</code> for whatever Gamma you like.</p>\n</blockquote>\n<p>Thanks Kevin. I think I see what you mean, it will probably take a while to refactor our project on this direction, but we'll report here or advances and/or doubts.</p>",
        "id": 511810572,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1744463621
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/511809399\">said</a>:</p>\n<blockquote>\n<p>I was meaning everything <em>without</em> a specified valuation.</p>\n</blockquote>\n<p>Ah, in that case it is a bit different, you're right. At any rate I think we'll try to implement Kevin's suggestion, and see where it brings us.</p>",
        "id": 511810653,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1744463692
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> are you talking about local fields? In that case you can have the uniform space and field structure but not the partial order.</p>",
        "id": 511811236,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744464196
    },
    {
        "content": "<p>\"Valuable field\" has a nice double meaning... <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 511811454,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1744464367
    },
    {
        "content": "<p>Yeah of course here I mean \"it's possible to put a valuation on this field\". Probably this stuff should extend to commutative rings.</p>",
        "id": 511811915,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744464766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/511742539\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsNonarchPreorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le_total</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">add_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h‚ÇÅ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"n\">mul_le_mul_right</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"n\">zero_lt_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I think this is a valuable ( <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> ) definition, but could we remove <code>add_le</code> so that this can also capture Archimedean valuations? Such preorders are called \"localities\" by some people, and it's actually possible to prove stuff about them! (e.g. <a href=\"https://arxiv.org/abs/1901.02632\">https://arxiv.org/abs/1901.02632</a> ). This does also generalize to commutative rings, and I guess if you look at the set of all <code>a</code> which are indistinguishable from 0 w.r.t. to the preorder, that would be a prime ideal, and the preorder would induce one on the residue field of the prime, etc.</p>",
        "id": 511815438,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744467679
    },
    {
        "content": "<p>In other words, I would suggest the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">Locality</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le_total</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">mul_le_mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b'</span>\n</code></pre></div>",
        "id": 511815564,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744467782
    },
    {
        "content": "<p>So you want no <code>add_le</code> field at all?</p>\n<p>It is not clear to me that we want to capture archimedean valuations. These always take values in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> and the analysts are already happily using <code>Norm</code> for these. They don't want our silly <code>Locality</code>s and it seems to me that mathlib is making no attempt to unify the archimedean and the nonarchimedean setting, e.g. look at our definition of adeles: it's \"do something algebraic at the finite places using <code>HeightOneSpectrum</code> and get a theory which works fine for any Dedekind domain, and then do something totally different at the infinite places using <code>InfinitePlace</code>, and then take the product\". I think that any attempt to unify these two approaches would be ludicrous, it would make both developments worse.</p>\n<p>I am prejudiced against unification having worked through Jacquet-Langlands. This book attempted to unify nonarchimedean and archimedean points of view when doing the representation theory of local fields and it just makes the book far more obscure than it could be. For example they spend a lot of time talking about Schwarz space, which IIRC they don't even define, but I eventually figured out that what they meant was something like \"normal Schwarz space in the real/complex case, and locally constant functions with compact support in the p-adic case\" (or possibly some L^2 extension of this). It meant that they could write statements which superficially make sense in both the arch and nonarch case, but then the proofs often split into cases anyway. Eventually after a few chapters even the authors got bored of this approach and just started writing separate chapters for arch and nonarch theorems.</p>\n<p>In short: I am not convinced that the analysts will ever care about <code>Locality</code>s. So why bother attempting to accommodate them?</p>",
        "id": 511922657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744562102
    },
    {
        "content": "<p>Just for the record: in the first version of our project with <span class=\"user-mention\" data-user-id=\"406490\">@Mar√≠a In√©s de Frutos Fern√°ndez</span> , we defined <code>LocalField</code> to be a <em>nonarchimedean</em> local field (through the <code>Valued</code> class discussed above), thinking that at any rate the \"uniform\" statement of local class field theory for both archimedean and non-archimedean complete locally compact normed fields is a bit artificial: it is true that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mover accent=\"true\"><mi>H</mi><mo>^</mo></mover><mi>n</mi></msup><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><msup><mi mathvariant=\"double-struck\">C</mi><mo>√ó</mo></msup><mo stretchy=\"false\">)</mo><mo>‚âÖ</mo><msup><mover accent=\"true\"><mi>H</mi><mo>^</mo></mover><mrow><mi>n</mi><mo>‚àí</mo><mn>2</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\hat{H}^n(G,\\mathbb{C}^\\times)\\cong \\hat{H}^{n-2}(G,\\mathbb{Z})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1968em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9468em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1944em;\"><span class=\"mord\">^</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">√ó</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚âÖ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1968em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9468em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1944em;\"><span class=\"mord\">^</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">‚àí</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mclose\">)</span></span></span></span>, for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>œÑ</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">G=\\{1,\\tau\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">œÑ</span><span class=\"mclose\">}</span></span></span></span> but for much more superficial reasons than for non-archimedean fields (with \"quasi-finite\" residue field, following Serre's <em>Corps Locaux</em>, Chap. XIII, ¬ß 2 --- let me observe in passing that, to the best of my reading, Serre never <em>defines</em> what a local field is in a 250 pages-long, beautiful book entitled \"Local Fields\"...): in particular, it does not follow from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Br</mi><mo>‚Å°</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">C</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi mathvariant=\"double-struck\">Q</mi><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Br}(\\mathbb{C})=\\mathbb{Q}/\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Br</span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">C</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Q</span><span class=\"mord\">/</span><span class=\"mord mathbb\">Z</span></span></span></span> (which is <em>false</em>), although Tate--Nakayama's lemma still applies. So, albeit for slightly different reasons (but ultimately analogous), I completely agree with <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> that keeping the two worlds apart looks the most sensible thing to do.</p>\n<p>Later on, we received objections that it was a pity to define local fields only in the nonarchimedean setting, and we tried to accomodate this. I believe that this discussion is mainly a social one (which is perfectly fine, IMHO), and should be treated as such. So, I'd like to propose the following poll, suggesting to postpone the technical discussion about how these gadgets must be implemented to when we'll have agreed about what \"these gadget\" ought to be:</p>",
        "id": 511991132,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1744610776
    },
    {
        "content": "<p>/poll Do you agree that Local Field should mean \"nonarchimedean\"?<br>\nYes, and we can keep the two theories separate.<br>\nYes, but I would insist in having a class containing rings/fields either with a non-archimedean valuation or with a real-valued archimedean norm.<br>\nNo, we must strive for a uniform approach for all definitions and statements, even if proofs differ in the two cases.</p>",
        "id": 511991143,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1744610785
    },
    {
        "content": "<p>The arguments of Kevin and Filippo convincingly explain that it would probably be an unnecessary burden to develop both theories at the same time, but it would also be misleading that the <em>name</em> departs from classical terminology. So I advocate for something such as ‚ÄúNALocalField‚Äù or ‚ÄúNonArchimedeanLocalField‚Äù.</p>",
        "id": 512000790,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1744614860
    },
    {
        "content": "<p>Yes my vote is for <strong>development of the theory</strong> to have nonarchimedean baked in, on the basis that the people developing the theory of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> are already leaps and bounds ahead of us and will not need to use any infrastructure which we build here. I agree with Antoine that we should stick to the literature when it comes to naming conventions.</p>",
        "id": 512001162,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744614989
    },
    {
        "content": "<p>Or,maybe clearer, two type classes, one ‚ÄúLocalField‚Äù, together with ‚ÄúNonarchimedean‚Äù although that is probably too polysemic and no real gain in terms of typing.</p>",
        "id": 512001200,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1744615005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/511815564\">said</a>:</p>\n<blockquote>\n<p>In other words, I would suggest the following:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">Locality</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le_total</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">mul_le_mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b'</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This fails on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, right? Because the \"valuation preorder\" conflicts with the usual order on the reals.</p>",
        "id": 512026535,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744621848
    },
    {
        "content": "<p>I agree that the two theories will be separate 99% of the time. But I would like to have support for clean unifying statements in that 1% of cases. But if that requires something like <code>[ArakelovLocalField K]</code> (I just made this up) then I'm happy with that.</p>",
        "id": 512027077,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744621998
    },
    {
        "content": "<p>OK, so if I understand correctly there is some agreement to define a class <code>NALocalField</code> for locally compact fields endowed with a non-archimedean discrete valuation (we'll decide later if this should extend <code>Preorder</code> or something else); and to postpone the definition of what a <code>LocalField</code> should be, if it will ever be a thing.</p>\n<p>This will allow for a speedy process and will allow <span class=\"user-mention\" data-user-id=\"406490\">@Mar√≠a In√©s de Frutos Fern√°ndez</span> and myself to pull (or adapt+pull) our API reasonably soon. The downside is that for a while <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> 's hope will come to a halt. One other option is that we also PR this \"umbrella\" class as for instance <a href=\"https://github.com/mariainesdff/LocalClassFieldTheory/blob/9b1150821ebe8a48ac8f5d5ac6b88e0028a8e427/LocalClassFieldTheory/LocalField/Basic.lean#L67\">here</a>: I am personally <em>not in favour</em> of this, mainly because if we're not planning to invest time and energy in the general theory for these \"archimedean agnostically\" local fields, it would simply be a flag put on this <code>def</code> rather than a proper addition to the library. </p>\n<p>Is my understanding correct? Shall I proceed like this?</p>",
        "id": 512040662,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1744625755
    },
    {
        "content": "<p>I am not pushing for <code>LocalField</code>, I suspect that there are several different usages of the phrase in the literature. <code>NonArchimedeanLocalField</code> I think we all agree what this means mathematically. Johan can have some <code>LocalField</code> later on if he wants, just by saying \"either nonarchimedean local field or RorCLike\" or whatever. I cannot imagine it getting much use at present but then again I don't know any Arakelov theory...</p>",
        "id": 512052723,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744629730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/512026535\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/511815564\">said</a>:</p>\n<blockquote>\n<p>In other words, I would suggest the following:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">Locality</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le_total</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">mul_le_mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b'</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This fails on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, right? Because the \"valuation preorder\" conflicts with the usual order on the reals.</p>\n</blockquote>\n<p>Yes, good point. But then a similar issue would come up with Kevin's original suggestion, e.g. for the nonstandard reals which can be ordered and which have a \"canonical\" valuation.</p>",
        "id": 512073141,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744635502
    },
    {
        "content": "<p>My thoughts on whether to keep things separate is to at least have the <em>core</em> of the theory be common, and, probably very quickly, specialize to the \"nonarchimedean\" and \"archimedean\" case on top of this common core. So in practice the development would be separate, but in the 1% of situations where there is something uniform that can be said, we wouldn't have to develop some hacks around the hierarchy to be able to say it.</p>",
        "id": 512073724,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744635665
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> maybe we need a name change:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">LocalIntegralStructure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">r_refl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">r_trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"n\">r_mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">r_total</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>",
        "id": 512075467,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744636140
    },
    {
        "content": "<p>Possibly. Do you think the <code>r</code> will be used? Or should we just record <code>S = {x | r x 1}</code> + axioms about how <code>S</code> behaves under scaling?<br>\nGetting flashbacks to the pseudo-normed monoids and balls of radius <code>c</code> from LTE...</p>",
        "id": 512090725,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744639997
    },
    {
        "content": "<p>I think with arbitrary commutative rings you probably do need the whole relation.</p>",
        "id": 512091122,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744640102
    },
    {
        "content": "<p>But is this needed straight away, or can we wait until we have something to say about this 1%? What scares me a bit is that this introduces data, so it would be wiser that <code>LocalFields</code> (or <code>NALocalFields</code>, are they'll probably be called) <code>extend</code> this class. On the other hand, the library would be at a funny stage, with this class left alone and immediately after another class extending it.</p>",
        "id": 512093445,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1744640683
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/512090725\">said</a>:</p>\n<blockquote>\n<p>Possibly. Do you think the <code>r</code> will be used? Or should we just record <code>S = {x | r x 1}</code> + axioms about how <code>S</code> behaves under scaling?<br>\nGetting flashbacks to the pseudo-normed monoids and balls of radius <code>c</code> from LTE...</p>\n</blockquote>\n<p>This gives me also flashbacks about the \"fundamental\" example in the forgetful inheritance paper; if we have <code>r</code> and we define the unit ball out of it, what happens on <code>M x M</code>? It will come with its own <code>r</code>, giving rise to a \"squared\" ball and I'm not sure that this is what we want.</p>",
        "id": 512097210,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1744641579
    },
    {
        "content": "<p>Surely in practice we can get away with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span>? A more appropriate name for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>‚â•</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a \\geq b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚â•</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>‚à£</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a\\mid b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚à£</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> meaning <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo>=</mo><mi>z</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">b=za</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mord mathnormal\">a</span></span></span></span> for some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>z</mi><mo stretchy=\"false\">)</mo><mo>‚â§</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">v(z)\\leq 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚â§</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>.</p>",
        "id": 512165125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744661574
    },
    {
        "content": "<p>If you take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>=</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">A = \\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> and the <code>r</code> to come from the trivial valuation on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">F</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{F}_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, so that the valuation ring of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">F</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{F}_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is all of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">F</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{F}_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> would be all of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>. But with <code>r</code> you can distinguish this from the valuation arising from the trivial valuation on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span> since <code>r 3 2</code> doesn't hold.</p>",
        "id": 512185669,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744670082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/511811915\">said</a>:</p>\n<blockquote>\n<p>Yeah of course here I mean \"it's possible to put a valuation on this field\". Probably this stuff should extend to commutative rings.</p>\n</blockquote>\n<p>My point is that if we want to have something work for rings, then we need the relation, not just the \"unit ball\".</p>",
        "id": 512185834,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744670182
    },
    {
        "content": "<p>About <code>Locality</code>, what does exactly fail with the real numbers? It seems that the  preorder underlying this definition is the one on absolute values. Is it enough to recover the classical ordering on reals?</p>",
        "id": 512227042,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1744694717
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> There isn't any math failure. What I meant is that you get to conflicting instances on the reals. So TC will be confused.</p>",
        "id": 512232342,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744697047
    },
    {
        "content": "<p>OK so all the dependencies of <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a> are now merged, and we're ready to make a decision about the definition. Having talked to various people I am now reluctantly coming around to the fact that we need to extend Valued despite it being a bit of a crappy design, because my proposed alternative (make the definition a Prop built on other things) will be really longwinded. My conclusions from thinking about this is that Lean 4's typeclass system is pushing us towards <code>(R : Type*) [Add R] [Mul R] [Neg R] [Zero R] [One R] [IsCommutativeAdd R] [IsDistrib R]...</code> and we have to choose between slowdowns and this explosion, and until we have machinery which can hide the explosion we're going to have to live with the slowdown, so I'm reluctantly agreeing with extending Valued even though it's data.</p>\n<p>Unless I've made some mistake, the PR doesn't compile with current master for some reason; I get </p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>typeclass instance problem is stuck, it is often due to metavariables\n  Ring ?m.557\n</code></pre></div>\n<p>on the <code>isDiscrete</code> field in the definition. Can you merge master <span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> ?</p>",
        "id": 514442296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745606940
    },
    {
        "content": "<p>Is there a reason to prefer <code>IsDiscrete v</code> over <code>IsDiscreteValuationRing v.valuationSubring</code>, especially since you already refer to the subring with <code>IsLocalRing.ResidueField v.valuationSubring</code>?</p>",
        "id": 514442860,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1745607147
    },
    {
        "content": "<p>Similarly, <code>IsCyclic</code> vs <code>MulArchimedean</code></p>",
        "id": 514442984,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1745607211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/514442296\">said</a>:</p>\n<blockquote>\n<p>OK so all the dependencies of <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a> are now merged,</p>\n</blockquote>\n<p>Kevin, <a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> is still open (bors closed it by mistake).</p>",
        "id": 514447653,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1745609057
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/514442860\">said</a>:</p>\n<blockquote>\n<p>Is there a reason to prefer <code>IsDiscrete v</code> over <code>IsDiscreteValuationRing v.valuationSubring</code>, especially since you already refer to the subring with <code>IsLocalRing.ResidueField v.valuationSubring</code>?</p>\n</blockquote>\n<p>We prefer <code>IsDiscrete</code> so that <code>v</code> is the normalized valuation.</p>",
        "id": 514449668,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1745609978
    },
    {
        "content": "<p>That's a great line to include in the module docstring and/or the structure field docstring.</p>",
        "id": 514453306,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1745611585
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I see it building, but as <span class=\"user-mention\" data-user-id=\"406490\">@Mar√≠a In√©s de Frutos Fern√°ndez</span> mentioned the previous <a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> is still not merged, so I'm devoting today/tomorrow to the comments from you and <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> and once that will be also merged I'll go back to <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a></p>",
        "id": 514508749,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745650799
    },
    {
        "content": "<p>Note that <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a> has conflicts with master but this is not being picked up by CI right now because <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a> is built off the base branch of <a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> rather than off master. Unfortunately <a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> is currently borked on github (it changes 419 files right nowe). <span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> I left some suggestions on how to proceed with <a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> on github. We can worry about <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a> github issues later. </p>\n<p>Modulo that, I'm reluctantly going to agree to the set-up of extending <code>Valued</code> on the basis that whilst it might cause us problems later on, the alternatives are currently worse, and I'd like to again raise the discussion of what this class should be called. Serre says this in Cassels-Froehlich:</p>\n<p><a href=\"/user_uploads/3121/Ou6vWX6FE_9Sn44Np65AyOco/Screenshot-from-2025-04-27-10-03-27.png\">Screenshot from 2025-04-27 10-03-27.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Ou6vWX6FE_9Sn44Np65AyOco/Screenshot-from-2025-04-27-10-03-27.png\" title=\"Screenshot from 2025-04-27 10-03-27.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"672x404\" src=\"/user_uploads/thumbnail/3121/Ou6vWX6FE_9Sn44Np65AyOco/Screenshot-from-2025-04-27-10-03-27.png/840x560.webp\"></a></div><p>so for him a local field is equipped with a discrete valuation, which makes me think that this class defined in <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a> should just be called <code>LocalField</code>, or if people are really against this because they still believe in this dream (which I do not believe in) that we are going to prove a nontrivial number of lemmas which are true for the p-adics and the reals but not true for general valuations or norms, then we should call it <code>NonarchimedeanLocalField</code>. I think that calling it <code>ValuedLocalField</code> will just cause confusion because we have made this term up and nobody else uses it.</p>",
        "id": 514627595,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745745474
    },
    {
        "content": "<p>I think that if we want a class which encapsulates local fields in the sense of complete locally compact fields with a real-valued norm inducing the topology, we can just say that, because all of that is in mathlib.</p>",
        "id": 514628181,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745745941
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/514627595\">said</a>:</p>\n<blockquote>\n<p>Note that <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a> has conflicts with master but this is not being picked up by CI right now because <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a> is built off the base branch of <a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> rather than off master. Unfortunately <a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> is currently borked on github (it changes 419 files right nowe). <span class=\"user-mention silent\" data-user-id=\"300245\">Filippo A. E. Nuccio</span> I left some suggestions on how to proceed with <a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> on github. We can worry about <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a> github issues later. </p>\n<p>Modulo that, I'm reluctantly going to agree to the set-up of extending <code>Valued</code> on the basis that whilst it might cause us problems later on, the alternatives are currently worse, and I'd like to again raise the discussion of what this class should be called. Serre says this in Cassels-Froehlich:</p>\n<p><a href=\"/user_uploads/3121/Ou6vWX6FE_9Sn44Np65AyOco/Screenshot-from-2025-04-27-10-03-27.png\">Screenshot from 2025-04-27 10-03-27.png</a></p>\n<p>so for him a local field is equipped with a discrete valuation, which makes me think that this class defined in <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a> should just be called <code>LocalField</code>, or if people are really against this because they still believe in this dream (which I do not believe in) that we are going to prove a nontrivial number of lemmas which are true for the p-adics and the reals but not true for general valuations or norms, then we should call it <code>NonarchimedeanLocalField</code>. I think that calling it <code>ValuedLocalField</code> will just cause confusion because we have made this term up and nobody else uses it.</p>\n</blockquote>\n<p>This was indeed our initial design. Since we also develop mixed (resp equal) characteristic local fields as finite  extensions of Q_p (resp of F_p((X)) ) we eventually need two more names for those. In order to keep everything somewhat homogenous and to simultaneously go in the directions of some comments above, avoiding attaching once and for all the name Local Field to something, what about deciding that all these gadgets are named <code>XXLocalField</code>, with</p>\n<ul>\n<li>XX = NA for the general one extending <code>Valued</code></li>\n<li>XX=EC for equal char ones</li>\n<li>XX=MC for mixed char ones<br>\n?</li>\n</ul>",
        "id": 514706405,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745805804
    },
    {
        "content": "<p>I'm trying to understand how one would phrase this statement using the proposed classes.<br>\n<a href=\"/user_uploads/3121/CoK9OVsS-NU0byTiRr1H7moO/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/CoK9OVsS-NU0byTiRr1H7moO/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"393x30\" src=\"/user_uploads/thumbnail/3121/CoK9OVsS-NU0byTiRr1H7moO/image.png/840x560.webp\"></a></div>",
        "id": 514708641,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1745807485
    },
    {
        "content": "<p>What I have is the following sketch. <code>IsGalois</code> is stronger than it needs to be to describe an extension. Does this look about right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsDiscrete'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">exists_generator_lt_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"bp\">À£</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"bp\">.</span><span class=\"n\">zpowers</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"bp\">‚Üë</span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ'</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Valued</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Valued</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ'</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- inlining proposed ValuedLocalField</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">IsDiscrete'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">))]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDiscrete'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">))]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">IsLocalRing</span><span class=\"bp\">.</span><span class=\"n\">ResidueField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">valuationSubring</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">IsLocalRing</span><span class=\"bp\">.</span><span class=\"n\">ResidueField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">valuationSubring</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- let's simplify to the mixed characteristic case</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">CharZero</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">CharZero</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- is this necessary unde the galois condition, or inferrable?</span>\n<span class=\"w\">  </span><span class=\"c1\">-- now we say L/K</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsGalois</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- do we need to say `[FiniteDimensional K L]`?</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">v_orderIso</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí*</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"c1\">-- something like</span>\n<span class=\"c1\">-- gen_Œì‚ÇÄ ‚Ü¶ gen_Œì‚ÇÄ' ^ (Ideal.ramificationIdx (algebraMap K L) ùìÇ[K] ùìÇ[L])</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v_orderIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 514708759,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1745807569
    },
    {
        "content": "<p>I completely lost track of the proposed classes, but it's always possible to take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mi>v</mi><mo stretchy=\"false\">(</mo><mi>œÄ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(p)/v(\\pi)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">œÄ</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>œÄ</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">œÄ</span></span></span></span> is a uniformizer.</p>",
        "id": 514708799,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1745807593
    },
    {
        "content": "<p>Right, when discussing an extension over the concrete Q_p. Here, I'm discussing an extension over an unspecified base field K.</p>",
        "id": 514709843,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1745808306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/514442296\">said</a>:</p>\n<blockquote>\n<p>My conclusions from thinking about this is that Lean 4's typeclass system is pushing us towards <code>(R : Type*) [Add R] [Mul R] [Neg R] [Zero R] [One R] [IsCommutativeAdd R] [IsDistrib R]...</code> and we have to choose between slowdowns and this explosion</p>\n</blockquote>\n<p>Minor comment: There shouldn't be an explosion of <code>IsFoo</code> assumptions stacked on top of each other. Since those are Prop's they can extend each other (and avoid <a href=\"https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html\">https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html</a>).<br>\nTo be precise: they can extend each other if they depend on the same set of types. So you would still have <code>[IsRing R] [IsAddGroup M] [IsModule R M]</code>.</p>",
        "id": 514736642,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745824253
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/514708799\">said</a>:</p>\n<blockquote>\n<p>I completely lost track of the proposed classes, but it's always possible to take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mi>v</mi><mo stretchy=\"false\">(</mo><mi>œÄ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(p)/v(\\pi)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">œÄ</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>œÄ</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">œÄ</span></span></span></span> is a uniformizer.</p>\n</blockquote>\n<p>Yes, this is the approach we take in our project, and we similarly proved that an extensions is \"absolutely unramified\" iff <code>p</code> stays a uniformizer.</p>",
        "id": 514783284,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745838259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/514708759\">said</a>:</p>\n<blockquote>\n<p>What I have is the following sketch. <code>IsGalois</code> is stronger than it needs to be to describe an extension. Does this look about right?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsDiscrete'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">exists_generator_lt_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"bp\">À£</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"bp\">.</span><span class=\"n\">zpowers</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"bp\">‚Üë</span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ'</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Valued</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Valued</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ'</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- inlining proposed ValuedLocalField</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">IsDiscrete'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">))]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDiscrete'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">))]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">IsLocalRing</span><span class=\"bp\">.</span><span class=\"n\">ResidueField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">valuationSubring</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">IsLocalRing</span><span class=\"bp\">.</span><span class=\"n\">ResidueField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">valuationSubring</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- let's simplify to the mixed characteristic case</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">CharZero</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">CharZero</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- is this necessary unde the galois condition, or inferrable?</span>\n<span class=\"w\">  </span><span class=\"c1\">-- now we say L/K</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsGalois</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- do we need to say `[FiniteDimensional K L]`?</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">v_orderIso</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí*</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">Œì‚ÇÄ'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"c1\">-- something like</span>\n<span class=\"c1\">-- gen_Œì‚ÇÄ ‚Ü¶ gen_Œì‚ÇÄ' ^ (Ideal.ramificationIdx (algebraMap K L) ùìÇ[K] ùìÇ[L])</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v_orderIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> I am not sure to understand what you're aiming at.</p>",
        "id": 514783914,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745838420
    },
    {
        "content": "<p>Let's say we have a tower of extensions of nonarchimedean local fields K/Q_p and L/K, where <code>v</code> is the valuation of <code>K</code> and <code>w</code> is the valuation of <code>L</code>, <code>k</code> is the uniformizer in <code>K</code> and <code>l</code> is the uniformizer in <code>L</code>.. We know that the ramification index of <code>K/Q_p</code> is <code>v(p) / v(k)</code>, and similarly, the ramification index of <code>L/Q_p</code> is <code>w(p) / w(l)</code>. However, how does one state the similar statement about the ramification index of <code>L/K</code>? </p>\n<p>This would be useful, for example, if we were discussing an intermediate field situation, where <code>L/K</code> is totally ramified and <code>K/Q_p</code> is unramified. I'm asking about how to state that <code>L/K</code> is totally ramified -- somehow talk about how <code>w(algebraMap K L k)</code> relates to <code>v(k)</code>.</p>",
        "id": 514810203,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1745845844
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/2W324JW6Q8_vVDi1GRDnNSUk/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/2W324JW6Q8_vVDi1GRDnNSUk/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1279x475\" src=\"/user_uploads/thumbnail/3121/2W324JW6Q8_vVDi1GRDnNSUk/image.png/840x560.webp\"></a></div>",
        "id": 514810987,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1745846046
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> and I are working towards constructing the maximal unramified subextension. It is still very much WIP, but Filippo explained our current strategy a few weeks ago in <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/510213936\">this comment</a>.</p>",
        "id": 514818477,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1745847896
    },
    {
        "content": "<p>In the FLT repo we assume <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> are taking values in the same totally ordered group with 0, and we talk about an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span></span></span></span> such that for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>‚àà</mo><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">x\\in K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚àà</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><msup><mo stretchy=\"false\">)</mo><mi>e</mi></msup></mrow><annotation encoding=\"application/x-tex\">w(x)=v(x)^e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span></span></span></span></span></span></span></span>, where by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> I mean <code>w (algebraMap K L x)</code>.</p>",
        "id": 514826984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745849883
    },
    {
        "content": "<p>Consider also that this would be quite easy to prove if we relate the absolute ramification index (i.e. over Q_p) to the valuation of <code>p</code> (which we have in our project), and then using <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/NumberTheory/RamificationInertia/Basic.html#Ideal.ramificationIdx_tower\">Ideal.ramificationIdx_tower</a>.</p>",
        "id": 514827594,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745850040
    },
    {
        "content": "<p>Why don't we just define the ramification degree of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mi mathvariant=\"normal\">‚à£</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">L|K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> to be the size of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mo>√ó</mo></msup><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><msup><mi>K</mi><mo>√ó</mo></msup><mo>‚ãÖ</mo><msubsup><mi mathvariant=\"script\">O</mi><mi>L</mi><mo>√ó</mo></msubsup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L^\\times/(K^\\times \\cdot \\mathcal{O}_L^\\times)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">√ó</span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">√ó</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚ãÖ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.105em;vertical-align:-0.2935em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8115em;\"><span style=\"top:-2.4065em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">L</span></span></span><span style=\"top:-3.1031em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">√ó</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2935em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>?</p>",
        "id": 514832586,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1745851249
    },
    {
        "content": "<p>This also has the benefit of working for <em>any</em> finite extension of valued fields, not just in the local field case.</p>",
        "id": 514832827,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1745851306
    },
    {
        "content": "<p>In general, I'm a bit concerned that a lot of the discussion above is very specialized to local fields, while most of the desired results hold in much greater generality.</p>",
        "id": 514833142,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1745851393
    },
    {
        "content": "<p>Well, actually my point is that most of the work has already been done more generally (as in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/NumberTheory/RamificationInertia/Basic.html#Ideal.ramificationIdx_tower\">Ideal.ramificationIdx_tower</a> ) and what we do is to try to align to the library as much as possible, so we simply provide a small bridge to what is already available, and rely on that.</p>",
        "id": 514833404,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745851457
    },
    {
        "content": "<p>But even this ramificationIdx_tower is only for discrete rank 1 valuations.</p>",
        "id": 514833520,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1745851493
    },
    {
        "content": "<p>True.</p>",
        "id": 514833596,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745851514
    },
    {
        "content": "<p>But I see two (not necessarily disjoint) paths: generalising what is currently in the library and adding results about extensions of local fields. What we're doing, and what I think is the most sensible thing, is to keep the valued fields results aligned to what is already in the library. If we eventually generalise these results, of course the valued fields part can be generalised as well, eg in rank &gt; 1, but departing from what is available only on the valued side seems a bit dangerous, it would make the local/global bridge more painful.</p>",
        "id": 514834609,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745851759
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/514833142\">said</a>:</p>\n<blockquote>\n<p>In general, I'm a bit concerned that a lot of the discussion above is very specialized to local fields, while most of the desired results hold in much greater generality.</p>\n</blockquote>\n<p>The reason I'm pushing for a local fields definition is that I want to start on arithmetic (e.g. the Artin map with no sorried data) for the Oxford class field theory thing and here you definitely need local compactness. I'm aware that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mi>f</mi><mo>‚â§</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">ef\\leq n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚â§</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> holds in huge generality and that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mi>f</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">ef=n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> holds quite often (e.g. for complete discretely-valued fields so e.g. completion of field of fractions of a DVR at a nonzero prime), I'm not suggesting we start proving theorems in the wrong generality, but I am really hoping that we can get a definition down which does have these strong arithmetic constraints so I can start proving things like \"Q_p is an example\" or \"completion of a number field at a finite place is an example\". To give a concrete example: I need to prove that integers of K_v is compact for K a number field because I want local compactness results for adeles of number fields to prove finiteness of spaces of quaternionic modular forms, which I need for Hecke algebras so I can state R=T theorems. And I felt that it was silly just proving these results for K_v when they should be being proved for a general nonarch local field.</p>",
        "id": 514912112,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745878114
    },
    {
        "content": "<p>I understand Kevin. Just to help me catch up again, is the following the current proposal for defining a nonarch local field (of possibly equal characteristic)?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">IsDiscrete</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">exists_generator_lt_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"bp\">À£</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Subgroup.zpowers</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"bp\">‚Üë</span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">Set.range</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Valued</span><span class=\"w\"> </span><span class=\"n\">IsLocalRing</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Valued</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">IsDiscrete</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">ResidueField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">valuationSubring</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 514914188,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1745879198
    },
    {
        "content": "<p>Your <code>IsDiscrete</code> is <a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> but the proposal for local field is <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a> and it's currently a data-carrying class <code>ValuedLocalField</code> (which I'm pushing to be renamed <code>NonarchimedeanLocalField</code>) and which extends <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Valued#doc\">docs#Valued</a> .</p>",
        "id": 514914888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745879589
    },
    {
        "content": "<p>ok thanks :)</p>",
        "id": 514915084,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1745879699
    },
    {
        "content": "<p>I have misgivings about extending <code>Valued</code> but my proposal was too extreme in the other direction (drop <code>Valued</code> completely because it's mixing algebra and topology (it wants <code>Ring R</code> and <code>UniformSpace R</code> and it's data so it's going to cause trouble for typeclass inference) and instead have a Prop-valued extension extending <code>Ring</code>, <code>UniformSpace</code> and <code>Preorder</code>. But it was pointed out to me that this would make all statements really unwieldy and that we might want to wait until we have some viable <code>variable?</code> or <code>[[ LocalField ]]</code> thing going. But I like your definition, removing <code>Valued</code> from mathlib will be a pain but I am still reluctant to extend it, I worry that it will just end up being like <code>OrderedSemiring</code>, <code>OrderedRing</code>, <code>OrderedCommRing</code> all over again if we keep allowing extensions of <code>Valued</code>. We removed all the ordered ring stuff and replaced it by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsOrderedRing#doc\">docs#IsOrderedRing</a> and got a 20% speedup of typeclass inference across the entire library!</p>",
        "id": 514915398,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745879858
    },
    {
        "content": "<p>The history of <code>Valued</code> is that it originally came from the perfectoid project when (a) we (or at least I) didn't really know what we were doing (I shouldn't speak for the other authors!) and (b) it was Lean 3, so the typeclass system worked differently. Originally (<a href=\"https://github.com/leanprover-community/mathlib3/pull/9589\">https://github.com/leanprover-community/mathlib3/pull/9589</a>) Gamma was bundled data in the same universe and it was a class (so you were only allowed on Gamma per R) but there was a diamond issue when it came to completions so in <a href=\"https://github.com/leanprover-community/mathlib3/pull/13691\">https://github.com/leanprover-community/mathlib3/pull/13691</a> it was refactored to be the definition you see now, extending uniform rings with more data and with the usual forgetful inheritance note.</p>",
        "id": 514916848,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745880608
    },
    {
        "content": "<p>It will be a lot of work to remove <code>Valued</code>, but it will be less work than it was to remove ordered rings <a href=\"https://github.com/leanprover-community/mathlib4/pull/20676\">#20676</a> , which changed 169 files and took me about 4 hours to review, but resulted in this <a href=\"https://github.com/leanprover-community/mathlib4/pull/20676#issuecomment-2790076259\">glorious sea of green</a> including the 20% reduction in typeclass inference.</p>",
        "id": 514917148,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745880804
    },
    {
        "content": "<p>But until it's gone, people are going to want to extend it which will just result in more work when we're ready to remove it and replace it with some Prop-valued mixin.</p>",
        "id": 514917252,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745880855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/514914888\">said</a>:</p>\n<blockquote>\n<p>Your <code>IsDiscrete</code> is <a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> but the proposal for local field is <a href=\"https://github.com/leanprover-community/mathlib4/pull/23720\">#23720</a> and it's currently a data-carrying class <code>ValuedLocalField</code> (which I'm pushing to be renamed <code>NonarchimedeanLocalField</code>) and which extends <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Valued#doc\">docs#Valued</a> .</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a></p>",
        "id": 514917444,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1745880975
    },
    {
        "content": "<p>I agree we should remove it and go with the mixin approach as much as possible. I learned yesterday that it may soon be possible to write macros that expand to binders (maybe <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> can confirm?) which would make the dream of <code>[[LocalField F]]</code> et al within reach.</p>",
        "id": 514917451,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1745880980
    },
    {
        "content": "<p>So <code>[Valued R Œì]</code> would become <code>(v : Valuation R Œì) [UniformSpace R] [IsTopologicalValuation R v]</code>?</p>",
        "id": 514918151,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1745881340
    },
    {
        "content": "<p>I'm thinking that that is a better design pattern. But if we don't bite the bullet yet with that refactor then I am wondering whether Yakov's</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsNonarchimedeanLocalField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Valued</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">complete</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">K</span>\n<span class=\"w\">  </span><span class=\"n\">isDiscrete</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsDiscrete</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">finiteResidueField</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">IsLocalRing</span><span class=\"bp\">.</span><span class=\"n\">ResidueField</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Valued</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">valuationSubring</span>\n</code></pre></div>\n<p>is better than <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a> because the analogue is that we're sort of stuck with <code>OrderedRing</code> but at least we avoided <code>OrderedCommRing</code>.</p>",
        "id": 514918378,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745881460
    },
    {
        "content": "<p>But I should say that I'm not really clear on how good the analogy is. The problem with <code>OrderedRing R</code> is that that say typeclass inference is trying to find an instance of <code>Ring R</code>. The sad and frustrating thing which you would see happening time and time again in problematic slow typeclass searches is that typeclass inference notices the instance <code>OrderedRing R -&gt; Ring R</code> and thinks \"ooh I know, maybe I can prove R is a ring by proving it's an ordered ring\" and this is just a totally boneheaded move sometimes because you look at the question and it's 100% algebra and there is no partial order anywhere in the question. But the Lean 4 typeclass algorithm  does this anyway, especially if it is <em>wrong</em> to be looking for a ring structure on R in which case it tries everything including <code>OrderedRing -&gt; Ring</code> and then all of a sudden it has a new problem, trying to prove that this ring R is ordered, and there is no way of doing this because there is no ordering in the question but it now goes off on a merry dance saying \"hmm well maybe I can do this by proving R is well-ordered, no, that didn't work, maybe I can prove it's a lattice, hmm, aah this looks promising, there are lots of ways of proving something is a lattice, maybe I'll now try and prove it's a conditionally complete orderbot lattice\" and 2 seconds later when it's half way through traversing the entire order heirarchy for no good reason you've overflowed the heartbeats timer and have an error suggesting you should increase the maxInstanceHeartbeats from 20000.</p>",
        "id": 514919078,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745881849
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/20676\">#20676</a> made all of those problems go away because now there is no <code>OrderedRing R -&gt; Ring R</code>, there is this completely independent <code>IsOrderedRing R [Ring R] [LE R]</code> which typeclass inference never notices when trying to solve <code>[Ring R]</code> as <code>Ring R</code> is now an input not an output, so you no longer get these crazy traversals of the order heirarchy in questions where there is no order in sight.</p>",
        "id": 514919286,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745881969
    },
    {
        "content": "<p>To be clear, I was not proposing unbundling the class, I had the snippet above just to provide a currently-working-in-Mathlib example of TC arguments that was an approximation to what's being PR'd. It was a mwe so people could load it and think about the interaction of different valuation groups.</p>",
        "id": 514919342,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1745882012
    },
    {
        "content": "<p>The difference here is that there's this Gamma involved so maybe we don't see the same problems with <code>Valued</code>.</p>",
        "id": 514919443,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745882058
    },
    {
        "content": "<p>Thinking about it more, I'm now coming to the conclusion that one of my worries (that <code>Valued</code> will cause typeclass inference to do silly things) is spurious. There is this extra Gamma, so maybe <code>[Valued R Gamma]</code> is just like <code>[Module R M]</code> which doesn't cause these typeclass explosions .</p>\n<p>I am still concerned about this <code>(Œì‚ÇÄ : outParam (Type v))</code> in <code>Valued</code> though. <a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> is saying \"we need to move away from Zm0, it's more convenient to work with a general cyclic group with 0\" but I think that this means you shouldn't have <code>[Valued R Gamma1]</code> and <code>[Valued R Gamma2]</code> at the same time, and there are instances like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FunctionField.valuedFqtInfty#doc\">docs#FunctionField.valuedFqtInfty</a> giving us <code>Valued (FqtInfty Fq) ‚Ñ§‚Çò‚ÇÄ</code> meaning that for this field that's it now, if you want another valuation or an isomorphic value group then you can't use <code>Valued</code> any more, and I think that this means that you won't be able to have <code>[Valued v.adicCompletion (FqtInfty Fq) Gamma]</code> for a general group with zero Gamma, right? Should <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FunctionField.valuedFqtInfty#doc\">docs#FunctionField.valuedFqtInfty</a> not be an instance? But this is an objection to Valued, not to the definition of a local field.</p>\n<p>And my other concern (which Yakov's suggestion solves) is that local fields extending <code>Valued</code> and then mixed char ones extending this and equichar ones extending this topo could just result in a big collection of type-valued classes which maybe runs the risk of diamonds, which the Prop variant definitely doesn't have. </p>\n<p>I think I'm talking myself into the following conclusion: maybe leave <code>Valued</code> alone for now, but go with Yakov's suggestion in <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a> ?</p>",
        "id": 514923055,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745884069
    },
    {
        "content": "<p>(Note: I was not suggesting anything! I was trying to work with the API as currently proposed, asking about how Gamma_K and Gamma_L will interact, which Maria Ines and Filippo explained above with the Galois coinsertion work)</p>",
        "id": 514923704,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1745884474
    },
    {
        "content": "<p>As a matter of fact, we <em>do want to have</em> the liberty of finding<code>Valued R Gamma1</code> and <code>Valued R Gamma2</code>; this is one of the reasons why we pushed away from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mrow><mi>m</mi><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_{m0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. The point is that the valuation from a DVR defined using multiplicities of the maximal ideal is naturally valued in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mrow><mi>m</mi><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_{m0}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> while the one used in the <code>Valuation</code> library (as done in Bourbaki) is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>K</mi><mo>√ó</mo></msup><mi mathvariant=\"normal\">/</mi><mi>R</mi><mo>‚à™</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">K^\\times/R\\cup\\{0\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">√ó</span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚à™</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mclose\">}</span></span></span></span>-valued; and we ended up realising that it is better to leave with both rather than forcing them to land in the same place and carrying the iso over.</p>",
        "id": 514943058,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745896301
    },
    {
        "content": "<p>So do you think <code>outParam</code> should be removed from <code>Œì‚ÇÄ</code> in the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Valued#doc\">docs#Valued</a> ? Can someone remind me what this means in practice for this declaration? I thought it meant \"this class comes with a promise that given R, we'll only ever use one Gamma\".</p>",
        "id": 514990469,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745914023
    },
    {
        "content": "<p>In other words, given an R, the class is currently designed in such a way that Lean would only ever expect one instance of <code>Valued R Gamma</code> for one Gamma.</p>",
        "id": 514990752,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745914113
    },
    {
        "content": "<p>Huh, removing the <code>outParam</code> from the definition of <code>Valued</code> changes the binder type of <code>Œì‚ÇÄ</code> in <code>Valued.toUniformSpace</code> from implicit to explicit.</p>",
        "id": 514991628,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745914393
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24445\">#24445</a> begins to explore this</p>",
        "id": 514993229,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745914885
    },
    {
        "content": "<p>Why is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Valuation.RankOne#doc\">docs#Valuation.RankOne</a> a class? This is data. Do you want to allow a change of choice in this data? If so it shouldn't be a class. <code>[RankOne v]</code> is currently only used once outside the file in which it's defined, in <code>Topology/Algebra/Valued/NormedValued</code>, and it's used as <code>[hv : RankOne val.v]</code>, and then <code>hv</code> is explicitly used 9 times in that file. Shouldn't this be a structure not a class if you want to use it in this way?</p>",
        "id": 514997715,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745916159
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/514990469\">said</a>:</p>\n<blockquote>\n<p>So do you think <code>outParam</code> should be removed from <code>Œì‚ÇÄ</code> in the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Valued#doc\">docs#Valued</a> ? Can someone remind me what this means in practice for this declaration? I thought it meant \"this class comes with a promise that given R, we'll only ever use one Gamma\".</p>\n</blockquote>\n<p>I am not sure that this is my mental model of <code>outParam</code>. I think that the point is that variables that are <code>outParam</code> are meant to be <em>outputs</em> of TC, the idea being that when TC looks for <code>[Ring R] [LinearCommGroup G] [Valued R G]</code> it looks for <code>[Ring R]</code> and before trying to come up with some <code>G</code> (and with its LinearCommGroup structure) it tries to find <code>Valued R G</code>: if it finds it, this will <em>output</em> a <code>G</code>, and only at this point will it try to look for a LinearCommGroup structure on this very <code>G</code>. I don't think there is any risk in marking <code>G</code> as <code>outParam</code> in general (sometimes it might be useless), but it makes sense that <code>G</code> becomes explicit if it is not an <code>outParam</code> any more.</p>",
        "id": 514997995,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745916239
    },
    {
        "content": "<p>I might have all this wrong, I am always a bit unsure about outParams.</p>",
        "id": 514998127,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745916270
    },
    {
        "content": "<p>The bottom line is: are you planning on doing <code>[Valued K Zm0]</code> and then later on <code>[Valued K (K/O^*)]</code> and, if so, will typeclass inference still be happy?</p>",
        "id": 514998476,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745916367
    },
    {
        "content": "<p>I see no reason why it should be unhappy (of course, as long as I do not try to say that these two things <em>coincide</em>)</p>",
        "id": 514998609,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745916411
    },
    {
        "content": "<p>But we've been living with <code>outParam</code>  in <code>Valued</code> for a while, we already have enough on our plate: perhaps we can postpone this point?</p>",
        "id": 514998822,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745916474
    },
    {
        "content": "<p>The point of <a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> is \"the design pattern used to be that discrete valuations took values in <code>‚Ñ§‚Çò‚ÇÄ</code> and we want to change it so that discrete valuations can take values in a more general class of groups with 0 which are isomorphic to this because sometimes we want to change the group with 0\" (which is something we weren't doing before, the point of Zm0 was so that every discrete valuation could take values there). My question is \"is this new design pattern compatible with the <code>outParam</code> in <code>Valued</code>?\" and the answer might be \"yes\", but my understanding of <code>outParam</code> is not good enough to be sure. Thanks for your explanation. I'm still a bit confused by it. Does it answer my question?</p>",
        "id": 515000369,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745916880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/514998476\">said</a>:</p>\n<blockquote>\n<p>The bottom line is: are you planning on doing <code>[Valued K Zm0]</code> and then later on <code>[Valued K (K/O^*)]</code> and, if so, will typeclass inference still be happy?</p>\n</blockquote>\n<p>If you have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valued</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">Zm0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"c1\">-- and then a bit later</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valued</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"bp\">/</span><span class=\"n\">O</span><span class=\"bp\">^*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>then Lean will get confused in the outParam case.</p>",
        "id": 515000967,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1745917034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/515000369\">said</a>:</p>\n<blockquote>\n<p>The point of <a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> is \"the design pattern used to be that discrete valuations took values in <code>‚Ñ§‚Çò‚ÇÄ</code> and we want to change it so that discrete valuations can take values in a more general class of groups with 0 which are isomorphic to this because sometimes we want to change the group with 0\" (which is something we weren't doing before, the point of Zm0 was so that every discrete valuation could take values there). My question is \"is this new design pattern compatible with the <code>outParam</code> in <code>Valued</code>?\" and the answer might be \"yes\", but my understanding of <code>outParam</code> is not good enough to be sure. Thanks for your explanation. I'm still a bit confused by it. Does it answer my question?</p>\n</blockquote>\n<p>Oh, now I understand your question better, sorry.</p>",
        "id": 515001236,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745917103
    },
    {
        "content": "<p>Ah, and Johan replied... <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 515001291,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745917120
    },
    {
        "content": "<p>...and the two of you together convinced me that it is indeed a good idea to remove it <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 515001611,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745917212
    },
    {
        "content": "<p>I agree that this is not something which <a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> should be doing!</p>",
        "id": 515001801,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745917264
    },
    {
        "content": "<p>But we must certainly fix it before going towards <a href=\"https://github.com/leanprover-community/mathlib4/pull/23730\">#23730</a></p>",
        "id": 515002770,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745917543
    },
    {
        "content": "<p>The more I read of this, the more I believe that any specific choice of valuation has to be taken out of the story.</p>",
        "id": 515009526,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1745919440
    },
    {
        "content": "<p>could statements be given as ‚Äúthere is a valuation such that‚Ä¶ ‚Äù for the definition of the structure, and ‚Äúthis valuation is such that‚Ä¶‚Äù when we use it?</p>",
        "id": 515010096,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1745919512
    },
    {
        "content": "<p>I can quite believe that in a completely natural proof we might want a Zm0-valued valuation and a real-valued one. The question is how to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Valued#doc\">docs#Valued</a> in that situation (or if we should be using it at all?).</p>",
        "id": 515018012,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745921251
    },
    {
        "content": "<p>I think that eventually we should shift toward mixins of the following form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Topology</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">IsTopologicalValuation</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">condition</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">ùìù</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"bp\">À£</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">‚äÜ</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">IsValuativePreorder</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">condition</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>",
        "id": 515045271,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1745928694
    },
    {
        "content": "<p>Then the \"discrete\" condition would be a class on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œì</span></span></span></span> itself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">IsDiscreteRankOne</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">condition</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œì</span><span class=\"bp\">À£</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ*</span><span class=\"w\"> </span><span class=\"n\">Multiplicative</span><span class=\"w\"> </span><span class=\"n\">‚Ñ§</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(or some alternative e.g. as suggested by <span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> in the PR)</p>",
        "id": 515045461,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1745928748
    },
    {
        "content": "<p>I don't think removing the outParam from <code>Valued</code> will really solve much. Yes, that means you would be able to write <code>Valued K G</code> for various <code>G</code>s, but Lean is very likely to get confused about what <code>G</code> you're using unless you tell it explicitly. Also, maybe <code>G</code> is fixed, but you have a different normalization. For example, think about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">C</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> with its canonical valuation. The value group (additive, without zero) is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span>, and you can normalize this <em>single</em> value group by choosing any positive rational to be the valuation of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>. I think <code>v</code> itself has to be a parameter to what ever class we end up with.</p>",
        "id": 515100495,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1745941497
    },
    {
        "content": "<p>Adam's comments are convincing. It's difficult to imagine typeclass inference working with <code>Valued</code> and also having the flexibility to change both v and Gamma.</p>",
        "id": 515121440,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745947265
    },
    {
        "content": "<p>Well, but in our definition local fields have finite residue fields (as in Serre's book) and therefore have a <em>unique preferred</em> valuation. I think that <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> suggestions are very much reasonable if we're trying to set-up the more general notion of \"valuable\" (nonarchimedean, say) field.</p>\n<p>Our starting observation is that <em>in practice</em> almost all proofs/arguments require the choice of a valuation, and typically consider the normalized one. In this sense, although <em>in principle</em> a local field can come with several valuations (but not \"as many\" as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">C</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>, in the sense that there exists a preferred one), fixing the normalized valuation on it is the first step one systematically performs.</p>\n<p>The situation reminded us very much of the class <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Metrizable/Basic.html#TopologicalSpace.MetrizableSpace\">TopologicalSpace.MetrizableSpace</a>, together with its <code>def</code>¬†<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Metrizable/Basic.html#TopologicalSpace.metrizableSpaceMetric\">TopologicalSpace.metrizableSpaceMetric</a>: observe that even for metrizable spaces, most of the library is developed for <code>MetricSpace</code> and the user systematically applies the <code>def</code>. In this perspective, it seems to me that</p>\n<ul>\n<li>Adam's and Antoine's suggestions somewhat go towards defining a parallel of the <code>Metrizable</code> structure;</li>\n<li>Our work is alike the <code>Metric</code> structure, in the sense that we're setting up the technology needed to formalise all statements/proofs that use, or involve, the normalized valuation.</li>\n</ul>\n<p>Am I wrong in saying that we seem to be addressing two problems at once (and, if so, we might want to find two separate solutions, so it feels like we're going back to the <code>ValuedLocalField</code> proposal), namely:</p>\n<ol>\n<li>What is the most elegant set-up to speak about a valuable field, possibly with  the least number of assumptions? And</li>\n<li>What is the best approach to put your hands on all proofs e.g. in Serre's <em>Local Fields</em> that use the normalised valuation all over the places?</li>\n</ol>",
        "id": 515212273,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745992095
    },
    {
        "content": "<blockquote>\n<p>and therefore have a <em>unique preferred valuation</em></p>\n</blockquote>\n<p>But they don't have a unique preferred valuation any more because in <a href=\"https://github.com/leanprover-community/mathlib4/pull/23727\">#23727</a> you want to move away from Zm0 so suddenly there is this ambiguity in Gamma</p>",
        "id": 515222470,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745996329
    },
    {
        "content": "<p>And right now the entire theory is set up so that Gamma is supposed to be uniquely guessable</p>",
        "id": 515222545,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745996361
    },
    {
        "content": "<p>Oh well, concerning the \"guessability\" of Gamma, I agreed with you that this should be removed</p>",
        "id": 515222647,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745996399
    },
    {
        "content": "<p>At any rate, I am in principle OK with Adam's approach, so long we have a way, given a local field and a Gamma (with the right assumptions, like \"being isomorphic to Z\", morally), to pick up \"the normalized Gamma-valued valuation \"</p>",
        "id": 515223088,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745996541
    },
    {
        "content": "<p>But, as expressed in my message above, it is not entirely clear to me if we're not trying to solve the problem \"this definition involves valuations whereas it should not be part of the data\", by shifting away from a design that concretely provides us with a working way to swiftly pick up a discrete valuation on every local field.</p>",
        "id": 515223483,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745996680
    },
    {
        "content": "<p>What would you want for the choice of Gamma for this discrete valuation? Would the idea be that the user provides it or would you want this swift discrete valuation to take values in Zm0? I think design decisions will be affected by how exactly you want to use this general cyclic Gamma, and you and Maria Ines know about this much better than anyone else.</p>",
        "id": 515231747,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745999425
    },
    {
        "content": "<p>We expected the author to provide it explicitly, but I am experimenting something along Adam's suggestions. I hope to soon report on the outcome.</p>",
        "id": 515232183,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1745999549
    },
    {
        "content": "<p>Note on the following: I am not trying to bikeshed on the class, and have been working at trying to generalize my previous work from NontriviallyNormedField to Valued, because I trust in our common designs. </p>\n<p>The difference between Valued and MetricSpace is that in MetricSpace, we don't parametrize over an arbitrary linearly ordered (semi) field. We could, but for all intents and purposes, they would be injective into or isomorphic as ordered (semi)fields to the reals.</p>\n<p>If we are working here over the extensions (not necessarily finite) over Q_p, and talking about discrete and normalized valuations, then necessarily these are rank one valuations. If discrete, they _could_ take values in Zm0. And thus, they can take values in NNReal in a way that is compatible with \"upgrading\" the valuation to a nonarchimedean norm. Yes, the \"base\" of the norm in the upgrade is arbitrary, but the uniform space structure is the same -- the norms are equivalent. </p>\n<p>I understand why going all the way to the norm is limiting for further generalizations, and makes it a little clunky if discussing how valuations extend in extensions. But if we're comparing to MetricSpace, I would say the more parallel comparison is to NontriviallyNormedField. And Valued is a class that does not have a parallel between MetrizableSpace and MetricSpace.</p>\n<p>I can't find it right now, but I remember working on a PR with Maria Ines and David Loeffler where we upgraded to a NormedAddGroup during a proof about some nonarchimedean sums (iirc) . The statement didn't refer to a norm, but one could do the upgrade and use the more narrow lemmas.</p>",
        "id": 515260372,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746007510
    },
    {
        "content": "<p>FWIW, here is how I would set up the notion of a (possibly equal characteristic) nonarch local field:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Topology</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">Valuation.IsTopologicalValuation</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">condition</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">ùìù</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"bp\">À£</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">‚äÜ</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Multiplicative</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">Valuation.IsDiscreteRankOne</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">condition</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidHom.mrange</span><span class=\"w\"> </span><span class=\"n\">v.toMonoidHom</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ*</span><span class=\"w\"> </span><span class=\"n\">‚Ñ§‚Çò‚ÇÄ</span>\n\n<span class=\"n\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Valuation.ResidueField</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">IsLocalRing.ResidueField</span><span class=\"w\"> </span><span class=\"n\">v.valuationSubring</span>\n\n<span class=\"kd\">variable</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">UniformSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalDivisionRing</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">v.IsTopologicalValuation</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">v.IsDiscreteRankOne</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">v.ResidueField</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 515330521,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1746025761
    },
    {
        "content": "<p>Note that this doesn't assume that the valuation is surjective onto <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> with zero, but just that its image is isomorphic to this.</p>",
        "id": 515330648,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1746025801
    },
    {
        "content": "<p>BTW <code>Nonempty &lt;| (MonoidHom.mrange v.toMonoidHom) ‚âÉ* ‚Ñ§‚Çò‚ÇÄ</code> is equivalent to not DenselyOrdered: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearOrderedCommGroupWithZero.discrete_iff_not_denselyOrdered#doc\">docs#LinearOrderedCommGroupWithZero.discrete_iff_not_denselyOrdered</a>. This does require <code>MulArchimedean</code>, but if you had such an mul-order-iso, you could transfer over <code>MulArchimedean</code>.</p>",
        "id": 515332347,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746026222
    },
    {
        "content": "<p>But not all value groups that show up in nature are <code>MulArchemedean</code> :)</p>",
        "id": 515332508,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1746026272
    },
    {
        "content": "<p>For example you may want to consider the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>-adic valuation on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> taking values in the value group of the <em>rank 2</em> valuation on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k(x,y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> associated to the flag <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>=</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>‚äÇ</mo><mo stretchy=\"false\">(</mo><mi>y</mi><mo>=</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(x = y = 0) \\subset (y = 0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚äÇ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 515332854,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1746026359
    },
    {
        "content": "<p>Yes, agreed, but the <code>mrange</code> would be! If the <code>mrange</code> is mul-order-iso to Zm0.</p>",
        "id": 515333009,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746026402
    },
    {
        "content": "<p>Concretely the value group of the rank 2 valuation is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo>√ó</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z \\times \\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7722em;vertical-align:-0.0833em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">√ó</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> with the lexicographic order and the value group of the valuation on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>√ó</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">0 \\times \\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">√ó</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>.</p>",
        "id": 515333043,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1746026403
    },
    {
        "content": "<p>Oh, I see.</p>",
        "id": 515333103,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1746026415
    },
    {
        "content": "<p>As seen in the statement of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isPrincipalIdealRing_iff_not_denselyOrdered#doc\">docs#isPrincipalIdealRing_iff_not_denselyOrdered</a></p>",
        "id": 515333242,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746026461
    },
    {
        "content": "<p>(Ah, that statement does have <code>MulArchimedean Œì‚ÇÄ</code> ...)</p>",
        "id": 515333496,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746026532
    },
    {
        "content": "<p>So you want something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Multiplicative</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">Valuation.IsDiscreteRankOne</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">rankOne</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MulArchimedean</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">MonoidHom.mrange</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">nonDense</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DenselyOrdered</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">MonoidHom.mrange</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 515333524,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1746026539
    },
    {
        "content": "<p>Yes, these are all equivalent.</p>",
        "id": 515333598,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746026562
    },
    {
        "content": "<p>And I'm pretty sure that if you have a mul-order-iso to Zm0, that is unique. Haven't formalized it.</p>",
        "id": 515333653,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1746026581
    },
    {
        "content": "<p>Yeah it's unique, there is a unique largest element <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">&lt; 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> which is \"the value of a uniformizer\".</p>",
        "id": 515333794,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1746026625
    },
    {
        "content": "<p>These are all props at the end of the day, so we can pretty easily go back and forth between the various approaches.</p>",
        "id": 515334169,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1746026718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20extensions.20of.20Q_p/near/515333653\">said</a>:</p>\n<blockquote>\n<p>And I'm pretty sure that if you have a mul-order-iso to Zm0, that is unique. Haven't formalized it.</p>\n</blockquote>\n<p><a href=\"https://github.com/matthewjasper/mathlib4/commit/ebefa469e075a5226a56111c75b972a0217f00eb\">https://github.com/matthewjasper/mathlib4/commit/ebefa469e075a5226a56111c75b972a0217f00eb</a> has a proof for <code>Unique (‚Ñ§‚Çò‚ÇÄ ‚âÉ*o ‚Ñ§‚Çò‚ÇÄ)</code>, which is most of the way there.</p>",
        "id": 515582931,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1746133938
    },
    {
        "content": "<p>Thanks! I am currently trying to perform some tests on our repo but I am very busy in Beijing and cannot work a lot on the project until next Tue. I will probably use much of the work I'm seeing here though <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 515615379,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1746149765
    }
]