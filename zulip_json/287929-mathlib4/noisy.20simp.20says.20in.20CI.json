[
    {
        "content": "<p>I can't be the only one who's been plagued by noisy <code>simp? says</code> causing CI to fail, right? e.g. <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/17538151883/job/49804893528?pr=26331\">https://github.com/leanprover-community/mathlib4/actions/runs/17538151883/job/49804893528?pr=26331</a></p>\n<p>I think in basically any scenario where the simp is _confluent_ but there are _multiple paths_ to simplify into a common form, <code>simp? says</code> is bound to pseudorandomly vary. And it makes it very annoying to fix when it twiddles back and forth all over mathlib in files you're not touching</p>",
        "id": 538125921,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1757303385
    },
    {
        "content": "<p>I would be in favour of moving everything back to a plain <code>simp</code>.</p>",
        "id": 538195451,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1757329858
    },
    {
        "content": "<p>In another (possibly private) channel, <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> suggested that <code>simp? says</code> was a \"failed experiment\" so I would imagine that nobody will be objecting to removing them from <code>mathlib</code>.</p>",
        "id": 538197934,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757330642
    },
    {
        "content": "<p>Another reason for removing <code>simp? says</code> is that it causes differences between CI oleans and locally-built (i.e. without setting the CI environment variable to <code>true</code>) oleans.</p>",
        "id": 538198597,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1757330850
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/noisy.20simp.20says.20in.20CI/near/538197934\">said</a>:</p>\n<blockquote>\n<p>In another (possibly private) channel, <span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> suggested that <code>simp? says</code> was a \"failed experiment\" so I would imagine that nobody will be objecting to removing them from <code>mathlib</code>.</p>\n</blockquote>\n<p><a class=\"message-link\" href=\"/#narrow/channel/428973-nightly-testing/topic/Mathlib.20status.20updates/near/535229602\">#nightly-testing &gt; Mathlib status updates @ üí¨</a></p>",
        "id": 538199206,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1757331049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/noisy.20simp.20says.20in.20CI/near/538197934\">said</a>:</p>\n<blockquote>\n<p>@Kim Morrison suggested that <code>simp? says</code> was a \"failed experiment\" so I would imagine that nobody will be objecting to removing them from <code>mathlib</code>.</p>\n</blockquote>\n<p>Don't remove Kim from mathlib! <span aria-label=\"fear\" class=\"emoji emoji-1f628\" role=\"img\" title=\"fear\">:fear:</span></p>",
        "id": 538214132,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1757335088
    },
    {
        "content": "<p>I'll get started on a PR to remove <code>simp? says</code>.</p>",
        "id": 538219242,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1757336388
    },
    {
        "content": "<p>I'm a big fan of <code>simp? says</code>: when there are very heavy simps, it is very valuable information to know which lemmas are interesting (those not in the default simp set), and which are not (coming from the default simp set). Otherwise, when the <code>simp only</code> breaks, it is very hard to fix. This happens often in differential geometry, which is simp very heavy. I already said that in <a href=\"#narrow/channel/287929-mathlib4/topic/Lint.20error.20with.20.60Simp.20says.60/near/535693447\">#mathlib4 &gt; Lint error with &#96;Simp says&#96; @ üí¨</a></p>",
        "id": 538222084,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1757336985
    },
    {
        "content": "<p>I think the solution is to write:</p>\n<ol>\n<li>a wrapper for simp that allows you to write something like <code>simp only [foo, bar] ++ [X, Y]</code>, and just translates this to <code>simp only [foo, bar, X, Y]</code></li>\n<li>maybe this wrapper should verify that everything in the first set is not in the standard simp set, and everything in the second set is</li>\n<li>then some <code>simp?'</code> that generates this sort of output</li>\n</ol>",
        "id": 538223013,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757337194
    },
    {
        "content": "<p>arguably <em>all</em> <code>simp only</code> should be converted to this form</p>",
        "id": 538223548,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757337327
    },
    {
        "content": "<p>maybe we could write <code>simp only [foo, bar; X, Y]</code> or similar to keep the noise down</p>",
        "id": 538223681,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757337364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/noisy.20simp.20says.20in.20CI/near/538223548\">said</a>:</p>\n<blockquote>\n<p>arguably <em>all</em> <code>simp only</code> should be converted to this form</p>\n</blockquote>\n<p>I not infrequently write <code>simp only [foo]</code> with just one argument, because really I am doing a sort of rewrite, under binders, and applying <code>foo</code> in several distinct places. I feel like that would be an exception. Although maybe <code>simp only [foo;]</code> or <code>simp only [;foo]</code> isn't that much worse. (I think it would be one extra thing to scare newcomers though.)</p>",
        "id": 538224057,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1757337464
    },
    {
        "content": "<p>Yes, there are many cases of <code>simp only</code>'s where everything is in the standard simp set (usually,  <code>Category.assoc, Functor.map_comp</code>, etc.), <code>simp only [] ++ [...]</code> would feel very weird...</p>",
        "id": 538224509,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1757337565
    },
    {
        "content": "<p>One thing that is unfortunate about the <code>simp only [foo, bar; X, Y]</code> proposal is that often the order of the lemmas is actually pretty close to the order they are applied in (indeed, sometimes one can successfully replace a <code>simp only</code> with a <code>simp_rw</code> in Mathlib), and having to split things before and after a divider obscures this.</p>",
        "id": 538224533,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757337572
    },
    {
        "content": "<p>I agree that often everything is in the simp set. So these should just stay with the current syntax.</p>",
        "id": 538224845,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757337646
    },
    {
        "content": "<p>I consider there are three kinds of <code>simp? says</code>:</p>\n<ol>\n<li>a terminal <code>simp?</code>/<code>simpa?</code>: I'm turning this into <code>simp</code>/<code>simpa</code></li>\n<li><code>simp? [foo] says simp only [foo]</code>: I'm turning this into <code>simp only [foo]</code></li>\n<li><code>simp? [foo] says simp only [foo, ...]</code> with a long list of arguments: here we seem to have the actual disagreements.</li>\n</ol>\n<p>I'll make sure to batch the changes into these three kinds, so we can deal with them in turn.</p>\n<p>An alternative approach for 3 is to make it more declarative: instead of <code>simp?</code>/<code>simp only</code> we can write a <code>suffices</code> with the intended goal type.</p>",
        "id": 538228050,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1757338403
    },
    {
        "content": "<p>Indeed <code>suffices</code> was a common Lean 3 idiom in this setting.</p>",
        "id": 538235394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757340248
    },
    {
        "content": "<p>Would keeping the order, but marking with a <code>+</code> the lemmas that appear before squeezing be reasonable?  There is already <code>-</code> to remove from the simp set, so having a <code>+</code> to mean \"really add this\" could work?</p>",
        "id": 538240848,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1757341555
    },
    {
        "content": "<p>I have turned to <code>suffices</code> a few times when the simp only list looks long and ugly</p>",
        "id": 538258867,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1757345737
    },
    {
        "content": "<p>Alright, PRs are in. I looked over all <code>says</code>es excluding those in <code>MathlibTest</code> and <code>Mathlib/Tactic/Says</code>. The edits are split out by controversiality:</p>\n<ul>\n<li>Replacing <code>simp? says</code> with a terminal tactic: <a href=\"https://github.com/leanprover-community/mathlib4/pull/29440\">#29440</a></li>\n<li>Replacing <code>simp? says</code> with <code>suffices</code>/<code>have</code>: <a href=\"https://github.com/leanprover-community/mathlib4/pull/29441\">#29441</a></li>\n<li>Replacing <code>simp? says</code> with <code>simp only</code>: <a href=\"https://github.com/leanprover-community/mathlib4/pull/29442\">#29442</a></li>\n</ul>",
        "id": 538274674,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1757349726
    },
    {
        "content": "<p>Thanks! I'm very happy with the first two, still not completely convinced by the last one. Random example: going from</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">simp?</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HomologicalComplex‚ÇÇ</span><span class=\"bp\">.</span><span class=\"n\">total_d</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"bp\">.</span><span class=\"n\">comm</span><span class=\"w\"> </span><span class=\"n\">i‚ÇÅ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dFrom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fromNext</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toPrev</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dTo</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">says</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Œπ_mapBifunctorMap</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"bp\">.</span><span class=\"n\">comm</span><span class=\"w\"> </span><span class=\"n\">i‚ÇÅ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dNext_eq_dFrom_fromNext</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dFrom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fromNext</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">AddMonoidHom</span><span class=\"bp\">.</span><span class=\"n\">mk'_apply</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prevD_eq_toPrev_dTo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toPrev</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dTo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">map_add</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">map_comp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">NatTrans</span><span class=\"bp\">.</span><span class=\"n\">app_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">NatTrans</span><span class=\"bp\">.</span><span class=\"n\">comp_app</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">Preadditive</span><span class=\"bp\">.</span><span class=\"n\">add_comp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">HomologicalComplex‚ÇÇ</span><span class=\"bp\">.</span><span class=\"n\">total_d</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">mapBifunctorHomologicalComplex_obj_obj_toGradedObject</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Preadditive</span><span class=\"bp\">.</span><span class=\"n\">comp_add</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">HomologicalComplex‚ÇÇ</span><span class=\"bp\">.</span><span class=\"n\">Œπ_D‚ÇÅ_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">mapBifunctorHomologicalComplex_obj_obj_X_X</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">HomologicalComplex‚ÇÇ</span><span class=\"bp\">.</span><span class=\"n\">Œπ_D‚ÇÇ_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_left_inj</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Œπ_mapBifunctorMap</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"bp\">.</span><span class=\"n\">comm</span><span class=\"w\"> </span><span class=\"n\">i‚ÇÅ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dNext_eq_dFrom_fromNext</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dFrom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fromNext</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">AddMonoidHom</span><span class=\"bp\">.</span><span class=\"n\">mk'_apply</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prevD_eq_toPrev_dTo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toPrev</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dTo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">map_add</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">map_comp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">NatTrans</span><span class=\"bp\">.</span><span class=\"n\">app_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">NatTrans</span><span class=\"bp\">.</span><span class=\"n\">comp_app</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Preadditive</span><span class=\"bp\">.</span><span class=\"n\">add_comp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">HomologicalComplex‚ÇÇ</span><span class=\"bp\">.</span><span class=\"n\">total_d</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">mapBifunctorHomologicalComplex_obj_obj_toGradedObject</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Preadditive</span><span class=\"bp\">.</span><span class=\"n\">comp_add</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">HomologicalComplex‚ÇÇ</span><span class=\"bp\">.</span><span class=\"n\">Œπ_D‚ÇÅ_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">mapBifunctorHomologicalComplex_obj_obj_X_X</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">HomologicalComplex‚ÇÇ</span><span class=\"bp\">.</span><span class=\"n\">Œπ_D‚ÇÇ_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_left_inj</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>looks like a worsening to me.</p>",
        "id": 538276727,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1757350415
    },
    {
        "content": "<p>What about a compromise of putting just a comment above?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- simp [HomologicalComplex‚ÇÇ.total_d, h‚ÇÅ.comm i‚ÇÅ, dFrom, fromNext, toPrev, dTo]</span>\n<span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Œπ_mapBifunctorMap</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"bp\">.</span><span class=\"n\">comm</span><span class=\"w\"> </span><span class=\"n\">i‚ÇÅ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dNext_eq_dFrom_fromNext</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dFrom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fromNext</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">AddMonoidHom</span><span class=\"bp\">.</span><span class=\"n\">mk'_apply</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prevD_eq_toPrev_dTo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toPrev</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dTo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">map_add</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">map_comp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">NatTrans</span><span class=\"bp\">.</span><span class=\"n\">app_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">NatTrans</span><span class=\"bp\">.</span><span class=\"n\">comp_app</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Preadditive</span><span class=\"bp\">.</span><span class=\"n\">add_comp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">HomologicalComplex‚ÇÇ</span><span class=\"bp\">.</span><span class=\"n\">total_d</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">mapBifunctorHomologicalComplex_obj_obj_toGradedObject</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Preadditive</span><span class=\"bp\">.</span><span class=\"n\">comp_add</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">HomologicalComplex‚ÇÇ</span><span class=\"bp\">.</span><span class=\"n\">Œπ_D‚ÇÅ_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">mapBifunctorHomologicalComplex_obj_obj_X_X</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">HomologicalComplex‚ÇÇ</span><span class=\"bp\">.</span><span class=\"n\">Œπ_D‚ÇÇ_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_left_inj</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>when we really want to preserve that information</p>",
        "id": 538282086,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1757352629
    },
    {
        "content": "<p>Yes, this is what I have been doing in my most recent code.</p>",
        "id": 538285131,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1757353862
    },
    {
        "content": "<p>This kind of comment will automatically become a lie as the simp set changes.</p>",
        "id": 538288770,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1757355223
    },
    {
        "content": "<p>It's only a lie if you interpret it as a promise that \"this code produces this output\". It's not a lie if you interpret it as \"this code was originally used to discover this other code\", and they may well be all that is needed</p>",
        "id": 538290247,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1757355743
    },
    {
        "content": "<p>Indeed, I would usually write something like <code>-- this was generated by simp? [...]</code>. In case the proof breaks in the future, the information of the original \"minimal\" list of lemma can be very fulpful in order to fix the proof, and the comment can be updated.</p>",
        "id": 538296443,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1757358113
    },
    {
        "content": "<p>I agree that the comment is better than nothing, but it saddens me that the final code gets obscured by squeezing the <code>simp</code> and that there is no good alternative to this.</p>",
        "id": 538296825,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1757358254
    },
    {
        "content": "<p>Yes, let's not merge the 3rd PR.</p>\n<p>Does anyone want to implement <code>simp [X, Y; foo, bar]</code> or <code>simp [+X, +Y, foo, bar]</code> as suggested above? Hopefully either of these can just be done in Mathlib itself.</p>",
        "id": 538410580,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757416405
    },
    {
        "content": "<p>I like the second one a lot given the existence of the <code>simp [-X, -Y, foo, bar]</code> syntax</p>",
        "id": 538420537,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1757419624
    },
    {
        "content": "<p>To throw another hat into the ring: before <code>simp says</code>, I wanted to implement a \"simp caching\" mechanism, where we would have the \"short simps\" of type 3 in the main codebase, whilst the long expanded simp onlys were either elsewhere or by default folded in the code editor. Importantly, the original command wasn't run [only type-checked for lemma renamings etc]; only this cached command. So how about we implement <code>simp? said</code> that does that?</p>",
        "id": 538443152,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1757425914
    },
    {
        "content": "<p>Where would said cache be stored?</p>",
        "id": 538450664,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1757427830
    },
    {
        "content": "<p>Back then, my vision was a separate file; but I think just keeping this as <code>simp? said simp [...]</code> would be fine</p>",
        "id": 538454921,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1757428878
    },
    {
        "content": "<p>I don't see how what you're describing is different from the current behavior of <code>simp? says</code> (when <code>says.verifier</code> is false)</p>",
        "id": 538458816,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1757429910
    },
    {
        "content": "<p>Ah, I wasn't aware of <code>says.verifer</code> - I guess I'm then advocating for that to be off</p>",
        "id": 538478274,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1757435236
    },
    {
        "content": "<p>It's off except in CI, where it's on so that we can make sure what it <code>says</code> still works before we merge. So it seems like you are advocating for the status quo.</p>",
        "id": 538480203,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1757435864
    },
    {
        "content": "<p>There does seem to be some unfortunate interaction with the cache, where a PR can pass CI even if it causes <code>says</code> to fail if <code>lake build</code> ends up using the cache files for the files containing the outdated <code>says</code>. Then someone else who didn't cause the failure might end up having to fix it just because their PR happened to trigger a rebuild.</p>",
        "id": 538481441,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1757436288
    },
    {
        "content": "<p>Jireh - I'm advocating that it should not cause CI failures even if the suggested text is completely wrong, as long as it's a valid lean tactic. Even something like <code>exact h says simp [h, add_comm]</code> should be fine.</p>\n<p>To me , <code>X says Y</code> tells me: I wanted to apply tactic <code>X</code>, but this is not appropriate for mathlib due to [tactic stability/speed/otherwise], so therefore I must actually use tactic <code>Y</code>.</p>",
        "id": 538494713,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1757439555
    },
    {
        "content": "<p>This would also allow for things like <code>polyrith says XYZ</code>, which could be nice</p>",
        "id": 538495869,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1757439895
    },
    {
        "content": "<p>That seems almost like having a comment, then, except that it gets checked for valid syntax, and gets correct syntax highlighting? </p>\n<p>So is the idea that there would be a <code>says</code> present tense which means \"this currently says this\" and is checked in CI, and a <code>said</code> past tense which just means \"this said this once but no promises now\", and it ignores the <code>verify</code> flag?</p>",
        "id": 538496474,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1757440091
    },
    {
        "content": "<p>Or maybe instead of <code>said</code>, something like <code>became</code> , to remove the connotation that this was output (like in Eric's other examples)</p>",
        "id": 538496904,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1757440267
    },
    {
        "content": "<p>PR for this: <a href=\"https://github.com/leanprover-community/mathlib4/pull/29488\">#29488</a></p>",
        "id": 538561513,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1757474546
    },
    {
        "content": "<p>/poll Best way to express this?<br>\nX said Y<br>\nX became Y<br>\nThis kind of tactic shouldn't exist</p>",
        "id": 538561536,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1757474582
    },
    {
        "content": "<p>I might propose <code>once_said</code> or <code>says (on := \"YYYY-MM-DD\")</code>, but I think it would be important to first collectively answer the following three questions:</p>\n<ol>\n<li>Who exactly is the audience of this (effective) comment? What are they meant to get out of it? What are the costs?</li>\n<li>When should it be used instead of <code>says</code>?</li>\n<li>What should be the possible long-term fates of this code? What are the expectations for what to do about it when it becomes outdated? How should it be maintained?</li>\n</ol>\n<p>My personal answer to (1) would be the same as any comment: \"future maintainers of the proof, who want to know why it was written this way\". Communicating the intent behind code, from past to future, seems useful in general, so this seems like a point in favor to me.</p>\n<p>But this is a duty well-performed by an ordinary comment, so we've got the cost of new syntax and (arguably) readability. I think the only thing that would elevate <code>said</code>/<code>once_said</code> above an ordinary comment and warrant the syntax is if we could, actually, verify that it did say this, or check what it says now (even if, unlike <code>says</code>, we decline to do so during CI).</p>\n<p>Are there other answers to (1)?</p>\n<p>I'm not sure I see immediate, canonical answers to questions 2 and 3, and they're important questions for reviewing new code and maintaining existing code, which makes me pause.</p>\n<p>I think a reasonable answer to (2) would be \"only when both of the following are true: suggestions are liable to change or the result would likely not have been human-generated; the suggested tactic is a 'refined' or 'completed' version of the suggesting tactic (e.g. nothing similar to <code>hint said ...</code>)\". The noisiness issue is mentioned in <a href=\"https://github.com/leanprover-community/mathlib4/pull/29488\">#29488</a>, but not the other parts.</p>\n<p>I think (3) presents a real ambiguity, though. If someone is cleaning up a proof and notices that we have <code>tac1? once_said tac2</code> but <code>tac1?</code> now says <code>tac3</code>, when should they change it? </p>\n<p>I'm tempted to suggest a \"chore model\" wherein we write <code>says (on := \"YYYY-MM-DD\")</code> such that an automated PR, made relatively infrequently (and independently of ordinary CI), could turn on an option, re-run the suggesting tactic for each dated <code>says</code>, and</p>\n<ol>\n<li>if the result is the same, update the date to the current date</li>\n<li>if the result is different, check if the resulting <em>tactic state</em> is (meaningfully) different than the one produced by the recorded suggestion. If so, report the change somewhere (e.g. on the PR description).</li>\n</ol>\n<p>But that seems complex, and I'd be reluctant to introduce these sorts of long-term chores and extra automation without a sufficiently good reason.</p>",
        "id": 538568943,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1757481077
    },
    {
        "content": "<p>I wonder if we could fix the noisiness issue just by having some variant of <code>says</code>, like <code>tac1? says +upToSyntax tac2</code>, which still runs during every CI, but only compares the tactic state produced by <code>tac1?</code>'s current suggestion to the tactic state produced by <code>tac2</code>, ignoring any differences in syntax.</p>\n<p>This protects against regressions (both still have to work) and alerts us to pro(?)gressions (where <code>tac1?</code> is able to suggest something better).</p>\n<p>Are there cases where this wouldn't be what we want, and we'd still want something like <code>said</code> or <code>says (on := \"YYYY-MM-DD\")</code>?</p>",
        "id": 538569053,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1757481151
    },
    {
        "content": "<p>I really do not like intentionally leaving unchecked code in the repository. It is just a recipe for accumulating rot.</p>",
        "id": 538576687,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1757486252
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span>, re: your comment on <a href=\"https://github.com/leanprover-community/mathlib4/pull/29488\">#29488</a>, there's more discussion here<br>\nAt least one benefit for <code>x said y</code> over <code>-- x \\n y</code> is that the former checks the syntax for correctness, and at least in principle stores some extra info in the syntax tree</p>",
        "id": 540810605,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1758549261
    },
    {
        "content": "<p>I thought the point of <code>said</code> was that, as opposed to <code>says</code>, it does not verify the correctness of the tactic. So I don't understand why you would want it to check the syntax for correctness.</p>",
        "id": 540811524,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758549455
    },
    {
        "content": "<p>By the way I completely agree with you that <code>simp? says</code> is annoying in CI</p>",
        "id": 540812636,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758549695
    },
    {
        "content": "<p>I'm coming late to this topic, after just realizing Mathlib doesn't contain any <code>simp? says</code> anymore.</p>\n<p>IIUC, it was removed because CI was annoying, because unnecessary/unneeded changes to the RHS were suggested.<br>\nDid we consider changing the semantics of <code>t says s</code> (or similar syntax) to mean</p>\n<ul>\n<li>For users: it executes <code>s</code></li>\n<li>For CI (or CI once a ~week): it checks that <code>t</code> and <code>s</code> both (independently) close the goal (assuming it's finishing). It does <em>not</em> check whether <code>t</code> produces the output <code>s</code> (which is noisy/fragile).</li>\n</ul>",
        "id": 555566861,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1763120477
    },
    {
        "content": "<p>For that use, <code>says</code> seems less appropriate than <code>as well as</code>/<code>alternatively</code>.</p>",
        "id": 555569126,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1763121184
    },
    {
        "content": "<p>I'm happy to rename what the tactic is called, but I think the functionality is useful.</p>",
        "id": 555592426,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1763128275
    }
]