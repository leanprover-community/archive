[
    {
        "content": "<p><code>Data.List.Cycle</code> contains a lot of theorems with redundant hypotheses:</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.next_cons_cons_eq%27#doc\">docs#List.next_cons_cons_eq'</a> has <code>x = y</code> and <code>x ∈ y :: z :: l</code></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.next_cons_cons_eq#doc\">docs#List.next_cons_cons_eq</a> has <code>x ∈ x :: z :: l</code></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.next_ne_head_ne_getLast#doc\">docs#List.next_ne_head_ne_getLast</a> has <code>x ∈ l</code> and <code>x ∈ y :: l</code></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.next_cons_concat#doc\">docs#List.next_cons_concat</a> has <code>x ∈ y :: l ++ [x]</code> (although it does have a proof as a default value)</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.next_getLast_cons#doc\">docs#List.next_getLast_cons</a> has <code>x ∈ l</code> and <code>x ∈ y :: l</code> (and also <code>x ≠ y</code>)</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.prev_getLast_cons%27#doc\">docs#List.prev_getLast_cons'</a> has <code>x = y</code> and <code>x ∈ y :: l</code></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.prev_getLast_cons#doc\">docs#List.prev_getLast_cons</a> has <code>x ∈ x :: l</code></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.prev_cons_cons_eq%27#doc\">docs#List.prev_cons_cons_eq'</a> has <code>x = y</code> and <code>x ∈ y :: z :: l</code></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.prev_cons_cons_eq#doc\">docs#List.prev_cons_cons_eq</a> has <code>x ∈ x :: z :: l</code></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.prev_cons_cons_of_ne%27#doc\">docs#List.prev_cons_cons_of_ne'</a> has <code>x = z</code> and <code>x ∈ y :: z :: l</code></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.prev_cons_cons_of_ne#doc\">docs#List.prev_cons_cons_of_ne</a> has <code>x ∈ y :: x :: l</code></li>\n</ul>\n<p>I believe most of them exist because the statement itself needs a proof of them, and while they trivially follow from the other hypotheses they make the statement much longer. E.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">next_cons_cons_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_cons</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>vs.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">next_cons_cons_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>I think we should remove the redundancy and fill in the proofs. Many of them are solved <code>by simp</code> (such as the example above) so they don't take up that much space, but more importantly I think it burdens the caller to provide more proofs to use a theorem which shouldn't require such a proof.</p>\n<p>What are your thoughts on this? How common is it across Mathlib to add a redundant hypothesis to simplify a statement? Is the default parameter approach a best-of-both-worlds? Or perhaps a <code>have</code> inside the theorem statement?</p>",
        "id": 558854928,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1763860459
    },
    {
        "content": "<p>but it makes unifying them easier</p>",
        "id": 558859149,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763865307
    },
    {
        "content": "<p>unifying who?</p>",
        "id": 558859352,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1763865536
    },
    {
        "content": "<p>I guess unifying the conclusion of the theorem?</p>",
        "id": 558859368,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763865553
    },
    {
        "content": "<p>I'm not looking at the statements right now so this is just a guess</p>",
        "id": 558859378,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763865572
    },
    {
        "content": "<p>From my experience proof irrelevance applies when unifying, so replacing a proof variable by a proof term shouldn't make a difference for unification</p>",
        "id": 558859803,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1763866104
    },
    {
        "content": "<p>Supplying the hypothesis as part of the arguments to the lemma vs directly in the statement allows for rw to work with side goals.</p>",
        "id": 558872947,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1763882200
    },
    {
        "content": "<p>If you inline the proof, then you don't match syntactically</p>",
        "id": 558872981,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1763882228
    },
    {
        "content": "<p><code>rw</code> works even when the proofs differ</p>",
        "id": 558873018,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1763882271
    },
    {
        "content": "<p>Although if we're talking about rewriting the parts which aren't the proofs, then a variable proof might save a few \"motive is not type correct\" errors, but that'll just help the theorem proof and won't help the user at all. So again I don't see an advantage</p>",
        "id": 558873607,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1763882897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Redundant.20hypotheses.20in.20.60Data.2EList.2ECycle.60/near/558873018\">said</a>:</p>\n<blockquote>\n<p><code>rw</code> works even when the proofs differ</p>\n</blockquote>\n<p>Because the proofs don't differ.</p>",
        "id": 558910136,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1763919417
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"933054\">@Snir Broshi</span> I advocate to not drop the <code>x = y</code> hyps. Those lift a defeq to a propeq, which can be genuinely useful in applications.<br>\nThe other types of hyps, I don't mind dropping.</p>",
        "id": 558976449,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1763972901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Redundant.20hypotheses.20in.20.60Data.2EList.2ECycle.60/near/558976449\">said</a>:</p>\n<blockquote>\n<p>Those lift a defeq to a propeq, which can be genuinely useful in applications.</p>\n</blockquote>\n<p>I agree they're useful, but doesn't the <code>convert</code> tactic solve that problem already?</p>",
        "id": 559129952,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1764011331
    },
    {
        "content": "<p>It's a bit of a hammer though, and you have to give up any form of fine-grained control over defeqs when you use it.</p>",
        "id": 559133166,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1764012179
    },
    {
        "content": "<p><code>convert</code> can also lead to hard-to-maintain code, because any changes in definitions can completely change the behaviour of the tactic.</p>",
        "id": 559146501,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764016523
    }
]