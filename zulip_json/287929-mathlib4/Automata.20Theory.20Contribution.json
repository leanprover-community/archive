[
    {
        "content": "<p>Hi all, I’m interested in contributing some automata theory to computability. I have been working on this project for several months and have been able to formalize quite a number of standard results of the theory that are not presently a part of mathlib. I wanted to check whether the direction I have in mind is a good fit for mathlib, and I am looking for maintainers to review the eventual pull requests.</p>\n<p><a href=\"https://github.com/AydenLamp/FinDFA\">Here is a link to the github repo.</a></p>\n<p>In brief: At present, the computability folder has a definition of deterministic automaton in Computability/DFA. (The ‘F’ in ‘DFA’ is a bit  of a misnomer, since as defined these automata are not necessarily finite.) I use this definition in my work. It appears that there is nothing in the present folder showing the existence of a unique minimal deterministic automaton for each language, nor of the algorithm for constructing the minimal automaton in the finite case. </p>\n<p>These are standard constructions in automata theory and are critical in proving results in the algebraic theory of formal languages. </p>\n<p>Below is a more detailed summary of what I have done so far.  </p>\n<h3>DFA morphisms</h3>\n<p>I  define a morphism between DFAs M and N as a map between their state types that</p>\n<ul>\n<li>\n<p>sends the start state of M to the start state of N,</p>\n</li>\n<li>\n<p>sends accepting states of M to accepting states of N, and</p>\n</li>\n<li>\n<p>is compatible with the transition functions.</p>\n</li>\n</ul>\n<p>From such a morphism M ⟶ N we prove that the language accepted by M is equal to language accepted by N. </p>\n<p><a href=\"https://github.com/AydenLamp/FinDFA/blob/main/MyProject/ForMathlib/DFAHom.lean\">Here</a> is a self-contained file that defines these morphisms. Should I make a PR that adds these definitions to Mathlib.Computability.DFA or should I add it in a new file (Mathlib.Computability.DFAHom)?</p>\n<p>Accessibility</p>\n<p>A state of a DFA is accessible if it is reachable from the start state by some word. A DFA is accessible if all of its states are accessible. I define:</p>\n<ul>\n<li>\n<p>accessibility for states and a typeclass expressing that a DFA is accessible,</p>\n</li>\n<li>\n<p>a partial order on DFAs by M ≤ N iff there exists a surjective DFA morphism N ⟶ M, and</p>\n</li>\n<li>\n<p>a “DFA.toAccessible” function: given a DFA, restrict its state type to the accessible states to obtain an accessible DFA accepting the same language. This construction preserves Fintype and DecidableEq instances on the state type, so it is “computable” in the sense that it really produces a finite DFA when you start with one.</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/AydenLamp/FinDFA/blob/main/MyProject/DFA/Accessible.lean\">Here</a> is a link to the file with these constructions. </p>\n<h3>DFA minimization</h3>\n<p>On top of this, I have implemented a minimization algorithm that</p>\n<ul>\n<li>\n<p>takes as input a DFA with Fintype / DecidableEq state type</p>\n</li>\n<li>\n<p>outputs a DFA accepting the same language</p>\n</li>\n</ul>\n<p>The resulting DFA is minimal with respect to the surjective-morphism order above. As a consequence it has the smallest number of states among DFAs accepting the language, and is the unique (up to isomorphism) DFA with this property.</p>\n<p>I further prove that this construction preserves Fintype and DecidableEq. In fact, the automaton constructed by the algorithm is equivalent (isomorphic) to the Nerode automaton of a language, which is already in mathlib (Computability/MyhillNerode). However, the existing definition in mathlib builds this automaton directly from an arbitrary language; since it doesn’t start from a DFA with a finite state type, the resulting automaton is not shown to carry a Fintype or Finite instance even when the language is regular. Nor does the existing definition show that the resulting automaton is minimal.</p>\n<p>By contrast, this minimization procedure starts from a DFA with a finite state type and stays within that world. In order to make this algorithm computable, I had to define another typeclass on DFAs, which I call <code>Fin</code>, defined <a href=\"https://github.com/AydenLamp/FinDFA/blob/main/MyProject/DFA/Fin.lean\">here</a>. This typeclass provides the set of accepting states of a DFA as a <code>Finset</code> rather than a <code>Set</code>. Without this typeclass, it would be impossible to decide word membership in a DFA’s language, even if the state and alphabet types have <code>Fintype</code> and <code>DecidableEq</code> instances. </p>\n<h3>Longer-term goals</h3>\n<p>The main motivation is to set up infrastructure for later results such as:</p>\n<ul>\n<li>\n<p>the syntactic monoid of a regular language (transition monoid of a minimal DFA),</p>\n</li>\n<li>\n<p>the characterization of star-free languages via aperiodic syntactic monoids (Schützenberger’s theorem),</p>\n</li>\n</ul>\n<p>connections to finite semigroup theory, which currently seems sparse in mathlib. I am currently participating in a parallel project aimed at formalizing the algebraic theory of finite semigroups in Lean, and these can be found in <a href=\"https://github.com/lean-summer-research/finalized\">this</a> github repo.</p>",
        "id": 562577081,
        "sender_full_name": "Ayden Lamparski",
        "timestamp": 1765237553
    },
    {
        "content": "<p>Hey, I think this might fit in CSLib</p>",
        "id": 562580179,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765239732
    },
    {
        "content": "<p>Hello <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>\n<hr>\n<p>You should consider <a class=\"stream\" data-stream-id=\"513188\" href=\"/#narrow/channel/513188-CSLib\">#CSLib</a> (<a href=\"https://github.com/leanprover/cslib\">https://github.com/leanprover/cslib</a> <span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span>).<br>\nThe computability folder still accepts PRs sometimes, and there isn't a clear policy about its relation with CSLib, but the automata in CSLib are a consolidation of many efforts from multiple people into one coherent and well thought out design. The project is still early days, but minimizing DFAs is a great addition.</p>\n<hr>\n<p>As for the project itself: I like the morphism &amp; accessibility concepts, looks good! Also I think your <code>Fin</code> class can and should be replaced by <code>Fintype M.accept</code>, it looks equivalent (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.toFinset#doc\">docs#Set.toFinset</a>).</p>",
        "id": 562580214,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765239776
    },
    {
        "content": "<p>Also worth checking out: <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Regular.20languages.3A.20the.20review.20queue/with/555492863\">#mathlib4 &gt; Regular languages: the review queue</a></p>",
        "id": 562580302,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765239865
    },
    {
        "content": "<p>and <a class=\"stream-topic\" data-stream-id=\"513188\" href=\"/#narrow/channel/513188-CSLib/topic/Automata/with/560175319\">#CSLib &gt; Automata</a></p>",
        "id": 562580375,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765239937
    },
    {
        "content": "<p>Pinging <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> because as the author he is most knowledgeable about CSLib's automata.</p>",
        "id": 562580879,
        "sender_full_name": "Chris Henson",
        "timestamp": 1765240362
    },
    {
        "content": "<p>Currently the automata theory in CSLib has the definitions of deterministic and nondeterministic automata and the finite-word, Büchi, and Muller acceptance conditions, the closure of regular languages under boolean operations, and the closure of ω-regular languages under union and intersection.   You can find most of the code under the following directories:</p>\n<ul>\n<li>Cslib/Computability/Automata</li>\n<li>Cslib/Computability/Languages</li>\n<li>Cslib/Foundations/Data/OmegaSequence</li>\n</ul>\n<p>in CSLib.  My main goal is to port the results I formalized earlier in a personal project:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory\">https://github.com/ctchou/AutomataTheory</a><br>\ninto CSLib.</p>\n<p>I am not familiar with the algebraic approach to automata theory, but it looks like a good addition to CSLib and will probably be pretty orthogonal to what I have already done and plan to do in automata theory.  <span class=\"user-mention\" data-user-id=\"992999\">@Ayden Lamparski</span>, could you give us some pointers to the documents and/or textbooks you are following?</p>\n<p>On the mathlib front, the PR for the closure of regular languages under boolean operations (<a href=\"https://github.com/leanprover-community/mathlib4/pull/31247\">mathlib#31247</a>) has just been merged and the PR for the closure under concatenation seems about to be merged (<a href=\"https://github.com/leanprover-community/mathlib4/pull/30872\">mathlib#30872</a>).</p>",
        "id": 562606128,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1765260875
    },
    {
        "content": "<p>DFA minimization (and connected topics) is definitely something we'd like to have in <a class=\"stream\" data-stream-id=\"513188\" href=\"/#narrow/channel/513188-CSLib\">#CSLib</a>!</p>",
        "id": 562697137,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1765290102
    },
    {
        "content": "<p>Cool formalization! <a href=\"https://www.cis.upenn.edu/~jean/tcbook.pdf\">Here</a> are some notes for a course I TA'd last year that covers the algebraic approach to automata theory in chapter 5. You can define (co)products and pullbacks/pushouts of DFAs using these morphisms as well</p>",
        "id": 562817136,
        "sender_full_name": "Tanner Duve",
        "timestamp": 1765320907
    }
]