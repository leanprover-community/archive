[
    {
        "content": "<p>How far are we from showing that Euclidean space is oriented? Eg something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Oriented</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>cc <span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span></p>",
        "id": 507334302,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1742578836
    },
    {
        "content": "<p>I think this is a one-liner, but also perhaps a bad global instance</p>",
        "id": 507338122,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742580142
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Oriented</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">Basis</span><span class=\"bp\">.</span><span class=\"n\">orientation</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Pi</span><span class=\"bp\">.</span><span class=\"n\">basisFun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span>\n</code></pre></div>",
        "id": 507338282,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742580208
    },
    {
        "content": "<p>Why do you think it's a bad global instance?</p>",
        "id": 507338416,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1742580243
    },
    {
        "content": "<p>I don't remember, I just remember thinking that in the past</p>",
        "id": 507338783,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742580374
    },
    {
        "content": "<p>Oh that was easy. I somehow assumed it would be harder due to the rays involved. But I guess <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Basis.orientation#doc\">docs#Basis.orientation</a> already does the heavy lifting</p>",
        "id": 507338790,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1742580377
    },
    {
        "content": "<p>Is it a good thing to force people to use <em>that</em> precise orientation?</p>",
        "id": 507352201,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1742585398
    },
    {
        "content": "<p>I would personally be happy with a <code>Nonempty (Module.Oriented ℝ (EuclideanSpace ℝ n) n)</code> instance</p>",
        "id": 507354685,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1742586299
    },
    {
        "content": "<p>I'm not sure I even understand <em>which</em> orientation that chooses for <code>n = Fin m</code></p>",
        "id": 507359720,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742588222
    },
    {
        "content": "<p>Note that <code>Nonempty (Module.Oriented ...)</code> just says that the dimension of a space is at least <code>Fintype.card ι</code>.</p>",
        "id": 507360121,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742588394
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Euclidean.20space.20is.20oriented/near/507359720\">said</a>:</p>\n<blockquote>\n<p>I'm not sure I even understand <em>which</em> orientation that chooses for <code>n = Fin m</code></p>\n</blockquote>\n<p>The one that's positive on the <code>Pi.single</code> basis, I guess.</p>",
        "id": 507360310,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742588476
    },
    {
        "content": "<p>BTW, there are no nontrivial instances of <code>Module.Oriented</code> at the moment.</p>",
        "id": 507360424,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742588522
    },
    {
        "content": "<p>E.g., we have no <code>Module.Oriented R R (Fin 1)</code> (or should we use <code>PUnit</code>?)</p>",
        "id": 507360504,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742588551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Euclidean.20space.20is.20oriented/near/507360121\">said</a>:</p>\n<blockquote>\n<p>Note that <code>Nonempty (Module.Oriented ...)</code> just says that the dimension of a space is at least <code>Fintype.card ι</code>.</p>\n</blockquote>\n<p>I am not saying it says much mathematically. However that doesn't mean we shouldn't have it!</p>",
        "id": 507361540,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1742588990
    },
    {
        "content": "<p>If we're talking about <code>Prod</code>/<code>Pi</code>/<code>PiLp</code> instances, then we have the following issue:</p>\n<ul>\n<li>If we have <code>Module.Oriented R M ι</code> and <code>Module.Oriented R N ι'</code>, then we can have <code>Module.Oriented R (M × N) (ι ⊕ ι')</code>;</li>\n<li>however, if <code>ι = Fin k</code> and <code>ι' = Fin l</code>, then we get <code>Fin k ⊕ Fin l</code>, not <code>Fin (k + l)</code>. Should we have an instance with <code>Fin (k + l)</code> too?</li>\n<li>similarly, for <code>∀ i : ι, E i</code> with <code>∀ i, Oriented R (E i) (σ i)</code>, we get <code>Oriented R (∀ i, E i) (Σ i, σ i)</code></li>\n<li>this time, we need an order (or <code>FinEnum</code>) on <code>ι</code> to get from <code>∀ i, Oriented R (E i) (Fin (d i))</code> to <code>Oriented R (∀ i, E i) (Fin (∑ i, d i))</code>.</li>\n<li>in the special case <code>ι → E</code>, we can have <code>Oriented R (ι → E) (ι × σ)</code>; should we?</li>\n<li>we can have <code>[Oriented R E (Fin d)] : Oriented R (ι → E) (Fin (Fintype.card ι * d))</code>, if we have an order on <code>ι</code>.</li>\n</ul>",
        "id": 507361721,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742589058
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Euclidean.20space.20is.20oriented/near/507361540\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Euclidean.20space.20is.20oriented/near/507360121\">said</a>:</p>\n<blockquote>\n<p>Note that <code>Nonempty (Module.Oriented ...)</code> just says that the dimension of a space is at least <code>Fintype.card ι</code>.</p>\n</blockquote>\n<p>I am not saying it says much mathematically. However that doesn't mean we shouldn't have it!</p>\n</blockquote>\n<p>If we want to talk about it, then IMHO we should have a more readable typeclass (e.g., <code>LERank R M d</code>).</p>",
        "id": 507361861,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742589115
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Euclidean.20space.20is.20oriented/near/507361721\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Should we have an instance with <code>Fin (k + l)</code> too?</li>\n</ul>\n</blockquote>\n<p>I don't think we need to worry about this, because the index type is not an outparam</p>",
        "id": 507369559,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742591965
    },
    {
        "content": "<p>So we can have as many alternative indices as we like</p>",
        "id": 507369588,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742591978
    },
    {
        "content": "<p>If you have an orientation on <code>Fin (k + l)</code>, playing with <code>add_comm</code> will sometimes give the right one on <code>Fin (l + k)</code>, sometimes not…</p>",
        "id": 507374599,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1742594357
    },
    {
        "content": "<p>Can you give an example?</p>",
        "id": 507379005,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742596583
    },
    {
        "content": "<p>I think if <code>l</code> and <code>k</code> are both odd, and you mix <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.cast#doc\">docs#Fin.cast</a> with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finAddFlip#doc\">docs#finAddFlip</a>, you will get the opposite orientation.</p>",
        "id": 507380339,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742597372
    },
    {
        "content": "<p>But why would you do that</p>",
        "id": 507380625,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742597540
    },
    {
        "content": "<p>Antoine, I think you need three variables in the sum for that to be the case. With two you always get a cyclic permutation.</p>",
        "id": 507384915,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1742600236
    },
    {
        "content": "<p>I don't really understand the problem here; if you start rewriting arguments to typeclasses you're usually going to end up in a mess; for instance, unfolding <code>Matrix</code> into a function types is going to leave you with nonsense <code>Mul</code> instances on functions.</p>",
        "id": 507388685,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742602991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Euclidean.20space.20is.20oriented/near/507374599\">said</a>:</p>\n<blockquote>\n<p>If you have an orientation on <code>Fin (k + l)</code>, playing with <code>add_comm</code> will sometimes give the right one on <code>Fin (l + k)</code>, sometimes not…</p>\n</blockquote>\n<p>I don't understand this. If you have <code>[Oriented R E (Fin 2)] [Oriented R F (Fin 3)]</code>, then you get some specific orientation for <code>Oreinted R (E × F) (Fin 5)</code>. Note that <code>F × E</code> is a different space, so it doesn't matter (for typeclass diamonds) if <code>Equiv.prodComm</code> is not an orientation-preserving map.</p>",
        "id": 507389048,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742603237
    },
    {
        "content": "<p>BTW, should we have <code>[Module Complex E] : Oriented Real E ???</code> for some <code>???</code>?</p>",
        "id": 507389168,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742603302
    },
    {
        "content": "<p>Here <code>???</code> is equivalent to <code>Fin (2 * finrank Complex E)</code>.</p>",
        "id": 507389193,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742603335
    },
    {
        "content": "<p>But we may want to use a different type to avoid diamonds for specific low dimensions.</p>",
        "id": 507389239,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742603370
    },
    {
        "content": "<p>Note that we don't yet have any of the definitions mapping from orientations of individual spaces to an orientation of a pairwise or indexed product space, which you need as <code>def</code>s on <code>Orientation</code> before you use them to construct any possible <code>Module.Oriented</code> instances.</p>",
        "id": 507391489,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1742604754
    },
    {
        "content": "<p>(I think such definitions only make sense - that is, are canonical - when the index types have cardinality equal to the dimensions (which is the intended use case of <code>Orientation</code>, but the definition of <code>Orientation</code> doesn't require the right cardinality).)</p>",
        "id": 507391657,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1742604874
    },
    {
        "content": "<p>If we don't have those definitions when I get to setting up the relation between <code>incenter</code> of a simplex and angle bisectors in general dimensions, I may add them at that point, since I think such definitions will be of use in e.g. saying what's a consistent collection of orientations of the faces of a simplex (in order then to say what's an internal / external bisector between two faces). The map in the reverse direction (given an orientation of a product space indexed by a sum type, and an orientation of one of the two spaces, get the corresponding orientation of the other space) may also be useful.</p>",
        "id": 507391915,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1742605062
    },
    {
        "content": "<p>I don't think of the <code>Fin (k + l)</code> orientation as being particularly canonical, it's more what you get if you use <code>Orientation.reindex</code> with a particular choice of equivalence between the sum type and that <code>Fin</code> type.</p>",
        "id": 507392271,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1742605248
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Euclidean.20space.20is.20oriented/near/507338282\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Oriented</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">Basis</span><span class=\"bp\">.</span><span class=\"n\">orientation</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Pi</span><span class=\"bp\">.</span><span class=\"n\">basisFun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Just to check <span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span>, do you think this <code>instance</code> is a good idea, or do you have reservations?</p>",
        "id": 507392655,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742605470
    },
    {
        "content": "<p>I think my reservation was mainly \"Joseph would surely have added this instance if he felt it was a good idea, so its absence suggests it may not be\"</p>",
        "id": 507392686,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742605500
    },
    {
        "content": "<p>I think it's a reasonable instance. I don't think I was considering the concrete <code>EuclideanSpace</code> at all when setting up orientations, just general spaces of a given dimension where an orientation might be assumed as a type class hypothesis where needed for a statement, or an (arbitrary) instance constructed inside a proof where only needed for the proof and not the statement of the result.</p>",
        "id": 507393952,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1742606283
    }
]