[
    {
        "content": "<p>In Clausal FOL, one defines clauses to be multisets of literals.<br>\nHowever when doing</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A Clause (over Function symbols F and variables alpha) is a multiset of Literals. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Clause</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Literal</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>clauses inherit the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Multiset/Defs.html#Multiset.Le\">subset-with-counts-ordering</a> of Multisets. This is very unfortunate, since<br>\nclauses are typically ordered by extending the order on literals by the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Multiset/DershowitzManna.html#Multiset.IsDershowitzMannaLT\">Dershowitz-Manna ordering extension</a> which is already in mathlib (but not an instance for multisets ofc).<br>\nI tried making my <code>abbrev</code> a <code>def</code>, however i find myself basically duplicating the whole mathlib library on multisets, just to avoid this instance.</p>\n<p>Is there any way i can kill the existing ordering instance for <code>Clause</code>?</p>",
        "id": 574307660,
        "sender_full_name": "Moritz R",
        "timestamp": 1771339375
    },
    {
        "content": "<p>AFAIK, no. You can try to write a metaprogram that will copy API for you.</p>",
        "id": 574323634,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771343185
    },
    {
        "content": "<p>You can write <code>attribute [-instance] foo</code>, i believe...</p>",
        "id": 574330758,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1771344976
    },
    {
        "content": "<p>But then you won't get the order on <code>Multiset</code> either</p>",
        "id": 574330936,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1771345018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Remove.20instance.20from.20abbrev.20type/near/574330936\">said</a>:</p>\n<blockquote>\n<p>But then you won't get the order on <code>Multiset</code> either</p>\n</blockquote>\n<p>If I modify the ordering behaviour of the multiset type, then the chances that anything ever gets merged into any library instantly drop to 0.<br>\nFor good reason</p>",
        "id": 574331778,
        "sender_full_name": "Moritz R",
        "timestamp": 1771345222
    },
    {
        "content": "<p>I stumbled across this very recent work on Lean by <a href=\"https://github.com/leanprover/lean4/pull/12247\">Leo</a>.<br>\nIn particular the sentence </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">**</span><span class=\"n\">We</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">decoupling</span><span class=\"w\"> </span><span class=\"n\">whether</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">declaration</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">available</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">resolution</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">its</span><span class=\"w\"> </span><span class=\"n\">transparency</span><span class=\"w\"> </span><span class=\"n\">status</span><span class=\"bp\">**</span>\n</code></pre></div>\n<p>looks like it might become a possibility to have this as a feature soon?</p>",
        "id": 574339985,
        "sender_full_name": "Moritz R",
        "timestamp": 1771347329
    },
    {
        "content": "<p>I hope someone in the know can comment on this</p>",
        "id": 574340212,
        "sender_full_name": "Moritz R",
        "timestamp": 1771347389
    },
    {
        "content": "<p>See how far moving the instances to a separate file gets you</p>",
        "id": 574345021,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1771348447
    },
    {
        "content": "<p>I'd argue that you should just make a new <code>def</code> for what you're doing, and create maps to convert between multisets and clauses.</p>",
        "id": 574396513,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1771366962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Remove.20instance.20from.20abbrev.20type/near/574345021\">schrieb</a>:</p>\n<blockquote>\n<p>See how far moving the instances to a separate file gets you</p>\n</blockquote>\n<p>How should moving the instance to a separate file and then importing that help in any way?</p>",
        "id": 574402644,
        "sender_full_name": "Moritz R",
        "timestamp": 1771370322
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Remove.20instance.20from.20abbrev.20type/near/574396513\">schrieb</a>:</p>\n<blockquote>\n<p>I'd argue that you should just make a new <code>def</code> for what you're doing, and create maps to convert between multisets and clauses.</p>\n</blockquote>\n<p>Well the conversion map would just be the typed identity function in both directions.<br>\nIf i now want to use all the nice api on multisets, like <code>.cons</code>, <code>+</code>, <code>insert</code>, <code>singleton</code>, <code>0</code>, <code>member</code><br>\ni need to define these via the conversion on <code>Clause F alpha</code>. But now i have zero lemmas about them and tactics like simp and grind will prove nothing about them. So then i have to copy all the theorems about these definitions (the proofs become <code>exacts</code> ofc).</p>",
        "id": 574402984,
        "sender_full_name": "Moritz R",
        "timestamp": 1771370544
    },
    {
        "content": "<p>How is this different to saying \"duplicate all the code\"?</p>",
        "id": 574403145,
        "sender_full_name": "Moritz R",
        "timestamp": 1771370648
    },
    {
        "content": "<p>You can use metaprogramming to do this for you.</p>",
        "id": 574404530,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771371478
    },
    {
        "content": "<p>But Lean is becoming more and more insistent on instances being canonical for a type.</p>",
        "id": 574404653,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771371550
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Remove.20instance.20from.20abbrev.20type/near/574404530\">schrieb</a>:</p>\n<blockquote>\n<p>You can use metaprogramming to do this for you.</p>\n</blockquote>\n<p>I dislike the thought of having a whole library of invisible lemmas. Is there any examples i can look at?</p>",
        "id": 574406451,
        "sender_full_name": "Moritz R",
        "timestamp": 1771372482
    },
    {
        "content": "<p>for example <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=commandDeclare_uint_theorems__#doc\">docs#commandDeclare_uint_theorems__</a></p>",
        "id": 574406593,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1771372611
    },
    {
        "content": "<p><code>to_additive</code> generates half of theorems about groups. You can have something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">multiset2clause</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">cons_inj_left</span><span class=\"w\"> </span><span class=\"c1\">-- more names</span>\n</code></pre></div>",
        "id": 574422555,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771383932
    },
    {
        "content": "<p>If i would do this automatically i would want <em>all</em> of the lemmas from Multiset to transfer. This is in the hundreds of theorems.</p>",
        "id": 574475953,
        "sender_full_name": "Moritz R",
        "timestamp": 1771411176
    },
    {
        "content": "<p>And this gets pretty complicated pretty quickly, since proofs and statements will expect the wrong <code>&lt;=</code> instance to be there</p>",
        "id": 574476035,
        "sender_full_name": "Moritz R",
        "timestamp": 1771411205
    },
    {
        "content": "<p>and some stuff might even be proven using the wrong <code>&lt;=</code> only in the proof, not in the statement</p>",
        "id": 574476176,
        "sender_full_name": "Moritz R",
        "timestamp": 1771411249
    },
    {
        "content": "<p>Note that the <code>to_additive</code> machinery is now fully extensible. So you can make your own attribute <code>to_clause</code> and use it in the same way that <code>to_additive</code> is used.</p>\n<p>(Unfortunately, you'll need to copy around 60 lines of code from <code>Mathlib.Tactic.Translate.ToAdditive</code>. This may be reduced in the future)</p>",
        "id": 574563695,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1771435161
    },
    {
        "content": "<p>On the other hand, how bad would it be to scope the order instance on <code>Multiset</code>? That would probably be an easy solution.</p>",
        "id": 574564248,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1771435316
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"602461\">Moritz R</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Remove.20instance.20from.20abbrev.20type/near/574402984\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Remove.20instance.20from.20abbrev.20type/near/574396513\">schrieb</a>:</p>\n<blockquote>\n<p>I'd argue that you should just make a new <code>def</code> for what you're doing, and create maps to convert between multisets and clauses.</p>\n</blockquote>\n<p>Well the conversion map would just be the typed identity function in both directions.<br>\nIf i now want to use all the nice api on multisets, like <code>.cons</code>, <code>+</code>, <code>insert</code>, <code>singleton</code>, <code>0</code>, <code>member</code><br>\ni need to define these via the conversion on <code>Clause F alpha</code>. But now i have zero lemmas about them and tactics like simp and grind will prove nothing about them. So then i have to copy all the theorems about these definitions (the proofs become <code>exacts</code> ofc).</p>\n</blockquote>\n<p>This is what we do elsewhere in the library (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderDual#doc\">docs#OrderDual</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Tropical#doc\">docs#Tropical</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lex#doc\">docs#Lex</a>) and I think it works well. If you teach simp about how your casting functions interact with the functions defined on the aliased type, it can get a lot done.</p>",
        "id": 574565211,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1771435577
    },
    {
        "content": "<p>An alternative would just be to use the type of multisets and keep <code>Multiset.IsDershowitzMannaLT</code> as a non-instance relation. Depending on what you're doing this might be easier.</p>",
        "id": 574565489,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1771435673
    },
    {
        "content": "<p>I think the best option would be to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Clause</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">literals</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Literal</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 574565988,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1771435811
    },
    {
        "content": "<p>Then you can add the order instance you want by pulling back across <code>literals</code></p>",
        "id": 574566107,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1771435841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Remove.20instance.20from.20abbrev.20type/near/574565489\">schrieb</a>:</p>\n<blockquote>\n<p>An alternative would just be to use the type of multisets and keep <code>Multiset.IsDershowitzMannaLT</code> as a non-instance relation. Depending on what you're doing this might be easier.</p>\n</blockquote>\n<p>All of mathlibs order lemmas only fire on seeing a LT instance. Having an ordering without a LT instance is extremely painful</p>",
        "id": 574571358,
        "sender_full_name": "Moritz R",
        "timestamp": 1771437416
    },
    {
        "content": "<p>This both applies to my definition of clauses and to <code>Multiset.IsDershowitzMannaLT</code> in Mathlib</p>",
        "id": 574571473,
        "sender_full_name": "Moritz R",
        "timestamp": 1771437449
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Remove.20instance.20from.20abbrev.20type/near/574564248\">schrieb</a>:</p>\n<blockquote>\n<p>On the other hand, how bad would it be to scope the order instance on <code>Multiset</code>? That would probably be an easy solution.</p>\n</blockquote>\n<p>I think this would be reasonable. Then Mathlib could also have a scoped instance for <code>Multiset.IsDershowitzMannaLT</code> and i can have my orderings on Clause.</p>",
        "id": 574571780,
        "sender_full_name": "Moritz R",
        "timestamp": 1771437555
    },
    {
        "content": "<p>this dershowitz manna ordering extension seems similar to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Relation.CutExpand#doc\">docs#Relation.CutExpand</a></p>",
        "id": 574573164,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1771437932
    },
    {
        "content": "<p>oh indeed, CutExpand seems to be equivalent to the (currently private) oneStep relation defined in the dershowitz file</p>",
        "id": 574573880,
        "sender_full_name": "Moritz R",
        "timestamp": 1771438158
    },
    {
        "content": "<p>and the DM ordering is proven to be the transitive closure of oneStep</p>",
        "id": 574573963,
        "sender_full_name": "Moritz R",
        "timestamp": 1771438184
    },
    {
        "content": "<p>I wonder if we could get an AI or something to look for files duplicating work in Mathlib...</p>",
        "id": 574575072,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1771438538
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Remove.20instance.20from.20abbrev.20type/near/574565489\">ha dicho</a>:</p>\n<blockquote>\n<p>An alternative would just be to use the type of multisets and keep <code>Multiset.IsDershowitzMannaLT</code> as a non-instance relation. Depending on what you're doing this might be easier.</p>\n</blockquote>\n<p>We make use of the equivalent (?) <code>Multiset.cutExpand</code> on the CGT repo without making it an instance, and it seems to work fine.</p>",
        "id": 574577342,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1771439240
    },
    {
        "content": "<p>No, cutexpand isn't an ordering yet, as it isn't transitive</p>",
        "id": 574577463,
        "sender_full_name": "Moritz R",
        "timestamp": 1771439284
    },
    {
        "content": "<p>How nice or painful it is to work with an unbundled relation largely depends on how many properties it has. I'd say that a well-founded partial order that doesn't interact with any of the algebraic structure on the type should not be too difficult to keep unbundled.</p>",
        "id": 574577803,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1771439391
    },
    {
        "content": "<p>I don't see how using mathlibs lemmas about Linear orders has to do with bundling</p>",
        "id": 574578423,
        "sender_full_name": "Moritz R",
        "timestamp": 1771439599
    },
    {
        "content": "<p>The point is that if you're working with e.g. a <code>PartialOrder</code> then it is easier to do so unbundled, compared to when using e.g. a <code>LinearOrder</code>, simply because there is less stuff that you're missing. And there are some lemmas/type classes that work in the unbundled setting, such as <code>Std.Refl</code> and <code>Std.isTotal</code>, which allow you to work with unbundled orders comfortably.</p>",
        "id": 574581125,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1771440565
    }
]