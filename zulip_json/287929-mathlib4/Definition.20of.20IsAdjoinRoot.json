[
    {
        "content": "<p>Fix a ring extension <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi mathvariant=\"normal\">/</mi><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">B/A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">A</span></span></span></span>. Currently, <code>IsAdjoinRoot B</code> takes a parameter <code>f : A[X]</code> and means \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-isomorphism between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">⟨</mo><mi>f</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">A[X]/\\langle f\\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">⟩</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>.\"</p>\n<p>The point of this object, as far as I understand, is to allow abstract reasoning about simple extensions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>α</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[\\alpha]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mclose\">]</span></span></span></span> without needing to commit to a particular model e.g. <code>AdjoinRoot</code>. In this sense it's similar to <code>IsLocalization</code>.</p>\n<p>In practice I've found a couple problems with this definition:<br>\n(a) it creates data<br>\n(b) distinct parameters create the same data: multiply <code>f</code> by a constant</p>\n<p>I want to change the definition to instead take a parameter <code>x : B</code> and mean \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> generates <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> as an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-algebra.\"</p>\n<p>This leads to the same definition over a field, since you can recover the minimal polynomial, and is also <code>Prop</code>-valued. I think this new definition is more flexible.</p>\n<p>What are people's thoughts? Pinging <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> as they wrote this file.</p>",
        "id": 547126967,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761481705
    },
    {
        "content": "<p>What if there no <code>B</code>?</p>",
        "id": 547127248,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761482021
    },
    {
        "content": "<p>What you describe already exists, it is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Algebra/Subalgebra/Lattice.html#Algebra.adjoin\">Algebra.adjoin</a>.</p>",
        "id": 547127301,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761482081
    },
    {
        "content": "<p>Or close to that.</p>",
        "id": 547127320,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761482098
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> as I describe, <code>IsAdjoinRoot</code> takes <code>B</code> as a parameter in either case. To answer your question, you choose whatever model you want the defeqs for eg <code>AdjoinRoot</code> or <code>QuadraticAlgebra</code>. The point AIUI is to have a unified API for the models.</p>",
        "id": 547127345,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761482113
    },
    {
        "content": "<p>And <code>Algebra.adjoin</code> is the construction, I am talking about the predicate!</p>",
        "id": 547127377,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761482138
    },
    {
        "content": "<p>Ah sorry, you are talking about <code>IsAdjoinRoot</code>, not <code>AdjoinRoot</code>.</p>",
        "id": 547127391,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761482155
    },
    {
        "content": "<p>The problem is that to make the link with <code>AdjoinRoot</code> you really want a polynomial. There is a rather long discussion about the actual implementation IIRC</p>",
        "id": 547127748,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761482575
    },
    {
        "content": "<p>Could you link the discussion? That would be very useful to me in understanding how to extend <code>IsAdjoinRoot</code>.</p>",
        "id": 547127783,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761482622
    },
    {
        "content": "<p>My thought was that you can recover the polynomial using <code>minpoly</code> the same way you recover the root from the image of <code>X</code> currently.</p>",
        "id": 547127827,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761482669
    },
    {
        "content": "<p>It seems I dreamed about the discussion</p>",
        "id": 547128104,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761482901
    },
    {
        "content": "<p>To un-xy myself: I am formalising the algebraic proof of the fundamental theorem of algebra (\"a real-closed field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> has algebraic closure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>\"), which requires reasoning concretely about generic field extensions. So for instance you have an arbitrary finite extension <code>K/R</code> and then you prove it has degree 2 and then you prove it is in fact <code>R[i]</code>. The idiomatic way to do this in Lean, avoiding tons of isomorphisms, appears to be <code>IsAdjoinRoot</code>, but I've found myself having to repeat lots of boilerplate nonsense for the reasons I specified above.</p>",
        "id": 547128344,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761483077
    },
    {
        "content": "<p>I think the point of <code>IsAdjoinRoot</code> is about the polynomial itself? Is <code>Algebra.adjoin R {x} = top</code> not enough for you?</p>",
        "id": 547128345,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1761483077
    },
    {
        "content": "<p>I agree with Andrew, both <code>AdjoinRoot</code> and <code>IsAdjoinRoot</code> are fundamentally about the polynomial.</p>",
        "id": 547128439,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761483158
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547128345\">said</a>:</p>\n<blockquote>\n<p>I think the point of <code>IsAdjoinRoot</code> is about the polynomial itself? Is <code>Algebra.adjoin R {x} = top</code> not enough for you?</p>\n</blockquote>\n<p>I mean yes in principle, and I've already PRed the equivalence of these predicates. But I'm trying to avoid duplicating API. <code>IsAdjoinRoot</code> has all sorts of things defined on top of it.</p>",
        "id": 547128482,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761483188
    },
    {
        "content": "<p>In that case perhaps the solution is to generalize those APIs to only require <code>Algebra.adjoin R {x} = top</code>? Are there any concrete examples of such things?</p>",
        "id": 547128558,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1761483256
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/SbfImgRjRZAye6cvuw1D6mKA/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/SbfImgRjRZAye6cvuw1D6mKA/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"606x527\" src=\"/user_uploads/thumbnail/3121/SbfImgRjRZAye6cvuw1D6mKA/image.png/840x560.webp\"></a></div><p>I think orthogonal to all of the discussion above, one improvement that could be made is to just take the <code>root</code> instead of one whole <code>map</code></p>",
        "id": 547128576,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761483267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547128558\">said</a>:</p>\n<blockquote>\n<p>In that case perhaps the solution is to generalize those APIs to only require <code>Algebra.adjoin R {x} = top</code>? Are there any concrete examples of such things?</p>\n</blockquote>\n<p>Yeah good shout actually. It <em>is</em> strictly more general (though equivalent over a field). I will do this and come back with a concrete proposal at some point in the future.</p>",
        "id": 547128716,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761483388
    },
    {
        "content": "<p>Another comment is that maybe (but this depends on precisely what you are doing), you should ignore <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> and only use the polynomial <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">x^2+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></p>",
        "id": 547128776,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761483456
    },
    {
        "content": "<p>I'm not sure what this means, sorry. The <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> above was just informal mathematical notation. But the proof I am formalising uses the data of the isomorphism and not just its existence, if that's what you mean?</p>",
        "id": 547128897,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761483591
    },
    {
        "content": "<p>Never mention any explicit root  of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">x^2+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> in your argument. Like avoid saying that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>, say that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><msup><mi>X</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}[X]/(X^2+1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></p>",
        "id": 547129005,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761483700
    },
    {
        "content": "<p>Oh also a related issue: currently I have to write something like <code>Nonempty (IsAdjoinRoot K (X^2 - (C -1)))</code> rather than <code>IsAdjoinRoot K (X^2 + 1)</code> because of the predicate being data and not a proposition. I'm not sure this is really fixable though.</p>",
        "id": 547129061,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761483734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547129005\">said</a>:</p>\n<blockquote>\n<p>Never mention any explicit root  of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">x^2+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> in your argument. Like avoid saying that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>, say that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><msup><mi>X</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}[X]/(X^2+1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></p>\n</blockquote>\n<p>that seems impossible without picking out <em>which</em> element in C corresponds to X</p>",
        "id": 547129079,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761483754
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547129061\">said</a>:</p>\n<blockquote>\n<p>Nonempty (IsAdjoinRoot</p>\n</blockquote>\n<p>we could make this into a definition called <code>IsIsAdjoinRoot</code></p>",
        "id": 547129118,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761483789
    },
    {
        "content": "<p>I think the solution is to make it take in an element of <code>K</code> as well, like <code>IsAdjoinRoot i (X^2 + 1)</code> instead of <code>IsAdjoinRoot C (X^2 + 1)</code>, and then make it prop valued.</p>",
        "id": 547129192,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1761483845
    },
    {
        "content": "<p>Well, it should be the definition of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>!</p>",
        "id": 547129193,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761483845
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547129005\">said</a>:</p>\n<blockquote>\n<p>Never mention any explicit root  of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">x^2+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> in your argument. Like avoid saying that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>, say that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><msup><mi>X</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}[X]/(X^2+1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></p>\n</blockquote>\n<p>What do you mean by <em>is</em> here? If it's an isomorphism, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> is just the image of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>. And it's much easier to reason about an element of my field satisfying some equation than it is to carry proofs along isomorphisms - that's the whole reason we have this <code>IsAdjoinRoot</code> pattern in the first place!</p>",
        "id": 547129213,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761483857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547129213\">said</a>:</p>\n<blockquote>\n<p>What do you mean by <em>is</em> here?</p>\n</blockquote>\n<p>Bill Clinton would be proud</p>",
        "id": 547129283,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761483925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547129192\">said</a>:</p>\n<blockquote>\n<p>I think the solution is to make it take in an element of <code>K</code> as well, like <code>IsAdjoinRoot i (X^2 + 1)</code> instead of <code>IsAdjoinRoot C (X^2 + 1)</code>.</p>\n</blockquote>\n<p>This is unsatisfactory because you want the conclusion of the theorem I mentioned to be something like <code>IsAdjoinRoot K (X^2+1)</code> and not <code>exists x. IsAdjoinRoot x (X^2+1)</code>. I think on reflection we do need both views (via the root, and via the poly).</p>",
        "id": 547129323,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761483970
    },
    {
        "content": "<p>I don't know what you are proving precisely, so it's difficult to answer, but I am saying something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsAdjoinRoot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AlgebraicClosure</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 547129345,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761483994
    },
    {
        "content": "<p>Riccardo, that structure requires choosing a root</p>",
        "id": 547129402,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761484047
    },
    {
        "content": "<p>I'm not entirely sure why <code>exists x. IsAdjoinRoot x (X^2+1)</code> is bad. Is it a usability concern or an aesthetical one?</p>",
        "id": 547129420,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1761484071
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547129193\">said</a>:</p>\n<blockquote>\n<p>Well, it should be the definition of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>!</p>\n</blockquote>\n<p>I think the definition of \\bbC should be via QuadraticAlgebra. But in any case, sometimes we have to start from an abstract field extension and conclude that it has some concrete form. In that case you can't simply redefine things to use <code>AdjoinRoot</code>. Indeed I thought that was the whole point of having an abstraction like <code>IsAdjoinRoot</code>?</p>",
        "id": 547129426,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761484080
    },
    {
        "content": "<p>fortunately <code>AlgebraicClosure</code> gives you roots of polynomials of degree <code>n</code> indexed by <code>Fin n</code></p>",
        "id": 547129536,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761484203
    },
    {
        "content": "<p>Well quadratic algebras exist since like two months, and the complex numbers are a bit older. Anyway you may also avoid <code>AdjointRoot</code> entirely if it is unsuitable for your work and use <code>IsSplittingField</code>, or whatever.</p>",
        "id": 547129578,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761484245
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547129420\">said</a>:</p>\n<blockquote>\n<p>I'm not entirely sure why <code>exists x. IsAdjoinRoot x (X^2+1)</code> is bad. Is it a usability concern or an aesthetical one?</p>\n</blockquote>\n<p>hm good question<br>\nit's certainly less aesthetic<br>\nit's basically extra redundant data on top of \"Algebra.adjoin {x} = top\"<br>\nit just means \"exists x. Algebra.adjoin {x} = top and minpoly R x = X^2+1\"</p>",
        "id": 547129602,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761484266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547129578\">said</a>:</p>\n<blockquote>\n<p>Well quadratic algebras exist since like two months, and the complex numbers are a bit older. Anyway you may also avoid <code>AdjointRoot</code> entirely if it is unsuitable for your work and use <code>IsSplittingField</code>, or whatever.</p>\n</blockquote>\n<p>I'm sorry, I don't understand. An isomorphism with <code>AdjoinRoot</code> <em>is</em> a choice of root. And I don't want a splitting field (though it's equivalent here, sure), I want to capture this fact, which is equivalent to both \"x generates K as an R algebra\" and \"K is isomorphic to R[X]/(minpoly x)\"</p>",
        "id": 547129726,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761484371
    },
    {
        "content": "<p>I think this is the point? <code>IsAdjoinRoot x (X^2+1)</code> should just be a wrapper for <code>Algebra.adjoin {x} = top and R[X] -&gt; S has kernel {X^2+1}</code>.</p>",
        "id": 547129767,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1761484412
    },
    {
        "content": "<p>Alright the first thing I'll do is generalise the <code>IsAdjoinRoot</code> stuff to \"adjoin = top\" and see how that makes my proofs look. If that's an improvement then I can come back to thinking about this. Thanks all!</p>",
        "id": 547129892,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761484540
    },
    {
        "content": "<p>And also note that this minpoly trick to recover the poly only works when you are in a field or at least an integrally closed domain.</p>",
        "id": 547130021,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1761484668
    },
    {
        "content": "<p>Yes indeed - but that's also the only place most of the API holds!</p>",
        "id": 547130054,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761484711
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400289\">@Artie Khovanov</span>  the point is that often if someone finds the current API very annoying to use is because they are using it in the wrong way, so before changing a def we prefer to be sure it's not the case.<br>\nI am not saying you are doing things in the wrong way, I haven't used <code>IsAdjoinRoot</code> a lot, but please consider that if a definition is painful to use it may be that you are doing something wrong.</p>",
        "id": 547130225,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761484881
    },
    {
        "content": "<p>Having said that it's completely possible the actual code is not the best one, and all contributions are very welcome!</p>",
        "id": 547130244,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761484901
    },
    {
        "content": "<p>Like mathematically speaking we never want to reason about \"an A-algebra map from A[X] onto B with a principal kernel\" without caring about the image of X</p>",
        "id": 547130251,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761484907
    },
    {
        "content": "<p>Well, I would say exactly the opposite: I usually don't want to fix the root!</p>",
        "id": 547130316,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761484973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547130225\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span>  the point is that often if someone finds the current API very annoying to use is because they are using it in the wrong way, so before changing a def we prefer to be sure it's not the case.<br>\nI am not saying you are doing things in the wrong way, I haven't used <code>IsAdjoinRoot</code> a lot, but please consider that if a definition is painful to use it may be that you are doing something wrong.</p>\n</blockquote>\n<p>I am no longer proposing changing the definition, at least for now. I've said I'm going to try generalising some results and see if that cleans up my proofs.</p>",
        "id": 547130329,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761484984
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547130316\">said</a>:</p>\n<blockquote>\n<p>Well, I would say exactly the opposite: I usually don't want to fix the root!</p>\n</blockquote>\n<p>I think the two paragraphs of yours are saying opposite things, because IsAdjoinRoot does require fixing a root</p>",
        "id": 547130437,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761485082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547130316\">said</a>:</p>\n<blockquote>\n<p>Well, I would say exactly the opposite: I usually don't want to fix the root!</p>\n</blockquote>\n<p>I'm not saying in terms of the external definition, I'm saying internally - the specialisation to principal kernels is not mathematically meaningful. I was responding to <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span>'s point that we can't always recover a minpoly.</p>",
        "id": 547130438,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761485086
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547130437\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547130316\">said</a>:</p>\n<blockquote>\n<p>Well, I would say exactly the opposite: I usually don't want to fix the root!</p>\n</blockquote>\n<p>I think the two paragraphs of yours are saying opposite things, because IsAdjoinRoot does require fixing a root</p>\n</blockquote>\n<p>I think the point is that we don't want to introduce the root explicitly, which is totally fair. But yes it is necessarily there in the data.</p>",
        "id": 547130537,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761485175
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547130437\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547130316\">said</a>:</p>\n<blockquote>\n<p>Well, I would say exactly the opposite: I usually don't want to fix the root!</p>\n</blockquote>\n<p>I think the two paragraphs of yours are saying opposite things, because IsAdjoinRoot does require fixing a root</p>\n</blockquote>\n<p>Oh yeah, this shows that I am really not used to <code>IsAdjoinRoot</code> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 547130592,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761485230
    },
    {
        "content": "<p>Indeed the fact it's data is the whole problem! The name <code>IsAdjoinRoot</code> is misleading in this sense because it implies that it's just a predicate when it isn't.</p>",
        "id": 547130634,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761485273
    },
    {
        "content": "<p>What I hope to gain from generalising to \"this element is a generator\" is in part that I have a predicate and so I'm no longer in defeq hell.</p>",
        "id": 547130680,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761485329
    },
    {
        "content": "<p>Ok, I actually read the code and I don't have a real opinion about the actual implementation, but the name is no misleading that there are surely results that use <code>IsAdjoinRoot</code> and actually only use the existence of the isomorphism, and this is surely a problem.</p>",
        "id": 547130953,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761485526
    },
    {
        "content": "<p>It should be clearly explained that <code>IsAdjoinRoot</code> generalize <code>AdjoinRoot</code> to avoid defeq hell, not to actually forget data. Sorry for all the noise.</p>",
        "id": 547131013,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761485582
    },
    {
        "content": "<p><code>IsAdjoinRoot</code> <em>is</em> just saying the isomorphism exists. Are you drawing a distinction between data and prop here?</p>",
        "id": 547131034,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761485599
    },
    {
        "content": "<p>Oh sorry just saw your second message yeah</p>",
        "id": 547131058,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761485615
    },
    {
        "content": "<p>Currently <code>IsAdjoinRoot</code> is the isomorphism rather than its existence (bundled in some way).</p>",
        "id": 547131086,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761485647
    },
    {
        "content": "<p>In particular it's not at all like <code>IsLocalization</code>.</p>",
        "id": 547131158,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761485715
    },
    {
        "content": "<p>And yes there are results like \"the degree of L/K where <code>IsAdjoinRoot L f</code> is <code>deg f</code>\" that don't use the choice of root but rather just the existence of some isomorphism. I see what you thought <code>IsAdjoinRoot</code> said.</p>\n<p>I think it should say what you thought it said, and then the whole API should be generalised to \"Algebra.adjoin {x} = \\top\" and in particular implemented in <code>IsAdjoinRoot</code> using choice.</p>",
        "id": 547131195,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761485755
    },
    {
        "content": "<p>yeah and that's because every localisation is an epimorphism</p>",
        "id": 547131200,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761485759
    },
    {
        "content": "<p>well with localizations there's no choice</p>",
        "id": 547131204,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761485761
    },
    {
        "content": "<p>it's not like roots where you can choose a different root</p>",
        "id": 547131242,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761485778
    },
    {
        "content": "<p>let me reassert the idea <code>IsIsAdjoinRoot</code></p>",
        "id": 547131259,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761485783
    },
    {
        "content": "<p>localizations have a universal property</p>",
        "id": 547131306,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761485828
    },
    {
        "content": "<p>Do we actually need the data carrying version if we have the prop valued version?</p>",
        "id": 547131337,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1761485852
    },
    {
        "content": "<p>We should think if we want both versions</p>",
        "id": 547131360,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761485875
    },
    {
        "content": "<p>the \"lfiting\" one requires data</p>",
        "id": 547131372,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761485887
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/IsAdjoinRoot.html#IsAdjoinRoot.lift\">IsAdjoinRoot.lift</a></p>",
        "id": 547131387,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761485906
    },
    {
        "content": "<p>It only requires the existence of data.</p>",
        "id": 547131392,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1761485908
    },
    {
        "content": "<p>well the lift depends on the choice of root anyways</p>",
        "id": 547131409,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761485926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547131392\">said</a>:</p>\n<blockquote>\n<p>It only requires the existence of data.</p>\n</blockquote>\n<p>the <em>existence</em> of lift only requires the <em>existence</em> of data</p>",
        "id": 547131428,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761485951
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547131337\">said</a>:</p>\n<blockquote>\n<p>Do we actually need the data carrying version if we have the prop valued version?</p>\n</blockquote>\n<p>Yes because we want to prove results about the actual root sometimes. But we should generalise that to a predicate on the root (\"adjoin {x} = top\") and leave <code>IsAdjoinRoot</code> to results that don't care about the choice of root (eg the degree of the extension).</p>",
        "id": 547131449,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761485968
    },
    {
        "content": "<p>This is just the universal property of polynomials and of the quotient</p>",
        "id": 547131459,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761485977
    },
    {
        "content": "<p>You can't compute it without the data</p>",
        "id": 547131461,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761485977
    },
    {
        "content": "<p>Polynomials have a different kind of universal property</p>",
        "id": 547131503,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761486007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547131459\">said</a>:</p>\n<blockquote>\n<p>universal property of polynomials</p>\n</blockquote>\n<p>which has data</p>",
        "id": 547131552,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761486052
    },
    {
        "content": "<p>In pseudocode<br>\n\"IsPrimitiveElement K (x : L) := (adjoin K {x} = top)\"<br>\n\"IsAdjoinRoot L (f : K[X]) := exists (F : AlgHom K K[X] L). F.surjective and F.ker = &lt;f&gt;\"</p>",
        "id": 547131730,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761486247
    },
    {
        "content": "<p>again I propose that we should take the root instead of the whole map</p>",
        "id": 547131762,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761486278
    },
    {
        "content": "<p>sure</p>",
        "id": 547131774,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761486289
    },
    {
        "content": "<p>Sure I can agree with this. But my question is do we still need the current <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsAdjoinRoot#doc\">docs#IsAdjoinRoot</a> ?</p>",
        "id": 547131835,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1761486316
    },
    {
        "content": "<p>\"IsAdjoinRoot L (f : K[X]) := exists x : L. IsPrimitiveElement K x and (all g : K[X]. aeval g x = 0 iff f | g)\"</p>",
        "id": 547131924,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761486391
    },
    {
        "content": "<p>or something</p>",
        "id": 547131939,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761486409
    },
    {
        "content": "<p>I mean that one can write <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/IsAdjoinRoot.html#IsAdjoinRoot.lift\">IsAdjoinRoot.lift</a> only assuming the existence of <code>h</code> (I am personally not interested in computability). Of course it will be an arbitrary choice, it will not be unique</p>",
        "id": 547131971,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761486449
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547131835\">said</a>:</p>\n<blockquote>\n<p>Sure I can agree with this. But my question is do we still need the current <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsAdjoinRoot#doc\">docs#IsAdjoinRoot</a> ?</p>\n</blockquote>\n<p>Under this proposal the results from that file mostly go to <code>IsPrimitiveElement</code> with the few that don't mention the root specialised to the new <code>IsAdjoinRoot</code> using choice</p>",
        "id": 547131979,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761486464
    },
    {
        "content": "<p>Question: when do we actually use <code>IsAdjoinRoot.lift</code>? The only way I've really used <code>IsAdjoinRoot</code> \"externally\" is to specify the degree of the extension and transfer instances from <code>AdjoinRoot</code>. Maybe I'm missing something.</p>",
        "id": 547132191,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761486712
    },
    {
        "content": "<p>I don't use IsAdjoinRoot either</p>",
        "id": 547133189,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761487580
    },
    {
        "content": "<p>I think one use could be to make <code>AdjoinRoot</code>  an opaque definition and prove everything via <code>IsAdjoinRoot</code>, so it's impossible to abuse defeq</p>",
        "id": 547133281,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761487666
    },
    {
        "content": "<p>I think that would be quite painful.</p>",
        "id": 547133314,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1761487705
    },
    {
        "content": "<p>But the file starts with \"This file defines a predicate...\" and this should surely be changed.</p>",
        "id": 547133333,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761487718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547133281\">said</a>:</p>\n<blockquote>\n<p><code>AdjoinRoot</code> an opaque definition and prove everything via <code>IsAdjoinRoot</code></p>\n</blockquote>\n<p>the philosophy of Localization and IsLocalization, and also RingHom vs. RingHomClass, is that we need both API</p>",
        "id": 547133581,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761487954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Definition.20of.20IsAdjoinRoot/near/547133333\">said</a>:</p>\n<blockquote>\n<p>But the file starts with \"This file defines a predicate...\"</p>\n</blockquote>\n<p>But this has nothing to do with <code>AdjoinRoot</code></p>",
        "id": 547133630,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761487986
    },
    {
        "content": "<p>Well, this is slightly different, since there are actually <em>three</em> versions: <code>AdjointRoot</code>, \"something fixing the isomorphism\" (currently <code>IsAdjoinRoot</code>), and something where we say there is an isomorphism.</p>",
        "id": 547133673,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761488032
    },
    {
        "content": "<p>AdjointRoot, which is the concrete construction, should not be part of this discussion at all, it is entirely irrelevant</p>",
        "id": 547133707,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761488070
    },
    {
        "content": "<p>We have <code>AlgebraicClosure</code> and <code>IsAlgClosure</code>, and <code>AlgebraicClosure</code> is not unique up to unique isomorphism, so this is a better analogue than <code>Localization</code> and <code>IsLocalization</code>. I am very surprised something called <code>Is</code> isn't a Prop. I argued hard that <code>IsROrC</code> should be renamed for this reason, and it was.</p>",
        "id": 547153847,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1761506453
    },
    {
        "content": "<p>Yeah that's a better analogue (and <em>in principle</em> supports my revised proposal)</p>",
        "id": 547160884,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761513848
    },
    {
        "content": "<p>Relevant file I found: <code>Mathlib.RingTheory.Adjoin.PowerBasis</code></p>",
        "id": 547175665,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761530077
    },
    {
        "content": "<p>Am trying now to translate the <code>IsAdjoinRoot</code> stuff to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">IsPrimitiveElem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">is_integral</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsIntegral</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">adjoin_eq_top</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">adjoin</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span>\n</code></pre></div>",
        "id": 547337311,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1761586561
    },
    {
        "content": "<p>I have gone ahead and made a design to make <code>IsAdjoinRoot</code> and <code>PowerBasis</code> into predicates<br>\nSee <a href=\"#narrow/channel/287929-mathlib4/topic/Should.20.60PowerBasis.60.20take.20a.20parameter\">#mathlib4 &gt; Should &#96;PowerBasis&#96; take a parameter</a></p>",
        "id": 560025175,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1764021823
    }
]