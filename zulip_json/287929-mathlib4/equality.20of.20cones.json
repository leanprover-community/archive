[
    {
        "content": "<p>In the <a href=\"https://github.com/leanprover-community/mathlib3/blob/65a1391a0106c9204fe45bc73a039f056558cb83/src/category_theory/limits/cones.lean#L244\">library</a>, we have </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">Functorially postcompose a cone for `F` by a natural transformation `F ⟶ G` to give a cone for `G`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">postcompose</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">pt</span>\n<span class=\"w\">      </span><span class=\"n\">π</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">π</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Postcomposing a cone by the composite natural transformation `α ≫ β` is the same as</span>\n<span class=\"sd\">postcomposing by `α` and then by `β`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps!</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">postcomposeComp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">postcompose</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">postcompose</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">postcompose</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">NatIso</span><span class=\"bp\">.</span><span class=\"n\">ofComponents</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Cones</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Iso</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is there a reason why <code>postcomposeComp</code> is not giving an equality ? </p>\n<p>In the same vein, there are no real extensionality lemma on <code>Cone</code>, only some up-to-iso</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">c'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cone</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">c'</span><span class=\"bp\">.</span><span class=\"n\">pt</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">π</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">c'</span><span class=\"bp\">.</span><span class=\"n\">π</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">c'</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>Is this just missing, probably because dealing with <code>HEq</code> or <code>eqToHom</code> is a pain, or is it a design choice ?</p>",
        "id": 466554275,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1725115719
    },
    {
        "content": "<p>I'm pretty sure avoiding equality in category theory is often a deliberate design choice</p>",
        "id": 466554930,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1725115913
    },
    {
        "content": "<p>The philosophical/mathematical reason is that equality of objects is “evil” (i.e. not preserved by equivalence of cats). The practical reason is that non-definitional equality of objects is very likely to prevent a lot of the category theory automation from working well.</p>",
        "id": 466556538,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725116322
    },
    {
        "content": "<p>In that case it seems equal by associativity of composition of natural transformations.</p>\n<p>if that’s « evil », what isn’t … ?</p>",
        "id": 466561137,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1725117237
    },
    {
        "content": "<p>But the natural transformation is part of the object!</p>",
        "id": 466563102,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725117707
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257803\">Nicolas Rolland</span> <a href=\"#narrow/stream/287929-mathlib4/topic/equality.20of.20cones/near/466561137\">said</a>:</p>\n<blockquote>\n<p>In that case it seems equal by associativity of composition of natural transformations.</p>\n<p>if that’s « evil », what isn’t … ?</p>\n</blockquote>\n<p>Definitional equalities are certainly not evil, but the associativity of the composition of morphisms in categories is not a definitional equality. (One of the problems with equalities of objects/functors is that <em>most of the time</em> it is not very practical to use them, while the isomorphisms API is usually convenient enough.)</p>",
        "id": 466563381,
        "sender_full_name": "Joël Riou",
        "timestamp": 1725117766
    },
    {
        "content": "<p>I see the argument about usability. </p>\n<p>Evilness is much less clear to me...</p>\n<p>As far as I remember it meant that giving a central role to a notion which is not equivalence-invariant is foolish. Of course definitional equality is not concerned about this. </p>\n<p>Have you a link about what is the real argument about evilness ?</p>",
        "id": 466566754,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1725118509
    },
    {
        "content": "<p>Equality in a category is \"evil\" in the same sense that asking about what the elements of the elements of a group are -- that latter question is not invariant under isomorphism, which is the fundamental way that groups can be \"mathematically the same\". Hence asking about elements of elements of groups is not a mathematical question. In category theory the fundamental way that categories are the same is equivalence of categories, and equality of objects is not respected by this equivalence relation, so in some sense it's also not a mathematical question.</p>",
        "id": 466568561,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725119111
    },
    {
        "content": "<p>I understand that we shouldn’t be interested about a general statement which is not invariant by equivalence. It would mean the statement is too particular and not about category theory.</p>\n<p>But if I am building a categorie, I can talk about objects being the same. I can equality talk about two categories being the same. If I build a functor to Cat, I have to <del>rely</del> prove functor equality which seems even worse (?)</p>\n<p>Equality of objects is probably evil to rely on, but I fail to see how it’s bad to assert it while building things…</p>",
        "id": 466573678,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1725120508
    },
    {
        "content": "<p>The point is that it’s not invariant under equivalence of categories.</p>",
        "id": 466585937,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725126402
    },
    {
        "content": "<p>For example the statement “this category has 37 objects” is evil because, again, that’s not invariant under equivalences.</p>",
        "id": 466586002,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725126437
    },
    {
        "content": "<p>In a statement  <code>postcompose (α ≫ β) = postcompose α ⋙ postcompose β  </code> what is not invariant under equivalence of categories ?</p>\n<p>Not trying to nitpick, I genuinely do not understand what this is all about.</p>\n<p>As for “this category has 37 objects” exemple, it is nonetheless very useful to talk about \"the\" terminal category, with 1 object  and a single morphism (and make good use of those facts !). Is this \"evil\" too ?</p>",
        "id": 466649668,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1725170984
    },
    {
        "content": "<p>This is the way I see it: As it's a main princple of category theory to talk about objects only up to (sometimes unique) isomorphism, it's good practice to \"forget\" about all properties of a construction which do not obey this principle as soon as possible. The \"API\" of <code>postcompose</code> consists entirely of the iso that you cited and of its behaviour on the identity <code>NatTrans</code>. That's all you need to use and talk about <code>postcompose</code>.</p>",
        "id": 466676114,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1725185010
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257803\">Nicolas Rolland</span> <a href=\"#narrow/stream/287929-mathlib4/topic/equality.20of.20cones/near/466649668\">said</a>:</p>\n<blockquote>\n<p>As for “this category has 37 objects” exemple, it is nonetheless very useful to talk about \"the\" terminal category, with 1 object  and a single morphism (and make good use of those facts !). Is this \"evil\" too ?</p>\n</blockquote>\n<p>In general, the terminal object is not unique, it is only unique up to a (unique) isomorphism. We have such a suitable API for initial/terminal objects.</p>",
        "id": 466693218,
        "sender_full_name": "Joël Riou",
        "timestamp": 1725192004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/287929-mathlib4/topic/equality.20of.20cones/near/466693218\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257803\">Nicolas Rolland</span> <a href=\"#narrow/stream/287929-mathlib4/topic/equality.20of.20cones/near/466649668\">said</a>:</p>\n<blockquote>\n<p>As for “this category has 37 objects” exemple, it is nonetheless very useful to talk about \"the\" terminal category, with 1 object  and a single morphism (and make good use of those facts !). Is this \"evil\" too ?</p>\n</blockquote>\n<p>In general, the terminal object is not unique, it is only unique up to a (unique) isomorphism. We have such a suitable API for initial/terminal objects.</p>\n</blockquote>\n<p>As any object « defined » by UP vs constructed uniquely.</p>\n<p>But is it evil to claim any of those have one object and one morphism ?</p>",
        "id": 466695853,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1725192821
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 466697104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725193415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/equality.20of.20cones/near/466676114\">said</a>:</p>\n<blockquote>\n<p>This is the way I see it: As it's a main princple of category theory to talk about objects only up to (sometimes unique) isomorphism, it's good practice to \"forget\" about all properties of a construction which do not obey this principle as soon as possible. The \"API\" of <code>postcompose</code> consists entirely of the iso that you cited and of its behaviour on the identity <code>NatTrans</code>. That's all you need to use and talk about <code>postcompose</code>.</p>\n</blockquote>\n<p>So what you say is that it is true that  <code>postcompose (α ≫ β) = postcompose α ⋙ postcompose β  </code> but we should not use it ?</p>",
        "id": 466697126,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1725193439
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/equality.20of.20cones/near/466697104\">said</a>:</p>\n<blockquote>\n<p>It's <em>not true</em> that there is one terminal object. For example in the category of sets, any set with one element is a terminal object and there are uncountably many of these. So it's worse than evil, it's just wrong.</p>\n</blockquote>\n<p>That’s not the discussion here.</p>\n<p>The purported evil property is that they have one element.</p>",
        "id": 466697247,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1725193525
    },
    {
        "content": "<p>Right, you should use EqToHom, because that's not evil. Re the set comment: yes, sorry, I misunderstood the question.</p>",
        "id": 466697264,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725193542
    },
    {
        "content": "<p>I don’t see how  <code>postcompose (α ≫ β) = postcompose α ⋙ postcompose β  </code>  is evil</p>",
        "id": 466697374,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1725193625
    },
    {
        "content": "<p>It's evil in a technical sense which I think you do understand, you just don't think it's relevant.</p>",
        "id": 466697392,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725193652
    },
    {
        "content": "<p>There used to be a page in nLab discussing evil arguments in category theory but it seems to have been removed (and right now I'm behind the great firewall so it's difficult to search)</p>",
        "id": 466697506,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725193748
    },
    {
        "content": "<p>No, I genuinely have no idea in what « technical » sense this is wrong. In my book it is true.</p>",
        "id": 466697756,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1725193927
    },
    {
        "content": "<p>\"evil\" is being used in a technical sense here. If you are lucky enough to be able to search the internet right now, see if you can find anything on evil arguments in category theory. Sorry, I'm a bit limited in what I can do right now.</p>",
        "id": 466697848,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725194007
    },
    {
        "content": "<p>The point is that when you are making a mathematical theory you have to write down your definitions, so you have to say what things mean. If you build mathematics from set theory there is an axiom telling you what it means for two sets to be equal -- they're equal iff they have the same elements. In category theory there is no such axiom or definition, the concept that two objects of a category are equal is not defined within category theory, and for good reason: it's not equivalence-invariant (i.e. it's not true that if e : C -&gt; D is an equivalence then c1=c2 iff e(c1)=e(c2)). However if you do category theory <strong>within Lean</strong> then the objects of a category <em>do</em> have an equality defined on them, and that's because Lean defines equality of terms of a fixed type via an inductive definition, and objects of a category are defined to be terms of a fixed type in Lean's model of the theory, so the definition applies. Hence because of choices coming from the model, rather than the theory itself, you can talk about equality of objects in a category within Lean. But this is a consequence of the way the theory has been set up, and you shouldn't necessarily expect equality to behave well, because there are no axioms or theorems involving equality of objects in category theory.  There is however <code>Eq.rec</code> in Lean (aka the <code>rw</code> tactic), so that's a way which you can use equality in Lean's model of category theory. But the correct concept of equality in category theory is isomorphism, which is <em>data</em> (it involves a choice of isomorphism, and in Lean you have to make this choice <em>even if there is only one</em> -- moving from the <code>Prop</code> universe to the <code>Type</code> universe is Lean's version of the axiom of choice), and to manipulate objects in category theory using the axioms of category theory you're going to need that data. <code>EqToHom</code> is what provides the data. Sure you can work with equality, but once you get going you'll need to know the API for category theory in mathlib and this is designed with isomorphisms, not equalities.</p>",
        "id": 466699185,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725194564
    },
    {
        "content": "<p>All the valid points you make about equality are at play here </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">assocOK</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\">  </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span>\n</code></pre></div>\n<p>Aka, we already have that the post-composing by a composite is <strong>equal</strong> to postcomposing by each component, with the caveat you mentioned that we defer to something outside of category to talk about equality. </p>\n<p>If we now consider <strong><em>cones</em></strong>, which are simply natural transformation from a constant functor and package them up in a category, I don't see why this would become « evil » in any technical sense.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">assocEVIL</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cone</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">cone</span><span class=\"w\">  </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">cone</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span>\n</code></pre></div>\n<p>Category theory is only a useful way to package things which exists independently of it.  I don’t really see why there should be any loss or penalty for the simple fact of packaging established things up in a category.  We had equality, why give it up ?</p>\n<p>That equality is not defined within category theory, but it is defined outside, is ok. As you say, in Set it will be something. In another category it will have some other meaning. We defer to the particular category at play to say what it actually means. Just like morphisms equality is not defined within category theory, but it is defined, \"outside\" of category theory, for each category, and we have to prove that it holds to craft a category.</p>\n<p>Here, specifically, we have two functors, and we want them to be equal. Equality of functors is defined by the fact that it transports an object to same object in the target category, and a morphism to the same morphism in the target category. </p>\n<p>Aka what « same » means for each image is deferred to the target category of the functors. </p>\n<p>Here the target category is the category of cones of a functor H. In that category, it means we have the same tip and the same legs. So those equalities are in terms of the target category of H. The tips here are definitionally equal. The legs are <em>almost</em> definitionally equal, we need associativity of composition of natural transformations, which come from the axiom of associativity in the target category. What is evil here ? </p>\n<p>The argument that equivalence is a better API for some (most ?) purposes is understandable.<br>\nEspecially since that there are few functors to Cat in Mathlib currently (but is it discouraged ?)</p>\n<p>As for the « evilness » one, I just do not see what it could possibly mean here in that particular case.</p>",
        "id": 466760722,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1725224089
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.Cones.postcompose#doc\">docs#CategoryTheory.Limits.Cones.postcompose</a> is a functor from the category of cones to another category of cones. If you postcompose with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≫</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a \\gg b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≫</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> that's equal to first postcomposing with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> then postcomposing with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>, yes. But, if you happen to replace (at least one of) the category of cones with an equivalent category, you could end up in a situation where an equality will not hold true on the nose. That's what I meant when I said above that this equality is not preserved under equivalence.</p>",
        "id": 466763991,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725225955
    },
    {
        "content": "<p>Now the subtle part is that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">F : C \\to D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> is a functor and you consider the category of cones over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>, replacing either <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> (and/or doing something analogous for the source and target of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>) by equivalent categories will induce equivalences on the category of cones, where the equality in question <em>is</em> (I think) preserved. But these are very special equivalences on the category of cones!</p>",
        "id": 466764128,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725226080
    },
    {
        "content": "<p>In your code snippet you identified a cone with the underlying natural transformation, but natural transformations don’t have the category structure that cones do, so this is somewhat misleading</p>",
        "id": 466764353,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725226273
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/equality.20of.20cones/near/466764353\">said</a>:</p>\n<blockquote>\n<p>In your code snippet you identified a cone with the underlying natural transformation, but natural transformations don’t have the category structure that cones do, so this is somewhat misleading</p>\n</blockquote>\n<p>As I understand the \"evilness\" argument, it would also apply to the discrete category whose objects are those natural transformations. so I don't think it is misleading.</p>\n<p>It's hard to see why christening some things under a label \"category\" would entail loosing some knowledge. Category theory is just a vocabulary :</p>\n<p>If I refer to natural transformations from a constant functor as such, or as an objects of a discrete category of natural transformations from a constant functor, that should not change (at least in theory, the implementation can differ) what I can say about them.</p>",
        "id": 467743407,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1725520934
    },
    {
        "content": "<p>Labelings are important and suggest to Lean and implementers how to treat expressions. For example, the discrete category label (technically <code>Discrete</code> type synonym) suggests that we should not think about equality between objects, although we can. This is not enforced by the system, but is more like a design pattern.</p>\n<p>The general best practice here is not to think about equality between types. Objects of categories are intended to be used to provide types for morphisms.</p>",
        "id": 467774259,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1725527375
    },
    {
        "content": "<p>I can imagine that it is  a best practice (or a Lean limitation ?)</p>\n<p>But this can bite when abstracting to write functors into <code>Cat</code>, like here.</p>\n<p>I dispute the argument that it is about \"evilness\" or category theory related ideas : there should be, in principle, no restriction on what can be said about some items resulting from the mere fact of organizing them in a category.</p>\n<p>Of course practice and limitation of the system is another matter.</p>",
        "id": 470482880,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1726471441
    },
    {
        "content": "<p>Yeah people do do evil things with categories in Lean because you can't remove <code>=</code>, you can just point out that it might not be the best idea in some situations. I'm seeing people using <code>=</code> when developing the theory of stacks in Lean and you see it in the literature as well.</p>",
        "id": 470527620,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1726479529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257803\">Nicolas Rolland</span> <a href=\"#narrow/stream/287929-mathlib4/topic/equality.20of.20cones/near/470482880\">said</a>:</p>\n<blockquote>\n<p>I can imagine that it is  a best practice (or a Lean limitation ?)</p>\n<p>But this can bite when abstracting to write functors into <code>Cat</code>, like here.</p>\n</blockquote>\n<p>The recommended practice (especially for mathlib contributions) is to avoid using equality of objects/functors when it is not necessary, and use isomorphisms if it is possible (sometimes, it may require expanding the existing API). If you formalise significant results/constructions which very much need equality of objects, I am quite sure that mathlib maintainers would be happy with these additions. We would probably be much more reluctant in case of a PR which would only add lemmas that some of us consider \"evil\".</p>",
        "id": 470740788,
        "sender_full_name": "Joël Riou",
        "timestamp": 1726519427
    },
    {
        "content": "<p>This seems to be a problem for categorical abstraction and modular programming.<br>\nFunctors to <code>Cat</code>, for instance,  are extremely useful for categorical reasoning.<br>\nTake the covariant embedding \\phi_ of Cat into Dist, the bicategory of distributors.<br>\nIt is a classical result that this embedding is full and faithful (Yoneda lemma really) by basic UP reasoning </p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mi>a</mi><mi>t</mi><mtext> </mtext><mi>F</mi><mtext> </mtext><mi>G</mi><mo>∈</mo><msub><mo>∫</mo><mi>a</mi></msub><mi>B</mi><mo stretchy=\"false\">(</mo><mi>F</mi><mi>a</mi><mo separator=\"true\">,</mo><mi>G</mi><mi>a</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><msub><mo>∫</mo><mi>a</mi></msub><mo stretchy=\"false\">[</mo><msup><mi>B</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo separator=\"true\">,</mo><mi>S</mi><mi>e</mi><mi>t</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mo separator=\"true\">,</mo><mi>F</mi><mi>a</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mo separator=\"true\">,</mo><mi>G</mi><mi>a</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>∋</mo><mi>N</mi><mi>a</mi><mi>t</mi><mo stretchy=\"false\">(</mo><msub><mi>ϕ</mi><mi>F</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><msub><mi>ϕ</mi><mi>G</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Nat~ F~ G  ∈ ∫_a B(Fa,Ga) ≅ ∫_a [B^{op},Set](B(-,Fa),B(-,Ga)) ∋ Nat (\\phi_F) (\\phi_G)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mspace nobreak\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace nobreak\"> </span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1608em;vertical-align:-0.3558em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"margin-right:0.19445em;position:relative;top:-0.0006em;\">∫</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:-0.0544em;\"><span style=\"top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3558em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1608em;vertical-align:-0.3558em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"margin-right:0.19445em;position:relative;top:-0.0006em;\">∫</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:-0.0544em;\"><span style=\"top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3558em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">]</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∋</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">ϕ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">ϕ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">G</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<p>The middle ≅ holds because two iso functors are mapped to two iso category of Ends (whose object are terminal wedges) because there is a functor to Cat.</p>\n<p>If I understand correctly, this simple categorical reasoning won't fly in Lean, because </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">wedgeHom_comp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"bp\">ᵒᵖ×</span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">wedgeHom</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">wedgeHom</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\">  </span><span class=\"n\">wedgeHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sorry_evil</span>\n</code></pre></div>\n<p>prevents from having such functor. So some specialized version has to be used </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isoFctrIsoWedgeInType</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"bp\">ᵒᵖ×</span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Wedge</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">Wedge</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\">  </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>It works, but the net loss in abstraction and modularity is obvious.</p>\n<p>Apart from that :</p>\n<p>1- It is extremely bothering that one can say something about some mathematical entities, which we can not say when considering the <strong>same entities</strong> as objects of a category.  This is a high price to pay and a strong negative advertisement to usage of category theory.</p>\n<p>2- In theory I still don't see how some of us can consider this evil...<br>\nI think there is some confusion as to what the purpose and scope of this \"evil\" notion is precisely.<br>\nCould this be \"Evil evilness\" ?</p>",
        "id": 471976980,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1726954450
    },
    {
        "content": "<p>You can say whatever you want (assuming that it type checks, of course). But the practical implications of saying “evil” things is that automation from the category theory library is much more likely to fail.</p>",
        "id": 471985104,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726962299
    },
    {
        "content": "<p>Do we consider the current state of <a href=\"https://github.com/leanprover-community/mathlib4/pull/16971\">#16971</a> as <span aria-label=\"angry devil\" class=\"emoji emoji-1f47f\" role=\"img\" title=\"angry devil\">:angry_devil:</span> or <span aria-label=\"angel\" class=\"emoji emoji-1f47c\" role=\"img\" title=\"angel\">:angel:</span>? Not sure anyone cares that whiskering induces a strict endofunctor on <code>Cat</code> instead of a pseudofunctor.</p>",
        "id": 472188221,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1727087058
    },
    {
        "content": "<p>The stuff in that PR seems fine to me since everything is proved with <code>rfl</code>. That means that it (probably) won't lead to DTT hell.</p>",
        "id": 472256746,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727103639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/equality.20of.20cones/near/472188221\">said</a>:</p>\n<blockquote>\n<p>Do we consider the current state of <a href=\"https://github.com/leanprover-community/mathlib4/pull/16971\">#16971</a> as <span aria-label=\"angry devil\" class=\"emoji emoji-1f47f\" role=\"img\" title=\"angry devil\">:angry_devil:</span> or <span aria-label=\"angel\" class=\"emoji emoji-1f47c\" role=\"img\" title=\"angel\">:angel:</span>? Not sure anyone cares that whiskering induces a strict endofunctor on <code>Cat</code> instead of a pseudofunctor.</p>\n</blockquote>\n<p>The <code>rfl</code> in</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">whiskeringLeft_obj_id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">whiskeringLeft</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">𝟭</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">𝟭</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>depends on the following defeq:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"mi\">𝟭</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">G</span>\n\n<span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">𝟭</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>I think the lemma itself is fine, but this should <strong>not</strong> be a simp lemma, at least unless it is really necessary, in the same philosophy  as the comment at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.comp_id#doc\">docs#CategoryTheory.Functor.comp_id</a>.</p>\n<p>The evilness of the <code>rfl</code> case is less than that of the non-rfl case, but there is still a possibility that it could be a problematic at <code>simp</code> or <code>isDefEq</code> performance in the future.</p>",
        "id": 472281696,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1727110090
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"438192\">Yuma Mizuno</span> <a href=\"#narrow/stream/287929-mathlib4/topic/equality.20of.20cones/near/472281696\">said</a>:</p>\n<blockquote>\n<p>The evilness of the <code>rfl</code> case is less than that of the non-rfl case</p>\n</blockquote>\n<p>Can you (or anyone...) clarify what you mean <strong><em>precisely</em></strong> by that ?<br>\nIs the evilness, in your sense of the word, of  <code>rfl</code> an idea coming from category theory,  or some best practice ?<br>\nCan it be rephrased as you considering \"f\" and \"f &gt;&gt; id\" as not equal, or evilly so, just because they are referred to as objects ?</p>\n<p>I fail to see what goal is pursued, or what problem is solved, by considering pre/post-composition not as a strict endofunctor.<br>\nThis seems very close to the associativity I had (no) issue with.</p>",
        "id": 472288277,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1727112058
    },
    {
        "content": "<p>Since the defeq (equallity can be proved by `rfl) is almost the \"identification\", it's usually fine to put an equality. Sometimes we need to recall that the defeq is actually not a true identification, and depends on how Lean or tactics handle expressions. </p>\n<p>The <code>simp</code> setting might be more controversial, and my intention was mostly a compatibility with the existing setting in the library.</p>",
        "id": 472303309,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1727116922
    },
    {
        "content": "<p>Thanks to <span class=\"user-mention\" data-user-id=\"438192\">@Yuma Mizuno</span> 's reminder about <code>Functor.comp_id</code>, I do agree that the Lemma from the PR should not be tagged with simp.</p>",
        "id": 472371322,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727141824
    },
    {
        "content": "<p>I noticed that <code>Functor.comp_id</code> and <code>Functor.id_comp</code> could not be proven with <code>rfl</code> in Lean 3, but they can be proven with <code>rfl</code> now. There may be a remnant of this in the current situation of these equalities.</p>",
        "id": 472374589,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1727143311
    },
    {
        "content": "<p>The related remark is that the <code>Functor.assoc</code> could be proved in <code>rfl</code> even in lean 3, but <code>Functor.associator</code> was preferred in many situations.</p>",
        "id": 472375145,
        "sender_full_name": "Yuma Mizuno",
        "timestamp": 1727143551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"438192\">Yuma Mizuno</span> <a href=\"#narrow/stream/287929-mathlib4/topic/equality.20of.20cones/near/472303309\">said</a>:</p>\n<blockquote>\n<p>Since the defeq (equallity can be proved by `rfl) is almost the \"identification\", it's usually fine to put an equality. Sometimes we need to recall that the defeq is actually not a true identification, and depends on how Lean or tactics handle expressions. </p>\n</blockquote>\n<p>So, just to clarify, that has nothing to do with category theory. It pertains to Lean and its use.<br>\nNotably, we rely on some normal form to identify expressions via defeq. </p>\n<p>It would be helpful to have another, more descriptive name for this kind of \"evilness\", distinct from the categorical one, (which is already confusing enough...), if this has an impact on any aspect .</p>",
        "id": 472417481,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1727162758
    },
    {
        "content": "<p>Thanks for your input, <span class=\"user-mention\" data-user-id=\"438192\">@Yuma Mizuno</span> ! Will remove the <code>simp</code>s</p>",
        "id": 472431452,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1727165992
    }
]