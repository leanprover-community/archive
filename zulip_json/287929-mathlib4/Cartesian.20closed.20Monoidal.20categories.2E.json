[
    {
        "content": "<p>After submitting <a href=\"https://github.com/leanprover-community/mathlib4/pull/17424\">#17424</a>, I realized that it would potentially introduce two competing ways for instanciating a monoidal category structure on <code>Type u</code>: either through the chosen finite products I introduced, or through <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.monoidalOfChosenFiniteProducts#doc\">docs#CategoryTheory.monoidalOfChosenFiniteProducts</a>. The code for cartesian closed categories impose that the monoidal category structure comes from the latter, and so a category whose monoidal structure comes from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.ChosenFiniteProducts.instMonoidalCategory#doc\">docs#CategoryTheory.ChosenFiniteProducts.instMonoidalCategory</a> canâ€™t be promoted to a Cartesian closed category, which feels pretty wrong as one should be able to freely choose wether or not their structure comes from provided finite products, or from abstract ones.</p>\n<p>I think a solution would be to introduce a class</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CartesianMonoidalCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">MonoidalCategory</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">unitTerminal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"n\">tensorUnit</span>\n<span class=\"w\">  </span><span class=\"n\">tensorProductIsBinaryProduct</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLimit</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">BinaryFan</span><span class=\"bp\">.</span><span class=\"n\">mk</span>\n<span class=\"w\">      </span><span class=\"o\">((</span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unitTerminal</span><span class=\"bp\">.</span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">â‰«</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rightUnitor</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">((</span><span class=\"n\">whiskerRight</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unitTerminal</span><span class=\"bp\">.</span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â‰«</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">leftUnitor</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which asserts that the underlying monoidal structure is in fact a cartesian one, and then change the code of <code>ChosenFiniteProducts</code>, <code>OfHasFiniteProduct</code> and the things about cartesian closed categories to use this class instead. But this would be a rather big refactor and it would also probably deprecate the code in <code>CategoryTheory/ChosenFiniteProducts/Symmetric.lean</code> (because its content would rather need to be generalized for arbitrarty cartesian monoidal categories).</p>\n<p>Since itâ€™s a rather big refactor, Iâ€™m asking for opinions on this before I try working on implementing it.</p>",
        "id": 474994114,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1728144963
    },
    {
        "content": "<p>Iâ€™m not sure why that PR is needed, since <code>Type</code> already has a chosen finite products instance in mathlib.</p>",
        "id": 474997046,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1728147278
    },
    {
        "content": "<p>The monoidal structure on <code>Type</code> in mathlib should indeed be the one coming from this instance.</p>",
        "id": 474997096,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1728147343
    },
    {
        "content": "<p>I donâ€™t see why <code>ChosenFiniteProducts</code> canâ€™t just be the class for Cartesian monoidal categories</p>",
        "id": 474997166,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1728147394
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Cartesian.20Monoidal.20categories.2E/near/474997046\">said</a>:</p>\n<blockquote>\n<p>Iâ€™m not sure why that PR is needed, since <code>Type</code> already has a chosen finite products instance in mathlib.</p>\n</blockquote>\n<p>Damn, youâ€™re right, I did not see that it was in <code>Monoidal/Types/Basic.lean</code><br>\nThen Iâ€™ll just close the PR, sorry for the noise for this one.<br>\nBut then it still looks like the code in <code>CategoryTheory/Closed/Types.lean</code> expects a different monoidal structure, or am I just completely not understanding how instances inferences work?</p>",
        "id": 474998231,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1728148203
    },
    {
        "content": "<p>Sorry, Iâ€™m not by a computer right now, so I canâ€™t check explicitly myself.</p>",
        "id": 475000475,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1728150089
    },
    {
        "content": "<p>Looks like I was worried about nothing and that instances find their way correctly, despite the code for monoidal closed categories relying on <code>OfHasFiniteProduct</code></p>",
        "id": 475008965,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1728154895
    },
    {
        "content": "<p>Actually, it looks like I spoke too soon:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Closed</span><span class=\"bp\">.</span><span class=\"n\">Types</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Monoidal</span><span class=\"bp\">.</span><span class=\"n\">Types</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">monoidalOfHasFiniteProducts</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MonoidalClosed</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">infer_instance</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n</code></pre></div>\n<p>The test instance canâ€™t be synthesized if I remove the local instance attribute, which tends to indicate that this is not using the \"right\" monoidal structure.</p>",
        "id": 475019855,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1728159741
    },
    {
        "content": "<p>Still on the subject of <code>ChosenFiniteProducts</code> and monoidal structures on <code>Type</code>, </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Monoidal</span><span class=\"bp\">.</span><span class=\"n\">Types</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">ChosenFiniteProducts</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">MonoidalCategory</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">âŠ—</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â‰…</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">â¨¯</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Iso</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n</code></pre></div>\n<p>Shows that despite the <code>ChosenFiniteProduct</code> instance, lean is not using it to synthesize <code>HasBinaryProduct E F</code> (and seems to be using that <code>Type u</code> has limits for all small discrete categories instead), and I donâ€™t know if that should count as a bug or a feature.</p>",
        "id": 475277077,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1728301295
    },
    {
        "content": "<p>The <code>â¨¯</code> notation always uses a choice principle to pick an arbitrary binary product (and <code>HasBinaryProduct E F</code> is a <code>Prop</code>-valued class that only asserts that a product exists, it does not contain a specific choice of product), so this is not supposed to work. If you want to talk about the chosen binary product, <code>E âŠ— F</code> is the correct way to do so.</p>",
        "id": 475278419,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1728301758
    },
    {
        "content": "<p>Feature it is then, thanks for the clarification.</p>",
        "id": 475278661,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1728301847
    },
    {
        "content": "<p>After the change to use <code>ChosenFiniteProducts</code> for CCCs, some lemmas that refer to <code>prod</code> no longer work when the <code>ChosenFiniteProducts</code> are chosen in the AC sense. Should the below be simp lemmas or not?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">ChosenFiniteProducts.ofFiniteProducts_fst</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasFiniteProducts</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">ChosenFiniteProducts.fst</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ChosenFiniteProducts.ofFiniteProducts</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">prod.fst</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">ChosenFiniteProducts.ofFiniteProducts_snd</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasFiniteProducts</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">ChosenFiniteProducts.snd</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ChosenFiniteProducts.ofFiniteProducts</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">prod.snd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 486409828,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1733440371
    },
    {
        "content": "<p>And is it a problem that the following fails to hold definitionally?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.ChosenFiniteProducts</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.Monoidal.OfHasFiniteProducts</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasFiniteProducts</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">monoidalOfHasFiniteProducts</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">ChosenFiniteProducts.instMonoidalCategory</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ChosenFiniteProducts.ofFiniteProducts</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 486410918,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1733440929
    }
]