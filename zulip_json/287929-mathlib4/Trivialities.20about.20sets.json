[
    {
        "content": "<p>Is there any <code>tauto</code>-like tactics that could solve trivialities about sets? I would like to use something similar to the former example to the latter example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∨</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">A</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">tauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∪</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">tauto</span>\n</code></pre></div>\n<p>Chaining these three tactics works well, but I'd rather use a single tactic. In this case, I could use <code>aesop</code> for a one-line proof of the latter statement, but there are cases where I want to avoid <code>aesop</code> because the sets have some inner structure that misleads <code>aesop</code> but would be irrelevant for a <code>tauto</code>-like tactic.</p>",
        "id": 430300658,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1711737321
    },
    {
        "content": "<p>This question comes periodically and I think we still don’t have a good answer.</p>",
        "id": 430301076,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1711737486
    },
    {
        "content": "<p>In your cases, <code>aesop</code> solves both.</p>",
        "id": 430301367,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711737635
    },
    {
        "content": "<p>Maybe there could be a <code>set_ext</code> simp set (not sure about the name) loaded with simp lemmas that turn equalities of sets and subset relations into booleans?</p>\n<p>Here are a few lemmas that could go into that simp set:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∪</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.ext_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_inter_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_union</span><span class=\"o\">]</span>\n  <span class=\"n\">tauto</span>\n</code></pre></div>\n<p>With the simp set, it could look like <code>simp only [set_ext]; tauto</code></p>",
        "id": 430317519,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711746059
    },
    {
        "content": "<p>If there wasn't already a tactic called <code>set</code>, then <code>set</code> would be a good name for this one!</p>",
        "id": 430317861,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711746233
    },
    {
        "content": "<p>This is my attempt at implementing it (and a few tests):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Tauto</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"setauto\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span>\n    <span class=\"n\">try</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span>\n      <span class=\"n\">Set.ext_iff</span><span class=\"o\">,</span>\n      <span class=\"n\">Set.subset_def</span><span class=\"o\">,</span>\n      <span class=\"n\">Set.mem_inter_iff</span><span class=\"o\">,</span>\n      <span class=\"n\">Set.mem_union</span><span class=\"o\">,</span>\n      <span class=\"n\">Set.mem_compl_iff</span><span class=\"o\">,</span>\n    <span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n    <span class=\"bp\">&lt;;&gt;</span>\n    <span class=\"n\">try</span> <span class=\"n\">tauto</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">Set.univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∅</span> <span class=\"bp\">⊆</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">A</span><span class=\"bp\">ᶜᶜ</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">⊆</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">Set.univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">-- setauto -- fails</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hAB</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hBC</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∪</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">∪</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">=</span> <span class=\"n\">C</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"bp\">ᶜᶜ</span><span class=\"o\">)</span><span class=\"bp\">ᶜᶜᶜᶜᶜ</span> <span class=\"bp\">=</span> <span class=\"n\">C</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∪</span> <span class=\"bp\">∅</span> <span class=\"bp\">∪</span> <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">D</span> <span class=\"bp\">∩</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∪</span> <span class=\"n\">C</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">ᶜᶜ</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"bp\">ᶜᶜᶜ</span> <span class=\"bp\">∩</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">D</span><span class=\"bp\">ᶜᶜ</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span><span class=\"o\">)</span><span class=\"bp\">ᶜᶜ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">setauto</span>\n</code></pre></div>\n<p>It was brought to my attention that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Tactic.Tauto.tauto#doc\">docs#Mathlib.Tactic.Tauto.tauto</a> doesn't work for universal quantifiers. Therefore, I cannot use <code>tauto</code> in this way probably. And I want a tactic that does not work with the internal structure of given sets, so <code>aesop</code> is not an option either.</p>",
        "id": 431564548,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712334962
    },
    {
        "content": "<p>Can somebody make a Mathlib-ready tactic out of the <code>setauto</code> above?</p>",
        "id": 436692000,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1714655944
    },
    {
        "content": "<p>Martin, I think you should specify precisely the scope of this tactic. What problems are in scope, and which are out of scope? After you have that list, try to make the above succeed on a collection of tests determined by your scope.</p>\n<p>After you get that working, realize that it's likely the case that you don't want to transform your entire local context (with <code>simp only ... at *</code>) permanently when calling this tactic. So then learn a bit more to make it so it doesn't suffer from that problem. At that point, I think <em>you</em> can make the PR. Even if it's not Mathlib-ready, you can at least hope that people will suggest improvements.</p>",
        "id": 436717476,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714662880
    },
    {
        "content": "<p>Has there been any follow-up work on this? </p>\n<p>When working on <a href=\"https://github.com/dagurtomas/LeanCondensed/blob/master/LeanCondensed/Projects/LightProfiniteInjective.lean\">this project</a> I frequently wished for a single tactic that proved inclusions/equalities between iterated unions, intersections, and complements. </p>\n<p>To add to the examples of <span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span>  above, here are some typical test cases that I have in mind:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Some of these are exact statements of mathlib lemmas, and many  of them can be handled by aesop or by Martin's tactic macro above. But I feel that a single tactic should be able to settle all of them (and in fact by reduction to an invocation of tauto). </p>\n<p>If nobody has worked on this, I'd be excited to try to do this myself; but it would be even better if someone else with more experience wants to join or help out!</p>",
        "id": 491764852,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1735914187
    },
    {
        "content": "<p>If you define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"set_tac\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">tauto</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>then all are solved with <code>by set_tac</code>, except</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 491767996,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1735915885
    },
    {
        "content": "<p>I also think that this should maybe be a lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">inter_eq_univ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 491769050,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1735916380
    },
    {
        "content": "<p>Why is this in <a class=\"stream\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4\">#lean4</a> ?</p>",
        "id": 491769162,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1735916415
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/Trivialities.20about.20sets\">#lean4 &gt; Trivialities about sets</a> by <span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span>.</p>",
        "id": 491770532,
        "sender_full_name": "Notification Bot",
        "timestamp": 1735916925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Trivialities.20about.20sets/near/491769162\">said</a>:</p>\n<blockquote>\n<p>Why is this in <a class=\"stream\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4\">#lean4</a> ?</p>\n</blockquote>\n<p>My bad, thanks for the move!</p>",
        "id": 491779137,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1735921091
    },
    {
        "content": "<p>I now have a version that passes all tests I could come up with. See here: <a href=\"https://github.com/LennyTaelman/setauto/blob/master/Setauto/Setauto.lean\">https://github.com/LennyTaelman/setauto/blob/master/Setauto/Setauto.lean</a></p>\n<p>Comments are very welcome! And examples that break this even more ;-)</p>\n<p>One thing that kept causing trouble was the simp lemma univ_subset_iff (and its counterpart subset_empty_iff). Everything seemed to work much more easily when reversing the direction of simplification in these. Is there any deeper reason for these lemmas to work the way they currently do?</p>",
        "id": 492274400,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1736242843
    },
    {
        "content": "<p>Ok, chasing boundary cases trying to break the tactic, it seems I broke something more. Here is a minimal case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Tauto</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">weird</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">tauto</span><span class=\"w\"> </span><span class=\"c1\">-- No goals, yet lean gives \"application type mismatch\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">weird</span><span class=\"w\"> </span><span class=\"c1\">-- unknown identifier 'weird'</span>\n</code></pre></div>\n<p>The tactic tauto seems to work, yet lean does not infer a term `weird'. Is this supposed to be possible? Is it a bug in tauto? Or in some part of lean? Or in the infoview?</p>",
        "id": 492332535,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1736263851
    },
    {
        "content": "<p>I get an error on the <code>weird</code> in <code>lemma weird</code> and I don't trust any Lean output (e.g. \"no goals\") after the first error in my code.</p>",
        "id": 492334431,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1736264471
    },
    {
        "content": "<p>This seems to be fixed on latest mathlib according to <a href=\"https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAWQIYwBYBtgCMB0AVJAYxmEPyQFcYIAoG9AUxBCTgHcHgoATOACkCNwHABccPAE8wDAJT9UIuEMBJhHABiSdAGcZ/AB4KBs0eq0MRAXjhZxNOHBiVqcALTO4AOQhwA5hA2aAGjhxBnhGJAA7H2AANwZNOAAiJDAwTEIUYAgomEkzEGBNFhhCVES6AGJShkIAa3ZOHhc3CgjaiIg2KOBuBgiSADNgBig4AHIOLm4xmiA\">the live server</a>.</p>",
        "id": 492334834,
        "sender_full_name": "Christian Merten",
        "timestamp": 1736264615
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.univ_subset_iff#doc\">docs#Set.univ_subset_iff</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.subset_empty_iff#doc\">docs#Set.subset_empty_iff</a></p>",
        "id": 492340609,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736266390
    },
    {
        "content": "<p>I agree that it would make sense to flip the simp direction of those.<br>\nWe should just try that, and see if Mathlib still builds (-;</p>",
        "id": 492340896,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736266475
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.univ_subset_iff#doc\">docs#Set.univ_subset_iff</a> matches <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=top_le_iff#doc\">docs#top_le_iff</a> though (same for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.subset_empty_iff#doc\">docs#Set.subset_empty_iff</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=le_bot_iff#doc\">docs#le_bot_iff</a>).</p>",
        "id": 492341360,
        "sender_full_name": "Christian Merten",
        "timestamp": 1736266601
    },
    {
        "content": "<p>I would be inclined to flip those as well, and see what happens</p>",
        "id": 492341958,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736266783
    },
    {
        "content": "<p>Here is a simpler new version that seems to tackle the boundary cases as well: <a href=\"https://github.com/LennyTaelman/setauto/blob/master/Setauto/Setauto.lean\">https://github.com/LennyTaelman/setauto/blob/master/Setauto/Setauto.lean</a></p>\n<p>The main point is a custom tactic 'specialize_all' that attempts to specialize all hypotheses in the local context at a common term.</p>\n<p>The actual setauto tactic then becomes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"setauto\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"o\">(</span>\n<span class=\"w\">  </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">    </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">diff_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">disjoint_iff</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">subset_def</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_union</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_compl_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_empty_iff_false</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_inter_iff</span><span class=\"o\">,</span>\n<span class=\"w\">  </span><span class=\"o\">]</span><span class=\"bp\">;</span>\n<span class=\"w\">  </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">specialize_all</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">tauto</span>\n<span class=\"o\">))</span>\n</code></pre></div>\n<p>Feedback is very welcome!</p>",
        "id": 492760601,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1736439334
    },
    {
        "content": "<p>One remaining issue: how do I make this into a tactic that either succeeds or raises an error? The tauto tactic will raise an error if it fails (as desired), but it will also raise an error if the simp already closes the goal.</p>",
        "id": 492761280,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1736439522
    },
    {
        "content": "<p>And here is the specialize_all tactic code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">specialize_all</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"specialize_all\"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"n\">specialize_all</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">evalSpecializeAll</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">withMainContext</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">specialize_all</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- loop over all hypotheses h</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">MonadLCtx</span><span class=\"bp\">.</span><span class=\"n\">getLCtx</span>\n<span class=\"w\">    </span><span class=\"n\">ctx</span><span class=\"bp\">.</span><span class=\"n\">forM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">LocalDecl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">saveState</span>\n<span class=\"w\">      </span><span class=\"n\">try</span>\n<span class=\"w\">        </span><span class=\"c1\">-- run `specialize h x`</span>\n<span class=\"w\">        </span><span class=\"n\">evalTactic</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">specialize</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">userName</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"n\">catch</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">restoreState</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"unexpected input\"</span>\n</code></pre></div>",
        "id": 492761672,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1736439613
    },
    {
        "content": "<p>If you use <code>&lt;;&gt; tauto</code>, tauto will not run if the previous tactics close all goal.</p>",
        "id": 492761889,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736439670
    },
    {
        "content": "<p>Ending with <code>done</code> will raise an error if there are open goals.</p>",
        "id": 492761959,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736439686
    },
    {
        "content": "<p>It is probably safer to add a <code>focus</code> at the very start of the tactic calls.</p>",
        "id": 492762052,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736439714
    },
    {
        "content": "<p>(Sorry that I'm so brief: I'm on mobile!)</p>",
        "id": 492762155,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736439733
    },
    {
        "content": "<p>ah, never seen this focus thing. Let me see if I can dig up an example/doc...</p>",
        "id": 492762385,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1736439808
    },
    {
        "content": "<p>Basically it makes the tactic act on the current goal, it's subgoals, but will not leak into a second goal.</p>",
        "id": 492762628,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736439871
    },
    {
        "content": "<p>So, if you had two goal and simp closes the first, you do not want tauto tackling the second one.</p>",
        "id": 492762727,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736439902
    },
    {
        "content": "<p>makes sense!</p>",
        "id": 492762787,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1736439923
    },
    {
        "content": "<p>Of course, it is already dubious form to have two accessible goals, but that is no reason to avoid building more robust tactics!</p>",
        "id": 492762859,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736439949
    },
    {
        "content": "<p>/poll What would be a good name for this tactic? (Alas \"set\" is already taken...)<br>\nsetauto<br>\nset_tauto<br>\ntauto_set</p>",
        "id": 492893795,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1736495164
    },
    {
        "content": "<p>(I voted for tauto_set because of aesop_cat)</p>",
        "id": 492902319,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1736498823
    },
    {
        "content": "<p>That convinced me!</p>",
        "id": 492902440,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1736498867
    },
    {
        "content": "<p>Good point!</p>",
        "id": 492904213,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1736499562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479731\">Lenny Taelman</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Trivialities.20about.20sets/near/492274400\">said</a>:</p>\n<blockquote>\n<p>Comments are very welcome! And examples that break this even more ;-)</p>\n</blockquote>\n<p>Can you please test the following examples?<br>\n<a href=\"https://github.com/Ivan-Sergeyev/seymour/blob/d8fcfa23336efe50b09fa0939e8a4ec3a5601ae9/Seymour/ForMathlib/SetTheory.lean\">https://github.com/Ivan-Sergeyev/seymour/blob/d8fcfa23336efe50b09fa0939e8a4ec3a5601ae9/Seymour/ForMathlib/SetTheory.lean</a><br>\nI would like your tactic to solve most of them.</p>",
        "id": 492911162,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1736501906
    },
    {
        "content": "<p>Thanks for the test cases! Some of those are outside of the scope (containing strict subsets or other forms of hidden existential quantifiers), and I don't think it would be reasonable to extend the scope (we'd quickly run into things that are meant for SAT solvers). All the ones that are within scope are solved by setauto, and some of them are quite significant compressions...</p>\n<p>See <a href=\"https://github.com/LennyTaelman/setauto/blob/master/Setauto/Setauto.lean\">https://github.com/LennyTaelman/setauto/blob/master/Setauto/Setauto.lean</a> for the updated file including your test cases.</p>",
        "id": 492919039,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1736504616
    },
    {
        "content": "<p>In case it is helpful, you can simplify your code:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/Setauto/Setauto.lean b/Setauto/Setauto.lean</span>\n<span class=\"gh\">index ad8dc49..7d6c0f0 100644</span>\n<span class=\"gd\">--- a/Setauto/Setauto.lean</span>\n<span class=\"gi\">+++ b/Setauto/Setauto.lean</span>\n<span class=\"gu\">@@ -26,22 +26,11 @@ open Lean Elab.Tactic</span>\n<span class=\"w\"> </span>  `specialize h x` for all hypotheses `h` where this tactic succeeds.\n<span class=\"w\"> </span>-/\n\n<span class=\"gd\">-syntax (name := specialize_all) \"specialize_all\" term : tactic</span>\n<span class=\"gd\">-</span>\n<span class=\"gd\">-@[tactic specialize_all] def evalSpecializeAll : Tactic :=</span>\n<span class=\"gd\">-    fun stx =&gt; withMainContext do</span>\n<span class=\"gd\">-  match stx with</span>\n<span class=\"gd\">-  | `(tactic| specialize_all $x:term) =&gt;</span>\n<span class=\"gd\">-    -- loop over all hypotheses h</span>\n<span class=\"gd\">-    let ctx ← Lean.MonadLCtx.getLCtx</span>\n<span class=\"gd\">-    ctx.forM fun h: Lean.LocalDecl =&gt; do</span>\n<span class=\"gd\">-      let s ← saveState</span>\n<span class=\"gd\">-      try</span>\n<span class=\"gd\">-        -- run `specialize h x`</span>\n<span class=\"gd\">-        evalTactic (← `(tactic|specialize $(mkIdent h.userName) $x))</span>\n<span class=\"gd\">-      catch _ =&gt;</span>\n<span class=\"gd\">-        restoreState s</span>\n<span class=\"gd\">-  | _ =&gt; throwError \"unexpected input\"</span>\n<span class=\"gi\">+elab (name := specialize_all) \"specialize_all\" x:term : tactic =&gt; withMainContext do</span>\n<span class=\"gi\">+  -- loop over all hypotheses h</span>\n<span class=\"gi\">+  for h in ← getLCtx do</span>\n<span class=\"gi\">+    -- run `specialize h x`</span>\n<span class=\"gi\">+    evalTactic (← `(tactic|specialize $(mkIdent h.userName) $x)) &lt;|&gt; pure ()</span>\n\n\n<span class=\"w\"> </span>macro \"tauto_set\" : tactic =&gt; `(tactic|\n</code></pre></div>",
        "id": 492948302,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736514994
    },
    {
        "content": "<p>Thanks! This seems actually more robust in my tests, with &lt;|&gt; catching errors that the try-catch block in the original code doesn't. I'll have to delve more into the different ways tactics can produce errors...</p>",
        "id": 492963662,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1736519884
    },
    {
        "content": "<p>As a general rule, <code>try ... catch</code> to simply restore a state is often better implemented using a \"backtrack\".</p>\n<p>Anyway, I am glad that this is helpful!</p>",
        "id": 492964216,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736520073
    },
    {
        "content": "<p>Not all monads have backtracking, though: I think that <code>MetaM</code>, <code>TermElabM</code> and <code>TacticM</code> do, but <code>CommandElabM</code> does not.  (To be confirmed!)</p>",
        "id": 492964507,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736520156
    },
    {
        "content": "<p>Thanks everyone for your help. I have now committed the <code>tauto_set</code> tactic to a branch of the mathlib4 repository, see <a href=\"https://github.com/leanprover-community/mathlib4/commit/36d9caf83ecb3ba06487c7d0cf53c3841e4b79e5\">here</a>.</p>\n<p>Before I make a pull request (my first), I have a few more questions:</p>\n<ol>\n<li>Do I include the test examples? Do they go somewhere else in mathlib? Or are they just discarded? They could be useful in asserting that changes elsewhere (e.g. in a simp lemma) don't break the tactic?</li>\n<li>What/where else should I document? And more generally: how do I make sure users actually know about this tactic and use it where appropriate? </li>\n<li>Anything else I should pay attention to?</li>\n</ol>",
        "id": 493195003,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1736693067
    },
    {
        "content": "<p>Yes tests definitely go with the PR. I've never PRed a tactic myself but looking at past PRs of tactics it looks like you should dump the test file in <code>MathlibTest/tauto_set.lean</code>. I would also be tempted to put two examples in the docstring for the tactic. Users will just come to learn about it by osmosis.</p>",
        "id": 493195435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1736693404
    },
    {
        "content": "<p>Regarding tests, they should go in a new file in the MathlibTest directory (see the other examples there).</p>",
        "id": 493195438,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1736693405
    },
    {
        "content": "<p>Wrt 2, you could also use your tactic in a few places in mathlib, to show how it works \"in the real world\" to golf/uniformize a few proofs.  It does not have to be exhaustive, in order to avoid creating too much extra diff.  Alternatively, you could also open a dependent PR that, on top of a PR that only adds the tactic (and the tests), uses it in mathlib: in this case, you can try to be more exhaustive.</p>",
        "id": 493198431,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736696031
    },
    {
        "content": "<p>The possibility of viewing what kinds of proofs get simplified/are in scope for the tactic is helpful for the review process.</p>",
        "id": 493198490,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1736696062
    },
    {
        "content": "<p>Thanks for all your help! This is now PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/20706\">#20706</a>.</p>",
        "id": 493336240,
        "sender_full_name": "Lenny Taelman",
        "timestamp": 1736770752
    },
    {
        "content": "<p>Are there any easy candidates for files where this could be used to golf proofs?</p>",
        "id": 495651076,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737704234
    }
]