[
    {
        "content": "<p>In category theory (and probably other areas of mathlib such as algebraic geometry), general purpose lemmas are not necessarily in <code>dsimp</code> normal form, but still it has been possible to use them with <code>rw</code> and <code>simp</code> until <a href=\"https://github.com/leanprover/lean4/pull/12179\">https://github.com/leanprover/lean4/pull/12179</a><br>\nThe temporary fix is using <code>set_option backward.isDefEq.respectTransparency false</code> but it is considered as a technical debt <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Technical.20Debt.20Counters/near/575224820\">#mathlib4 &gt; Technical Debt Counters @ üí¨</a></p>",
        "id": 575321937,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1771859769
    },
    {
        "content": "<p>Feature-request: add an attribute <code>dsimp-nf</code> which would replace a lemma by its <code>dsimp</code>ed-version, e.g. in the example below, the statement of <code>naturality</code> would be transformed into <code>naturality'</code>. (It would be nice to have a setup which would allow to automatically apply this attribute to all the <code>simp</code>-lemmas that are declared in a given file/section.)</p>",
        "id": 575321965,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1771859775
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">module</span>\n\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.Functor.Category</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">œÑ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"mi\">ùü≠</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">backward.isDefEq.respectTransparency</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">naturality</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F.map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">œÑ.app</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">œÑ.app</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Note that we can do `dsimp only [Functor.id_obj, Functor.comp_obj]` here</span>\n<span class=\"w\">  </span><span class=\"c1\">-- which means that the statement is not in \"dsimp\" normal form</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">NatTrans.naturality</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F.map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">œÑ.app</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">œÑ.app</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">naturality</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- fails since https://github.com/leanprover/lean4/pull/12179</span>\n<span class=\"w\">  </span><span class=\"c1\">-- unless we do `set_option backward.isDefEq.respectTransparency false`</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">naturality'</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F.obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">G.obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F.obj</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G.map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F.map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F.obj</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">œÑ.app</span><span class=\"w\"> </span><span class=\"n\">Y</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F.obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">œÑ.app</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">NatTrans.naturality</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">test'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F.map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">œÑ.app</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">œÑ.app</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">naturality'</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 575321988,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1771859782
    },
    {
        "content": "<p>Alternatively or additionally, I am wondering if we should use unification hints for some of the standard identities that we want to treat as reducible equalities. For example, with this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">unif_hint</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚âü</span><span class=\"w\"> </span><span class=\"n\">X</span>\n</code></pre></div>\n<p>the example works.</p>",
        "id": 575324383,
        "sender_full_name": "Christian Merten",
        "timestamp": 1771860332
    },
    {
        "content": "<p>Everywhere where we have (non-reducible) bundled objects with projections involving terms that (often) appear in types (i.e. everywhere in category theory / algebraic geometry), it has always been difficult to write reducibly type-correct lemmas. Aggressively running <code>dsimp</code> on all statements is maybe one fix, but it seems more like a hack than a long-term solution to me.</p>",
        "id": 575326263,
        "sender_full_name": "Christian Merten",
        "timestamp": 1771860771
    },
    {
        "content": "<p>In principle, the <code>simpNF</code> linter should complain on these lemmas...<br>\nWhat I am basically saying is that <code>set_option backward.isDefEq.respectTransparency true</code> completely breaks the experience of writing category theory Lean code unless one or more reasonable solutions are found!</p>",
        "id": 575327472,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1771861045
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Feature.20request.3A.20attribute.20dsimp-nf/near/575324383\">said</a>:</p>\n<blockquote>\n<p>Alternatively or additionally, I am wondering if we should use unification hints for some of the standard identities that we want to treat as reducible equalities. For example, with this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">unif_hint</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚âü</span><span class=\"w\"> </span><span class=\"n\">X</span>\n</code></pre></div>\n<p>the example works.</p>\n</blockquote>\n<p>Where do I start learning more about unification hints? What do they do exactly that makes this example work? The command <code>unif_hint</code> has no hover info, and is not mentionned in the reference manual.</p>",
        "id": 575335880,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1771863002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Feature.20request.3A.20attribute.20dsimp-nf/near/575335880\">said</a>:</p>\n<blockquote>\n<p>Where do I start learning more about unification hints?</p>\n</blockquote>\n<p>Unfortunately, I think this is an open question. If you find the answer, I am happy to hear it. Maybe the best documentation is following the <a href=\"https://github.com/leanprover/lean4/blob/ed0fd1e933239beaa7aaa12598f961c260062ab6/src/Lean/Meta/ExprDefEq.lean#L1979\">source code</a>. This is the only invocation of <code>tryUnificationHints</code> and it happens as one of the last steps in the def-eq algorithm (which is why I don't get why they are called unification <em>hints</em>, the name suggests to me they should be checked much earlier).</p>\n<p>The one thing I learnt, purely from observation, is that</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">unif_hint</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚âü</span><span class=\"w\"> </span><span class=\"n\">B</span>\n</code></pre></div>\n<p>makes <code>A</code> and <code>B</code> <em>reducibly</em> def-eq if <code>A</code> and <code>B</code> are def-eq.</p>",
        "id": 575339616,
        "sender_full_name": "Christian Merten",
        "timestamp": 1771863942
    },
    {
        "content": "<p>And <code>unif_hint</code> can be conditional, i.e. you can write things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">unif_hint</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚âü</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚âü</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">B</span>\n</code></pre></div>",
        "id": 575340403,
        "sender_full_name": "Christian Merten",
        "timestamp": 1771864072
    },
    {
        "content": "<p>When normal definition equality fails (as part of <code>onFailure</code>), then it tries unification hints. In a call of <code>isDefEq t s</code> trying a unification hint <code>unif_hint name? binders... where $[clhs ‚âü crhs]* ‚ä¢ lhs ‚âü rhs</code> does the following: it first tries unifying <code>t</code> with <code>lhs</code> as well as <code>s</code> with <code>rhs</code> under reducible transparency and then checks definitional equality of all constraints, i.e. it checks <code>isDefEq clhs crhs</code> for every constraint. If this fails, it tries again with <code>t</code> and <code>s</code> swapped.<br>\nSo roughly speaking, it tells definitional equality what to do in a situation that looks like <code>lhs =?= rhs</code>, namely, that it should try unifying all <code>clhs =?= crhs</code> in that case. Also notable is that unification hints are indexed using their left-hand side, so that should be the more specific side.<br>\nHowever, the current implementation of unification hints is <em>not</em> safe, consider:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">unif_hint</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"c1\">-- totally fine</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- kernel error</span>\n</code></pre></div>\n<p>c.f. <a href=\"https://github.com/leanprover/lean4/pull/8982\">lean4#8982</a> and <a href=\"https://github.com/leanprover/lean4/pull/8988\">lean4#8988</a></p>",
        "id": 575343365,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1771864724
    },
    {
        "content": "<p>Thanks to you both for taking the time to explain!</p>",
        "id": 575348259,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1771865933
    },
    {
        "content": "<p>This is maybe similar to what you are imagining (as a command, because attributes need two files which is not compatible with the live editor). I unfortunately don't know how to <em>replace</em> the original declaration by the <code>dsimp</code>ed one.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">Category</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Term</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">dsimpExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"n\">simpType</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ctxt</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">Simp</span><span class=\"bp\">.</span><span class=\"n\">Context</span><span class=\"bp\">.</span><span class=\"n\">ofNames</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">res</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">ctxt</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"dsimp_decl\"</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"bp\">.</span><span class=\"n\">getId</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">info</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">withoutExporting</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">getConstInfo</span><span class=\"w\"> </span><span class=\"n\">src</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">info</span><span class=\"bp\">.</span><span class=\"n\">levelParams</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">mkLevelParam</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">src</span><span class=\"bp\">.</span><span class=\"n\">appendAfter</span><span class=\"w\"> </span><span class=\"s2\">\"_dsimped\"</span>\n<span class=\"w\">  </span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newValue</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">dsimpExpr</span><span class=\"w\"> </span><span class=\"n\">value</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newType</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">newValue</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">addDecl</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">mkThmOrUnsafeDef</span>\n<span class=\"w\">      </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">levelParams</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">info</span><span class=\"bp\">.</span><span class=\"n\">levelParams</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">newType</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">newName</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">newValue</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">œÑ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"mi\">ùü≠</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">backward</span><span class=\"bp\">.</span><span class=\"n\">isDefEq</span><span class=\"bp\">.</span><span class=\"n\">respectTransparency</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">naturality</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Note that we can do `dsimp only [Functor.id_obj, Functor.comp_obj]` here</span>\n<span class=\"w\">  </span><span class=\"c1\">-- which means that the statement is not in \"dsimp\" normal form</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">NatTrans</span><span class=\"bp\">.</span><span class=\"n\">naturality</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"n\">dsimp_decl</span><span class=\"w\"> </span><span class=\"n\">naturality</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span>\n<span class=\"w\">  </span><span class=\"c1\">-- fails</span>\n<span class=\"w\">  </span><span class=\"n\">fail_if_success</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">naturality</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- succeeds</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">naturality_dsimped</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 575353306,
        "sender_full_name": "Christian Merten",
        "timestamp": 1771867231
    }
]