[
    {
        "content": "<p>When working on <a href=\"https://github.com/leanprover-community/mathlib4/pull/21745\">#21745</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/21746\">#21746</a>, I ran into the annoying situation where I would end ups with casts of <code>a : Nat</code> to <code>Fin m</code> while having a context \"easily\" proving that <code>a &lt; m</code> , and had to manually rewrite it to <code>⟨a, h⟩</code> using something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">fin_natCast_of_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NeZero</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">val_natCast</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mod_eq_of_lt</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This is probably a design issue on my end that I ended up with such casts in the first place, but it made me feel like some kind of tactic could automate getting rid of those, and I ended up writing the <a href=\"https://gist.github.com/robin-carlier/f2e43600581c95d723b82467bd1b248e\">following</a>. It’s basically a wrapper around <code>rw</code>and <code>omega</code>that looks for occurences of casts from <code>a : Nat</code> to <code>Fin m</code> (for <code>a</code> in a list of <code>Nat</code>-valued terms provided as argument to the tactic), tries to find a proof that <code>a &lt; m</code> using omega, and replace the cast by a better term using that proof.  </p>\n<p>I am rather new to metaprogramming so I would greatly appreciate overall comments on the code/ the way this kind of things are done normally.</p>\n<p>Arguably, this is a very specific tactic for a very specific application in a situation people should avoid ending up in the first place, so is it worth cleaning this up and try to PR it or would that be unneeded?</p>",
        "id": 500042595,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1739737906
    },
    {
        "content": "<p>I broke it... Looks like it can't handle forall expressions. Maybe if you test it a bit more.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- PANIC at Lean.Meta.whnfEasyCases Lean.Meta.WHNF:366:22: loose bvar in expression</span>\n<span class=\"c1\">-- backtrace:</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NeZero</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))),</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">fin_natcast</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 500043890,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1739739002
    },
    {
        "content": "<p>Well, that says a lot about my meta skills <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>, guess I indeed need to test more...</p>",
        "id": 500043995,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1739739086
    },
    {
        "content": "<p>matching on <code>e</code> rather than on <code>whnfR e</code> at line 13 seems to fix this particular case, but I can’t say I understand why...</p>",
        "id": 500044267,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1739739280
    },
    {
        "content": "<p>The problem seems to be in <code>partial def collectTargets</code> calling <code>whnfR</code> on expressions that may contain loose bvars. You can check if an expression has loose bvars with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr.hasLooseBVars#doc\">docs#Lean.Expr.hasLooseBVars</a>, and skip the ones that do (this is what <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.kabstract#doc\">docs#Lean.Meta.kabstract</a>, the machinery behind <code>rw</code>, does).</p>",
        "id": 500044386,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1739739385
    },
    {
        "content": "<p>Yup, trying around it looks like overall I need to do better on the parsing. It performs badly on stuff like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NeZero</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))),</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">fin_natcast</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>So this is very much not ready yet</p>",
        "id": 500046448,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1739741127
    }
]