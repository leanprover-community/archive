[
    {
        "content": "<p>In the following example, <code>linarith</code> fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>\n<p>Shouldn't this work?<br>\nI could be mistaken, but I think it used to work.  Did something change?</p>",
        "id": 564853074,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1766263935
    },
    {
        "content": "<p>I might be over explaining, but here's how I understand it. <br>\nYou have <code>let n := 1</code>. This is a <strong>let-binding</strong>: <code>n</code> is <em>definitionally</em> equal to <code>1</code>. The kernel can unfold <code>n</code> to <code>1</code>. However, this is <strong>not</strong> a hypothesis <code>h : n = 1</code>, and <strong><code>linarith</code> does not unfold let-bindings</strong>. It operates though</p>\n<ol>\n<li>Collect hypotheses</li>\n<li>Negate the goal</li>\n<li>Search for a contradiction</li>\n</ol>\n<p>So you may fix it with</p>\n<ul>\n<li>Parse <code>let</code> as a hypothesis</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">    </span><span class=\"n\">linarith</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>\n<ul>\n<li>Use <code>omega</code>, which unfolds <code>let</code></li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">omega</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>\n<ul>\n<li>Take it as a decidable proposition</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\">          </span><span class=\"c1\">-- norm_num, native_decide, etc. all work</span>\n</code></pre></div>",
        "id": 564866001,
        "sender_full_name": "Fengyang Wang",
        "timestamp": 1766284221
    },
    {
        "content": "<p>That makes sense.  But I think this used to work.  Did linarith used to unfold let-bindings, and was it changed?  Or am I remembering wrong?</p>",
        "id": 564866228,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1766284675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"453098\">Dan Velleman</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linarith.20and.20let/near/564866228\">said</a>:</p>\n<blockquote>\n<p>That makes sense.  But I think this used to work.  Did linarith used to unfold let-bindings, and was it changed?  Or am I remembering wrong?</p>\n</blockquote>\n<p>Your question intrigues me on what <code>linarith</code> can and cannot unfold. Here's a snippet that shows the behavior of <code>whnfR</code>(Weak Wead Normal Form with <strong>Reducible</strong> transparency) that <code>linarith</code> operates on</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"#demo_whnfR\"</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">e</span>\n\n<span class=\"w\">    </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"Original:  {← ppExpr e}\"</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- whnfR: reducible transparency (default for linarith)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">whnfR_result</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">withTransparency</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">reducible</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">whnf</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">    </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"whnfR:     {← ppExpr whnfR_result}\"</span>\n\n<span class=\"w\">    </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span>\n\n\n<span class=\"c1\">-- Reducible definitions are unfolded</span>\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myId</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"bp\">#</span><span class=\"n\">demo_whnfR</span><span class=\"w\"> </span><span class=\"n\">myId</span><span class=\"w\"> </span><span class=\"mi\">42</span>\n<span class=\"c1\">-- Original:  myId 42</span>\n<span class=\"c1\">-- whnfR:     42</span>\n\n<span class=\"c1\">-- ## Non-reducible definitions are NOT unfolded</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myConst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"bp\">#</span><span class=\"n\">demo_whnfR</span><span class=\"w\"> </span><span class=\"n\">myConst</span><span class=\"w\"> </span><span class=\"mi\">42</span>\n<span class=\"c1\">-- Original:  myConst 42</span>\n<span class=\"c1\">-- whnfR:     myConst 42  (unchanged!)</span>\n</code></pre></div>\n<p>As for <em>why</em> it is implemented this way, then we are going into deep type theory and the meta-programming. I also took a look at <a href=\"https://leanprover-community.github.io/mathlib_docs/tactic/linarith/parsing.html\">lean3 doc</a> for <code>linarith</code>, it doesn't invoke explicitly <code>whnfR</code>, so I can't conclude anything of how it might behave. But it's reasonably possible that you remembered the lean3 application of <code>linarith</code></p>\n<p>RM: Even with transparency enabled <code>linarith!</code> (lean4), it does not invoke ζ-reduction and does not unfold let binding</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">linarith!</span><span class=\"w\">     </span><span class=\"c1\">--linarith still failed to find a contradiction</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>\n<p>But in practice, we may as well resort to <code>aesop?</code></p>",
        "id": 564867055,
        "sender_full_name": "Fengyang Wang",
        "timestamp": 1766286024
    },
    {
        "content": "<p>A general workaround is the tactic <code>set</code>. Usage: <code>set a := t with h</code> gives <code>a</code> let-bound to <code>t</code> with <code>h : a = t</code>. <code>set</code> also automatically rewrites all occurences of <code>t</code> in the context into <code>a</code>.</p>",
        "id": 564903041,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766334710
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400289\">@Artie Khovanov</span> <code>let (eq := h) a := t</code> gives you that <code>h : a = t</code> (I think this was released 6mo ago or so)</p>",
        "id": 564903138,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1766334836
    },
    {
        "content": "<p>Oh nice, wasn't aware! Is this in core?</p>",
        "id": 564903183,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1766334872
    },
    {
        "content": "<p>Yep!</p>",
        "id": 564903355,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1766335095
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"453098\">@Dan Velleman</span> One piece of the puzzle here seems to be that it's specific to Nat. It succeeds if you use Int (or other rings):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 564903362,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1766335121
    },
    {
        "content": "<p>I haven't checked changes to <code>linarith</code>, but it seems like it has something to do with the order in which it decides on what the atoms are vs when it coerces everything to <code>Int</code></p>",
        "id": 564903401,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1766335165
    },
    {
        "content": "<p>Do you specifically want this to work with <code>Nat</code>?</p>",
        "id": 564903407,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1766335185
    },
    {
        "content": "<p><code>lia</code> works. Isn't <code>linarith</code> going to be depracated in favor of <code>lia</code>?</p>",
        "id": 564906958,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766340034
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> My interest in Lean is primarily for education.  I don't think this is very important, but if a student stumbled over this I think they would find it confusing.  And I wouldn't want to have to give an explanation about identifying atoms and coercing to <code>Int</code>.</p>",
        "id": 564907251,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1766340304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/287929-mathlib4/topic/linarith.20and.20let/near/564906958\">said</a>:</p>\n<blockquote>\n<p><code>lia</code> works. Isn't <code>linarith</code> going to be depracated in favor of <code>lia</code>?</p>\n</blockquote>\n<p>no, <code>lia</code> only does linear <em>integer</em> arithmetic, but <code>linarith</code> does linear arithmetic in any linearly ordered ring</p>",
        "id": 564907313,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766340376
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"453098\">@Dan Velleman</span> That's fair — and I my little digging into atoms and coercions is just meant to be a hint for whoever wants to try digging deeper into this.</p>\n<p>My feeling is that <code>linarith</code> ought to add equalities for each of the <code>let</code> bindings in scope. Or I guess it could zeta reduce every relevant <code>let</code> binding first. There doesn't seem to be any obvious, reliable way to fix this through tweaks of just the Nat-&gt;Int coercion preprocessor.</p>\n<p>Worst case, you can explain to students that <code>linarith</code> is unreliable for natural numbers, since it's for linear arithmetic, and Nat doesn't have negatives. It doesn't seem necessary to get into the weeds of atoms and coercions to explain why it works only sometimes for Nat. (I get it though that then this takes explaining that <code>Nat</code> isn't a subset of <code>Int</code>.)</p>",
        "id": 564907947,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1766341176
    }
]