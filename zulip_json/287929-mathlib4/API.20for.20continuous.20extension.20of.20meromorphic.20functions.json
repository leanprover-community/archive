[
    {
        "content": "<p>Dear all,</p>\n<p>as part of the ongoing <a href=\"https://github.com/kebekus/ProjectVD\">project to formalize value distribution theory</a>, I would like to add definitions/API for continuous extension of meromorphic functions to mathlib. I see various ways to do that and would like to ask your opinion before prematurely finalizing anything and then running into trouble. </p>\n<p><span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span> <span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> I'd love your feedback since you have worked with analytic and meromorphic functions. </p>\n<p>Best wishes,</p>\n<p>Stefan</p>\n<hr>\n<p>In detail: I would like to say that a function is \"continuously extended meromorphic at <code>z‚ÇÄ</code>\" if it is locally zero, or if it looks like <code>(z - z‚ÇÄ) ^ n ‚Ä¢ g</code>, where <code>g</code> is analytic and does not vanish at <code>z‚ÇÄ</code>. This is a bit of a misnomer because it does not only require that the function is analytic at all resolvable singularities, but also imposes that it takes the default value <code>0 </code> wherever it has a pole; this will make the API a lot more convenient. My plan is to define this as follows,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">CEMeromorphicAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z‚ÇÄ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=·∂†</span><span class=\"o\">[</span><span class=\"n\">ùìù</span><span class=\"w\"> </span><span class=\"n\">z‚ÇÄ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñ§</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AnalyticAt</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">z‚ÇÄ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">z‚ÇÄ</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=·∂†</span><span class=\"o\">[</span><span class=\"n\">ùìù</span><span class=\"w\"> </span><span class=\"n\">z‚ÇÄ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">z‚ÇÄ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>then </p>\n<ul>\n<li>Prove that <code>CEMeromorphicAt</code> implies <code>MeromorphicAt</code> and establish a coercion</li>\n<li>Provide API to use <code>CEMeromorphicAt</code>, similar to what we have for analytic functions.</li>\n<li>Show that meromorphic functions can be made <code>CEMeromorphicAt</code> by updating their value at  <code>z‚ÇÄ</code></li>\n<li>Do the same with <code>CEMeromorphicOn</code>, showing that meromorphic functions can be made <code>CEMeromorphicOn</code> by changing their values along sets that are no worse than discrete within their domain of meromorphy</li>\n</ul>",
        "id": 498694708,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1739175875
    },
    {
        "content": "<p>Are you sure this is a good concept? What bothers me is that the sum of two <code>CEMeromorphic</code> functions is in general not <code>CEMeromorphic</code> (take <code>1/z + 1</code> at <code>0</code>), and same thing for the product (take <code>1/z * z</code>).</p>",
        "id": 498700320,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1739177547
    },
    {
        "content": "<p>Yes, I was just about to post the same remark. Of course , if <code>f, g</code> are CEMeromorphic, there's a unique <code>h</code> which is <code>CEMeromorphicAt z</code> and agrees with <code>f + g</code> almost everywhere, but you need to know <code>f</code> and <code>g</code> on a whole neighbourhood of <code>z</code> to determine <code>h z</code>.</p>",
        "id": 498700420,
        "sender_full_name": "David Loeffler",
        "timestamp": 1739177581
    },
    {
        "content": "<p>I've not worked with L^p spaces in mathlib, but maybe we can learn from what's done there. Because there the lesson is that it is convenient to work with actual functions, and almost-everywhere equality.<br>\nSo maybe we want something like <code>AEMeromorphic</code> for functions that are almost everywhere meromorphic, except for a discrete set of points where they do something wacky. (And also the <code>At</code>, <code>Within</code> variants.)<br>\nThat notion should be stable under algebraic operations.</p>\n<p>Of course, evaluation such a function at a point will sometimes not give you the \"correct\" value. So there should be some API that \"course corrects\".</p>",
        "id": 498708189,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1739179701
    },
    {
        "content": "<p>Our current notion of <code>Meromorphic</code> is pretty much your <code>AEMeromorphic</code> ‚Äì¬†it is insensitive to modifying the function on a discrete set.</p>",
        "id": 498709562,
        "sender_full_name": "David Loeffler",
        "timestamp": 1739180018
    },
    {
        "content": "<p>The difference with Lp spaces is that there is genuinely no hope of selecting a \"best\" representative of an ae-equivalence class of measurable functions; while there is a reasonably sensible candidate for a representative of an equiv class of AEMeromorphic functions up to equality on a codiscrete set ‚Äì namely Stefan's idea of filling in the gaps by continuity when that works, and by 0 otherwise.</p>",
        "id": 498711523,
        "sender_full_name": "David Loeffler",
        "timestamp": 1739180519
    },
    {
        "content": "<p>Thanks for all your thoughtful comments, I greatly appreciate. Let me answer to the concerns of <span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> and <span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span> and explain my reasoning. Maybe someone (perhaps with more formalization experience) has better ideas. I am looking forward to your feedback!</p>\n<p><strong>Conceptually Right?</strong> The observation of <span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> and <span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span> is definitely correct and the concerns are justified. I guess what's going on here is this: we have meromorphic functions on a set <code>U</code> and the equivalence relation <code>=·∂†[Filter.codiscreteWithin U]</code>. The quotient map is a map of rings (or more precisely: algebras over the sheaf of analytic functions). What I (would like to|need to) do is to define a section, by picking the 'obviously best' representative from each class. I believe that the examples of <span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span>  show that <strong>no section can ever be a ring morphism</strong>. Independent of the implementation details and the precise definition of 'obviously best', we will never get commutativity of continous extension with addition/multipliciation.</p>\n<p><strong>Should we then even have continuous extension in mathlib?</strong> I believe that continuous extension will be useful, complex analysis uses the operation implicitly nearly in every step of every argument. Example: given a meromorphic <code>f</code> defined on a compact <code>U</code>, the <a href=\"https://en.wikipedia.org/wiki/Jensen's_formula\">textbook proofs of Jensen's formula</a> start by writing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>z</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mi>z</mi><mo stretchy=\"false\">)</mo><mo>‚àó</mo><msub><mo>‚àè</mo><mrow><msub><mi>z</mi><mn>0</mn></msub><mo>‚àà</mo><mi>U</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>z</mi><mo>‚àí</mo><msub><mi>z</mi><mn>0</mn></msub><msup><mo stretchy=\"false\">)</mo><mrow><msub><mrow><mi mathvariant=\"normal\">order</mi><mo>‚Å°</mo></mrow><msub><mi>z</mi><mn>0</mn></msub></msub><mi>f</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">f(z) = g(z) * \\prod_{z_0 \\in U} (z - z_0)^{\\operatorname{order}_{z_0} f}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àó</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1498em;vertical-align:-0.3998em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">‚àè</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.04398em;\">z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:-0.044em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mrel mtight\">‚àà</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">U</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3998em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0991em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.044em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mop mtight\"><span class=\"mop mtight\"><span class=\"mord mathrm mtight\">order</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1645em;\"><span style=\"top:-2.357em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.04398em;\">z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3448em;margin-left:-0.044em;margin-right:0.1em;\"><span class=\"pstrut\" style=\"height:2.6444em;\"></span><span class=\"mord mtight\">0</span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2996em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.357em;\"><span></span></span></span></span></span></span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span></span></span></span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> is analytic without zeros on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span>. In lean, we need to be more precise and replace equality by <code>=·∂†[Filter.codiscreteWithin U]</code> of course. How do I define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> in lean? Easy: take the continuous extension of  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>z</mi><mo stretchy=\"false\">)</mo><mo>‚àó</mo><msub><mo>‚àè</mo><mrow><msub><mi>z</mi><mn>0</mn></msub><mo>‚àà</mo><mi>U</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>z</mi><mo>‚àí</mo><msub><mi>z</mi><mn>0</mn></msub><msup><mo stretchy=\"false\">)</mo><mrow><mo>‚àí</mo><msub><mrow><mi mathvariant=\"normal\">order</mi><mo>‚Å°</mo></mrow><msub><mi>z</mi><mn>0</mn></msub></msub><mi>f</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">f(z) * \\prod_{z_0 \\in U} (z - z_0)^{-\\operatorname{order}_{z_0} f}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àó</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1498em;vertical-align:-0.3998em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">‚àè</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.04398em;\">z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:-0.044em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mrel mtight\">‚àà</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">U</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3998em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0991em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.044em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">‚àí</span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mop mtight\"><span class=\"mop mtight\"><span class=\"mord mathrm mtight\">order</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1645em;\"><span style=\"top:-2.357em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.04398em;\">z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3448em;margin-left:-0.044em;margin-right:0.1em;\"><span class=\"pstrut\" style=\"height:2.6444em;\"></span><span class=\"mord mtight\">0</span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2996em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.357em;\"><span></span></span></span></span></span></span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span></span></span></span></span></span></span></span>, done. In <a href=\"https://github.com/kebekus/ProjectVD\">Project VD</a> I need to do this all the time.</p>\n<p><strong>Sane API?</strong> You can argue. I also considered a few alternative options but did eventually settle on the one I proposed. Maybe you have/someone here has better ideas, and I'd be more than glad to hear them.</p>\n<ul>\n<li>Make <code>CEMeromorphicAt</code> an attribute of <code>MeromorphicAt</code> instead of a stand-alone definition. There might be a case for that. I did not pursue this idea because the definition of the attribute <code>CEMeromorphicAt</code> does not refer to the property <code>MeromorphicAt</code> that it describes. That looks quite odd to me.</li>\n<li>Make <code>CEMeromorphicAt</code> an attribute of <code>Function</code> then? Again, there might be a case for that, but mathlib does not seem to do that for any of the other attributes.</li>\n<li>Drop the idea of a definition and simply define \"continuous extension\" as a map from meromorphic functions to meromorphic functions, then state properties of the map. Now this seems reasonable and doable. If you prefer, I could go for that. But then, there will be dozens of theorems about to the output of the continuous extension map, and I need to repeat the relevant properties every time ... that prompted me to isolate the defintion <code>CEMeromorphicAt</code> so I can refer to it instead of repeating it.</li>\n</ul>",
        "id": 498837051,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1739213304
    },
    {
        "content": "<blockquote>\n<p>We have meromorphic functions on a set¬†<code>U</code>¬†and the equivalence relation¬†<code>=·∂†[Filter.codiscreteWithin U]</code>. The quotient map is a map of rings (or more precisely: algebras over the sheaf of analytic functions).</p>\n</blockquote>\n<p>This assertion ‚Äì including the implicit claim that the ring operations on the quotient are well-defined ‚Äì would be a very nice thing to have in mathlib. (In fact I was vaguely planning to do this myself, and when I originally PR'ed the codiscrete filter it was with this application specifically in mind, but I somehow never got around to it <span aria-label=\"embarrassed\" class=\"emoji emoji-1f633\" role=\"img\" title=\"embarrassed\">:embarrassed:</span>)</p>\n<blockquote>\n<p>What I (would like to|need to) do is to define a section, by picking the 'obviously best' representative from each class.</p>\n</blockquote>\n<p>I agree this would be worthwhile ‚Äì¬†both the section map, and the predicate on functions saying \"this function is the best representative of its equiv class\" (your <code>CEMeromorphic</code>). I'm not 100% sure about the <em>name</em>, since \"continuously extended meromorphic\" somehow suggests it should always be continuous and it isn't, but I don't have a better suggestion to offer.</p>",
        "id": 498846294,
        "sender_full_name": "David Loeffler",
        "timestamp": 1739216119
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span> Thanks for your quick answer. I share your unease with the name and would welcome any suggestion...</p>",
        "id": 498846943,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1739216337
    },
    {
        "content": "<p>Maybe the name of the section can be something like <code>meromorphicRepr</code>, indicating that it is a <em>suitably chosen</em> representative?</p>",
        "id": 498928691,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1739249927
    },
    {
        "content": "<p>How about <code>NormalFormMeromorphicAt</code>, and then with a function <code>MeromorphicAt.toNormalForm</code>? Perhaps shorter as <code>NFMeromorphic</code>?</p>",
        "id": 498933188,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1739252804
    },
    {
        "content": "<p>Sounds good to me. And I think the shorter <code>NF</code> variant is better, in order to keep the names reasonably short.</p>",
        "id": 498938177,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1739255758
    },
    {
        "content": "<p>I would rather name them <code>MeromorphicNFAt</code> and <code>MeromorphicAt.meromorphicNFAt</code>, but it's marginal</p>",
        "id": 498938384,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1739255876
    },
    {
        "content": "<p>Very well, I will implement <code>MeromorphicNFAt</code> then. This will take me a few days because I have guests at the institute this week and next. </p>\n<p>Looking forward to meeting you in the PR channel then. Best wishes, and thanks for your help!</p>",
        "id": 499021403,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1739283918
    },
    {
        "content": "<p>I have prepared a first PR, which will come online as soon as <a href=\"https://github.com/leanprover-community/mathlib4/pull/21502\">PR #21502</a> is reviewed and merged. I am wondering if we should have a coercion/automatic conversion from <code>MeromorphicNFAt</code> to <code>MeromorphicAt</code>. Right now there is only a theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- If a function is meromorphic in normal form at `x`, then it is meromorphic at `x`. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MeromorphicNFAt</span><span class=\"bp\">.</span><span class=\"n\">meromorphicAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeromorphicNFAt</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">MeromorphicAt</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I think an automatation can save users a lot of typing, but then I am not sure how to do that or if there are good reasons for not having it. Any help is greatly welcome.</p>",
        "id": 499652277,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1739514697
    },
    {
        "content": "<p>Thanks again to everyone involved. The implementation of <code>MeromorphicNFAt</code> is now available as <a href=\"https://github.com/leanprover-community/mathlib4/pull/22867\">PR #22867</a>.</p>",
        "id": 505072389,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1741771388
    },
    {
        "content": "<p>The second batch of theorems on <code>MeromorphicNFAt</code> has arrived in <a href=\"https://github.com/leanprover-community/mathlib4/pull/23005\">PR #23005</a>. The PR re-installs a theorem <code>AnalyticAt.eventuallyEq_nhdNE_iff_eventuallyEq_nhd</code> previously criticized by reviewers. It adds an analogous theorem <code>MeromorphicNFAt.eventuallyEq_nhdNE_iff_eventuallyEq_nhd</code> for meromorphic functions in normal form which, by transitivity, might be just as bad.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">AnalyticAt</span><span class=\"bp\">.</span><span class=\"n\">eventuallyEq_nhdNE_iff_eventuallyEq_nhd</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AnalyticAt</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">z‚ÇÄ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AnalyticAt</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">z‚ÇÄ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=·∂†</span><span class=\"o\">[</span><span class=\"n\">ùìù</span><span class=\"o\">[</span><span class=\"bp\">‚â†</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">z‚ÇÄ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=·∂†</span><span class=\"o\">[</span><span class=\"n\">ùìù</span><span class=\"w\"> </span><span class=\"n\">z‚ÇÄ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MeromorphicNFAt</span><span class=\"bp\">.</span><span class=\"n\">eventuallyEq_nhdNE_iff_eventuallyEq_nhd</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeromorphicNFAt</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">z‚ÇÄ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeromorphicNFAt</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">z‚ÇÄ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=·∂†</span><span class=\"o\">[</span><span class=\"n\">ùìù</span><span class=\"o\">[</span><span class=\"bp\">‚â†</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">z‚ÇÄ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=·∂†</span><span class=\"o\">[</span><span class=\"n\">ùìù</span><span class=\"w\"> </span><span class=\"n\">z‚ÇÄ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The reason for bringing these theorems back is that I use them in several places throughout <a href=\"https://github.com/kebekus/ProjectVD\">Project VD</a>, which makes it difficult for me to hide them with a <code>private</code> label. One might argue that <code>MeromorphicNFAt.eventuallyEq_nhdNE_iff_eventuallyEq_nhd</code> is what justifies the existence of the notion in the first place.</p>\n<p>I have downgraded the PR to draft status and would like to ask your advice on how to handle this. Maybe there is a reformulation that is just as useful und more agreeable?</p>\n<p><span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> <span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Since you have been involved in the first PR, I would love to hear your opinion. Thank you in advance!</p>",
        "id": 506121505,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1742210762
    },
    {
        "content": "<p>FYI you can type <code>#23005</code> on Zulip and it will display as <a href=\"https://github.com/leanprover-community/mathlib4/pull/23005\">#23005</a></p>",
        "id": 506121906,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1742210868
    },
    {
        "content": "<p>Ah! Now that will save me a lot of typing. Thanks.</p>",
        "id": 506122057,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1742210896
    }
]