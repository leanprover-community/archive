[
    {
        "content": "<p>in discord, a question came up about tetration, where the OP defined it as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">tetration</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HomogeneousPow</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tetration</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>although the definition compiles, it is not useful at all, since the only instance for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HomogeneousPow#doc\">docs#HomogeneousPow</a> is for <code>Float</code>, rather than also for <code>Nat</code>, <code>Real</code>, and maybe <code>Complex</code>. do we want to have these instances? or maybe should we prefer to have <code>HomogeneousPow α</code> reduce to <code>Pow α α</code> or something like that?</p>",
        "id": 490500752,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734952805
    },
    {
        "content": "<p>small bits of context: right now, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HPow#doc\">docs#HPow</a> , <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Pow#doc\">docs#Pow</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HomogeneousPow#doc\">docs#HomogeneousPow</a> are all separate one-field classes (yes, they don't extend eachother) and have instances in the sensible direction, but there are no instances or anything to turn <code>HPow a b a</code> into <code>Pow a b</code> or <code>Pow a a</code> into <code>HomogeneousPow a</code></p>",
        "id": 490502346,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734953490
    },
    {
        "content": "<p>I think this might just be a notation implementation detail (cc <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>), and for the definition above you should just use <code>Pow α α</code></p>",
        "id": 490503605,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734954014
    },
    {
        "content": "<p>as far as i can tell, <code>HPow</code> is the only notation class among them, since <code>b ^ a</code> <a href=\"https://github.com/leanprover/lean4/blob/ffac974dba799956a97d63ffcb13a774f700149c/src/Init/Notation.lean#L287C1-L288C1\">means</a> <a href=\"https://github.com/leanprover/lean4/blob/ffac974dba799956a97d63ffcb13a774f700149c/src/Init/Notation.lean#L305\"><code>HPow.hpow b a</code></a></p>",
        "id": 490506806,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734955349
    },
    {
        "content": "<p>Right, but I think this plays a part in the custom elaborator that implements that notation</p>",
        "id": 490507109,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734955507
    },
    {
        "content": "<p>you mean the <code>rightact%</code> elaborator?</p>",
        "id": 490507261,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734955567
    },
    {
        "content": "<p><del>i can't seem to find source code for that elaborator, is it built in?</del> <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Extra.lean\">found it</a></p>",
        "id": 490507547,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734955684
    },
    {
        "content": "<p>as far as i can tell, there is no mention of <code>Pow</code> or <code>HomogeneousPow</code> there...</p>",
        "id": 490508298,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734956042
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/2854\">lean4#2854</a> has some context</p>",
        "id": 490508659,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734956194
    },
    {
        "content": "<p>so, if i'm reading this right, you're correct in saying that <code>HomogeneousPow</code> (and as it turns out <code>NatPow</code> as well) are implementation details...</p>\n<blockquote>\n<p>Both <code>NatPow</code> and <code>HomogeneousPow</code> provide a default <code>Pow</code> instance, and types can choose to implement an instance for one of these two depending on whether they would prefer the exponent to default to being a <code>Nat</code> or to the base's type</p>\n</blockquote>",
        "id": 490509247,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734956463
    },
    {
        "content": "<p><del>i suppose it would be useful if these get marked as such?</del> they are, but apparently not clearly enough</p>",
        "id": 490510229,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734956916
    },
    {
        "content": "<p>would the docs be improved if it were to explicitly say \"this class should not be used as an argument\"?</p>",
        "id": 490510658,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734957107
    },
    {
        "content": "<p>I think \"prefer writing <code>[Pow A A]</code> to <code>[HomogeneousPow A]</code> in argument lists\" would be clearer</p>",
        "id": 490512799,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734958049
    },
    {
        "content": "<p>It should be HPow in argument lists, since HPow does not provide Pow instances.</p>",
        "id": 490579602,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734986097
    },
    {
        "content": "<p>I would not say NatPow or HomogeneousPow are implementation details — they're intended to be used by users to specify how the exponentiation should elaborate by default.</p>",
        "id": 490579873,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734986226
    },
    {
        "content": "<p>Is there a reason to distinguish between <code>Pow A B</code> and <code>HPow A B A</code>?</p>",
        "id": 490580176,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734986374
    },
    {
        "content": "<p>In what sense?</p>",
        "id": 490580787,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734986670
    },
    {
        "content": "<p>For writing instances? Probably not. For argument lists? Yes, because <code>HPow</code> does not provide <code>Pow</code> instances.</p>",
        "id": 490580867,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734986708
    },
    {
        "content": "<p>From a design POV, what is wrong with having <code>abbrev Pow (A : Type*) (B : Type*) := HPow A B A</code>?</p>",
        "id": 490581191,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734986865
    }
]