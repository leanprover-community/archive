[
    {
        "content": "<p>While we have the oriented version of this lemma in mathlib, we don't have the unoriented one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Geometry</span><span class=\"bp\">.</span><span class=\"n\">Euclidean</span><span class=\"bp\">.</span><span class=\"n\">Altitude</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Geometry</span><span class=\"bp\">.</span><span class=\"n\">Euclidean</span><span class=\"bp\">.</span><span class=\"n\">Angle</span><span class=\"bp\">.</span><span class=\"n\">Sphere</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Geometry</span><span class=\"bp\">.</span><span class=\"n\">Euclidean</span><span class=\"bp\">.</span><span class=\"n\">Simplex</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Geometry</span><span class=\"bp\">.</span><span class=\"n\">Euclidean</span><span class=\"bp\">.</span><span class=\"n\">Sphere</span><span class=\"bp\">.</span><span class=\"n\">SecondInter</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Affine</span><span class=\"w\"> </span><span class=\"n\">EuclideanGeometry</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Real</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MetricSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddTorsor</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">yyy</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ABC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Triangle</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hA</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ABC</span><span class=\"bp\">.</span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ABC</span><span class=\"bp\">.</span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ABC</span><span class=\"bp\">.</span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">π</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ABC</span><span class=\"bp\">.</span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ABC</span><span class=\"bp\">.</span><span class=\"n\">circumcenter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ABC</span><span class=\"bp\">.</span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">∠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ABC</span><span class=\"bp\">.</span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ABC</span><span class=\"bp\">.</span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ABC</span><span class=\"bp\">.</span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>How can this be proved?</p>",
        "id": 519528081,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1747806940
    },
    {
        "content": "<p>Start by adding lemmas to transfer <code>circumsphere</code>, <code>circumcenter</code> and <code>circumradius</code> across isometries, and in particular across the coercion from an affine subspace to the full space. (We already have those for unoriented angles: <code>AffineIsometry.angle_map</code> and <code>AffineSubspace.angle_coe</code>. But lots of geometrical definitions don't have such lemmas at present.) Then you can move to a two-dimensional subspace spanned by the three points, choose an arbitrary orientation, and use the oriented angle result to deduce the unoriented angle one via existing lemmas relating oriented and unoriented angles. (To use this technique for some results you may also need to use lemmas showing that certain pairs of oriented angles have the same sign; we have plenty of those as well.)</p>\n<p>(In principle the lemmas to transfer across isometries could actually apply to any <code>DilationClass</code>, when transferring <code>circumcenter</code>, while <code>circumradius</code> would scale by the ratio of a dilation. But things could probably be done initially for the <code>AffineIsometry</code> and coercion cases and generalized later to cover dilations.)</p>",
        "id": 519585397,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1747826281
    },
    {
        "content": "<p>This probably also needs a <code>def</code> for mapping a <code>Simplex</code> under an injective affine map, from which the particular case of mapping it from a subspace to the full space can be constructed.</p>",
        "id": 519585856,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1747826416
    },
    {
        "content": "<p>Probably a tactic could be written to automate \"move to a two-dimensional subspace and pick an orientation\", once all the relevant lemmas are present, but I expect lots of such proofs need to be written manually before it's clear exactly what such a tactic should look like.</p>",
        "id": 519586277,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1747826573
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Unoriented.20version.20of.20the.20circumcircle.20angle.20theorem/near/519585856\">said</a>:</p>\n<blockquote>\n<p>This probably also needs a <code>def</code> for mapping a <code>Simplex</code> under an injective affine map, from which the particular case of mapping it from a subspace to the full space can be constructed.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/25156\">#25156</a></p>",
        "id": 520212793,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748105365
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/25172\">#25172</a> adds the restriction of a simplex to a subspace</p>",
        "id": 520246472,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748136651
    }
]