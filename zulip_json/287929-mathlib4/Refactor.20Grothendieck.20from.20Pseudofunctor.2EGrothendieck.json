[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776892\">@Yiming Xu</span> and I would like to make a PR to mathlib unifying the two existing Grothendieck constructions in mathlib. More precisely</p>\n<ul>\n<li><code>CategoryTheory.Grothendieck</code> defines the Grothendieck construction on a 1-functor into <code>Cat</code></li>\n<li>Separately <code>CategoryTheory.Pseudofunctor.Grothendieck</code> defines the Grothendieck construction on a pseudofunctor from a <code>LocallyDiscrete</code> bicategory (i.e. a 1-category promoted to a bicategory) into <code>Cat</code>.</li>\n<li>I would like to refactor the former through the latter, except also I need to redefine the latter, as it puts an \"op\" on the source of the pseudofunctor.</li>\n</ul>\n<p>Comments and ideas welcome!</p>",
        "id": 529165679,
        "sender_full_name": "joseph hua",
        "timestamp": 1752699288
    },
    {
        "content": "<p>Should I first make PRs that only add the new definitions and associated lemmas, without removing the old definition? I know the convention is to make small PRs</p>",
        "id": 529167135,
        "sender_full_name": "joseph hua",
        "timestamp": 1752699949
    },
    {
        "content": "<p>I am not completely sure we want to remove the <code>op</code> in the definition of the Grothendieck construction of a pseudofunctor. Before proceeding, I would think we should ask <span class=\"user-mention\" data-user-id=\"132603\">@Calle Sönne</span>.</p>",
        "id": 529169465,
        "sender_full_name": "Joël Riou",
        "timestamp": 1752701094
    },
    {
        "content": "<p>To me, it seems fine to remove the <code>op</code>. However, as for certain use cases we need the <code>op</code> this refactor should provide good API / results to recover the current definition easily.</p>",
        "id": 529171469,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1752702230
    },
    {
        "content": "<p>Maybe to start with let's have both definitions, then once we are convinced that it is easy to work with the <code>op</code> version on top of the non-<code>op</code> version we can replace it.</p>",
        "id": 529171817,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1752702437
    },
    {
        "content": "<p>Here are two possible approaches:</p>\n<ol>\n<li>(not defeq) Leave the definition <code>CatgoryTheory.Grothendieck</code> and define an equivalence between <code>F.Grothendieck</code> and <code>F.toPseudofunctor'.Pseudofunctor.Grothendieck</code> for a 1-functor <code>F</code></li>\n<li>(defeq) Redefine <code>F.Grothendieck</code> as <code>F.toPseudofunctor'.Pseudofunctor.Grothendieck</code></li>\n</ol>\n<p>In both approaches we basically need to define everything twice, which is fine. The main downside of 1 is that we need to prove coherence lemmas for the equivalence. The main downside of 2 is that <code>@[simp!]</code> produces lemmas that are not in the best form for 1-categorical reasoning. I would like to not leak the 2-categorical definition if we use that under the hood. I am currently going with approach 2. Any suggestions on this?</p>",
        "id": 529330257,
        "sender_full_name": "joseph hua",
        "timestamp": 1752774974
    },
    {
        "content": "<p>I am actually not so familiar with the 1-categorical construction. Is it common to only want to talk about this in a 1-categorical framework (I assume yes since you are interested in bridging these two)? My possibly false assumption from before was that we only had it because the bicategory library was not developed enough.</p>",
        "id": 529469677,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1752847546
    },
    {
        "content": "<p>I always understood that the Grothendieck construction was useful for 2 (related) reasons:</p>\n<ul>\n<li>It allows you to construct pseudofunctors without checking all the coherence conditions, instead you only have to construct some fibered category which is a 1-categorical notion.</li>\n<li>It allows you to talk about things that should be pseudofunctors without worrying about bicategories</li>\n</ul>\n<p>So what is the interest in this construction in the 1-categorical setting? The two points above no longer apply since functors are quite simple in comparison.</p>\n<p>(this is coming from someone who just knows about these things from the point of view of stacks)</p>",
        "id": 529470666,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1752847826
    },
    {
        "content": "<p>I am also asking these things to better understand the use case, so I can know which of the two options above would be better</p>",
        "id": 529470944,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1752847912
    },
    {
        "content": "<p>So firstly, I guess you are convinced that IF there is an application of the 1-categorical version, then we should have API for both versions. My reason for believing this is that, although the 2-cells are kind of still hanging about, it is still much easier to work with the 1-categorical construction. Having worked on both the last couple of days, I'm more confident that this is true.</p>\n<p>As for applications: <br>\nThe Grothendieck construction on a 1-functor <code>F : C -&gt; Cat</code> is an explicit construction of the pullback of the \"universal (something) fibration\", which is the forgetful functor from <code>PCat</code>, the category of pointed categories (homs preserve the point only up to iso) to <code>Cat</code>.</p>\n<p>Specifically for my use case, <code>PCat</code> can be used to model a universe for dependent type theory, and the Grothendieck construction can be used to model (coherent) context extension. (Coherent means that we are relying on an explicit construction that satisfies some naturality, rather than just picking a pullback using choice.) I'm not sure about other applications of the pullback result.</p>\n<p>For context, this is for the <a href=\"https://sinhp.github.io/groupoid_model_in_lean4/\">HoTTLean</a> project</p>",
        "id": 529478985,
        "sender_full_name": "joseph hua",
        "timestamp": 1752850844
    },
    {
        "content": "<p>By the way, the pullback result is really evil, and may be something mathlib would not accept - I don't know what the consensus on this is right now. It is treating <code>Cat</code> as an object in the 1-category of categories. An equality between maps in the pullback diagram is an equality between functors with codomain <code>Cat</code></p>",
        "id": 529480190,
        "sender_full_name": "joseph hua",
        "timestamp": 1752851258
    },
    {
        "content": "<p>Side note on the last comment: every 1-pullback in <code>Cat</code> is also a 2-pullback; so it doesn't seem that evil to me. Though I agree that the result in the last sentence is indeed \"evil\".</p>",
        "id": 529492589,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752855668
    },
    {
        "content": "<p>Nice to see you here <span class=\"user-mention\" data-user-id=\"587858\">@Fernando Chu</span> <span aria-label=\"smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 529493000,
        "sender_full_name": "joseph hua",
        "timestamp": 1752855827
    },
    {
        "content": "<p>Same! :D</p>",
        "id": 529493968,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752856272
    },
    {
        "content": "<p>Oh and for further context, for a specific definition I wanted to make, I needed the result that a pseudonatural transformation between two 1-functors into <code>Cat</code> induces a functor between their Grothendieck constructions, which is a direct result of <code>Pseudofunctor.Grothendieck.map</code></p>",
        "id": 529498638,
        "sender_full_name": "joseph hua",
        "timestamp": 1752858381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"587858\">Fernando Chu</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Refactor.20Grothendieck.20from.20Pseudofunctor.2EGrothendieck/near/529492589\">said</a>:</p>\n<blockquote>\n<p>Side note on the last comment: every 1-pullback in <code>Cat</code> is also a 2-pullback; so it doesn't seem that evil to me. Though I agree that the result in the last sentence is indeed \"evil\".</p>\n</blockquote>\n<p>I thought that's only true if one of the functor is an isofibration? At least, I'm pretty sure the 1-pullback of the two (unique) functors <code>* -&gt; BG</code> is not a 2-pullback.<br>\nIn the case of the universal Grothendieck construction of the identity functor (so, <code>PCat</code> to <code>Cat</code>), it's true though.</p>",
        "id": 529510289,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1752863899
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> my claim comes from <a href=\"https://categorytheory.zulipchat.com/#narrow/channel/229199-learning.3A-questions/topic/.E2.9C.94.201-limits.20are.202-limits.20in.20an.20.28op.29representable.20category\">here</a>, maybe I should clarify that by 2-pullback I mean strict 2-pullback, which is the right notion from the enriched category theory perspective (but the wrong one from the bicategory theory perspective).</p>",
        "id": 529514354,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752866130
    },
    {
        "content": "<p>Ok, then I understand the claim a bit more, though for \"non-evil\" things we want pullbacks in the bicategorical sense. Related: my PRs about what I call the \"Categorical pullback\" (i.e the actually bicategorical pullback) are getting merged, but I don't expect that this API can be used as it is for a nice claim about the Grothendieck construction (of pseudofunctors) being a pullback of a universal cocartesian fibration (which is what we would actually want here) for now.</p>",
        "id": 529515756,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1752866842
    },
    {
        "content": "<p>I have made an initial PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/27320\">here</a>, just changing the name of <code>Pseudofunctor.Grothendieck</code> to <code>Pseudofunctor.coGrothendieck</code>. Next I will add the new definition <code>Pseudofunctor.Grothendieck</code> with variance consistent with the 1-categorical version.</p>",
        "id": 531178728,
        "sender_full_name": "joseph hua",
        "timestamp": 1753636786
    },
    {
        "content": "<p>Hi folks, I have just updated the PR again because of a conflict. Would someone mind taking a minute to approve it? From Joel's comment it seems to be good to go.</p>",
        "id": 537298333,
        "sender_full_name": "joseph hua",
        "timestamp": 1756823030
    }
]