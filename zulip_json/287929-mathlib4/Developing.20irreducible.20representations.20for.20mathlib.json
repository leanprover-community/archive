[
    {
        "content": "<p>I am a math PhD student interested in developing the basic properties of irreducible and absolutely irreducible representations for mathlib, motivated by potential applications in the FLT project.</p>\n<p>Do I need to get preliminary approval for content/exact statements that I would like to add to mathlib? For example, let's say that I would like to make a PR which makes a definition of an (absolutely) irreducible representation and culminates with a proof that every absolutely irreducible representation of an abelian group is one-dimensional.</p>\n<p>Do I have to discuss beforehand in which generality should the theorem be stated? For example, instead of developing the theory of absolutely irreducible representations of a group, I could define absolutely simple modules over algebras over a field, and prove that an absolutely simple module over a commutative algebra over a field is one-dimensional. Maybe the results should be proven in an even broader context, which I cannot think of right now.</p>\n<p>Do I have to discuss beforehand which definitions to use? I couldn't help but notice that in ##Mathlib.RepresentationTheory.Character orthogonality relations are proved using <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Simple.html#CategoryTheory.Simple\">CategoryTheory.Simple</a> as a definition for an irreducible representation. Does this mean that mathlib prefers not to have a separate definition of an irreducible representation? In comparison, in the FLT project the irreducibility is defined separately as </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsIrreducible</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">irreducible</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSimpleOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subrepresentation</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Thank you in advance,<br>\nStepan</p>",
        "id": 563582882,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1765588906
    },
    {
        "content": "<p>It's generally good to discuss ahead of time if you're up for it!</p>",
        "id": 563582988,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765589055
    },
    {
        "content": "<p>The fact that Mathlib's representation theory currently uses <code>CategoryTheory.Simple</code> is a mistake (mine). While we should certain make the connections with category theory, and use it, and make it easier to use, we also need to make progress on representation theory and it is clear that the way forward is to make non-categorical definitions.</p>",
        "id": 563583037,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765589132
    },
    {
        "content": "<p>I see by looking at <a href=\"https://github.com/leanprover-community/mathlib4/commits/master/\">https://github.com/leanprover-community/mathlib4/commits/master/</a> that most commits to mathlib are generally pretty small (rarely exceeding a 100 lines of code). If that is the typical length of a mathlib PR, I could start, for example, by creating a file <code>Mathlib.RepresentationTheory.Irreducible</code>, and prove an equivalence between three definitions:</p>\n<ul>\n<li>The FLT project definition <code>IsSimpleOrder (Subrepresentation ρ)</code></li>\n<li><code>IsSimpleModule ρ.asModule</code></li>\n<li><code>CategoryTheory.Simple Rep.of ρ</code><br>\nIs this a good idea for a first mathlib PR and if so, are there any other equivalent definitions that should be included?</li>\n</ul>",
        "id": 563583591,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1765589784
    },
    {
        "content": "<p>This sounds very good to me!</p>",
        "id": 563583801,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765590051
    },
    {
        "content": "<p>And yes, please try to make fairly small PRs, especially when you're starting out. It makes review a lot smoother</p>",
        "id": 563615345,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1765627554
    },
    {
        "content": "<p>I have a question about homomorphisms of representations.<br>\nAs far as I can tell, currently the way to talk about a homomorphism from ρ to σ is to write<code>ρ.asModule →ₗ[k[G]] σ.asModule</code>. Is this intentional according to the Mathlib style, or would it be beneficial to set up separate notation for homomorphisms of representations?</p>",
        "id": 563640243,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1765652096
    },
    {
        "content": "<p>Ok I guess I underestimated how long the proof of <code>IsSimpleOrder (Subrepresentation ρ) ↔ * </code>IsSimpleModule ρ.asModule<code> would be. I proved it by constructing an order isomorphism </code>Subrepresentation ρ ≃o Submodule A[G] ρ.asModule` and that's already about a 100 lines.</p>",
        "id": 563648787,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1765663067
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/32856\">https://github.com/leanprover-community/mathlib4/pull/32856</a><br>\nCurrently my PR fails \"check the PR title format\":<br>\nfeat: definition of an irreducible representation</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:4:40\">https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:4:40</a></p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:4:41\">https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:4:41</a>error: failed to parse latest release tag</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:4:42\">https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:4:42</a>Error: Process completed with exit code 1.</p>\n<p>What did I do wrong?</p>",
        "id": 563648835,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1765663132
    },
    {
        "content": "<p>I think you can ignore that error; the other one is valid, though</p>",
        "id": 563649036,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1765663351
    },
    {
        "content": "<p>Ok I added docstrings</p>",
        "id": 563649897,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1765664461
    },
    {
        "content": "<p>Now it says <br>\nRun if [[ \"failure\" != \"success\" ]]; then</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:32:14\">https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:32:14</a>+ [[ failure != \\s\\u\\c\\c\\e\\s\\s ]]</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:32:15\">https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:32:15</a>Please run 'lake exe mk_all' to regenerate the import all files</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:32:16\">https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:32:16</a>+ echo 'Please run '\\''lake exe mk_all'\\'' to regenerate the import all files'</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:32:17\">https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:32:17</a>+ exit 1</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:32:18\">https://github.com/leanprover-community/mathlib4/actions/runs/20198356387/job/57985595813?pr=32856#step:32:18</a>Error: Process completed with exit code 1.</p>",
        "id": 563649913,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1765664479
    },
    {
        "content": "<p>Yes, please also run <code>lake exe mk_all</code> - new files need to be added to <code>Mathlib.lean</code>, and that tool will do it for you</p>",
        "id": 563649963,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1765664533
    },
    {
        "content": "<p>Alright all checks have passed!<br>\nThank you for the help :)</p>",
        "id": 563651605,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1765666740
    },
    {
        "content": "<p>I have extended the theory of irreducible representations and managed to prove the following result:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">one_dimensional_of_irreducible_of_abelian</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsIrreducible</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsAlgClosed</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsMulCommutative</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>I see that sometimes there are PRs in mathlib that depend on other PRs. Is this considered good practice to create chains of PRs like that or is it better to wait until my first PR is reviewed?</p>",
        "id": 564902342,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1766333837
    },
    {
        "content": "<p>It's fine to have PRs which depend on other PRs. Thanks for working on this!</p>",
        "id": 564902382,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1766333887
    },
    {
        "content": "<p>It does make me sad when we prove things about representations of groups that are true of representations of algebras...</p>",
        "id": 564920662,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1766359165
    },
    {
        "content": "<p>I am considering whether I should first PR this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsAlgClosed</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">one_dimensional_of_simple_of_commutative</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsMulCommutative</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsSimpleModule</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">rank</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>If I do, which directory does it go to? I think RepresentationTheory is specifically about representation of groups right now. In a new file in RingTheory/SimpleModule maybe?</p>",
        "id": 564923445,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1766363218
    },
    {
        "content": "<p>I think we shouldn't be shy about treating the representation theory of commutative algebras as part of RepresentationTheory/. Just make a new directory there?</p>",
        "id": 564926224,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1766367265
    },
    {
        "content": "<p>Ok I've just PRed the general algebra fact: <a href=\"https://github.com/leanprover-community/mathlib4/pull/33216\">https://github.com/leanprover-community/mathlib4/pull/33216</a></p>\n<p>It does give a mysterious error though:</p>\n<p>Run cd pr-branch</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/20450645550/job/58762751810?pr=33216#step:14:10\">https://github.com/leanprover-community/mathlib4/actions/runs/20450645550/job/58762751810?pr=33216#step:14:10</a>+ cd pr-branch</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/20450645550/job/58762751810?pr=33216#step:14:11\">https://github.com/leanprover-community/mathlib4/actions/runs/20450645550/job/58762751810?pr=33216#step:14:11</a>+ lake env</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/20450645550/job/58762751810?pr=33216#step:14:12\">https://github.com/leanprover-community/mathlib4/actions/runs/20450645550/job/58762751810?pr=33216#step:14:12</a>info: plausible: cloning <a href=\"https://github.com/leanprover-community/plausible\">https://github.com/leanprover-community/plausible</a></p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/20450645550/job/58762751810?pr=33216#step:14:13\">https://github.com/leanprover-community/mathlib4/actions/runs/20450645550/job/58762751810?pr=33216#step:14:13</a>error: external command 'git' exited with code 128</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/20450645550/job/58762751810?pr=33216#step:14:14\">https://github.com/leanprover-community/mathlib4/actions/runs/20450645550/job/58762751810?pr=33216#step:14:14</a>Error: Process completed with exit code 1.</p>",
        "id": 565095001,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1766461653
    },
    {
        "content": "<p>Doesn't sound like your fault, I restarted the job</p>",
        "id": 565143895,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1766491153
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Developing.20irreducible.20representations.20for.20mathlib/near/564926224\">said</a>:</p>\n<blockquote>\n<p>I think we shouldn't be shy about treating the representation theory of commutative algebras as part of RepresentationTheory/. Just make a new directory there?</p>\n</blockquote>\n<p>I am slightly hesitant about this. I think having a more clear cut line between top level folders is better and I wonder if we could come up with one here first?</p>",
        "id": 565215327,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1766525894
    },
    {
        "content": "<p>Is this PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/33802\">https://github.com/leanprover-community/mathlib4/pull/33802</a> set up correctly as a PR which depends on my two previous PRs?<br>\nI see that it includes (copies of) commits from both of them, but you can't tell at a glance that these are commits from different PRs, so it makes me worried</p>",
        "id": 567266972,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1767994994
    },
    {
        "content": "<p>No, you should edit the PR summary to follow the instructions in the comment:</p>\n<div class=\"codehilite\" data-code-language=\"Markdown\"><pre><span></span><code>If this PR depends on other PRs, please list them below this comment,\nusing the following format:\n<span class=\"k\">- [ ]</span> depends on: <span class=\"ni\">#abc</span> [optional extra text]\n<span class=\"k\">- [ ]</span> depends on: <span class=\"ni\">#xyz</span> [optional extra text]\n</code></pre></div>",
        "id": 567267310,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1767995166
    },
    {
        "content": "<p>Ok fixed it</p>",
        "id": 567267545,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1767995269
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/33221\">https://github.com/leanprover-community/mathlib4/pull/33221</a> I was asked to discuss on Zulip the naming of \"homomorphism between two representations\", which can either be called \"intertwining map\", or \"equivariant linear map\". How does this usually work, do people vote on this?</p>",
        "id": 568115625,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1768444612
    },
    {
        "content": "<p>On a related note, is it worth creating a special syntax for intertwining/equivariant maps, such as <code>(ρ →i[G] σ)</code> or  <code>(ρ →e[G] σ) </code>?</p>",
        "id": 568281375,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1768500383
    },
    {
        "content": "<p>I'm not objecting to <code>IntertwiningMap</code>, people mat complain that it's long but we have <code>ContinuousLinearMap</code> which is longer, and you only really type it in theorem names because we have notation. </p>\n<p>For notation, probably the notation needs to mention the ring as well as the group? Wait -- I guess both the ring and the group can be read off from the types of rho and sigma? So you could just have <code>ρ →ᵣ σ</code> for \"map of representations\"?</p>",
        "id": 568420511,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768565728
    },
    {
        "content": "<p>Are there subgroup restriction coercions on representations? If so, and if that operation is common in practice, we might want to keep the group in the notation.</p>",
        "id": 568474257,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1768580888
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Developing.20irreducible.20representations.20for.20mathlib/near/568474257\">said</a>:</p>\n<blockquote>\n<p>Are there subgroup restriction coercions on representations? If so, and if that operation is common in practice, we might want to keep the group in the notation.</p>\n</blockquote>\n<p>I don't think there are, might it be a good idea to add them?</p>",
        "id": 568480325,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1768582610
    },
    {
        "content": "<p>I don't know this part of the library sorry<br>\nI also don't know much rep theory, I only have a first course in it, so I don't know what sorts of constructions are common</p>",
        "id": 568481781,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1768583070
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/33802\">#33802</a>, the following question was brought up: mathlib already has an older spelling of Schur's lemma, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RepresentationTheory/FinGroupCharZero.html#FDRep.simple_iff_end_is_rank_one\">FDRep.simple_iff_end_is_rank_one</a>, which defines an irreducible representation as a simple object in the category of representations. I have developed a few PRs using an alternative definition of an irreducible representation, which I copied from the FLT project. <br>\nIn a subsequent PR, I could prove the equivalence of two definitions, and make the earlier API for irreducible representations available for FLT. However, it is a bit inelegant to have to juggle two definitions like that. It is worthwhile to attempt to refactor some parts of the library to use the FLT definition?</p>",
        "id": 570680203,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1769643793
    },
    {
        "content": "<p>I think we should proceed with <a href=\"https://github.com/leanprover-community/mathlib4/pull/33802\">#33802</a>, that the link to the category theory should be an equivalence between <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Representation.IsIrreducible#doc\">docs#Representation.IsIrreducible</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Simple#doc\">docs#CategoryTheory.Simple</a>, and that the results outside the category theory library should be stated using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Representation.IsIrreducible#doc\">docs#Representation.IsIrreducible</a> and not <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Simple#doc\">docs#CategoryTheory.Simple</a>.</p>\n<p>As to proofs of statements which do not use the language of category theory, I think we should use category theory results (porting their proofs on the fly via equivalences) only if it saves substantial work. This does mean that for easy results like Schur we'll have some proof duplication but I think this will make for a more maintainable library.</p>",
        "id": 570772619,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1769687174
    },
    {
        "content": "<p>We have followed this pattern elsewhere in the library. E.g., a recent case where I encountered it is demonstrated in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CommRingCat.epi_iff_epi#doc\">docs#CommRingCat.epi_iff_epi</a></p>",
        "id": 570773134,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1769687334
    },
    {
        "content": "<p>Should the references to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FDRep#doc\">docs#FDRep</a> in <a href=\"https://tqft.net/mathlib4files/Mathlib/RepresentationTheory/Character\">file#Mathlib/RepresentationTheory/Character</a> be replaced by an unbundled version then?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 570887340,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1769717810
    },
    {
        "content": "<p>My instinct is that we should be developing representation theory using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Representation#doc\">docs#Representation</a> for now, because we've decided on this as a definition and now we need to do the experiment of figuring out if it works.</p>",
        "id": 570904747,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769724583
    },
    {
        "content": "<p>Another issue that came up in <a href=\"https://github.com/leanprover-community/mathlib4/pull/34584\">#34584</a> is the need to refactor <a href=\"https://tqft.net/mathlib4files/Mathlib/RepresentationTheory/Maschke\">file#Mathlib/RepresentationTheory/Maschke</a> to use <code>Finite</code> instead of <code>Fintype</code>. As I'm refactoring it anyway, I could also change all the category-theoretic spellings of representation-theoretic notions to the ones I've been developing: <code>Rep</code> to <code>Representation</code>, <code>CategoryTheory.Simple</code> to <code>IsIrreducible</code> etc. Obviously I have to worry about some projects relying on these old theorems breaking because I changed assumptions. Do people think this refactor is worth doing? Do I need to mark old theorems as deprecated? (I see that label in mathlib from time to time)</p>",
        "id": 572038250,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770251784
    },
    {
        "content": "<p>Can we just reprove the theorems for <code>Representation</code> and leave the <code>Rep</code> ones?</p>",
        "id": 572083560,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770279355
    },
    {
        "content": "<p>What would the naming convention be for such cases? For example, if we have </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">trace</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>do I define </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">character'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">trace</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 572229020,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770318377
    },
    {
        "content": "<p>Probably <code>Representation.character</code></p>",
        "id": 572232412,
        "sender_full_name": "Bryan Wang",
        "timestamp": 1770319604
    },
    {
        "content": "<p>Ah right, different namespaces</p>",
        "id": 572232596,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770319670
    },
    {
        "content": "<p>Ok I've created locally a carbon copy of the file Character.lean with all the spellings changed from <code>Rep</code> to <code>Representation</code>. What would be a good way to PR it to mathlib? As a separate file or a new section of the old file?</p>",
        "id": 572236046,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770320912
    },
    {
        "content": "<p>Well I need just a small PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/34888\">#34888</a> to define a respelling of 'isomorphism of representations', and then my refactor will work</p>",
        "id": 572258085,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1770329660
    },
    {
        "content": "<p>In the PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/35100\">#35100</a>, I complete the proof of orthogonality of characters for <code>Representation</code>'s.</p>",
        "id": 575655574,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1771973040
    }
]