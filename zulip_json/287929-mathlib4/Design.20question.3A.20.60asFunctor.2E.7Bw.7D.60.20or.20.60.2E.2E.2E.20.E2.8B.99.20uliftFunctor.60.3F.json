[
    {
        "content": "<p>I'm finishing up limits and colimits in <code>Quiv.{v, u}</code>; I have a working version and am now refactoring/cleaning it up to be presentable for Mathlib. </p>\n<p>One thing I'd like to check for opinions on: The easiest way to create (co)limits in <strong>Quiv</strong> is by writing the category as a presheaf category and porting over limits that way. I expect that in general, quite a lot of categorical machinery will be easiest provided by making use of the general richness/well-behavedness of presheaf categories, so I would like this machinery to be fluid and easy to use. </p>\n<p>Unfortunately, when <code>v</code>  the universe level of the edges does not match <code>u</code> the universe level of the vertices, things get messy, and <strong>Quiv</strong> ceases to be equivalent to the entirety of the corresponding presheaf category, greatly complicating matters. To work around this, I have created machinery for working with the full subcategory of functors that happen to be <code>v, u</code>-small when represented as a quiver.</p>\n<p>I now have a choice: I can either define </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">asFunctor</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quiv</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">WalkingQuiver</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span>\n</code></pre></div>\n<p>with an extra universe level <code>w</code>, so that the underlying definition can work natively with functors into a larger level of <code>Type</code> than strictly required. This allows the core machinery to work with many universe levels directly, but moderately complicates the resulting implementation as a result. It also means that you gain less benefit from working in the usual simpler case of <code>u = v</code>; the complexity of having heterogenous universe levels bleeds over.</p>\n<p>Alternatively, I can hardcode <code>asFunctor</code> to be as small as it can be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">asFunctor</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quiv</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">WalkingQuiver</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span>\n</code></pre></div>\n<p>and instead prove lemmas about <code>asFunctor ⋙ whiskeringRight.obj uliftFunctor</code> and similar contortions, ultimately culminating in an equivalence that has the same universe polymorphism features as in the first option. This in some sense results in a cleaner, better-structured library at a higher level, which also allows users to use the simpler homogenous-universe-level code when applicable; but it also results in harder to read, harder to <em>use</em> definitions in terms of heavily nested compositions, as well as cluttering up search results with extra internal implementation details. </p>\n<p>One of these is already coded; I got halfway through refactoring it into the other before starting to reconsider.</p>\n<p>Thoughts/opinions?</p>",
        "id": 510053817,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1743723024
    }
]