[
    {
        "content": "<p>I suggest introducing a more general version of <code>Algebra.norm</code>. Currently, this definition requires an <code>R</code>-algebra <code>S</code> which is f.g. and free as an <code>R</code>-module, but one can define the norm when <code>S</code> is f.g. and projective, rather than free.</p>\n<p>This would be useful for example in the following setup: <code>L</code> is a finite extension of a number field or function field <code>K</code>;  <code>R</code> is a Dedekind domain with field of fractions <code>K</code> and <code>S</code> is the integral closure of <code>R</code> in <code>L</code>. We currently have no norm map from <code>S</code> to <code>R</code> apart from the special cases where <code>S</code> is a free <code>R</code>-module, but <code>S</code> is always projective over <code>R</code>.</p>\n<p>I suggest something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">projective_determinant</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hM</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Projective</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Projective</span><span class=\"bp\">.</span><span class=\"n\">finite_split</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∘ₗ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">hs</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"bp\">.</span><span class=\"n\">exists_fin'</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"n\">hi</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">projective_lifting_property</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">i</span>\n\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The \"determinant\" of a linear map `φ : P →ₗ[R] P`, where `P` is a finitely generated</span>\n<span class=\"sd\">projective `R`-module.</span>\n\n<span class=\"sd\">This is defined as follows. There is a module `Q` such that</span>\n<span class=\"sd\">`P ⊕ Q` is isomorphic to the free module `F := (Fin n → R)`.</span>\n<span class=\"sd\">The determinant of `φ` is defined to be the</span>\n<span class=\"sd\">determinant `φ ⊕ id : F →ₗ[R] F`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">projectiveDet</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Projective</span><span class=\"bp\">.</span><span class=\"n\">finite_split</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₃</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h₃</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">Φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"n\">Φ</span>\n\n\n<span class=\"c\">/-</span>\n<span class=\"cm\"># TODO :</span>\n<span class=\"cm\">1. this is well defined, i.e. doesn't depend on a choice of splitting `P ⊕ Q ≃ Free`.</span>\n<span class=\"cm\">2. this coincides with the usual determinant for free modules,</span>\n<span class=\"cm\">3. This is compatible with base change,</span>\n<span class=\"cm\">  i.e. the determinant of `φ ⊗ id : P ⊗ S →ₗ[S] P ⊗ S` is `algebaMap R S` of the determinant of `φ`.</span>\n<span class=\"cm\">4. `projectiveDet (φ ∘ₗ ψ) = ...`</span>\n<span class=\"cm\">5. `projectiveDet 0 = 0` if `P` is nontrivial.</span>\n<span class=\"cm\">6. `projectiveDet LinearMap.id = 1`</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">projective_determinant</span>\n\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">projective_norm</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Projective</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">norm'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→*₀</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">projectiveDet</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">lmul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">map_zero'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">map_one'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">map_mul'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">projective_norm</span>\n</code></pre></div>\n<p>Is this something which is worth pursuing?</p>",
        "id": 456656616,
        "sender_full_name": "Richard Hill",
        "timestamp": 1722877909
    },
    {
        "content": "<p>We have the norm from L to K right? Is it not hard to prove that the norm of something in the integral closure of S is still integral over S and hence presumably in the integral closure of R in K?</p>\n<p>On the other hand, what you're doing is strictly more general, and I've used your definition in the past (for characteristic power series of projective Banach modules). NB the proof that it's independent of Q is by considering P+Q+P+Q' and the fact that phi+1+1+1 and 1+1+phi+1 are conjugate so have the same char poly. If you're sticking to the f.g. projective case you could even define char poly this way (that way you get trace and norm).</p>",
        "id": 456702253,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1722890444
    },
    {
        "content": "<p>Thanks for your comments.</p>\n<p>Yes, the norm from <code>L</code> to <code>K</code> is in Mathlib because <code>K</code> is a field, so <code>L</code> is free over <code>K</code>. One could simply prove that this norm maps <code>S</code> to <code>R</code>. This is often done prime-by-prime, using the fact that locally <code>S</code> is locally free over <code>R</code>. But that would mean that <code>L</code> and <code>K</code> come into the definition of the norm from <code>S</code> to <code>R</code>, which could make the notation more awkward.</p>\n<p>Another way of defining the norm from <code>S</code> to <code>R</code> would be (up to a sign) a power of the constant term in the minimal polynomial. This is the most direct method, but it seems like an odd way to define the norm.</p>\n<p>The definition which I sketched out is more general, as it does not require <code>R</code> and <code>S</code> to be Dedekind rings, and it does not mention <code>K</code> or <code>L</code>.</p>\n<p>I'm a bit confused by your comment on char polys. The char poly does depend on the splitting, since its degree depends on the rank of $P \\oplus Q$. If one wanted to define the trace by the same trick, then I guess one should take the trace of <code>\\phi \\oplus (0 : Q \\to Q)</code> instead of <code>\\phi \\oplus id</code>.</p>",
        "id": 456715089,
        "sender_full_name": "Richard Hill",
        "timestamp": 1722895052
    },
    {
        "content": "<p>The char power series (starts 1+aX+... instead of X^n+aX^(n-1)+...) is independent of splitting. I agree that there should be a definition independent of L and K and mathematically your plan sounds fine to me.</p>",
        "id": 456718157,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1722896408
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.intNorm#doc\">docs#Algebra.intNorm</a> that came from flt-regular as it is more easily defined that way. But I agree this definition is better.</p>",
        "id": 456720504,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1722897328
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  ok, thanks for clarifying; I thought you were talking about charpoly. I assume the characteristic power series is something like $\\det (1 + x \\smul \\phi)$, although I'm not familiar with the definition. If one defined the determinant to be the leading coefficient,  would this be compatible with usual determinants (in the case that the usual determinant is 0)?</p>\n<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span>  Thanks for pointing that out. I have some slight issues with <code>Algebra.intNorm</code>. First, it assumes separability, which isn't needed. More importantly, it is not general enough to be used in the definition of <code>Ideal.spanNorm</code>. Because of this, it is not used in <code>Ideal.relNorm</code>. Consequently, <code>Ideal.relNorm</code> is only defined when <code>S</code> is a free <code>R</code>-module (where <code>R \\to S</code> is an extension of Dedekind domains). It would be nice to use <code>Ideal.relNorm</code> in more general situations (eg. to state the theorems of class field theory).</p>",
        "id": 456813184,
        "sender_full_name": "Richard Hill",
        "timestamp": 1722938203
    },
    {
        "content": "<p>The reason it assumes separability is that mathlib does not know (or at least did not know at the time) how norm behaves under purely inseparable extensions. Once we have the general version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.norm_eq_prod_embeddings#doc\">docs#Algebra.norm_eq_prod_embeddings</a> we can remove that easily.</p>\n<p>As for ideal norms, In flt-regular, we had <a href=\"https://github.com/leanprover-community/flt-regular/blob/master/FltRegular/NumberTheory/IdealNorm.lean\"><code>Ideal.spanIntNorm</code></a> to deal with this exact situation. This approach works for arbitrary finite extension of integrally closed domains (which are not necessarily projective) but I'm not sure if we need this generality or not.</p>",
        "id": 456815370,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1722938848
    },
    {
        "content": "<p>Thank you, it looks like <code>Ideal.spanIntNorm</code> solves the problem. Will this replace <code>Ideal.relNorm</code> in Mathlib?</p>",
        "id": 456818801,
        "sender_full_name": "Richard Hill",
        "timestamp": 1722940069
    },
    {
        "content": "<p>I don't think anyone has active plans for it. The thing is <code>Algebra.norm</code> (or the suggestion you raised) and <code>Algebra.intNorm</code> aren't strictly generalisations of each other and it is not clear to me if we should drop either of them.</p>",
        "id": 456848344,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1722948435
    },
    {
        "content": "<p>Yes I see that people might want to keep <code>Ideal.spanNorm</code>, but I can't see an argument for <code>Ideal.relNorm</code>. It only applies to Dedekind domains, so <code>Ideal.spanIntNorm</code> generalizes it (or at least this will be true when the separability condition is removed).</p>",
        "id": 457076799,
        "sender_full_name": "Richard Hill",
        "timestamp": 1723027525
    }
]