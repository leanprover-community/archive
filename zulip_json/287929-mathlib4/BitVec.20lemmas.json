[
    {
        "content": "<p>I agree with the sentiment behind keeping the lemmas about <code>BitVec</code> in mathlib at a minimum, but shouldn't we at least have the ring iso to <code>ZMod (2 ^ m)</code> in there as an off-bridge? Right now it seems it's a <code>CommRing</code> instance without any algebraic properties proven about it? /cc <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> <span class=\"user-mention\" data-user-id=\"481133\">@Alex Keizer</span> <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span></p>",
        "id": 491087995,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1735387933
    },
    {
        "content": "<p><del>That equivalence is not true when m=0</del></p>",
        "id": 491092539,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735392274
    },
    {
        "content": "<p>I'd expect the iso with <code>Fin (2^m)</code> though</p>",
        "id": 491092551,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735392296
    },
    {
        "content": "<p>If you want Zmod then I'd expect you to have to compose with another iso</p>",
        "id": 491092632,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735392370
    },
    {
        "content": "<p>Shouldn't all algebraic statements rather be about <code>ZMod</code>? I thought the ring structure on <code>Fin</code> is more or less only defined to then put it on <code>ZMod</code></p>",
        "id": 491092967,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1735392692
    },
    {
        "content": "<p>Hm, though I guess both have their applications in terms of what the zero case should be</p>",
        "id": 491093068,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1735392774
    },
    {
        "content": "<p>The nice thing about the <code>Fin</code> spelling is that the simplification lemmas can reduce the iso to <code>ofFin</code> and <code>toFin</code>, without needing to introduce new <code>ofZMod</code> and <code>toZMod</code></p>",
        "id": 491094478,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735394171
    },
    {
        "content": "<p>I have no opinion about BitVec except I know that having BitVec stuff in Mathlib is annoying to the FRO.</p>",
        "id": 491108946,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735408671
    },
    {
        "content": "<p>Given we have the Ring instance in mathlib, I think a PR to add the corresponding <code>RingEquiv</code> alongside it would be very reasonable</p>",
        "id": 491109335,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735408962
    },
    {
        "content": "<p>Will do!</p>",
        "id": 491171973,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1735474739
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/20322\">#20322</a></p>",
        "id": 491174441,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1735477098
    },
    {
        "content": "<p>I’m trying to prove a BitVec lemma in Mathlib and I’m stuck on the right lemmas / approach. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofInt_append_zeros_eqv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofInt</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofInt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Intuitively: 'ofInt w z' stores 'z mod 2^w', and appending 'n' zero bits should shift left by 'n', matching 'z * 2^n' at width 'w+n'<br>\nWhat’s the cleanest way to prove theorems like this which involves conversion between BitVec and Int? Any pointers to the right lemmas would be hugely appreciated.</p>",
        "id": 566670729,
        "sender_full_name": "Anirudh Suresh",
        "timestamp": 1767767981
    },
    {
        "content": "<p>I would start by applying toInt_injective, assuming that exists</p>",
        "id": 566683051,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767774744
    },
    {
        "content": "<p>Thanks. I tried that, and it does seem like the right first step.<br>\nAfter <code>apply BitVec.toInt_injective</code>and then simp/unfolding, the goal quickly turns into an Int arithmetic statement about <code>Int.bmod</code>.<br>\nThe part I’m stuck on is that <code>Int.bmod</code> is defined via <code>%</code> plus the half-range adjustment, so the proof becomes reasoning about the <code>%</code> remainder and those <code>&lt; (m+1)/2</code> conditions.<br>\nIs there a lemma that relates <code>bmod</code> to <code>emod</code>/<code>%</code> under these inequalities?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofInt_append_zeros_eqv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofInt</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofInt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toInt_inj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:=</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofInt</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:=</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofInt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toInt_append_zero</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toInt_ofInt</span><span class=\"o\">,</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toInt_ofInt</span><span class=\"o\">,</span><span class=\"n\">pow_add</span><span class=\"o\">,</span><span class=\"n\">mul_comm</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">all_goals</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 566691498,
        "sender_full_name": "Anirudh Suresh",
        "timestamp": 1767778008
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> Int.bmod, _ % _</p>",
        "id": 566695731,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1767779465
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Int/DivMod/Bootstrap.html#Int.bmod_emod\">Int.bmod_emod</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Int/DivMod/Bootstrap.html#Int.bmod_def\">Int.bmod_def</a>, and <a href=\"https://loogle.lean-lang.org/?q=Int.bmod%2C%20_%20%25%20_\">15 more</a></p>",
        "id": 566695743,
        "sender_full_name": "loogle",
        "timestamp": 1767779468
    },
    {
        "content": "<p>A few of those should be relevant</p>",
        "id": 566695763,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1767779473
    },
    {
        "content": "<p>Why do we have lemmas about a data structure in mathlib? Shouldn't this go in batteries?</p>",
        "id": 566871028,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1767851600
    },
    {
        "content": "<p>Sometimes the lemmas are easier to prove in terms of Mathlib's alternative hierarchy, and so it's often easier to prove in mathlib and wait for someone who wants it in batteries to relocate it</p>",
        "id": 566872966,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767852941
    }
]