[
    {
        "content": "<p>Hello! I'm working on formalizing domain theory for my final project in Brown University's Formal Proof and Verification course, following <a href=\"https://achimjungbham.github.io/pub/papers/handy1.pdf\">Abramsky-Jung handbook</a>. I have a question about <code>CompletePartialOrder</code> (Mathlib.Order.CompletePartialOrder). I noticed that we can prove that any <code>CompletePartialOrder</code> has a unique bottom element:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">complete_partial_order_has_bottom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompletePartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsBot</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DirectedOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DirectedOn</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CompletePartialOrder</span><span class=\"bp\">.</span><span class=\"n\">lubOfDirected</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"n\">h₁</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"bp\">∅</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsLUB</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLeast</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">upperBounds</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lowerBounds</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h₂</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h₂</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h₂</span>\n</code></pre></div>\n<p>Thus, should we add an instance <code>CompletePartialOrder.toOrderBot</code>? I noticed that in some domain theory literature (e.g., the handbook), directed sets are required to be non-empty. Under this alternative definition, a directed-complete partial order wouldn't necessarily have a bottom element, which makes it a more general structure.</p>\n<p>Addtionally, I've also formalized several key concepts from the handbook:</p>\n<ul>\n<li>Way-below relation (Definition 2.2.1)</li>\n<li>Continuous directed-complete partial order (Definition 2.2.6)</li>\n<li>Scott topology on continuous directed-complete partial order (Proposition 2.3.6)</li>\n<li>Existence of fixpoint for Scott continuous functions (Theorem 2.1.19.1)</li>\n</ul>\n<p>Would you be interested in these? I'd be happy to contribute them to Mathlib.</p>",
        "id": 487998057,
        "sender_full_name": "Zekai Li",
        "timestamp": 1733881686
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompletePartialOrder#doc\">docs#CompletePartialOrder</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DirectedOn#doc\">docs#DirectedOn</a> for reference)</p>",
        "id": 487999816,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1733882820
    },
    {
        "content": "<p>So I guess your proposal is changing <code>CompletePartialOrder</code> to have the field</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"w\"> </span>lubOfDirected (d : Set α) :\n<span class=\"gd\">-  DirectedOn (· ≤ ·) d → IsLUB d (sSup d)</span>\n<span class=\"gi\">+  Nonempty d → DirectedOn (· ≤ ·) d → IsLUB d (sSup d)</span>\n</code></pre></div>",
        "id": 488000042,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1733882986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.3E.20complete.20partial.20order.20and.20domain.20theory.20formalization/near/488000042\">said</a>:</p>\n<blockquote>\n<p>So I guess your proposal is changing <code>CompletePartialOrder</code> to have the field</p>\n<p><div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"w\"> </span>lubOfDirected (d : Set α) :\n<span class=\"gd\">-  DirectedOn (fun (x1 x2 : α) =&gt; x1 ≤ x2) d → IsLUB d (sSup d)</span>\n<span class=\"gi\">+  Nonempty d → DirectedOn (fun (x1 x2 : α) =&gt; x1 ≤ x2) d → IsLUB d (sSup d)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Exactly!</p>",
        "id": 488000248,
        "sender_full_name": "Zekai Li",
        "timestamp": 1733883124
    },
    {
        "content": "<p>Pinging <span class=\"user-mention\" data-user-id=\"373192\">@Christopher Hoskin</span>, as they are on the authors line of this file</p>",
        "id": 488000438,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1733883263
    },
    {
        "content": "<p>Would personally find the new formalizations useful! Do you have the source up somewhere?</p>",
        "id": 488003040,
        "sender_full_name": "nrs",
        "timestamp": 1733885046
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"749978\">nrs</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.3E.20complete.20partial.20order.20and.20domain.20theory.20formalization/near/488003040\">said</a>:</p>\n<blockquote>\n<p>Would personally find the new formalizations useful! Do you have the source up somewhere?</p>\n</blockquote>\n<p>My code is available <a href=\"https://github.com/spanning-tree/DomainTheoryFormalization/blob/main/DomainTheory.lean\">here</a>. The naming is currently messy, and I'm working on refining it according to Mathlib's contribution guidelines.</p>",
        "id": 488021217,
        "sender_full_name": "Zekai Li",
        "timestamp": 1733896532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"787068\">Zekai Li</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.3E.20complete.20partial.20order.20and.20domain.20theory.20formalization/near/487998057\">said</a>:</p>\n<blockquote>\n<p>Addtionally, I've also formalized several key concepts from the handbook:</p>\n<ul>\n<li>Way-below relation (Definition 2.2.1)</li>\n<li>Continuous directed-complete partial order (Definition 2.2.6)</li>\n<li>Scott topology on continuous directed-complete partial order (Proposition 2.3.6)</li>\n<li>Existence of fixpoint for Scott continuous functions (Theorem 2.1.19.1)</li>\n</ul>\n<p>Would you be interested in these? I'd be happy to contribute them to Mathlib.</p>\n</blockquote>\n<p>Hello <span class=\"user-mention\" data-user-id=\"787068\">@Zekai Li</span> - I'd certainly like to see the Way-below relation in Mathlib. I was planning to add this at some point, but I have plenty else to do, so please go ahead. I'm interested in complete continuous lattices, but I think it make sense to develop the theory for DCPOs.</p>\n<p>Christopher</p>",
        "id": 488029050,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1733900851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"787068\">Zekai Li</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.3E.20complete.20partial.20order.20and.20domain.20theory.20formalization/near/487998057\">said</a>:</p>\n<blockquote>\n<p>I noticed that in some domain theory literature (e.g., the handbook), directed sets are required to be non-empty.</p>\n</blockquote>\n<p>I was working initially from Gierz <em>et al</em> where directed sets are also required to be non-empty. This required having<code>d.Nonempty → DirectedOn (· ≤ ·) d →</code> everywhere in <a href=\"https://github.com/leanprover-community/mathlib4/pull/2508\">#2508</a>.</p>",
        "id": 488029922,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1733901266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"373192\">Christopher Hoskin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.3E.20complete.20partial.20order.20and.20domain.20theory.20formalization/near/488029922\">said</a>:</p>\n<blockquote>\n<p>I was working initially from Gierz <em>et al</em> where directed sets are also required to be non-empty. This required having<code>d.Nonempty → DirectedOn (· ≤ ·) d →</code> everywhere in <a href=\"https://github.com/leanprover-community/mathlib4/pull/2508\">#2508</a>.</p>\n</blockquote>\n<p>That's true! In my formalization,  <code>d.Nonempty → DirectedOn (· ≤ ·) d →</code> appears almost everywhere, which is a bit annoying. I have two proposals:<br>\nAdding CompletePartialOrder.toOrderBot and keeping the definition of <code>CompletePartialOrder</code> unchanged</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">CompletePartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toOrderBot</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompletePartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OrderBot</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">bot</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"bp\">∅</span>\n<span class=\"w\">  </span><span class=\"n\">bot_le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DirectedOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DirectedOn</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CompletePartialOrder</span><span class=\"bp\">.</span><span class=\"n\">lubOfDirected</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"n\">h₁</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsLUB</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsLeast</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">upperBounds</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lowerBounds</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h₂</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h₂</span>\n</code></pre></div>\n<p>Or changing the definition of <code>CompletePartialOrder</code> and adding a typeclass <code>PointedCompletePartialOrder</code> (we still need to write <code>d.Nonempty → DirectedOn (· ≤ ·) d →</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"w\"> </span>lubOfDirected (d : Set α) :\n<span class=\"gd\">-  DirectedOn (· ≤ ·) d → IsLUB d (sSup d)</span>\n<span class=\"gi\">+  d.Nonempty  → DirectedOn (· ≤ ·)  d → IsLUB d (sSup d)</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PointedCompletePartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">CompletePartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">OrderBot</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>Which one do we prefer?</p>",
        "id": 488176795,
        "sender_full_name": "Zekai Li",
        "timestamp": 1733947232
    },
    {
        "content": "<p>What about the third option of simply making <code>CompletePartialOrder</code> extend <code>OrderBot</code>?</p>",
        "id": 488664417,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1734018673
    },
    {
        "content": "<p>I would imagine that if a concrete type implements <code>CompletePartialOrder</code>, then it's likely to also implement <code>OrderBot</code>. Adding the instance <code>CompletePartialOrder.toOrderBot</code> manually can potentially create diamonds.</p>",
        "id": 488664761,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1734018756
    },
    {
        "content": "<p>If it's useful, we can define a constructor for <code>CompletePartialOrder</code> which takes in the other properties and fills in <code>bot = sSup Ø</code>.</p>",
        "id": 488665033,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1734018823
    },
    {
        "content": "<p>I think the two reasonable options here are to either extend <code>OrderBot</code> as Violeta says, or to restrict the axioms such that it is not implied at all (and the choice between these is a mathematical / terminology one). Indeed, <code>bot := sSup Ø</code> will create instance diamonds.</p>",
        "id": 488689563,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734026413
    },
    {
        "content": "<p>If we let <code>CompletePartialOrder</code> extend <code>OrderBot</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CompletePartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">SupSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">OrderBot</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">lubOfDirected</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">DirectedOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I think a construtor like this might be helpful:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkCompletePartialOrder</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OrderBot</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">lubOfDirected</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">DirectedOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsLUB</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">CompletePartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">d</span>\n<span class=\"w\">    </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">d</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⊥</span>\n<span class=\"w\">  </span><span class=\"n\">lubOfDirected</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">d</span>\n<span class=\"w\">    </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">lubOfDirected</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">not_nonempty_iff_eq_empty</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I would imagine we typically assume we're working with nonempty sets, when discussing LUB.</p>",
        "id": 488902538,
        "sender_full_name": "Zekai Li",
        "timestamp": 1734116222
    }
]