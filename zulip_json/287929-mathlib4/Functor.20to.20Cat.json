[
    {
        "content": "<p>Could anyone confirm it's impossible to write a functor <code>(J ⥤ M)  ⥤ Cat</code> which to a functor associates its category of cone ?</p>\n<p>(because of the equality non-sense of <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/equality.20of.20cones\">#mathlib4 &gt; equality of cones</a> )</p>\n<p>I still can't believe it</p>",
        "id": 478050151,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1729514524
    },
    {
        "content": "<p>I think it should be possible to write down such a functor. But it would probably be better to write it as a pseudofunctor!</p>",
        "id": 478064293,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1729518123
    },
    {
        "content": "<p>As Adam says. The pseudo functor would be more useful :-).</p>\n<p>Nevertheless I just wrote down </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">coneFunctor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>without too much trouble (it's 18 lines, uses <code>Functor.ext</code>).</p>",
        "id": 478067129,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1729518855
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>(it's a good exercise, so for whatever reason you believed it was impossible, I encourage you to try it first)</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>import Mathlib</p>\n<p>open CategoryTheory Limits</p>\n<p>variable {J M : Type*} [Category J] [Category M]</p>\n<p>@[simp] theorem Cones.hom_eqToHom {F : J ⥤ M} {X Y : Cone F} (h : X = Y) : <br>\n    (eqToHom h).hom = eqToHom (congrArg <a href=\"http://Cone.pt\">Cone.pt</a> h) := by cases h; simp</p>\n<p>def coneFunctor : (J ⥤ M) ⥤ Cat where<br>\n  obj F := Cat.of (Cone F)<br>\n  map f := Cones.postcompose f<br>\n  map_id F := by<br>\n    dsimp<br>\n    fapply CategoryTheory.Functor.ext<br>\n    · intro X<br>\n      simp [Cones.postcompose]<br>\n    · intro X Y f<br>\n      ext<br>\n      simp<br>\n  map_comp f g := by<br>\n    dsimp<br>\n    fapply CategoryTheory.Functor.ext<br>\n    · intro X<br>\n      simp [Cones.postcompose]<br>\n    · intro X Y f<br>\n      ext<br>\n      simp </p>\n</div></div>",
        "id": 478067797,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1729519018
    },
    {
        "content": "<p>What's the statement of the pseudo-functor version?</p>",
        "id": 478076273,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729521120
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">coneFunctor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pseudofunctor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LocallyDiscrete</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 478091484,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1729524916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Functor.20to.20Cat/near/478064293\">said</a>:</p>\n<blockquote>\n<p>I think it should be possible to write down such a functor. But it would probably be better to write it as a pseudofunctor!</p>\n</blockquote>\n<p>Why would it be better to write it as a pseudo functor ?</p>",
        "id": 478113437,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1729531596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Functor.20to.20Cat/near/478067797\">said</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">it's</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">good</span><span class=\"w\"> </span><span class=\"n\">exercise</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">so</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">whatever</span><span class=\"w\"> </span><span class=\"n\">reason</span><span class=\"w\"> </span><span class=\"n\">you</span><span class=\"w\"> </span><span class=\"n\">believed</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">was</span><span class=\"w\"> </span><span class=\"n\">impossible</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">encourage</span><span class=\"w\"> </span><span class=\"n\">you</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The reason I thought it was impossible is the previous discussion where the equality <code> postcompose (α ≫ β) = postcompose α ⋙ postcompose β</code>, used here,  was hailed as \"evil\" and triggered a philosophical debate on equality...</p>\n<p>I still have two questions, which have a common answer I suppose  :</p>\n<ul>\n<li>if that's a good exercice (it is !), doesn't that illustrate some lemmas are missing in the library ?</li>\n<li>why would the pseudo functor be any more useful ?</li>\n</ul>\n<p>A priori, functors are more useful. they have more properties.<br>\nI dont dislike pseudo functors (especially, and famously, to Cat!!), but what's with this obsession ?</p>",
        "id": 478142006,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1729541701
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257803\">@Nicolas Rolland</span>, could I suggest that this discussion seems to be going in circles a bit, and that perhaps rather than talking about what we \"like\" or think is \"evil\", you go and write some code, and make PRs? I think using the library, and trying to extend it, is the best way to understand the point we're trying to make.</p>\n<p>In any case, the basic point is that generic casting via equality, or using heterogeneous equality, is intrinsically painful. The fault here is partly just the usual \"dependent type theory hell\", but also partly that informal mathematics tends to sweep casting under the rug because it is tedious and tends to always work out, even if the reasoning is sometimes subtle. Using casting operations specific to the context at hand (e.g. using <code>eqToHom</code> to promote an equality of objects to a morphism, or using a 2-functor to send equalities of morphisms to 2-morphisms) is more ergonomic, and easy to do reasoning about.</p>",
        "id": 478156910,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1729547721
    },
    {
        "content": "<p>To be clear, no one said \"evil\" had anything to do with \"impossible\", I think that might be you jumping to a conclusion. :-) But as above, there's no need for philosophical debate here, instead we can debate with the typechecker! (And remembering our promise that so far we haven't run into anything insurmountable in this direction, despite having come quite far.)</p>",
        "id": 478157405,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1729547917
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Functor.20to.20Cat/near/478156910\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257803\">Nicolas Rolland</span>, could I suggest that this discussion seems to be going in circles a bit, and that perhaps rather than talking about what we \"like\" or think is \"evil\", you go and write some code, and make PRs? I think using the library, and trying to extend it, is the best way to understand the point we're trying to make.</p>\n</blockquote>\n<p>Many points were made, philosophical, categorical-ish, with different kind of arguments (of which I only understand the ergonomical one)</p>\n<p>I am all in favor of extending the library and making PR (I did a few) for this equality which you use.<br>\nI do not see why it should not be in the library. </p>\n<blockquote>\n<p>In any case, the basic point is that generic casting via equality, or using heterogeneous equality, is intrinsically painful. The fault here is partly just the usual \"dependent type theory hell\", but also partly that informal mathematics tends to sweep casting under the rug because it is tedious and tends to always work out, even if the reasoning is sometimes subtle. Using casting operations specific to the context at hand (e.g. using <code>eqToHom</code> to promote an equality of objects to a morphism, or using a 2-functor to send equalities of morphisms to 2-morphisms) is more ergonomic, and easy to do reasoning about.</p>\n</blockquote>\n<p>Right but having a plain functor allows all this too. <br>\nAnd having only a pseudo functor is less powerful.<br>\nI don't see where is the benefit.</p>\n<p>Unless to say we rely on the <code>simp</code> infrastructure somehow, in a way unavailable to functor, nor to functor viewed as pseudo-functor.... ? It would be useful to have a clear example of this.</p>",
        "id": 478244050,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1729589856
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257803\">Nicolas Rolland</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Functor.20to.20Cat/near/478244050\">said</a>:</p>\n<blockquote>\n<p>Right but having a plain functor allows all this too.<br>\nAnd having only a pseudo functor is less powerful.<br>\nI don't see where is the benefit.</p>\n</blockquote>\n<p>A functor is \"more powerful\", sure, but in what way? Perhaps you are thinking that because you have an equality you can now use <code>rw</code> and <code>simp</code> where you couldn't before. And you can, but this is a trap, because now you have introduced a cast operation into a piece of data, and this will cause issues with second order rewrites when you later try to reason about the term you just constructed.</p>\n<p>Trust me, we've all been through this. The library design decision here is to argue that the \"original sin\" was having an equality sitting around where it can only be used in ways that are misuse. Hence the \"evil\" moniker and the preference for using pseudofunctors instead.</p>\n<p>Note that none of the issues involved with using strict functors (and object equality more generally) are actually impossible to overcome, they are just very painful. The statement with functors <em>is</em> stronger, and occasionally a situation comes up where you actually need strict functoriality for mathematical reasons, and in that case you just have to power through it. But because the problems that arise on this path are well known, we would like to make sure that there are really no alternatives before going this route.</p>",
        "id": 478391845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729646023
    },
    {
        "content": "<p>Thank you, I understand better what is at play here.<br>\nIf I rephrase to make this <strong>ergonomical</strong> issue clearer, in a nutshell : </p>\n<p>Having pseudo functors is more usable, as they have already, built-in, at categorical level, some official slot for those pesky '<code>eqToHom</code> casts' . <br>\nThey are the simplest honest categorical structure dealing natively with the unfortunate limitation of this encoding of categories (where each pair of objects yields a different hom-set type - thus \"dependent type theory hell\")</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Functor.20to.20Cat/near/478391845\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257803\">Nicolas Rolland</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Functor.20to.20Cat/near/478244050\">said</a>:</p>\n<blockquote>\n<p>Right but having a plain functor allows all this too.<br>\nAnd having only a pseudo functor is less powerful.<br>\nI don't see where is the benefit.</p>\n</blockquote>\n<p>A functor is \"more powerful\", sure, but in what way? Perhaps you are thinking that because you have an equality you can now use <code>rw</code> and <code>simp</code> where you couldn't before. And you can, but this is a trap, because now you have introduced a cast operation into a piece of data, and this will cause issues with second order rewrites when you later try to reason about the term you just constructed.</p>\n</blockquote>\n<p>I imagined we could easily turn a functor into a pseudo when necessary. and come back to plain functor world when we can after the <code>eqToHom</code> business is cared for. This is true categorically, but ergonomically, as you later expose, having functors requires to power thought it.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Functor.20to.20Cat/near/478391845\">said</a>:</p>\n<blockquote>\n<p>Trust me, we've all been through this. The library design decision here is to argue that the \"original sin\" was having an equality sitting around where it can only be used in ways that are misuse. Hence the \"evil\" moniker and the preference for using pseudofunctors instead.</p>\n</blockquote>\n<p>This moniker seems a bit overloaded.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Functor.20to.20Cat/near/478391845\">said</a>:</p>\n<blockquote>\n<p>Note that none of the issues involved with using strict functors (and object equality more generally) are actually impossible to overcome, they are just very painful. The statement with functors <em>is</em> stronger, and occasionally a situation comes up where you actually need strict functoriality for mathematical reasons, and in that case you just have to power through it. But because the problems that arise on this path are well known, we would like to make sure that there are really no alternatives before going this route.</p>\n</blockquote>\n<p>If I rephrase : As long as what you want to get out of a functor is also provided by having a pseudo, dont fight the encoding and embrace the pseudo.</p>\n<p>[Another encoding, more natively suited for plain functors I suppose, would probably be as triple in Set, where we would have one type for all the morphisms  ...  Having conversion back and forth could be useful to get the best of both worlds ]</p>",
        "id": 478456497,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1729677288
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257803\">Nicolas Rolland</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Functor.20to.20Cat/near/478456497\">said</a>:</p>\n<blockquote>\n<p>I imagined we could easily turn a functor into a pseudo when necessary. and come back to plain functor world when we can after the <code>eqToHom</code> business is cared for. This is true categorically, but ergonomically, as you later expose, having functors requires to power thought it. </p>\n</blockquote>\n<p>We have API to turn a functor into a pseudo-functor. Conversely, it is possible to obtain an equality of functors from an isomorphim <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.ext_of_iso#doc\">docs#CategoryTheory.Functor.ext_of_iso</a></p>",
        "id": 478463286,
        "sender_full_name": "Joël Riou",
        "timestamp": 1729679630
    }
]