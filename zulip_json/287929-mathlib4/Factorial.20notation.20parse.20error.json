[
    {
        "content": "<p>In some cases the <code>Nat.factorial</code> notation parses incorrectly.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Factorial.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">∣</span> <span class=\"n\">n</span> <span class=\"bp\">!</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"c1\">-- fine</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">∣</span> <span class=\"n\">n</span> <span class=\"bp\">!</span> <span class=\"o\">:=</span> <span class=\"c1\">-- fine</span>\n    <span class=\"n\">dvd_factorial</span> <span class=\"n\">hn</span> <span class=\"n\">le_rfl</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">∣</span> <span class=\"n\">n</span> <span class=\"bp\">!</span> <span class=\"c1\">-- parsed incorrectly</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">dvd_factorial</span> <span class=\"n\">hn</span> <span class=\"n\">le_rfl</span>\n  <span class=\"n\">exact</span> <span class=\"n\">dvd_factorial</span> <span class=\"n\">hn</span> <span class=\"n\">le_rfl</span>\n</code></pre></div>",
        "id": 356724290,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1683555520
    },
    {
        "content": "<p>My guess is that the <code>·</code> is parsed as the anonymous variable, because we're still resolving the overloaded notation <code>!</code> (either <code>not</code> or <code>Nat.factorial</code>)</p>",
        "id": 356725626,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1683555714
    },
    {
        "content": "<p>Removing the whitespace works, since it prevents it from being treated as an application of <code>n</code> to <code>! ·</code>. Of course the lexer issues with <code>n!</code> still apply, but you can write <code>(n)!</code> instead</p>",
        "id": 356786417,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683570678
    },
    {
        "content": "<p>There's also using an explicit semicolon (<code>have : n ∣ n !;</code>) or using parentheses around other parts of the expression (like <code>have : n ∣ (n !)</code>).</p>",
        "id": 356799989,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683575226
    },
    {
        "content": "<p>or even <code>(have : n ∣ n !)</code></p>",
        "id": 356800532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683575428
    },
    {
        "content": "<p>(Javascript also has optional semicolons, and the risk of unexpected parses like this pushed me towards always using semicolons there.)</p>",
        "id": 356800546,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683575433
    },
    {
        "content": "<p>It's too bad that <code>·</code> for focusing is also a valid notation in expressions; if focusing used a unique symbol this could be less of an issue.</p>",
        "id": 356800677,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683575482
    },
    {
        "content": "<p>Does it work if you use <code>.</code> (period) instead of <code>·</code>?</p>",
        "id": 356800735,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1683575513
    },
    {
        "content": "<p>nope, <code>.</code> works as an ascii replacement for <code>·</code> in both cases</p>",
        "id": 356800843,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683575546
    },
    {
        "content": "<p>This also wouldn't be an issue if indentation-based syntax worked like in Haskell (as discussed elsewhere)</p>",
        "id": 356872028,
        "sender_full_name": "Reid Barton",
        "timestamp": 1683611409
    },
    {
        "content": "<p>Sorry for necrobumping this... I think <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> had a parser \"hack\" that made factorial notation work nicely. Maybe we actually want to have that in mathlib</p>",
        "id": 367703733,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1687194057
    },
    {
        "content": "<p><a href=\"#narrow/stream/287929-mathlib4/topic/New.20.60propose.60.20tactic/near/351149815\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/New.20.60propose.60.20tactic/near/351149815</a><br>\n(it's in a <code>propose</code> thread since Johan came across <code>n!</code> not being <code>n !</code> when creating a <code>propose</code> demo)</p>",
        "id": 367704149,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1687194144
    }
]