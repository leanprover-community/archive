[
    {
        "content": "<p>While the functionality for rational numbers now works (yay!), the given example in <a href=\"https://github.com/leanprover-community/mathlib4/pull/1102\">mathlib4#1102</a> (<code>example {α} [DivisionRing α] [CharZero α] : (-1:α) ≠ 2 := by norm_num</code>) still doesn't, because characteristic functionality is something else. Maybe there should be a new issue for that? <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> how time-sensitive is support for characteristics vs., say, <code>ring</code>?</p>",
        "id": 321293076,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673663941
    },
    {
        "content": "<p>(Or, actually—would this count as <code>≠</code> functionality? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span>)</p>",
        "id": 321301078,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673672600
    },
    {
        "content": "<p>yes</p>",
        "id": 321301336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673672790
    },
    {
        "content": "<p>we need inequalities, including !=</p>",
        "id": 321301347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673672806
    },
    {
        "content": "<p>tracking issue for inequalities: <a href=\"https://github.com/leanprover-community/mathlib4/pull/1567\">mathlib4#1567</a></p>",
        "id": 321302813,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673674114
    },
    {
        "content": "<p>open PR for <code>≠</code> in particular: <a href=\"https://github.com/leanprover-community/mathlib4/pull/1568\">mathlib4#1568</a></p>",
        "id": 321302826,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673674135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/287929-mathlib4/topic/norm_num.20characteristic.20functionality/near/321293076\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> how time-sensitive is support for characteristics vs., say, <code>ring</code>?</p>\n</blockquote>\n<p>cross-ref to <a href=\"#narrow/stream/287929-mathlib4/topic/Rat.20in.20norm_num/near/321399782\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Rat.20in.20norm_num/near/321399782</a> for further discussion of Thomas' questions about priorities.</p>",
        "id": 321401756,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1673724927
    },
    {
        "content": "<p>Am I right in thinking we’ll need something like <code>.isProp typeExpr proof</code> as a constructor for <code>Result</code>(<code>'</code>)? or possibly <code>.isNe α proof</code>, <code>.isLe α proof</code>, etc.?</p>\n<p>If so is one of these obviously better? And if the latter, what about e.g. <code>.isNe α lhs rhs proof</code> instead for results lhs and rhs? I’m wondering about the latter in case any later tactics will need to actually string these results together somehow, and I’m wondering if they might need some extra info from a result.</p>",
        "id": 321414611,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673735374
    },
    {
        "content": "<p>(We could also do something like <code>isRel α rel lhs rhs proof</code> with <code>rel</code> representing the (name of the) relation somehow, e.g. tokens <code>.le</code>, <code>.ne</code> or something if we wanted to cut down on how many constructors we have for <code>Result</code>.)</p>",
        "id": 321415076,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673735758
    },
    {
        "content": "<p>I think I’ve got an idea for how to structure things in the move to give <code>norm_num</code> the ability to prove props.</p>\n<p>so, there are really only two possible purposes of any given norm_num extension: it’s either constructing a literal value (a number) or proving a <code>Prop</code>. We know its purpose in advance.</p>\n<p>So the thought is: what if we added a(n essentially boolean) parameter to <code>Result</code> and <code>NormNumExt</code> to keep track of which kind of thing they’re doing? This would make the code easier to handle since we could keep the two cases separate. <code>.isRat</code> etc. would construct values of <code>Result .num e</code>, whereas e.g. <code>.isLe</code> (or however exactly we did it) would construct values of <code>Result .prop e</code>. That should mean we wouldn’t be matching on constructors in extension code that didn’t make sense to match on. We’d also know e.g. whether it made sense to extract a literal from a <code>Result</code> based on the type (though I guess that’s not too much of an issue since we work in <code>Option</code> and can have things just fail, but still).</p>\n<p>This might mean maintaining two discrimination trees, one for <code>NormNumExt .prop</code> and one for <code>NormNumExt .num</code>—not sure. <code>derive</code> would get an extra argument like this as well, saying whether it should try to derive a number or a prop. (We’d need to infer the kind of result we wanted from the expression at the beginning of the outermost norm_num process, but it’s easy to test an expression for <code>Prop</code>hood, iirc?)</p>\n<p>I think it would keep the code cleaner, but what I don’t know is whether it would be good for performance. Keeping the two discrimination trees separate might be good for performance, or it could be negligible; likewise for matching on less constructors and the opposite for having more arguments in Result.</p>\n<p>Giving <code>norm_num</code> the ability to handle <code>Prop</code>s will mean refactoring/updating code in one place or another, and this is the least annoying way I can think of—it lets us leave basically all of our number-handling code as-is at the cost of a little change to the infrastructure. Plus we get useful information in the type.</p>\n<p>If this sounds good lmk and I’ll have fun implementing it!</p>",
        "id": 321453079,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673769776
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> I pushed some changes to your branch to set up inequality proving and I tried to do one of everything so that there are enough clues to do the rest. For <code>ne</code>, the proof approach which is used in mathlib3 is to prove either <code>lt</code> or <code>gt</code> depending on which one we can establish, so the main work is on <code>le</code>/<code>lt</code>.</p>",
        "id": 321515134,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673805083
    },
    {
        "content": "<p>Sounds great! I see we went with the “add another constructor to <code>Result</code>” approach, and we just treat them as boolean literals.</p>\n<p>All that I don’t get is why we return a proof of the negation of a prop even when we’re apparently trying to prove the prop. (the <code>else</code> branch at the end of <code>&lt;</code>). Does this yield useful error messages or something? Or does it work differently?</p>",
        "id": 321522040,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673809414
    },
    {
        "content": "<p>(Also, just as a disclaimer, the weekends are when I have the least amount of time to actually code—I might have a bit of time today, but if I can’t finish it today, I will tomorrow.)</p>",
        "id": 321522253,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673809539
    },
    {
        "content": "<p>When <code>norm_num</code> is given an inequality like <code>2 &lt; 5</code> or <code>4 &lt; 1</code>, it's supposed to <em>normalize</em> it, to <code>True</code> or <code>False</code> (that is to say, prove or disprove it). This is important for three reasons: (1) when used as a non-goal-closing normalization it's supposed to replace subterms like <code>2 &lt; 5</code> with <code>True</code> even if it's not at the top level, (2) reducing a goal to <code>False</code> is a way to communicate that norm_num didn't just fail but actually disproved the claim, and (3) <code>norm_num at h</code> can close goals by reducing them to <code>False</code></p>",
        "id": 321522409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673809660
    },
    {
        "content": "<p>Remember that in all other cases when we are given an expression like <code>2 + 3</code> we are supposed to return a normal form expression which is provably equal to the input. For <code>2 &lt; 3</code> it's the same thing, the normal form expression provably equal to that is <code>True</code></p>",
        "id": 321522554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673809748
    },
    {
        "content": "<p>That makes sense!</p>",
        "id": 321522704,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1673809870
    },
    {
        "content": "<p>No problem if you can't get to it soon, I just wanted to make sure I got the architecture stuff in first :)</p>",
        "id": 321522771,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1673809919
    }
]