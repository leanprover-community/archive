[
    {
        "content": "<p>How can I do this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Setoid.Partition</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">notAdjFinpartition</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finpartition</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 404749362,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1701219716
    },
    {
        "content": "<p>The motivationn is Turán's theorem and my proof through \"Zykov symmetrisation\". I've got to the point where I have the <code>Setoid</code> over vertices with non-adjacency as the relation: <a href=\"/user_uploads/3121/WkOisO4UDbOAEZ9ZWxhJ7JYr/Turan.lean\">Turan.lean</a><br>\nNow my plan is to get a <code>Finpartition</code> from the <code>Setoid</code>, prove this is an <code>Equipartition</code> and finally prove the theorem as an isomorphism between any maximal graph and the relevant Turán graph. But the needed conversions from <code>Set</code> to <code>Finset</code> are stumping me</p>",
        "id": 404765193,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1701226305
    },
    {
        "content": "<p>Sorry, don't have time to write my thoughts, but it should be as easy as making <code>parts</code> be <code>univ.image fun a ↦ univ.filter (s a)</code>.</p>",
        "id": 404810013,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701246218
    },
    {
        "content": "<p><code>s a</code> doesn't make sense when <code>s</code> is a <code>Setoid</code></p>",
        "id": 404842716,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1701256885
    },
    {
        "content": "<p>You probably meant <code>univ.image fun a =&gt; univ.filter &lt;| (notAdjSetoid hmax).r a</code> for parts but then I get <code>failed to synthesize instance\n  DecidablePred fun x ↦ Setoid.r a x</code></p>",
        "id": 404845533,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1701258003
    },
    {
        "content": "<p>OK, this works, but how do I get the remaining three fields?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">notAdjFinpartition</span> <span class=\"o\">:</span> <span class=\"n\">Finpartition</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">parts</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">classical</span>\n    <span class=\"n\">exact</span> <span class=\"n\">univ.image</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">univ.filter</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">notAdjSetoid</span> <span class=\"n\">hmax</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"n\">a</span>\n  <span class=\"n\">supIndep</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">supParts</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">not_bot_mem</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 404846847,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1701258471
    },
    {
        "content": "<p><code>not_bot_mem</code> comes from the fact that <code>univ.filter &lt;| (notAdjSetoid hmax).r a</code> is nonempty since it contains <code>a</code>.</p>",
        "id": 404860453,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701262891
    },
    {
        "content": "<p><code>supParts</code> should be pretty obvious too (<code>a ∈ univ.filter &lt;| (notAdjSetoid hmax).r a</code>).</p>",
        "id": 404860562,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701262916
    },
    {
        "content": "<p>Finally <code>supIndep</code> is a bit harder, but if you've done the first two it should be pretty obvious (hint: <code>(notAdjSetoid hmax).r</code> is transitive).</p>",
        "id": 404860807,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701262965
    },
    {
        "content": "<p>OK, this was a pain</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Setoid.Partition</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span> <span class=\"n\">Setoid</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">finpartition_ofSetoid</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finpartition</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">parts</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">classical</span> <span class=\"n\">exact</span> <span class=\"n\">univ.image</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">univ.filter</span> <span class=\"o\">(</span><span class=\"n\">s.r</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"n\">supIndep</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">classical</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">forall_true_left</span><span class=\"o\">,</span> <span class=\"n\">supIndep_iff_pairwiseDisjoint</span><span class=\"o\">,</span> <span class=\"n\">Set.PairwiseDisjoint</span><span class=\"o\">,</span>\n      <span class=\"n\">Set.Pairwise</span><span class=\"o\">,</span> <span class=\"n\">coe_image</span><span class=\"o\">,</span> <span class=\"n\">coe_univ</span><span class=\"o\">,</span> <span class=\"n\">Set.image_univ</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_range</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">forall_exists_index</span><span class=\"o\">,</span>\n      <span class=\"n\">forall_apply_eq_imp_iff</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">q</span>\n    <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">q</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">not_disjoint_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">q</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">d1</span><span class=\"o\">,</span> <span class=\"n\">d2</span><span class=\"o\">⟩⟩</span> <span class=\"o\">:=</span> <span class=\"n\">q</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">id_eq</span><span class=\"o\">,</span> <span class=\"n\">mem_filter</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">d1</span> <span class=\"n\">d2</span>\n    <span class=\"n\">ext</span> <span class=\"n\">y</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">forall_true_left</span><span class=\"o\">,</span> <span class=\"n\">mem_filter</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">r1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s.iseqv.trans</span> <span class=\"o\">(</span><span class=\"n\">s.iseqv.trans</span> <span class=\"n\">d2.2</span> <span class=\"o\">(</span><span class=\"n\">s.iseqv.symm</span> <span class=\"n\">d1.2</span><span class=\"o\">))</span> <span class=\"n\">r1</span><span class=\"o\">,</span>\n           <span class=\"k\">fun</span> <span class=\"n\">r2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s.iseqv.trans</span> <span class=\"o\">(</span><span class=\"n\">s.iseqv.trans</span> <span class=\"n\">d1.2</span> <span class=\"o\">(</span><span class=\"n\">s.iseqv.symm</span> <span class=\"n\">d2.2</span><span class=\"o\">))</span> <span class=\"n\">r2</span><span class=\"o\">⟩</span>\n  <span class=\"n\">supParts</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">classical</span>\n    <span class=\"n\">ext</span> <span class=\"n\">a</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sup_image</span><span class=\"o\">,</span> <span class=\"n\">Function.comp.left_id</span><span class=\"o\">,</span> <span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">mem_sup</span><span class=\"o\">,</span> <span class=\"n\">mem_filter</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">iff_true</span><span class=\"o\">]</span>\n    <span class=\"n\">use</span> <span class=\"n\">a</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">s.iseqv.refl</span> <span class=\"n\">a</span>\n  <span class=\"n\">not_bot_mem</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">classical</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">bot_eq_empty</span><span class=\"o\">,</span> <span class=\"n\">mem_image</span><span class=\"o\">,</span> <span class=\"n\">not_exists</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">filter_eq_empty_iff</span><span class=\"o\">,</span> <span class=\"n\">not_forall</span><span class=\"o\">,</span> <span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">forall_true_left</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">not_not</span><span class=\"o\">]</span>\n    <span class=\"n\">use</span> <span class=\"n\">a</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">s.iseqv.refl</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 404869176,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1701265569
    },
    {
        "content": "<p><strong>Now</strong> that I have the <code>Finpartition</code> of <code>univ : Finset V</code>, given <code>a : V</code> is there a neat expression to get the part <code>a</code> lies in?</p>",
        "id": 404901793,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1701274373
    },
    {
        "content": "<p>I suggest looking at a lot of Finpartition API built here:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/compare/master...aluffi#diff-b1ded7d3cd173a640508811049587f4fe2fde9d282a73fd6e0d7c51f4b710ad4\">https://github.com/leanprover-community/mathlib4/compare/master...aluffi#diff-b1ded7d3cd173a640508811049587f4fe2fde9d282a73fd6e0d7c51f4b710ad4</a></p>\n<p>Like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">eq_of_mem_of_mem</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Finpartition</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">P.parts</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">P.parts</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hxa</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hya</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">P.supIndep</span> <span class=\"o\">(</span><span class=\"n\">singleton_subset_iff.mpr</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"n\">hy</span>\n  <span class=\"n\">by_contra</span> <span class=\"n\">H</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_singleton</span><span class=\"o\">,</span> <span class=\"n\">id_eq</span><span class=\"o\">,</span> <span class=\"n\">sup_singleton</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">Ne.symm</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">singleton_subset_iff.mpr</span> <span class=\"n\">hya</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">singleton_subset_iff.mpr</span> <span class=\"n\">hxa</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_unique_mem</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Finpartition</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃!</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">t</span> <span class=\"bp\">∈</span> <span class=\"n\">P.parts</span> <span class=\"bp\">∧</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">ht'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">P.exists_mem</span> <span class=\"n\">ha</span>\n  <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">ht'</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">u</span> <span class=\"o\">⟨</span><span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">hu'</span><span class=\"o\">⟩</span>\n  <span class=\"n\">exact</span> <span class=\"n\">eq_of_mem_of_mem</span> <span class=\"n\">hu</span> <span class=\"n\">ht</span> <span class=\"n\">hu'</span> <span class=\"n\">ht'</span>\n</code></pre></div>",
        "id": 404904028,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1701275072
    },
    {
        "content": "<p>This is now at <a href=\"https://github.com/leanprover-community/mathlib4/pull/8735\">#8735</a>. Still not sure what's the best way to link the <code>Setoid</code> and the <code>Finpartition</code> derived from it – I want something that directly equates the <code>Setoid</code>'s equivalence classes and the <code>Finpartition</code>'s parts</p>",
        "id": 405149564,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1701360366
    },
    {
        "content": "<p>But getting past the (computable) <code>Finset.choose</code> in my definition of <code>Finpartition.part</code> is the big obstacle. There appears to be no API around it</p>",
        "id": 405150162,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1701360509
    },
    {
        "content": "<p>How does the equiv between the two work in my branch? I don't recall.</p>",
        "id": 405193225,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1701374989
    },
    {
        "content": "<p>OK, here's what's going on right now. I have a non-adjacency setoid over the graph vertices and a <code>Finpartition</code> derived from it using my old <code>ofSetoid</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hmax</span> <span class=\"o\">:</span> <span class=\"n\">G.IsTuranMaximal</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">notAdjEquivalence</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span><span class=\"n\">G.Adj</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">where</span>\n  <span class=\"n\">refl</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">symm</span> <span class=\"n\">xy</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">xy</span><span class=\"o\">,</span> <span class=\"n\">adj_comm</span><span class=\"o\">]</span>\n  <span class=\"n\">trans</span> <span class=\"n\">xy</span> <span class=\"n\">yz</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">adj_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">xy</span>\n    <span class=\"n\">exact</span> <span class=\"n\">G.not_adj_transitive</span> <span class=\"n\">hmax</span> <span class=\"n\">xy</span> <span class=\"n\">yz</span>\n\n<span class=\"sd\">/-- In a Turán-maximal graph, non-adjacency is an equivalence relation. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">notAdjSetoid</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">Setoid.mk</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">notAdjEquivalence</span> <span class=\"n\">hmax</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">notAdjFinpartition</span> <span class=\"o\">:</span> <span class=\"n\">Finpartition</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Finpartition.ofSetoid</span> <span class=\"o\">(</span><span class=\"n\">notAdjSetoid</span> <span class=\"n\">hmax</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Now I want to prove this theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">xxx</span> <span class=\"o\">:</span> <span class=\"n\">G.degree</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">V</span> <span class=\"bp\">-</span>\n    <span class=\"o\">((</span><span class=\"n\">notAdjFinpartition</span> <span class=\"n\">hmax</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">part</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mem_univ</span> <span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span>\n    <span class=\"n\">G.degree</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">univ.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">G.Adj</span> <span class=\"n\">s</span> <span class=\"n\">b</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">card_neighborFinset_eq_degree</span><span class=\"o\">,</span> <span class=\"n\">neighborFinset</span><span class=\"o\">]</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">V</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">univ.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span><span class=\"n\">G.Adj</span> <span class=\"n\">s</span> <span class=\"n\">b</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">:=</span>\n      <span class=\"n\">eq_tsub_of_add_eq</span> <span class=\"o\">(</span><span class=\"n\">filter_card_add_filter_neg_card_eq_card</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">congr</span>\n      <span class=\"n\">ext</span> <span class=\"n\">v</span>\n      <span class=\"n\">simp</span> <span class=\"c1\">-- stuck here</span>\n</code></pre></div>\n<p>The goal state after the simp is <code>¬Adj G s v ↔ v ∈ Finpartition.part (notAdjFinpartition hmax) _</code></p>",
        "id": 405317173,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1701421521
    },
    {
        "content": "<p><em>Your</em> equiv (that I have just added to <a href=\"https://github.com/leanprover-community/mathlib4/pull/8735\">#8735</a> as <code>Finpartition.equivSubtypeSetoidIsPartition</code>) does not work as a drop-in substitute!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">notAdjFinpartition</span> <span class=\"o\">:</span> <span class=\"n\">Finpartition</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">Finpartition.equivSubtypeSetoidIsPartition</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">⟨(</span><span class=\"n\">notAdjSetoid</span> <span class=\"n\">hmax</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">classes</span><span class=\"o\">,</span> <span class=\"bp\">...</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">Subtype.mk</span> <span class=\"o\">(</span><span class=\"n\">Setoid.classes</span> <span class=\"o\">(</span><span class=\"n\">notAdjSetoid</span> <span class=\"n\">hmax</span><span class=\"o\">))</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">Setoid.classes</span> <span class=\"o\">(</span><span class=\"n\">notAdjSetoid</span> <span class=\"n\">hmax</span><span class=\"o\">)</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n</code></pre></div>\n<p>However am I going to synth the instance <code>Fintype ↑(Setoid.classes (notAdjSetoid hmax))</code>?</p>",
        "id": 405317989,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1701421830
    },
    {
        "content": "<p>If I can get this theorem that would directly complete the proof of <code>xxx</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mem_part_iff_rel</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">ofSetoid</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">part</span> <span class=\"o\">(</span><span class=\"n\">mem_univ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">s.r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 405318826,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1701422163
    },
    {
        "content": "<p>proved</p>",
        "id": 405398868,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1701448779
    }
]