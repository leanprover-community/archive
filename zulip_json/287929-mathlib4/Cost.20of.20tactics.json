[
    {
        "content": "<p>What is the energy/time cost of the tactics that leave some uninteresting and automatizable work to the computer?<br>\nMore precisely, assume we end a proof by</p>\n<ul>\n<li><code>rw [blah,…]</code> </li>\n<li><code>simp only [blah,…]</code></li>\n<li><code>simp [blah]</code></li>\n<li>some more elaborate tactic such as <code>group</code> or <code>ring</code>,</li>\n</ul>\n<p>where <code>blah</code> is some sequence of explicit lemmas, and <code>…</code> is some other <code>simp</code>-lemmas.</p>\n<p>If I understand things correctly, each time the file is compiled, the compiler has to elaborate by itself a way out to the proof. Most of the time, unless some things have changed, this is the same way as before. So isn't it a waste of computer power to have the computer recompute this? Or is this waste definitely negligible in comparison with the rest of the compilation?</p>",
        "id": 498206353,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1738874238
    },
    {
        "content": "<p>Let's say you have a 100W CPU with 8 threads of execution, electricity is 34 cents per kWh, mathlib is recompiled 100 times per day, and you have a tactic that takes 0.5 seconds to complete. That costs 2.2 cents of electricity per year.</p>",
        "id": 498208199,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738875018
    },
    {
        "content": "<p>Much more expensive is engineering time. If not using a more elaborate tactic means a maintainer needs to look at it for maintenance, then they can't spend more than a couple seconds fixing it.</p>",
        "id": 498209104,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738875403
    },
    {
        "content": "<p>There's a tradeoff though, since long compilation times aren't efficient for development either.</p>",
        "id": 498209388,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738875533
    },
    {
        "content": "<p>Does one know how many times mathlib is recompiled every day?</p>",
        "id": 498210180,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1738875867
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/metrics/usage\">This page</a> contains usage statistics.</p>",
        "id": 498211023,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738876256
    },
    {
        "content": "<p>The actions <code>build</code> and <code>bors</code> are the main ones that, among other things, build mathlib.</p>",
        "id": 498211104,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738876299
    },
    {
        "content": "<p>Those don't count local (possibly partial) builds tho</p>",
        "id": 498211296,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1738876374
    },
    {
        "content": "<p>Note that the cache saves a lot too</p>",
        "id": 498211368,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1738876413
    },
    {
        "content": "<p>Estimating how many times users of mathlib build mathlib will be hard.</p>",
        "id": 498211377,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738876420
    },
    {
        "content": "<p>Though then you need to look at the cost of storing and fetching and verifying the cache</p>",
        "id": 498211411,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1738876437
    },
    {
        "content": "<p>I have been interested in this too.  Has there been any benchmarking  done in this area?  Is there evidence that term-based proofs compile faster than tactic based proofs?</p>",
        "id": 498363371,
        "sender_full_name": "Kent Van Vels",
        "timestamp": 1738941421
    },
    {
        "content": "<p>I seem to remember that there is no correlation between term-mode vs tactic-mode for compile speed.</p>",
        "id": 498382724,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738946870
    },
    {
        "content": "<p>Or, rather, it can go both ways: I'm not actually sure about correlations.</p>",
        "id": 498383140,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1738946988
    },
    {
        "content": "<p>There's not really any inherent overhead to using tactics vs terms in Lean's architecture. They're both roughly at the same level of abstraction.</p>\n<p>Tactics can take advantage of global information when constructing terms that term elaborators can only infer in a piecewise way for example. I wouldn't be surprised if <code>intro x y z</code> were marginally faster than <code>refine fun x y z =&gt; ?_</code> for example.</p>",
        "id": 498384590,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738947445
    }
]