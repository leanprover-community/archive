[
    {
        "content": "<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> be a group. A submonoid <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>≤</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">M\\leq G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> induces a preorder on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> via <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>a</mi><mo>−</mo><mi>b</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">a\\leq b\\iff a-b\\in M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7184em;vertical-align:-0.024em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟺</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>. Consider the <em>support</em> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">supp</mi><mo>⁡</mo><mi>M</mi><mo><mi mathvariant=\"normal\">≔</mi></mo><mi>M</mi><mo>∩</mo><mo>−</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">\\operatorname{supp}M\\coloneqq M\\cap-M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">supp</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mop\" style=\"position:relative;top:-0.0347em;\">:</span></span><span class=\"mrel\"><span class=\"mspace\" style=\"margin-right:-0.0667em;\"></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>. This is exactly the equivalence class of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, so the quotient poset forms an ordered group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"normal\">supp</mi><mo>⁡</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">G/\\operatorname{supp}M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">/</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">supp</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>. This order is total if and only if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>∪</mo><mo>−</mo><mi>M</mi><mo>=</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">M\\cup-M=G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>. Conversely, the positive cone <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>g</mi><mo>≥</mo><mn>0</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{g\\geq0\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">}</span></span></span></span> of an ordered group is a submonoid with zero support.</p>\n<p>The story repeats for convex cones and modules over an ordered ring, and (with one slight variation) for semirings and rings. The story for modules is partially formalised in Mathlib at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PointedCone#doc\">docs#PointedCone</a>, and the one for groups and rings at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=GroupCone#doc\">docs#GroupCone</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingCone#doc\">docs#RingCone</a>. I would like to refactor Mathlib to unify these definitions and results.</p>\n<p>I can think of two main ways to design the formalisation in a uniform way:</p>\n<ol>\n<li>Have generic classes <code>IsSalient s := ∀ x, x ∈ s → -x ∈ s → x = 0</code> and <code>IsGenerating s := ∀ x, x ∈ s ∨ -x ∈ s</code> on any <code>SetLike</code> type over a type with negation.</li>\n<li>Define classes <code>IsSalient</code> and <code>IsGenerating</code> on the type <code>AddSubmonoid _</code>, making use of dot notation for convex cones and subsemirings.</li>\n</ol>\n<p>The advantage of (1) is that it makes automation (<code>simp</code>, <code>aesop</code>) easier. The advantage of (2) is that it makes typeclass search easier. I don't have a good reference point for designing predicates on generic substructures. Does anybody have thoughts on how to proceed?</p>",
        "id": 566009734,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767316635
    },
    {
        "content": "<p>When you say \"generic classes\", do you mean that <code>IsSalient</code> and <code>IsGenerating</code> would be predicates on sets?</p>",
        "id": 566033245,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767343230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Design.20for.20positive.20cones/near/566033245\">said</a>:</p>\n<blockquote>\n<p>When you say \"generic classes\", do you mean that <code>IsSalient</code> and <code>IsGenerating</code> would be predicates on sets?</p>\n</blockquote>\n<p>No, on <code>SetLike</code> types. Like how <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasMemOrNegMem#doc\">docs#HasMemOrNegMem</a> (\"<code>IsGenerating</code>\") is formalised currently.</p>",
        "id": 566048238,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767353730
    },
    {
        "content": "<p>So this will be a definition <em>scheme</em>, right? in the sense that you get one predicate for each <code>SetLike</code> type. As you know,  we are moving away from definition schemes when dealing with morphisms. Shouldn't we move away from them when dealing with subobjects too?</p>",
        "id": 566051768,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767356066
    },
    {
        "content": "<p>Yes, it would be. And yes <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHom.ker#doc\">docs#RingHom.ker</a> was on my mind when I asked this.</p>",
        "id": 566052024,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767356244
    },
    {
        "content": "<p>The problem is that set membership on a <code>SetLike</code> type works differently than bundled function application. That is, <code>x ∈ s</code> does not elaborate to <code>x ∈ s.toSet</code>. This means that, if <code>S : Semiring R</code>, then <code>S.IsSalient := ∀ x, x ∈ s.toAddSubmonoid → -x ∈ s.toAddSubmonoid → x = 0</code>. This expression simplifies to what we want, but it is not defeq to what we want, which makes matching on hypotheses of the form  <code>x ∈ s</code> difficult. On the other hand, <code>f x</code> for a <code>FunLike</code> type elaborates to <code>f.toFun x</code> via a coercion, avoiding this issue.</p>",
        "id": 566052559,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767356619
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Design.20for.20positive.20cones/near/566052559\">said</a>:</p>\n<blockquote>\n<p>which makes matching on hypotheses of the form <code>x ∈ s</code> difficult</p>\n</blockquote>\n<p>But do you <em>rewrite</em> <code>x ∈ s</code> hypotheses often?</p>",
        "id": 566054534,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767358225
    },
    {
        "content": "<p>Yeah true. But you do sometimes want to partially apply <code>eq_zero_of_mem_of_neg_mem</code>, especially when using automation like <code>aesop</code>. I suppose I can just add an extra lemma for each structure I work with.</p>",
        "id": 566066055,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767365377
    },
    {
        "content": "<p>How many generalisable lemmas are we talking about? 10? 100? 1000?</p>",
        "id": 566068176,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767366600
    },
    {
        "content": "<p>3</p>",
        "id": 566089225,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767379175
    },
    {
        "content": "<p>To be fair the number of extra instances in the other approach is very low too</p>",
        "id": 566089261,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767379203
    },
    {
        "content": "<p>IMO that's way too low a number to justify the overhead cost</p>",
        "id": 566089509,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767379399
    },
    {
        "content": "<p>Alright so something like<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasMemOrNegMem#doc\">docs#HasMemOrNegMem</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PositiveCone.IsGenerating#doc\">docs#PositiveCone.IsGenerating</a>  -&gt; <code>(Add)Submonoid.IsGenerating</code><br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddGroupCone#doc\">docs#AddGroupCone</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingCone#doc\">docs#RingCone</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PositiveCone.IsSalient#doc\">docs#PositiveCone.IsSalient</a> -&gt; <code>(Add)Submonoid.IsSalient</code></p>",
        "id": 566089829,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767379611
    },
    {
        "content": "<p>Tagging <span class=\"user-mention\" data-user-id=\"407120\">@Bjørn Solheim</span> because I've seen him do work on the convex cone side. Does my refactor seem reasonable?</p>",
        "id": 566184748,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767484371
    },
    {
        "content": "<p>Thanks for the tag. I believe you have a good suggestion (focusing on the more fundamental sub-monoid structure). The following might be relevant: the total order inducing criteria you are proposing is stronger than the current IsGenerating for ConvexCones (<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Geometry/Convex/Cone/Basic.html#ConvexCone.IsGenerating\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Geometry/Convex/Cone/Basic.html#ConvexCone.IsGenerating</a>). Therefore there might be some issues regarding which terminology to use. Maybe IsTotal can be considered? For IsSalient I think the notions coincide with the current library version (possibly modulo the inclusion of zero).</p>\n<p>Note that the ConvexCone definition is over positive scalars and thus is separate and different from the submodule over nonnegative scalars definition for PointedCones. There are transport mechanisms but this could be relevant for what you are envisioning. Both IsGenerating and Salient are defined for convex cones (and then later transported to pointed cones).</p>",
        "id": 566218897,
        "sender_full_name": "Bjørn Solheim",
        "timestamp": 1767528890
    },
    {
        "content": "<p>Thanks for the info!<br>\n\"Generating cone\" is, I believe, the standard name for the thing I want. The exact predicate is in Mathlib as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConvexCone.IsReproducing#doc\">docs#ConvexCone.IsReproducing</a>, and they're equivalent for pointed cones over a ring.</p>",
        "id": 566223319,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767533834
    },
    {
        "content": "<p>The fact positive cones aren't submonoids is a bit annoying - are non-pointed cones used much in Mathlib? I think I will just redefine the predicates for submonoids.</p>",
        "id": 566223440,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767533981
    },
    {
        "content": "<p>Oh wow the design for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConvexCone#doc\">docs#ConvexCone</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConvexCone#doc\">docs#ConvexCone</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PointedCone#doc\">docs#PointedCone</a> is really strange - it's a series of coercions, instead of structure classes or projections. <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> have you seen anything like this before?</p>",
        "id": 566230608,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767541359
    },
    {
        "content": "<p>What's <code>PositiveCone</code>?</p>",
        "id": 566230652,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767541396
    },
    {
        "content": "<p>(fixed)</p>",
        "id": 566230685,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767541428
    },
    {
        "content": "<p>What design did you expect?</p>",
        "id": 566230784,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767541522
    },
    {
        "content": "<p>Either <code>ConvexConeClass</code> or a <code>.toConvexCone</code> non-coercion projection</p>",
        "id": 566230840,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767541589
    },
    {
        "content": "<p>We don't really use <code>PointedCone</code>s as subobjects, and <code>ConvexCone</code> is rather odd as it doesn't even really represent subobjects!</p>",
        "id": 566230863,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767541615
    },
    {
        "content": "<p>I don't really get why <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConvexCone#doc\">docs#ConvexCone</a> exists tbh. I know it's the pen-and-paper definition, but it's just an axiomatisation of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PointedCone#doc\">docs#PointedCone</a> (ie a semimodule over the positive cone of a ring) without the 0 point.</p>",
        "id": 566230968,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767541737
    },
    {
        "content": "<p>The situation with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PointedCone#doc\">docs#PointedCone</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProperCone#doc\">docs#ProperCone</a> seems more reasonable to me, it's just the closed subgroup design.</p>",
        "id": 566231132,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767541923
    },
    {
        "content": "<p>Yeah OK: the only place in Mathlib where <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConvexCone#doc\">docs#ConvexCone</a> is used to prove things not about itself is for the Riesz Extension Theorem.<br>\n<a href=\"/user_uploads/3121/lypqAYRlQftysP-Vrkl27dtr/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/lypqAYRlQftysP-Vrkl27dtr/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1176x264\" src=\"/user_uploads/thumbnail/3121/lypqAYRlQftysP-Vrkl27dtr/image.png/840x560.webp\"></a></div>",
        "id": 566231974,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767542622
    },
    {
        "content": "<p>This theorem is not affected by changing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConvexCone#doc\">docs#ConvexCone</a> to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PointedCone#doc\">docs#PointedCone</a>.</p>",
        "id": 566232039,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767542675
    },
    {
        "content": "<p>I am sure there were reasons for choosing the path of ConvexCone as it exists in mathlib (although I am not familiar with them). But I would agree that PointedCones is more in line with the notion of conic/conical span/hull. And, while terminology choices are always difficult and multifaceted, I think convex cone terminology based on convex cones with nonnegative scalars is more common than the positive scalars only version (although it is mentioned on Wikipedia).</p>",
        "id": 566232247,
        "sender_full_name": "Bjørn Solheim",
        "timestamp": 1767542836
    },
    {
        "content": "<p>I'm not necessarily saying we should make this refactor now - but I am pointing out that doing so would be very easy. In particular, the predicates on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConvexCone.Blunt#doc\">docs#ConvexCone.Blunt</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConvexCone.Pointed#doc\">docs#ConvexCone.Pointed</a> do not appear to be used at all except to bundle <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConvexCone#doc\">docs#ConvexCone</a> into <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PointedCone#doc\">docs#PointedCone</a>.</p>",
        "id": 566232493,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767543102
    },
    {
        "content": "<p>Basically I'm saying that we shouldn't worry about duplicating work done by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConvexCone#doc\">docs#ConvexCone</a> for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PointedCone#doc\">docs#PointedCone</a>, because I don't think there's actually any work being done.</p>",
        "id": 566232549,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767543154
    },
    {
        "content": "<p>From the copyrights: looks like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConvexCone#doc\">docs#ConvexCone</a> was written in 2020 by Yury, and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PointedCone#doc\">docs#PointedCone</a> was contributed in 2023 by Apurva Nakade.<br>\n<span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> do you remember the considerations that went into choosing the \"strictly positive\" definition of positive cones in vector spaces rather than the \"non negative\" one?</p>",
        "id": 566232659,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767543295
    },
    {
        "content": "<p>I don't remember</p>",
        "id": 566260455,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1767573259
    },
    {
        "content": "<p>I think I've added them because they were needed as a dependency for something. I don't mind if you redefine them (assuming that people who actually care about this part of Mathlib don't mind either).</p>",
        "id": 566272397,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1767585465
    },
    {
        "content": "<p>OK thanks, I suspected so (they're apparently needed for integration)</p>",
        "id": 566275251,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767588041
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"768262\">@ooovi</span> saw that you are working in this area - do you have thoughts on the definition of convex cone? ^^</p>",
        "id": 566551463,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767708887
    },
    {
        "content": "<p>The terminology <code>PointedCone</code> is also perceived rather negatively whenever I speak to mathematicians working in optimization/geometry. \"pointed\" is usually used for what mathlib calls \"salient\". When we move away from using <code>ConvexCone</code>, does the name become available for <code>PointedCone</code>? Together with Olivia (<span class=\"user-mention\" data-user-id=\"768262\">@ooovi</span> ) we are currently working a lot on faces and duality theory for cones and <code>PointedCone</code> is the more important concept throughout.</p>",
        "id": 566560262,
        "sender_full_name": "Martin Winter",
        "timestamp": 1767711366
    },
    {
        "content": "<p>In fact, we never used <code>ConvexCone</code>. There is one case where one could consider using it: the relative interior of a <code>PointedCone</code> is a <code>ConvexCone</code>.</p>",
        "id": 566560963,
        "sender_full_name": "Martin Winter",
        "timestamp": 1767711548
    },
    {
        "content": "<p>Yeah I agree: rename <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PointedCone#doc\">docs#PointedCone</a> to <code>ConvexCone</code>. Then <code>IsPointed</code> can be a name for \"I don't contain any lines\", which I want to be a predicate on <code>AddMonoid</code> as described upthread. I think <code>IsPointed</code> would be a good name for the predicate: we say \"positive cone of an ordered group/ring\" instead of \"pointed monoid/semiring,\" but \"cone\" is already used in \"convex cone\" which is unfortunate for uniform naming.</p>",
        "id": 566561925,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767711817
    },
    {
        "content": "<p>Although from a quick search \"pointed monoid\" can mean what Mathlib calls \"monoid with zero\"... ugh</p>",
        "id": 566562398,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767711954
    },
    {
        "content": "<p>Related question: does the notion of \"support\" of a cone, defined as the union of lines it contains, come up in convex geometry or optimisation? The \"support\" of a subsemiring (defined as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>∩</mo><mo>−</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C \\cap -C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>) comes up in real algebra / ordered ring theory. So, a submonoid / subsemiring / convex cone is proper iff it has zero \"support\".</p>",
        "id": 566564477,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767712623
    },
    {
        "content": "<p>In convex geometry this is called the <em>lineality space</em> of a cone. We just introduced it as <code>PointedCone.lineal</code> in our recent (not yet approved) PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/33664\">https://github.com/leanprover-community/mathlib4/pull/33664</a></p>",
        "id": 566565415,
        "sender_full_name": "Martin Winter",
        "timestamp": 1767712935
    },
    {
        "content": "<p>OK thanks! I will make sure to use that.</p>",
        "id": 566565723,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767713029
    },
    {
        "content": "<p>If we are going to make this refactor, I would caution against moving files, in case we have to move them all back. But maybe it's fine since my story will take a while to implement.</p>",
        "id": 566565948,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767713101
    },
    {
        "content": "<p>I guess one more question: I understand that the common term for \"contains no lines\" is \"pointed,\" with \"salient\" sometimes used (most notably on Wikipedia). What is the common term in convex geometry for \"the set of pointwise differences generates the space,\" or equivalently \"the convex cone is not contained in a proper subspace\"? I've seen \"generating\" and \"reproducing\".</p>",
        "id": 566570446,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767714476
    },
    {
        "content": "<p>I usually use \"full-dimensional\", thought that might be too geometric for your generality. I heard people say \"essential\" or \"spanning\". But \"generating\" sounds not wrong for me either. I don't really like \"reproducing\".</p>",
        "id": 566571895,
        "sender_full_name": "Martin Winter",
        "timestamp": 1767714893
    },
    {
        "content": "<p>\"generating\" sounds a bit generic to me<br>\n\"spanning\" could work imo</p>",
        "id": 566575013,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767715735
    },
    {
        "content": "<p>OK well I've added it to my project, it seems to work fine<br>\nWill PR eventually</p>",
        "id": 566647631,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767750260
    },
    {
        "content": "<p>pinging <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> as the original author of the group/ring cone files</p>",
        "id": 566830142,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767822841
    },
    {
        "content": "<p>This whole file looks completely different from when I worked on it. Originally, it was not meant to be used as such, it was just a temporary structure used to construct a partial order when you want to define \"x is positive\" or \"x is nonnegative\" rather than \"x &lt; y\" or \"x &lt;= y\"</p>",
        "id": 566907763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1767867155
    },
    {
        "content": "<p>I guess people tried to give it more of a standalone mathematical meaning but it was really supposed to be a <code>*Core</code> kind of class, that's why I didn't want any infrastructure around it other than <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsOrderedRing.mkOfCone#doc\">docs#IsOrderedRing.mkOfCone</a> and the other versions for ordered groups and so on</p>",
        "id": 566908418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1767867366
    },
    {
        "content": "<p>OK cool (yeah that was me rewriting). I guess I'm rewriting again to unbundle and unify everything.</p>",
        "id": 566960299,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1767883734
    },
    {
        "content": "<p>New question: it's been suggested in review (<a href=\"https://github.com/leanprover-community/mathlib4/pull/33942\">#33942</a>) that <code>IsPointed</code> and <code>IsGenerating</code> should be <code>def</code>s rather than classes. Having to pass around <code>IsPointed</code> and <code>IsGenerating</code> as explicit arguments makes using dot notation for polymorphism more annoying. <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> or anyone else do you have thoughts on this? <br>\n(tagging <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> and <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> from the PR)</p>",
        "id": 569887145,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769273567
    },
    {
        "content": "<p>Can you give a short example of what you mean by the dot notation being annoying?</p>",
        "id": 569889972,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769276107
    },
    {
        "content": "<p>Before:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">AddSubmonoid</span><span class=\"bp\">.</span><span class=\"n\">eq_zero_of_mem_of_neg_mem</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddSubmonoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">IsPointed</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"n\">Subsemiring</span><span class=\"bp\">.</span><span class=\"n\">IsPointed</span><span class=\"bp\">.</span><span class=\"n\">eq_zero_of_mem_of_neg_mem</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subsemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">toAddSubmonoid</span><span class=\"bp\">.</span><span class=\"n\">IsPointed</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>And then we can say <code>M.eq_zero_of_mem_of_neg_mem</code>, <code>S.eq_zero_of_mem_of_neg_mem</code>, <code>S.toAddSubmonoid.eq_zero_of_mem_of_neg_mem</code> and the <code>x ∈ ?</code> hypotheses are all in the right type.</p>\n<p>Now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">AddSubmonoid</span><span class=\"bp\">.</span><span class=\"n\">IsPointed</span><span class=\"bp\">.</span><span class=\"n\">eq_zero_of_mem_of_neg_mem</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddSubmonoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hM</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">IsPointed</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"n\">Subsemiring</span><span class=\"bp\">.</span><span class=\"n\">IsPointed</span><span class=\"bp\">.</span><span class=\"n\">eq_zero_of_mem_of_neg_mem</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subsemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hS</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">IsPointed</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>Then <code>hS.eq_zero_of_mem_of_neg_mem</code> has hypotheses <code>x ∈ S.toAddSubmonoid</code> etc, because the type of <code>hS</code> is still <code>AddSubmonoid.IsPointed</code>. We could change the namespace to just <code>Subsemiring</code>, but then we have to do <code>S.eq_zero_of_mem_of_neg_mem hS</code>.</p>",
        "id": 570378840,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769534384
    }
]