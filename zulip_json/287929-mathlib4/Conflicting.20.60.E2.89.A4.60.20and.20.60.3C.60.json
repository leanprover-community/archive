[
    {
        "content": "<p>In working on <a href=\"https://ohaithe.re/Lean-QuantumInfo/QuantumInfo.html\">QuantumInfo</a> we've run into a funny problem. The <a href=\"https://en.wikipedia.org/wiki/Loewner%20order\">Loewner_order</a> is pretty common throughout quantum information, and defines two operators <code>â‰¤</code> and <code>&lt;</code> on matrices (or more generally, linear operators): <code>A â‰¤ B</code> means <code>(B - A).PosSemidef</code>, and <code>A &lt; B</code> means <code>(B - A).PosDef</code>. Each of these is generally well-behaved with regards to addition and scalar multiplication ... they turn matrices into a OrderedCancelAddCommMonoid, for instance.</p>\n<p>We would like to have these both available to work with.</p>\n<p>But the silly thing is that these two definitions <em>conflict</em>: it is <em>not</em> true that <code>a â‰¤ b â†” a = b âˆ¨ a &lt; b</code>. They generally \"agree\" in the sense that <code>a = b â†’ a â‰¤ b</code>, <code>a &lt; b â†’ a â‰¤ b</code>, and <code>a &lt; b â†’ a â‰  b</code>. Unfortunately, already at the most basic level(!) of Preorder, Mathlib assumes that <code>LE</code> and <code>LT</code> should be related this way. This means we can't make one instance accessible without automatically making another, garbage notation available.</p>\n<p>If we make <code>a â‰¤ b</code> available, then we get <code>a &lt; b</code> which ends up meaning \"<code>B - A</code> is positive semi-definite but not zero\". We can make <code>a &lt; b</code> available instead, and (uniquely) complete it to a preorder by defining <code>a â‰¤ b</code> appropriately, but then that ends up meaning \"<code>B - A</code> is either 0 or positive definite\". Both of these are pretty undesirable.</p>\n<p>We can of course use a custom notation like <code>â‰º</code> and <code>â‰¼</code>, or <code>â©½</code>, but then we're losing out on <code>Preorder</code> and the entire class hierarchy and all the useful theorems.</p>",
        "id": 512123692,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1744647998
    },
    {
        "content": "<p>Is there any way to, for instance, say \"I have this <code>Preorder</code> instance, but please only ever use it to for the <code>LE</code> instances and not an <code>LT</code> instance\"? And then likewise for another one, where I only want the LT instance?</p>\n<p>Of course if I start with <code>h : a â‰¤ b</code> and then do <code>h.lt</code> I'll have ended up with the \"bad\" instance, but I don't expect Lean (or Mathlib) could offer me any better solution.</p>",
        "id": 512124990,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1744648329
    },
    {
        "content": "<p>you could have a type alias where you endow the structure with the reflexivisation of <code>&lt;</code>, then have notation <code>â‰º</code> which means \"move to the type alias, then &lt;\"</p>",
        "id": 512125085,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744648355
    },
    {
        "content": "<p>at least, i think that works</p>",
        "id": 512125118,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744648362
    },
    {
        "content": "<p>so basically, you can have two <code>Preorder</code> instances, and have notation tell lean which to use by making them a macro for type aliases</p>",
        "id": 512125285,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744648395
    },
    {
        "content": "<p><del>This is probably a bad idea, because the lemmas  / tactics will likely match the wrong one and complain</del> whoops, I missed the type alias part.</p>",
        "id": 512125530,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744648451
    },
    {
        "content": "<p>I don't think type aliases are the way to go here.</p>",
        "id": 512125538,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744648452
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>, is the proposed <code>â‰¤</code> order also the one that satisfies <code>StarOrderedRing</code>?</p>",
        "id": 512125802,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744648527
    },
    {
        "content": "<p>Yes, I think we already have this order on matrices over <code>RCLike</code> in Mathlib.</p>",
        "id": 512125883,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744648551
    },
    {
        "content": "<p>At least, I definitely wrote it at one point, and I think I remember PR'ing it, but possibly not.</p>",
        "id": 512125974,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744648570
    },
    {
        "content": "<p>It exists and we're using it. :) (Thanks!)</p>",
        "id": 512126005,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1744648580
    },
    {
        "content": "<p>Loogle finds nothing for <code>StarOrderedRing (Matrix _ _ _)</code></p>",
        "id": 512126016,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744648583
    },
    {
        "content": "<p>Oh, then I guess I didn't PR it.</p>",
        "id": 512126072,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744648598
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span>, what are you referring to then?</p>",
        "id": 512126249,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744648652
    },
    {
        "content": "<p>Oh, I got it mixed up. We're not using one from Mathlib, we've got our own instance. It was a while ago and we went through a few iterations so my memory got confused</p>",
        "id": 512126358,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1744648678
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 512126362,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744648680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Conflicting.20.60.E2.89.A4.60.20and.20.60.3C.60/near/512123692\">said</a>:</p>\n<blockquote>\n<p>We can of course use a custom notation like <code>â‰º</code> and <code>â‰¼</code>, or <code>â©½</code>, but then we're losing out on <code>Preorder</code> and the entire class hierarchy and all the useful theorems.</p>\n</blockquote>\n<p>How many \"useful theorems\" do you expect apply to your case (apart from the fact that <code>a &lt; b â†” a â‰¤ b âˆ§ Â¬ b â‰¤ a</code> doesn't hold)?</p>",
        "id": 512126430,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1744648687
    },
    {
        "content": "<p>I guess at worst we could generalize <code>Preorder</code> to <code>PrePreorder</code>/<code>SemiPreorder</code>/etc</p>",
        "id": 512126483,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744648706
    },
    {
        "content": "<p>Oh, there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousLinearMap.instLoewnerPartialOrder#doc\">docs#ContinuousLinearMap.instLoewnerPartialOrder</a>, that's what I was thinking of</p>",
        "id": 512126566,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1744648727
    },
    {
        "content": "<p>I think if forced to choose the <code>â‰¤</code> ordering is most justified as a global instance</p>",
        "id": 512126728,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744648783
    },
    {
        "content": "<p>No, I think the answer here is that we want something akin to (but different from) <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=StrongLT#doc\">docs#StrongLT</a>. We're going to need the same kind of thing for Câ‹†-algebras, as this is exactly the concept of a <em>strictly positive</em> element in that context.</p>",
        "id": 512126732,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744648785
    },
    {
        "content": "<p>And probably (scoped) notation like <code>â‰ª</code> is appropriate for it.</p>",
        "id": 512126860,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744648824
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">YaÃ«l Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Conflicting.20.60.E2.89.A4.60.20and.20.60.3C.60/near/512126430\">said</a>:</p>\n<blockquote>\n<p>How many \"useful theorems\" do you expect apply to your case (apart from the fact that <code>a &lt; b â†” a â‰¤ b âˆ§ Â¬ b â‰¤ a</code> doesn't hold)?</p>\n</blockquote>\n<p>All the theorems that <code>OrderedAddCommMonoid</code> obeys, like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Order/Group/Unbundled/Basic.html#sub_le_sub_iff\">sub_le_sub_iff</a> for instance</p>",
        "id": 512126894,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1744648836
    },
    {
        "content": "<p>(and then also <code>sub_lt_sub_iff</code> ... both of which hold, they're just talking about different orderings)</p>",
        "id": 512126993,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1744648872
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Conflicting.20.60.E2.89.A4.60.20and.20.60.3C.60/near/512126728\">said</a>:</p>\n<blockquote>\n<p>I think if forced to choose the <code>â‰¤</code> ordering is most justified as a global instance</p>\n</blockquote>\n<p>I would also be happy to see this PR :)!</p>",
        "id": 512126996,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744648873
    },
    {
        "content": "<p>I am pressed to remind the community that last time someone claimed to have an interesting order for which <code>a &lt; b â†” a â‰¤ b âˆ§ Â¬ b â‰¤ a</code> doesn't hold, it turned out the order was wrong: <a class=\"message-link\" href=\"/#narrow/channel/116395-maths/topic/Surreal.20numbers/near/281094701\">#maths &gt; Surreal numbers @ ðŸ’¬</a></p>",
        "id": 512127005,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1744648877
    },
    {
        "content": "<p>YaÃ«l, this is absolutely standard in operator algebras.</p>",
        "id": 512127118,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744648919
    },
    {
        "content": "<p><code>StrongLT</code> is a trivial example of where that doesn't hold, right?</p>",
        "id": 512127196,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744648935
    },
    {
        "content": "<p>Just making sure... <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 512127207,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1744648939
    },
    {
        "content": "<p>Preferably, it will be some sort of class that you can hook into and extends <code>PartialOrder</code>. Note that it needs to be a class like this to cover both the case of matrices and abstract Câ‹†-algebras. (In the non-unital Câ‹†-algebra setting, being strictly positive means that the hereditary Câ‹†-subalgebra generated by that element is the whole algebra, so it's quite a different beast; in the unital setting this is equivalent to being nonnegative with zero not in the spectrum.)</p>",
        "id": 512127510,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744649027
    },
    {
        "content": "<p>Indeed the Loewner order is exactly the same as the<code>StrongLT</code> issue, if you treat each matrix <code>M</code> as a function <code>fun v =&gt; v * M * (star v)</code>; then the standard ordering on functions gives the <code>A â‰¤ B</code> ordering, and the <code>StrongLT</code> ordering on functions gives the <code>A &lt; B</code> ordering.</p>",
        "id": 512127657,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1744649060
    },
    {
        "content": "<blockquote>\n<p>In the non-unital Câ‹†-algebra setting, being strictly positive means that the hereditary Câ‹†-subalgebra generated by that element is the whole algebra, so it's quite a different beast</p>\n</blockquote>\n<p>woah, I didn't know that</p>",
        "id": 512127791,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1744649100
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Conflicting.20.60.E2.89.A4.60.20and.20.60.3C.60/near/512126728\">said</a>:</p>\n<blockquote>\n<p>I think if forced to choose the <code>â‰¤</code> ordering is most justified as a global instance</p>\n</blockquote>\n<p>Just wanted to echo I totally agree with this. This is what's been going on in our repo so far. We'd written <code>0 &lt; B</code> a couple of places to mean <code>B.PosDef</code>, and when trying (and failing) to fill in the sorries we realized what was happening... :)</p>",
        "id": 512128097,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1744649178
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Conflicting.20.60.E2.89.A4.60.20and.20.60.3C.60/near/512126860\">said</a>:</p>\n<blockquote>\n<p>And probably (scoped) notation like <code>â‰ª</code> is appropriate for it.</p>\n</blockquote>\n<p>What do we call the version of <code>Set.Ioo</code> for the strong order?</p>",
        "id": 512128527,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744649286
    },
    {
        "content": "<p><code>Set.Ioooooooo</code> <span aria-label=\"laughter tears\" class=\"emoji emoji-1f602\" role=\"img\" title=\"laughter tears\">:laughter_tears:</span></p>",
        "id": 512128635,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744649314
    },
    {
        "content": "<p>I think we likely don't have a name for it.</p>",
        "id": 512128740,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744649344
    },
    {
        "content": "<p>I can see that being quite handy, because on product types <code>Set.Ioo</code> is pretty useless (give me the whole cube except its top and bottom point)</p>",
        "id": 512128769,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744649350
    },
    {
        "content": "<p>i mean... is there even a notion of strongly open sets, for that matter?</p>",
        "id": 512128778,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744649354
    },
    {
        "content": "<p>since that's what the <code>o</code> refers to</p>",
        "id": 512128936,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744649395
    },
    {
        "content": "<p><code>infix:max \"ðŸ’ª&lt;\" =&gt; StrongLT</code></p>",
        "id": 512129007,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1744649403
    },
    {
        "content": "<p>So (besides just making do with <code>(B-A).PosDef</code>), what would be the best way to try to move forward with this?<br>\nTry to figure out a \"generalized StrongLT\", that has some facts about it being compatible with a PartialOrder, so it can be a kind of mixin - across different objects that would have a notion like this?</p>",
        "id": 513200996,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1745093288
    },
    {
        "content": "<p>I'm picturing something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Strong_LT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">rel</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">so</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsStrictOrder</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"n\">rel</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_stronglt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rel</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kn\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"s2\">\" â‰º \"</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Strong_LT</span><span class=\"bp\">.</span><span class=\"n\">rel</span>\n</code></pre></div>",
        "id": 513201453,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1745093702
    },
    {
        "content": "<p>I think by connecting it to a preorder like that, then some other theorems can be proved by <code>â‰º</code> in appropriate cases. Like with <code>IsOrderedAddMonoid</code> you can already establish that <code>a â‰º b â†’ âˆ€ (c : Î±), Â¬(c + b â‰º c + a)</code>, for instance</p>",
        "id": 513201738,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1745093929
    },
    {
        "content": "<p>I don't know if it would make sense to require more connections between the two. Saying that <code>â‰º</code> should also respect any <code>StrictMono</code> functions seems reasonable (and, I think, holds for both these cases) and then a lot more could be proved in general about linking it back and forth to the 'main' preorder</p>",
        "id": 513202101,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1745094205
    },
    {
        "content": "<p>Why is <code>Î±</code> implicit in Strong_LT?</p>\n<p>âˆ€&lt; is apparently a valid notation too.</p>",
        "id": 513202503,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1745094488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Conflicting.20.60.E2.89.A4.60.20and.20.60.3C.60/near/513202503\">said</a>:</p>\n<blockquote>\n<p>Why is <code>Î±</code> implicit in Strong_LT?</p>\n</blockquote>\n<p>Because I was silly :) Fixed haha</p>\n<blockquote>\n<p>âˆ€&lt; is apparently a valid notation too.</p>\n</blockquote>\n<p>Oh, that's nice</p>",
        "id": 513202742,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1745094663
    }
]