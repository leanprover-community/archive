[
    {
        "content": "<p>I'm currently working on infrastructure for elaboration-aware library-scale utilities (<a href=\"https://github.com/thorimur/skimmer\">Skimmer</a>), and I'm starting with the use case of refactoring occurrences of deprecated declarations by replacing them with their current version. Here's a small demo of the core action:<br>\n<a href=\"/user_uploads/3121/5yAEnoWlI8whi0wZAezIJLZp/AdprecationDemo.mp4\">AdprecationDemo.mp4</a></p>\n<div class=\"message_inline_image message_inline_video\"><a href=\"/user_uploads/3121/5yAEnoWlI8whi0wZAezIJLZp/AdprecationDemo.mp4\" title=\"AdprecationDemo.mp4\"><video preload=\"metadata\" src=\"/user_uploads/3121/5yAEnoWlI8whi0wZAezIJLZp/AdprecationDemo.mp4\"></video></a></div><p>Currently this requires that the names only differ in their last component, but the goal is of course to make this utility fully general, and to also allow custom specification of arbitrarily complex refactors. More generally, Skimmer is intended to be a \"cotool\" that provides an environment in which to build and a harness in which to run other, modular tools at library scale like refactors</p>\n<p>Crucial to all this, though, are the ergonomics, which are not addressed by the demo! Skimmer ought to</p>\n<ul>\n<li>be easy to control/use (activate, run tools, etc.)</li>\n<li>be easy to extend locally, via third parties, and also \"mid-library\"</li>\n<li>be able to run its tools nonlocally (i.e. in CI)</li>\n<li>be able to run its tools without asking the user to make changes to (or to leave!) their repo/lakefile; an initial setup should be enough to make it accessible and extendable</li>\n</ul>\n<p>among other requirements.</p>\n<p>One approach that currently seems promising for these goals is the use of lake plugins. They let us run initializers at the start of each file during build, and thus hook into the actual build process with e.g. linters and environment extensions without creating a custom frontend (which would be subject to drifting away from the \"real\" frontend, and would necessitate its own custom notion of a build, which comes with a maintainability cost).</p>\n<p>(Another option is to try to use lake facets somehow, but these can only fetch the result of the build, and thus miss out on all the elaboration information which is crucial to tools like this. I don't know a way to inject something into the build process itself  within a facet without either creating a custom frontend/build process there (which again is fragile and less maintainable) or turning back to plugins anyway.)</p>\n<p>I'd love to hear any other ideas or prior art re: library development tools, even in other languages; I'm especially curious about the ergonomics and UX. Thanks! :)</p>",
        "id": 564104762,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1765908453
    }
]