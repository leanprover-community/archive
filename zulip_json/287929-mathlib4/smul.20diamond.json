[
    {
        "content": "<p>I am writing the linear algebra chapter of MIL and I was very disappointed to see that all our diamond infrastructure is not giving <code>rfl</code> for</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact_mod_cast</span><span class=\"w\"> </span><span class=\"n\">zsmul_eq_smul_cast</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">nsmul_eq_smul_cast</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>Am I missing something? Is this a well-known unsolvable issue?</p>",
        "id": 457163013,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723052971
    },
    {
        "content": "<p>I don't think I understand. The whole point of forgetful inheritance is that we store the low-level data in the high-level structure so that when you go back down you don't forget the original definition (and make up a new one built from the bigger structure).</p>\n<p>Point being: you've got an <code>SMul ℕ V</code> instance, a <code>SMul K V</code> instance and a <code>NatCast V</code> (or <code>OfNat</code>) instance, all of which could have arbitrarily complicated definitions, and you somehow want, for <code>n : ℕ</code>, <code>v : V</code>, for <code>n • v = (Nat.cast n : K) • v</code> to hold <em>definitionally</em>? Admittedly, because they have <code>Field</code> and <code>Module</code> instances, they obviously hold propositionally, but I'm just not clear why you think these arbitrary structures should be expected to be definitionally equal.</p>",
        "id": 457164562,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1723053642
    },
    {
        "content": "<p>If you <em>didn't</em> do forgetful inheritance, then you could ensure this was true definitionally for <code>Field</code> and <code>Module</code>, but then you would be <em>creating</em> diamonds.</p>",
        "id": 457164663,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1723053692
    },
    {
        "content": "<p>Ah, I think I totally missed the point of your question. You didn't mean you wanted the proofs to be <code>rfl</code>, you meant that you didn't want to need <code>exact_mod_cast</code>, correct?</p>",
        "id": 457165434,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1723054018
    },
    {
        "content": "<p>The issue here is that <code>Int.cast</code> is defined using a typeclass, not by cases on the integer number.</p>",
        "id": 457168194,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1723054953
    },
    {
        "content": "<p>BTW, I don't know if some of these typeclasses can be discarded in Lean 4, since it inserts explicit <code>*.cast</code>s</p>",
        "id": 457168437,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1723055021
    },
    {
        "content": "<p>Of course, this will make something like <code>(Nat.cast n : Nat) = n</code> a non-<code>rfl</code>.</p>",
        "id": 457168710,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1723055091
    },
    {
        "content": "<p>UPD: no, <code>Algebra Nat Nat</code> needs it to be <code>rfl</code>.</p>",
        "id": 457168867,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1723055134
    },
    {
        "content": "<p>(or we need to drop the <code>algebraMap</code> from <code>Algebra</code> and define it in terms of <code>SMul</code>)</p>",
        "id": 457169090,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1723055178
    },
    {
        "content": "<p>I think the right proofs here are:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ofNat_smul_eq_nsmul</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ofNat_smul_eq_nsmul</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ofNat_smul_eq_nsmul</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>",
        "id": 457198633,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723063698
    },
    {
        "content": "<p>This isn't <code>Nat.cast</code> or <code>Int.cast</code>, but <code>OfNat.ofNat</code> so you should be using the <code>ofNat</code> lemma</p>",
        "id": 457198654,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723063708
    },
    {
        "content": "<p>So I think your problem is not about <code>smul</code> at all, and actually that</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>since you're treating the LHS as though it were the RHS</p>",
        "id": 457198870,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723063782
    },
    {
        "content": "<p>I think the problem is that we have all these cast tactics but they don't prove the examples in Patrick's post (neither of of <code>norm_cast</code>, <code>push_cast</code> prove it, even though it looks like it's of the form x=x). Presumably what one would want to tell a beginner here is \"just use this tactic\". All the proofs which work above are pretty horrible (e.g. I think I might have struggled to find any of them, <code>exact?</code> and <code>hint</code> don't work for the first one so this is a pretty poor user experience here).</p>",
        "id": 457200495,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1723064281
    },
    {
        "content": "<p>I think the difficulty with solving <code>norm_cast</code> is choosing what the norm form is. Usually when you use norm_cast, the rule is just \"make the outer expression the simplest type you can\". When your expression is about a module over multiple rings, you now need to pick which ring to normalize <em>inner expressions</em> into</p>",
        "id": 457201026,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723064415
    },
    {
        "content": "<p>To make matters worse, the proofs in Patrick's code sample use deprecated functions and when I replace the functions with what Lean tells me to replace them with, the proofs no longer work :-(</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact_mod_cast</span><span class=\"w\"> </span><span class=\"n\">zsmul_eq_smul_cast</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">`zsmul_eq_smul_cast` has been deprecated, use `Int.cast_smul_eq_nsmul` instead</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact_mod_cast</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">cast_smul_eq_nsmul</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">mod_cast has type</span>\n<span class=\"cm\">  4 • ?m.15669 = 4 • ?m.15669 : Prop</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  4 • v = 4 • v : Prop</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 457201158,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1723064461
    },
    {
        "content": "<p>The deprecated versions are the reverse of the new versions (I guess it was awkward to convey that with <code>deprecated</code>)</p>",
        "id": 457201195,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723064479
    },
    {
        "content": "<p>(also it looks like you're behind the web editor, <code>Int.cast_smul_eq_nsmul</code> was a typo and no longer exists, it is now <code>Int.cast_smul_eq_zsmul</code>)</p>",
        "id": 457201487,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723064564
    },
    {
        "content": "<p>We could teach <code>simp</code> to solve this specific problem with <code>ofNat_smul_eq_ofNat_smul</code>, but this doesn't compose to anything more useful in more complex cases</p>",
        "id": 457201605,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723064628
    },
    {
        "content": "<p>Yes, the point is that there doesn’t seem to be any nice proof for such an obvious statement. This is really super frustrating.</p>",
        "id": 457214282,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723069711
    },
    {
        "content": "<p>I think the answer here is that we need to write the <code>module</code> tactic analogous to <code>ring</code></p>",
        "id": 457214661,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723069832
    },
    {
        "content": "<p>I guess with this <code>module</code> tactic it would accept a type argument for the scalar ring?</p>",
        "id": 457215697,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1723070188
    },
    {
        "content": "<p>Optimistically it could just work it out</p>",
        "id": 457215810,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723070232
    },
    {
        "content": "<p>If your rings all form a directed graph into a single <code>Algebra</code>, you can just keep promoting till they match</p>",
        "id": 457215869,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723070255
    },
    {
        "content": "<p>Probably the only cases that are crucial to handle are mixtures of <code>Nat</code>, <code>Int</code>, <code>Rat</code>, and <code>K</code></p>",
        "id": 457216032,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723070313
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/smul.20diamond/near/457214661\">said</a>:</p>\n<blockquote>\n<p>I think the answer here is that we need to write the <code>module</code> tactic analogous to <code>ring</code></p>\n</blockquote>\n<p>Yes, this is one of the first things I wrote in this chapter.</p>",
        "id": 457310170,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723107836
    },
    {
        "content": "<p>Did somebody do the mathematical work for that? (= a normal form algorithm for expressions in modules)</p>",
        "id": 457311068,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1723108119
    }
]