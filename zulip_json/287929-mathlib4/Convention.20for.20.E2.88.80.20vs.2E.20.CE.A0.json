[
    {
        "content": "<p>In mathlib3 I recall the convention was to use Π for data and ∀ for proofs (i.e. <code>∀ i, p i</code> if <code>p : ι → Prop</code> and <code>Π i, T i</code> if <code>T : ι → Type*</code>. However, mathport has translated all <code>Π</code> to <code>∀</code> so we only saw the latter in mathlib4 for a while, and people probably followed this convention. But lately, <a href=\"\">new PR</a>s by e.g. <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> have been systematically using e.g. <code>Π i, A i</code> (for a product of algebra in this case) but still keep using <code>∀</code> in <code>[∀ i, CommRing (A i)] [∀ i, Algebra R (A i)]</code> even though these are also data. Personally this also feels natural to me, and I think the rationale is that since typeclass arguments is meant to supply something unique, it's intuitive for people to speak that \"for each <code>i</code> there exists a (canonical) CommRing/Algebra structure\". Or in other words, Since there's only one canonical inhabitant of the type, it's natural to treat it as a subsingleton and use ∀ since Props are also subsingletons. If people agree with this convention (use <code>∀</code> for proofs and typeclass arguments and <code>Π</code> otherwise), we should probably codify it and prepare a PR to make mathlib4 compliant. Thoughts?</p>\n<p>cc <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> since you once commented \"the ship has sailed\".</p>",
        "id": 495975114,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1737904620
    },
    {
        "content": "<p>I definitely agree that <code>Π i, A i</code> is more natural than <code>∀ i, A i</code> if we want to say \"indexed product\". And for me it reads more naturally <code>[∀ i, CommRing (A i)]</code> (each <code>A i</code> comes with <code>CommRing</code> structure) than <code>[Π i, CommRing (A i)]</code>. Analogously to <code>[CommRing A] [CommRing B]</code> having more in common with \"and\" and not <code>×</code>.</p>\n<p>It seems that Mathlib4 is quite consistent with typeclass arguments, but there are places with <code>∀ i, A i</code>...</p>",
        "id": 495975883,
        "sender_full_name": "Michał Staromiejski",
        "timestamp": 1737905281
    },
    {
        "content": "<p>I think the convention I am following myself is not \"<code>∀</code> for proofs and typeclass arguments and <code>Π</code> otherwise\".</p>\n<p>For example I would write <code>(A B : ι → Type) (e : ∀ i, A i ≃ B i) : (Π i, A i) ≃ (Π i, B i)</code> despite <code>e</code> being data, because on paper we would say \"If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">A_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">B_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mi>i</mi></msub><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\prod_i A_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.162em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mi>i</mi></msub><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\prod_i B_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.162em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>\", and not \"if we have a product of isomorphisms\" or \"'<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>' is isomorphic to '<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>'\"</p>",
        "id": 495976415,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1737905683
    },
    {
        "content": "<p>That would seem a bit arbitrary to me. Maybe we should fall back to using Π everywhere for data?<br>\nWorth noting in HoTT literature you'll see Π even for proofs (but their Props are not subsingletons).<br>\n<a href=\"/user_uploads/3121/jNgFkDJHIzzSLypwyYruvLem/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/jNgFkDJHIzzSLypwyYruvLem/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1578x1120\" src=\"/user_uploads/thumbnail/3121/jNgFkDJHIzzSLypwyYruvLem/image.png/840x560.webp\"></a></div>",
        "id": 495978929,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1737907594
    },
    {
        "content": "<p>that's nice for HoTT, but as i understand it lean is not HoTT based?</p>",
        "id": 495979158,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737907769
    },
    {
        "content": "<p>personally, i'd be fine with only using <code>∀</code>, even for what may be clearly data</p>",
        "id": 495979262,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737907835
    },
    {
        "content": "<p>I don't think it's data/not-data, I agree with <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> that if it should read \"for all <code>i</code> we have ...\" we use <code>∀</code> and if it should read \"product of all <code>X i</code> for <code>i : I</code>\" then use <code>Π</code>. In type theory I think it means the same and has even more basic syntax: <code>(i : I) → X i</code>. I'm guessing it was just readability (for mathematicians) to introduce both <code>Π</code> and <code>∀</code>.</p>\n<p>BTW, for terms we have to use \"the basic syntax\" <code>fun i =&gt; x i</code> anyway...</p>",
        "id": 495984245,
        "sender_full_name": "Michał Staromiejski",
        "timestamp": 1737911615
    },
    {
        "content": "<p>Yeah, I was going to write that my recommendation is:</p>\n<ul>\n<li>Use <code>∀ i, p i</code> for propositions</li>\n<li>Use <code>(x : X) → A x</code> for dependent functions</li>\n<li>Use <code>Π i, A i</code> for indexed products (note that this is mathlib-only notation)</li>\n</ul>\n<p>Sometimes it's more convenient writing <code>[∀ i, Algebra R (A i)]</code> since (1) you sort of think of \"<code>A i</code> is an algebra\" as a proposition and (2) the alternative using vanilla Lean is <code>[(i : _) → Algebra R (A i)]</code>, which has some extra symbols that make it harder to read.</p>",
        "id": 495986326,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737913161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.E2.88.80.20vs.2E.20.CE.A0/near/495979158\">said</a>:</p>\n<blockquote>\n<p>that's nice for HoTT, but as i understand it lean is not HoTT based?</p>\n</blockquote>\n<p>That page is about basic dependent type theory; it doesn't matter that it came from the HoTT book :-)</p>",
        "id": 495986413,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737913218
    },
    {
        "content": "<p>We added <code>Π i, A i</code> notation to mathlib because <code>Algebra R (Π i, A i)</code> is a lot more friendly to a mathematical reader than <code>Algebra R ((i : I) → A i)</code> (or worse, <code>Algebra R (∀ i, A i)</code> — try explaining that one to someone just getting into Lean!)</p>",
        "id": 495986599,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737913377
    },
    {
        "content": "<p>What exactly is the distinction between bullet points 2 and 3? Can we implement the rule to convert existing mathlib automatically?</p>",
        "id": 495986942,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1737913679
    },
    {
        "content": "<p>I think we could at least implement the rule to distinguish 1, and leave 2 vs 3 as a subjective stylistic decision</p>",
        "id": 495987009,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737913707
    },
    {
        "content": "<p>The distinction is how you think about it — somehow we all know that the product of algebras looks better with pi notation, but somehow also we all know that functions on Fin for example look better with dependent function notation.</p>",
        "id": 495987051,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737913753
    },
    {
        "content": "<p>(I don't have any concrete idea how to codify that difference.)</p>",
        "id": 495987187,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737913857
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> can you point to an example when vanilla-Lean syntax is used and would be preferred?</p>\n<p>Anyway, I have an impression that most of us agree that it is about how we want to read.</p>",
        "id": 495987377,
        "sender_full_name": "Michał Staromiejski",
        "timestamp": 1737913997
    },
    {
        "content": "<p>Random example: would you rather read</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">Π</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span>\n</code></pre></div>\n<p>The point of the vanilla Lean syntax is that it fits in perfectly well with plain arrow notation. You can make any of the arrows dependent by just giving one of the types a binder.</p>",
        "id": 495987630,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737914181
    },
    {
        "content": "<p>(Similarly, would you rather read <code>Σ i : I, X i</code> or <code>(i : I) × X i</code>? There are some cases where sigma might be more agreeable, but if you already know about products, dependent products are a small increase in complexity rather than an entirely new syntax.)</p>",
        "id": 495987722,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737914271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.E2.88.80.20vs.2E.20.CE.A0/near/495987630\">said</a>:</p>\n<blockquote>\n<p>Random example: would you rather read</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span>\n</code></pre></div>\n<p>or</p>\n<p><code>Π n m : Nat, n = m → Fin n → Fin m</code></p>\n</blockquote>\n<p>Hot take: Second one, because if I remove the type ascriptions I get <code>n → m → n = m → Fin n → Fin m</code> and it is nonsense to write a function from a natural number.</p>",
        "id": 495988579,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1737914907
    },
    {
        "content": "<p>I think I'd rather read <code>∀ n m : Nat, n = m → Fin n → Fin m</code>!</p>",
        "id": 495988655,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1737914978
    },
    {
        "content": "<p>More seriously, I dislike this new syntax for dependent functions because <code>(e : type)</code> stands for <code>e</code> everywhere else in Lean (meaning we can type-ascript any expression <code>e</code>) but here instead <code>(e : type)</code> stands for <code>type</code>!</p>",
        "id": 495988756,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1737915053
    },
    {
        "content": "<p><code>if h : p then ... else ... </code> and <code>for h : x in lst do ...</code> are some counterexamples to that</p>",
        "id": 495988902,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737915194
    },
    {
        "content": "<p>I am claiming that no, they are not. <code>if (h : p) then ... else ...</code> would be but I've never seen anyone write this so I don't even know whether it's valid syntax</p>",
        "id": 495988986,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1737915286
    },
    {
        "content": "<p>Editing-wise, in my experience sometimes you have a non-dependent function type and you realize you actually want to later use one of the parameters in the middle in a dependent way. With the new notation, it's <em>so</em> easy to modify the type, but with the forall/pi notation you have to do a larger-scale transformation.</p>",
        "id": 495988987,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737915289
    },
    {
        "content": "<p>That I agree, but dually it has happened to me that <code>α → β</code> doesn't quite mean what I want, so I do <code>(α : myType) → β</code> and suddenly get an obscure error. After a minute of staring at it, I finally think \"Oh\" and must do the larger scale transformation of writing <code>∀ _ : (α : myType), β</code></p>",
        "id": 495989231,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1737915499
    },
    {
        "content": "<p>do we need <code>(a &lt;: b)</code> and <code>(a :&gt; b)</code> notations?</p>",
        "id": 495990757,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737916778
    },
    {
        "content": "<p>(btw, i think this is a core lean question/issue, not a mathlib one)</p>",
        "id": 495990824,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737916813
    },
    {
        "content": "<p>or maybe do we want <code>(_ : α : myType)</code> to be a sensible notion in that case?</p>",
        "id": 495990907,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737916899
    },
    {
        "content": "<p>I think I'm missing something <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>. Is this an example involving a coercion? You could write <code>((α : myType)) → β</code> at least.</p>\n<p>That's admittedly a wart, this lack of compositionality with type ascriptions for coercion.</p>",
        "id": 495991126,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737917046
    },
    {
        "content": "<p>Friction with <code>:</code> aside, I love <code>(a : X) → …</code> conceptually. These things <em>are</em> functions, so I think it makes sense to write them as functions; having a unified syntax to reflect a unified concept is a really appealing to me. (I might go a step further and claim that being confronted with this fact is sometimes <em>good</em> for mathematicians, even if we’re used to thinking of these things exclusively as products! :) )</p>",
        "id": 495991333,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1737917252
    },
    {
        "content": "<p>Once you start to see <code>→</code> as something which can bind, I think it’s not so big a shift in the end, and at least <em>usually</em> unambiguous. The only case where it’s ambiguous is when <code>a</code> is a type or can be coerced to one, so maybe it makes sense to warn the user of this ambiguity in those cases (possibly behind an option, like autoimplicits).</p>",
        "id": 495991584,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1737917466
    },
    {
        "content": "<p>It seems possible to improve the error message in this case too</p>",
        "id": 495991673,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737917532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.E2.88.80.20vs.2E.20.CE.A0/near/495991126\">said</a>:</p>\n<blockquote>\n<p>I think I'm missing something @Yaël Dillies. Is this an example involving a coercion?</p>\n</blockquote>\n<p>Yes, that has come up in the form of me wanting to write a function <code>(s : Set α) → β</code> where <code>s : Finset α</code></p>",
        "id": 495991691,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1737917549
    },
    {
        "content": "<p>4 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/CoeSort.20for.20Finset\">#mathlib4 &gt; CoeSort for Finset</a> by <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span>.</p>",
        "id": 495992802,
        "sender_full_name": "Notification Bot",
        "timestamp": 1737918394
    },
    {
        "content": "<p>I agree with <code>∀</code> for propositions and <code>Π</code> for non-unique data. I prefer <code>Π</code> for all data, even if unique, but I'm willing to settle.</p>",
        "id": 496008385,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1737931007
    },
    {
        "content": "<p>I'm in strong support of <code>∀</code> for props, and <code>Π</code> for indexed products, and letting the context/author/conventions influence the middle ground.</p>",
        "id": 496125505,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1737985448
    },
    {
        "content": "<p>Following the discussion, I created a PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/21213\">#21213</a> with changes in <code>Algebra.Algebra.Pi</code>. I basically did the following:</p>\n<ul>\n<li>make consistent usage of <code>Π</code> and <code>∀</code></li>\n<li>rename variables</li>\n<li>use section variables</li>\n<li>use <code>Type*</code> instead of explicit universe variables.</li>\n</ul>\n<p>If this is what we all like, I could refactor other <code>Pi</code> files.</p>",
        "id": 496507443,
        "sender_full_name": "Michał Staromiejski",
        "timestamp": 1738144153
    },
    {
        "content": "<p>I think the first move after agreement should be a PR to the <a href=\"https://leanprover-community.github.io/contribute/style.html\">style guide</a> and only start refactor PRs based on decisions written down in the style guide</p>",
        "id": 496510694,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1738145130
    },
    {
        "content": "<p>The file required cleanup anyway. I posted in this topic because it is connected. But I agree, if we want the clear rules, let's write them down.</p>",
        "id": 496512071,
        "sender_full_name": "Michał Staromiejski",
        "timestamp": 1738145551
    },
    {
        "content": "<p>Also, I think the PR could serve as a material for any further discussion. After all, I don't think we'd write down the rules and refactor all the mathlib. <code>Algebra.Algebra.Pi</code> was the starting point of the discussion so it feels natural to try to clean it up.</p>",
        "id": 496512692,
        "sender_full_name": "Michał Staromiejski",
        "timestamp": 1738145758
    }
]