[
    {
        "content": "<p>Currently, the <code>CategoryTheory/Subobject</code> folder talks about two kind of \"morphisms\" between subobjects, those of the form <code>x ≤ y</code>, and those of the form <code>x ⟶ y</code>. It seems the former seems to be the intended way to talk about subobjects while the latter are a consequence that some of the operations are defined in terms of functors. Indeed, the <a href=\"https://github.com/leanprover-community/mathlib4/blob/de2995686cbdea3ba481fe421d46bb30b64aae06/Mathlib/CategoryTheory/Subobject/Basic.lean#L51\"><code>Subobject/Basic</code></a> lean file mentions:</p>\n<blockquote>\n<p>Currently we describe <code>pullback</code>, <code>map</code>, etc., as functors. It may be better to just say that they are monotone functions, and even avoid using categorical language entirely when describing <code>Subobject X</code>. (It's worth keeping this in mind in future use; it should be a relatively easy change here if it looks preferable.)</p>\n</blockquote>\n<p>The reason for this is clear, we usually want to show that <code>Subobject X</code> has some operation by showing first that <code>MonoOver X</code> has some corresponding operation, which is most naturally stated as a functor. Hence, in order to talk about the intend inequalities, we first have to decategorify a morphism <code>x ⟶ y</code>. This creates quite the overhead, as we would have to translate everything form category theory land to poset land, and some translations are missing, e.g. <a href=\"https://github.com/leanprover-community/mathlib4/blob/de2995686cbdea3ba481fe421d46bb30b64aae06/Mathlib/CategoryTheory/Subobject/Basic.lean#L697\">this</a>.</p>\n<p>Instead, I think the approach with lowest overhead is to talk only about category theory, and completely avoid the fact that <code>Subobject X</code> is a poset. That way all the results are in one single language and no translation is necessary. Of course, at some point we would like to e.g. say that <code>Subobject X</code>, as a poset, is a lattice; but this should then be a purely abstract consequence of the fact that it has finite (co)products, which should be stated in another file.</p>\n<hr>\n<p>Tldr; would a PR de-de-categorifying (≅ categorifying) the <code>Subobject</code> folder be accepted?</p>",
        "id": 537418526,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756885499
    },
    {
        "content": "<p>I do not think it is a good idea. One of the interests of <code>Subobject X</code> is that from an object <code>X</code> in a category, it produces a partially ordered type. For example, we have notions of artinian and noetherian objects which are defined using the order on <code>Subobject</code>. I believe it would be a mistake to reject the very good order API that we have, and which can express things which could be relatively ackward in the sole language of category theory.</p>",
        "id": 537424242,
        "sender_full_name": "Joël Riou",
        "timestamp": 1756887564
    },
    {
        "content": "<p>We currently do not use much of the functors/monotone maps involving <code>Subobject</code> types. As the remark suggests, we can keep in mind that using Galois connections instead of adjunctions could be an option if it turns out to become more convenient in the future.</p>",
        "id": 537424266,
        "sender_full_name": "Joël Riou",
        "timestamp": 1756887569
    },
    {
        "content": "<p>I just looked at the <code>Subobject/ArtenianObject</code> and <code>Suobject/NoetherianObject</code> files and in fact they exclusively use the category-based results! (Other than in saying e.g. <code>WellFoundedGT (Subobject X)</code>, as well as adding a <code>.monotone</code>/<code>.toOrderHom</code>/etc to a functor). So it seems to me that this rather supports my proposal. Even if it did use some stuff about the preorder, my suggestion is that the lemma would be in categorical language, so that any use of order stuff is a <code>leOfHom</code>/<code>.monotone</code>/<code>.toOrderHom</code>/etc away.</p>",
        "id": 537426020,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756888259
    },
    {
        "content": "<p>For some more context, this proposal comes from my experience formalizing for the <a href=\"https://github.com/kyoDralliam/model-theory-topos\">geometric logic project</a>, where it was very common that I was talking about subobjects in categorical language (again since that's the natural language when coming from MonoOvers, etc), but some results (e.g. <a href=\"https://github.com/leanprover-community/mathlib4/blob/de2995686cbdea3ba481fe421d46bb30b64aae06/Mathlib/CategoryTheory/Subobject/Lattice.lean#L201\">OrderTop</a>) were only in poset language, so I had to categorify them anyways.</p>",
        "id": 537427406,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756888722
    },
    {
        "content": "<p>I would agree that we need more API, but I am afraid I cannot continue this discussion seriously if you consider that when the most basic definition of a file uses the term <code>WellFoundedGT (Subobject X)</code> then it \"exclusively use the category-based results\".</p>",
        "id": 537428883,
        "sender_full_name": "Joël Riou",
        "timestamp": 1756889278
    },
    {
        "content": "<p>I think I did not explain well what I'm proposing, sorry about that. I'm not saying we should never consider <code>Subobject X</code> as a poset, this is definitely useful. What I'm saying is that when we are developing results specifically about subobjects, say in <code>Subobject/Basic.lean</code>, its content should never be using the order api. For a concrete example, we could change:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_of_comm</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subobject</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"bp\">.</span><span class=\"n\">arrow</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">arrow</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>So that the conclusion is <code>X ⟶ Y</code>. If we need this result, at some point, then we just use <code>.leOfHom</code>.</p>\n<p>My claim is that delaying the introduction of the order api (as above) will allow to not have to duplicate the api, while having an <em>almost</em> as good api for both languages (precisely, it will be just a <code>.leOfHom</code>/etc worse when working with the order api, compared to having both poset and category api). Part of the glue that should be there (and is) between the two languages includes the poset instance of <code>Subobject X</code>.</p>",
        "id": 537435228,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756891498
    },
    {
        "content": "<p>For another example, I'd ague against showing this in the <code>Subobject</code> folder</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">semilatticeInf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SemilatticeInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subobject</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>Instead, we can translate it to category language as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasBinaryProducts</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subobject</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>And then delay the introduction of order api by showing that <code>HasBinaryProducts</code> implies <code>SemilatticeInf</code> for a poset (which would then not reference Subobjects at all).</p>",
        "id": 537436493,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756891909
    },
    {
        "content": "<p>But surely this should go the other way around? Any inf-semilattice has binary products</p>",
        "id": 537436763,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756891997
    },
    {
        "content": "<p>This is also true, I'm PRing both statements <a href=\"https://github.com/leanprover-community/mathlib4/pull/29253\">here</a>. The point is that if we want to avoid duplication of api, one choice of language has to be made; for reasons I've explained above I suggest such choice should be the category language.</p>",
        "id": 537437028,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756892083
    },
    {
        "content": "<p>To clarify why I suggest that we want that <code>HasBinaryProducts</code> implies <code>SemilatticeInf</code> instead of the other way around: Currently the <code>SemilatticeInf</code> instance on subobjects is obtained by constructing a product in <code>MonoOver</code>, and then lowering this bifunctor to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">inf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subobject</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">Subobject</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">Subobject</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>and then showing that this bifunctor is the <code>inf</code>.</p>\n<p>Instead, with my suggestion this is unneeded. A one liner shows <code>Subobject</code> has products, from the fact that <code>MonoOver</code> has products, and so it immediately has an <code>inf</code>. This pattern reoccurs with all constructions.</p>",
        "id": 537464984,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756902606
    },
    {
        "content": "<p>does this mean typeclass search for <code>SemilatticeInf</code> will wander into category theory?</p>",
        "id": 537471713,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756904693
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"587858\">Fernando Chu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Proposal.3A.20Categorify.20the.20.60Subobject.60folder/near/537464984\">said</a>:</p>\n<blockquote>\n<p>To clarify why I suggest that we want that <code>HasBinaryProducts</code> implies <code>SemilatticeInf</code> instead of the other way around</p>\n</blockquote>\n<p>This is not going to work: <code>SemilatticeInf</code> contains data while <code>HasBinaryProducts</code> does not.</p>",
        "id": 537472035,
        "sender_full_name": "Joël Riou",
        "timestamp": 1756904777
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Proposal.3A.20Categorify.20the.20.60Subobject.60folder/near/537471713\">said</a>:</p>\n<blockquote>\n<p>does this mean typeclass search for <code>SemilatticeInf</code> will wander into category theory?</p>\n</blockquote>\n<p>Yeah this does seem a bit weird to me. We could have this as a def instead (which is what my other PR does).</p>",
        "id": 537472162,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756904820
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Proposal.3A.20Categorify.20the.20.60Subobject.60folder/near/537472035\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"587858\">Fernando Chu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Proposal.3A.20Categorify.20the.20.60Subobject.60folder/near/537464984\">said</a>:</p>\n<blockquote>\n<p>To clarify why I suggest that we want that <code>HasBinaryProducts</code> implies <code>SemilatticeInf</code> instead of the other way around</p>\n</blockquote>\n<p>This is not going to work: <code>SemilatticeInf</code> contains data while <code>HasBinaryProducts</code> does not.</p>\n</blockquote>\n<p>It does, in the sense that I can make this <a href=\"https://github.com/leanprover-community/mathlib4/pull/29253/files#diff-03a61afbfda964e4c8cc46fe3dc306cb2459f19b6cc65ae40128909a6431ca94R150\">definition</a>.</p>",
        "id": 537472397,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756904891
    },
    {
        "content": "<p>The <code>Limits.prod</code> already gets the data out of a <code>Prop</code>. It is true that with the current approach we get a specific <code>inf</code> whereas with the suggested change you a random one, but of course this does not matter, they are equal since <code>Subobject</code> is skeletal.</p>",
        "id": 537472769,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756905014
    },
    {
        "content": "<p>What do people think about merging the <code>to_dual</code> PR, adding some support to <code>to_additive</code> for removing universe parameters, making a new translation attribute <code>cat_to_ord</code>,  and then having this API in both forms automatically?</p>",
        "id": 537751353,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1757018832
    },
    {
        "content": "<p>Alternatively, we could allow <code>Prop</code> morphisms in category theory, making the two forms equal by <code>rfl</code>, but that is a whole different discussion.</p>",
        "id": 537753928,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1757019693
    }
]