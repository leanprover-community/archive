[
    {
        "content": "<p>I'm trying to revive my very <a href=\"https://github.com/leanprover-community/mathlib4/pull/8949\">old PR</a> adding a tactic which proves real inequalities by automatically deriving sufficiently good rational bounds. I don't like the original implementation strategy which was more of a proof of concept, I want to do something that looks more like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Approximator</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"n\">improve</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"n\">bounds</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">ℚ</span>\n<span class=\"w\">  </span><span class=\"n\">prove_lb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"c1\">-- : e ≥ ↑{mkRatExpr lb}</span>\n<span class=\"w\">  </span><span class=\"n\">prove_ub</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"c1\">-- : e ≤ ↑{mkRatExpr ub}</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ByApproxExt</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">build_approximator</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℝ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Approximator</span>\n</code></pre></div>\n<p>Basically I want to build a tree of <code>Approximators</code> which each keep state. This type of this state varies depending on the expression being approximated. Then I want to recursively improve the approximation at whichever node in the tree is most important to the overall error.</p>\n<p>I think this should all work, the problem is that this leads to <code>Approximator</code> being <code>Type 1</code>, which I can't really use inside a <code>MetaM</code> so it's very unclear to me whether I can do any of this in a tactic.</p>\n<p>Any advice?</p>",
        "id": 505862431,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1742055536
    },
    {
        "content": "<p>If you can make an inductive type that comprises all possible State types, that's one way around this. (Presumably not <em>every</em> type is a possible state.) It's less flexible though, if you want to be able to support adding new approximators for new kinds of expressions from outside the core module.</p>",
        "id": 505862706,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742055730
    },
    {
        "content": "<p>I'll try that. I'll make the expression-specific code be stateless and have a fixed state representing the approximations of the children.</p>",
        "id": 505863328,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1742056134
    },
    {
        "content": "<p>Or, there's an interface like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Approximation</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">improve</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Approximation</span>\n<span class=\"w\">  </span><span class=\"n\">bounds</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">ℚ</span>\n<span class=\"w\">  </span><span class=\"n\">prove_lb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n<span class=\"w\">  </span><span class=\"n\">prove_ub</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n</code></pre></div>\n<p>where the state is encapsulated in the function <code>improve</code>, so it doesn't cause a universe bump.</p>\n<p>You'll have to define <code>partial</code> approximations though I'm pretty sure.</p>\n<p>The tradeoff is \"make a universal state type, no need for <code>partial</code>\" vs \"can write flexible approximators more directly, but need <code>partial</code>, so no guarantee the meta code will terminate\". It's meta code though, and <code>partial</code> doesn't cause any soundness issues for the generated proofs.</p>",
        "id": 505863338,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742056140
    },
    {
        "content": "<p>Ok I'll try both approaches thanks</p>",
        "id": 505863460,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1742056217
    },
    {
        "content": "<p>One more:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Approximation</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">improve</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Approximation</span>\n<span class=\"w\">  </span><span class=\"n\">bounds</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">ℚ</span>\n<span class=\"w\">  </span><span class=\"n\">prove_lb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n<span class=\"w\">  </span><span class=\"n\">prove_ub</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n</code></pre></div>\n<p>The <code>MetaM</code> is enough to defer computing the next approximation, plus it lets the system use MetaM, if you want. This also lets you defer computing the lb and ub proofs and use MetaM to construct them.</p>",
        "id": 505863708,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742056357
    },
    {
        "content": "<p>That last approach looks great but when I try it doesn't compile.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">ByApprox</span><span class=\"bp\">.</span><span class=\"n\">Approximation</span><span class=\"bp\">.</span><span class=\"n\">mk'</span><span class=\"w\"> </span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">non</span><span class=\"w\"> </span><span class=\"n\">valid</span><span class=\"w\"> </span><span class=\"n\">occurrence</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">datatypes</span><span class=\"w\"> </span><span class=\"n\">being</span><span class=\"w\"> </span><span class=\"n\">declaredLean</span><span class=\"w\"> </span><span class=\"mi\">4</span>\n</code></pre></div>\n<p>Do I need to tell it somehow not to pass the type to the kernel?</p>",
        "id": 505865836,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1742057853
    },
    {
        "content": "<p>I guess I can mark everything unsafe, but presumably that is undesirable?</p>",
        "id": 505867140,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1742058774
    },
    {
        "content": "<p>I'll note that <a href=\"https://github.com/leanprover/lean4/pull/3011\">lean4#3011</a> suggests steps towards making using <code>Type 1</code> legal inside MetaM, but I don't think there's much appetite for it</p>",
        "id": 505867281,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742058879
    },
    {
        "content": "<p>I'd love it if the less controversial <a href=\"https://github.com/leanprover/lean4/pull/3010\">lean4#3010</a> could be merged though</p>",
        "id": 505867340,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742058941
    },
    {
        "content": "<p>Oh, sorry Sebastian, with the last example I forgot that this kind of recursion isn't allowed.</p>\n<p>It's possible to mark it <code>unsafe</code>. I think the main consequence is that everything that mentions <code>Approximation</code> then has to be marked <code>unsafe</code> too. None of the meta code would be kernel checked.</p>",
        "id": 505868055,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742059460
    },
    {
        "content": "<p>i) Would marking this code <code>unsafe</code> be a usability issue for people using the tactic?<br>\nii) Is there any easy way to mark an entire module unsafe?</p>",
        "id": 505868327,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1742059660
    },
    {
        "content": "<p>i) No<br>\nii) I'm not sure</p>",
        "id": 505868453,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1742059744
    }
]