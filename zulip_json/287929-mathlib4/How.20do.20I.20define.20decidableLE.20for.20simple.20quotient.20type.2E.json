[
    {
        "content": "<p>I am implementing my own version of the Integers in lean4 just for the practice.  I define the Integers as an quotient of ordered pairs of Naturals numbers with an appropriate equivalence relation.   I am following the <code>Zmod37</code> <a href=\"https://github.com/ImperialCollegeLondon/formalising-mathematics-2022/tree/master/src/section06quotients\">example</a> set forward in Kevin Buzzard's \"Formalizing Mathematics\" <a href=\"https://github.com/ImperialCollegeLondon/formalising-mathematics-2022\">class</a>.   </p>\n<p>I have a most of the results I need to claim that my integer class is a linear order.  But I am stuck trying to show the <code>DecidableLE</code> (and most likely the <code>DecidableEQ</code>) field in the struct.  The relevant code is a follows</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">N2</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span>\n\n<span class=\"c1\">--my equivalence relation</span>\n<span class=\"kd\">def</span> <span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"n\">cd</span> <span class=\"o\">:</span> <span class=\"n\">N2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ab.1</span> <span class=\"bp\">+</span> <span class=\"n\">cd.2</span> <span class=\"bp\">=</span> <span class=\"n\">ab.2</span> <span class=\"bp\">+</span> <span class=\"n\">cd.1</span>\n\n<span class=\"c1\">--the \"sorry\" here is the omitted proof that `rel` is indeed an equivalence relation</span>\n<span class=\"kd\">instance</span> <span class=\"n\">mysetoid</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">N2</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">rel</span><span class=\"o\">,</span><span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">mysetoid</span>\n<span class=\"kd\">def</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient</span> <span class=\"n\">mysetoid</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">Z</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">le_aux</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"n\">cd</span> <span class=\"o\">:</span> <span class=\"n\">N2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">ab.fst</span> <span class=\"bp\">+</span> <span class=\"n\">cd.snd</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">=</span>  <span class=\"o\">(</span><span class=\"n\">cd.fst</span> <span class=\"bp\">+</span> <span class=\"n\">ab.snd</span><span class=\"o\">)</span>\n\n<span class=\"c1\">--here we lift that aux definition to the Quotient.</span>\n<span class=\"kd\">def</span> <span class=\"n\">le</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Quotient.lift₂</span> <span class=\"n\">le_aux</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">a10</span><span class=\"o\">,</span><span class=\"n\">a11</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">b10</span><span class=\"o\">,</span><span class=\"n\">b11</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">a20</span><span class=\"o\">,</span><span class=\"n\">a21</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">b20</span><span class=\"o\">,</span><span class=\"n\">b21</span><span class=\"o\">⟩</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">--I have the proof that goes here</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">le</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"c1\">--I have most of the proofs needed here</span>\n  <span class=\"n\">decidableLE</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">--what do I do here?</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>It seems that since my <code>le_aux</code> is decidable, (it is equivalent to saying that <code>ab.fst + cd.snd ≤ cd.fst + ab.snd</code> ) it should be straight-forward to claim that le is decidable.  I don't know how to do this though.</p>\n<p>Please let me know if this is the incorrect board to post this question.  I appreciate any pointers. </p>\n<p>I am using Lean version 4.0.0-nightly-2023-06-20, commit a44dd71ad62a</p>",
        "id": 375102102,
        "sender_full_name": "Kent Van Vels",
        "timestamp": 1689298203
    },
    {
        "content": "<p>Why not define <code>le_aux</code> as <code>ab.1 + cd.1 ≤ cd.1 + ab.2</code>?</p>",
        "id": 375106909,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689300747
    },
    {
        "content": "<p>As for the original question, you can do induction on both arguments (or just <code>rintro</code> them).</p>",
        "id": 375107143,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689300892
    },
    {
        "content": "<p>Then your goal will be defeq <code>Decidable (le_aux a b)</code></p>",
        "id": 375107181,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689300908
    },
    {
        "content": "<p>I originally did, I thought this would be easier/better for some reason. </p>\n<p>I just changed it back, and I still need to define <code>decidableLE</code></p>",
        "id": 375108684,
        "sender_full_name": "Kent Van Vels",
        "timestamp": 1689301784
    },
    {
        "content": "<p>I didn't see your 2nd and third posts.  After <code>rintro</code>ing a an b ,I get a goal of <code>Decidable (a ≤ b)</code>, where <code>a</code> and <code>b</code> are in <code>Z</code>, not <code>N2</code>.  (I don't get  a goal of <code>Decidable (le_aux a b)</code> )      I tried using <br>\n<code>induction' a using Quotient.inductionOn with aa</code> as I used that incantation for my other proofs but it complains of a type mismatch.</p>",
        "id": 375109642,
        "sender_full_name": "Kent Van Vels",
        "timestamp": 1689302336
    },
    {
        "content": "<p>You can <code>rintro ⟨a⟩ ⟨b⟩; change Decidable (le_aux a b)</code></p>",
        "id": 375111035,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689303128
    },
    {
        "content": "<p>You can also use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient#doc\">docs#Quotient</a>.lift₂.decidablePred</p>",
        "id": 375111243,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689303292
    },
    {
        "content": "<p>linkifier failed: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Quot.html#Quotient.lift%E2%82%82.decidablePred\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Quot.html#Quotient.lift%E2%82%82.decidablePred</a></p>",
        "id": 375111389,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689303366
    },
    {
        "content": "<p>Thanks for your help and your looking into this.  Unfortunately, when I do <code>rintro ⟨a⟩ ⟨b⟩</code>, it complains of an invalid constructor.  And if I do <code>intro a b</code> instead, then <code>a</code> and <code>b</code>are <code>Z</code>'s not <code>N2</code>'s (so I can't change the goal to <code>le_aux a b</code>.  I can't find <code>Quotient.lift₂.decidablePred</code> used anywhere in Mathlib, so I don't know how it is supposed to be used.  Do you have any ideas?</p>",
        "id": 375120897,
        "sender_full_name": "Kent Van Vels",
        "timestamp": 1689308954
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Order.Basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">N2</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span>\n\n<span class=\"c1\">--my equivalence relation</span>\n<span class=\"kd\">def</span> <span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"n\">cd</span> <span class=\"o\">:</span> <span class=\"n\">N2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ab.1</span> <span class=\"bp\">+</span> <span class=\"n\">cd.2</span> <span class=\"bp\">=</span> <span class=\"n\">ab.2</span> <span class=\"bp\">+</span> <span class=\"n\">cd.1</span>\n\n<span class=\"c1\">--the \"sorry\" here is the omitted proof that `rel` is indeed an equivalence relation</span>\n<span class=\"kd\">instance</span> <span class=\"n\">mysetoid</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">N2</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">rel</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">add_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">rel</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">eq_comm</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">}</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"bp\">↦</span> <span class=\"n\">add_left_cancel</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">y.1</span> <span class=\"bp\">+</span> <span class=\"n\">y.2</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n    <span class=\"n\">convert</span> <span class=\"n\">congr_arg₂</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"n\">using</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">add_left_comm</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">]⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient</span> <span class=\"n\">mysetoid</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">le_aux</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"n\">cd</span> <span class=\"o\">:</span> <span class=\"n\">N2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">ab.1</span> <span class=\"bp\">+</span> <span class=\"n\">cd.2</span> <span class=\"bp\">≤</span> <span class=\"n\">ab.2</span> <span class=\"bp\">+</span> <span class=\"n\">cd.1</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"n\">le_aux</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">inferInstanceAs</span> <span class=\"o\">(</span><span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">le_aux_quot</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">N2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hac</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≈</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hbd</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≈</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">le_aux</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">le_aux</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">change</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span> <span class=\"n\">at</span> <span class=\"n\">hac</span> <span class=\"n\">hbd</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">le_aux</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_le_add_iff_right</span> <span class=\"o\">(</span><span class=\"n\">c.2</span> <span class=\"bp\">+</span> <span class=\"n\">d.1</span><span class=\"o\">),</span> <span class=\"n\">add_add_add_comm</span><span class=\"o\">,</span> <span class=\"n\">hac</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hbd</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_le_add_iff_left</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_left_comm</span><span class=\"o\">,</span> <span class=\"n\">add_le_add_iff_left</span><span class=\"o\">,</span> <span class=\"n\">le_aux</span><span class=\"o\">]</span>\n\n<span class=\"c1\">--here we lift that aux definition to the Quotient.</span>\n<span class=\"kd\">def</span> <span class=\"n\">le</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient.lift₂</span> <span class=\"n\">le_aux</span> <span class=\"n\">le_aux_quot</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient.lift₂.decidablePred</span> <span class=\"n\">_</span> <span class=\"n\">le_aux_quot</span>\n</code></pre></div>",
        "id": 375128601,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689312785
    },
    {
        "content": "<p>Thank you.  I am going to sleep now, but I will look at this in the morning.  I really appreciate it!</p>",
        "id": 375129729,
        "sender_full_name": "Kent Van Vels",
        "timestamp": 1689313323
    },
    {
        "content": "<p>I got that part working. I truly do appreciate your help.  Now,  I am trying to show the following </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">myDecEq</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(this is what the field <code>decidableEq</code> requires in <code>LinearOrder</code>)  I have tried using the normal tactics of <code>induction' a using Quotient.inductionOn with aa</code> but it complains about that.  I appreciate any help.</p>",
        "id": 375373125,
        "sender_full_name": "Kent Van Vels",
        "timestamp": 1689364173
    },
    {
        "content": "<p>There's already an instance for this, but you have to write some instances to unfold the definition for Lean to see it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"n\">cd</span> <span class=\"o\">:</span> <span class=\"n\">N2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"bp\">≈</span> <span class=\"n\">cd</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstanceAs</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstanceAs</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">DecidableEq</span> <span class=\"o\">(</span><span class=\"n\">Quotient</span> <span class=\"n\">mysetoid</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 375376719,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689364985
    },
    {
        "content": "<p>The first one says \"the setoid relation is decidable because it's defined using natural number equality\" and this is fed <br>\n implicitly into the second one, which is getting it to see that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instDecidableEqQuotient#doc\">docs#instDecidableEqQuotient</a> applies</p>",
        "id": 375377154,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689365079
    },
    {
        "content": "<p>Thank you. I appreciate it.</p>",
        "id": 375379105,
        "sender_full_name": "Kent Van Vels",
        "timestamp": 1689365526
    }
]