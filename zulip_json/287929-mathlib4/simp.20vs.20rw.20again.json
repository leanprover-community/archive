[
    {
        "content": "<p>Still porting the sphere eversion project, I have a new example where <code>simp</code> is not working a <em>very</em> innocent looking goal, but <code>rw</code> works. The following is a SE-free example but it is not Mathlib-free.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.NormedSpace.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Calculus.FDeriv.Basic</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">OneJet</span> <span class=\"o\">:=</span>\n  <span class=\"n\">E</span> <span class=\"bp\">×</span> <span class=\"n\">F</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">RelLoc</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">OneJet</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">×</span> <span class=\"n\">F</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">RelLoc</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">delta</span> <span class=\"n\">RelLoc</span><span class=\"bp\">;</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">P</span> <span class=\"n\">F</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">oneJetSnd</span> <span class=\"o\">:</span> <span class=\"n\">OneJet</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">×</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">OneJet</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"o\">(</span><span class=\"n\">p.1.2</span><span class=\"o\">,</span> <span class=\"n\">p.2.1</span><span class=\"o\">,</span> <span class=\"n\">p.2.2</span> <span class=\"bp\">∘</span><span class=\"n\">L</span> <span class=\"n\">fderiv</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">p.1.1</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"n\">p.1.2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">RelLoc.relativize</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">RelLoc</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">RelLoc</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">×</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"n\">oneJetSnd</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">R</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">RelLoc</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">RelLoc.mem_relativize</span>  <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">OneJet</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">×</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">R.relativize</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">w.1.2</span><span class=\"o\">,</span> <span class=\"n\">w.2.1</span><span class=\"o\">,</span> <span class=\"n\">w.2.2</span> <span class=\"bp\">∘</span><span class=\"n\">L</span> <span class=\"n\">ContinuousLinearMap.inr</span> <span class=\"n\">ℝ</span> <span class=\"n\">P</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">RelLoc.relativize</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_preimage</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">oneJetSnd_eq</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 390975879,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694708014
    },
    {
        "content": "<p>The goal is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">oneJetSnd</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">R</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">w.fst.snd</span><span class=\"o\">,</span> <span class=\"n\">w.snd.fst</span><span class=\"o\">,</span> <span class=\"n\">ContinuousLinearMap.comp</span> <span class=\"n\">w.snd.snd</span> <span class=\"o\">(</span><span class=\"n\">ContinuousLinearMap.inr</span> <span class=\"n\">ℝ</span> <span class=\"n\">P</span> <span class=\"n\">E</span><span class=\"o\">))</span> <span class=\"bp\">∈</span> <span class=\"n\">R</span>\n</code></pre></div>\n<p>but <code>simp only [Set.mem_preimage]</code> fails.</p>",
        "id": 390976041,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694708065
    },
    {
        "content": "<p>Note there is no coercion to function involved. <code>oneJetSnd</code> is a honest (non-dependent) function.</p>",
        "id": 390976149,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694708102
    },
    {
        "content": "<p>Here's a start:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Image</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">OneJet</span> <span class=\"o\">:=</span>\n  <span class=\"n\">E</span> <span class=\"bp\">×</span> <span class=\"n\">F</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">RelLoc</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">OneJet</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">short_name</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">×</span> <span class=\"n\">F</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">RelLoc</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">delta</span> <span class=\"n\">RelLoc</span><span class=\"bp\">;</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">P</span> <span class=\"n\">F</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">oneJetSnd</span> <span class=\"o\">:</span> <span class=\"n\">OneJet</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">×</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">OneJet</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"o\">(</span><span class=\"n\">p.1.2</span><span class=\"o\">,</span> <span class=\"n\">p.2.1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p.2.1</span><span class=\"o\">))</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">RelLoc.relativize</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">RelLoc</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">RelLoc</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">×</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"n\">oneJetSnd</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">R</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">RelLoc</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">RelLoc.mem_relativize</span>  <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">OneJet</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">×</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">R.relativize</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">w.1.2</span><span class=\"o\">,</span> <span class=\"n\">w.2.1</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">w.2.1</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">RelLoc.relativize</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_preimage</span><span class=\"o\">]</span> <span class=\"c1\">-- fails</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_preimage</span><span class=\"o\">]</span> <span class=\"c1\">-- works</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 391001323,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694717957
    },
    {
        "content": "<p>I am still confused about the last two :(</p>",
        "id": 391001714,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694718080
    },
    {
        "content": "<p>Heh :-)</p>\n<p>OK, mathlib-free:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">setOf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">p</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">Mem</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">s</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">Set.Mem</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">preimage</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">setOf</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"s2\">\" ⁻¹' \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">preimage</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mem_preimage</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">OneJet</span> <span class=\"o\">:=</span>\n  <span class=\"n\">E</span> <span class=\"bp\">×</span> <span class=\"n\">F</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">RelLoc</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">OneJet</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">short_name</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">×</span> <span class=\"n\">F</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">RelLoc</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">delta</span> <span class=\"n\">RelLoc</span><span class=\"bp\">;</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">P</span> <span class=\"n\">F</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">oneJetSnd</span> <span class=\"o\">:</span> <span class=\"n\">OneJet</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">×</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">OneJet</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"o\">(</span><span class=\"n\">p.1.2</span><span class=\"o\">,</span> <span class=\"n\">p.2.1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p.2.1</span><span class=\"o\">))</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">RelLoc.relativize</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">RelLoc</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">RelLoc</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">×</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"n\">oneJetSnd</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">R</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">RelLoc</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">RelLoc.mem_relativize</span>  <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">OneJet</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">×</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">R.relativize</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">w.1.2</span><span class=\"o\">,</span> <span class=\"n\">w.2.1</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">w.2.1</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">RelLoc.relativize</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_preimage</span><span class=\"o\">]</span> <span class=\"c1\">-- fails</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_preimage</span><span class=\"o\">]</span> <span class=\"c1\">-- works</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 391002418,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694718379
    },
    {
        "content": "<p>Thanks Kevin!</p>",
        "id": 391003153,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694718703
    },
    {
        "content": "<p><code>abbrev RelLoc</code></p>",
        "id": 391011183,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694722260
    },
    {
        "content": "<p>Yeah but that still doesn't explain what's going on :-/</p>",
        "id": 391023148,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694728150
    },
    {
        "content": "<p>Ok, I think the care is less about why <code>simp</code> does what it does now but whether the following statement should be valid: </p>\n<p>Whenever <code>rw [h]</code> applies so should <code>simp only [h]</code>.</p>",
        "id": 391166323,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694783219
    },
    {
        "content": "<p>There is also the statement: \"simp should be able to do whatever it could do in Lean 3\".</p>",
        "id": 391167535,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694783558
    },
    {
        "content": "<p>Of course I'm currently porting Lean 3 code, so I get to see explicitly only regressions. But I would still be very much afraid of starting a new ambitious project with the current Lean 4 simp.</p>",
        "id": 391167653,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1694783604
    },
    {
        "content": "<p>I chose the most anodyne version :)</p>",
        "id": 391168375,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694783800
    },
    {
        "content": "<p>Since this smells like an RFC, should I make a poll on <a class=\"stream\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4\">#lean4</a> ?</p>",
        "id": 391168515,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694783850
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.20vs.20rw.20again/near/391166323\">said</a>:</p>\n<blockquote>\n<p>Whenever <code>rw [h]</code> applies so should <code>simp only [h]</code>.</p>\n</blockquote>\n<p>This is false in Lean3 and Lean4 if <code>h</code> has hypotheses that create side goals</p>",
        "id": 391256966,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694809751
    },
    {
        "content": "<p>Yael pointed that out in the other thread and I don't think you want to change that</p>",
        "id": 391257354,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694809824
    },
    {
        "content": "<p>Hot take: I think this is working as intended</p>",
        "id": 391257935,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694809922
    },
    {
        "content": "<p>The problem is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">RelLoc</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">OneJet</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which says \"let me make a new type, that's implemented with <code>Set</code>\". But then you try and use <code>Set.preimage</code> on <code>RelLoc</code>, which is defeq-abusing nonsense that <code>simp</code> won't put up with.</p>\n<p>If you change it to an <code>abbrev</code> then everything is fine.</p>",
        "id": 391258656,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694810045
    },
    {
        "content": "<p>If <code>rw</code> works then why shouldn't <code>simp</code>? This is a regression, regardless of this reasoning, right?</p>",
        "id": 391259973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694810509
    },
    {
        "content": "<p>Here's a smaller mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- mathlib-like setup</span>\n<span class=\"kd\">def</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">setOf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Set</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">Mem</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">s</span> <span class=\"n\">a</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">mem</span> <span class=\"o\">:=</span> <span class=\"n\">Set.Mem</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">preimage</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">setOf</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"s2\">\" ⁻¹' \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">preimage</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">mem_preimage</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">SetWrapper</span> <span class=\"o\">:=</span> <span class=\"n\">Set</span> <span class=\"n\">E</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instMem</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"o\">(</span><span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">SetWrapper</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">delta</span> <span class=\"n\">SetWrapper</span><span class=\"bp\">;</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"c1\">-- this def has defeq abuse in its implementation and should not be unfolded</span>\n<span class=\"kd\">def</span> <span class=\"n\">preimageWrapper</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">SetWrapper</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">SetWrapper</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"n\">id</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">RelLoc.mem_relativize</span>  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">SetWrapper</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">preimageWrapper</span> <span class=\"n\">_</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">preimageWrapper</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_preimage</span><span class=\"o\">]</span> <span class=\"c1\">-- fails</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_preimage</span><span class=\"o\">]</span> <span class=\"c1\">-- works</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 391260816,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694810928
    },
    {
        "content": "<p>The key piece here is that we're doing lots of messy casting between defeq-but-not-reducibly-equal types</p>",
        "id": 391260848,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694810950
    },
    {
        "content": "<p>I am still very unclear about why one of <code>rw</code> and <code>simp</code> should work, but not the other. What is one tactic doing that the other cannot and, more to the point, why?</p>",
        "id": 391274215,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694817111
    },
    {
        "content": "<p>I understand the defeq abuse issue, what I don't understand is why this causes different behaviour in the two tactics.</p>",
        "id": 391274347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694817159
    },
    {
        "content": "<p>My mental model of <code>simp</code> is that it's \"repeat for h in list_of_all_lemmas_tagged_simp, try rw [h]\" and I'm trying to work out what it should be.</p>",
        "id": 391275147,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694817495
    },
    {
        "content": "<p>I think probably there is a <code>DiscrTree</code> lookup for <code>simp</code> but not <code>rw</code></p>",
        "id": 391276780,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694818001
    },
    {
        "content": "<p>Yeah but I have no real idea what a discrimination tree is.  My vague mental model is that it's \"a good way of deciding which order to try the simp lemmas\" and in particular is shredding no light on the question of why some defeq abuse is allowed by <code>rw</code> but not <code>simp</code>. </p>\n<p>Aah! Are you saying that the discrimination tree is deciding that it's not going to try rewriting the lemma at all because it doesn't match?</p>\n<p>Is it possible to find out if the lemma is not being rewritten by <code>simp</code> \"because of a failure at the discrimination tree stage\" or does this make no sense?</p>\n<p>(I'm also aware that another difference between simp and rw is how they might handle conditional lemmas but I'm assuming that this is not relevant in this example)</p>",
        "id": 391330901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694841855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.20vs.20rw.20again/near/391274215\">said</a>:</p>\n<blockquote>\n<p>more to the point, why?</p>\n</blockquote>\n<p>I think the idea is that <code>rw</code> is a tactic that <em>must</em> be able to apply the lemma it's been given, but <code>simp</code> is a tactic that is expected to efficiently figure out which lemma from the whole <code>@[simp]</code> set could apply. This \"discrimination tree\" business in other words is \"simp has a database of simp lemmas keyed by expressions, where given an expression it can quickly give come up with a list of lemmas whose LHS matches.\" It looks things up mostly syntactically, though it can handle a little bit of defeq.</p>",
        "id": 391348824,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1694853011
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.20vs.20rw.20again/near/391275147\">said</a>:</p>\n<blockquote>\n<p>My mental model of <code>simp</code> is that it's \"repeat for h in list_of_all_lemmas_tagged_simp, try rw [h]\" and I'm trying to work out what it should be.</p>\n</blockquote>\n<p>That's not an accurate mental model (two observable differences: (1) <code>rw</code> is less powerful under binders (2) you can use <code>simp</code> sometimes to avoid \"motive is not type correct\"). Both <code>simp</code> and <code>rw</code> have some overlap but they use completely different algorithms.</p>\n<ol>\n<li>\n<p>What <code>rw</code> does: it computes a \"key\" from the LHS of the lemma (like in a function application, the head constant) using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr.toHeadIndex#doc\">docs#Lean.Expr.toHeadIndex</a>, and then it looks for all subexpressions in the goal with that key which are defeq to the LHS using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.kabstract#doc\">docs#Lean.Meta.kabstract</a>. This function punches holes into goal whenever there were matches, creates a lambda function <code>f</code> from this (the \"motive\"), uses this to prove <code>h : f LHS = f RHS</code>, and then basically does <code>apply cast h.symm</code>.</p>\n</li>\n<li>\n<p>What <code>simp</code> does: it basically uses <code>conv</code> to navigate into every part of an expression (using \"congruence lemmas\" like <code>funext</code>, <code>congr</code>, etc.), and then while it's at every given subexpression it looks for a relevant lemma <code>h</code> and tries doing <code>apply h</code>.</p>\n</li>\n</ol>",
        "id": 391348828,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1694853016
    },
    {
        "content": "<p>Here's a short version of the differences, to point out how <code>rw</code> and <code>simp</code> match up \"one\" and \"many\" with \"lemma\" and \"subexpression\" in both ways:</p>\n<ul>\n<li><code>rw</code> tries using the \"kabstract\" algorithm to find all matching subexpressions in the goal given the LHS pattern of a single rw lemma.</li>\n<li><code>simp</code> tries using this \"congruence lemma\" algorithm to find all matching simp lemmas given a single subexpression in the goal.</li>\n</ul>",
        "id": 391348854,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1694853036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.20vs.20rw.20again/near/391166323\">said</a>:</p>\n<blockquote>\n<p>Whenever <code>rw [h]</code> applies so should <code>simp only [h]</code>.</p>\n</blockquote>\n<p>Even if <code>simp</code> tried every <code>simp</code> lemma in the simp set, rather than only the ones it thinks might match (maybe by using the key system that rw uses to be a little more efficient), there would be examples where <code>rw</code> works but <code>simp</code> doesn't and vice versa. One reason is that <code>rw</code> rewrites all matches simultaneously but <code>simp</code> can only rewrite one at a time, which might not be possible since intermediate rewrites might not typecheck. Another is that there are places in an expression that <code>simp</code> might be too conservative due to its congruence lemma algorithm and it will only try <code>rfl</code> lemmas, where <code>rw</code> doesn't have that restriction and will try anyway (with \"motive not type correct\" if it didn't work out).</p>",
        "id": 391350024,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1694853750
    },
    {
        "content": "<p>One remark that you may confirm, just to check I understand the underlying  dynamics  : when given only one lemma ‘rw‘ will find the first applicable instance, deduce the arguments and then rewrite with those arguments at all possible places. But these places will necessarily be disjoint.<br>\nOn the other hand, ‘simp‘ similarly applies at the first applicable instance, but then starts again and it may apply either at a one of the initial possible instances (those where  ‘rw‘ would have applied), or to an earlier instance, and that one might have been created by the first application of ‘simp‘.</p>",
        "id": 397375174,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1697658890
    }
]