[
    {
        "content": "<p>I would like to start a discussion whether <code>aesop</code> should unfold semireducible definitions. I think it shouldn't (by default), and wrote this in an RFC <a href=\"https://github.com/leanprover-community/aesop/pull/146\">aesop#146</a>. I am reposting here for more visibility.</p>\n<p>I don't use <code>aesop</code> myself all that much, so others with more experience might have a different view than I do, but below is my viewpoint.</p>\n<p>I think <code>aesop</code> (and all other automation) should apply lemmas up to instances transparency by default. Otherwise, I don't think it is possible to make performant automation. <br>\nIt is unreasonable to expect automation to be quick if it can unfold almost any definitions, and experimentally, sometimes <code>apply ...</code> takes seconds to fail (even if the lemma \"obviously\" doesn't apply). Sure, in those cases we could do better in Mathlib, marking more things irreducible, but we cannot only fix in on Mathlib's side.</p>\n<p>My experience is that aesop is often very slow, and there have been multiple PRs to Mathlib moving away from aesop because of performance reasons: <a href=\"https://github.com/leanprover-community/mathlib4/pull/13769\">1</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/13959\">2</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/13993\">3</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/12541\">4</a>. I am assuming this is because of the transparency of <code>apply</code> rules, but maybe I'm wrong there.</p>\n<p>This will lead to a regression in capabilities of <code>aesop</code> and we will need to mark more things as unfoldable by aesop. Maybe specialized tactics like <code>aesop_cat</code> can work up to semireducible transparency.</p>\n<p>I already talked to <span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> about this in person, but I never wrote up the suggestion on Zulip/Github.</p>",
        "id": 450144286,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720525405
    },
    {
        "content": "<p>In principle, I agree. Is it as simple as sprinkling a few <code>withReducibleAndInstances</code>? (Before the fallout)</p>",
        "id": 450145193,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720525591
    },
    {
        "content": "<p>Re <code>aesop_cat</code>: this replacement is also happening there as <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> has experienced</p>",
        "id": 450146261,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720525825
    },
    {
        "content": "<p>Proofs change to <code>ext; simp</code> or just <code>rfl</code> and speed up geometrically which comports with transparency being the difference</p>",
        "id": 450146538,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720525901
    },
    {
        "content": "<p>I'm not opposed to this at all. I think design-wise it would make a lot of sense for all 'automation' tactics (which is a bit of an ill-defined category, but probably clear enough in practice) to standardise on one transparency.</p>\n<p>I'm not clear on whether this transparency should be <code>instances</code> or <code>reducible</code>. At the moment, Aesop's indexing is up to <code>reducible</code> transparency, but when indexing succeeds, the rules are run at <code>default</code> transparency. I'm not sure whether the <code>DiscrTree</code> supports <code>instances</code> transparency, but I guess it should.</p>\n<p>Aesop already allows the transparencies of all rules to be adjusted, so it would be fairly easy to check how much of Mathlib breaks at different transparency settings.</p>\n<p>With all that said, the slowness in the linked PRs does not seem to be caused by the transparency of <code>apply</code>. One of the PRs effectively replaces <code>simp_all</code> (run by Aesop) with <code>simp_all only [...]</code>. The other three replace <code>aesop</code>-based <code>continuity</code> with <code>fun_prop</code>. The latter has three advantages:</p>\n<ul>\n<li>It uses a discrimination tree that efficiently supports some fragment of higher-order unification. This is useful because <em>all</em> <code>continuity</code> goals are higher-order since the goal contains a function. Core's discrimination tree, which Aesop uses, makes no attempt at higher-order unification, so for a goal <code>Continuous f</code> it returns every lemma with conclusion <code>Continuous _</code> as a possible match, regardless of the shape of <code>f</code>. As a result, <code>continuity</code> rules are effectively unindexed. However, it's not clear to me whether the <code>fun_prop</code> discrimination tree preserves the completeness of indexing; that's why I never switched to it. (cc <span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span>)</li>\n<li><code>aesop</code> runs a lot of built-in rules which are unlikely to be useful for <code>continuity</code>. In particular, it frequently <code>simp</code>s intermediate goals, which is very costly. It would be easy to disable these built-in rules in <code>continuity</code>, at the cost of some inevitable breakage.</li>\n<li><code>fun_prop</code> is restricted to lemmas of particular shapes, which gives it more optimisation opportunities. I've never looked into this in detail, though.</li>\n</ul>\n<p>When Aesop is slow, my first guess would be that its repeated <code>simp</code> calls are the cause. A student of mine is currently working towards better caching of <code>simp</code> in Aesop, but it's hard.</p>",
        "id": 450165890,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1720530117
    },
    {
        "content": "<p>Discrimination trees index up to <code>reducible</code> transparency. <del>I think it makes little difference with the <code>instances</code> transparency, because instance arguments are always indexed with a star (so they are ignored).</del></p>",
        "id": 450236911,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1720546296
    },
    {
        "content": "<p>I presume that with completeness you mean that whenever two terms unify in <code>reducible</code> transparency, then they will unify in the discrimination tree. I think if core's <code>DiscrTree</code> has this, then my <code>RefinedDiscrTree</code> should as well.</p>",
        "id": 450237063,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1720546326
    },
    {
        "content": "<p>I thought the instance projections were intentionally not unfolded for indexing the keys</p>",
        "id": 450237136,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720546346
    },
    {
        "content": "<blockquote>\n<p>When Aesop is slow, my first guess would be that its repeated <code>simp</code> calls are the cause. </p>\n</blockquote>\n<p>This is also something that is problematic in the library due to statements with very weak keys</p>",
        "id": 450237703,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720546524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/should.20aesop.20unfold.20semireducible.20definitions.3F/near/450237136\">said</a>:</p>\n<blockquote>\n<p>I thought the instance projections were intentionally not unfolded for indexing the keys</p>\n</blockquote>\n<p>For example <code>+</code> is an instance projection function. You don't want this to unfold to the specific definition of addition, because you want it to match with the general lemma <code>add_comm</code>.</p>",
        "id": 450238534,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1720546735
    },
    {
        "content": "<p>Right, perhaps I misunderstood what you said</p>",
        "id": 450238939,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720546843
    },
    {
        "content": "<p>No, I didn't say it right at first</p>",
        "id": 450239059,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1720546880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/287929-mathlib4/topic/should.20aesop.20unfold.20semireducible.20definitions.3F/near/450165890\">said</a>:</p>\n<blockquote>\n<p>When Aesop is slow, my first guess would be that its repeated <code>simp</code> calls are the cause</p>\n</blockquote>\n<p>I recently came across this, where a single <code>simp_all</code> call by <code>aesop</code> caused several seconds worth of slowness, but <code>simp</code> solved the goal immediately. (the context was only moderately sized, not enormous)</p>",
        "id": 450256622,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1720551481
    },
    {
        "content": "<p>Ok, maybe my assumption that <code>aesop</code> is mostly slow because of slow apply statements is wrong, and it's mostly <code>simp</code> that is slow (I've had some cases where <code>simp</code> was instantaneous but <code>aesop</code> timed out, but I didn't try <code>simp_all</code>).</p>",
        "id": 450398171,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720604460
    },
    {
        "content": "<blockquote>\n<p>I'm not clear on whether this transparency should be <code>instances</code> or <code>reducible</code>. At the moment, Aesop's indexing is up to <code>reducible</code> transparency, but when indexing succeeds, the rules are run at <code>default</code> transparency. I'm not sure whether the <code>DiscrTree</code> supports <code>instances</code> transparency, but I guess it should.</p>\n</blockquote>\n<p>This surprises me a little. Indexing is up to reducible, and instance arguments are part of the key in a discrimination tree? I would imagine that would stifle <code>simp</code>, since I would imagine that in the presence if diamonds you need to unfold instances to see whether a lemma applies (even at the matching stage).</p>",
        "id": 450398647,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720604558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/287929-mathlib4/topic/should.20aesop.20unfold.20semireducible.20definitions.3F/near/450237063\">said</a>:</p>\n<blockquote>\n<p>I presume that with completeness you mean that whenever two terms unify in <code>reducible</code> transparency, then they will unify in the discrimination tree. I think if core's <code>DiscrTree</code> has this, then my <code>RefinedDiscrTree</code> should as well.</p>\n</blockquote>\n<p>Yes. More formally, if <code>t</code> and <code>u</code> unify at <code>reducible</code> transparency, and the mapping <code>t -&gt; v</code> was added to the <code>RefinedDiscrTree</code> <code>T</code>, then <code>T.getUnify u</code> should return <code>v</code>. You think this holds?</p>",
        "id": 450492412,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1720626519
    },
    {
        "content": "<p>I'm interested in this <code>simp</code> vs <code>aesop</code> business. If you come across any examples where <code>simp</code> is fast but <code>aesop</code> is slow, I'd like to hear about them. Bonus points if <code>simp_all</code> is also fast because then it's definitely Aesop's 'fault'.</p>",
        "id": 450492863,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1720626646
    },
    {
        "content": "<p>Btw, <code>set_option trace.aesop.stats in aesop</code> reports how much time was spent executing each rule (cumulatively) in an Aesop call. You can also <code>set_option aesop.collectStats true</code> at the start of a file and then <code>#aesop_stats</code> at the end to get aggregate stats for all Aesop calls in that file. (Also works for multiple files.)</p>",
        "id": 450494110,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1720626928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/287929-mathlib4/topic/should.20aesop.20unfold.20semireducible.20definitions.3F/near/450398647\">said</a>:</p>\n<blockquote>\n<p>Indexing is up to reducible, and instance arguments are part of the key in a discrimination tree?</p>\n</blockquote>\n<p>Instance arguments are ignored (they are indexed as a <code>star</code>) in the key in a discrimination tree. So the discrimination tree doesn't check whether the instance is correct.</p>",
        "id": 450570911,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1720647302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/287929-mathlib4/topic/should.20aesop.20unfold.20semireducible.20definitions.3F/near/450492412\">said</a>:</p>\n<blockquote>\n<p>Yes. More formally, if <code>t</code> and <code>u</code> unify at <code>reducible</code> transparency, and the mapping <code>t -&gt; v</code> was added to the <code>RefinedDiscrTree</code> <code>T</code>, then <code>T.getUnify u</code> should return <code>v</code>. You think this holds?</p>\n</blockquote>\n<p>I think in <code>RefinedDiscrTree</code> it does hold for <code>getMatch</code>, and not for <code>getUnify</code>. There are some edge cases with metavariables where <code>getUnify</code> fails to find a unifying key, due to how <code>RefinedDiscrTree</code> gives metavariables an index. I think this could be fixed, but the majority of use cases (such as <code>simp</code>) use <code>getMatch</code> anyways.</p>\n<p>Another case where completeness doesn't hold is that you can manually pass a WhnfCoreConfig, which allows you to disable certain reductions, but that is the sane in core's <code>DiscrTree</code>.</p>",
        "id": 450573361,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1720648380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/287929-mathlib4/topic/should.20aesop.20unfold.20semireducible.20definitions.3F/near/450570911\">said</a>:</p>\n<blockquote>\n<p>Instance arguments are ignored (they are indexed as a <code>star</code>) in the key in a discrimination tree. So the discrimination tree doesn't check whether the instance is correct.</p>\n</blockquote>\n<p>Ok, thanks! Then it should have very little difference to match up to reducible eq or instance eq, and the only question is the reducibility of unification after finding a match.</p>",
        "id": 450696477,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720700899
    },
    {
        "content": "<p>For the <code>rw??</code> tactic, I need to use the <code>reducible</code> setting, because that is what <code>rw</code> uses. I would guess <code>simp</code> also uses that, but I don't know. I think <code>isDefEq</code> at <code>reducible</code> transparency can change the transparency setting for instance arguments, so that the instance arguments can still be unified.</p>",
        "id": 450766244,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1720718680
    }
]