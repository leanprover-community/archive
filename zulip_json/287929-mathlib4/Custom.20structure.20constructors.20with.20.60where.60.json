[
    {
        "content": "<p>Throughout mathlib, we often have alternate constructors for structures or classes for convenience (for example, <code>Equiv.ofBijective</code>). Is it possible to extend Lean's <code>where</code> notation to allow these as well?<br>\nI'm imagining something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myEquiv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">Bijective</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">    </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">ofBijective</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hf</span>\n</code></pre></div>\n<p>so I can specify the constructor I want to use, then the rest would elaborate as if <code>Equiv.ofBijective</code> was the actual constructor instead of <code>Equiv.mk</code>. (I'm flexible on the <code>(mk :=_)</code> notation)</p>",
        "id": 489604306,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1734487304
    },
    {
        "content": "<p>I've thought something like this would be neat. It would also let you apply a transformation function or elaborator to the result.</p>",
        "id": 489607987,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734489675
    },
    {
        "content": "<p>An alternative design though is to make a version of <code>Equiv.ofBijective</code> that takes a <code>structure</code> designed just for it, and then you would write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myEquiv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">Bijective</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">ofBijective'</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">    </span><span class=\"n\">bijective</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hf</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Now that <code>{..}</code> notation supports everything that <code>where</code> does, this loses nothing, and it doesn't take implementing new core features.</p>",
        "id": 489608543,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734490059
    },
    {
        "content": "<p>Hmm, I think this would mean we'd end up with loads of extra structures around mathlib. That said, I was hoping that there'd be a way of extending <code>where</code> in batteries/mathlib instead of adding bits to core</p>",
        "id": 489608692,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1734490158
    },
    {
        "content": "<p>Yes, it would mean making more structures, but is there any harm in that? I assumed they'd be documented with \"alternative formulation for X, use X.ofY to use\" to keep any theory from being built up.</p>\n<p>Of course there's also</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myEquiv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">Bijective</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">ofBijective</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 489609041,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734490414
    },
    {
        "content": "<p>(The <code>where</code> syntax isn't extensible outside of core.)</p>",
        "id": 489609145,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734490480
    },
    {
        "content": "<p>Does this one allow <code>(f x := f x)</code> like <code>where</code> does?</p>",
        "id": 489609214,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1734490545
    },
    {
        "content": "<p>No, that's just available to <code>{ ... }</code> and <code>where</code></p>",
        "id": 489611167,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734491803
    },
    {
        "content": "<p>I ran into this just the other day, when I was making restricted products of groups. My thought process was: </p>\n<ul>\n<li>given a bunch of groups and some structure, I want to make a new group. </li>\n<li>Let's use the default constructor -- oh this stinks because I have to prove too many axioms. </li>\n<li>Oh, but I remember Chris Hughes PR'ed things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Group.ofLeftAxioms#doc\">docs#Group.ofLeftAxioms</a> which means I only have to prove the minimal axioms</li>\n<li>Oh but then I lose all the nice structure provided by the default structure constructor and my code becomes unreadable.</li>\n</ul>",
        "id": 489711608,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734513324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Custom.20structure.20constructors.20with.20.60where.60/near/489608543\">said</a>:</p>\n<blockquote>\n<p>An alternative design though is to make a version of <code>Equiv.ofBijective</code> that takes a <code>structure</code> designed just for it</p>\n</blockquote>\n<p>This is precisely the <code>MinimalAxioms</code> design, eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.Frame.MinimalAxioms#doc\">docs#Order.Frame.MinimalAxioms</a></p>",
        "id": 489737849,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1734522022
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Custom.20structure.20constructors.20with.20.60where.60/near/489604306\">said</a>:</p>\n<blockquote>\n<p>Throughout mathlib, we often have alternate constructors for structures or classes for convenience (for example, <code>Equiv.ofBijective</code>). Is it possible to extend Lean's <code>where</code> notation to allow these as well?<br>\nI'm imagining something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myEquiv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">Bijective</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">    </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">ofBijective</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hf</span>\n</code></pre></div>\n<p>so I can specify the constructor I want to use, then the rest would elaborate as if <code>Equiv.ofBijective</code> was the actual constructor instead of <code>Equiv.mk</code>. (I'm flexible on the <code>(mk :=_)</code> notation)</p>\n</blockquote>\n<p>Another bonus of this is that it (hopefully) would allow for something like <code>(mk := @AddHom.mk _ _ _ noncanonicalInstance)</code></p>",
        "id": 489744258,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1734524103
    },
    {
        "content": "<p>Or just <code>(mk := @AddHom.mk _ _ _ (_))</code></p>",
        "id": 489769530,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734532192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Custom.20structure.20constructors.20with.20.60where.60/near/489737849\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Custom.20structure.20constructors.20with.20.60where.60/near/489608543\">said</a>:</p>\n<blockquote>\n<p>An alternative design though is to make a version of <code>Equiv.ofBijective</code> that takes a <code>structure</code> designed just for it</p>\n</blockquote>\n<p>This is precisely the <code>MinimalAxioms</code> design, eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.Frame.MinimalAxioms#doc\">docs#Order.Frame.MinimalAxioms</a></p>\n</blockquote>\n<p>Similarly <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Adjunction.CoreHomEquiv#doc\">docs#CategoryTheory.Adjunction.CoreHomEquiv</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Adjunction.CoreHomEquivUnitCounit#doc\">docs#CategoryTheory.Adjunction.CoreHomEquivUnitCounit</a></p>",
        "id": 489807621,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1734542807
    }
]