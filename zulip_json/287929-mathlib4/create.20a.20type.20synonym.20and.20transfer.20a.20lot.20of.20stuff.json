[
    {
        "content": "<p>For PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/16177\">#16177</a>, I added some variant of the lexicographic order of monomials which led me to add a type synonym <code>LexHom</code> so that <code>LexHom (Finsupp I Nat)</code> would be endowed with that order (first on degree, then on lexicographic order). Here are my two questions.</p>\n<ol>\n<li>\n<p>Maybe I could/should have been content with typing something like <code>Lex (Nat x Lex (Finsupp I Nat)</code> all the time. Should I have?</p>\n</li>\n<li>\n<p>On the other hand, if adding a type synonym is useful, then it requires to start adding a lot of equivalences (<code>toLexHom</code>, <code>ofLexHom</code>, etc., as there is for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.Lex#doc\">docs#Finsupp.Lex</a>),  functions and instances (endowing <code>LexHom _</code> with a monoid structure when <code>_</code> has, so that <code>toLexHom</code>is a morphism of monoids), a task which is rather uninteresting in itself. (Of course, I started by copy-pasting what exists for <code>Lex</code>and adjusted things afterwards according to my needs.)<br>\nSo the question is — what should be the proper way to have this boring code written automatically for us?</p>\n</li>\n</ol>",
        "id": 466115191,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1724966812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/287929-mathlib4/topic/create.20a.20type.20synonym.20and.20transfer.20a.20lot.20of.20stuff/near/466115191\">said</a>:</p>\n<blockquote>\n<p>Maybe I could/should have been content with typing something like <code>Lex (Nat x Lex (Finsupp I Nat)</code> all the time. Should I have?</p>\n</blockquote>\n<p>I would think so, yes. You are free to add notation for it, the same way as <code>α ×ₗ β</code> is notation for <code>Lex (α × β)</code></p>",
        "id": 466115387,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724966897
    },
    {
        "content": "<p>So I'll try adjusting my code in this direction and see if that makes it better. (You should like it, it's combinatorics after all!)</p>",
        "id": 466115573,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1724966986
    },
    {
        "content": "<p>What combinatorics, may I excitingly ask?</p>",
        "id": 466115724,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724967039
    },
    {
        "content": "<p>Oh, the combinatorial nullstellensatz. Sorry, I should have clicked!</p>",
        "id": 466115792,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724967067
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> If you use <code>abbrev</code> instead of <code>def</code> then typeclass synthesis will see through it and find all the instances that it would normally find for <code>Lex (Nat x Lex (Finsupp I Nat)</code>. And then you shouldn't need all the equivalences and transferring...</p>",
        "id": 466153124,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1724989980
    }
]