[
    {
        "content": "<p>I have learned that <code>∀ α, Set α ≠ α</code> is not a theorem in mathlib (at least according to a Loogle search). Is this something worth contributing? More generally, are such theroerems about types in scope of mathlib?</p>",
        "id": 472092271,
        "sender_full_name": "Mac Malone",
        "timestamp": 1727045726
    },
    {
        "content": "<p>That one can be strengthened to saying that the types are not equivalent. I'm pretty sure that exists somewhere, but I don't remember what it's called...</p>",
        "id": 472093122,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727046126
    },
    {
        "content": "<p>At least there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.cantor_surjective#doc\">docs#Function.cantor_surjective</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.cantor_injective#doc\">docs#Function.cantor_injective</a></p>",
        "id": 472093217,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727046191
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">cantor_injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 472093494,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727046308
    },
    {
        "content": "<p>Yeah, that is essentially my proof. <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 472093571,
        "sender_full_name": "Mac Malone",
        "timestamp": 1727046334
    },
    {
        "content": "<p>I didn't realize the proof for the injectivity of the cast could be reduced to <code>by intros; ismp</code>, though. Instead, I proved <code>cast_injective</code> (which I also could not find in Lean/mathlib) as well.</p>",
        "id": 472093782,
        "sender_full_name": "Mac Malone",
        "timestamp": 1727046426
    },
    {
        "content": "<p>I think <code>cast_injective</code> would be great to contribute. I was just about to suggest it :-)</p>",
        "id": 472093817,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727046446
    },
    {
        "content": "<p><code>by intro; simp</code> is just a trick that happened to work.</p>",
        "id": 472093857,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727046467
    },
    {
        "content": "<p>Maybe this spelling of the statement?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Cardinal</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">card_lt_card_set</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Cardinal</span><span class=\"bp\">.</span><span class=\"n\">mk_embedding_eq_zero_iff_lt</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mk_eq_zero_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">isEmpty_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">cantor_injective</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hf</span>\n</code></pre></div>",
        "id": 472093935,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727046484
    },
    {
        "content": "<p>Though I guess <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cardinal.cantor#doc\">docs#Cardinal.cantor</a> is close enough</p>",
        "id": 472094114,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727046580
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Set.20.CE.B1.20.E2.89.A0.20.CE.B1/near/472093817\">said</a>:</p>\n<blockquote>\n<p>I think <code>cast_injective</code> would be great to contribute. I was just about to suggest it :-)</p>\n</blockquote>\n<p>Apparently this alredy does somewhat exist as <code>cast_inj</code>, which is not quite<code> Injective (cast h)</code> (and which is why I did not find it in my search).</p>",
        "id": 472094127,
        "sender_full_name": "Mac Malone",
        "timestamp": 1727046586
    },
    {
        "content": "<p>(I learned this with a <code>simp?</code> on your example.)</p>",
        "id": 472094225,
        "sender_full_name": "Mac Malone",
        "timestamp": 1727046615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Set.20.CE.B1.20.E2.89.A0.20.CE.B1/near/472094114\">said</a>:</p>\n<blockquote>\n<p>Though I guess <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cardinal.cantor#doc\">docs#Cardinal.cantor</a> is close enough</p>\n</blockquote>\n<p>Yeah:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">card_lt_card_set</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mk_set</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Cardinal</span><span class=\"bp\">.</span><span class=\"n\">cantor</span>\n</code></pre></div>",
        "id": 472094536,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727046752
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span> Usually there's <code>foo_injective</code> for the <code>Injective</code> version and <code>foo_inj</code> for the spelled-out version. I think we should have <code>cast_injective</code> and <code>cast_surjective</code>.</p>",
        "id": 472094643,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727046820
    },
    {
        "content": "<p>Equality of types is often not a useful notion. About as much as you can ask about two distinct types is whether there exists an equivalence or not.</p>",
        "id": 472109953,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1727056351
    },
    {
        "content": "<p>(which is what this cardinality statement is saying)</p>",
        "id": 472109962,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1727056361
    },
    {
        "content": "<p>While fair and usually true, I happened to be toying around with something where the equality (and inequality) of types was of prime importance. (An encoding of inductives as types rather than values.)</p>",
        "id": 472110375,
        "sender_full_name": "Mac Malone",
        "timestamp": 1727056681
    },
    {
        "content": "<p>The only way we can prove that two types are unequal is by proving that they're not equivalent (ie don't biject with each other). For example Nat = Int is undecidable. This is the main reason why equality of types is not fleshed out in mathlib -- it's just a weaker version of equality of cardinality if it's not rfl</p>",
        "id": 472138056,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1727072517
    }
]