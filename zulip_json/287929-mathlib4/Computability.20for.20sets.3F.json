[
    {
        "content": "<p>Right now the computability library deals with functions/predicates/relations, but in my own work on the subject, I often find myself needing basic facts about <a href=\"https://github.com/DavidJWebb/Formalization_of_Computability/blob/main/FormalizationOfComputability/Sets.lean\">computable (or primitive/partial recursive) sets</a> - closure under union/intersection/complement/etc. Would these be a good potential addition to Mathlib?</p>",
        "id": 534588636,
        "sender_full_name": "David J. Webb",
        "timestamp": 1755226151
    },
    {
        "content": "<p>I think your <code>set</code> is almost <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PrimrecPred#doc\">docs#PrimrecPred</a> ?</p>",
        "id": 534632130,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755254180
    },
    {
        "content": "<p>Oh true - I wrote that definition a while ago and hadn't thought more about it, just the lemmas that followed. Perhaps something like <code>Primrec.set X := PrimrecPred (λ x ↦ (x ∈ X) = True)</code> would be cleaner</p>",
        "id": 534729640,
        "sender_full_name": "David J. Webb",
        "timestamp": 1755308325
    },
    {
        "content": "<p>You don't need the <code>= True</code> part</p>",
        "id": 534731513,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755310345
    },
    {
        "content": "<p>just <code>PrimrecPred fun x =&gt; x ∈ X</code></p>",
        "id": 534731522,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755310357
    },
    {
        "content": "<p>I thought about that, but I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">synthesize</span>\n<span class=\"w\">  </span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">X</span>\n</code></pre></div>\n<p>So I was including = True to avoid needing that as a hypothesis. If there's a better way to get around that error, I'm happy to implement that!</p>",
        "id": 534731727,
        "sender_full_name": "David J. Webb",
        "timestamp": 1755310614
    },
    {
        "content": "<p>If you put <code>= True</code> this doesn't actually let you skip <code>DecidablePred fun x ↦ x ∈ X</code> as a hypothesis</p>",
        "id": 534731851,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755310756
    },
    {
        "content": "<p>what you should do is add it as an assumption to every theorem you prove</p>",
        "id": 534731867,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755310782
    },
    {
        "content": "<p>or, if you know you will never compute with this, you can wrap it in a new definition that uses the classical decidability instance</p>",
        "id": 534731895,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755310810
    },
    {
        "content": "<p>I can add that the sets under consideration have decidable membership, that's the most reasonable path forward</p>",
        "id": 534731959,
        "sender_full_name": "David J. Webb",
        "timestamp": 1755310881
    },
    {
        "content": "<p>however, if the theorem <em>statement</em> does not need decidability, then you can use the classical instance inside the proof</p>",
        "id": 534732027,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755310973
    },
    {
        "content": "<p>if a <em>definition</em> needs decidability, you should still add it as a hypothesis</p>",
        "id": 534732049,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755311001
    },
    {
        "content": "<p>this is to ensure you don't get diamonds</p>",
        "id": 534732069,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755311025
    },
    {
        "content": "<p>Ohhhh, okay. Good to know!</p>\n<p>Refactoring the definition this way makes many of the proofs <em>much</em> shorter <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 534732152,
        "sender_full_name": "David J. Webb",
        "timestamp": 1755311148
    },
    {
        "content": "<p>Actually, maybe I'm still misunderstanding something. <a href=\"https://github.com/DavidJWebb/Formalization_of_Computability/blob/main/FormalizationOfComputability/Sets1.lean\">I have made the definition</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PrimrecPred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which lets me prove closure for union/intersection/set difference much more slickly than before. But some proofs run into difficulties - for example, when I go to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">symmdiff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hY</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">∆</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">∆</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>the intuitive proof breaks immediately. In the <code>∃ (f : ℕ → Bool)</code> formalism, it was as simple as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">union</span>\n<span class=\"w\">  </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">sdiff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hX</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hY</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>but with this definition I get an error instead</p>\n<blockquote>\n<p>Tactic <code>apply</code> failed: could not unify the conclusion of <code>@union</code><br>\n  @set (?X ∪ ?Y) fun a ↦ decidableUnion ?X ?Y a<br>\nwith the goal<br>\n  @set (X ∆ Y) inst✝</p>\n</blockquote>\n<p>I had a similar problem with proving that finite sets are primitive recursive - in both cases, I can get around the difficulty by using the fact that this new definition is equivalent to the old one, which seems to defeat the point of the new one!</p>\n<p>I figure I've either mis-implemented things, or there is some way to avoid this trouble that I am just unaware of.</p>",
        "id": 534758551,
        "sender_full_name": "David J. Webb",
        "timestamp": 1755345982
    },
    {
        "content": "<p>oh no this is a bit complicated</p>",
        "id": 534761299,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755349330
    },
    {
        "content": "<p>Why does <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PrimrecPred#doc\">docs#PrimrecPred</a> assume <code>DecidablePred</code>?</p>",
        "id": 534761475,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1755349520
    },
    {
        "content": "<p>I thought it didn't anymore</p>",
        "id": 534761628,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1755349679
    },
    {
        "content": "<p>Or is that in an open pr?</p>",
        "id": 534761635,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1755349686
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/27076\">#27076</a></p>",
        "id": 534764153,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1755352591
    },
    {
        "content": "<p>Reviewed by <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>",
        "id": 534764183,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1755352625
    },
    {
        "content": "<p>Ahaha</p>",
        "id": 534773354,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1755362973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Computability.20for.20sets.3F/near/534761299\">said</a>:</p>\n<blockquote>\n<p>oh no this is a bit complicated</p>\n</blockquote>\n<p>Music to my ears, I was starting to think I was even worse at Lean than I thought <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n<p>I'll keep an eye on that PR and revisit this refactor after it goes through</p>",
        "id": 534794030,
        "sender_full_name": "David J. Webb",
        "timestamp": 1755394831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"381517\">David J. Webb</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Computability.20for.20sets.3F/near/534794030\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Computability.20for.20sets.3F/near/534761299\">said</a>:</p>\n<blockquote>\n<p>oh no this is a bit complicated</p>\n</blockquote>\n<p>Music to my ears, I was starting to think I was even worse at Lean than I thought <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n<p>I'll keep an eye on that PR and revisit this refactor after it goes through</p>\n</blockquote>\n<p>So the correct thing to do here is to assume <code>[decXY : DecidablePred fun x ↦ x ∈ X ∆ Y]</code> in your statement, and then in the proof do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">decX</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">decPred</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">decY</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">decPred</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Y</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">decXY</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">clear</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">decXY</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which should hopefully fix all your decidability issues</p>",
        "id": 534795245,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755396624
    },
    {
        "content": "<p>But this theorem wants <code>set X</code> and <code>set Y</code> as hypotheses, which I cannot even state without having <code>decX</code> and <code>decY</code> already declared. Plus <code>inferInstance</code> fails to synthesize <code>DecidablePred fun x ↦ x ∈ X ∆ Y</code>.</p>\n<p>Or is this for after the PR goes through? (If it does)</p>",
        "id": 534808927,
        "sender_full_name": "David J. Webb",
        "timestamp": 1755417469
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"381517\">David J. Webb</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Computability.20for.20sets.3F/near/534808927\">said</a>:</p>\n<blockquote>\n<p>But this theorem wants <code>set X</code> and <code>set Y</code> as hypotheses, which I cannot even state without having <code>decX</code> and <code>decY</code> already declared. Plus <code>inferInstance</code> fails to synthesize <code>DecidablePred fun x ↦ x ∈ X ∆ Y</code>.</p>\n</blockquote>\n<p>This has become twice the amount of headache with two sentences</p>",
        "id": 534813930,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755425146
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"381517\">David J. Webb</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Computability.20for.20sets.3F/near/534794030\">said</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">I'll</span><span class=\"w\"> </span><span class=\"n\">keep</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">eye</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">PR</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">revisit</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">refactor</span><span class=\"w\"> </span><span class=\"n\">after</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">goes</span><span class=\"w\"> </span><span class=\"n\">through</span>\n</code></pre></div>\n<p>Now that it has, I no longer need DecidablePred as a hypothesis (thank goodness)!</p>",
        "id": 535790965,
        "sender_full_name": "David J. Webb",
        "timestamp": 1755937009
    }
]