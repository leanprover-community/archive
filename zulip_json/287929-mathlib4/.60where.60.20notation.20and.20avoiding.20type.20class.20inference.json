[
    {
        "content": "<p>I am very much puzzled by why the second syntax below causes errors. I think I am explicitly trying to forbid Lean from inferring any instances, and yet the error is <em>\"synthesized type class instance is not definitionally equal to expression inferred by typing rules\"</em>.</p>\n<p>The first syntax works, just for reference --- i.e., the user can tell Lean not to infer any instances here, just not with the <code>where</code> notation.</p>\n<p>What am I missing?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Homeomorph</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">id_homeomorph</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Homeomorph</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">Homeomorph</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">continuous_id_of_le</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">continuous_id_of_le</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Homeomorph</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- **So this syntax works.**</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Homeomorph</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"c1\">-- **This syntax produces the following error:**</span>\n<span class=\"w\">    </span><span class=\"c1\">-- synthesized type class instance is not definitionally equal to expression</span>\n<span class=\"w\">    </span><span class=\"c1\">-- inferred by typing rules, synthesized t₂ inferred t₁</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">continuous_toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">continuous_invFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It doesn't matter whether I fill in the sorries in these fields; the same error remains.</p>\n<p>Incidentally, for homeomorphisms, maybe we should introduce the custom topology specifying notation as below (although this doesn't fix the issue with the <code>where notation</code>).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Homeomorph</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Topology</span>\n\n<span class=\"sd\">/-- Notation for `Homeomorph` with respect to a non-standard topologies. -/</span>\n<span class=\"kn\">scoped</span><span class=\"o\">[</span><span class=\"n\">Topology</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Homeomorph_of</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"s2\">\" ≃ₜ[\"</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"s2\">\", \"</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"s2\">\"]\"</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">Homeomorph</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"n\">t₂</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tX</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tY</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f_cont</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"o\">[</span><span class=\"n\">tX</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tY</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f_inv_cont</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"o\">[</span><span class=\"n\">tY</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tX</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">≃ₜ</span><span class=\"o\">[</span><span class=\"n\">tX</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tY</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Homeomorph</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>",
        "id": 521355030,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1748631589
    },
    {
        "content": "<p>The more direct comparison isn't <code>where</code> to <code>:= sorry</code>, but to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Homeomorph</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">continuous_toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">continuous_invFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>This is what <code>where</code> expands to, so-called \"structure instance notation.\"</p>\n<p>The issue is that there's an implicit <code>Homeomorph.mk</code> in here. It elaborates <code>Homeomorph.mk</code> using pretty much the normal rules of elaboration, and the normal rules involve re-synthesizing instance arguments even if they can be inferred, to ensure that they're the canonical ones.</p>\n<p>There's no way to use structure instance notation while also specifying the type's parameters (the arguments to <code>Homeomorph</code>) using some <code>@</code>-like mode.</p>",
        "id": 521355725,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748631893
    },
    {
        "content": "<p>If you do want multiple topologies on the same space, it's probably better to introduce some type synonym to guide which topology should be found. For example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">WithTop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Topology</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WithTop</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inst</span>\n</code></pre></div>\n<p>and then work with <code>Homeomorph (WithTop X t1) (WithTop X t2)</code></p>\n<p>(I know <code>WithTop</code> is taken, just sketching.)</p>",
        "id": 521356009,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748632008
    },
    {
        "content": "<p>I agree one usually should use a type synonym. This came up in the context of the sequential Banach-Alaoglu theorem and <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>'s advice to <em>avoid</em> a type synonym originally used by <span class=\"user-mention\" data-user-id=\"879570\">@Janette Setälä</span>... <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> (Which I think is the right advice for that particular case.)</p>\n<p>I was only puzzled by the failure of the <code>where</code> syntax.</p>",
        "id": 521356270,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1748632107
    },
    {
        "content": "<p>How is breaking a fundamental assumption about typeclasses justified here? (The assumption being that instance arguments should be filled in with the unique instance.)</p>",
        "id": 521373234,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748639983
    },
    {
        "content": "<p>Sorry, I didn't understand what \"here\" refers to...</p>\n<p>In sequential Banach-Alaoglu, the key is to prove metrizability of a topology (the relative topology on a subset coming from weak-* topology on a dual of a normed space). To prove the metrizability, one temporarily introduces a metric and compares the topology induced by that metric to the topology one is originally interested in. So one has two a priori different topologies (with the goal of proving them propositionally equal).</p>\n<p>Arguably, when avoiding type synonyms, the more natural way of phrasing the statement is <code>t₁ = t₂</code> rather than the homeomorphism spelling <code>X ≃ₜ[t₁, t₂] X</code> (only the latter lead to my syntax confusion). (And I still maintain it is awkward that in this case there is no easy way to use the \"low level\" constructors such as <code>where</code> or <code>:= { ... }</code> that specify all fields of the <code>Homeomorph</code> structure.)</p>",
        "id": 521373911,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1748640357
    },
    {
        "content": "<p>(\"here\" is referring to \"in the context where this advice was given\")</p>\n<p>Why is it better to put a second topology on the same type rather than use a type synonym for the space with the topology induced by the temporary metric? This is breaking assumptions about typeclass instances, which you've run into with this example.</p>\n<p>They might be the same topology in the end, but even so, as you mention the topologies are only propositionally equal, not defeq.</p>",
        "id": 521374740,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748640791
    },
    {
        "content": "<p>And to be clear, the second topology is not introduced as an instance. I made sure in the original example not to put anything in square brackets! That is why I wrote</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>instead of, say,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t₂</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">t₁</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 521374766,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1748640805
    },
    {
        "content": "<p>There was a reason. Unfortunately it is late and I do not remember it offhand</p>",
        "id": 521374866,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1748640848
    },
    {
        "content": "<p>Ah <span class=\"user-mention\" data-user-id=\"373986\">@Kalle Kytölä</span>, the square brackets only specify how a parameter is filled in. It doesn't matter what sort of brackets you use, typeclasses always result in local instances from within the definition/theorem.</p>",
        "id": 521374942,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748640903
    },
    {
        "content": "<p>This would all be different if Homeomorph itself didn't use <code>[]</code>'s</p>",
        "id": 521375009,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748640946
    },
    {
        "content": "<p>Ok, thanks for the clarification!</p>\n<p>But in the seq. B-A, the current approach would still to be to not have an <code>instance</code> for the metric space --- only a <code>def</code>.</p>",
        "id": 521375170,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1748641026
    },
    {
        "content": "<p>That's fine, it doesn't need to be an <code>instance</code>, but still, it's playing with fire in Lean to have multiple instances for the same type, even if they're not in scope.</p>",
        "id": 521375303,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748641104
    },
    {
        "content": "<p>One reason why one might want to avoid defining the type synonym for the metric space version is that the metric is constructed out of a pretty arbitrary countable collection of functions separating points; to have the instance, the space needs to take the collection and a handful of properties of the collection as an argument. That renders the type synonym pretty useless.</p>",
        "id": 521375398,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1748641172
    },
    {
        "content": "<p>This all said, there's probably a future where the structure instance notation <em>does</em> expose the structure's type parameters as additional fields (it would help with going back and forth between bundling and unbundling). That won't help you in this particular case though, since it would necessitate modifying <code>Homeomorph</code> to have the two TopologicalSpace instances be named.</p>",
        "id": 521375435,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748641200
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"373986\">Kalle Kytölä</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60where.60.20notation.20and.20avoiding.20type.20class.20inference/near/521375398\">said</a>:</p>\n<blockquote>\n<p>That renders the type synonym pretty useless.</p>\n</blockquote>\n<p>Isn't it a little widget just for the sake of the proof though? It doesn't have to be a fully-developed theory of using the topology of a metric space.</p>",
        "id": 521375564,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748641262
    },
    {
        "content": "<p>(I'm speaking with some ignorance here. I haven't seen the Lean proof and how it's organized.)</p>",
        "id": 521375643,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748641318
    },
    {
        "content": "<p>That is the original point of view we took... The original design choices are described in <a href=\"https://aaltodoc.aalto.fi/items/2852d62e-f46a-47dc-9833-96ffa30a0f0f\">Janette's BSc thesis</a> (p.29 for <code>metricCopy X fs fs_sep</code> as the type synonym). They felt natural at the time, but I think avoiding ever making the rather arbitrary metric an instance and avoiding a type synonym felt right later. But I don't have a particularly clear justification, mostly that the metric has no use beyond the metrizability proof (and we only care about the metrizability so that sequential compactness is equivalent to compactness).</p>",
        "id": 521376047,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1748641537
    },
    {
        "content": "<p>The instance at least could be a <code>local instance</code>, and if it really is all very local, it could be <code>private def metricCopy</code> and <code>private local instance</code>, to hide these implementation details.</p>",
        "id": 521376534,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748641845
    },
    {
        "content": "<p>Having multiple instances on the same type also leads to difficulties with trying to make sense of tactic states and theorem statements. The pretty printed version of <code>homeomorph_seriesMetric</code> would be that <code>X ≃ₜ X</code>, which is not so informative</p>",
        "id": 521376631,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748641906
    },
    {
        "content": "<p>I guess what I find awkward is that <code>metricCopy X fs fs_sep</code> has to take at least <code>fs_sep</code> as an argument (<code>X</code> and <code>fs</code> could be implicit though) to know which (pretty arbitrary) metric it wants as an instance. (The repository with the original design is <a href=\"https://github.com/janemms/BanachAlaoglu/blob/main/BanachAlaoglu/Metrizability.lean\">this one</a>.)</p>\n<p>The alternative is indeed to never declare the metric as instance, only as a <code>def</code>.</p>\n<p>Both approaches work. I don't have a super strong preference, but I do feel the rather arbitrary type synonym carrying extra arbitrary data (which required appeasing with <code>set_option linter.unusedVariables false in</code>) in its type was not particularly elegant (and would never be used again). With <code>private</code>, these may nevertheless not be too bad, as you point out.</p>",
        "id": 521377115,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1748642187
    },
    {
        "content": "<p>The data could be packaged up in some structure if you want to hide it more, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SBAData</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">fs_sep</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SBAData</span><span class=\"bp\">.</span><span class=\"n\">metricCopy</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SBAData</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"c1\">-- no need for unused variable linter override if you use `_` or a `_` prefix</span>\n\n<span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SBAData</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetricSpace</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">metricCopy</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 521377676,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748642476
    },
    {
        "content": "<p>That would make it more elegant, indeed.</p>\n<p>I'm still not clear about the preference, though. Does someone have a strong opinion one way or another? I hope <span class=\"user-mention\" data-user-id=\"728389\">@Janette Setälä</span> will soon PR the proof (and we will soon have a PR review). But knowing reasons for a good design are helpful for preparing a PR.</p>",
        "id": 521378056,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1748642675
    },
    {
        "content": "<p>I don't see why not have a local instance. It could be a def, but there's no harm in having throw-away auxiliary structures like this for a proof.</p>\n<p>With my Lean developer hat on, relying on multiple instances on the same type feels very very inelegant, and I'm thinking \"please everyone stop abusing Lean\" :-)</p>",
        "id": 521378081,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748642696
    },
    {
        "content": "<p>I know there are reasons to do it occasionally. There are examples of it when studying the lattice of topologies on a particular type, and there <em>ought</em> to be a better way to do that, but there's no better answer than to allow the abuse. In this case though, I don't see a reason to go out of the way to do it (structure instances don't work, pretty printing won't show the differences, etc.) when there's an alternative.</p>",
        "id": 521378240,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748642826
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"373986\">@Kalle Kytölä</span> please tell me we're doing the general version of this. That is, if you have a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithSeminorms#doc\">docs#WithSeminorms</a> where <code>ι</code> is countable then <code>E</code> is metrizable?</p>",
        "id": 521397610,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1748657906
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 521399020,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1748659272
    },
    {
        "content": "<p>Nevermind, that's a separate thing, I was misremembering.</p>",
        "id": 521400772,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1748660908
    }
]