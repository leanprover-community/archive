[
    {
        "content": "<p>This is a continuation of the discussion here <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/product.20of.20modules.20over.20product.20of.20rings/near/532797132\">#mathlib4 &gt; product of modules over product of rings @ ðŸ’¬</a> , which turned from a discussion about a missing instance which caused a diamond to a general discussion about diamond-causing instances of the form <code>SMul X Y -&gt; SMul (F X) (F Y)</code> and then to the possible hack <a href=\"https://github.com/leanprover-community/mathlib4/pull/29315\">#29315</a> raising the priority of <code>instance : IsModuleTopology R R</code> analogous to mathlib's current <code>instance (priority := 1100) id : Algebra R R</code>. It was suggested that I write a library note explaining this design decision but I sat on this job for 3 months and am only now finding the motivation to come back to it. When trying to put my thoughts together I was very surprised to discover that core has <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instSMulOfMul#doc\">docs#instSMulOfMul</a> a.k.a.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">910</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">smul</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"bp\">.</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>If my understanding of priorities is correct, this is a <em>lower</em> than default priority, which is completely in contrast with mathlib's</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The identity map inducing an `Algebra` structure. -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1100</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>This results in the situation that given a commutative ring structure we take a very quick route to the self-SMul:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"c1\">-- (Algebra.id R).toSMul</span>\n</code></pre></div>\n<p>whereas given a weaker structure we take a much lower priority route</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"c1\">-- NonUnitalNonAssocSemiring.toDistribSMul.toSMul</span>\n</code></pre></div>\n<p>going via </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Ring</span><span class=\"bp\">.</span><span class=\"n\">toNonAssocRing</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NonAssocRing</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>and then with a little less algebra we go a different way</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"c1\">-- (Monoid.toMulAction R).toSMul</span>\n</code></pre></div>\n<p>with </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">910</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Monoid</span><span class=\"bp\">.</span><span class=\"n\">toMulAction</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>and finally with essentially no algebra at all we go through core</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"c1\">-- instSMulOfMul</span>\n</code></pre></div>\n<p>This does all seem a bit wacky (and to be honest I am a little surprised that we find our way to the prio 100 route in the <code>Ring</code> case rather than the prio 910 route). <span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span> and others suggested that we might want different kinds of SMuls but this experiment indicates that in some sense we already have this -- Algebra SMuls get a different kind of treatment to other ones. I am not trying to make any particular point here other than the fact that I was surprised by what is currently happening, it doesn't really seem to affect anything in practice, but it is making it difficult for me to write the library note explaining why we want <code>&lt;hypotheses&gt; : Foo X X</code> to have a higher prio (because it is almost always what you want when it matches) when core is telling me that for <code>[Mul X] : SMul X X</code> we actually want a lower prio.</p>",
        "id": 561633235,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764763478
    },
    {
        "content": "<p>I feel like it could very much be affecting things in practice. Experiments indicate that <code>SMul</code> inference is the worst performer by a decent amount amongst all the algebra menagerie.</p>",
        "id": 561893737,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1764859045
    },
    {
        "content": "<p>It would be interesting to test what happens if we change the 910 to 1100 in core and then benchmark but I have no idea how to do this.</p>",
        "id": 561907159,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764861824
    },
    {
        "content": "<p>100% serious: can claude do it one-shot? My guess is that today is not the day but we are getting close.</p>",
        "id": 561908114,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1764862019
    },
    {
        "content": "<p>Of course, you need to file this under: only for expert guidance because it goes terribly if you have limited understanding of what is going on.</p>",
        "id": 561908401,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1764862083
    },
    {
        "content": "<p>Digging further. <a href=\"https://github.com/leanprover-community/mathlib4/pull/31040\">#31040</a> deprecates <code>instSMulOfMul</code> and changes the instance of <code>SMul (S âŠ—[R] S â§¸ KaehlerDifferential.ideal R S ^ 2)</code> from <code>Mul.toSMul _</code> to <code>inferInstance</code>; I just <a href=\"https://github.com/leanprover-community/mathlib4/pull/31040#issuecomment-3621974001\">benchmarked the PR</a> and if my understanding of the output is correct, build instructions in mathlib went up by 8.2%? (13.8 tera-instructions, that's so many instructions that I don't even know how many zeros are in that number). Or am I misunderstanding the benchmarking?</p>",
        "id": 562418951,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765185724
    }
]