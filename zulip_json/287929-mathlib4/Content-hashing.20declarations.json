[
    {
        "content": "<p>Intuitively, I'm a big proponent of everything that increases the decoupling of names from lambda expressions.</p>",
        "id": 512065384,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744633344
    },
    {
        "content": "<p>I think there is a meaningful intermediary here, i.e. it would not be a good idea to go \"full unison\" and say that names are just resolving to lambda expressions. Rather names resolve to definitions which have lambda expression bodies</p>",
        "id": 512070254,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744634745
    },
    {
        "content": "<p>otherwise we don't have anywhere to hang definition unfolding heuristics</p>",
        "id": 512070299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744634761
    },
    {
        "content": "<p>But I see no innate issue with a definition having multiple names like a linux hard link</p>",
        "id": 512070506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744634808
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/180721-mathlib-maintainers/topic/Deprecating.20field.20names/near/512070299\">said</a>:</p>\n<blockquote>\n<p>otherwise we don't have anywhere to hang definition unfolding heuristics</p>\n</blockquote>\n<p>You can hang those in a separate db, indexed by hashes, right?</p>",
        "id": 512072979,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744635465
    },
    {
        "content": "<p>hashes of what?</p>",
        "id": 512074389,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744635844
    },
    {
        "content": "<p>if you are hashing the lambda term then you would not be able to have two definitions with the same content and different metadata</p>",
        "id": 512074511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744635873
    },
    {
        "content": "<p>basically I'm saying that if we erase all the names and just look at it as a soup of nodes, then there is a node type representing expressions but there is also a node type representing definitions together with all their metadata (except the name)</p>",
        "id": 512074817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744635953
    },
    {
        "content": "<p>and constant references in expressions refer to definitions, not the body expression directly</p>",
        "id": 512074926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744635973
    },
    {
        "content": "<p>and then you can layer names on top of that and content hash to your heart's content</p>",
        "id": 512075103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744636034
    },
    {
        "content": "<p>Another case of content hashing causing problems is if you erase names in inductive types, it would make <code>structure Foo where n : Nat</code> and <code>structure Bar where n : Nat</code> the same type</p>",
        "id": 512075379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744636113
    },
    {
        "content": "<p>some things have to be \"generative\"</p>",
        "id": 512075469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744636140
    },
    {
        "content": "<p>in the soup of nodes picture these would be distinct nodes that have the same subnodes</p>",
        "id": 512075694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744636198
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/180721-mathlib-maintainers/topic/Deprecating.20field.20names/near/512075379\">said</a>:</p>\n<blockquote>\n<p>Another case of content hashing causing problems is if you erase names in inductive types, it would make <code>structure Foo where n : Nat</code> and <code>structure Bar where n : Nat</code> the same type</p>\n</blockquote>\n<p>Is that a feature or a bug?</p>",
        "id": 512075856,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744636234
    },
    {
        "content": "<p>Anyway, maybe we should split this thread.</p>",
        "id": 512075901,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744636249
    },
    {
        "content": "<p>15 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"180721\" href=\"/#narrow/channel/180721-mathlib-maintainers/topic/Deprecating.20field.20names/with/512053396\">#mathlib maintainers &gt; Deprecating field names</a> by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>.</p>",
        "id": 512104817,
        "sender_full_name": "Notification Bot",
        "timestamp": 1744643386
    },
    {
        "content": "<p>On the subject of nominal types, the <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> formalization does not use nominal inductive types, it has a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi><mi>T</mi><mo>:</mo><mi>F</mi><mi mathvariant=\"normal\">.</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">\\mu T:F. K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> term constructor for inductive types instead of an <code>inductive</code> declaration form</p>",
        "id": 512105495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744643543
    },
    {
        "content": "<p>which has the side effect that you can prove the equality of types like <code>Foo</code> and <code>Bar</code></p>",
        "id": 512105600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744643569
    },
    {
        "content": "<p>And the way you can \"fix\" that is to put the name in the constructor, i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi><mo stretchy=\"false\">[</mo><mi>F</mi><mi>o</mi><mi>o</mi><mo stretchy=\"false\">]</mo><mi>T</mi><mo>:</mo><mi>F</mi><mi mathvariant=\"normal\">.</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">\\mu[Foo]T:F.K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">oo</span><span class=\"mclose\">]</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, or an auto-incrementing counter</p>",
        "id": 512105815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744643625
    },
    {
        "content": "<p>Maybe I'm naive, but to me it seems that names are strictly an elaborator feature.<br>\nI don't see harm in being able to prove that <code>Foo</code> and <code>Bar</code> are equal.</p>",
        "id": 512222253,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744691838
    },
    {
        "content": "<p>The standard argument for newtypes is things like <code>structure Meters where n : Real</code> and <code>structure Feet where n : Real</code></p>",
        "id": 512317010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744722814
    },
    {
        "content": "<p>if I have such types and have a function <code>def tooBig : Meters -&gt; Bool</code> it should be a type error to pass <code>Feet.mk 37</code> to it</p>",
        "id": 512317261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744722872
    },
    {
        "content": "<p>Put another way, a type is not just a set of values but also an interpretation of those values, even though only the set of values is explicitly expressed in the syntax. If the interpretation changes then using a different type puts guard rails avoiding accidental misinterpretation</p>",
        "id": 512317787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744722981
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Content-hashing.20declarations/near/512105815\">said</a>:</p>\n<blockquote>\n<p>And the way you can \"fix\" that is to put the name in the constructor, i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi><mo stretchy=\"false\">[</mo><mi>F</mi><mi>o</mi><mi>o</mi><mo stretchy=\"false\">]</mo><mi>T</mi><mo>:</mo><mi>F</mi><mi mathvariant=\"normal\">.</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">\\mu[Foo]T:F.K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">oo</span><span class=\"mclose\">]</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, or an auto-incrementing counter</p>\n</blockquote>\n<p>When I call it an auto-incrementing counter it makes this sound rather unnatural, but there are other ways of presenting type declarations that are more like variable bindings, and it should not be any surprise that when you are in a scope <code>x : Nat, y : Nat |- ...</code>, <code>x</code> and <code>y</code> do not magically become equal simply because they have the same type. They are different variables and the type theory respects this, and in the underlying system this is accomplished using de bruijn variables, i.e. \"an auto-incrementing counter\". Note that this really has nothing to do with the <em>names</em> <code>x</code> and <code>y</code>, rather just that they are different variables because the declaration operation was performed twice.</p>",
        "id": 512318891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744723243
    },
    {
        "content": "<p>But that auto-incrementing counter does imply that you need some global entity that knows about all declarations out there, and then assigns them a \"de bruijn index\".</p>",
        "id": 512366740,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744734855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Content-hashing.20declarations/near/512317261\">said</a>:</p>\n<blockquote>\n<p>if I have such types and have a function <code>def tooBig : Meters -&gt; Bool</code> it should be a type error to pass <code>Feet.mk 37</code> to it</p>\n</blockquote>\n<p>Can't it be enough from a UX POV to have this be a type error at the elaboration level?</p>",
        "id": 512366889,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744734903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Content-hashing.20declarations/near/512366740\">said</a>:</p>\n<blockquote>\n<p>But that auto-incrementing counter does imply that you need some global entity that knows about all declarations out there, and then assigns them a \"de bruijn index\".</p>\n</blockquote>\n<p>That depends on how you conceptualize it, I suppose. You need them to be recognized as distinct, but there are ways to get that without central coordination points, e.g. UUIDs</p>",
        "id": 512367190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744734987
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Content-hashing.20declarations/near/512366889\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Content-hashing.20declarations/near/512317261\">said</a>:</p>\n<blockquote>\n<p>if I have such types and have a function <code>def tooBig : Meters -&gt; Bool</code> it should be a type error to pass <code>Feet.mk 37</code> to it</p>\n</blockquote>\n<p>Can't it be enough from a UX POV to have this be a type error at the elaboration level?</p>\n</blockquote>\n<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> I think all typing can be done at the elaboration level</p>",
        "id": 512367617,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744735115
    },
    {
        "content": "<p>but if you do that then it's not clear how you've done anything other than shift the burden of checking to a different subsystem and still having nominal semantics</p>",
        "id": 512367734,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744735149
    },
    {
        "content": "<p>Well, I'm not doing <em>all</em> typing at the elaboration level.</p>\n<p>My main application is mathematical consistency, proof correctness. Plugging <code>Feet.mk 37</code> into <code>tooBig</code> will not give you a proof of <code>False</code>.</p>",
        "id": 512368389,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744735333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Content-hashing.20declarations/near/512367190\">said</a>:</p>\n<blockquote>\n<p>That depends on how you conceptualize it, I suppose. You need them to be recognized as distinct, but there are ways to get that without central coordination points, e.g. UUIDs</p>\n</blockquote>\n<p>But then you lose the feature that if person Foo defines <code>Nat</code> in Greece in 370 BC and person Bar defines <code>Nat</code> in India in 530 BC, that they automatically end up with the same <code>Nat</code>.<br>\nAnd so now person Foo can't use theorems by Bar, when they discovers them.</p>",
        "id": 512368675,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744735426
    },
    {
        "content": "<p>yeah I think that is by design, that's the same thing you would get if both the ancient Greek and Indian lean users used the <code>inductive</code> command separately</p>",
        "id": 512369771,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744735753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Content-hashing.20declarations/near/512368389\">said</a>:</p>\n<blockquote>\n<p>My main application is mathematical consistency, proof correctness. Plugging <code>Feet.mk 37</code> into <code>tooBig</code> will not give you a proof of <code>False</code>.</p>\n</blockquote>\n<p>It can lead to <a href=\"https://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure\">proofs by explosion</a> though</p>",
        "id": 512371129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744736173
    },
    {
        "content": "<p>I think it is more appropriate to have separate types but use something HoTT-styled to mediate the various ways that the types can be identified. Just because they have the same structure doesn't mean the \"identity function\" induced by this is the right isomorphism to apply to turn Greek mathematics into Indian mathematics</p>",
        "id": 512372134,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744736479
    },
    {
        "content": "<p><code>Nat</code> is a special case because it has no nontrivial isomorphisms</p>",
        "id": 512372234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744736519
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Content-hashing.20declarations/near/512372234\">said</a>:</p>\n<blockquote>\n<p><code>Nat</code> is a special case because it has no nontrivial isomorphisms</p>\n</blockquote>\n<p>What kind of isomorphisms?</p>",
        "id": 512372661,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744736666
    },
    {
        "content": "<p>Does every inductive have no nontrivial automorphisms if by \"automorphism\" you been \"constructor-preserving map\"?</p>",
        "id": 512373133,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744736813
    },
    {
        "content": "<p>Then <code>Bool</code> would seem to have <code>Bool.not</code></p>",
        "id": 512373293,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744736853
    },
    {
        "content": "<p>I think kevin means mapping each constructor to the corresponding constructor</p>",
        "id": 512373410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744736883
    },
    {
        "content": "<p>Preserves constructors up to renaming</p>",
        "id": 512373412,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744736884
    },
    {
        "content": "<p>That doesn't preserve the constructor <code>Bool.true</code>. This is why your question is pertinent!</p>",
        "id": 512373426,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744736889
    },
    {
        "content": "<p>and I think the answer is yes</p>",
        "id": 512373439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744736894
    },
    {
        "content": "<p>What about <code>Prod.swap</code>?</p>",
        "id": 512373492,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744736918
    },
    {
        "content": "<p>It preserves the only constructor <code>Prod.mk</code></p>",
        "id": 512373541,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744736937
    },
    {
        "content": "<p>No, because this takes two arguments in order</p>",
        "id": 512373584,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1744736952
    },
    {
        "content": "<p>(I also assume that preserving a constructor means mapping the arguments in the same order <span aria-label=\"stuck out tongue closed eyes\" class=\"emoji emoji-1f61d\" role=\"img\" title=\"stuck out tongue closed eyes\">:stuck_out_tongue_closed_eyes:</span> )</p>",
        "id": 512373630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744736972
    },
    {
        "content": "<p>Actually, what does \"preserves constructors\" even mean?</p>",
        "id": 512373924,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744737058
    },
    {
        "content": "<p>a homomorphism of <code>Nat</code> is a function <code>f</code> such that <code>f zero = zero</code> and <code>f (succ n) = succ (f n)</code></p>",
        "id": 512374009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744737087
    },
    {
        "content": "<p>and since this has clauses mirroring those of a definition by recursion, you can prove by induction that it's the identity function</p>",
        "id": 512374187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744737154
    },
    {
        "content": "<p>so this is true for all inductive types</p>",
        "id": 512374224,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744737165
    },
    {
        "content": "<p>This is interesting, it's a kind of \"rigidity\" I associate with ZFC set theory, \"junk theorems\" and all that</p>",
        "id": 512374346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744737215
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Content-hashing.20declarations/near/512374009\">said</a>:</p>\n<blockquote>\n<p>a homomorphism of <code>Nat</code> is a function <code>f</code> such that <code>f zero = zero</code> and <code>f (succ n) = succ (f n)</code></p>\n</blockquote>\n<p>So how does this definition apply to <code>Prod</code> (or <code>Prod Nat Nat</code> if you want to be concrete)?</p>",
        "id": 512374353,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744737219
    },
    {
        "content": "<p>Would it just be <code>f (a, b) = (a, b)</code>?</p>",
        "id": 512374514,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744737261
    },
    {
        "content": "<p>a homomorphism of <code>h : A x B -&gt; A' x B'</code> relative to morphisms <code>f : A -&gt; A'</code>, <code>g : B -&gt; B'</code> is a function such that <code>h (a, b) = (f a, g b)</code></p>",
        "id": 512374576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744737286
    },
    {
        "content": "<p>(misread)</p>",
        "id": 512374599,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744737295
    },
    {
        "content": "<p>the \"relative to\" part is because <code>Prod</code> is a parameterized type</p>",
        "id": 512374690,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744737325
    },
    {
        "content": "<p>but if <code>f</code> and <code>g</code> are identity functions then you can prove by recursion that <code>h</code> is also an identity function</p>",
        "id": 512374756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744737354
    },
    {
        "content": "<p>What about arrow types?</p>",
        "id": 512374923,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744737403
    },
    {
        "content": "<p>I think you need isomorphisms to do contravariant things, a homomorphism of <code>f : (A -&gt; B) -&gt; (A' -&gt; B')</code> over <code>a : A ~= A'</code> and <code>b : B ~= B'</code> satisfies <code>f g = fun x =&gt; b (g (a^-1 x))</code></p>",
        "id": 512375323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744737529
    },
    {
        "content": "<p>What about universe types, like <code>Prop</code> and <code>Type</code>? Those don't seem to have any constructors.</p>",
        "id": 512375379,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744737547
    },
    {
        "content": "<p>HoTT can basically compute these expressions for any type former</p>",
        "id": 512375386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744737550
    },
    {
        "content": "<p>I was just getting to that: the universe is an example of a non-rigid type since it is not inductively defined. It actually has nontrivial isomorphisms</p>",
        "id": 512375488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744737585
    },
    {
        "content": "<p>and those isomorphisms are precisely the things that e.g. interchange <code>Meters</code> and <code>Feet</code></p>",
        "id": 512375630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744737618
    },
    {
        "content": "<p>So what's a homomorphism of <code>Type</code> have to satisfy?</p>",
        "id": 512375790,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744737665
    },
    {
        "content": "<p>In HoTT, it would be a function <code>F : Type -&gt; Type</code> such that <code>(A = B) ~= (F A ~= F B)</code></p>",
        "id": 512376142,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744737780
    },
    {
        "content": "<p>that really doesn't make a lot of sense without HoTT though, since applied to the identity function it's literally univalence</p>",
        "id": 512376243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744737816
    },
    {
        "content": "<p>but the simple consequence would be that isomorphic types are mapped to isomorphic types</p>",
        "id": 512376442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744737876
    },
    {
        "content": "<p>(Don't quote me on that one though, I haven't actually worked it out)</p>",
        "id": 512376649,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744737950
    },
    {
        "content": "<p><code>Type</code> is a category and you could ask for an equivalence from Type to itself (or slightly more ridiculously for an isomorphism). One such isomorphism could be \"swap Meters and Feet and fix everything else\" although of course there is a model of Lean where this is the identity and another model where it's not ;-)</p>",
        "id": 512381834,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744739560
    }
]