[
    {
        "content": "<p>Lean seems to go into an infinite loop here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">CWComplex</span><span class=\"bp\">.</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Topology</span><span class=\"w\"> </span><span class=\"n\">RelCWComplex</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">RelCWComplex</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">coe_le_succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">coe_le_coe</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_add_right</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">diagnostics</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">skeletonLT_subset_succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">skeletonLT</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">skeletonLT</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">skeleton_mono</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">coe_le_succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 519230308,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1747690809
    },
    {
        "content": "<p>I've made an error in the last line -- it should be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Topology.RelCWComplex.skeletonLT_mono#doc\">docs#Topology.RelCWComplex.skeletonLT_mono</a>, not <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Topology.RelCWComplex.skeleton_mono#doc\">docs#Topology.RelCWComplex.skeleton_mono</a>. But it's weird that rather than just failing, Lean goes into an infinite cycle of some kind trying to show that <code>skeletonLT C (n + 1)</code> and <code>skeleton C (n + 1)</code> are secretly the same.</p>",
        "id": 519230664,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1747690946
    },
    {
        "content": "<p>CC <span class=\"user-mention\" data-user-id=\"697518\">@Hannah Scholz</span> <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span></p>",
        "id": 519297009,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1747720718
    },
    {
        "content": "<p>When you give a wrong proof in term mode (including when using the <code>refine</code> or <code>exact</code> tactics), Lean will  try its best to check that the terms has the correct type. If the type is wrong, it starts unfolding all kinds of definitions to see if the type is correct after unfolding all those definition. When this exactly happens is subtle, and is more likely to happen during elaboration. If you help Lean a little bit, it will stop doing so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">skeletonLT_subset_succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">skeletonLT</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">skeletonLT</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">skeleton_mono</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">coe_le_succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"c1\">-- this errors quickly</span>\n<span class=\"w\">  </span><span class=\"c1\">-- exact skeleton_mono (C := C) (ENat.coe_le_succ n) -- this gives the same timeout</span>\n</code></pre></div>\n<p>If you let Lean fully elaborate the term <code>skeleton_mono (C := C) (ENat.coe_le_succ n)</code>, then it sees that it cannot possibly unify with the goal. But if you try to elaborate the term saying it should solve the goal, it goes into this goose hunt.</p>\n<p>I'm not quite sure where the infinite loop comes from, but the diagnostics output strongly suggest it keeps repeatedly unfolding <code>+</code> on <code>ENat</code>.</p>\n<p>A good way to avoid such long searches is to mark complicated definitions as <code>@[irreducible]</code>, so that this acts as a wall that Lean will not unfold past. In this case, marking <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RelCWComplex.skeletonLT#doc\">docs#RelCWComplex.skeletonLT</a> as irreducible seems very sensible and fixes this particular error. </p>\n<p><span class=\"user-mention\" data-user-id=\"697518\">@Hannah Scholz</span> could you do that at some point? It should barely break anything, but maybe you have to unfold <code>skeletonLT</code> a few more times manually.</p>",
        "id": 519341300,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1747734526
    },
    {
        "content": "<p>Sure, will do!</p>",
        "id": 519407895,
        "sender_full_name": "Hannah Scholz",
        "timestamp": 1747753068
    }
]