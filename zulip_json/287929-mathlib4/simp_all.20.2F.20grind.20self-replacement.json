[
    {
        "content": "<p>I realize that <code>simp_all</code> is a fragile tactic that goes all over the place in how it affects goal state. <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> But this seems somewhat unfortunate. Here I have a short argument that can be closed by just <code>simp_all [...]; grind [...]</code>. Unfortunately, when I want to squeeze the <code>simp_all</code>, the suggested <code>simp_all only</code> given by <code>simp_all?</code> breaks the proof!</p>\n<p>I'm mentioning simp_all <em>and</em> grind in the subject line, because it seems not great on the part of the <code>simp_all</code>, but also maybe a bit of a sore spot on grind, that it's sensitive to the exact simplification that happened, in this way. (I'm having a hard time piecing together exactly where the simplification changes, so maybe it's not grind's fault at all, though, depending on what happened.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">extracted_issue</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">MetricSpace</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddTorsor</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">O</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">P_AB</span><span class=\"w\"> </span><span class=\"n\">P_AC</span><span class=\"w\"> </span><span class=\"n\">P_BC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h_a_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">O</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h_AB</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">affineSpan</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">affineSpan</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P_AB</span><span class=\"o\">})</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h_AC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">affineSpan</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">affineSpan</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P_AC</span><span class=\"o\">})</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h_BC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">affineSpan</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">affineSpan</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P_BC</span><span class=\"o\">})</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hb₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">O</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hc'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">O</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Collinear</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P_AB</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P_AC</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P_BC</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_all?</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">eq_singleton_iff_unique_mem</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> replacing with the suggested</span>\n<span class=\"cm\">  simp_all only [coe_affineSpan, Set.mem_singleton_iff, Set.insert_eq_of_mem, AffineSubspace.coe_affineSpan_singleton,</span>\n<span class=\"cm\">    Set.eq_singleton_iff_unique_mem, Set.mem_inter_iff, and_imp]</span>\n<span class=\"cm\">  causes grind to fail. -/</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">collinear_singleton</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 561016930,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1764523522
    },
    {
        "content": "<p>Oh dear, I just saw <a href=\"#narrow/channel/287929-mathlib4/topic/.60simp.20only.60.20.2B.20.60grind.60.20failure\">#mathlib4 &gt; <code>simp only</code> + <code>grind</code> failure</a> too. Possible duplicate.</p>",
        "id": 561016977,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1764523580
    },
    {
        "content": "<p>It's not great that <code>simp_all?</code> doesn't always give a viable replacement. It's easier to recover if the simp lemmas are locally confluent. In this case, this means adding:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">spanPoints_singleton</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddTorsor</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">O</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">spanPoints</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">O</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">O</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(or rather, some generalization replacing \\real)</p>\n<p>Then <code>simp_all? [Set.eq_singleton_iff_unique_mem]</code> gives</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">coe_affineSpan</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_singleton_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">insert_eq_of_mem</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">AffineSubspace</span><span class=\"bp\">.</span><span class=\"n\">coe_affineSpan_singleton</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">eq_singleton_iff_unique_mem</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_inter_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">and_imp</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>as before, but then a subsequent <code>simp_all?</code> gives <code>simp_all only [spanPoints_singleton, Set.mem_singleton_iff, Set.insert_eq_of_mem]</code>, at which point <code>grind [collinear_singleton]</code> goes through.</p>",
        "id": 563120638,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765439217
    },
    {
        "content": "<p><code>coe_affineSpan</code> should not be a <code>simp</code> lemma. <code>spanPoints</code> and all lemmas stated using it should be deprecated (this would require some reworking to avoid using <code>spanPoints</code> to define <code>affineSpan</code> and prove lemmas about it).</p>",
        "id": 563282850,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1765487180
    },
    {
        "content": "<p>For the record: I am often running into situations where the <code>simp only [...]</code> suggestion breaks the proof but when I add <code>exists_prop</code> to the list it works again. The same with <code>simp_all?</code> and its suggestion. So maybe there is something about <code>exists_prop</code> that prevents it from getting picked up by the <code>?</code> suggestion machinery?<br>\nI don't have an MWE, but it keeps popping up while I am trying to satisfy the flexible linter in my project where it was not enabled before.</p>",
        "id": 564703406,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1766153146
    },
    {
        "content": "<p>Hmm, I remember <code>simp?</code> being unreliable in the Lean 3 days, but I don't remember any issues in the past &gt; 8 months. (Maybe even the past 2 years. But I don't trust my memory.)</p>\n<p>I would be interested in seeing a non-MWE if you encounter this again at some point.</p>",
        "id": 564704460,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1766153432
    },
    {
        "content": "<p>Here is one, I tried to find something towards the root of my import tree so you should not have to compile too much. It does not break the proof in this case, but it does show an example where <code>exists_prop</code> is not caught: <a href=\"https://github.com/m4lvin/lean4-pdl/commit/6f9009d2561a5d7528f84992efbffb948820719c\">https://github.com/m4lvin/lean4-pdl/commit/6f9009d2561a5d7528f84992efbffb948820719c</a></p>",
        "id": 564705932,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1766153888
    },
    {
        "content": "<p>Johan, I have a recent example of a failed squeeze for simp. Search \"<code>simp only</code> and <code>grind</code> failure\"</p>",
        "id": 564706102,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1766153946
    },
    {
        "content": "<p>Semi-related: I often wrote <code>cases bla &lt;;&gt; simp at *</code> or similar where some cases finish with this, some don't and need follow-up proofs. The linter complains about this, and rightly so <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span> But with <code>cases bla &lt;;&gt; simp? at *</code> I get multiple suggestions, one for each of the cases. And accepting one can then break other cases, so I end up semi-manually writing the union of the suggestions. It would be very cool if <code>simp?</code> would be aware of such multi-goal situations and only make one suggestion.</p>",
        "id": 564709058,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1766154772
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/issues/4615\">https://github.com/leanprover/lean4/issues/4615</a> I think this might be the same exists_prop issue</p>",
        "id": 564727002,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1766159430
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"422703\">Malvin Gattinger</span> <a href=\"#narrow/channel/287929-mathlib4/topic/simp_all.20.2F.20grind.20self-replacement/near/564709058\">said</a>:</p>\n<blockquote>\n<p>Semi-related: I often wrote <code>cases bla &lt;;&gt; simp at *</code> or similar where some cases finish with this, some don't and need follow-up proofs. The linter complains about this, and rightly so <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span> But with <code>cases bla &lt;;&gt; simp? at *</code> I get multiple suggestions, one for each of the cases. And accepting one can then break other cases, so I end up semi-manually writing the union of the suggestions. It would be very cool if <code>simp?</code> would be aware of such multi-goal situations and only make one suggestion.</p>\n</blockquote>\n<p>This is meant to exist, and used to work. See Batteries.Tactic.SqueezeScope. Perhaps someone could investigate?</p>",
        "id": 566634441,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1767740548
    },
    {
        "content": "<p><code>squeeze_scope</code> had broken an wasn't working with <code>simp?</code> (although it was working with <code>simp</code>), fixed in <a href=\"https://github.com/leanprover-community/batteries/pull/1604\">batteries#1604</a>.</p>",
        "id": 566637188,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1767742472
    },
    {
        "content": "<p>Should this fix be included in <code>v4.28.0</code>? I see that tag on the page of <a href=\"https://github.com/leanprover-community/batteries/commit/d6185f08ce71924484cec85b51def733dcef378b\">this commit</a>, so I assumed it should be.</p>\n<p>But after updating a small project to 4.28.0 I still get multiple separate suggestions for <code>simp_all?</code> <a href=\"https://github.com/m4lvin/Gossip-in-Lean/commit/2ecbe5276eb49e41337ef812ad97e6384d50831a#diff-edcb1ee4cb878e6c5508a37ad49884fca9805ca7d2f720e9cf4a46dc60d34e2fR483-R504\">here</a>, as <a href=\"https://github.com/m4lvin/Gossip-in-Lean/actions/runs/22096860078/job/63856095690#step:5:136\">shown in CI here</a>.</p>",
        "id": 574271348,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1771328647
    }
]