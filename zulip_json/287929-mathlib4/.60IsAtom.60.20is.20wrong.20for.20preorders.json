[
    {
        "content": "<p><code>IsAtom</code> is wrong for preorders. I can make an element which is both <code>IsBot</code> and <code>IsAtom</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> def IsAtom.{u_2} : {α : Type u_2} → [inst : Preorder α] → [OrderBot α] → α → Prop :=</span>\n<span class=\"cm\">fun {α} [Preorder α] [OrderBot α] a =&gt; a ≠ ⊥ ∧ ∀ b &lt; a, b = ⊥ -/</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">IsAtom</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">NotBool</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">NotBool</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"w\">  </span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">False</span>\n<span class=\"w\">  </span><span class=\"n\">le_refl</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n<span class=\"w\">  </span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n<span class=\"w\">  </span><span class=\"n\">lt_iff_le_not_ge</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OrderBot</span><span class=\"w\"> </span><span class=\"n\">NotBool</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">bot</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"n\">bot_le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">notatom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">NotBool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">true</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isBot_notatom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsBot</span><span class=\"w\"> </span><span class=\"n\">notatom</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">zero_le</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">trivial</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isAtom_notatom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsAtom</span><span class=\"w\"> </span><span class=\"n\">notatom</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">nofun</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">isBot_notatom</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">not_gt</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">notatom_unique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">NotBool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsAtom</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">notatom</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isAtom_notatom</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"n\">notatom</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">isBot_notatom</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nofun</span><span class=\"bp\">⟩</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n</code></pre></div>\n<p>Obviously, the issue is the <code>≠</code> in the definition, which is too weak in preorders, and the <code>=</code> in the definition, which is too strong in preorders. What should this be changed to?</p>",
        "id": 533386747,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754619266
    },
    {
        "content": "<p>(<code>IsCoatom</code> is also wrong)</p>",
        "id": 533386833,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754619357
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsAtom#doc\">docs#IsAtom</a></p>",
        "id": 533403734,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754633947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60IsAtom.60.20is.20wrong.20for.20preorders/near/533386747\">said</a>:</p>\n<blockquote>\n<p>What should this be changed to?</p>\n</blockquote>\n<p><code>IsAtom a := ¬ a ≤ ⊥ ∧ ∀ b &lt; a, b ≤ ⊥</code> or possibly the neater <code>⊥ ⋖ a</code></p>",
        "id": 533403872,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754634028
    },
    {
        "content": "<p>Personally I would first ask you: What preorders that aren't partial orders do you care about?</p>",
        "id": 533404140,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754634159
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60IsAtom.60.20is.20wrong.20for.20preorders/near/533403872\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60IsAtom.60.20is.20wrong.20for.20preorders/near/533386747\">said</a>:</p>\n<blockquote>\n<p>What should this be changed to?</p>\n</blockquote>\n<p><code>IsAtom a := ¬ a ≤ ⊥ ∧ ∀ b &lt; a, b ≤ ⊥</code> or possibly the neater <code>⊥ ⋖ a</code></p>\n</blockquote>\n<p>By the way, I think this can with without assuming <code>OrderBot</code></p>",
        "id": 533434503,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754647285
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60IsAtom.60.20is.20wrong.20for.20preorders/near/533404140\">said</a>:</p>\n<blockquote>\n<p>Personally I would first ask you: What preorders that aren't partial orders do you care about?</p>\n</blockquote>\n<p>Why do you ask? All the preorders I care about now have no atoms, but that doesn't mean there won't be any in the future.</p>",
        "id": 533435653,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754647811
    },
    {
        "content": "<p>I ask because generality without applicability is merely ruining the soul, said Rabelean, or something like that</p>",
        "id": 533458058,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754657397
    },
    {
        "content": "<p>Projections in a von Neumann algebra are a preorder under Murray-von Neumann subequivalence. Moreover, a factor is Type I iff this preorder has atoms in the sense Aaron describes.</p>",
        "id": 533458073,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1754657402
    },
    {
        "content": "<p>That's a nice application!</p>",
        "id": 533458202,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754657459
    },
    {
        "content": "<p>The definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.NoAtoms#doc\">docs#MeasureTheory.NoAtoms</a> is wrong for essentially the same reason, which I recently noticed.</p>",
        "id": 533458275,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1754657492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60IsAtom.60.20is.20wrong.20for.20preorders/near/533434503\">said</a>:</p>\n<blockquote>\n<p>By the way, I think this can without assuming <code>OrderBot</code></p>\n</blockquote>\n<p>I'm not sure what the point of not assuming <code>OrderBot</code> is. If you have an atom, then you automatically have a bot, right?</p>",
        "id": 533458384,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754657527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60IsAtom.60.20is.20wrong.20for.20preorders/near/533458275\">said</a>:</p>\n<blockquote>\n<p>The definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.NoAtoms#doc\">docs#MeasureTheory.NoAtoms</a> is wrong for essentially the same reason, which I recently noticed.</p>\n</blockquote>\n<p>Is this what the \"NB\" in its docstring is trying to convey?</p>",
        "id": 533458552,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754657587
    },
    {
        "content": "<p>As another example: atoms in the divisibility order (not a partial order if there is a nontrivial unit) should be the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Irreducible#doc\">docs#Irreducible</a> elements. (assuming we're in a CancelCommMonoid)</p>",
        "id": 533458653,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754657622
    },
    {
        "content": "<p>Yes, but that's a sort of non-example: We don't use <code>Preorder</code> to talk about divisibility</p>",
        "id": 533460535,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754658320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60IsAtom.60.20is.20wrong.20for.20preorders/near/533458384\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60IsAtom.60.20is.20wrong.20for.20preorders/near/533434503\">said</a>:</p>\n<blockquote>\n<p>By the way, I think this can without assuming <code>OrderBot</code></p>\n</blockquote>\n<p>I'm not sure what the point of not assuming <code>OrderBot</code> is. If you have an atom, then you automatically have a bot, right?</p>\n</blockquote>\n<p>Sometimes there's no canonical choice of bot</p>",
        "id": 533460843,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754658434
    },
    {
        "content": "<p>Then, sure, use <code>IsBot</code></p>",
        "id": 533460975,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754658498
    },
    {
        "content": "<p>but of course you can still talk about atoms and then you don't need the <em>theorem</em> that every bot works equally well for the definition</p>",
        "id": 533460976,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754658498
    },
    {
        "content": "<p>I'm tempted to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Cover.html#Pi.covBy_iff\">Pi.covBy_iff</a> to characterize irreducible elements in a direct product monoid, but the equivalence between covBy and Irreducible doesn't work if multiplication isn't cancellative. (See <a href=\"https://github.com/leanprover-community/mathlib4/pull/27936/files#diff-d91f23712d1df1b46b934712d9e32a63b98531a01ef9d90feaa4653bfb7cb7a6\">the binary version</a> that I already proved.) I wonder if there's anything more general to encompass both. I'm actually interested in showing <code>single _ 1 : Finsupp _ Nat</code> is AddIrreducible, which implies <code>MvPolynomial.X _</code> is irreducible. (Interesting to note that an additive UniqueFactorizationMonoid is just a group times <code>Finsupp _ Nat</code>.)</p>",
        "id": 533467284,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1754660675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60IsAtom.60.20is.20wrong.20for.20preorders/near/533460535\">said</a>:</p>\n<blockquote>\n<p>Yes, but that's a sort of non-example: We don't use <code>Preorder</code> to talk about divisibility</p>\n</blockquote>\n<p>Wait, what <em>do</em> we use?</p>",
        "id": 536947630,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1756600035
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Dvd#doc\">docs#Dvd</a></p>",
        "id": 536948578,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1756601515
    },
    {
        "content": "<p>sure<br>\nI guess I'm asking, do we not view it as an order at all?</p>",
        "id": 536948633,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1756601593
    },
    {
        "content": "<p>We do in the context of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Associates#doc\">docs#Associates</a></p>",
        "id": 536949797,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1756603364
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Associates.instPreorder#doc\">docs#Associates.instPreorder</a></p>",
        "id": 536949833,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1756603419
    }
]