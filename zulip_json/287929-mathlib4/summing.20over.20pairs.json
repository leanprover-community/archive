[
    {
        "content": "<p>Am I right in thinking that if a paper says that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>‚äÜ</mo><mi>X</mi><mo>√ó</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">C\\subseteq X\\times Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚äÜ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">√ó</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> and we want to do <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>‚àë</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>‚àà</mo><mi>C</mi></mrow></msub><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\sum_{(x,y)\\in C}f(x)g(y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2247em;vertical-align:-0.4747em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">‚àë</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2253em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">x</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose mtight\">)</span><span class=\"mrel mtight\">‚àà</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4747em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> then in Lean I have to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">‚àë'</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùìí</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n</code></pre></div>\n<p>? This looks so much messier than the LaTeX. Here are my failed examples to make it look better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚àë'</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"c1\">-- works and is ugly</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚àë'</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"c1\">-- doesn't typecheck</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚àë'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"c1\">-- doesn't compile</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚àë'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"c1\">-- doesn't compile</span>\n</code></pre></div>\n<p>The last one would somehow be the best one (but I am half-dreading that even if it did typeheck it wouldn't be correct because of the weird issue involving summing over proofs).</p>",
        "id": 561909500,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764862353
    },
    {
        "content": "<p>Is your C finite?</p>",
        "id": 561909856,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1764862426
    },
    {
        "content": "<p>Ha ha I am not sure! It's this paper <a href=\"https://arxiv.org/pdf/2204.10309\">https://arxiv.org/pdf/2204.10309</a> , Theorem 1.3. Maybe \"not necessarily\"?</p>",
        "id": 561911122,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764862737
    },
    {
        "content": "<p>I have got it into my head that I want formalizations of hard mathematical statements to look as much like the mathematics as I can make it as opposed to following mathlib conventions, because this is not mathlib (this is the formalize Annals paper project, so we have x &gt;= y and everything)</p>",
        "id": 561912265,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764862990
    },
    {
        "content": "<p>For finite sums we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>We can definitely make a similar (d)elaborator for infinite sums</p>",
        "id": 561912384,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1764863023
    },
    {
        "content": "<p>Probably not finite, then. So indeed you need <code>‚àë'</code>. Your functions should be ENNReal-valued, though, which avoids the issue with subtypes, but that's not answering your question at all. We have sophisticated notation for finite sums, but I don't think it has made its way to infinite sums.</p>",
        "id": 561912577,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1764863072
    },
    {
        "content": "<p>Oh sure, this was just an MWE, David Ledvinka is well aware of this issue and indeed did use ENNReal.</p>",
        "id": 561912895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764863153
    },
    {
        "content": "<p>By the way, this is the kind of paper that already looks completely formalizable (i.e., without crazy prerequisites). A good job for one of the autoformalization startup? (Except that math papers are littered with ambiguities -- for instance, in Theorem 1.1 of this paper, is L independent of M or not?)</p>",
        "id": 561916697,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1764864015
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/287929-mathlib4/topic/summing.20over.20pairs/near/561916697\">said</a>:</p>\n<blockquote>\n<p>By the way, this is the kind of paper that already looks completely formalizable (i.e., without crazy prerequisites). </p>\n</blockquote>\n<p>Yeah, I discussed this with the second author of the paper last year, and made a tiny amount of progress towards it at the time. It would definitely be really nice to have, and has super-useful applications in probabilistic combi.</p>",
        "id": 561925222,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1764866057
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/287929-mathlib4/topic/summing.20over.20pairs/near/561916697\">said</a>:</p>\n<blockquote>\n<p>By the way, this is the kind of paper that already looks completely formalizable (i.e., without crazy prerequisites). A good job for one of the autoformalization startup? (Except that math papers are littered with ambiguities -- for instance, in Theorem 1.1 of this paper, is L independent of M or not?)</p>\n</blockquote>\n<p>Yeah I agree with both your points! I think this is also true for several of the papers I have been working on formalizing the statements of for this project (which will eventually be made public).</p>\n<p>In this case Theorem 1.1 is actually a well known previous Theorem which motivate the main results of the paper (L is a universal constant). You would think a sufficiently strong autoformalizer should be able to infer this from the proof. Funny enough I think the referenced theorem number is wrong as far as I could tell but this is made explicit in Proposition 3.2 here: <a href=\"https://michel.talagrand.net/prizes/small.pdf\">https://michel.talagrand.net/prizes/small.pdf</a>.</p>",
        "id": 561928345,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1764866845
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/summing.20over.20pairs/near/561912384\">said</a>:</p>\n<blockquote>\n<p>For finite sums we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚àë</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>We can definitely make a similar (d)elaborator for infinite sums</p>\n</blockquote>\n<p>Would this be desirable for mathlib? I haven't written elaborators and delaborators before but wouldn't mind learning, so I could try this and PR.</p>",
        "id": 561929709,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1764867180
    },
    {
        "content": "<p>With my formalizing annals hat on I would definitely be keen on it, because we are trying to make the Lean look as much like the maths as possible, so that when I email authors saying \"look what we did to your theorem statement\" I minimise the chance that they are intimidated. In general notation questions can be complicated, especially if they're of the form \"let's try using <code>(</code> or <code>[</code> in a yet another way\" because you can imagine that any such ideas would be brittle, but here it looks like a far more clear-cut case, especially if we already have it for finsets.</p>",
        "id": 561943957,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1764871237
    },
    {
        "content": "<p>I spent a few days thinking about the topic, and here are my two cents:</p>\n<p>I think that the real issue with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">‚àë'</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùìí</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n</code></pre></div>\n<p>is that it contains the numbers <code>1</code> and <code>2</code> which evoke arithmetical connotations that distract from the actual content of the term that is written. Numeric digits, especially in higher math where concrete numbers are quite rare, immediately catch the reader's eye before the reader's brain parses that the digits are actually used to denote projections. Writing</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">‚àë'</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùìí</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">snd</span>\n</code></pre></div>\n<p>improves the readability but is perhaps too long. Unfortunately, its readability relies on <code>f</code>, <code>g</code>, and most importantly <code>c</code> being highlighted by color or bold font so that they don't become just one of many letters written in a sequence of letters. The letter <code>c</code> should scream \"I am the variable!\". But let's assume we have a good semantic highlighting, as it is necessary for good readability of Lean in any case.</p>\n<p>Something that could potentially improve our lives but Mathlib maintainers would certainly dislike would be declaring <code>.frst</code> to mean <code>.val.fst</code> and similarly <code>.scnd</code> to mean <code>.val.snd</code> so that we could write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">‚àë'</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùìí</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">frst</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">scnd</span>\n</code></pre></div>\n<p>or something like that.</p>",
        "id": 563150046,
        "sender_full_name": "Martin Dvo≈ô√°k",
        "timestamp": 1765448761
    },
    {
        "content": "<p>I don't think any of those solutions are too bad if <code>c.val.1</code> and <code>c.val.2</code> are \"similar\" things. The above was a MWE but in my actual use case <code>ùìí</code> is a set of pairs where the first element is a function and the second element is a real number, having <code>c.val.fst</code> be a function and <code>c.val.snd</code> be a number looks confusing (and I think thats true for any of those solutions). Its unclear how often cases like these will come up though.</p>",
        "id": 563180373,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1765457929
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"223948\">David Ledvinka</span> <a href=\"#narrow/channel/287929-mathlib4/topic/summing.20over.20pairs/near/561929709\">said</a>:</p>\n<blockquote>\n<p>Would this be desirable for mathlib? I haven't written elaborators and delaborators before but wouldn't mind learning, so I could try this and PR.</p>\n</blockquote>\n<p>Oops, I missed this question. I think this would be desirable. I agree with Kevin that we want statements to look nice.</p>\n<p>It shouldn't be super hard to copy-paste the <code>Finset.sum</code> delaborators and modify them for <code>tsum</code>. A nicer (but much trickier) approach would be to have some general framework for this, which we can then also use for binders in other places (e.g. <code>finsum</code>, and maybe even things like big unions, infima and integrals).</p>",
        "id": 563182824,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1765458723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"223948\">David Ledvinka</span> <a href=\"#narrow/channel/287929-mathlib4/topic/summing.20over.20pairs/near/563180373\">said</a>:</p>\n<blockquote>\n<p>I don't think any of those solutions are too bad if <code>c.val.1</code> and <code>c.val.2</code> are \"similar\" things. The above was a MWE but in my actual use case <code>ùìí</code> is a set of pairs where the first element is a function and the second element is a real number, having <code>c.val.fst</code> be a function and <code>c.val.snd</code> be a number looks confusing (and I think thats true for any of those solutions). Its unclear how often cases like these will come up though.</p>\n</blockquote>\n<p>In these situations, the only \"better\" solution is to declare a new structure with suitable names of the two parts.</p>",
        "id": 563384695,
        "sender_full_name": "Martin Dvo≈ô√°k",
        "timestamp": 1765526023
    }
]