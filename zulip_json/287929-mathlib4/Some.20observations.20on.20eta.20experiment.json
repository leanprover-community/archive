[
    {
        "content": "<p>I tried to understand why we need the eta experiment so much in e.g <a href=\"https://github.com/leanprover-community/mathlib4/pull/3708\">!4#3708</a>, and I've managed to minimize it to this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Module.LinearMap</span>\n\n<span class=\"c1\">-- succeeds</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R₁</span> <span class=\"n\">R₂</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M₂</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R₁</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R₂</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R₁</span> <span class=\"bp\">→+*</span> <span class=\"n\">R₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">SemilinearMapClass</span> <span class=\"o\">(</span><span class=\"n\">M₁</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"n\">σ</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:=</span>\n<span class=\"n\">inferInstance</span>\n\n<span class=\"c1\">-- fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R₁</span> <span class=\"n\">R₂</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M₂</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R₁</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R₂</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R₁</span> <span class=\"bp\">→+*</span> <span class=\"n\">R₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">SemilinearMapClass</span> <span class=\"o\">(</span><span class=\"n\">M₁</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"n\">σ</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:=</span>\n<span class=\"n\">inferInstance</span>\n\n<span class=\"c1\">-- succeeds</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">synthInstance.etaExperiment</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R₁</span> <span class=\"n\">R₂</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M₂</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R₁</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R₂</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R₁</span> <span class=\"bp\">→+*</span> <span class=\"n\">R₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">SemilinearMapClass</span> <span class=\"o\">(</span><span class=\"n\">M₁</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"n\">σ</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:=</span>\n<span class=\"n\">inferInstance</span>\n</code></pre></div>\n<p>I believe that this explains quite a lot of troubles we've had when working with (continuous) semilinear maps, and looking at it closer it seems that the problem comes from unifying the <code>NonAssocSemiring</code> instances appearing in <code>σ : R₁ →+* R₂</code>: in one case it's <code>Ring -&gt; NonAssocRing -&gt; NonAssocSemiring</code> while in the other it's <code>Ring -&gt; Semiring -&gt; NonAssocSemiring</code>. So it would be really nice to try and optimize this diamond: of course there will still be cases where we <em>need</em> eta reduction, but right now we are at the point where some files need <code>synthInstance.etaExperiment</code> for every lemma, which slows down typeclass search a lot, so we could try to optimize that.</p>",
        "id": 354981202,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1682976823
    },
    {
        "content": "<p>I've tried to play a bit with the precise definition of all the <code>Ring</code>-like structure, but I didn't find how to make it work yet. I guess we could just make all of them extend <code>NonUnitalNonAssocSemiring</code> and have all fields be added to that, but at that point it's not clear if we get any of the advantages of new structures. Anyway, if someone wants to play with that, I thought this was a good test.</p>",
        "id": 354981597,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1682976996
    },
    {
        "content": "<p>You should read Eric's paper if he'll send it to you. It's quite good.</p>",
        "id": 354982728,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1682977597
    },
    {
        "content": "<p>Maybe I should just send it to arXiv, I just wasn't ready to fight their TeX compiler just yet</p>",
        "id": 354982786,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682977638
    },
    {
        "content": "<p>(I already sent it to <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>)</p>",
        "id": 354982820,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682977659
    },
    {
        "content": "<p>Yes I've read it, and I understood from it that the only two ways to get to a situation where everything works is either to flatten everything back of to enable the <code>etaExperiment</code>. My point is, even if we have to manually do it for now in some places, since there are so many cases that could be solved all at once, maybe it would be worth trying to change this one diamond (between <code>Ring</code> and <code>NonAssocSemiring</code>), at least to make porting easier (in its current state, <code>Analysis.NormedSpace.OperatorNorm</code> is <em>very</em> slow to compile because of <code>etaExperiment</code> being enabled for most lemmas). Sorry if I'm juste re-discovering well-known facts.</p>",
        "id": 354983948,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1682978174
    },
    {
        "content": "<p>I agree that some small-scale optimization of the \"preferred\" paths could work as an interim solution</p>",
        "id": 354985589,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682978833
    },
    {
        "content": "<p>I suspect something else that would help is changing the priority of the first parent of structures to be higher than that of subsequent parents; but I think there is a lean bug that makes that impossible</p>",
        "id": 354985639,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682978863
    },
    {
        "content": "<p>Did you open an issue? Sounds like it might be more easily fixed than type class inference!</p>",
        "id": 354986546,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682979311
    },
    {
        "content": "<p>Yes, there's already an issue about not being able to change <code>extends</code> priority</p>",
        "id": 354986967,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682979544
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/2115\">lean4#2115</a></p>",
        "id": 354987024,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682979574
    },
    {
        "content": "<p>Could <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> or <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> put a <code>mathlib-high-prio</code> label on that one?</p>",
        "id": 354987836,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1682980001
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 355000164,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1682987576
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 355000250,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1682987634
    },
    {
        "content": "<p>I think I have finally understood something that Eric Wieser had already explained to me, that there is no way to avoid either eta or flat structures, and that I had not fullly grasped at the time. Let me record this for my future self, and maybe others.</p>\n<p>When a structure <code>B</code> extends <code>A</code>, then it has normally a field <code>toA</code> (and additional fields).</p>\n<p>Suppose now that both <code>B</code> and <code>C</code> extend <code>A</code>, and that <code>D</code> extends <code>B</code> and <code>C</code> (think <code>A = NonUnitalNonAssocSemiring</code> and <code>B = NonUnitalSemiring</code> and <code>C = NonAssocSemiring</code> and <code>D = Semiring</code>). Then one can not put in <code>D</code> two fields <code>toC</code> and <code>toB</code>, as the two maps one would get to <code>A</code> would be unrelated. Instead, one makes an arbitrary choice that there is a field <code>toC</code>, say, and additional fields that correspond to the missing fields of <code>B</code>. And the map from <code>D</code> to <code>B</code> is an ad-hoc construction, such that <code>D.toB foo</code> has a field <code>toA</code> given by <code>foo.toC.toA</code> and the other missing fields added by hand. In this way, both ways to go from <code>D</code> to <code>A</code> commute definitionally, and there is no diamond issue.</p>\n<p>Note a big difference between the two maps <code>D.toC</code> and <code>D.toB</code> above. The map <code>D.toC foo</code> produces a whole structure <code>C</code> (without defining fields individually) (I will say this is a whole map) while <code>D.toB foo</code> produces a structure by filling in individual fields (I will say this is an opening map).</p>\n<p>For now, everything is fine. Assume now that there are other structures with a prime, that follow the same inheritance as above (<code>D'</code> extends <code>C'</code> and <code>B'</code>, which both extend <code>A'</code>), and moreover each primed version extends the non-primed one (remove <code>Semi</code> in the examples above). How should one set the maps in the cube <code>A, B, C, D, A', B', C', D'</code>? Which ones should be whole and which ones should be opening?</p>\n<p>The claim is that there is no solution for this diagram (which shows up in mathlib) where all arrows commute definitionally if we don't use eta or flat structures. Flat structures ensures that all the maps are opening, and would solve all the issues. Assume instead we want to use whole maps whenever possible for performance reasons, say one whole map going out of each vertex (property (I)). Without eta, something obtained from a whole map can not be defeq to something obtained from an opening map if I understand right, so if we want defeq everywhere, each vertex in the cube should be the target only of opening maps, or only of whole maps (property (II)).</p>\n<p>Then one cheks that there is no labelling of the oriented edges of the cube <code>A, B, C, D, A', B', C', D'</code> by whole maps or opening maps satisfying the properties (I) and (II). Too bad...</p>",
        "id": 355336941,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1683096770
    },
    {
        "content": "<p>And because turning on structure eta in typeclass search makes things slower, so is not acceptable, the only solution is flat structures, right? <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span></p>\n<p>PS thanks a lot Sebastien -- your explanation has finally made the penny drop about what the issue is.</p>",
        "id": 355341186,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683098090
    },
    {
        "content": "<p>Well, the other option is to redesign the hierarchy with a different amount of bundling, by going full mixin on notation typeclasses. But that will be a huge refactor. (And we don't have a solid amount of data to know if the result will actually be usable in practice.)</p>",
        "id": 355341956,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1683098326
    },
    {
        "content": "<p>I know it's probably way too late but remember than some people have been telling us for five years that the solution is to use unification hints instead of type classes.</p>",
        "id": 355342815,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1683098567
    },
    {
        "content": "<p>I don't understand what you're proposing Johan (and I'd be interested to understand). Sebastien is saying that we can't have property (I) which means we can't have \"whole maps\" (forgetful functors) at all if we want to preserve defeq (which we do if eta is off).</p>",
        "id": 355343691,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683098764
    },
    {
        "content": "<p>Oh, you mean <code>[ring_notation R]</code> to be +-*01?</p>",
        "id": 355343991,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683098844
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>, your explanation is missing an important piece; the problem only arises when you add typeclasses that depend on other typeclasses to the mix, like <code>module</code>, <code>star_ring</code>, and <code>archimedean</code></p>",
        "id": 355345346,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683099241
    },
    {
        "content": "<p>I will try to submit my CICM preprint to arXiv today, as it includes that note</p>",
        "id": 355345718,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683099350
    },
    {
        "content": "<p>Can you explain why? I had the impression that the cube example gives rise to non-defeq diamonds whatever you do, even without additional typeclasses that depend on those, unless you use eta or flat structures.</p>",
        "id": 355358155,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1683102643
    },
    {
        "content": "<p>Those non-defeq diamonds don't matter if in the end you just use the raw data projections, as composed with those projections the results are defeq again</p>",
        "id": 355359328,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683102930
    },
    {
        "content": "<p>I suppose probably you hit the same problem with structures that consume other typeclasses, not just typeclasses consuming typeclasses</p>",
        "id": 355359603,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683102978
    },
    {
        "content": "<p>Sure, you need something that uses the full <code>A</code>, and not subfields of <code>A</code>.</p>",
        "id": 355360151,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1683103122
    },
    {
        "content": "<p>In practice I think that something has to be an <code>inductive</code>, though I suppose an irreducible def might do the trick too</p>",
        "id": 355360486,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683103203
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Some.20observations.20on.20eta.20experiment/near/355342815\">said</a>:</p>\n<blockquote>\n<p>I know it's probably way too late but remember than some people have been telling us for five years that the solution is to use unification hints instead of type classes.</p>\n</blockquote>\n<p>What does the unification hints solution look like?</p>\n<p>Note that we used flat structures for 5 years and also had very few problems.</p>",
        "id": 355373566,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683106230
    },
    {
        "content": "<p>Kevin, you forgot: \"... and a slow mathlib.\" Of course, I'm not claiming that this is a major contributing factor to that, but maybe it played some role.</p>",
        "id": 355416585,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1683116016
    },
    {
        "content": "<p>We may just be able to turn on eta globally. There is a patch to Lean4 + mathlib4 by Gabriel that does this (and which I've just updated to current master), and it's faster than the current mathlib4. It may take a while to work out how / if / when it could be merged, but don't despair that we're stuck with <code>etaExperiment</code> quite yet. :-)</p>",
        "id": 355417568,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1683116243
    },
    {
        "content": "<p>Here's a diagrammatic representation of <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>'s post above:</p>\n<p><a href=\"/user_uploads/3121/6b1beHAFjnZi2nzXZJsEnbgi/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/6b1beHAFjnZi2nzXZJsEnbgi/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/6b1beHAFjnZi2nzXZJsEnbgi/image.png\"></a></div>",
        "id": 363356450,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685814747
    },
    {
        "content": "<p>Is there an algebraic hierarchy design that works better with Lean 4?</p>",
        "id": 363401662,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1685839429
    },
    {
        "content": "<p>Flat structures like lean 3. But then they'll become gigantic and slow in the long run</p>",
        "id": 363446837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685868262
    },
    {
        "content": "<p>It's not clear to me that flat structures have any reason to be less performant than nested structures, in the presence of eta expansion</p>",
        "id": 363452633,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685870396
    },
    {
        "content": "<p>Aren't the main problems these defeq pseudo-diamonds which lean 4 spends forever fussing about?</p>",
        "id": 363466853,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685874893
    },
    {
        "content": "<p>I don't think switching between the two approaches has much effect on whether it should spend forever fussing</p>",
        "id": 363476204,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685877985
    },
    {
        "content": "<p>Though it's certainly easier to reason about the flat case!</p>",
        "id": 363476281,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685878011
    },
    {
        "content": "<p>Why did Lean 3's typeclass system have no problems unifying <code>Field.toSemiring</code> and <code>Ring.toSemiring</code> and <code>CommSemiring.toSemiring</code>?</p>",
        "id": 363477417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685878357
    },
    {
        "content": "<p>Will we reduce the number of diamonds if we somehow decouple data and properties?</p>",
        "id": 363543988,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1685900618
    },
    {
        "content": "<p>What is the trade-off here?</p>",
        "id": 363544011,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1685900634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Some.20observations.20on.20eta.20experiment/near/363356450\">said</a>:</p>\n<blockquote>\n<p>Here's a diagrammatic representation of <span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span>'s post above:</p>\n</blockquote>\n<p>Having now published this, I realize that this claim is false; in particularly, this plausible characterization turns out not to the the case</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Some.20observations.20on.20eta.20experiment/near/355336941\">said</a>:</p>\n<blockquote>\n<p>Without eta, something obtained from a chain of whole maps can not be defeq to something obtained from an opening map if I understand right</p>\n</blockquote>\n<p>The true statement is that something obtained <em>only</em> from whole maps cannot be defeq to something not obtained this way. Once both paths include an open step, then all bets are off unless you can see the full graph.</p>\n<blockquote>\n<p>The claim is that there is no solution for this diagram</p>\n</blockquote>\n<p>The figure in my post above <a href=\"https://github.com/eric-wieser/lean-multiple-inheritance/blob/master/lean3/main.lean#L148-L200\">is precisely such a solution</a>, I apparently did not check it correctly in Lean</p>",
        "id": 388597708,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693601431
    },
    {
        "content": "<p>So we should go back to carefully choosing spanning trees a la <a href=\"https://github.com/leanprover-community/mathlib4/pull/6011\">#6011</a> ?</p>",
        "id": 388598337,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1693601685
    },
    {
        "content": "<p>Well, we still don't know that it's possible for sure; all we know is that the counterexample we thought we had wasn't good enough</p>",
        "id": 388599489,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693602235
    },
    {
        "content": "<p>If a solution is possible, I think the above is pretty strong evidence that we can't be trusted to find it by hand</p>",
        "id": 388599543,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693602257
    },
    {
        "content": "<p>It definitely still isn't possible to solve it for cyclic typeclass graphs, but we pretty much never use those anyway</p>",
        "id": 388599648,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693602328
    },
    {
        "content": "<p>that picture is: one down-arrow from nu_semi to nu_na_semi, and then two right arrows (adding nu) and four left arrows (dropping semi). Is that what the pattern is supposed to be?</p>",
        "id": 388599827,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1693602401
    },
    {
        "content": "<p>That picture is neither intended to represent reality, or to represent what mathlib should change to. It was supposed to be a counterexample, but... At any rate, we're not solving for just that cube in mathlib; we're solving for the entire graph of typeclasses</p>",
        "id": 388599991,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693602494
    },
    {
        "content": "<p>I'm not sure I understand whether this problem is expressible using just graph theory</p>",
        "id": 388600004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693602503
    },
    {
        "content": "<p>is there some property of the dotted edges that we want to ensure?</p>",
        "id": 388600036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693602521
    },
    {
        "content": "<p>not to mention that if you include eta then everything becomes a defeq so I don't know any more what is being measured from a theory perspective</p>",
        "id": 388600158,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693602582
    },
    {
        "content": "<blockquote>\n<p>not to mention that if you include eta then everything becomes a defeq</p>\n</blockquote>\n<p>Right, to test these things you have to use Lean 3.</p>",
        "id": 388600250,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693602607
    },
    {
        "content": "<p>okay so the claim is about defeq without eta?</p>",
        "id": 388600297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693602629
    },
    {
        "content": "<p>Yes, exactly</p>",
        "id": 388600306,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693602637
    },
    {
        "content": "<p>and you want to evaluate whether any two paths are defeq?</p>",
        "id": 388600350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693602661
    },
    {
        "content": "<p>So this isn't a problem with us using eta, but it <em>is</em> a problem in my/our understanding of why (and whether) it was necessary</p>",
        "id": 388600363,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693602665
    },
    {
        "content": "<p>I just want to understand what the theoretical version of the problem is, and to what extent the picture above is or isn't a counterexample and what properties you need to find a real one</p>",
        "id": 388600469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693602720
    },
    {
        "content": "<p>What does it mean, precisely, that the given square does not commute?</p>",
        "id": 388600614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693602774
    },
    {
        "content": "<p>are you saying that given a variable of type <code>ring</code>, the two paths yield terms of type <code>na_semiring</code> that are not defeq without eta?</p>",
        "id": 388600681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693602813
    },
    {
        "content": "<p>That is what the original (false) claim was, yes</p>",
        "id": 388600699,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693602827
    },
    {
        "content": "<p>are these non-flat structures?</p>",
        "id": 388600761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693602853
    },
    {
        "content": "<p>Yes, it's all trivial for flat structures</p>",
        "id": 388600782,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693602864
    },
    {
        "content": "<p>Here's a model of that situation if I understand correctly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">NUNASemiring</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">structure</span> <span class=\"n\">NUSemiring</span> <span class=\"n\">where</span>\n  <span class=\"n\">to</span> <span class=\"o\">:</span> <span class=\"n\">NUNASemiring</span>\n  <span class=\"n\">assoc</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n<span class=\"kd\">structure</span> <span class=\"n\">NASemiring</span> <span class=\"n\">where</span>\n  <span class=\"n\">to</span> <span class=\"o\">:</span> <span class=\"n\">NUNASemiring</span>\n  <span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Semiring</span> <span class=\"n\">where</span>\n  <span class=\"n\">to</span> <span class=\"o\">:</span> <span class=\"n\">NUSemiring</span>\n  <span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n<span class=\"kd\">structure</span> <span class=\"n\">NARing</span> <span class=\"n\">where</span>\n  <span class=\"n\">to</span> <span class=\"o\">:</span> <span class=\"n\">NASemiring</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n<span class=\"kd\">structure</span> <span class=\"n\">NUNARing</span> <span class=\"n\">where</span>\n  <span class=\"n\">to</span> <span class=\"o\">:</span> <span class=\"n\">NUNASemiring</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n<span class=\"kd\">structure</span> <span class=\"n\">NURing</span> <span class=\"n\">where</span>\n  <span class=\"n\">to</span> <span class=\"o\">:</span> <span class=\"n\">NUSemiring</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Ring</span> <span class=\"n\">where</span>\n  <span class=\"n\">to</span> <span class=\"o\">:</span> <span class=\"n\">Semiring</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Ring.toNA</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">NARing</span> <span class=\"n\">where</span>\n  <span class=\"n\">to.to</span> <span class=\"o\">:=</span> <span class=\"n\">r.to.to.to</span>\n  <span class=\"n\">to.unit</span> <span class=\"o\">:=</span> <span class=\"n\">r.to.unit</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:=</span> <span class=\"n\">r.neg</span>\n<span class=\"kd\">def</span> <span class=\"n\">Ring.toNU</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">NURing</span> <span class=\"n\">where</span>\n  <span class=\"n\">to</span> <span class=\"o\">:=</span> <span class=\"n\">r.to.to</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:=</span> <span class=\"n\">r.neg</span>\n<span class=\"kd\">def</span> <span class=\"n\">Semiring.toNA</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Semiring</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">NASemiring</span> <span class=\"n\">where</span>\n  <span class=\"n\">to</span> <span class=\"o\">:=</span> <span class=\"n\">r.to.to</span>\n  <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"n\">r.unit</span>\n<span class=\"kd\">def</span> <span class=\"n\">Semiring.toNU</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Semiring</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">NUSemiring</span> <span class=\"n\">where</span>\n  <span class=\"n\">to</span> <span class=\"o\">:=</span> <span class=\"n\">r.to.to</span>\n  <span class=\"n\">assoc</span> <span class=\"o\">:=</span> <span class=\"n\">r.to.assoc</span>\n<span class=\"kd\">def</span> <span class=\"n\">NURing.toNA</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">NURing</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">NUNARing</span> <span class=\"n\">where</span>\n  <span class=\"n\">to</span> <span class=\"o\">:=</span> <span class=\"n\">r.to.to</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:=</span> <span class=\"n\">r.neg</span>\n<span class=\"kd\">def</span> <span class=\"n\">NARing.toNU</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">NARing</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">NUNARing</span> <span class=\"n\">where</span>\n  <span class=\"n\">to</span> <span class=\"o\">:=</span> <span class=\"n\">r.to.to</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:=</span> <span class=\"n\">r.neg</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Eq'</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">Eq</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Semiring</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq'</span> <span class=\"n\">r.toNA.to</span> <span class=\"n\">r.to.to</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Semiring.toNA</span><span class=\"o\">]</span>\n  <span class=\"n\">guard_target</span> <span class=\"bp\">=ₛ</span> <span class=\"n\">Eq'</span> <span class=\"n\">r.to.to</span> <span class=\"n\">r.to.to</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">NURing</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq'</span> <span class=\"n\">r.toNA.to</span> <span class=\"n\">r.to.to</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">NURing.toNA</span><span class=\"o\">]</span>\n  <span class=\"n\">guard_target</span> <span class=\"bp\">=ₛ</span> <span class=\"n\">Eq'</span> <span class=\"n\">r.to.to</span> <span class=\"n\">r.to.to</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">NARing</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq'</span> <span class=\"n\">r.toNU.to</span> <span class=\"n\">r.to.to</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">NARing.toNU</span><span class=\"o\">]</span>\n  <span class=\"n\">guard_target</span> <span class=\"bp\">=ₛ</span> <span class=\"n\">Eq'</span> <span class=\"n\">r.to.to</span> <span class=\"n\">r.to.to</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq'</span> <span class=\"n\">r.toNU.to</span> <span class=\"n\">r.to.to</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Ring.toNU</span><span class=\"o\">]</span>\n  <span class=\"n\">guard_target</span> <span class=\"bp\">=ₛ</span> <span class=\"n\">Eq'</span> <span class=\"n\">r.to.to</span> <span class=\"n\">r.to.to</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq'</span> <span class=\"n\">r.toNA.to</span> <span class=\"n\">r.to.toNA</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"c1\">-- the one in the paper</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Ring.toNA</span><span class=\"o\">,</span> <span class=\"n\">Semiring.toNA</span><span class=\"o\">]</span>\n  <span class=\"n\">guard_target</span> <span class=\"bp\">=ₛ</span> <span class=\"bp\">@</span><span class=\"n\">Eq'</span> <span class=\"n\">NASemiring</span> <span class=\"o\">⟨</span><span class=\"n\">r.to.to.to</span><span class=\"o\">,</span> <span class=\"n\">r.to.unit</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">r.to.to.to</span><span class=\"o\">,</span> <span class=\"n\">r.to.unit</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq'</span> <span class=\"n\">r.toNA.toNU</span> <span class=\"n\">r.toNU.toNA</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Ring.toNU</span><span class=\"o\">,</span> <span class=\"n\">NARing.toNU</span><span class=\"o\">,</span> <span class=\"n\">NURing.toNA</span><span class=\"o\">,</span> <span class=\"n\">Ring.toNA</span><span class=\"o\">]</span>\n  <span class=\"n\">guard_target</span> <span class=\"bp\">=ₛ</span> <span class=\"bp\">@</span><span class=\"n\">Eq'</span> <span class=\"n\">NUNARing</span> <span class=\"o\">⟨</span><span class=\"n\">r.to.to.to</span><span class=\"o\">,</span> <span class=\"n\">r.neg</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">r.to.to.to</span><span class=\"o\">,</span> <span class=\"n\">r.neg</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- fail test</span>\n<span class=\"kd\">def</span> <span class=\"n\">Ring.toNU'</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">NURing</span> <span class=\"n\">where</span>\n  <span class=\"n\">to.to</span> <span class=\"o\">:=</span> <span class=\"n\">r.to.to.to</span>\n  <span class=\"n\">to.assoc</span> <span class=\"o\">:=</span> <span class=\"n\">r.to.to.assoc</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:=</span> <span class=\"n\">r.neg</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq'</span> <span class=\"n\">r.toNU'.to</span> <span class=\"n\">r.to.to</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Ring.toNU'</span><span class=\"o\">]</span>\n  <span class=\"n\">fail_if_success</span> <span class=\"n\">guard_target</span> <span class=\"bp\">=ₛ</span> <span class=\"n\">Eq'</span> <span class=\"n\">r.to.to</span> <span class=\"n\">r.to.to</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Note that <code>dsimp only</code> will not use eta here</p>",
        "id": 388602389,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693603663
    },
    {
        "content": "<p>Note I edited a link to a (lean3) model in my top post; it looks like your model is indeed the same</p>",
        "id": 388602580,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693603775
    },
    {
        "content": "<p>Note the challenge is <em>not</em> to show that a situation with failing defeq exists (the paper already contains a genuine one), but to show that for any unlabelled graph, it's possible to label the edges as <code>to</code> or <code>toX</code> (to use your naming) such that no such problem is present</p>",
        "id": 388602746,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693603841
    },
    {
        "content": "<p>wait, so your (new) claim is that it is always possible to make a DAG commute by some spanning tree?</p>",
        "id": 388603656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693604397
    },
    {
        "content": "<p>I did actually insert a bit of \"domain knowledge\" into the model: it's a cube graph, and I added fields representing each thing that was lost in each forgetful functor</p>",
        "id": 388603781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693604481
    },
    {
        "content": "<p>in a general DAG it's not immediately obvious how to determine these extra fields, and they are relevant to the definitions of the non-parent projections</p>",
        "id": 388603825,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693604518
    },
    {
        "content": "<p>I'm pretty sure the extra fields are a distraction (beyond using \"forgetful inheritance\" to populate them)</p>",
        "id": 388603879,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693604539
    },
    {
        "content": "<p>maybe it would be good to have an example of a failing defeq in the same framework</p>",
        "id": 388603962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693604591
    },
    {
        "content": "<p><a href=\"https://github.com/eric-wieser/lean-multiple-inheritance\">https://github.com/eric-wieser/lean-multiple-inheritance</a> has such an example, admittedly without the clear statement of defeq</p>",
        "id": 388604000,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693604624
    },
    {
        "content": "<p>which one?</p>",
        "id": 388604110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693604689
    },
    {
        "content": "<p><a href=\"https://github.com/eric-wieser/lean-multiple-inheritance/blob/master/lean3/main.lean#L147-L149\">this one</a></p>",
        "id": 388604338,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693604830
    },
    {
        "content": "<p>(this doesn't confirm the fields are a distraction, but it's easy to eliminate them and check)</p>",
        "id": 388604394,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693604871
    },
    {
        "content": "<p>ah, my <code>dsimp only</code> trick doesn't work, here's a variant that should fail but doesn't</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Ring.toNU'</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">NURing</span> <span class=\"n\">where</span>\n  <span class=\"n\">to.to</span> <span class=\"o\">:=</span> <span class=\"n\">r.to.to.to</span>\n  <span class=\"n\">to.assoc</span> <span class=\"o\">:=</span> <span class=\"n\">r.to.to.assoc</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:=</span> <span class=\"n\">r.neg</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">r.toNU'.to</span> <span class=\"bp\">=</span> <span class=\"n\">r.to.to</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Ring.toNU'</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span>\n</code></pre></div>",
        "id": 388604863,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693605182
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Some.20observations.20on.20eta.20experiment/near/388603656\">said</a>:</p>\n<blockquote>\n<p>wait, so your (new) claim is that it is always possible to make a DAG commute by some spanning tree?</p>\n</blockquote>\n<p>Yes, that's my (tentative) claim</p>",
        "id": 388605315,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693605485
    },
    {
        "content": "<p>okay, I updated the code above with an indirection to avoid the accidental eta application</p>",
        "id": 388605679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693605730
    },
    {
        "content": "<p>and indeed you can remove all the auxiliary fields while retaining the same behavior</p>",
        "id": 388605763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693605795
    },
    {
        "content": "<p>Okay, so I think it can be phrased as a graph theory problem thusly: Given a DAG and a spanning tree of that DAG, given any two points <code>u</code> and <code>v</code> in the graph there is a unique path from <code>u</code> to <code>v</code> in the spanning tree, and a unique minimum element in that path wrt the DAG order, call that <code>lca(u, v)</code> (least common ancestor). We can extend this to any sequence of vertices <code>a1, ..., an</code> via <code>lca(a1, ..., an) = lca(a1, lca(a2, ..., an))</code>. Then we say a pair of paths <code>a1 -...-&gt; an</code>, <code>b1 -...-&gt; bm</code> (with <code>a1 = b1</code> and <code>an = bm</code>) in the original graph commutes if <code>lca(a1, ..., an) = lca(b1, ..., bn)</code>. Does every DAG admit a spanning tree such that every pair of paths with the same source and target in the original graph commutes?</p>",
        "id": 388607065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693606564
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Some.20observations.20on.20eta.20experiment/near/388597708\">said</a>:</p>\n<blockquote>\n<p>The true statement is that something obtained <em>only</em> from whole maps cannot be defeq to something not obtained this way. Once both paths include an open step, then all bets are off unless you can see the full graph.</p>\n</blockquote>\n<p>Very good point!</p>",
        "id": 388657427,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1693636255
    },
    {
        "content": "<p>Oh by the way <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> , I checked the graph theoretic statement for all dags with up to 7 points, and about a 20% random sampling of all 8 point configurations, for commuting triangles and squares. So that's some evidence that the statement is true, maybe it's worth trying to find a proof</p>",
        "id": 388727351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693687449
    },
    {
        "content": "<p>there are about 2^28 dags to check for 8 points and 2^36 for 9 points, if I let it run for a few hours I could probably get all 8 point configurations</p>",
        "id": 388727501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693687581
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> or <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> can you prove it?</p>",
        "id": 388727651,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1693687715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Some.20observations.20on.20eta.20experiment/near/388607065\">said</a>:</p>\n<blockquote>\n<p>Okay, so I think it can be phrased as a graph theory problem thusly: Given a DAG and a spanning tree of that DAG, given any two points <code>u</code> and <code>v</code> in the graph there is a unique path from <code>u</code> to <code>v</code> in the spanning tree, and a unique minimum element in that path wrt the DAG order, call that <code>lca(u, v)</code> (least common ancestor). We can extend this to any sequence of vertices <code>a1, ..., an</code> via <code>lca(a1, ..., an) = lca(a1, lca(a2, ..., an))</code>. Then we say a pair of paths <code>a1 -...-&gt; an</code>, <code>b1 -...-&gt; bm</code> (with <code>a1 = b1</code> and <code>an = bm</code>) in the original graph commutes if <code>lca(a1, ..., an) = lca(b1, ..., bn)</code>. Does every DAG admit a spanning tree such that every pair of paths with the same source and target in the original graph commutes?</p>\n</blockquote>\n<p>I think I'm misunderstanding something about the statement (although I haven't read the earlier context) - given a path, lca on the path doesn't depend on the tree, only on the DAG order, I think. So the commuting property shouldn't depend on the choice of tree either...</p>",
        "id": 388737921,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1693692245
    },
    {
        "content": "<p>Yes, it does. The lca is the least element on the unique path in the spanning tree.</p>",
        "id": 388739779,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1693693047
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Some.20observations.20on.20eta.20experiment/near/388739779\">said</a>:</p>\n<blockquote>\n<p>Yes, it does. The lca is the least element on the unique path in the spanning tree.</p>\n</blockquote>\n<p>Ah, I was confusing the path which is an input to the lca and the path used in its computation, thanks</p>",
        "id": 388740803,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1693693549
    },
    {
        "content": "<p>/me is thinking</p>",
        "id": 388781454,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1693718080
    },
    {
        "content": "<p>Mario, could you check if in your examples, a spanning tree that works can be obtained as follows:</p>\n<ul>\n<li>Among all pairs of paths with same beginning and end in the DAG, find one where the length of one of the two paths is maximal.</li>\n<li>Remove the last edge of that longest path.</li>\n<li>Repeat until there are no more pairs of paths joining two vertices.</li>\n</ul>\n<p>Does the resulting spanning tree have the right property ?</p>",
        "id": 388788018,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1693723419
    },
    {
        "content": "<p>I was about to say that paths lengths can't help, because you could split any edge into a series of edges; but I would have been incorrect, as when you do this all the new edges are solid lines</p>",
        "id": 388804560,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693733848
    },
    {
        "content": "<p>What's the lca of <code>a</code> and <code>c</code> in <code>a -&gt; b &lt;- c</code>? Does \"minimal\" here depend on the chosen topological ordering?</p>",
        "id": 388807883,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1693736288
    },
    {
        "content": "<p>Either way, here are some thoughts that may or may not be useful or correct. <br>\nThis only concerns the case where the DAG has a unique initial element. Take a DFS tree (respecting the DAG order) starting at the initial element. I think this tree makes the DAG commute.</p>\n<ul>\n<li>Note that in this construction the LCA of a set of nodes can be found by moving the deepest node \"upwards\" towards the root until they all coincide.</li>\n<li>All triangles commute. Consider a triangle <code>a -&gt; b -&gt; c</code>. If <code>a</code> is found before <code>b</code> by the DFS then <code>lca(a,b,c) = a</code>. If <code>b</code> is found first then <code>c</code> is a descendant of <code>b</code> and the path from <code>c</code> to <code>a</code> passes through <code>b</code>. If <code>c</code> is found first then draw (squiggly) paths from each point going to the root, and consider where they can intersect given the DFS property.</li>\n<li>Consider the transitive closure <code>G</code> of the DAG. Our DFS tree is still a valid DFS tree in <code>G</code>. Hence triangles commute in <code>G</code> and <code>G</code> commutes. Then so does our original DAG.</li>\n</ul>",
        "id": 388808292,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1693736610
    },
    {
        "content": "<p>Sorry, I should have specified better. I am assuming that the dag is directed, which implies for finite dags that there is a unique minimal element. The case of non-directed dags is not interesting because there are no spanning trees in that case (probably this is also a bit of underspecification; the spanning trees have to have the property that every vertex has in-degree at most 1). To have a spanning tree in that case, since there is one more vertex than edge, there must be exactly one node which has no parent, and that node must be the minimum of the dag because nothing else can point to the minimum element of the dag.</p>",
        "id": 388836509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693754477
    },
    {
        "content": "<blockquote>\n<p>Does \"minimal\" here depend on the chosen topological ordering?</p>\n</blockquote>\n<p>No</p>",
        "id": 388836641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693754527
    },
    {
        "content": "<p>I don't think the in-degree is limited to one in the real case; though I also don't know which way is in and which way is out in your description!</p>",
        "id": 388838176,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693755494
    },
    {
        "content": "<p>(doesn't the \"d\" in \"dag\" stand for \"directed\"?)</p>",
        "id": 388843893,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1693760561
    },
    {
        "content": "<p>There's also <a href=\"https://en.wikipedia.org/wiki/Directed_set\">directed</a> in the order sense, versus directed in the directed graph sense. The DAG induces an order (say if <code>u -&gt; v</code> then <code>u &lt;= v</code>), and it's directed if every finite subset of vertices has an upper bound. (I'm not sure which conventions are being used here, maybe Mario's using lower bound.) At least this is what I think is going on, I'm not following too closely.</p>",
        "id": 388867089,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693778708
    },
    {
        "content": "<p>oops, I mean downward directed (in the order sense) of course</p>",
        "id": 388898253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693797750
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Some.20observations.20on.20eta.20experiment/near/388838176\">said</a>:</p>\n<blockquote>\n<p>I don't think the in-degree is limited to one in the real case; though I also don't know which way is in and which way is out in your description!</p>\n</blockquote>\n<p>Hm, this does complicate matters if we are considering multiple \"preferred parents\" in the real case. If in the tree you have <code>a -&gt; b &lt;- c</code>, i.e. <code>b</code> has two parents, then it must be the case that <code>a</code> and <code>c</code> are incomparable - they have no common lower bound - in which case they have no lca. However this doesn't come up when considering pairs of paths with a common source and target, because in that case we only ever take the lca of comparable nodes (i.e. related in the transitive closure one way or the other).</p>",
        "id": 388899954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693798768
    },
    {
        "content": "<p>I think your arrows are backwards with respect to my diagram above (so indeed in and out are swapped)</p>",
        "id": 388905243,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693802315
    },
    {
        "content": "<p>But yes, that case can happen if <code>Semiring</code> extends <code>monoid</code> and <code>add_comm_monoid</code>, which would both be preferred/whole maps</p>",
        "id": 388905270,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693802337
    },
    {
        "content": "<p>I was using the same convention as <span class=\"user-mention silent\" data-user-id=\"585783\">Arend Mellendijk</span> and <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> there, so a root has in-degree zero</p>",
        "id": 388905753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693802649
    },
    {
        "content": "<p>oh yeah your diagram is the other way around</p>",
        "id": 388905776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693802674
    },
    {
        "content": "<p>I guess the usual convention for trees in CS gives the root in-degree 0</p>",
        "id": 388905863,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693802738
    }
]