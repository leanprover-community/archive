[
    {
        "content": "<p>Hello,<br>\nI want to prove that the Nucleus in Mathlib is a <code>CompleteSemilatticeInf</code>. I implemented it like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nucleus</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sInf_fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nucleus</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sInf_fun_increasing</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">sInf_fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">sInf_fun</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_apply</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sInf_fun_idempotent</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">sInf_fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sInf_fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">sInf_fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">sInf_fun</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_sInf_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_setOf_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">forall_exists_index</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">and_imp</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">forall_apply_eq_imp_iff₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sInf_le_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lowerBounds</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">idempotent</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">OrderHomClass</span><span class=\"bp\">.</span><span class=\"n\">GCongr</span><span class=\"bp\">.</span><span class=\"n\">mono</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">sInf_le_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lowerBounds</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sInf_preserves_inf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">sInf_fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">sInf_fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">sInf_fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">sInf_fun</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">InfHomClass</span><span class=\"bp\">.</span><span class=\"n\">map_inf</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">le_antisymm</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_inf_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_sInf_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_setOf_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sInf_le_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lowerBounds</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">forall_exists_index</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">and_imp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">forall_apply_eq_imp_iff₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">implies_true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">and_self</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_sInf_iff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">inf_le_of_left_le</span>\n<span class=\"w\">      </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">sInf_le_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lowerBounds</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">inf_le_of_right_le</span>\n<span class=\"w\">      </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">sInf_le_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lowerBounds</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">InfSet</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nucleus</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">sInf_fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sInf_preserves_inf</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sInf_fun_idempotent</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sInf_fun_increasing</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>This seems rather ugly to me, but I'm not sure how to do this differently. I separted the proofs into their own lemmas, because they are to big to be done inline at the sInf instance. Can these proofs be golfed considerably and(are there any helpful resources for me to learn how to shorten these? proofs)?. In general, what is the idiomatic way to handle such a case where the proofs are to big to fit in the instance definition?</p>",
        "id": 497861181,
        "sender_full_name": "Christian K",
        "timestamp": 1738752138
    },
    {
        "content": "<p>I noticed a few details which might be helpful (even thought they may not fully answer your question):</p>\n<ul>\n<li>side comment: I suspect most of your <code>def</code>s should be <code>lemma</code>s. (If you run #lint after your code, a <code>defLemma</code> linter should complain.)</li>\n<li>are all these <code>simp_all</code>s necessary, or does <code>simp</code> also work?</li>\n<li>if the latter; simp and exact can usually be combined into <code>simpa</code> or <code>simpa using</code>: for example <code>simp [foo]; exact bar</code> can usually become <code>simpa [foo] using bar</code></li>\n</ul>",
        "id": 497866986,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1738753863
    },
    {
        "content": "<p>Since you're asking about idiomatic code, let me also mention the mathlib convention <a href=\"https://leanprover-community.github.io/contribute/style.html#hypotheses-left-of-colon\">\"hypotheses left of colon\"</a>: instead of having a conclusion \"\\forall x, ...<code> and starting your proofs with </code>intro x<code>, it's shorter to make </code>x` part of the hypotheses.</p>",
        "id": 497867267,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1738753958
    },
    {
        "content": "<p>A few more comments:</p>\n<ul>\n<li>can <code>refine OrderHomClass.GCongr.mono a ?_</code> just become <code>gcongr</code>?</li>\n<li>the first subgoal in <code>sInf_preserves_inf</code> is a terminal simp: unless it's slow, you don't need to squeeze it (i.e. writing <code>simp</code> or <code>simp_all</code> is just fine)</li>\n<li>if you just want shorter code: <code>apply And.intro</code> should be equivalent to <code>constructor</code> or <code>refine \\&lt;?_, ?_\\&gt;</code> (these should be the correct angular brackets; cannot type them into zulip right now); if one proof is short you can also \"inline\" it (i.e. write <code>refine \\&lt;by simp, ?_\\&gt;</code>)</li>\n</ul>",
        "id": 497867780,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1738754130
    },
    {
        "content": "<p>Finally: writing out lemmas needed for these instances seems useful (particularly if you want to use those results separately, at some point in the future, or anticipate somebody wanting to do so).</p>\n<p>I have a number of comments now. Let me emphasize that all these are about style: your code <em>works already</em>; these are just things I'd do to make it more mathlib-ready.</p>",
        "id": 497868071,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1738754228
    },
    {
        "content": "<p>Thank you very much for your detailed comments, they are very helpful to me! I implemented them and created a <a href=\"https://github.com/leanprover-community/mathlib4/pull/21515\">PR</a>.</p>",
        "id": 498163610,
        "sender_full_name": "Christian K",
        "timestamp": 1738859717
    }
]