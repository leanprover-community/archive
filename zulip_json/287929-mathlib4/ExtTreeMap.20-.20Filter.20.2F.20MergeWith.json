[
    {
        "content": "<p>Can anyone please recommend an approach to proving properties about <code>Std.ExtTreeMap.filter</code> and <code>Std.ExtTreeMap.mergeWith</code> - the proofs that already exist regarding <code>Std.ExtTreeMap</code> use some exceedingly <a href=\"https://github.com/leanprover/lean4/blob/0071bea64eb57afff8339f22ec71944080246e7b/src/Std/Data/DTreeMap/Internal/Lemmas.lean#L135\">convoluted custom machinery</a>.</p>\n<p>For example, something <a href=\"https://github.com/NethermindEth/CertiPlonk/blob/651e0fa5b875faa72d4d203ead4f598acef0505e/CMvPolynomial/Wheels.lean#L90C1-L90C2\">as simple</a> as the analogue of <a href=\"https://github.com/leanprover/lean4/blob/0071bea64eb57afff8339f22ec71944080246e7b/src/Std/Data/ExtHashMap/Lemmas.lean#L1987\">Std.ExtHashMap.getElem?_filter</a>.</p>\n<p>I am happy to do the legwork, but I would appreciate some general guidance.</p>\n<p>In a broader context, we are reasonably close to finishing 'some' version of computable polynomials in Lean - in particular, <a href=\"https://github.com/NethermindEth/CertiPlonk/blob/651e0fa5b875faa72d4d203ead4f598acef0505e/CMvPolynomial/MvPolyEquiv.lean#L87\">we have an equivalence</a> between an <code>ExtTreeMap</code>-based polynomial with computable operations and <code>Mathlib.MvPolynomial</code> and we are midway towards a full <code>RingEquiv</code>.</p>\n<p>Please note that this is all very much WIP and in no way polished for any 'public' consumption.</p>",
        "id": 530754833,
        "sender_full_name": "FrantiÅ¡ek SilvÃ¡Å¡i ðŸ¦‰",
        "timestamp": 1753443641
    },
    {
        "content": "<p>It seems that noone has proved anything about filter for treemaps yet, so you will have to do this from the basics. The general process for HashMaps is described here: <a href=\"https://github.com/leanprover/lean4/blob/0071bea64eb57afff8339f22ec71944080246e7b/src/Std/Data/DHashMap/Internal/Defs.lean\">https://github.com/leanprover/lean4/blob/0071bea64eb57afff8339f22ec71944080246e7b/src/Std/Data/DHashMap/Internal/Defs.lean</a> and TreeMaps are kind of similar. So you would prove something on the list model (which might already exists since the list model is the same for Hash and tree maps and filter is verified for hashmaps). Afterwards you use the simp_to_model tactic with your list lemma. The last steps are usually just copying the name of the lemma and the statement to the next level of the hierarchy.</p>",
        "id": 530756942,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1753444497
    },
    {
        "content": "<p>This is the filter PR for Hashmaps <a href=\"https://github.com/leanprover/lean4/pull/7400\">https://github.com/leanprover/lean4/pull/7400</a></p>",
        "id": 530757099,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1753444558
    },
    {
        "content": "<p>Thank you kindly for the pointers.</p>",
        "id": 530757249,
        "sender_full_name": "FrantiÅ¡ek SilvÃ¡Å¡i ðŸ¦‰",
        "timestamp": 1753444620
    },
    {
        "content": "<p>Are treemaps critical for your application? With Hashmaps you would already have the filter operation verified and union should be easy to verify as well, since it is based on fold and insert which are already verified. You wouldnt need the framework then.</p>",
        "id": 530758773,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1753445150
    },
    {
        "content": "<p>Well, <code>ExtTreeMap</code> had <code>mergeWith</code> and <code>keys</code> whereas <code>ExtHashMap</code> didn't (IIRC), so in general the reasoning didn't go beyond: the former has all the operations I needed, and I sort of... assumed? that it would have some statements pertaining thereto.</p>\n<p>The order is not critical at all, as a matter of fact, I think performance-wise, I'd rather have the constant amortised access, they won't see many inserts regardless.</p>\n<p>The broader context is computable polynomials, the even broader context is finite field decision procedure bridge to CVC5.</p>\n<p>This is an interesting direction to explore - the <code>keys</code> might be slightly annoying because (obviously) hash maps are unordered, but I technically don't care because the sums in polynomials commute. I'll investigate this, I think it should be reasonably straightforward to port to <code>ExtHashMap</code> modulo not sure how annoying the <code>keys</code> will be.</p>",
        "id": 530760114,
        "sender_full_name": "FrantiÅ¡ek SilvÃ¡Å¡i ðŸ¦‰",
        "timestamp": 1753445585
    },
    {
        "content": "<p>Thank you for your valuable insights! :)</p>",
        "id": 530760310,
        "sender_full_name": "FrantiÅ¡ek SilvÃ¡Å¡i ðŸ¦‰",
        "timestamp": 1753445644
    },
    {
        "content": "<p>keys wont be possible for ExtHashMap as this not the same list for equivalent hashmaps. The stuff about union I said above is also not completely correct, as foldl is for the same reason only available on hashmap and not exthashmap</p>",
        "id": 530761010,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1753445863
    },
    {
        "content": "<p>FWIW, here is the proof of one of the lemmas you requested in the original message, just to demonstrate the principle that Johannes described:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">ExtTreeMap</span><span class=\"bp\">.</span><span class=\"n\">Lemmas</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">low</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">beqOfOrd</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">DTreeMap</span><span class=\"bp\">.</span><span class=\"n\">Internal</span><span class=\"bp\">.</span><span class=\"n\">Impl</span><span class=\"bp\">.</span><span class=\"n\">Const</span><span class=\"bp\">.</span><span class=\"n\">get?_filter</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TransOrd</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DTreeMap</span><span class=\"bp\">.</span><span class=\"n\">Internal</span><span class=\"bp\">.</span><span class=\"n\">Impl</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">WF</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Const</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">balanced</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Const</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pfilter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">getKey</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">contains_eq_isSome_get?</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">isSome_of_eq_some</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- This manual proof is usually done by the `simp_to_model` tactic</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Const</span><span class=\"bp\">.</span><span class=\"n\">get?_eq_getValue?</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">ordered</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toListModel_filter</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Const</span><span class=\"bp\">.</span><span class=\"n\">get?_eq_getValue?</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">ordered</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">getKey_eq_getKey</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">ordered</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Internal</span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Const</span><span class=\"bp\">.</span><span class=\"n\">getValue?_filter</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">ordered</span><span class=\"bp\">.</span><span class=\"n\">distinctKeys</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">DTreeMap</span><span class=\"bp\">.</span><span class=\"n\">get?_filter</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">cmp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TransCmp</span><span class=\"w\"> </span><span class=\"n\">cmp</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DTreeMap</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">cmp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Const</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Const</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pfilter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">getKey</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Const</span><span class=\"bp\">.</span><span class=\"n\">contains_eq_isSome_get?</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">isSome_of_eq_some</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">cmp</span><span class=\"bp\">âŸ©</span>\n<span class=\"w\">  </span><span class=\"n\">DTreeMap</span><span class=\"bp\">.</span><span class=\"n\">Internal</span><span class=\"bp\">.</span><span class=\"n\">Impl</span><span class=\"bp\">.</span><span class=\"n\">Const</span><span class=\"bp\">.</span><span class=\"n\">get?_filter</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">inner</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">wf</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ExtDTreeMap</span><span class=\"bp\">.</span><span class=\"n\">get?_filter</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">cmp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TransCmp</span><span class=\"w\"> </span><span class=\"n\">cmp</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ExtDTreeMap</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">cmp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Const</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Const</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pfilter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">getKey</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Const</span><span class=\"bp\">.</span><span class=\"n\">contains_eq_isSome_get?</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">isSome_of_eq_some</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">inductionOn</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">DTreeMap</span><span class=\"bp\">.</span><span class=\"n\">get?_filter</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ExtTreeMap</span><span class=\"bp\">.</span><span class=\"n\">getElem?_filter</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">cmp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TransCmp</span><span class=\"w\"> </span><span class=\"n\">cmp</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ExtTreeMap</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"n\">cmp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"bp\">?.</span><span class=\"n\">pfilter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">getKey</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">contains_eq_isSome_getElem?</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">isSome_of_eq_some</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">ExtDTreeMap</span><span class=\"bp\">.</span><span class=\"n\">get?_filter</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">inner</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">k</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n</code></pre></div>",
        "id": 530761978,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1753446169
    },
    {
        "content": "<p>Well ok this is far beyond 'enough' for me to do the rest; I appreciate this and will make sure to PR all the other ones to <code>ExtTreeMap</code>.</p>",
        "id": 530762421,
        "sender_full_name": "FrantiÅ¡ek SilvÃ¡Å¡i ðŸ¦‰",
        "timestamp": 1753446301
    },
    {
        "content": "<p>Especially the <code>simp_to_model</code> sugar seemed a little too arcane, but this is perfectly reasonable now :).</p>",
        "id": 530762728,
        "sender_full_name": "FrantiÅ¡ek SilvÃ¡Å¡i ðŸ¦‰",
        "timestamp": 1753446403
    },
    {
        "content": "<p>I'll concede that the machinery is somewhat elaborate, but as there are literally thousands of lemmas that we have proved and many more that still have to be proved, it makes sense to optimize the process.</p>",
        "id": 530763239,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1753446549
    },
    {
        "content": "<p>Oh that's prefectly understandable, I am all for abusing any and all automation - it miiight be missing a docstring  if only to appear less daunting, because honestly I had no idea what kind of rabbit hole I would be getting myself into if I had decided to take an in-depth look.</p>",
        "id": 530763768,
        "sender_full_name": "FrantiÅ¡ek SilvÃ¡Å¡i ðŸ¦‰",
        "timestamp": 1753446707
    },
    {
        "content": "<p>By the way, you might want to talk to <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span>, who is working on something similar at <a href=\"https://github.com/kim-em/sparse-polynomial\">https://github.com/kim-em/sparse-polynomial</a></p>",
        "id": 530765062,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1753447110
    },
    {
        "content": "<p>Happy to be made redundant on that front, although I do like the fact that my development starts to provide an implementation of finitely supported functions along the way.</p>",
        "id": 531046892,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753584606
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> <code>MergeWith</code> lemmas are <a href=\"https://github.com/NethermindEth/ExtTreeMapLemmas/blob/69922d8b59e64de6f500c139271ef3dd8f1dda9c/ExtTreeMapLemmas/ExtTreeMap.lean#L50\">now proven</a> pending some cleanups, props to <span class=\"user-mention\" data-user-id=\"819811\">@Vladislav Isenbaev</span> and apparently some AI???? :) I think they have a report on this coming up in a week or two.</p>\n<p>I'll make some time next week to make this Batteries-worthy. The <a href=\"#narrow/channel/113486-announce/topic/Computable.20MvPolynomial.20.2B.20RingEquiv.20with.20MvPolynomial/near/537894388\">computable polynomial</a> is finished as well.</p>",
        "id": 537895935,
        "sender_full_name": "FrantiÅ¡ek SilvÃ¡Å¡i ðŸ¦‰",
        "timestamp": 1757086205
    },
    {
        "content": "<p>FYI, we have lemmas for filter, map and filterMap in latest nightly now; mergeWith still need verification though</p>",
        "id": 537905065,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757089141
    }
]