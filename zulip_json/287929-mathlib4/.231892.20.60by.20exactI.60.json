[
    {
        "content": "<p>In PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/1892\">!4#1892</a>, mathport translates</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">to_with_top_le</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">part_enat</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">[</span><span class=\"n\">decidable</span> <span class=\"n\">x.dom</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable</span> <span class=\"n\">y.dom</span><span class=\"o\">],</span> <span class=\"kd\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">to_with_top</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">to_with_top</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">toWithTop_le</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">PartENat</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">x.Dom</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">y.Dom</span><span class=\"o\">],</span> <span class=\"n\">toWithTop</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">toWithTop</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>but I have the feeling that's not how to deal with this <code>by exactI</code>.</p>\n<p>Essentially the proof would call<br>\n<code>refine part_enat.cases_on y _ _,</code> first (lean4:  <code>refine' PartENat.casesOn y _ _</code>)</p>\n<p>In lean 3 it kept the <code>∀ [decidable x.dom] [decidable y.dom] </code> and has then a term <code>@to_with_top ⊤ h</code> where <code>h</code> is an instance <code>decidable ⊤.dom</code>, but in lean 4 it does not keep the <code>∀</code> (i.e. creates assumptions <code>inst✝: Decidable y.Dom</code>) and then the term <code>@toWithTop ⊤ h</code> has the wrong instance <code>h : decidable y.Dom</code>.</p>\n<p>Can somebody explain what <code>by exactI</code> did here and that would be done in lean4?</p>",
        "id": 325642006,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1675433910
    },
    {
        "content": "<p>In Lean 3, typeclasses after the colon are not added to the typeclass inference system, so the system will not be able to find <code>[decidable x.dom]</code> even though it's right there in square brackets. <code>by exactI</code> resets the cache so that the two decidable instances are accessible. I don't know how Lean 4 works in this regard.</p>",
        "id": 325644108,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675434483
    },
    {
        "content": "<p>In this particular case I don't really understand why the typeclass instances aren't just moved before the colon. Did they need to be after them because of the proof, for some reason?</p>",
        "id": 325644425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675434554
    },
    {
        "content": "<p>Oh I see, heh, the motive has a typeclass problem in it and if you move the instances before the colon then the motive doesn't compile because it can't find the instance (\\lam x, [statement] is no good because the statement needs decidable x.dom)</p>",
        "id": 325646268,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675435040
    },
    {
        "content": "<p>if you change the lean3 statement to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">to_with_top_le</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">part_enat</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable</span> <span class=\"n\">x.dom</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable</span> <span class=\"n\">y.dom</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">to_with_top</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">to_with_top</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"n\">part_enat.cases_on</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">part_enat.cases_on</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">))</span>  <span class=\"c1\">--fails</span>\n</code></pre></div>\n<p>then statement seems valid, but it fails in the proof in the exact same way the lean4 proof is failing atm,  nameley landing at an instance <code>@to_with_to ⊤ (_ : Decidable y.Dom)</code> instead of <code>@to_with_to ⊤ (_ : Decidable ⊤.Dom)</code>.</p>\n<p>I think I understand what you're saying <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, except what's exactly a \"motive\"?</p>",
        "id": 325653671,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1675436944
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"385895\">@Jon Eugster</span> I found a workaround using the <code>induction</code> tactic, but it takes a <em>really</em> long time to type check.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">toWithTop_le</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">PartENat</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">x.Dom</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">y.Dom</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">toWithTop</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">toWithTop</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">y</span> <span class=\"n\">using</span> <span class=\"n\">PartENat.cases_on</span> <span class=\"n\">generalizing</span> <span class=\"n\">hy</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n  <span class=\"n\">induction</span> <span class=\"n\">x</span> <span class=\"n\">using</span> <span class=\"n\">PartENat.cases_on</span> <span class=\"n\">generalizing</span> <span class=\"n\">hx</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 325661807,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675438845
    },
    {
        "content": "<p>This isn't just <code>simp</code> being slow. If you <code>sorry</code> out the <code>exact</code> in the following it's fast:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">toWithTop_le</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">PartENat</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">x.Dom</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">y.Dom</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">toWithTop</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">toWithTop</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">y</span> <span class=\"n\">using</span> <span class=\"n\">PartENat.cases_on</span> <span class=\"n\">generalizing</span> <span class=\"n\">hy</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n  <span class=\"n\">induction</span> <span class=\"n\">x</span> <span class=\"n\">using</span> <span class=\"n\">PartENat.cases_on</span> <span class=\"n\">generalizing</span> <span class=\"n\">hx</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n  <span class=\"n\">next</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">iff_self</span><span class=\"o\">,</span> <span class=\"n\">PartENat.coe_le_coe</span><span class=\"o\">,</span> <span class=\"n\">PartENat.toWithTop_coeNat'</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Nat.cast_le</span>\n</code></pre></div>",
        "id": 325661815,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675438849
    },
    {
        "content": "<p>Answering your question, the \"motive\" is the <code>P</code> argument to <code>PartENat.cases_on</code>. Since this lemma is marked as <code>elab_as_elim</code>, Lean will try to solve for <code>P</code> itself, which is a more difficult unification problem than usual, since it's solving for a lambda expression (this is called \"higher order unification\" I believe). It seems to solve for the wrong thing if you don't help it out by reverting instances (which is what <code>generalizing</code> does).</p>",
        "id": 325662360,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675438989
    },
    {
        "content": "<p>Thx for the explanation!</p>",
        "id": 325664586,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1675439566
    }
]