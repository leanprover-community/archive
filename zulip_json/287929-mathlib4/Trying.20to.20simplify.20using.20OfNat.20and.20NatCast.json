[
    {
        "content": "<p>I'm having a weird problem using <code>simp</code> to simplify casting to the natural numbers in a custom class.  Here is a MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">natCast</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_eq_coe</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_inj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_eq_coe</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_inj</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>Here I have some custom class <code>MyNat</code> which is supposed to contain the natural numbers as a subset.  Using an <code>OfNat</code>instance, I can define <code>(n:MyNat)</code> for any numeral <code>n</code>, and using a <code>NatCast</code> instance, I can define <code>(n:MyNat)</code> for any <code>n: ℕ</code>.  Assuming these casts are compatible and injective, I can then prove things like <code>(5:MyNat) ≠ (3:MyNat)</code> using <code>simp_rw</code> as indicated above.  But for some reason, <code>simp</code> itself does not work.  </p>\n<p>It seems that the issue has to do with a subtle difference between say <code>@OfNat.ofNat MyNat 5 instOfNatMyNat</code> and <code>@OfNat.ofNat MyNat 5 instOfNatAtLeastTwo</code>; <code>simp_rw</code> tends to generate the former while <code>simp</code> generates the latter.  If I try to introduce more <code>simp</code> lemmas to handle the former then I tend to generate infinite <code>simp</code> loops, e.g.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">natCast</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_eq_coe</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_eq_coe'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">AtLeastTwo</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">instOfNatAtLeastTwo</span><span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_inj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ne_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- creates infinite loop</span>\n</code></pre></div>\n<p>Is there an idiomatic way to support casting both numerals and <code>Nat</code> into a custom class in such a way that one can establish facts such as <code>(5:MyNat) ≠ (3:MyNat)</code> through <code>simp</code> (or <code>norm_num</code>)?  For my application I don't expect to be able to make <code>MyNat</code> decidable enough that <code>decide</code> becomes an option.</p>",
        "id": 521373815,
        "sender_full_name": "Terence Tao",
        "timestamp": 1748640294
    },
    {
        "content": "<p>I think the lemma you want to write is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_eq_coe</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">ofNat</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ofNat</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 521374296,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748640554
    },
    {
        "content": "<p>In general, the rule is \"if <code>n</code> appears in an <code>ofNat()</code> application somewhere, it should do so everywhere\"</p>",
        "id": 521374313,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748640569
    },
    {
        "content": "<p>The other trap you're running into here is that if you populate these two instances with <code>sorry</code>, then they will <em>always</em> form a diamond</p>",
        "id": 521374421,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748640613
    },
    {
        "content": "<p>Fixing those issues, the infinite loop still persists though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">natCast</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_eq_coe</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ofNat</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">ofNat</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">natCast_inj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ne_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- infinite loop, but the lemmas above alternate between introducing and removing casts!</span>\n</code></pre></div>",
        "id": 521374808,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748640834
    },
    {
        "content": "<p>This works though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ne_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_eq_coe</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">natCast_inj</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">norm_num</span>\n</code></pre></div>",
        "id": 521374991,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748640933
    },
    {
        "content": "<p>Yeah, for some reason <code>simp_rw</code> dodges all the issues.  But then I have to specify all the lemmas and can't rely on the <code>@[simp]</code> tag, which is annoying.</p>",
        "id": 521375088,
        "sender_full_name": "Terence Tao",
        "timestamp": 1748640971
    },
    {
        "content": "<p>This is the lemma you actually want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_inj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ofNat</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ofNat</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">ofNat</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ofNat</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 521375104,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748640981
    },
    {
        "content": "<p>The problem above is that <code>MyNat.ofNat_eq_coe</code> is a bad simp lemma, as it makes things more complex</p>",
        "id": 521375156,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748641019
    },
    {
        "content": "<p>I based it off of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.ofNat_eq_coe#doc\">docs#Int.ofNat_eq_coe</a> which is a <code>@[simp]</code> lemma that seems to work just fine</p>",
        "id": 521375222,
        "sender_full_name": "Terence Tao",
        "timestamp": 1748641069
    },
    {
        "content": "<p>That lemma is a trick, it is about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.ofNat#doc\">docs#Int.ofNat</a> (the constructor) not <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OfNat.ofNat#doc\">docs#OfNat.ofNat</a> (the typeclass field)</p>",
        "id": 521375293,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748641095
    },
    {
        "content": "<p>OK that explains why I got derailed</p>",
        "id": 521375428,
        "sender_full_name": "Terence Tao",
        "timestamp": 1748641198
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 521375477,
        "sender_full_name": "Terence Tao",
        "timestamp": 1748641204
    }
]