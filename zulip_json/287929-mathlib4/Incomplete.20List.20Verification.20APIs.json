[
    {
        "content": "<p>I noticed that the documentation for <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/List/Find.html\">Init.Data.List.Find</a> has several incomplete APIs - idxOf, finIdxOf?, and IdxOf?. Is anyone working on these?</p>\n<p>I've proved a few of the missing theorems for use in my own work, so I'm considering working on filling in the rest of the API - but I don't want to duplicate work that's already underway.</p>",
        "id": 526300371,
        "sender_full_name": "David J. Webb",
        "timestamp": 1751238474
    },
    {
        "content": "<p>As far as I'm aware no one is currently working on these. I would like these filled, and am happy to review and merge PRs doing so, or to discuss here what should be done!</p>",
        "id": 526321399,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1751260912
    },
    {
        "content": "<p>Okay great, I will move that up my to-do list!</p>\n<p>There were a few proofs here: <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20List.20index.20and.20membership/with/525535868\">#Is there code for X? &gt; ✔ List index and membership</a>, and I've got</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">idxOf?_getElem?_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">idxOf?</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">idxOf?_append</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulBEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l₁</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">idxOf?</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l₁</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l₁</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">idxOf?</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l₁</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">idxOf?</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">l₁</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which (I hope) seems like enough for the computable enumeration stuff I'm working on. I figure as long as I've knee-deep in lists, I may as well keep plugging away after that.</p>",
        "id": 526323872,
        "sender_full_name": "David J. Webb",
        "timestamp": 1751262806
    },
    {
        "content": "<p>My very rudimentary approach is going to be to follow the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/List/Find.html#idxOf\">current suggestions</a> in the documentation, and then add any other ? versions of non-? lemmas that exist already. But if there's anything else that should be added, I'd be happy to chip away at it.</p>",
        "id": 526324128,
        "sender_full_name": "David J. Webb",
        "timestamp": 1751263001
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> Got to a stopping point in my computability formalization work, so, gonna get started on Lists now :)</p>",
        "id": 527064734,
        "sender_full_name": "David J. Webb",
        "timestamp": 1751572572
    },
    {
        "content": "<p>Thank you, looking forward to it. (Be aware that I'm about to be away for two weeks, so don't expect speedy reviews from me. It's possibly that others will be able to review/merge in the meantime, however!)</p>",
        "id": 527098580,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1751597295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"381517\">David J. Webb</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Incomplete.20List.20Verification.20APIs/near/526323872\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">idxOf?_append</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulBEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l₁</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">idxOf?</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l₁</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l₁</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">idxOf?</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l₁</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">idxOf?</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">l₁</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I wonder if this would be better as<br>\n<code>idxOf? a (l₁ ++ l₂) = idxOf? a l₁ &lt;|&gt; (List.idxOf? a l₂).map (· + l₁.length)</code></p>",
        "id": 527130764,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751617314
    },
    {
        "content": "<p>I was pattern matching to <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/List/Find.html#List.idxOf_append\">List.idxOf_append</a></p>",
        "id": 527237566,
        "sender_full_name": "David J. Webb",
        "timestamp": 1751670157
    },
    {
        "content": "<p>That's a good answer on your side, I guess then I'm curious whether <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> thinks <code>&lt;|&gt;</code> would be a more convenient spelling of the <code>List</code> one.</p>",
        "id": 527238991,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751671984
    },
    {
        "content": "<p>I have a <a href=\"https://github.com/leanprover/lean4/pull/9613\">draft PR</a> for the idxOf API now - I proved the lemmas in my usual Mathlib workspace, but creating a new one just for tinkering with Lean itself is causing trouble. Once I've resolved that (so that I can be sure the changes to Find.lean actually compile), I will make it an actual PR.</p>",
        "id": 531506875,
        "sender_full_name": "David J. Webb",
        "timestamp": 1753761944
    },
    {
        "content": "<p>Happy if you make the naming changes to resolve those naming discrepancies. Remember though that we prefer to put <code>_iff</code> in a name if it's at all non-obvious the statement will be an iff.</p>",
        "id": 531545273,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753777687
    }
]