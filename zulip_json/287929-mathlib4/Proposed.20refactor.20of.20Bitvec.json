[
    {
        "content": "<p>There's been some discussion on what is the appropriate representation of bitvectors.</p>\n<p>Currently, we have <code>Bitvec n</code> defined as <code>Vector bool n</code>. <span class=\"user-mention\" data-user-id=\"265538\">@Harun Khan</span>  and <span class=\"user-mention\" data-user-id=\"417967\">@Abdalrhman M Mohamed</span>  are proposing to change this to <code>Fin (2^n)</code>, the definition they've been using in <a href=\"https://github.com/mhk119/lean-smt/blob/bitvec/Smt/Data/BitVec.lean\">lean-smt</a>, which is more efficient computationally, and allows us to reuse existing theorems on <code>Fin</code> or <code>Nat</code> more easily.</p>\n<p>However, this definition does put us farther away from the perspective of <code>Bitvec</code> as, well, a vector of bits, and the <code>Fin</code>-based definition might make it harder to prove theorems that mix bitwise operations and arithmetic.</p>\n<p>Thus, we propose to have both definitions, say <code>Bitvec n := Fin (2^n)</code> and another type <code>abbrev Bitvec.BitVector n := Vector bool n</code> (exact name T.B.D.). We'd suggest the <code>Fin</code>-based definition as the one to primarily use in definitions and to state theorems, to reduce duplication. But we do keep the <code>Vector</code>-definition, after proving that the isomorphism translates, say, <code>Bitvec.and</code> to <code>Bitvec.BitVector.and</code>, as an internal detail of the proofs of these theorems when appropriate. We are working on a <a href=\"https://github.com/leanprover-community/mathlib4/pull/5687\">draft PR</a> that moves the current <code>Bitvec</code> theory to <code>Bitvec.BitVector</code>.</p>\n<p>Does this plan make sense as a way to go forward?</p>",
        "id": 372026614,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1688394265
    },
    {
        "content": "<p>If you're only using it as a theoretic model, I'm wondering if <code>Fin n -&gt; Bool</code> isn't more appropriate than <code>Vector Bool n</code>?</p>",
        "id": 372373963,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688490509
    },
    {
        "content": "<p>or is the intention to preserve the current vector based interface as a deprecated api?</p>",
        "id": 372374157,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688490572
    },
    {
        "content": "<p>Some part of wanting to stick with <code>Vector</code> comes from it's current API and particularly it's recursion principles (<code>Vector.inductionOn</code>/<code>Vector.revInductionOn</code>). I don't think <code>Fin n -&gt; Bool</code> has as nice of an API currently, but it could of course always be developped</p>",
        "id": 372543494,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1688553936
    },
    {
        "content": "<p>Are you familiar with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.vecEmpty#doc\">docs#Matrix.vecEmpty</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.vecCons#doc\">docs#Matrix.vecCons</a>, and the <code>![x0, x1, ..., xn] : Fin (n + 1) -&gt; X</code> vector notation?</p>",
        "id": 372552556,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688555883
    },
    {
        "content": "<p><code>Vector</code> seems fine too, and it might be easier in some ways to develop API for it just because there's a <code>Vector</code> namespace and you can use dot notation.</p>",
        "id": 372553354,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688556050
    },
    {
        "content": "<p>I am, but <code>Matrix</code> is two-dimensional, right? There is also <code>Vector3</code>, which is more akin to <code>Fin n -&gt; Bool</code> (Although it uses <code>Fin2</code> instead), but <code>Vector3</code> has much less than <code>Vector</code>. In particular, currently a lot of bitvector operations are defined in terms of <code>Vector.mapAccumr</code>, and I'm working on <a href=\"https://github.com/leanprover-community/mathlib4/pull/5558\">a PR</a> that adds a lot of simplification lemmas for this. Ideally, I'd like <code>mapAccumr</code> to be defined in terms of some generic <code>Foldable</code> typeclass, and define these simplificaiton lemmas also generically (w.r.t. to some laws that should hold for the <code>Foldable</code>)</p>",
        "id": 372582366,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1688561910
    },
    {
        "content": "<p>But, maybe let's first get consensus for the approach of having two bitvector definitions, a computationally efficient one with <code>Fin</code>, and a more semantically \"Vector\"-like definition (in terms of <code>Vector</code>, <code>Fin n -&gt; Bool</code>, <code>Vector3</code>, or some other T.B.D. option)?</p>",
        "id": 372582846,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1688562002
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"265538\">@Harun Khan</span>, you did a +1 on the original post one, I guess that means you are on board?</p>",
        "id": 372583273,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1688562069
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> could you maybe weigh in, does this plan make sense?</p>",
        "id": 372583415,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1688562093
    },
    {
        "content": "<p>It's in the <code>Matrix</code> namespace, but take a look at the types, they're <code>Fin n -&gt; X</code>. (Matrices that are <code>m x n</code> are modeled as nested <code>Fin m -&gt; Fin n -&gt; X</code> vectors-of-vectors.)</p>",
        "id": 372589519,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688563314
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/372583273\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"265538\">Harun Khan</span>, you did a +1 on the original post one, I guess that means you are on board?</p>\n</blockquote>\n<p>Yes. This plan sounds good!</p>",
        "id": 372697752,
        "sender_full_name": "Harun Khan",
        "timestamp": 1688585902
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/372582846\">said</a>:</p>\n<blockquote>\n<p>But, maybe let's first get consensus for the approach of having two bitvector definitions, a computationally efficient one with <code>Fin</code>, and a more semantically \"Vector\"-like definition (in terms of <code>Vector</code>, <code>Fin n -&gt; Bool</code>, <code>Vector3</code>, or some other T.B.D. option)?</p>\n</blockquote>\n<p>Chiming in as I am responsible for the comment promoting the <code>Fin (2^w)</code> version. I believe that having two versions connected by extensionality lemmas is basically necessary if you want to switch between the bitwise and more arithmetic viewpoints, and to prove lemmas about both.</p>",
        "id": 372710333,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1688589927
    },
    {
        "content": "<p>Btw, I have now come to believe that (although it is good to have), in the <code>Fin (2^w)</code> variant having a nice computational representation is less important than the fact that it gives you the entire <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZMod#doc\">docs#ZMod</a> theory for free.</p>",
        "id": 372710985,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1688590147
    },
    {
        "content": "<p>I suspect we're not really getting <code>ZMod</code> for free. We still have to prove the equivalence between <code>Vector Bool n</code> and <code>Fin (2^n)</code>, which would also give us the <code>ZMod</code> theory for the <code>Vector</code> definition, right?</p>",
        "id": 372826860,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1688635713
    },
    {
        "content": "<p>In any case, I'll continue with the proposed PR. I think keeping the <code>Bitvec.BitVector</code> definition based on <code>Vector</code> is the easiest way to go forward with this change. If we do want to change that to, say, <code>Fin n -&gt; Bool</code>, I propose we do so in a subsequent PR</p>",
        "id": 372828065,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1688635942
    },
    {
        "content": "<p>My perspective is that we should have <code>Bitvector</code> as <code>Fin (2^n)</code> because it is the fastest one, and maybe <code>Bitvector</code> is something people actually want to compute with from time to time. </p>\n<p>As Alex said, it doesn't really save any work or create any work in terms of proof. We still want to know the Bitvector definitions of addition and so on in terms of folding over a vector, and we want to know that these are isomorphic to the definition on <code>ZMod</code>. I personally would advocate for defining <code>Bitvec</code> to be <code>Fin</code>, and proving an isomorphism with <code>Vector n Bool</code> (I personally wouldn't make any abbreviations as Alex suggested). I would also define a bunch of recursion principles directly on <code>Bitvec</code> that allowed you to think and reason about <code>Bitvec</code> as though it were a <code>Vector</code>, without invoking the isomorphism with <code>Vector</code>.</p>",
        "id": 372832904,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1688637014
    },
    {
        "content": "<p>My impression from mathlib experience is that we have tried every representation under the sun and have now mostly settled on <code>Fin n -&gt; A</code> or a type wrapper around it for fixed length vectors. So I am dubious about putting more work into <code>Vector n A</code>. I agree with Chris regarding <code>Fin (2^n)</code> as the \"official\" representation, since that's pretty close to what you want from a real bitvector type.</p>",
        "id": 373135116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688721307
    },
    {
        "content": "<p>I would like to see more regarding why we need bitvector anything, what is the actual use case?</p>",
        "id": 373135333,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688721347
    },
    {
        "content": "<p>For implementing most fixed width integer operations <code>Nat.bitAnd</code> et al seem to be sufficient</p>",
        "id": 373135508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688721379
    },
    {
        "content": "<p>Thanks for your input! Then I guess we want to end up with (a wrapper around) <code>Fin n -&gt; Bool</code> as the semantic Vector-like definition eventually. But, would you agree it makes sense to split this in two: first rename the existing <code>Vector</code> definitions and introduce a more efficient <code>Fin (2^n)</code> as the main representation. Then, in a second PR, reimplement the <code>Vector</code> definitions in terms of <code>Fin n -&gt; Bool</code>?</p>",
        "id": 373139100,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1688722159
    },
    {
        "content": "<p>Also, I got the impressions <code>Vector</code> was preferred over <code>Vector3</code> (i.e., <code>Fin n -&gt; A</code>), since it has the shorter, more obvious name. If you suggest <code>Fin n -&gt; A</code> should be the preferred encoding of fixed length vectors, would it make sense to name that one <code>Vector</code>, and call the other one, say, <code>VectorList</code> (to indicate it's based on <code>List</code>)? Possibly with documentation to indicate <code>Vector</code> (i.e., <code>Fin n -&gt; A</code>, post-rename) is generally preferred?</p>",
        "id": 373139752,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1688722274
    },
    {
        "content": "<blockquote>\n<p>Also, I got the impressions Vector was preferred over Vector3 (i.e., Fin n -&gt; A), since it has the shorter, more obvious name.</p>\n</blockquote>\n<p>That's not a correct inference. A shorter name can also mean that it is the older version which got the good name and is preserved for compatibility purposes</p>",
        "id": 373149656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688724126
    },
    {
        "content": "<p>this is especially true for types that were in core for a long time, since this largely prevented iterating on the design or making any naming changes</p>",
        "id": 373149814,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688724164
    },
    {
        "content": "<p>As Kyle linked earlier, the modern mathlib spelling uses <code>Fin n -&gt; A</code> directly, and the <code>![...]</code> literal syntax is for constructing such functions</p>",
        "id": 373150378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1688724281
    },
    {
        "content": "<p>Sorry, I should have clarified. I am not disagreeing with you, I'm saying that as someone who isn't as familiar with mathlib, it is difficult to see which definition to use. The naive strategy of \"just pick the one with the most obvious/nice name, since that is probably the preferred version\" apparently doesn't work. I'm asking if it would make sense to change the names (at some point in the future) so that the actually preferred version does have the nicer name.</p>",
        "id": 373171146,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1688728447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/373150378\">said</a>:</p>\n<blockquote>\n<p>As Kyle linked earlier, the modern mathlib spelling uses <code>Fin n -&gt; A</code> directly, and the <code>![...]</code> literal syntax is for constructing such functions</p>\n</blockquote>\n<p>Isn't it benificial to have a namespace for such vectors? For example, a lot of the bitvec definitions currently use <code>Vector.mapAccumr</code> (which is essentially a specialized version of a monadic <code>foldr</code>), how would I call the <code>Fin n -&gt; A</code> version of that operation, if we just use <code>Fin n -&gt; A</code> directly everywhere?<br>\nI could always define <code>Bitvec.mapAccumr</code> directly, but that seems like a missed oppurtunity for code reuse.</p>",
        "id": 373172443,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1688728721
    },
    {
        "content": "<p>That's also what bothers me a bit about, say <code>Typevec n</code> (which is defined as <code>Fin2 n -&gt; Type u</code>). All of the vector operations are re-implemented in the <code>Typevec</code> namespace. We could do the same for <code>BitVector n</code>, but then we have a lot of duplication.</p>",
        "id": 373172855,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1688728803
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 373173039,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1688728835
    },
    {
        "content": "<p>definitely worth having a namespace. not really sure why mathlib just uses <code>Fin n -&gt; A</code> directly, is there a thread about why that became standard practice?</p>",
        "id": 373259954,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688745577
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/372826860\">said</a>:</p>\n<blockquote>\n<p>I suspect we're not really getting <code>ZMod</code> for free. We still have to prove the equivalence between <code>Vector Bool n</code> and <code>Fin (2^n)</code>, which would also give us the <code>ZMod</code> theory for the <code>Vector</code> definition, right?</p>\n</blockquote>\n<p>Yes, exactly. But once you prove the core <code>Vector Bool n ≃ Fin (2^n)</code> equivalence, a lot of the theory should hopefully transfer.</p>",
        "id": 373269194,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1688747274
    },
    {
        "content": "<p>The equivalence essentially amounts to a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FinEnum#doc\">docs#FinEnum</a> instance I think</p>",
        "id": 373285016,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1688750967
    },
    {
        "content": "<p>(which could be automatically inferred if bitvec is taken as <code>Fin n -&gt; Bool</code> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>)</p>",
        "id": 373287128,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1688751526
    },
    {
        "content": "<p>The current instance is awful computationally though</p>",
        "id": 373291933,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1688752810
    },
    {
        "content": "<p>And you'd want a proof the order is lexicographic</p>",
        "id": 373292073,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1688752854
    },
    {
        "content": "<p>I PRed the proposed refactor at <a href=\"https://github.com/leanprover-community/mathlib4/pull/5687\">https://github.com/leanprover-community/mathlib4/pull/5687</a>. For now, I've kept the alternative definition as <code>Vector Bool n</code>. I suggest we make the move to <code>Fin n -&gt; Bool</code>, if desired, in a subsequent PR.</p>",
        "id": 374630817,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689170575
    },
    {
        "content": "<p>This is hard to review on github because you're moving <code>A -&gt; B</code> then replacing A with something else</p>",
        "id": 374636134,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689171436
    },
    {
        "content": "<p>I think it would be best to leave the names as is for now, and introduce the new version in terms of <code>Fin</code> as <code>BitVec</code>; it's much easier to review a PR that moves around the names when it's separate to one that adds a load of content</p>",
        "id": 374636641,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689171518
    },
    {
        "content": "<p>This one doesn't add any new content, besides the bare-bones for the new <code>Bitvec := Fin (2^n)</code> definition. All of the content in <code>Bitvec.BitVector.Defs</code> and <code>Bitvec.BitVector.Lemmas</code> are directly taken from the previous <code>Bitvec.Defs</code> and <code>Bitvec.Lemmas</code> files (modulo namespace renaming)</p>",
        "id": 374638164,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689171767
    },
    {
        "content": "<p>Or do you mean that I should first change the namespaces in one PR (without moving the files), and then in a second PR do the moving of the files (without touching the contents)?</p>",
        "id": 374638506,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689171827
    },
    {
        "content": "<p>OK, I completely removed the <code>Bitvec</code> definition, which has made GitHub realize that the <code>BitVector</code> files are just renames of existing files. I'll re-add the new definitions in another PR, after this gets merged</p>",
        "id": 374642872,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689172568
    },
    {
        "content": "<p>Note that the PR title is now misleading</p>",
        "id": 374675577,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689178539
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"481133\">@Alex Keizer</span>. The diff now really shows that the actual theorems remain unchanged. That should simplify reviewing given that we already agreed on the rename. Thank you <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> for pointing this out.</p>",
        "id": 374721500,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1689190023
    },
    {
        "content": "<p>Did we agree on the rename? I didn't see the message above. It would be great to link to the zulip message from the PR!</p>",
        "id": 374722817,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689190345
    },
    {
        "content": "<p>My understanding was that there was agreement to move Bitvec to Fin (2^n), but maybe I missed something. Here the positive messages that I found, I guess you did not vote for Bitvec as Fin (2^n), so maybe I was too fast. Sorry for this. As I am not very active her, let me take a step back and wait for more established people to advice on how to advance.</p>\n<p>Below some of the positive messages that i found:</p>\n<hr>\n<p><span class=\"user-mention silent\" data-user-id=\"265538\">Harun Khan</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/372697752\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/372583273\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"265538\">Harun Khan</span>, you did a +1 on the original post one, I guess that means you are on board?</p>\n</blockquote>\n<p>Yes. This plan sounds good!</p>\n</blockquote>\n<hr>\n<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/372710333\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/372582846\">said</a>:</p>\n<blockquote>\n<p>But, maybe let's first get consensus for the approach of having two bitvector definitions, a computationally efficient one with <code>Fin</code>, and a more semantically \"Vector\"-like definition (in terms of <code>Vector</code>, <code>Fin n -&gt; Bool</code>, <code>Vector3</code>, or some other T.B.D. option)?</p>\n</blockquote>\n<p>Chiming in as I am responsible for the comment promoting the <code>Fin (2^w)</code> version. I believe that having two versions connected by extensionality lemmas is basically necessary if you want to switch between the bitwise and more arithmetic viewpoints, and to prove lemmas about both.<br>\n</p>\n</blockquote>\n<hr>\n<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/372832904\">said</a>:</p>\n<blockquote>\n<p>My perspective is that we should have <code>Bitvector</code> as <code>Fin (2^n)</code> because it is the fastest one, and maybe <code>Bitvector</code> is something people actually want to compute with from time to time. </p>\n</blockquote>\n<hr>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/373135116\">said</a>:</p>\n<blockquote>\n<p>I agree with Chris regarding <code>Fin (2^n)</code> as the \"official\" representation, since that's pretty close to what you want from a real bitvector type.</p>\n</blockquote>",
        "id": 374728403,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1689191984
    },
    {
        "content": "<p><del>None of those messages seem to suggest that we should be keeping the <code>Vector Bool n</code> implementation under a longer name though, right?</del> sorry, that's the original post!</p>",
        "id": 374755963,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689200175
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/372832904\">said</a>:</p>\n<blockquote>\n<p>I personally wouldn't make any abbreviations as Alex suggested).</p>\n</blockquote>\n<p>Chris, just to check I understand correctly; you are advocating that all the bit API for <code>Vector Bool n</code> should just be dropped, and inlined into lemma statement about the replacement API on <code>NewBitvector = Fin (2^n)</code> and <code>NewBitvector.toBoolVector</code>? If so, I think I agree with this</p>",
        "id": 374756245,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689200334
    },
    {
        "content": "<p>Indeed, that is what Chris suggested. I personally like the idea of having a separate namespace to organize the <code>Vector</code>-like definitions, but am not opposed to implementing the inlined-lemmas approach, if that is the consensus of the community.</p>",
        "id": 374866582,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689242030
    },
    {
        "content": "<p>/poll How should we refactor <code>Bitvec</code></p>\n<ol>\n<li>Keep it as-is (only the <code>Vector bool</code> definition)</li>\n<li>Change it to <code>Fin (2^n)</code>; move the existing <code>Vector Bool n</code> API to a new type <code>Bitvec.BitVector</code></li>\n<li>Change it to <code>Fin (2^n)</code>; drop the existing API and inline it in lemmas that relate, say <code>Fin.add</code> to <code>Vector.mapAccumr</code> (the current implementation of bitwise addition on <code>Vector Bool</code>)</li>\n<li>Something else</li>\n</ol>",
        "id": 374867580,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689242221
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <span class=\"user-mention\" data-user-id=\"128280\">@Wojciech Nawrocki</span> <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"265538\">@Harun Khan</span> <span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> You've all expressed opinions in this thread, if you could cast your vote in the poll above, or explain why none of these options seem appropriate for you, then I know which one to implement</p>",
        "id": 374868263,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689242363
    },
    {
        "content": "<p>I chose 3 because now I'm not completely convinced that one needs the type <code>Bitvec.BitVector</code> anyway. Inlining it with the equivalence lemmas sounds like a good option :).</p>",
        "id": 375043483,
        "sender_full_name": "Harun Khan",
        "timestamp": 1689277163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/374756245\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/372832904\">said</a>:</p>\n<blockquote>\n<p>I personally wouldn't make any abbreviations as Alex suggested).</p>\n</blockquote>\n<p>Chris, just to check I understand correctly; you are advocating that all the bit API for <code>Vector Bool n</code> should just be dropped, and inlined into lemma statement about the replacement API on <code>NewBitvector = Fin (2^n)</code> and <code>NewBitvector.toBoolVector</code>? If so, I think I agree with this</p>\n</blockquote>\n<p>I voted for 3. I wouldn't rename <code>Vector Bool n</code> because the name is completely clear already, and nobody will know at first what <code>Bitvec.BitVector</code></p>\n<p>I think there should not be <code>add</code> and things defined on <code>Vector Bool n</code>, anything that's not about generic Vectors should be on Bitvec.</p>",
        "id": 375045525,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1689277698
    },
    {
        "content": "<p>Some of the shift primitives on BitVector might make sense to generalize to <code>Vector T n</code></p>",
        "id": 375051792,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689279468
    },
    {
        "content": "<p>Maybe that should be the first phase of the refactor; turn as many definitions as possible into result about <code>Vector T</code> instead of <code>Vector Bool</code>, and implement the BitVector ones in terms of the general ones</p>",
        "id": 375055535,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689280515
    },
    {
        "content": "<p>I think only the shift primitives, and a congruence definition w.r.t. the length of the vector, can be generalized, the other definitions seem pretty specific to the interpretation of a <code>Bitvec</code> as a number.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Create a vector from another with a provably equal length. -/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">congr</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span>\n\n<span class=\"sd\">/-- `shiftLeftFill v i` is the vector obtained by left-shifting `v` `i` times and padding with the</span>\n<span class=\"sd\">    `fill` argument. If `v.length &lt; i` then this will return `replicate n fill`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">shiftLeftFill</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fill</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n\n<span class=\"sd\">/-- `shiftRightFill v i` is the vector obtained by right-shifting `v` `i` times and padding with the</span>\n<span class=\"sd\">    `fill` argument. If `v.length &lt; i` then this will return `replicate n fill`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">shiftRightFill</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fill</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>I PRed this at <a href=\"https://github.com/leanprover-community/mathlib4/pull/5896\">https://github.com/leanprover-community/mathlib4/pull/5896</a> (currently awaiting CI)</p>",
        "id": 375214341,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689332801
    },
    {
        "content": "<p>There seems to be a preference for dropping and inlining the current API. So then I guess the next step is to introduce the new <code>Fin</code>-based definition? <span class=\"user-mention\" data-user-id=\"265538\">@Harun Khan</span> you seem to have this already, can you get a PR started?</p>",
        "id": 375215230,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689333001
    },
    {
        "content": "<p>Are there any lemmas about <code>BitVector.shl</code> that generalize too?</p>",
        "id": 375215531,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689333067
    },
    {
        "content": "<p>There's no theorems about shifts at all yet</p>",
        "id": 375215934,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689333163
    },
    {
        "content": "<p>Just want to chime in to say that I have just encountered the utility of being able to move between <code>Fin(2^n)</code> and <code>Fin n -&gt; Bool</code>, and having an API for that would be very useful.</p>",
        "id": 375218528,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689333723
    },
    {
        "content": "<p>Specifically actually I had a context where I was considering <code>Fin((2*n + 1)*2^n) -&gt; Bool</code>, and it is useful to think of this as <code>Fin (2*n + 1) → (Fin n → Bool) → Bool</code></p>",
        "id": 375219143,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689333856
    },
    {
        "content": "<p>(Not sure if we have a good way of going <code>Fin(a*b) -&gt; (Fin a -&gt; Fin b)</code> in the natural way - obviously there's some wrinkles there.)</p>",
        "id": 375219495,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689333936
    },
    {
        "content": "<p>Do you mean you'd just like an API to translate between these contexts (i.e., option 3 from the poll above), or that you'd want to have an API to, say, add <code>Fin n -&gt; Bool</code>s together (i.e., option 2 from the poll)?</p>",
        "id": 375219699,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689333972
    },
    {
        "content": "<p>Hmm - I thought both option 2 and option 3 were about <code>Vector</code> rather than <code>Vector3</code>? <code>Vector</code> (which I think is the subtype definition?) is basically of no interest to me.</p>",
        "id": 375220344,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689334127
    },
    {
        "content": "<p>It would be quite nice to have an API to add <code>Fin n -&gt; Bool</code> together, but I would accept some nice way of translating it forward and backwards. In a sense, you want to move to <code>Fin n -&gt; Bool</code> when you're doing operations like, say, \"add in an extra bit at the 4th place\", which is natural there. So it doesn't need arithmetic - it makes sense to do arithmetic at Fin(2^n) for sure.</p>",
        "id": 375220786,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689334223
    },
    {
        "content": "<p>Yeah, the move from <code>Vector</code> to <code>Fin n -&gt; Bool</code> was suggested already, but it's in a sense orthogonal. First we wanted to reach consensus about what <code>Bitvec</code>'s definition should be, and whether we'd have an alternative, more vector-like definition, and later we might move this vector-like definition to <code>Fin n -&gt; Bool</code></p>",
        "id": 375221402,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689334346
    },
    {
        "content": "<p>Do note that <code>Vector3</code> is different from both of these still, that one is defined as <code>Fin2 n -&gt; A</code>, instead of <code>Fin n -&gt; A</code>!</p>",
        "id": 375221534,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689334379
    },
    {
        "content": "<p>Oh yes, doy. Well, I see what you're saying.</p>",
        "id": 375223147,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689334702
    },
    {
        "content": "<p>I think I'm going to vote for 3 because in a sense I don't think <code>Fin n -&gt; Bool</code> should have a special name!</p>",
        "id": 375223389,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689334751
    },
    {
        "content": "<p>Oh - you'd want a good way to work with endianness.</p>",
        "id": 375272243,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689342683
    },
    {
        "content": "<p>i.e. for f : Fin n -&gt; Bool, is f 0 the MSB or LSB? It can be either!</p>",
        "id": 375272581,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689342727
    },
    {
        "content": "<p>Also pretty printing of bitvectors has some utility... I don't know if that's a thing we can do for such types easily currently.</p>",
        "id": 375273249,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689342831
    },
    {
        "content": "<p>If you don't have an API to do arithmetic on <code>Fin n -&gt; Bool</code>, then endianness doesn't really matter, right? We'd only care about that at the border, i.e,. when defining the equivalence between <code>Bitvec n</code> and <code>Fin n -&gt; Bool</code>. We currently use the convention that <code>v[0]</code> is the MSB, so I'll assume we continue to do so</p>",
        "id": 375274556,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689343018
    },
    {
        "content": "<p>I highly recommend using <code>v[0]</code> as the LSB (aka little endian)</p>",
        "id": 375274749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1689343047
    },
    {
        "content": "<p>IMO that was the biggest issue with the lean 3 bitvec</p>",
        "id": 375274924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1689343077
    },
    {
        "content": "<p>I wonder if it matters that much, if we have a reverse induction principle on vectors. You are right in that the bitwise arithmetic operations generally operate from the LSB to the MSB, so little endian would make it a bit more natural</p>",
        "id": 375276631,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689343293
    },
    {
        "content": "<p>I am certainly currently considering a context where it does matter. Suppose as I said above I am considering <code>Fin((2*n + 1)*2^n) -&gt; Bool</code> (which I suppose in turn could be interpreted as Fin(2^((2<em>n + 1)</em>2^n)) but I don't wish to do this), and I want to re-interpret this as <code>Fin (2*n + 1) → (Fin n → Bool) → Bool</code>. Indeed, in that context, I am then also going to want to, like, considering the <code>Fin n -&gt; Bool</code> part, going to also want to think about <code>Fin (n + 1) -&gt; Bool</code>, and then think about \"deleting\" a bit. I just want to be clear as to which bit, like, is represented by <code>v[0]</code> in that.</p>\n<p>I think I agree with Mario that little-endian is better. It makes more sense to me that the 0th bit represents 2^0, the 1st bit represents 2^1, and so on.</p>\n<p>If you had a good \"bit reverse\" operation and API around that, of course, it wouldn't matter too much - but I think little-endian is the way to go.</p>",
        "id": 375307232,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689348685
    },
    {
        "content": "<p><del>docs#finReverse</del></p>",
        "id": 375316689,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689350625
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/375215230\">said</a>:</p>\n<blockquote>\n<p>There seems to be a preference for dropping and inlining the current API. So then I guess the next step is to introduce the new <code>Fin</code>-based definition? <span class=\"user-mention silent\" data-user-id=\"265538\">Harun Khan</span> you seem to have this already, can you get a PR started?</p>\n</blockquote>\n<p>Sure!</p>",
        "id": 375425400,
        "sender_full_name": "Harun Khan",
        "timestamp": 1689384511
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/375274749\">said</a>:</p>\n<blockquote>\n<p>I highly recommend using <code>v[0]</code> as the LSB (aka little endian)</p>\n</blockquote>\n<p>Yes! This is alot better because <code>Nat.testBit 0</code> is also the lsb and <code>Data.Nat.Bitwise</code> (the file that uses <code>testBit</code>) is really clean.</p>",
        "id": 375425726,
        "sender_full_name": "Harun Khan",
        "timestamp": 1689384675
    },
    {
        "content": "<p>Allright, there seems to be clear consensus that little endian is the way to go (if anyone disagrees, please speak up).</p>",
        "id": 375536975,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689424811
    },
    {
        "content": "<p>Further thoughts: there are issues with Bool. <a href=\"#narrow/stream/287929-mathlib4/topic/Algebraic.20structure.20on.20Bool\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Algebraic.20structure.20on.20Bool</a></p>",
        "id": 376080887,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689609283
    },
    {
        "content": "<p>Specifically: I see computer scientists happily and interchangably use logical operations (and/or/xor) on bitvectors, and also sometimes addition, where addition means addition <em>as bitvectors</em> (that is to say, bitwise-xor).</p>",
        "id": 376081332,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689609340
    },
    {
        "content": "<p><code>Bool</code> doesn't provide +/*/0/1, so you will not, for free, get \"0\" as a zero vector.</p>",
        "id": 376081659,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689609374
    },
    {
        "content": "<p>Instead it will be ⊥. I would say that that will seem perverse notation to most people who might use this part of the library.</p>",
        "id": 376081885,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689609403
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"265538\">@Harun Khan</span> in particular, if you're starting a PR, I would be interested in your thoughts.</p>",
        "id": 376082284,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689609451
    },
    {
        "content": "<p>An argument against using <code>Fin 2</code> instead of <code>Bool</code> is now you have two ways to spell everything not one</p>",
        "id": 376082619,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689609486
    },
    {
        "content": "<p>Yeah I mean I think <code>Bool</code> is better for this.</p>",
        "id": 376083313,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689609565
    },
    {
        "content": "<p>I just also think that <code>Bool</code> should have +/*/0/1</p>",
        "id": 376083444,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689609579
    },
    {
        "content": "<p>Having two ways to spell the same thing is bad because now every lemma that mentions one thing has to be duplicated, every lemma that mentions two has to be quadrupled, ...</p>",
        "id": 376083875,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689609620
    },
    {
        "content": "<p>i.e. <code>Field Bool</code> does not to me feel unreasonable.</p>",
        "id": 376083924,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689609624
    },
    {
        "content": "<p>Or you make simp lemmas that turns one spelling into the other, and essentially say \"<code>0 : Bool</code> exists, but the only lemma we will write about it is <code>0 = false</code>\"</p>",
        "id": 376084380,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689609677
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376083875\">said</a>:</p>\n<blockquote>\n<p>Having two ways to spell the same thing is bad because now every lemma that mentions one thing has to be duplicated, every lemma that mentions two has to be quadrupled, ...</p>\n</blockquote>\n<p>I don't disagree but because you can't get rid of <code>Fin 2</code> and I assume you couldn't just define <code>Bool</code> as a synonym of <code>Fin 2</code> to a degree this tension is there.</p>",
        "id": 376084402,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689609680
    },
    {
        "content": "<p>Sure - how do you think the zero bitvector should be spelled?</p>",
        "id": 376084665,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689609711
    },
    {
        "content": "<p>Sorry, I should have been clear that I meant two ways to spell the same \"function\". I don't hold that opinion as strongly for types.</p>",
        "id": 376084687,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689609713
    },
    {
        "content": "<p>A point in favor for defining bit vectors as <code>Fin n -&gt; Fin 2</code> is that you can use coercions go from each <code>Fin 2</code> element to <code>Nat</code> or <code>Int</code>. Then the bitwise-or is <code>⊔</code>, right?</p>",
        "id": 376084858,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689609727
    },
    {
        "content": "<p>I feel like you're getting into the weeds here when ultimately I don't disagree with you. It's bad to have two ways of spelling the same thing. I just ran into the pitfall that I was expected <code>0 : Fin n -&gt; Bool</code> to exist and it doesn't.</p>",
        "id": 376085224,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689609773
    },
    {
        "content": "<p>I am also guessing any context where you want to handle bools as elements of Z/2 it would be fine to insert an explicit coercion <code>Bool.toFin : Bool -&gt; Fin 2</code>, so I don't really know that this needs to be hashed out right now.</p>",
        "id": 376085256,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689609776
    },
    {
        "content": "<p>I think <em>nearly every</em> context in which you would want to use bitvectors, you would want 0 to mean the zero bitvector.</p>",
        "id": 376086022,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689609852
    },
    {
        "content": "<p>Yes, but that would be covered by having an <code>OfNat Bitvector 0</code> instance.</p>",
        "id": 376086411,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689609891
    },
    {
        "content": "<p>Fair.</p>",
        "id": 376086570,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689609905
    },
    {
        "content": "<p>I think this is the same argument as \"if I want to use a single bit, I want to talk about <code>0</code>/<code>1</code> not <code>true</code>/<code>false</code>\"</p>",
        "id": 376086720,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689609920
    },
    {
        "content": "<p>It is certainly related.</p>",
        "id": 376086894,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689609942
    },
    {
        "content": "<p>I do think it would be reasonable to add <code>OfNat Bool 0/1</code> to mathlib, even if we don't add <code>Add Bool</code></p>",
        "id": 376087008,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689609955
    },
    {
        "content": "<p>If you do that none of the lemmas about <code>true</code> and <code>false</code> work when you're using it</p>",
        "id": 376087164,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689609970
    },
    {
        "content": "<p>You could have a simp lemma that rewrites <code>0 : Bool</code> to <code>false</code></p>",
        "id": 376087432,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689610002
    },
    {
        "content": "<p>simp lemma to true/false seems fine with me. I just sometimes want to write 0/1 in source cuz it's more readable to have 1-wide characters there.</p>",
        "id": 376087486,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689610008
    },
    {
        "content": "<p>although now that I think more on it, using 0/1 outside the context of bitvectors is a bit cursed... I take it back!</p>",
        "id": 376087653,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689610027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376087008\">said</a>:</p>\n<blockquote>\n<p>I do think it would be reasonable to add <code>OfNat Bool 0/1</code> to mathlib, even if we don't add <code>Add Bool</code></p>\n</blockquote>\n<p>It is mildly odd to me, at least that while presumably when moved inline, you would have the instance of Xor (Bitvec n) still, but that Xor operation isn't much related to other things.</p>",
        "id": 376087839,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376087486\">said</a>:</p>\n<blockquote>\n<p>I just sometimes want to write 0/1 in source cuz it's more readable to have 1-wide characters there.</p>\n</blockquote>\n<p>But as soon as you start writing lemma statements you'll be forced to use <code>true</code> and <code>false</code> again, otherwise the simpNF linter will complain at you</p>",
        "id": 376087859,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689610051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376086720\">said</a>:</p>\n<blockquote>\n<p>I think this is the same argument as \"if I want to use a single bit, I want to talk about <code>0</code>/<code>1</code> not <code>true</code>/<code>false</code>\"</p>\n</blockquote>\n<p>This is basically what I was trying to say. Plus, <code>Fin 2</code> gives you zero/false as <code>0</code>, one/true as <code>1</code>, <code>+</code> as xor, <code>*</code> as mul/and, and <code>⊔</code> as or, so there's no need for new operations to handle all the basics.</p>",
        "id": 376087878,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689610053
    },
    {
        "content": "<p>I don't think you need new operators whatever you do, right?</p>",
        "id": 376088028,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689610073
    },
    {
        "content": "<p>Well, you need <code>^^^</code> for xor-ing bitvectors.</p>",
        "id": 376088188,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610089
    },
    {
        "content": "<p>That's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=symmDiff#doc\">docs#symmDiff</a></p>",
        "id": 376088241,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689610096
    },
    {
        "content": "<p>Which works for both spellings</p>",
        "id": 376088304,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689610104
    },
    {
        "content": "<p>All the bitwise operations you need exist on bool. Fin gives you duplicate spellings for some of them.</p>",
        "id": 376088441,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689610123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376088028\">said</a>:</p>\n<blockquote>\n<p>I don't think you need new operators whatever you do, right?</p>\n</blockquote>\n<p>There's this talk about using <code>0</code> and <code>1</code>, which are 0-ary operators, and adding <code>+</code> and <code>*</code> to <code>Bool</code></p>",
        "id": 376088506,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689610132
    },
    {
        "content": "<p>That is true, ∆ does exist.</p>",
        "id": 376088627,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610148
    },
    {
        "content": "<p>I suppose - from my point of view, this is a library.</p>",
        "id": 376088726,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610165
    },
    {
        "content": "<p>I think my point is that the only argument is here is notation. The operations themselves are already defined on both types, just with spellings that have the \"wrong\" notation.</p>",
        "id": 376088753,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689610170
    },
    {
        "content": "<p>It is designed to be used by people.</p>",
        "id": 376088803,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610176
    },
    {
        "content": "<p>Yes, I think it is just a notation issue - if you can seamlessly handle the notation issue then it's all gucci.</p>",
        "id": 376088939,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610197
    },
    {
        "content": "<p>We've already forced mathematicians to use <code>\\bot</code> for the 0 submodule</p>",
        "id": 376089040,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689610205
    },
    {
        "content": "<p>I think a) that's more natural, b) they whine less.</p>",
        "id": 376089151,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610223
    },
    {
        "content": "<p>(though admittedly we <em>do</em> have a <code>0 : Submodule R M</code> instance too, but that's because we actually want the semiring structure)</p>",
        "id": 376089158,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689610224
    },
    {
        "content": "<p>I didn't say that and you can't quote it against me professionally.</p>",
        "id": 376089218,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376088753\">said</a>:</p>\n<blockquote>\n<p>I think my point is that the only argument is here is notation</p>\n</blockquote>\n<p>Right, I don't mean to say the operations don't exist, just that basically the correct notation already exists for <code>Fin 2</code>. I'm only talking about notation.</p>",
        "id": 376089221,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689610233
    },
    {
        "content": "<p>(unless people want <code>&amp;&amp;</code> and <code>||</code> notation extended to these vectors)</p>",
        "id": 376089437,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689610264
    },
    {
        "content": "<p>But \"⊥ ∆ k is the correct notation for xor-ing a bitvector k with 0\" is like. It reminds me of this meme. <br>\n<a href=\"/user_uploads/3121/ZzB8fFZP1bskZuJaxpSvm0TI/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/ZzB8fFZP1bskZuJaxpSvm0TI/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/ZzB8fFZP1bskZuJaxpSvm0TI/image.png\"></a></div>",
        "id": 376089575,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610287
    },
    {
        "content": "<p>We can have whatever notation we want for bit vectors. The thing that is (somewhat) constrained is notation on elements of the bitvector, be they <code>Fin 2</code> or <code>Bool</code>, since the types have somewhat different notations</p>",
        "id": 376089874,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689610325
    },
    {
        "content": "<p>I think that <em>is</em> mathlib's stance, because it gives you the lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=bot_symmDiff#doc\">docs#bot_symmDiff</a></p>",
        "id": 376089977,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689610340
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376089437\">said</a>:</p>\n<blockquote>\n<p>(unless people want <code>&amp;&amp;</code> and <code>||</code> notation extended to these vectors)</p>\n</blockquote>\n<p>That is exactly what I planned, with the non-short-circuiting versions <code>&amp;&amp;&amp;</code> and <code>|||</code>, at least</p>",
        "id": 376090121,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689610360
    },
    {
        "content": "<p>yes, and I feel very affectionate about mathlib</p>",
        "id": 376090130,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610361
    },
    {
        "content": "<p>But I'm sort of merrily and with no judgement noting that it is, well. Eccentric.</p>",
        "id": 376090875,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610451
    },
    {
        "content": "<p>mathlib is in the weird position of being forced to regularize/unify notation that historically has never been aligned <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span> the computer scientist in me is not used to it.</p>",
        "id": 376091558,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689610549
    },
    {
        "content": "<p>I am happy with the idea that that is how you spell it for proofs, to stop the lemma multiplication issue, and that the simp-normal form of (0 + k) should be (⊥ ∆ k) when k is a bitvector. It is weird but that is the nature of proofs. It feels Odd to me that that former wouldn't work.</p>",
        "id": 376091577,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610551
    },
    {
        "content": "<p>To me, it seems more natural to have <code>+</code> refer to addition in the regular, numeric sense. I feel that having <code>+</code> refer to <code>xor</code> would be very surprising, given that we have an explicit xor operator typeclass and notation <code>^^^</code>.</p>",
        "id": 376091579,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689610551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376089874\">said</a>:</p>\n<blockquote>\n<p>We can have whatever notation we want for bit vectors.</p>\n</blockquote>\n<p>There are limits though -- for this to be mathlib-friendly you want the notation to all be compatible in the sense of being within the theory of some sort of structure. Mixing <code>*</code>/<code>+</code> and <code>⊓</code>/<code>∆</code> is already going to lead to the pain. (A mild but persistent pain.)</p>",
        "id": 376091597,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689610553
    },
    {
        "content": "<p>A type synonym that converts one notation to the other is probably a good idea</p>",
        "id": 376091908,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689610592
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376091579\">said</a>:</p>\n<blockquote>\n<p>To me, it seems more natural to have <code>+</code> refer to addition in the regular, numeric sense. I feel that having <code>+</code> refer to <code>xor</code> would be very surprising, given that we have an explicit xor operator typeclass and notation <code>^^^</code>.</p>\n</blockquote>\n<p>This is interesting. But I note that a bitvector does not unambiguously represent a natural.</p>",
        "id": 376091954,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610598
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/374867580\">said</a>:</p>\n<blockquote>\n<p>/poll How should we refactor <code>Bitvec</code></p>\n<ol>\n<li>Keep it as-is (only the <code>Vector bool</code> definition)</li>\n<li>Change it to <code>Fin (2^n)</code>; move the existing <code>Vector Bool n</code> API to a new type <code>Bitvec.BitVector</code></li>\n<li>Change it to <code>Fin (2^n)</code>; drop the existing API and inline it in lemmas that relate, say <code>Fin.add</code> to <code>Vector.mapAccumr</code> (the current implementation of bitwise addition on <code>Vector Bool</code>)</li>\n<li>Something else</li>\n</ol>\n</blockquote>\n<p>perhaps people want to reconsider their votes here...</p>",
        "id": 376092249,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689610637
    },
    {
        "content": "<p>And I actually think that, while we should (as discussed above) provide the machinery to dip over to the Fin(2^n) form and back again when doing arithmetric, you should be neutral about what a Bitvector represents.</p>",
        "id": 376092327,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610649
    },
    {
        "content": "<p>Indeed, there are various horrible, terrible tricks (that real humans regrettably do) that come from taking a vector of bits that was a natural, and reinterpreting it as, say, a floating-point number.</p>",
        "id": 376092924,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610728
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376091908\">said</a>:</p>\n<blockquote>\n<p>A type synonym that converts one notation to the other is probably a good idea</p>\n</blockquote>\n<p><del>The data already exists, it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/boolean_algebra.to_boolean_ring\">docs3#boolean_algebra.to_boolean_ring</a></del>. This already exists, it's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AsBoolRing#doc\">docs#AsBoolRing</a> !</p>",
        "id": 376093135,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689610752
    },
    {
        "content": "<p>The neutral option would be to not have anything called \"a bitvector\" at all and just let people write <code>Fin n -&gt; Bool</code>, <code>Fin n -&gt; Fin 2</code>, <code>Fin (2^n)</code>, whatever they mean</p>",
        "id": 376093211,
        "sender_full_name": "Reid Barton",
        "timestamp": 1689610762
    },
    {
        "content": "<p>Heck you could use a list if you're into that sort of thing.</p>",
        "id": 376093599,
        "sender_full_name": "Reid Barton",
        "timestamp": 1689610805
    },
    {
        "content": "<p>I think there are substantial advantages to having clearly indicated spellings for various purposes and interpretations.</p>",
        "id": 376093788,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610824
    },
    {
        "content": "<p>There is a tension here between wanting neutral/general representations, and not wanting multiple, redundant, representations.</p>",
        "id": 376093813,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689610827
    },
    {
        "content": "<p>Otherwise people will <em>definitely</em> use one when they really should have used another.</p>",
        "id": 376093945,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610845
    },
    {
        "content": "<p>right, but this seems incompatible with</p>\n<blockquote>\n<p>you should be neutral about what a Bitvector represents.</p>\n</blockquote>",
        "id": 376093987,
        "sender_full_name": "Reid Barton",
        "timestamp": 1689610851
    },
    {
        "content": "<p>Two (named) types: <code>BitVector n</code> (represented as <code>Fin n -&gt; Bool</code>, implemented as <code>Fin (2^n)</code>) and <code>FixedWidth n</code> (represented as <code>Fin (2^n)</code>). APIs for both, conversions between them.</p>\n<p>I posit nobody actually wants <code>Fin n -&gt; Fin 2</code>.</p>",
        "id": 376094740,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689610944
    },
    {
        "content": "<p>A Bitvector should almost certainly (to me) be a vector of bits. That is to say, it's of type <code>Fin n -&gt; Bit</code> where Bit is the type that represents the singular unit of information.</p>",
        "id": 376094844,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610962
    },
    {
        "content": "<p>FWIW, the isomorphism between the last two of Reid's suggestions already exists as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finFunctionFinEquiv#doc\">docs#finFunctionFinEquiv</a> (and the one between the first two is boring)</p>",
        "id": 376094879,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689610966
    },
    {
        "content": "<p><code>Bit</code> is nearly certainly <code>Bool</code> I think.</p>",
        "id": 376094934,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689610974
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376094740\">said</a>:</p>\n<blockquote>\n<p>Two (named) types: <code>BitVector n</code> (represented as <code>Fin n -&gt; Bool</code>, implemented as <code>Fin (2^n)</code>) and <code>FixedWidth n</code> (represented as <code>Fin (2^n)</code>). APIs for both, conversions between them.</p>\n<p>I posit nobody actually wants <code>Fin n -&gt; Fin 2</code>.</p>\n</blockquote>\n<p>Yes I think I agree with this - my original post was that people would want to use +/0 on -&gt; Bool, but I actually think they wouldn't want to use Fin 2 for that!</p>",
        "id": 376095325,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689611029
    },
    {
        "content": "<p>There's also a risk of premature generalization. I am interested in developing a theory of bitvectors that involves doing arithmetic on them as if they are (signless) integers. It would be nice to have a type for this were I can just use <code>+</code>.</p>",
        "id": 376095357,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689611034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376094740\">said</a>:</p>\n<blockquote>\n<p>I posit nobody actually wants <code>Fin n -&gt; Fin 2</code>.</p>\n</blockquote>\n<p>I'm very sure there are people who do want <code>Fin n -&gt; Fin 2</code>, but they might be disjoint from the set of people who would use the word \"bitvector\".</p>",
        "id": 376095695,
        "sender_full_name": "Reid Barton",
        "timestamp": 1689611083
    },
    {
        "content": "<p>I would guess that anyone wanting to prove things about bitwise operations alone would prefer <code>Fin n -&gt; Fin 2</code></p>",
        "id": 376095988,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689611130
    },
    {
        "content": "<p>To quote Wikipedia (dangerously): \"These values are most commonly represented as either \"1\" or \"0\", but other representations such as true/false, yes/no, on/off, or +/− are also widely used. \"</p>\n<p>In a sense this is the issue. While I think in practice <code>Bit</code> should probably be <code>Bool</code>, actually <code>Bit</code> is NOT <code>Bool</code>. To get slightly philosophical: <code>Bool</code> represents decided truthiness - it is the type of <code>decide p</code> for decidable statements <code>p</code>. Wheras <code>Bit</code> is the type that fundamentally represents the basic unit of information - which is conceptually distinct from the basic unit of truth.</p>",
        "id": 376096497,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689611200
    },
    {
        "content": "<p>also worth having a <code>FixedWidth</code> type so that we can get all the <code>UIntX</code>s into a consistent proving API...</p>",
        "id": 376096819,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689611263
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376096819\">said</a>:</p>\n<blockquote>\n<p>also worth having a <code>FixedWidth</code> type so that we can get all the <code>UIntX</code>s into a consistent proving API...</p>\n</blockquote>\n<p>Yes, definitely.</p>",
        "id": 376096873,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689611276
    },
    {
        "content": "<p>I think there are technical reasons why the Uint types are distinct, related to native compilation</p>",
        "id": 376097318,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689611357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376096497\">said</a>:</p>\n<blockquote>\n<p>Wheras <code>Bit</code> is the type that fundamentally represents the basic unit of information - which is conceptually distinct from the basic unit of truth.</p>\n</blockquote>\n<p>Still not sure that means we should have a separate type for it. You have to have some asymmetry in <code>Bit</code> by choosing an order, which makes it equivalent to Bool again...</p>",
        "id": 376097429,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689611385
    },
    {
        "content": "<p>I actually agree.</p>",
        "id": 376097574,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689611405
    },
    {
        "content": "<p>I think <code>Bool</code> is the way. It's also what other languages tend to do (e.g. I was just reminding myself what Rust does).</p>",
        "id": 376097690,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689611432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376097318\">said</a>:</p>\n<blockquote>\n<p>I think there are technical reasons why the Uint types are distinct, related to native compilation</p>\n</blockquote>\n<p>Yep. But there's a whole swath of lemmas to talk about UInt operations when they could instead all be simp'd to a single <code>FixedWidth</code> type in proofs.</p>",
        "id": 376097701,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689611434
    },
    {
        "content": "<p>(There's also the wrinkle that in practice bits don't exist - bytes do - but I think we can all agree that is overcomplicated for this issue.)</p>",
        "id": 376097838,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689611472
    },
    {
        "content": "<p>In fact I'd be very open to PR'ing a fixedwidth type to core so that the proof representation of the <code>UIntX</code>'s can be <code>FixedWidth X</code> instead of <code>Fin (2^X)</code>, but I don't think core would be open to it atm.</p>",
        "id": 376098053,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689611521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376097429\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376096497\">said</a>:</p>\n<blockquote>\n<p>Wheras <code>Bit</code> is the type that fundamentally represents the basic unit of information - which is conceptually distinct from the basic unit of truth.</p>\n</blockquote>\n<p>Still not sure that means we should have a separate type for it. You have to have some asymmetry in <code>Bit</code> by choosing an order, which makes it equivalent to Bool again...</p>\n</blockquote>\n<p>In other words - I think there's a conceptual difference but not everything that has a conceptual difference needs a separate type - you have to be practical.</p>",
        "id": 376098121,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689611526
    },
    {
        "content": "<p>but anyways. it sounds like alex wants to make an API for going between bitwise representation <code>Fin n -&gt; Bool</code> and the <code>Fin (2^n)</code> ring. so does it make sense to have a type for each and build the API on that?</p>",
        "id": 376098477,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689611612
    },
    {
        "content": "<p>(The reason to have a def for <code>Fin n -&gt; Bool</code> is to get a namespace for operations, and the reason to have a def for <code>Fin (2^n)</code> is so that the 2^n doesn't get unfolded)</p>",
        "id": 376099011,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689611745
    },
    {
        "content": "<p>Although that was indeed my original proposal, now I think it would be OK to have just the name for <code>Fin (2^n)</code>, and have all the arithmetic operations live only on that representation. However, I do think we should give a name to <code>Fin n -&gt; \\a</code>, so that we have a namespace for the structural operations on vectors.</p>",
        "id": 376100300,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689612007
    },
    {
        "content": "<p>Is <code>\\a</code> a generic type there?</p>",
        "id": 376101072,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689612186
    },
    {
        "content": "<p>Yes</p>",
        "id": 376101097,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689612191
    },
    {
        "content": "<p>Could do with a name though I assume <code>Pi</code> types cover most of it. <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/InformationTheory/Hamming.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/InformationTheory/Hamming.html</a> is defined for <code>Π i : ι, β i</code>, for instance, and just uses <code>Fintype ι</code> (and decidable equality on the <code>β i</code>).</p>",
        "id": 376101776,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689612346
    },
    {
        "content": "<p>I think you might do better to write things about <code>[IsPowTwo n] (x : Fin n)</code> instead of <code>(x : Fin (2 ^ n))</code></p>",
        "id": 376101899,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689612371
    },
    {
        "content": "<p>I disagree with that - it is often pretty handy to have what the power is explict.</p>",
        "id": 376102010,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689612405
    },
    {
        "content": "<p>So more widely, what does <code>Fin n -&gt; \\a</code> need to cover? I think the main one is, like, properties that come from the specific ordering on <code>Fin n</code> that means that we think of it as have a 0th element, next a 1st, next a 2nd, and so on.</p>",
        "id": 376102174,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689612449
    },
    {
        "content": "<p>Because you're in trouble when you concatenate the latter with with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finProdFinEquiv#doc\">docs#finProdFinEquiv</a></p>",
        "id": 376102186,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689612452
    },
    {
        "content": "<p>For example,  <code>cons : \\a -&gt; (Fin n -&gt; \\a) -&gt; (Fin (n+1) -&gt; \\a)</code>, which currently exists as <code>Matrix.vecCons</code>, but also things like appending two vectors, and an analogue of <code>Vector.mapAccumr</code> (map-accumulate)</p>",
        "id": 376103002,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689612615
    },
    {
        "content": "<p>Yes, on that subject, I think I mentioned either in this thread or another that <code>Fin 6 -&gt; Bool</code>, <code>Fin 2 -&gt; Fin 3 -&gt; Bool</code>, <code>Fin 3 -&gt; Fin 2 -&gt; Bool</code> are like - they naturally correspond to certain operations you perform on... well, it doesn't have to just be Bool, but you do do it on that.</p>",
        "id": 376103766,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689612776
    },
    {
        "content": "<p>I don't know if people are familiar with Cryptol (<a href=\"https://github.com/GaloisInc/cryptol\">https://github.com/GaloisInc/cryptol</a>), but that does some very nice stuff with size-dependent typing and type inference (for instance, if you have a function with type signature f : [6] -&gt; [4], where [n] is Bitvec n, you can define f = take, where take is a library function with generic type signature [n + m] -&gt; [n], and it will work out for you that n = 6, m = 2 and f is a special case of take. You can do wackier stuff - though actually it doesn't work very well when you have bitvectors whose length are exponents - beyond the tooling).</p>",
        "id": 376104762,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689613002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376100300\">said</a>:</p>\n<blockquote>\n<p>Although that was indeed my original proposal, now I think it would be OK to have just the name for <code>Fin (2^n)</code>, and have all the arithmetic operations live only on that representation. However, I do think we should give a name to <code>Fin n -&gt; \\a</code>, so that we have a namespace for the structural operations on vectors.</p>\n</blockquote>\n<p>I would be more than happy if someone wanted to take over and port <a href=\"https://github.com/leanprover-community/mathlib/pull/4406\">mathlib#4406</a>.</p>",
        "id": 376105574,
        "sender_full_name": "Reid Barton",
        "timestamp": 1689613186
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376104762\">said</a>:</p>\n<blockquote>\n<p>I don't know if people are familiar with Cryptol (<a href=\"https://github.com/GaloisInc/cryptol\">https://github.com/GaloisInc/cryptol</a>), but that does some very nice stuff with size-dependent typing and type inference (for instance, if you have a function with type signature f : [6] -&gt; [4], where [n] is Bitvec n, you can define f = take, where take is a library function with generic type signature [n + m] -&gt; [n], and it will work out for you that n = 6, m = 2 and f is a special case of take. You can do wackier stuff - though actually it doesn't work very well when you have bitvectors whose length are exponents - beyond the tooling).</p>\n</blockquote>\n<p>More relevantly to my previous paragraph: defining a function as <code>split : [6] -&gt; [2][3]</code> or <code>split : [6] -&gt; [3][2]</code>does exactly what you expect.</p>",
        "id": 376106141,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689613315
    },
    {
        "content": "<p>That's cool, but adopting that would require changes to core, right?</p>",
        "id": 376106344,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689613358
    },
    {
        "content": "<p>Yeah that's a good point - it's certainly not likely to be a simple refactor.</p>",
        "id": 376106526,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689613391
    },
    {
        "content": "<blockquote>\n<p>I would be more than happy if someone wanted to take over and port <a href=\"https://github.com/leanprover-community/mathlib/pull/4406\">mathlib#4406</a>.</p>\n</blockquote>\n<p>Note that various things have grown in <code>Mathlib.Data.Fin.Tuple</code> since that PR was first made; so taking over should probably involve unifying it with the now-existing aPI</p>",
        "id": 376106834,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689613458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376105574\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376100300\">said</a>:</p>\n<blockquote>\n<p>Although that was indeed my original proposal, now I think it would be OK to have just the name for <code>Fin (2^n)</code>, and have all the arithmetic operations live only on that representation. However, I do think we should give a name to <code>Fin n -&gt; \\a</code>, so that we have a namespace for the structural operations on vectors.</p>\n</blockquote>\n<p>I would be more than happy if someone wanted to take over and port <a href=\"https://github.com/leanprover-community/mathlib/pull/4406\">mathlib#4406</a>.</p>\n</blockquote>\n<p>Is there a particular reason you did them as homogenous tuples?</p>",
        "id": 376106846,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689613461
    },
    {
        "content": "<p>Yes, because dealing with possibly heterogeneous tuples is a nightmare when you actually want homogenous ones (which I did in my application).</p>",
        "id": 376106972,
        "sender_full_name": "Reid Barton",
        "timestamp": 1689613488
    },
    {
        "content": "<p>Yeah that is fair enough.</p>",
        "id": 376107062,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689613507
    },
    {
        "content": "<p>In fact there is already something like <code>fin.snoc</code> and it was trying to use it and giving up which led me to write <code>finvec</code>.</p>",
        "id": 376107196,
        "sender_full_name": "Reid Barton",
        "timestamp": 1689613536
    },
    {
        "content": "<p>Yeah I can imagine it might be tricky.</p>",
        "id": 376107765,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689613661
    },
    {
        "content": "<p>snoc or cons feel like they just won't be natural there - though as I allude to above, you somewhat do want to be able to go <code>join (Fin n -&gt; \\a) (Fin m -&gt; \\a)</code> and end up with a <code>(Fin (n + m) -&gt; \\a)</code>.</p>",
        "id": 376108136,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689613740
    },
    {
        "content": "<p>But cons and snoc are different because you're appending an element rather than doing arithmetic on the index.</p>",
        "id": 376108273,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689613767
    },
    {
        "content": "<p>Are you saying that <code>snoc</code> won't be natural in the homogeneous or the heterogeneous case?</p>",
        "id": 376108350,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689613782
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376108136\">said</a>:</p>\n<blockquote>\n<p>snoc or cons feel like they just won't be natural there - though as I allude to above, you somewhat do want to be able to go <code>join (Fin n -&gt; \\a) (Fin m -&gt; \\a)</code> and end up with a <code>(Fin (n + m) -&gt; \\a)</code>.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/4406/files#diff-23c1469dd6b09926b8ad8dff0cb586a154b0e24dec44e0d3358f98a63fa2959aR85-R92\">https://github.com/leanprover-community/mathlib/pull/4406/files#diff-23c1469dd6b09926b8ad8dff0cb586a154b0e24dec44e0d3358f98a63fa2959aR85-R92</a></p>",
        "id": 376108890,
        "sender_full_name": "Reid Barton",
        "timestamp": 1689613901
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span>, your <code>join</code> already exists it's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.append#doc\">docs#Fin.append</a></p>",
        "id": 376108914,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689613906
    },
    {
        "content": "<p>Oh I assumed it did.</p>",
        "id": 376109047,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689613930
    },
    {
        "content": "<p>That wasn't \"I am big brain smarter than you all because I have remembered you can add numbers\".</p>",
        "id": 376109239,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689613975
    },
    {
        "content": "<p>I was just trying to think through what the difference was.</p>",
        "id": 376109314,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689613989
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376106141\">said</a>:</p>\n<blockquote>\n<p>More relevantly to my previous paragraph: defining a function as <code>split : [6] -&gt; [2][3]</code> or <code>split : [6] -&gt; [3][2]</code>does exactly what you expect.</p>\n</blockquote>\n<p>There is a trick with <code>Decidable</code> to achieve this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fin.Tuple.Basic</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">When</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">isTrue</span> <span class=\"o\">:</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">When</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">isTrue</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">When.mk</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">isTrue</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">split</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">mn</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">When</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">mn</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">mn</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- Reid's code + `Fin.cast`</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">split</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">6</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">4</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">))</span>  <span class=\"c1\">-- ok!</span>\n</code></pre></div>\n<p>Edit: oops, you wanted multiplication not addition</p>",
        "id": 376109464,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689614022
    },
    {
        "content": "<p>FWIW in my application there were a lot of inductions on the dimension, so <code>snoc</code> was a frequent operation.</p>",
        "id": 376109489,
        "sender_full_name": "Reid Barton",
        "timestamp": 1689614027
    },
    {
        "content": "<p>Oh yeah I mean I can very much see why you'd do it!</p>",
        "id": 376109595,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689614047
    },
    {
        "content": "<p>The reason for having an alternative, more vector-like, representations of bitvectors is exactly to do inductions on the dimension, so that seems similar enough</p>",
        "id": 376109894,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689614117
    },
    {
        "content": "<p>But \"induction on the dimension\" is, again, arithmetic on the indexing set. As opposed to List where cons/snoc doesn't have that sense.</p>",
        "id": 376109930,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689614126
    },
    {
        "content": "<p>Are you argueing that arithmetic on the index is bad? That is also what happens with <code>Vector</code> currently, IIUC</p>",
        "id": 376110256,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689614199
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.consInduction#doc\">docs#Fin.consInduction</a> gives you list-like induction on tuples</p>",
        "id": 376110401,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689614226
    },
    {
        "content": "<p>(that link 404's)</p>",
        "id": 376110477,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689614248
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376110256\">said</a>:</p>\n<blockquote>\n<p>Are you argueing that arithmetic on the index is bad? That is also what happens with <code>Vector</code> currently, IIUC</p>\n</blockquote>\n<p>No, sorry!</p>",
        "id": 376111993,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689614600
    },
    {
        "content": "<p>I think arithmetic on the index is extremely good and I want to do as much of it as possible.</p>",
        "id": 376112054,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689614616
    },
    {
        "content": "<p>For example I also want to do things like \"consider vectors of length 2^k, and induct on k\".</p>",
        "id": 376112225,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689614653
    },
    {
        "content": "<p>(To remove ambiguity: I mean like, Fin 2^k -&gt; Bool, and so if you interpreted these as naturals they would be Fin (2^(2^k)), that is to say quite quickly very large.)</p>",
        "id": 376112464,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689614718
    },
    {
        "content": "<p>But, as it was pointed out to me the other day... one could also interpret this as (Fin k -&gt; Bool) -&gt; Bool... and so we imagine vectors indexed by vectors...</p>",
        "id": 376112761,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689614802
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 376112811,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689614816
    },
    {
        "content": "<p>A further thought (going way back to what I first brought up): how do I spell \"the bit vector that is True at index i and False everywhere else\"?</p>",
        "id": 376115209,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689615385
    },
    {
        "content": "<p>I can't use <code>Pi.single</code> if there isn't a Zero instance.</p>",
        "id": 376115261,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689615398
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.update#doc\">docs#Function.update</a> \\bot i true</p>",
        "id": 376118073,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689616064
    },
    {
        "content": "<p>fin tuples always annoyed me for not having a namespace. might be a minority view there.</p>",
        "id": 376120516,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689616660
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376081659\">said</a>:</p>\n<blockquote>\n<p><code>Bool</code> doesn't provide +/*/0/1, so you will not, for free, get \"0\" as a zero vector.</p>\n</blockquote>\n<p>It does: See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bool.BooleanRing#doc\">docs#Bool.BooleanRing</a></p>",
        "id": 376126913,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1689618346
    },
    {
        "content": "<p>( <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BooleanRing#doc\">docs4#BooleanRing</a> , <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BooleanAlgebra#doc\">docs4#BooleanAlgebra</a> )</p>",
        "id": 376127142,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689618401
    },
    {
        "content": "<p>I think Yaël meant <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instBooleanRingBool#doc\">docs#instBooleanRingBool</a> ? I didn't know about this instance, and I missed when searching <code>inst.*Bool</code></p>",
        "id": 376127631,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689618526
    },
    {
        "content": "<p>there's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instBooleanAlgebraBool#doc\">docs#instBooleanAlgebraBool</a></p>",
        "id": 376129338,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689618947
    },
    {
        "content": "<p>Yeah sorry for not joining the discussion earlier. It seems you fluffed a lot around the absence of notation that is actually there.</p>",
        "id": 376129853,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1689619080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376127631\">said</a>:</p>\n<blockquote>\n<p>I think Yaël meant <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instBooleanRingBool#doc\">docs#instBooleanRingBool</a> ? I didn't know about this instance, and I missed when searching <code>inst.*Bool</code></p>\n</blockquote>\n<p>... which is why I keep on sending links to the mathlib docs <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 376130021,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1689619118
    },
    {
        "content": "<p>You mean the \"mathlib3 docs\" by this point, right? <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 376130227,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689619170
    },
    {
        "content": "<p>you sent a wrong link then, docs# links to mathlib4 now</p>",
        "id": 376147792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1689624049
    },
    {
        "content": "<p>But also, I disagree with this instance, <code>instBooleanRingBool</code> should be a scoped instance</p>",
        "id": 376147932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1689624082
    },
    {
        "content": "<p>I think if we remove it it shouldn't even be scoped, we already have a type alias to apply it</p>",
        "id": 376148538,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689624251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376129853\">said</a>:</p>\n<blockquote>\n<p>Yeah sorry for not joining the discussion earlier. It seems you fluffed a lot around the absence of notation that is actually there.</p>\n</blockquote>\n<p>Hmm. Sorry about that - but I am getting that it doesn't exist (though maybe I just didn't import the right file?)</p>",
        "id": 376251143,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689665696
    },
    {
        "content": "<p><code>#check 0 : Bool</code> doesn't work for me - what am I doing wrong/how do I get that notation?</p>",
        "id": 376251888,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689665886
    },
    {
        "content": "<p>It does seem as I get the other stuff I wanted if I do <code>import Mathlib.Algebra.Ring.BooleanRing</code>. Arguably that is... a bit of an odd import simply to get that <code>Bool</code> is a ring. It feels like a weird instance!</p>",
        "id": 376253155,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689666216
    },
    {
        "content": "<p>I don't see why you find it weird to have to import a file with \"boolean\" and \"ring\" in the name to get a ring on booleans</p>",
        "id": 376254060,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689666444
    },
    {
        "content": "<p>But thanks Yael - it would have been a lot quicker to just be told I was wrong about the lack of +/-/0/1 etc. in the first place!</p>",
        "id": 376254245,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689666486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376254060\">said</a>:</p>\n<blockquote>\n<p>I don't see why you find it weird to have to import a file with \"boolean\" and \"ring\" in the name to get a ring on booleans</p>\n</blockquote>\n<p>Well, because I don't want the BooleanRing stuff really! It is, clearly, a little hard to find... I don't have to import anything to get the BooleanAlgebra structure on Bool.</p>",
        "id": 376254424,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689666534
    },
    {
        "content": "<p>Or, well, maybe I do but it seems if so it's a very basic import. (I was also importing Mathlib.Data.Fin.Basic so maybe that did it.)</p>",
        "id": 376254582,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1689666579
    },
    {
        "content": "<p>To go back on topic, with how much we want to change the vector-like representation (moving from <code>Vector Bool n</code> to <code>Fin n -&gt; Bool</code>, without giving it a special name, and changing the endianness). I don't expect it makes a lot of sense to preserve the current API. Instead, should we go ahead with <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a>, and try to introduce the inlined vector-like lemmas (as discussed in the poll) afterwards?</p>",
        "id": 376701592,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1689779488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/376701592\">said</a>:</p>\n<blockquote>\n<p>To go back on topic, with how much we want to change the vector-like representation (moving from <code>Vector Bool n</code> to <code>Fin n -&gt; Bool</code>, without giving it a special name, and changing the endianness). I don't expect it makes a lot of sense to preserve the current API. Instead, should we go ahead with <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a>, and try to introduce the inlined vector-like lemmas (as discussed in the poll) afterwards?</p>\n</blockquote>\n<p>Is there anything that would speak against that? (or is this PR just needing review)</p>",
        "id": 382585607,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1691406272
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span>, <span class=\"user-mention\" data-user-id=\"481133\">@Alex Keizer</span>, <span class=\"user-mention\" data-user-id=\"122318\">@Tobias Grosser</span>, would you mind discussing further the implications of a PR like <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a> ? Reviewing here has stalled because I believe no maintainer is competent enough to tell whether this is a step in the right direction.</p>",
        "id": 403328925,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1700555927
    },
    {
        "content": "<p>Given that he already approved related PRs to Std, maybe <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> has opinions too?</p>",
        "id": 403328976,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1700555953
    },
    {
        "content": "<p>Let me take a look. I haven't been paying close attention to this work; I seem to recall I walked back from my initial thoughts on it after the rationale for it was discussed.</p>",
        "id": 403329069,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700556003
    },
    {
        "content": "<p>This PR has meanwhile in large portions been upstreamed to std4</p>",
        "id": 403329155,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700556024
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/std4/pull/286\">https://github.com/leanprover/std4/pull/286</a></p>",
        "id": 403329208,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700556053
    },
    {
        "content": "<p>So we are now just adding mathlib specific features to mathlib.</p>",
        "id": 403329264,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700556070
    },
    {
        "content": "<p>In fact, most of these are minor extensions.</p>",
        "id": 403329293,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700556085
    },
    {
        "content": "<p>Such as <a href=\"https://github.com/leanprover-community/mathlib4/pull/8301\">https://github.com/leanprover-community/mathlib4/pull/8301</a>.</p>",
        "id": 403329330,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700556104
    },
    {
        "content": "<p>Advice on <a href=\"https://github.com/leanprover-community/mathlib4/pull/8301\">#8301</a> would unblock us.</p>",
        "id": 403329442,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700556138
    },
    {
        "content": "<p>Tobias, could you possibly give a brief executive summary of what's ended up going into std4/what's still to go in?</p>",
        "id": 403329549,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700556185
    },
    {
        "content": "<p>Is there a reason that <code>Nat.ofBits</code> and related fallout is part of <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a>? Is it replacing part of the old bitvector API, or is this a new feature being introduced at the same time as the cleanup?</p>",
        "id": 403329560,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700556192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/403329549\">said</a>:</p>\n<blockquote>\n<p>Tobias, could you possibly give a brief executive summary of what's ended up going into std4/what's still to go in?</p>\n</blockquote>\n<p>Actually, ignore that, everything you have in std4 now seems very comprehensible.</p>",
        "id": 403330849,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700556703
    },
    {
        "content": "<p>Nice.</p>",
        "id": 403330975,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700556749
    },
    {
        "content": "<p>One thing you don't seem to have - please correct me if I'm wrong: you have special functions for adding a bit to either end.</p>",
        "id": 403330995,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700556760
    },
    {
        "content": "<p>What about functions for adding a bit to arbitrary places in a bitvector?</p>",
        "id": 403331045,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700556782
    },
    {
        "content": "<p>Specifically \"inserting\" a bit, so that for a bitvector of length m, there are m + 1 possible places you could add it?</p>",
        "id": 403331150,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700556833
    },
    {
        "content": "<p>I am curious, why are you asking for these functions?</p>",
        "id": 403331223,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700556847
    },
    {
        "content": "<p>These seem to go beyond the featureset of the current bitvector implementation in mathlib, no?</p>",
        "id": 403331271,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700556873
    },
    {
        "content": "<p>They're very relevant to some work I've been doing, enough that I have a whole parallel API I developed to use them.</p>",
        "id": 403331283,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700556878
    },
    {
        "content": "<p>As <span class=\"user-mention\" data-user-id=\"122318\">@Tobias Grosser</span>  alludes to, I definitely don't think <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a> should be growing new features not already in mathlib. The scope of \"deduplicate what we already have\" is already big enough</p>",
        "id": 403331395,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700556924
    },
    {
        "content": "<p>Sure, we would like to get these to. The honest answer: we do not have more features because we are already struggeling to get the existing featureset into mathlib.</p>",
        "id": 403331402,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700556926
    },
    {
        "content": "<p>for sure, I'm not saying \"please add these special functions right now\". Just wondering how hard it would be.</p>",
        "id": 403331433,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700556947
    },
    {
        "content": "<p>Probably not that hard, given that we agreed on the representation in std4 already.</p>",
        "id": 403331712,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700557057
    },
    {
        "content": "<p>What I'm not clear on is: if much of <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a> is now part of std4, and mathlib4 incorporates std4 anyway, what actually is being added/changed? And what functionality is desired to be preserved?</p>",
        "id": 403331755,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700557076
    },
    {
        "content": "<p>Frankly I don't remember the current bitvector representation in mathlib being very good - I don't use it - so I'm curious what features are at stake.</p>",
        "id": 403331866,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700557114
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a> has already absorbed the std upstreaming. Its aim is to move all the existing lemmas to be about the new bitvector instead of the old one</p>",
        "id": 403332020,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700557183
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 403332669,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700557366
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"122318\">@Tobias Grosser</span> what advice do you want on 8301? My only thought is that the type signature of Subtype.extendFun is slightly odd and it might be better to maintain symmetry by having the two inputs be f : Subtype p -&gt; alpha and g : Subtype not p -&gt; alpha? But I can't actually remember offhand if you can \"not\" predicates like that. Your definition is equivalent but unpacked I think.</p>\n<p>That's minor though. What is the blocker there?</p>",
        "id": 403333142,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700557546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/403332020\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a> has already absorbed the std upstreaming. Its aim is to move all the existing lemmas to be about the new bitvector instead of the old one</p>\n</blockquote>\n<p>Well that seems pretty straightforward. The idea is to delete the old definition entirely, right?</p>",
        "id": 403333249,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700557578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/403333142\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"122318\">Tobias Grosser</span> what advice do you want on 8301? My only thought is that the type signature of Subtype.extendFun is slightly odd and it might be better to maintain symmetry by having the two inputs be f : Subtype p -&gt; alpha and g : Subtype not p -&gt; alpha? But I can't actually remember offhand if you can \"not\" predicates like that. Your definition is equivalent but unpacked I think.</p>\n<p>That's minor though. What is the blocker there?</p>\n</blockquote>\n<p>I would just like to get this one reviewed. This is a independent PR that will unblock further work on the bitvector stuff. <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> already offered some advice which we implemented.  <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> had some concerns, but is now unavailable for reviews due to exams. I think we would benefit from a second mathlib reviewer to make sure this PR is indeed ready to go. From my understanding it is relatively streightforward. So if you can give it a thumbs up (or point out minor issues), we could move this along.</p>",
        "id": 403333681,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700557739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/403333249\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/403332020\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a> has already absorbed the std upstreaming. Its aim is to move all the existing lemmas to be about the new bitvector instead of the old one</p>\n</blockquote>\n<p>Well that seems pretty straightforward. The idea is to delete the old definition entirely, right?</p>\n</blockquote>\n<p>Right. There is really very little left. We have corresponding proofs for everything that was in the old bitvector implementation and added #align to the old mathlib implementation.</p>",
        "id": 403333951,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700557834
    },
    {
        "content": "<p>The last missing piece  is the review of Nat.ofBits.</p>",
        "id": 403334001,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700557852
    },
    {
        "content": "<p>I don't think I'm senior enough to give 8301 a a true thumbs up, but it does look fairly good! As I say I think I would make small definition changes but that's a personal preference and I don't know that it's helpful to stick my oar in there.</p>",
        "id": 403334107,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700557890
    },
    {
        "content": "<p>Can Nat.ofBits move to it's own PR? I think that would help with review</p>",
        "id": 403334151,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700557908
    },
    {
        "content": "<p>(I assume it's a prerequisite for adapting some of the old proofs?)</p>",
        "id": 403334437,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700558001
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/403334151\">said</a>:</p>\n<blockquote>\n<p>Can Nat.ofBits move to it's own PR? I think that would help with review</p>\n</blockquote>\n<p>I went into the history of Nat.ofBits. It was added in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">commit</span> <span class=\"n\">b211ed21dd53e8932bcfbcb8d1aedcdad59c7b7d</span>\n<span class=\"n\">Author</span><span class=\"o\">:</span> <span class=\"n\">Harun</span> <span class=\"n\">Khan</span> <span class=\"bp\">&lt;</span><span class=\"n\">harun19</span><span class=\"bp\">@</span><span class=\"n\">stanford.edu</span><span class=\"bp\">&gt;</span>\n<span class=\"n\">Date</span><span class=\"o\">:</span>   <span class=\"n\">Sun</span> <span class=\"n\">Jun</span> <span class=\"mi\">18</span> <span class=\"mi\">01</span><span class=\"o\">:</span><span class=\"mi\">18</span><span class=\"o\">:</span><span class=\"mi\">59</span> <span class=\"mi\">2023</span> <span class=\"bp\">-</span><span class=\"mi\">0700</span>\n\n    <span class=\"n\">merged</span> <span class=\"n\">recent</span> <span class=\"n\">work</span> <span class=\"n\">into</span> <span class=\"n\">bitwise.lean</span>\n</code></pre></div>\n<p>as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">+</span><span class=\"kd\">def</span> <span class=\"n\">toNat</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">+</span>  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">z.bit</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"bp\">+</span>  <span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">toNat</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">z.bit</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>This commit never hit mathlib (as it ist still part of <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a>). So, we can probably just drop Nat.ofBits and continue with life.</p>",
        "id": 403334682,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700558089
    },
    {
        "content": "<p>(meaning, we add and review it later if needed)</p>",
        "id": 403334704,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700558099
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, would that simplify reviewing?</p>",
        "id": 403334751,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700558113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"122318\">Tobias Grosser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/403334704\">said</a>:</p>\n<blockquote>\n<p>(meaning, we add and review it later if needed)</p>\n</blockquote>\n<p>Or add and review it in parallel; it's a reasonable function to want, but anything that makes <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a> smaller is good</p>",
        "id": 403334977,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700558170
    },
    {
        "content": "<p>Presumably that also saves <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a> from depending on <a href=\"https://github.com/leanprover-community/mathlib4/pull/8301\">#8301</a>?</p>",
        "id": 403335067,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700558207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/403335067\">said</a>:</p>\n<blockquote>\n<p>Presumably that also saves <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a> from depending on <a href=\"https://github.com/leanprover-community/mathlib4/pull/8301\">#8301</a>?</p>\n</blockquote>\n<p>Indeed. I think your comment unlocked <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a>. Great observation.</p>",
        "id": 403335155,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700558239
    },
    {
        "content": "<p>I will implement it and push the changes.</p>",
        "id": 403335204,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700558261
    },
    {
        "content": "<p>Having just been reading <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a>... I'm not actually sure what that leaves.</p>",
        "id": 403335230,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700558271
    },
    {
        "content": "<p>Apart from a few useful lemmas about 2^n here and there.</p>",
        "id": 403335312,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700558290
    },
    {
        "content": "<p>Not a lot. That's the point. Mostly the #align directives for the old Bitvec proofs, which are important to be able to remove the old bitvector implementation.</p>",
        "id": 403335438,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700558340
    },
    {
        "content": "<p>This hopefully gives us then a clean foundation for further work.</p>",
        "id": 403335497,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700558366
    },
    {
        "content": "<p>If I'm entirely honest you might then be better to split <em>those</em> off in a new PR and simply abandon 5920. The main issue with it seems to be that it was this titanic PR that has got smaller thanks to all your hard work... but the history probably remains an albatross around it.</p>",
        "id": 403335882,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700558501
    },
    {
        "content": "<p>But I'm a big advocate of \"PRs are cheap\". If the patch isn't working... make a new patch. Might not actually be the best choice here though.</p>",
        "id": 403336026,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700558539
    },
    {
        "content": "<p>I don't think restarting the PR is useful, the size of the diff is a much bigger factor than the length of the history</p>",
        "id": 403336213,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700558599
    },
    {
        "content": "<p>Yes, I suppose. Making that smaller can't hurt.</p>",
        "id": 403336743,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700558756
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"122318\">@Tobias Grosser</span> incidentally, as I think I've said before, I would love to help out with any of this work in the future, or talk with you about what I've been doing and my whys and wherefores for that.</p>",
        "id": 403336967,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700558817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/403336967\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"122318\">Tobias Grosser</span> incidentally, as I think I've said before, I would love to help out with any of this work in the future, or talk with you about what I've been doing and my whys and wherefores for that.</p>\n</blockquote>\n<p>Sure. That would be great. Just drop me an email and we can get this arranged.</p>",
        "id": 403337652,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700559042
    },
    {
        "content": "<p>OK. I dropped the ofBits from <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a>. Let's hope that the build goes through.</p>",
        "id": 403338623,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700559350
    },
    {
        "content": "<p>Sorry I wasn't around earlier today. For some context: <span class=\"user-mention\" data-user-id=\"265538\">@Harun Khan</span> and <span class=\"user-mention\" data-user-id=\"417967\">@Abdalrhman M Mohamed</span> were the original authors of <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a>. Tobias and I have just been helping out with pushing the PR forward since we also have an interest in a stable bitvector representation.<br>\n Like Tobias mentioned, large parts of the new bitvector representation are already upstreamed, <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a> is now mostly about getting rid of the old bitvector representation in Mathlib, and adding equivalent API to the <code>Std.BitVec</code> type. This of course has a risk of code churn for users of the old API, but, like <span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span> mentions, the old API is not really used. At least, in the 6+ months since discussing this refactor, nobody has mentioned using the old API. (Well, we did for a while, but are now instead blocked on the refactor since we bought in and decided to go with the new representation).</p>",
        "id": 403368410,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1700568912
    },
    {
        "content": "<p>Am I right in saying your interest comes from an SMT solver perspective? I know we've chatted about this before but I can't recall the details.</p>",
        "id": 403368606,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700568996
    },
    {
        "content": "<p>Not directly, we are doing a project on formalizing the semantics of MLIR (a framework for compiler IRs evolved from LLVM), and as part of that we are formalizing an IR that does fixed-bit arithmetic. Our interest in standardizing the representation, though, is definitely in hopefully being able to use some of the SMT-solver work done by the community for proving the goals that come up in our project.</p>",
        "id": 403371429,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1700569944
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/403335882\">said</a>:</p>\n<blockquote>\n<p>If I'm entirely honest you might then be better to split <em>those</em> off in a new PR and simply abandon 5920. The main issue with it seems to be that it was this titanic PR that has got smaller thanks to all your hard work... but the history probably remains an albatross around it.</p>\n</blockquote>\n<p>It might be worth mentioning <a href=\"https://github.com/leanprover-community/mathlib4/pull/8345\">#8345</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/8353\">#8353</a>. Those PRs together contain most of the additions made in <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a>, without removing the existing API. </p>\n<blockquote>\n<p>These definitions are factored out from <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a>. That PR is blocked (and has been for quite a long time) on not wanting to lose any API for bitvectors, and has become very large.</p>\n</blockquote>",
        "id": 403372862,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1700570501
    },
    {
        "content": "<p>However, Eric and Yael seem to not be a fan of restarting the PR, for good reasons, so it might be best to focus on getting <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a> in a state where we can do the refactor in one go</p>",
        "id": 403373955,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1700570874
    },
    {
        "content": "<p>Indeed. We seem to get pretty close. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 403374172,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1700570940
    },
    {
        "content": "<p>What I would say about <a href=\"https://github.com/leanprover-community/mathlib4/pull/8345\">#8345</a>, from my perspective, is that I tend to live by the maxim \"every definition is a debt\". If you create definitions, that is not useful unless you fulfil the promise implied by their existence and add lemmas that demonstrate all the distinguishing properties they have.</p>",
        "id": 403376892,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700571895
    },
    {
        "content": "<p>Unfortunately, this applies even if you're re-implementing old functions that didn't have API - it's just old debt!</p>",
        "id": 403377254,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700572031
    },
    {
        "content": "<p>To give a concrete example: <code>adc x y false = x + y</code>, <code>adc x y true = x + y + 1</code> (with appropriate extensions), <code>adc x y b = adc y x b</code>, and so forth.</p>",
        "id": 403377867,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700572261
    },
    {
        "content": "<p>In addition, I am afraid I have had another thought. Namely: I could imagine it could be useful to have a type synonym for \"Signed Bitvector\", rather than, as you do currently, sort of interpreting a BitVec as both but favoring the unsigned interpretation.</p>",
        "id": 403378231,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700572372
    },
    {
        "content": "<p>Probably this would be better as future work after <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a> is in though :). I can definitely see reasons why having a clear type distinguishment between SgnBitVec and BitVec would be good though!</p>",
        "id": 403378397,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1700572436
    },
    {
        "content": "<p>Note that <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a> currently has merge conflicts</p>",
        "id": 403394640,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700577592
    },
    {
        "content": "<p>I've just merged master, so the conflicts should be gone</p>",
        "id": 403413276,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1700582182
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/403378397\">said</a>:</p>\n<blockquote>\n<p>Probably this would be better as future work after <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a> is in though :). [...]</p>\n</blockquote>\n<p>Don't worry, I have plenty of things to add to make the API better, but let's first get the basis merged!</p>",
        "id": 403416134,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1700582907
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/403334437\">said</a>:</p>\n<blockquote>\n<p>(I assume it's a prerequisite for adapting some of the old proofs?)</p>\n</blockquote>\n<p>It's a prerequsite for new proofs we intended to add in subsequent PRs. Specifically, now that bit-vector operations are defined as arithemtic over <code>Fin 2^w</code> we want to show that this is equivalent to corresponding bit-blasting operations (or corresponding operations over <code>Fin n -&gt; Bool</code>). Here's an example for <a href=\"https://github.com/mhk119/std4/blob/bitblast/Std/Data/BitVec/Bitblast.lean\">addition</a>.</p>",
        "id": 403456729,
        "sender_full_name": "Harun Khan",
        "timestamp": 1700598163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/403334151\">said</a>:</p>\n<blockquote>\n<p>Can Nat.ofBits move to it's own PR? I think that would help with review</p>\n</blockquote>\n<p>Good idea. That will also reduce the size of <a href=\"https://github.com/leanprover-community/mathlib4/pull/5920\">#5920</a>.</p>",
        "id": 403457079,
        "sender_full_name": "Harun Khan",
        "timestamp": 1700598330
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"265538\">Harun Khan</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/403456729\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/403334437\">said</a>:</p>\n<blockquote>\n<p>(I assume it's a prerequisite for adapting some of the old proofs?)</p>\n</blockquote>\n<p>Here's an example for <a href=\"https://github.com/mhk119/std4/blob/bitblast/Std/Data/BitVec/Bitblast.lean\">addition</a>.</p>\n</blockquote>\n<p>I would argue that you shouldn't define <code>bitAdd</code>, but should instead have a lemma that says <code>(a + b).bits j =  (x.testBit j ^^ y.testBit j) ^^ carry x y j</code></p>",
        "id": 403464067,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700601568
    },
    {
        "content": "<p>Congratulations on the successful merge.</p>",
        "id": 405331241,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701426315
    },
    {
        "content": "<p>Do we have, yet, the Equiv between Fin n -&gt; Bool and Std.BitVec? It looks like there's a bunch more stuff that would probably be useful to do, certainly...</p>",
        "id": 405333072,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701426827
    },
    {
        "content": "<p>(The equiv shouldn't be particularly hard to do, given the definitions: though it is probably wise to define it in a way compatible with the rest of the API, and that might be a little harder. In particular you want it to be compatible with getLsb and getMsb in the obvious way!)</p>",
        "id": 405334643,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701427310
    },
    {
        "content": "<p>The reverse direction is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.BitVec.getLsb%27#doc\">docs#Std.BitVec.getLsb'</a></p>",
        "id": 405335762,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701427662
    },
    {
        "content": "<p>It's on the roadmap, but we don't have the full equivalence yet</p>",
        "id": 405358880,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701435846
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finPiFinEquiv#doc\">docs#finPiFinEquiv</a> is pretty much exactly the equivalence</p>",
        "id": 405361845,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701436778
    },
    {
        "content": "<p>Which leads to an obvious API gap; the equivalence between <code>Fin</code> and <code>Bitvec</code></p>",
        "id": 405361910,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701436798
    },
    {
        "content": "<p>I assume you meant <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finFunctionFinEquiv#doc\">docs#finFunctionFinEquiv</a> ?</p>",
        "id": 405433257,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701462382
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/8775\">#8775</a> is a simple draft that shows the equivalence with <code>Fin n -&gt; Bool</code> by composing existing equivalences (like the one Eric linked), although we probably want to define the equivalence in terms of <code>getLsb'</code> and a (yet to-be-defined) <code>ofFn</code> def.</p>",
        "id": 405437426,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701464495
    },
    {
        "content": "<p>Yeah, getting the equivalence is easy, the trick is then making sure that's compatible with the rest of your API.</p>",
        "id": 405783855,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701682534
    },
    {
        "content": "<p>finFunctionFinEquiv is something I am intimately familiar with nowadays and it's great, but proving things about its actual values can sometimes be a little fiddly.</p>",
        "id": 405784025,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701682592
    },
    {
        "content": "<p>Oh interesting. It's one of those things I added not because I needed it but because it was neat.</p>",
        "id": 405784343,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1701682696
    },
    {
        "content": "<p>Yeah it's been really really useful for my project I've been doing.</p>",
        "id": 405784398,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701682718
    },
    {
        "content": "<p>Because I needed to do a lot of inserting and removing bits from a given place and the best way to do that is converting to tuples and using the appropriate equivs for that</p>",
        "id": 405784507,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701682765
    },
    {
        "content": "<p>I've been playing around with <a href=\"https://github.com/leanprover-community/mathlib4/pull/8775\">#8775</a>, it now has a theorem that <code>getaLsb'</code> is an isomorpism</p>",
        "id": 405784760,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701682849
    },
    {
        "content": "<p>Like, specifically defining the family of equivs Fin (m + 1) -&gt; (Fin(2^(m+1)) \\equiv Bool -&gt; Fin(2^m)) is really nice when you have it.</p>",
        "id": 405784775,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701682854
    },
    {
        "content": "<p>Which is the \"isolate a particular bit\" transformation.</p>",
        "id": 405784967,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701682917
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/405784760\">said</a>:</p>\n<blockquote>\n<p>I've been playing around with <a href=\"https://github.com/leanprover-community/mathlib4/pull/8775\">#8775</a>, it now has a theorem that <code>getaLsb'</code> is an isomorpism</p>\n</blockquote>\n<p>This is very nice.</p>",
        "id": 405785295,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701683024
    },
    {
        "content": "<p>The strategy I took is to define the easy equivalence, and then proof a theorem that coercing this equiv to a function is equal to <code>getLsb</code>, is that a sensible proof strategy?</p>",
        "id": 405785672,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701683135
    },
    {
        "content": "<p>I think that is how I would have gone about it. Though I suspect you probably want to show that the equivs are equal, not just their coercion - i.e. I would define another equiv, your \"via getLsb\" equiv, that has <code>getLsb'</code> and <code>ofLEFn</code> as components, and assert that these are equal <em>as equivs</em>. Obviously your coercion lemmas are necessary for this.</p>",
        "id": 405797767,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701687006
    },
    {
        "content": "<p>You should also think about getMsb, and how it interacts with <code>Fin.revPerm</code> (I think this is the right thing to consider but opinions might differ).</p>",
        "id": 405797890,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701687053
    },
    {
        "content": "<p>(Reasons to have an actual equiv - I am somewhat assuming your getLSB' and ofLEFn may well be faster than the implementation that comes from finFunctionFinEquiv, which isn't written for performance. It would be useful to have a performant equiv!)</p>",
        "id": 405798172,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701687158
    },
    {
        "content": "<p>I would also assume they're faster. I guess my question is does having a fast equiv matter, or would people use <code>getLsb</code>, etc. directly anyways?</p>",
        "id": 405798349,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701687242
    },
    {
        "content": "<p>I would use the equivs!</p>",
        "id": 405798452,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701687263
    },
    {
        "content": "<p>Then again, it's easy to define the actual equiv, so I might as well</p>",
        "id": 405798469,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701687271
    },
    {
        "content": "<p>I think you should make the equiv fast; but more importantly, defeq to the underlying operations</p>",
        "id": 405798710,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701687357
    },
    {
        "content": "<p>It's very convenient to be able to use the fact that an equiv is defeq to some raw function in the goal state</p>",
        "id": 405798794,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701687376
    },
    {
        "content": "<p>Just to make explicit my example of how I am currently using finFunctionFinEquiv.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">getBitRes</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">≃</span> <span class=\"n\">Bool</span> <span class=\"bp\">×</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">calc</span>\n  <span class=\"n\">_</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span>   <span class=\"o\">:=</span> <span class=\"n\">finFunctionFinEquiv.symm</span>\n  <span class=\"n\">_</span> <span class=\"bp\">≃</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.piFinSuccAboveEquiv</span> <span class=\"n\">_</span> <span class=\"n\">i</span>\n  <span class=\"n\">_</span> <span class=\"bp\">≃</span> <span class=\"n\">_</span>                       <span class=\"o\">:=</span> <span class=\"n\">finTwoEquiv.prodCongr</span> <span class=\"n\">finFunctionFinEquiv</span>\n</code></pre></div>",
        "id": 405798959,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701687447
    },
    {
        "content": "<p>You can see how that would translate to your context. But having the <em>actual equiv</em> is useful.</p>",
        "id": 405799124,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701687496
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Bitvec.getBitRes</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Bitvec</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">Bool</span> <span class=\"bp\">×</span> <span class=\"n\">Bitvec</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"k\">calc</span>\n  <span class=\"n\">_</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span>   <span class=\"o\">:=</span> <span class=\"n\">finFunctionEquiv.symm</span>\n  <span class=\"n\">_</span> <span class=\"bp\">≃</span> <span class=\"n\">Bool</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.piFinSuccAboveEquiv</span> <span class=\"n\">_</span> <span class=\"n\">i</span>\n  <span class=\"n\">_</span> <span class=\"bp\">≃</span> <span class=\"n\">_</span>                       <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Equiv.refl</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prodCongr</span> <span class=\"n\">finFunctionEquiv</span>\n</code></pre></div>\n<p>Specifically it would look something like this.</p>",
        "id": 405800095,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701687802
    },
    {
        "content": "<p>I would argue that should be called <code>consEquiv</code> (or do I mean <code>concatEquiv</code> / <code>snocEquiv</code>?)</p>",
        "id": 405800179,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701687832
    },
    {
        "content": "<p>And it should probably not be implemented that way, because we want the reverse direction to be defeq to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BitVec.cons#doc\">docs#BitVec.cons</a></p>",
        "id": 405800323,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701687870
    },
    {
        "content": "<p>I don't disagree, but currently this only exists in my project file and I intend to name everything according to convention when I port stuff.</p>",
        "id": 405800338,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701687877
    },
    {
        "content": "<p>I am not re-implementing it though :P</p>",
        "id": 405800382,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701687892
    },
    {
        "content": "<p>For quite a lot of reasons that I am not going to get into (mainly because Zulip is REALLY SLOW right now) I think this is the right choice, it's very convenient to work with.</p>",
        "id": 405800520,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701687946
    },
    {
        "content": "<p>Anyway, it can't use <code>cons</code> because it isn't only for the bit on the end.</p>",
        "id": 405800631,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701687980
    },
    {
        "content": "<p>Note the <code>(i : Fin (m + 1))</code></p>",
        "id": 405800662,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701687992
    },
    {
        "content": "<p>if we had an extension to cons that did the calculation of the residuum/its inverse in some other way... yeah fine OK. I'd still want that as an equiv though!</p>",
        "id": 405801468,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701688282
    },
    {
        "content": "<p>It has been my experience that defining stuff using the standard equivalences makes things so, so much easier.</p>",
        "id": 405801522,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701688302
    },
    {
        "content": "<p>(Also, huh, I would have expected what we call <code>Bitvec.concat</code> to be called <code>Bitvec.snoc</code>. <code>++</code> to me is what you would use to join two vectors together (which I would called concatenation), rather than what you would use to add an element to the end (which I would call appending).)</p>",
        "id": 405802355,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701688589
    },
    {
        "content": "<p>This discussion has been had, but we're kind of stuck with the naming of <code>List.concat</code>, and wanting to be consistent with that</p>",
        "id": 405802477,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701688636
    },
    {
        "content": "<p>Yeah I get you. I think Lean is Just Wrong on this but I agree and there's no sense bikeshedding about fixing that here.</p>",
        "id": 405802549,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701688667
    },
    {
        "content": "<p>Sure, I like the <code>snoc</code> name, too (although <code>concat</code> has grown on me), but if you're serious about that, petition core to change <code>List.concat</code> first. ( don't think the name change there is worth the code churn, though</p>",
        "id": 405802783,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701688742
    },
    {
        "content": "<p>I think being correct is always worth it, but this isn't the time or place I agree.</p>",
        "id": 405802856,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701688772
    },
    {
        "content": "<p>For your interest by the way, I also had this equivalence.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">getBitResZero</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">≃</span> <span class=\"n\">Bool</span> <span class=\"bp\">×</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n <span class=\"k\">calc</span>\n  <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">≃</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">finCongr</span> <span class=\"o\">(</span><span class=\"n\">Nat.pow_succ</span> <span class=\"mi\">2</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n  <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">finProdFinEquiv.symm</span>\n  <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span> <span class=\"bp\">≃</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span> <span class=\"bp\">×</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.prodComm</span> <span class=\"bp\">..</span>\n  <span class=\"n\">_</span> <span class=\"bp\">≃</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">finTwoEquiv.prodCongr</span> <span class=\"o\">(</span><span class=\"n\">Equiv.refl</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This is equal to the above (not defeq) for i = 0, i.e. this actually probably is a thing you have in terms of actual bit operations etc.</p>",
        "id": 405803003,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701688820
    },
    {
        "content": "<p>Is <code>i</code> indexed least-significant-first, or most-significant?</p>",
        "id": 405803136,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701688865
    },
    {
        "content": "<p>least significant (i = 0 is the odd/even bit)</p>",
        "id": 405803174,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701688883
    },
    {
        "content": "<p>Simply because that is what made much more sense in my context. Clearly you could do it the other way.</p>",
        "id": 405803241,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701688903
    },
    {
        "content": "<p><del>Then we have it as <code>(x.msb, x.truncate n)</code>, where <code>x : BitVec (n+1)</code></del> (EDIT: this is for the other endiannes)</p>",
        "id": 405803251,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701688906
    },
    {
        "content": "<p>Hurrah!</p>",
        "id": 405803269,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701688913
    },
    {
        "content": "<p>Which end does <code>truncate</code> truncate? Shouldn't that be <code>msb</code>?</p>",
        "id": 405803388,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701688948
    },
    {
        "content": "<p>Wait, truncate?</p>",
        "id": 405803412,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701688956
    },
    {
        "content": "<p>Ah right yes, just for the i = 0 case.</p>",
        "id": 405803445,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701688969
    },
    {
        "content": "<p>Wait, no, we have it for msb with truncate</p>",
        "id": 405803463,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701688978
    },
    {
        "content": "<p>I assume you have the <code>i = Fin.last _</code> case also? Or  - that is that I guess.</p>",
        "id": 405803497,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701688989
    },
    {
        "content": "<p>There might be some shifting in there too</p>",
        "id": 405803525,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701688997
    },
    {
        "content": "<p>As an aside, I find it very surprising that <em>anyone</em> wants to index bits by their msb</p>",
        "id": 405803530,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701689001
    },
    {
        "content": "<p>Endianness is the cause of all the sins of the world, Eric.</p>",
        "id": 405803586,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701689023
    },
    {
        "content": "<p>Sure, but anyone writing C, verilog, or VHDL is indexing from the LSB (even if they view it as on the left instead of the right), so this msb API just feels like a trap to lead curious people astray.</p>",
        "id": 405803760,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701689084
    },
    {
        "content": "<p>\"This msb API\" = is that what Bitvec currently does?</p>",
        "id": 405803896,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701689136
    },
    {
        "content": "<p>Bitvec builds everything in duplicate, once for msb and once for lsb</p>",
        "id": 405804119,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701689221
    },
    {
        "content": "<p>Does it not define one in terms of the other?</p>",
        "id": 405804168,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701689236
    },
    {
        "content": "<p>I think you want an <code>msb</code> API purely for people who are perverse I fear. But technically of course this isn't even an endianess thing - endianess is for bytestrings.</p>",
        "id": 405804244,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701689275
    },
    {
        "content": "<p>Rather it's a bit order thing - and I do agree that for <em>most</em> contexts -- all I can think of - it's LSB-first.</p>",
        "id": 405804340,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701689302
    },
    {
        "content": "<p>(As I say - if you are thinking about them as Fin n -&gt; Bool, then this just represents a suitable conjugation through Fin.revPerm)</p>",
        "id": 405804491,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701689379
    },
    {
        "content": "<p>The definitions are usually not that bad to duplicate, it becomes annoying for theorems</p>",
        "id": 405804508,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701689387
    },
    {
        "content": "<p>(As I'm currently experiencing, trying to duplicate the equivalence for <code>getMsb</code>/<code>ofBEFn</code>)</p>",
        "id": 405804597,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701689413
    },
    {
        "content": "<p>So I essentially think maybe you should just have the getLsb interface, and anywhere you have a theorem about getMsb i x, you replace it with a theorem about getLsb (Fin.rev i) x. But I am Fin-API-pilled.</p>",
        "id": 405804823,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701689520
    },
    {
        "content": "<p>Well, we already have a theorem that <code>getMsb' i x = getLsb i.rev x</code>, so that's essentially what we're doing</p>",
        "id": 405805016,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701689598
    },
    {
        "content": "<p>(Indeed, I think you should probably define getMsb i x as getLsb (Fin.rev i) x. I think you currently do it by manually subtracting? I think this is probably a Bad Plan.)</p>",
        "id": 405805027,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701689602
    },
    {
        "content": "<p><code>Fin</code> is so much easier to work with as an index set if you avoid doing arithmetic in it as much as possible...</p>",
        "id": 405805143,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701689647
    },
    {
        "content": "<p>Currently there is <code>getLsb</code>/<code>getMsb</code> in Std which index with naturals, then there are <code>getLsb'</code>/<code>getMsb'</code> in mathlib which index with <code>Fin</code>'s, but just by wrapping the <code>Nat</code>-indexing functions and <code>Fin.val</code></p>",
        "id": 405805216,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701689684
    },
    {
        "content": "<p>Cursed. I mean I see why you've presumably done that but D:</p>",
        "id": 405805296,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701689715
    },
    {
        "content": "<p>That means in fact <code>getMsb</code> is defined with <code>tsub</code>. Abandon hope, all, ye are doomed.</p>",
        "id": 405805355,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701689747
    },
    {
        "content": "<p>Not that I mean to be overdramatic. But I can feel the spectre of Lemma Hell here.</p>",
        "id": 405805486,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701689798
    },
    {
        "content": "<p>There is <a href=\"https://github.com/leanprover/std4/pull/400\">https://github.com/leanprover/std4/pull/400</a>, but the reaction there was luke-warm. Maybe you can try to convince Joe Hendrix to re-consider</p>",
        "id": 405805519,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701689811
    },
    {
        "content": "<p>I would be enthusiastic about it I think.</p>",
        "id": 405805620,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701689859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/405805486\">said</a>:</p>\n<blockquote>\n<p>Not that I mean to be overdramatic. But I can feel the spectre of Lemma Hell here.</p>\n</blockquote>\n<p>To be fair, in proofs I just don't unfold <code>getMsb'</code> and instead use the aforementioned <code>getMsb' i x = getLsb i.rev x</code> equality, so it's not that bad, so far</p>",
        "id": 405805713,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701689889
    },
    {
        "content": "<p>Incidentally, as an example of the kind of nonsense (but useful nonsense) you can prove with my <code>getBitRes</code>, I have this theorem as essentially a straightforward consequence of the definitions.</p>\n<p><code>getBit (j.succAbove i) q = getBit i (getRes j q)</code></p>\n<p><code>getBit</code> and <code>getRes</code> are the two components of <code>getBitRes</code>. So this says that \"If you take all bits except the jth bit of q, and then take the ith bit, that is the same as taking the <code>j.succAbove i</code>th bit of q, which essentially like saying \"the ith bit of q, once you have j back in, but ignored\".</p>",
        "id": 405805922,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701689983
    },
    {
        "content": "<p>But with the wrong definitions, proving this sort of thing becomes extremely tiresome.</p>",
        "id": 405806026,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701690014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/405805713\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/405805486\">said</a>:</p>\n<blockquote>\n<p>Not that I mean to be overdramatic. But I can feel the spectre of Lemma Hell here.</p>\n</blockquote>\n<p>To be fair, in proofs I just don't unfold <code>getMsb'</code> and instead use the aforementioned <code>getMsb' i x = getLsb i.rev x</code> equality, so it's not that bad, so far</p>\n</blockquote>\n<p>Indeed, but this might be an indication that this is a better definition.</p>",
        "id": 405806113,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701690064
    },
    {
        "content": "<p>Oh, another definition that was handier to define using the equivalence:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">bitInvar</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"n\">bp</span><span class=\"o\">,</span> <span class=\"n\">bp.fst</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">getBitRes</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">conj</span> <span class=\"n\">f</span> <span class=\"n\">bp</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 405806878,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701690393
    },
    {
        "content": "<p>(For reference, after looking it up and finding my third comment of the form \"this is the function <code>append</code>, which concatenates, I broke and decided to raise the conversation: <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend</a>)</p>",
        "id": 405812588,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701692517
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span> what is the idiomatic way to reverse a tuple? Currently I'm using <code>f ∘ Fin.rev</code>, but I'm missing a result that says that reversing <code>Fin.cons</code> gives <code>Fin.snoc</code>, i.e., <code>Fin.cons a f ∘ Fin.rev = Fin.snoc (f ∘ Fin.rev) a</code></p>",
        "id": 405823171,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701696208
    },
    {
        "content": "<p>It's not too hard to prove, I PR'ed it at <a href=\"https://github.com/leanprover-community/mathlib4/pull/8814\">#8814</a>, just checking if I'm missing an easier way to do this</p>",
        "id": 405823336,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701696251
    },
    {
        "content": "<p>It might be shorter to prove that via <code>List.ofFn</code></p>",
        "id": 405823693,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701696371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/405823171\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> what is the idiomatic way to reverse a tuple? Currently I'm using <code>f ∘ Fin.rev</code>, but I'm missing a result that says that reversing <code>Fin.cons</code> gives <code>Fin.snoc</code>, i.e., <code>Fin.cons a f ∘ Fin.rev = Fin.snoc (f ∘ Fin.rev) a</code></p>\n</blockquote>\n<p>Good question. The API here is a little weird.</p>\n<p>Another option would be, for a <code>f : Fin n -&gt; a</code>, ((Fin.revPerm).prodCongr (Equiv.refl _)) f.</p>\n<p><em>Arguably</em>, <code>(Fin n)ᵒᵈ -&gt; a</code> would be a better type for \"tuples indexed from the end\".</p>",
        "id": 405825467,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701696964
    },
    {
        "content": "<p>In this logic, you're then using <code>Fin.revOrderIso</code> to transport between the two...</p>",
        "id": 405826115,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701697159
    },
    {
        "content": "<p>I'm sure our \"order heads\" could say that in a more sophisticated way.</p>",
        "id": 405826275,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701697206
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/405823171\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> what is the idiomatic way to reverse a tuple? Currently I'm using <code>f ∘ Fin.rev</code></p>\n</blockquote>\n<p>I think composition with <code>rev</code> is sensible</p>",
        "id": 405826329,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701697228
    },
    {
        "content": "<p>Yes, I think so too, despite my digression. The above do boil down to that also - it's just a question of the best way of doing it.</p>",
        "id": 405826424,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701697264
    },
    {
        "content": "<p>The context is this definition, for which I think keeping it simple (i.e., sticking with <code>rev</code>) seems the best way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Create a bitvector from a function that maps index `i` to the `i`-th most significant bit -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">ofBEFn</span> <span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">BitVec</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ofLEFn</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">Fin.rev</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 405826829,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701697411
    },
    {
        "content": "<p>Yep. Also it will not be hard to change if later you find a different definition would be more convenient.</p>",
        "id": 405827265,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701697554
    },
    {
        "content": "<p>I generally find that if you are doing your homework as you go and splitting stuff neatly into logical lemmas, refactoring is straightforward. It's when you've got some titanic proof that uses about 8 different facts and the details of the implementation that things go wrong.</p>",
        "id": 405827438,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701697602
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481133\">@Alex Keizer</span> for your reference:</p>\n<p><code>getBitRes j q = (getLsb j q, (q % 2^j) + ((q &gt;&gt; (j + 1)) &lt;&lt; j)</code><br>\n<code>(getBitRes j).symm (b, p) = (p % 2^j) + ((q &gt;&gt; j) &lt;&lt; (j + 1)) + bif b then 2^j else 0</code></p>\n<p>I don't know if there's a simpler way to write this in the Bitvec form - the modulo operation is presumably some kind of truncation, for instance. This isn't how it is defined under the hood for me, but I think this is probably how you'd want to define it in the \"closer to bit operation\" form.</p>",
        "id": 405845152,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701702628
    },
    {
        "content": "<p>So if you tell me \"oh yeah we can definitely prove that these are inverse already\" I'll be very excited</p>",
        "id": 405845231,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701702653
    },
    {
        "content": "<p>The modulus is indeed <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.BitVec.truncate#doc\">docs#Std.BitVec.truncate</a></p>",
        "id": 405845567,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701702747
    },
    {
        "content": "<p>Though presumably you then need to zero-extend it back to length.</p>",
        "id": 405845658,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701702773
    },
    {
        "content": "<p>Oho, but zeroextend and truncate are just the same thing in a hat ;)</p>",
        "id": 405845873,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701702826
    },
    {
        "content": "<p>We also have the shift notation on bitvectors (although that one truncates bits that are shifted out of the static width, so you might have to zero-extend first)</p>",
        "id": 405845998,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701702850
    },
    {
        "content": "<p>The \"+\" here could equally be \"^^\", incidentally - I don't know which is more efficient.</p>",
        "id": 405846155,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701702890
    },
    {
        "content": "<p>(Because as it happens you're only ever adding stuff to 0, you don't need to keep track of carries.)</p>",
        "id": 405846230,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701702907
    },
    {
        "content": "<p>And the <code>bif b then 2^j else 0</code> can be stated in terms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.BitVec.ofBool#doc\">docs#Std.BitVec.ofBool</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.BitVec.shiftLeftZeroExtend#doc\">docs#Std.BitVec.shiftLeftZeroExtend</a></p>",
        "id": 405846292,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701702923
    },
    {
        "content": "<p>Not sure about efficiency, but <code>^^^</code> might make proofs easier</p>",
        "id": 405846409,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701702954
    },
    {
        "content": "<p>Now as to whether we can prove these are isomorphisms, I'm not confident enough to say \"definitely\", but I'd encourage you to try</p>",
        "id": 405846723,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701703029
    },
    {
        "content": "<p>You might want to wait until some of my outstanding PRs are merged, though</p>",
        "id": 405846817,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701703052
    },
    {
        "content": "<p>Would that I could, but that might have to be an after-thesis jobbie.</p>",
        "id": 405846854,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701703060
    },
    {
        "content": "<p>In practice, when you are building a context time implementation, what you do is mask by ~(b - 1), because when b is 0 that is all-zeroes and when b is 1 that is all -ones).</p>",
        "id": 405846962,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701703085
    },
    {
        "content": "<p>Because you want to avoid the branch.</p>",
        "id": 405847005,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701703097
    },
    {
        "content": "<p>I don't know if that's really meaningfully modelable in Lean yet.</p>",
        "id": 405847054,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701703116
    },
    {
        "content": "<p>Also morally it is somewhat evil to just casually treat (-1) as the all-ones vector, even though it is true (because you are using overflow properties which depending on your type and target language might be ambiguously defined/IMPDEF). Nevertheless it is the standard way I've seen.</p>",
        "id": 405847511,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701703245
    },
    {
        "content": "<p>And I think it's true for you here!</p>",
        "id": 405847562,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701703257
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proposed.20refactor.20of.20Bitvec/near/405846962\">said</a>:</p>\n<blockquote>\n<p>In practice, when you are building a context time implementation, what you do is mask by ~(b - 1), because when b is 0 that is all-zeroes and when b is 1 that is all -ones).</p>\n</blockquote>\n<p>That would work if you're talking about <code>2^j - 1</code>, but your previous code bit had <code>2^j</code> in the <code>true</code> branch, so that is different, no? Hence my suggestion to model it as <code>b.toNat &lt;&lt;&lt; j</code>, that would be <code>0 &lt;&lt;&lt; j = 0</code> if <code>b = false</code> and <code>1 &lt;&lt;&lt; j = 2^j</code> if <code>b = true</code>.</p>",
        "id": 405869655,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1701708731
    },
    {
        "content": "<p>Well, hmm. Yes, it used 2^j*b, and for that I think you're quite correct. HOWEVER in practice what you have is two elements of an arbitrary array of a type (but we can cast it to a bitvector, like, it's morally a number of some size). The index for these two things are given by that calculation - but you don't need to hide this because you always load those two things. The secret information is whether you swap them or not.</p>\n<p>So what you do is you XOR them together, and then XOR that by an all-1s or all-0s number (that you've made from b). Then you XOR each entry by your result and set it. This achieves conditional exchange without branching, do you see?</p>\n<p>So you're absolutely right - but in context the things you want to mask are not the bitvecs but things you've loaded from an array using the bitvecs as indices.</p>",
        "id": 405885065,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701713248
    },
    {
        "content": "<p>Does that make sense?</p>",
        "id": 405885127,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1701713276
    }
]