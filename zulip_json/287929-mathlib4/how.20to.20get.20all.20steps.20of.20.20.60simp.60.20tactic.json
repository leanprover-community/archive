[
    {
        "content": "<p>In Lean 4, many simple proofs can be completed directly using the <code>simp</code> tactic. I am trying to understand how <code>simp</code> works internally and would like to see all the steps it performs during the simplification process.</p>\n<p>I know that by enabling the trace option:</p>\n<p>lean</p>\n<p><code>set_option trace.Meta.Tactic.simp true</code></p>\n<p>I can see some traces of the <code>simp</code> tactic's behavior. However, the trace only shows part of the process, and many details are still omitted.</p>\n<p>For example, consider the following code:</p>\n<p>lean</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"w\"> </span><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\">   </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>The trace output is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">simp</span><span class=\"bp\">.</span><span class=\"n\">rewrite</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">add_zero</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">==&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">simp</span><span class=\"bp\">.</span><span class=\"n\">rewrite</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">mul_one</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">==&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">simp</span><span class=\"bp\">.</span><span class=\"n\">rewrite</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">eq_self</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">==&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span>\n</code></pre></div>\n<p>Based on this information, I tried to manually reproduce the proof:</p>\n<p>lean</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">add_zero</span><span class=\"o\">]</span>\n<span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mul_one</span><span class=\"o\">]</span>\n<span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq_self</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>However, Lean 4 gives an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Basic</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"o\">:</span><span class=\"mi\">7</span><span class=\"o\">:</span><span class=\"mi\">27</span>\n<span class=\"n\">unsolved</span><span class=\"w\"> </span><span class=\"n\">goals</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">True</span>\n</code></pre></div>\n<p>This is a simple unsolved goal, but the core issue is that I cannot retrieve the complete steps performed by <code>simp</code>. Specifically:</p>\n<ul>\n<li>The trace does not show how <code>simp</code> closes the final goal (e.g., proving <code>⊢ True</code>).</li>\n<li>Some intermediate steps or implicit reasoning might be missing from the trace.</li>\n</ul>\n<h3>Questions:</h3>\n<ol>\n<li>Is there a way to get <strong>all</strong> the steps performed by <code>simp</code>, including the final step that closes the goal?</li>\n<li>Are there additional debugging options or techniques to fully reconstruct what <code>simp</code> does?</li>\n</ol>\n<p>Any guidance or suggestions would be greatly appreciated!</p>",
        "id": 501972641,
        "sender_full_name": "John Smith",
        "timestamp": 1740551807
    },
    {
        "content": "<p>You can just use <code>#print</code> to look inside the generated code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">of_eq_true</span>\n</code></pre></div>",
        "id": 501978532,
        "sender_full_name": "suhr",
        "timestamp": 1740554931
    },
    {
        "content": "<p>If you want to know how exactly <code>simp</code> does what it does, I guess you should read the implementation</p>",
        "id": 501981506,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1740556259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/channel/287929-mathlib4/topic/how.20to.20get.20all.20steps.20of.20.20.60simp.60.20tactic/near/501978532\">said</a>:</p>\n<blockquote>\n<p>You can just use <code>#print</code> to look inside the generated code</p>\n</blockquote>\n<p>When I tried using <code>#print</code> to inspect some mathlib lemmas that were proven by <code>simp</code>, I encountered an issue. The output often contains references to <code>_auxLemma</code>. However, when I attempt to check these auxiliary lemmas, Lean 4 responds with <code>unknown constant</code>.</p>\n<p>For example:</p>\n<p><code>#print SimpleGraph.isClique_empty</code></p>\n<p>The output is:</p>\n<p><code>theorem SimpleGraph.isClique_empty.{u_1} : ∀ {α : Type u_1} {G : SimpleGraph α}, G.IsClique ∅ := fun {α} {G} ↦ of_eq_true (Mathlib.Data.Set.Pairwise.Basic._auxLemma.1 G.Adj)</code></p>\n<p>But when I try to inspect <code>Mathlib.Data.Set.Pairwise.Basic._auxLemma.1</code>, Lean 4 gives me the error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unknown</span><span class=\"w\"> </span><span class=\"n\">identifier</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Pairwise</span><span class=\"bp\">.</span><span class=\"n\">Basic</span><span class=\"bp\">._</span><span class=\"n\">auxLemma'</span>\n</code></pre></div>\n<p>why this happens? Are these <code>_auxLemma</code> definitions inaccessible or intentionally hidden? Is there a way to fully explore the steps used by <code>simp</code> in such cases?</p>",
        "id": 501982643,
        "sender_full_name": "John Smith",
        "timestamp": 1740556731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/287929-mathlib4/topic/how.20to.20get.20all.20steps.20of.20.20.60simp.60.20tactic/near/501981506\">said</a>:</p>\n<blockquote>\n<p>If you want to know how exactly <code>simp</code> does what it does, I guess you should read the implementation</p>\n</blockquote>\n<p>Nice suggestion, I will try</p>",
        "id": 501982719,
        "sender_full_name": "John Smith",
        "timestamp": 1740556765
    },
    {
        "content": "<p>See also <a href=\"https://github.com/nomeata/lean-calcify\">https://github.com/nomeata/lean-calcify</a></p>",
        "id": 501998909,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1740562277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/287929-mathlib4/topic/how.20to.20get.20all.20steps.20of.20.20.60simp.60.20tactic/near/501998909\">said</a>:</p>\n<blockquote>\n<p>See also <a href=\"https://github.com/nomeata/lean-calcify\">https://github.com/nomeata/lean-calcify</a></p>\n</blockquote>\n<p><code>calcify</code> is a useful tactic for breaking down proofs into clear steps.</p>\n<p>However, in complex cases, <code>calcify</code> may fail, and in other situations, it can still involve <code>auxLemma</code>.</p>\n<p>Is there currently a fully mature explanation tactic or tool that can provide complete transparency into what <code>simp</code> does?</p>",
        "id": 502202433,
        "sender_full_name": "John Smith",
        "timestamp": 1740635840
    },
    {
        "content": "<p>The step to close the goal is hard-coded. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.simpTargetCore#doc\">docs#Lean.Meta.simpTargetCore</a> looks to see that the goal is <code>True</code>, and if so, uses <code>of_eq_true</code> to turn the proof generated by <code>simp</code> that <code>p = True</code> into a proof of <code>p</code>. (Or, if the simplification was purely definitional, it uses <code>True.intro</code> directly.)</p>",
        "id": 502204211,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740636863
    },
    {
        "content": "<p>It's part of the <code>simp</code> tactic, but not the core <code>simp</code> algorithm.</p>",
        "id": 502204237,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740636883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"819526\">John Smith</span> <a href=\"#narrow/channel/287929-mathlib4/topic/how.20to.20get.20all.20steps.20of.20.20.60simp.60.20tactic/near/501972641\">said</a>:</p>\n<blockquote>\n<ul>\n<li>The trace does not show how <code>simp</code> closes the final goal (e.g., proving <code>⊢ True</code>).</li>\n</ul>\n</blockquote>\n<p>simp closes the final goal by proving <code>|- True</code></p>",
        "id": 505408376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741869217
    },
    {
        "content": "<p>it always proves goals by reducing them to True</p>",
        "id": 505408446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741869236
    }
]