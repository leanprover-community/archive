[
    {
        "content": "<p>Consider this:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>~/build/lean/mathlib4 $ lake exec cache get\nAttempting to download 3938 file(s)\nDownloaded: 3938 file(s) [attempted 3938/3938 = 100%] (100% success)\nDecompressing 3938 file(s)\nunpacked in 7072 ms\n~/build/lean/mathlib4 $ md5sum .lake/build/**/*.olean &gt; /tmp/md5sums-before\n~/build/lean/mathlib4 $ git checkout origin/master\nVorherige Position von HEAD war e9bcfc6e58 style(Algebra/Module/Injective): fix weird bracket position (#8589)\nHEAD ist jetzt bei 84c26b211a feat(Calculus/ContDiff): add `ContDiffAt.contDiffOn` (#8600)\n~/build/lean/mathlib4 $ git log -n 2\ncommit 84c26b211afbd8ae411c6f7cb9458f5a6e44ca0a (HEAD, origin/staging, origin/master, origin/HEAD)\nAuthor: Yury G. Kudryashov &lt;urkud@urkud.name&gt;\nDate:   Thu Nov 23 19:13:50 2023 +0000\n\n    feat(Calculus/ContDiff): add `ContDiffAt.contDiffOn` (#8600)\n\ncommit e9bcfc6e583d0784ece32475ca6f450126ef286f\nAuthor: Jujian Zhang &lt;jujian.zhang1998@outlook.com&gt;\nDate:   Thu Nov 23 14:01:58 2023 +0000\n\n    style(Algebra/Module/Injective): fix weird bracket position (#8589)\n\n    The bracket position seems off\n~/build/lean/mathlib4 $ lake exec cache get\nAttempting to download 162 file(s)\nDownloaded: 162 file(s) [attempted 162/162 = 100%] (100% success)\nDecompressing 3938 file(s)\nunpacked in 1985 ms\n~/build/lean/mathlib4 $ md5sum .lake/build/**/*.olean &gt; /tmp/md5sums-after\n~/build/lean/mathlib4 $ diff -u /tmp/md5sums-before /tmp/md5sums-after |diffstat\n md5sums-after |   22 +++++++++++-----------\n 1 file changed, 11 insertions(+), 11 deletions(-)\n</code></pre></div>\n</div></div>\n<p>I had a fresh cache at <code>master^</code>, then updated to mathlib master, where <a href=\"https://github.com/leanprover-community/mathlib4/commit/84c26b211afbd8ae411c6f7cb9458f5a6e44ca0a\">one definition was added to <code>Calculus.ContDiff</code></a>.</p>\n<p>then <code>cache get</code> downloaded 162 files, but only 22 are actually different afterwards.</p>\n<p>This makes me wonder:</p>\n<ul>\n<li>\n<p>Does <code>cache get</code> really have to download the 140 <code>.oleans</code> that are bitwise identical? Wouldn’t it save a s-load of storage in the cloud, download bandwidth and time, and local storage if <code>.oleans</code> were downloaded content-addressed, and <code>cache get</code> would first get a mapping from trace(?) to olean content hash, and only download if it doesn't have it already?</p>\n</li>\n<li>\n<p>Why did these files changes:</p>\n</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Analysis</span><span class=\"bp\">/</span><span class=\"n\">Calculus</span><span class=\"bp\">/</span><span class=\"n\">BumpFunction</span><span class=\"bp\">/</span><span class=\"n\">FiniteDimension.olean</span>\n<span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Analysis</span><span class=\"bp\">/</span><span class=\"n\">Calculus</span><span class=\"bp\">/</span><span class=\"n\">ContDiff</span><span class=\"bp\">/</span><span class=\"n\">Basic.olean</span>\n<span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Analysis</span><span class=\"bp\">/</span><span class=\"n\">Calculus</span><span class=\"bp\">/</span><span class=\"n\">ContDiff</span><span class=\"bp\">/</span><span class=\"n\">Bounds.olean</span>\n<span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Analysis</span><span class=\"bp\">/</span><span class=\"n\">Calculus</span><span class=\"bp\">/</span><span class=\"n\">ContDiff</span><span class=\"bp\">/</span><span class=\"n\">FiniteDimension.olean</span>\n<span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Analysis</span><span class=\"bp\">/</span><span class=\"n\">Calculus</span><span class=\"bp\">/</span><span class=\"n\">FDeriv</span><span class=\"bp\">/</span><span class=\"n\">Analytic.olean</span>\n<span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Analysis</span><span class=\"bp\">/</span><span class=\"n\">Calculus</span><span class=\"bp\">/</span><span class=\"n\">IteratedDeriv.olean</span>\n<span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Analysis</span><span class=\"bp\">/</span><span class=\"n\">Calculus</span><span class=\"bp\">/</span><span class=\"n\">Series.olean</span>\n<span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Analysis</span><span class=\"bp\">/</span><span class=\"n\">Distribution</span><span class=\"bp\">/</span><span class=\"n\">SchwartzSpace.olean</span>\n<span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Analysis</span><span class=\"bp\">/</span><span class=\"n\">InnerProductSpace</span><span class=\"bp\">/</span><span class=\"n\">Calculus.olean</span>\n<span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Analysis</span><span class=\"bp\">/</span><span class=\"n\">SpecialFunctions</span><span class=\"bp\">/</span><span class=\"n\">SmoothTransition.olean</span>\n</code></pre></div>\n<p>I would assume these oleans still have the exact same semantic content. Maybe some global counter shows up somewhere that could be avoided or normalized before serialization? (But even if they are not always the same when they could, it still seems that there is something to be saved.)</p>",
        "id": 403860682,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1700778374
    },
    {
        "content": "<p>Does Lake have an option to compute all traces without building anything? If so, I agree content-addressing would be a good improvement. As I understand it, <code>cache</code> currently hashes the inputs (Nix-style) instead of being content-addressed.</p>",
        "id": 403912561,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1700810254
    },
    {
        "content": "<p>I think it's mostly orthogonal. You'd still query the cache as now, but instead of querying for the olean directly, you ask it for the olean hash (small response), so the trace related part is mostly the same. Then a new second step checks if that hash is already present locally and only download the real file if it doesn't exist already. </p>\n<p>Every problem can be solved by an extra layer of indirection, except the problem of too many indirections.</p>",
        "id": 403913130,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1700810542
    },
    {
        "content": "<p>For my second question, it’s (at least) hygienic names. Using <code>oleandump</code> to compare the changed <code>Mathlib/Analysis/SpecialFunctions/SmoothTransition.olean</code></p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"w\"> </span>let x927492f2{176} : Lean.Expr := Lean.Expr.app #[xd8a3bb26{144}, x23b53e6f{392}]\n<span class=\"w\"> </span>let xaf761576{208} : Lean.Expr := Lean.Expr.app #[x927492f2{176}, xc62553d9{5768}]\n<span class=\"w\"> </span>let x6a66db6b{24} : Lean.Expr := Lean.Expr.sort #[x870a583e{24}]\n<span class=\"gd\">-let x1c66e28e{368} : Lean.Name := Lean.Name.num #[`inst._@.Mathlib.Analysis.Calculus.ContDiff.Defs._hyg, 26695]</span>\n<span class=\"gi\">+let x75a663ef{368} : Lean.Name := Lean.Name.num #[`inst._@.Mathlib.Analysis.Calculus.ContDiff.Defs._hyg, 26824]</span>\n<span class=\"w\"> </span>let x91159395{32} : Lean.Expr := Lean.Expr.const #[`NontriviallyNormedField, x75ba0d01{24}]\n<span class=\"w\"> </span>let xf266cb60{64} : Lean.Expr := Lean.Expr.app #[x91159395{32}, xf87d595c{24}]\n<span class=\"gd\">-let xe6bbd2a8{32} : Lean.Name := Lean.Name.num #[`inst._@.Mathlib.Analysis.Calculus.ContDiff.Defs._hyg, 26699]</span>\n<span class=\"gi\">+let xacaad2af{32} : Lean.Name := Lean.Name.num #[`inst._@.Mathlib.Analysis.Calculus.ContDiff.Defs._hyg, 26828]</span>\n<span class=\"w\"> </span>let x7914a10d{32} : Lean.Expr := Lean.Expr.const #[`NormedAddCommGroup, x75ba0d01{24}]\n<span class=\"w\"> </span>let xa540fd54{64} : Lean.Expr := Lean.Expr.app #[x7914a10d{32}, xf87d595c{24}]\n</code></pre></div>\n<p>I notice that some hygienic names in <code>Mathlib.Analysis.Calculus.ContDiff.Defs</code> have changed. Not unexpected, a bit unfortunate, probably not easy to work around. Although if <code>cache</code> would deduplicate oleans, the motivation to solve this  differently would increase.</p>",
        "id": 403926424,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1700816604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Download.20oleans.20that.20are.20bitwise.20identical.3F/near/403860682\">said</a>:</p>\n<blockquote>\n<p>Does <code>cache get</code> really have to download the 140 <code>.oleans</code> that are bitwise identical? Wouldn’t it save a s-load of storage in the cloud, download bandwidth and time, and local storage if <code>.oleans</code> were downloaded content-addressed, and <code>cache get</code> would first get a mapping from trace(?) to olean content hash, and only download if it doesn't have it already?</p>\n</blockquote>\n<p>They already are doing exactly what you suggest. So this indicates rather that something in the hash changed, not necessarily the file itself but one of its dependents. We can't calculate the content hash for files with missing dependencies because we don't have the olean file yet, but we could in principle download only the things directly needed, then rerun the hash computation and see if that knocks out some additional requests, rather than computing the whole to-download list upfront and then sending it all to curl, at the cost of some lost parallelism.</p>",
        "id": 404001812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700847130
    },
    {
        "content": "<p>We can't look things up by the hash of the olean file because we don't have the olean file until we have requested it, this would be a circular dependency. So we hash the lean file instead, and we have to take all dependencies into account here. So it is always possible that we look up the olean after a change to the lean files which could potentially invalidate the olean, but it turns out not to and we end up downloading an olean bitwise identical to the one we have already. There is no way to predict in advance that the server will send the same file until we actually get it</p>",
        "id": 404001934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700847230
    },
    {
        "content": "<p>Sorry, I wasn't clear. All of that appens as now. But where currently you download a Olean from the server, you download the hash of the Olean (which, of course the server needs to provide). Then you check of you have it locally already, and only if not, download the actual Olean.</p>",
        "id": 404002655,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1700847686
    },
    {
        "content": "<p>We could download the olean hash first if we happen to have an olean lying around and suspect it is already up to date, but this is again a data dependency which reduces parallelism, and asking for an 8 byte hash file from the server, then comparing the received olean hash with the one we have and only if it differs requesting the (5-100 KB) .ltar file would be a significant overhead.</p>",
        "id": 404002666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700847690
    },
    {
        "content": "<p>forming a new server request for a file is about half of the cost, the other half is sending data, so I would expect this strategy not to be worth it unless the oleans are very large. We could try to be clever about this since we know how big the file we expect is, but it would need some testing to find the right cutoff point. I would expect just doing this for every file to be a net negative</p>",
        "id": 404002908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700847843
    },
    {
        "content": "<p>We are also constrained by the fact that the cache server is a plain file server with no \"smarts\", and it is unclear whether reservoir would have the same restriction. For a plain file server it would necessitate doubling the number of files we store, and the .ltar files we store are already \"uncomfortably small and numerous\" so this may cause issues on the server too</p>",
        "id": 404003395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700848113
    },
    {
        "content": "<p>Basically, .ltar files are too small to be worth it</p>",
        "id": 404003411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700848127
    },
    {
        "content": "<p>Hmm, I see. Thanks for entertaining the idea!</p>",
        "id": 404005482,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1700849385
    },
    {
        "content": "<p>Another idea could be that the client sends the hash of the file it has locally, and if the server sees that hash matches the file it would send, it would send a \"no change\" response rather than the entire olean. Not sure if that's possible or worthwhile given the current server architecture, but it seems it could reduce the amount of data sent over the network without increasing round trips</p>",
        "id": 404007574,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1700850890
    },
    {
        "content": "<p>Note that \"the server\" is just Azure's cloud API. We push and request stuff without any specific logic on the other side besides what Azure offers</p>",
        "id": 404008164,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1700851291
    },
    {
        "content": "<p>Sounds like HTTP's ETag could be useful there. In that variant you need to make an educated guess about which local file you want to compare with, rather than getting a hash and then looking in the local store. But it does save a roundtrip indeed.</p>",
        "id": 404008406,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1700851483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Download.20oleans.20that.20are.20bitwise.20identical.3F/near/403912561\">said</a>:</p>\n<blockquote>\n<p>Does Lake have an option to compute all traces without building anything? </p>\n</blockquote>\n<p>This would also be useful for doing a nix build, but then opening the folder in vscode and having lake know that everything is already built</p>",
        "id": 404010723,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700853139
    }
]