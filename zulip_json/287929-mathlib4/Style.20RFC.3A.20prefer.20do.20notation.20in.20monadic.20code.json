[
    {
        "content": "<p>I’d like to propose documenting a style preference for <code>do</code> notation over Haskell-style monadic operators like <code>&gt;&gt;=</code>.</p>\n<p>As far as I can tell, we already do this for the most part, but haven’t written it down. I think using <code>do</code> notation helps make code more readable and maintainable. :)</p>\n<p>There are a couple of Haskell-style operators we do use occasionally in specific circumstances, like <code>&lt;$&gt;</code>, boolean monadic operators, and occasionally <code>&lt;|&gt;</code>.</p>\n<p>My proposal would be to mention those, and allow some discretion on the part of the contributor/reviewer to use one of these common-enough Haskell-style operators when significantly more readable. (Maybe we’d want to discuss which ones exactly would be allowed.)</p>\n<p>It’s <a href=\"#narrow/channel/287929-mathlib4/topic/Mathlib.3A.20the.20Missing.20Manuals/near/544981420\">been mentioned</a> that we should also have a reference for Haskell-style monadic notation, and we could include this together with their <code>do</code> translations for those used to Haskell-style notation. (Possibly this should info should be in the docstrings for the notation as well, but that’s a separate topic.) I think this is a good idea! We could link to it from this section of the style guide.</p>\n<p>Up to details, does this sound reasonable?</p>",
        "id": 545010846,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1760545369
    },
    {
        "content": "<p>I personally am in favour: I don't come from a Haskell background, and do notation is significantly more readable to me.</p>",
        "id": 545012152,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760545738
    },
    {
        "content": "<p>Note that in theory <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> notation can express implementations that are faster than the <code>&gt;&gt;=</code> generated by <code>do</code>notation</p>",
        "id": 545013156,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1760546068
    },
    {
        "content": "<p>Eg <code>&lt;$&gt;</code> on an array monad can preallocate up front, and on a state monad it can in theory elide a reference count</p>",
        "id": 545013216,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1760546091
    },
    {
        "content": "<p>Interesting!</p>\n<blockquote>\n<p>in theory</p>\n</blockquote>\n<p>Do they? <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 545013301,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1760546120
    },
    {
        "content": "<p>If so—or even if they might confer an advantage over <code>do</code> in the future—it would, imo, make sense to allow these specific combinators, especially in performance-critical pieces of code.</p>",
        "id": 545013693,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1760546254
    },
    {
        "content": "<p>(But I’d like to distinguish them from the ones which don’t! <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span>)</p>",
        "id": 545013840,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1760546305
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Attempted test-case</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Array.replicate</span><span class=\"w\"> </span><span class=\"mi\">10000000</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Array.flatMap</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Array.map</span>\n\n<span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace.profiler</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span>\n\n<span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace.profiler</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">Array.size</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n</code></pre></div>\n</div></div>",
        "id": 545014276,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1760546422
    },
    {
        "content": "<p>Admittedly seems very marginal</p>",
        "id": 545014353,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1760546445
    },
    {
        "content": "<p>(I’ll also link the thread <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/Alternative.20and.20do-notation/with/543620783\">#lean4 &gt; Alternative and do-notation</a> as well as <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/Applicative.20and.20do-notation/with/543620889\">#lean4 &gt; Applicative and do-notation</a> here for good measure)</p>",
        "id": 545014585,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1760546531
    }
]