[
    {
        "content": "<p>Hi,</p>\n<p>I'm currently investigating how to approach formalizing complexity theory, and while doing so I found <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Primrec#doc\">docs#Primrec</a> which I had to give a go.</p>\n<p>While proving some basic statements I noticed that Mathlib is missing some obvious lemmas. E.g. the following theorems (plus similar versions for <code>mul</code>, <code>sub</code>, <code>mod</code>, etc.). Without them, a major part of my code is just <code>Primrec.id</code> and <code>Primrec.const _</code>. (Maybe we could have a tactic for <code>Primrec</code> too.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">nat_add_right</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Primrec₂</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">nat_add</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">nat_add_left</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Primrec₂</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">nat_add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">id</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n<span class=\"n\">include</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"n\">hg</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Primrec₂</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">nat_add</span><span class=\"w\"> </span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"n\">snd</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I was also wondering if there's a mistake in the following doc comment comment about <code>PrimrecRel</code> in <code>Primrec.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"ss\">`PrimrecRel</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">means</span><span class=\"w\"> </span><span class=\"ss\">`p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">decidable</span><span class=\"o\">)</span>\n<span class=\"n\">primitive</span><span class=\"w\"> </span><span class=\"n\">recursive</span><span class=\"w\"> </span><span class=\"n\">relation</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">which</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">say</span><span class=\"w\"> </span><span class=\"n\">that</span>\n<span class=\"ss\">`decide</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">primitive</span><span class=\"w\"> </span><span class=\"n\">recursive</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p><code>decide ∘ p</code> doesn't type check as the codomain of <code>decide</code> is not <code>β → Bool</code>. It was probably copied over from <code>PrimrecPred</code>. This is not so important, as the idea of the notion is pretty clear any ways, and the formal definition does type check.</p>\n<p>Edit: never mind about the tactic, I found this <code>apply_rules</code> trick which solves most of my examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">apply_rules</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">    </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">nat_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">nat_mul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">nat_sub</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Primrec</span><span class=\"bp\">.</span><span class=\"n\">nat_mod</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Primrec₂</span><span class=\"bp\">.</span><span class=\"n\">comp</span>\n<span class=\"w\">  </span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 526208302,
        "sender_full_name": "Niklas Halonen",
        "timestamp": 1751121945
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Part.bind_some#doc\">docs#Part.bind_some</a>, but I couldn't find <code>Part.seq_some</code>. Would something like the following be good to have in Mathlib?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Part</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Part</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">seq_some</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Part</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">&lt;*&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Part</span><span class=\"bp\">.</span><span class=\"n\">instLawfulMonad</span><span class=\"bp\">.</span><span class=\"n\">toLawfulApplicative</span><span class=\"bp\">.</span><span class=\"n\">seq_pure</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Part</span>\n</code></pre></div>\n<p>It seems like this makes simplification of Partrec.Code expressions much better.</p>\n<p>Or should Part.some be simplified towards <code>pure</code> instead?  Then this simp lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Part.pure_eq_some#doc\">docs#Part.pure_eq_some</a> would be backwards.</p>\n<p>Here's an example (the factorial function) which compiles in the presence of <code>Part.seq_some</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">A minimized proof of factorial function expressed as `Code`.</span>\n\n<span class=\"cm\">This example attempts to highlight the need for the `Part.seq_some`, `PFun.pure_apply` and `Code.eval_zero` simp lemmas.</span>\n\n<span class=\"cm\">Removing any of them will cause various simps to stop half-way.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Part</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"c1\">-- This should be in Mathlib</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">seq_some</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Part</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">&lt;*&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Part</span><span class=\"bp\">.</span><span class=\"n\">instLawfulMonad</span><span class=\"bp\">.</span><span class=\"n\">toLawfulApplicative</span><span class=\"bp\">.</span><span class=\"n\">seq_pure</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Part</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">PFun</span>\n\n<span class=\"c1\">-- This should be in Mathlib</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">pure_apply</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PFun</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">PFun</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Partrec</span><span class=\"bp\">.</span><span class=\"n\">Code</span>\n\n<span class=\"c1\">-- This should be in Mathlib</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">eval_zero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Part</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">prec</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">eval_add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">add</span>\n<span class=\"w\">  </span><span class=\"n\">induction'</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eval</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">ac_rfl</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">prec</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">eval_mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">mul</span>\n<span class=\"w\">  </span><span class=\"n\">induction'</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eval</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">congr</span>\n\n<span class=\"c1\">-- `comp right right` gives `ih` and `comp left right` gives `k` (i.e. `n - 1`)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fact_rec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">   </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"o\">))</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fact</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">fact_rec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">eval_fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fact</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">fact</span><span class=\"w\"> </span><span class=\"n\">fact_rec</span>\n<span class=\"w\">  </span><span class=\"n\">induction'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eval</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eval</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">factorial_succ</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">ac_rfl</span>\n</code></pre></div>\n<p>I guess we could add these definitions for <code>add</code>, <code>mul</code>, <code>fact</code> (I have <code>pow</code> too) to <code>Code</code>, what do you think?</p>",
        "id": 526261234,
        "sender_full_name": "Niklas Halonen",
        "timestamp": 1751193482
    }
]