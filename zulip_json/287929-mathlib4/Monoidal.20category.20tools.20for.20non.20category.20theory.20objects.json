[
    {
        "content": "<p>I am working with objects that are not implemented as a category in Mathlib, but I want to use some cool operations and tactics from the category theory part of Mathlib, and I am not sure on how to proceed.</p>\n<p>In the probability theory part of the library, I am working with measurable spaces (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasurableSpace#doc\">docs#MeasurableSpace</a>) and probability transition kernels (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.Kernel#doc\">docs#ProbabilityTheory.Kernel</a>) that map one measurable space to another. When composing kernels, issues can arise: you can't compose <code>κ : Kernel α' (α × (β × γ))</code> and <code>η : Kernel ((α × β) × γ) δ</code> because the two products of three spaces are not the same type because the parentheses are not at the same place. To compose them, you have to insert a measurable equivalence between the measurable spaces and in more complex cases the code can get long and hard to read. On paper, you would just compose them and not even mention the associativity issue.</p>\n<p>Now if we take a category theory point of view, measurable spaces and kernels are a symmetric monoidal category (under some restriction on the kernels we consider). If you restrict the kernels enough, they are even a Markov category as <a href=\"#narrow/stream/113489-new-members/topic/Automation.20for.20Markov.2FMonoidal.20Category.20Theory/near/469102847\">discussed here recently</a> .<br>\nThat means that if the <code>κ</code> and <code>η</code> discussed above were implemented as morphisms in such a category, I could write <code>κ ⊗≫ η</code> to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.monoidalComp#doc\">docs#CategoryTheory.monoidalComp</a>, which automatically finds and inserts the associator needed, and I could also use the coherence tactics Yuma Mizuno  is PRing to mathlib these days. If possible, I'd also like to use string diagrams for kernels.</p>\n<p>The main question is: how do I get to use the category theory definitions and tactics for kernels?</p>\n<p>I see an ugly solution, which is to copy the definitions and tactics but specialize them to the case of measurable spaces and kernels instead of objects and morphisms in a monoidal category. I would defined a specialized <code>MonoidalCoherence</code> class which uses measurable equivalences and a <code>monoidalComp</code> for kernels. That's a lot of duplication and not very appealing.</p>\n<p>Is there a better solution? Was a similar thing done somewhere else in the library?</p>",
        "id": 469406115,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1726063031
    },
    {
        "content": "<p>Do you know about <code>prod_assoc%</code>, the elaborator that automatically reassociates products?</p>",
        "id": 469406984,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1726063183
    },
    {
        "content": "<p>I don't! Do you have a link to some doc? Will it allow me to write compositions as easily as <code>κ ⊗≫ η</code>?</p>",
        "id": 469408880,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1726063468
    },
    {
        "content": "<p>(found the doc by myself)</p>",
        "id": 469409839,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1726063613
    },
    {
        "content": "<p>I don't know how <code>⊗≫</code> works exactly in category theory but I believe the heavy lifting is done by <code>prod_assoc%</code></p>",
        "id": 469410577,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1726063768
    },
    {
        "content": "<p><code>prod_assoc%</code> produces equivalences between products, but I would need measurable equivalences. Also I would really like to not have any equivalences at all (as in, not see them in the code).</p>",
        "id": 469410589,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1726063771
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Monoidal.20category.20tools.20for.20non.20category.20theory.20objects/near/469410577\">said</a>:</p>\n<blockquote>\n<p>I don't know how <code>⊗≫</code> works exactly in category theory but I believe the heavy lifting is done by <code>prod_assoc%</code></p>\n</blockquote>\n<p>No, these are two completely different things. The monoidal one adds in isomorphisms on the fly, assuming the isomorphism is something that holds true in the free monoidal category. <code>prod_assoc</code>is indeed just for (type-level) products.</p>",
        "id": 469449092,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726070579
    },
    {
        "content": "<p>the benefit of <code>prod_assoc%</code> over the monoidal category one is that you can let the components of the product live in arbitrary universes.</p>",
        "id": 469449237,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726070610
    },
    {
        "content": "<p>if you want to use the monoidal category infrastructure, then you would need to introduce a monoidal category at some point. IIRC the Kleisli category of the Giry monad is supposed to be the category whose morphisms are Markov kernels, is that right?</p>",
        "id": 469450297,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726070832
    },
    {
        "content": "<p>BTW, the equivalences produced by <code>prod_assoc%</code> are extremely simple and exactly what you expect, so a <code>measurability</code> tactic <em>should</em> be able to discharge measurability proof obligations for such maps. But again, this elaborator is weaker than what the monoidal coherence tactic does since it only accounts for associativity, and not commutativity or units.</p>",
        "id": 469451282,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726071039
    },
    {
        "content": "<p>I think the nice way to accomplish this using existing category theory infrastructure is to prove that the Kleisli category of a monoidal monad is monoidal ( <span aria-label=\"sunglasses\" class=\"emoji emoji-1f60e\" role=\"img\" title=\"sunglasses\">:sunglasses:</span> ), then specialize to whatever variant of the Giry monad you want.</p>",
        "id": 469452082,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726071249
    },
    {
        "content": "<p>I agree that at some point I have to introduce a monoidal category, and I have partial code to prove that the Kleisli category of a monoidal monad is monoidal and I could apply that to some variant of the Giry monad. At some point it's clear I have to prove that those monoidal results apply to my objects.</p>\n<p>But I have no Idea how that would help me work with the type <code>Kernel</code>. I could prove a bunch of results for Markov categories, sure, or for copy-discard categories or whatever, but then I want to use them with the non-category types <code>MeasurableSpace</code> and <code>Kernel</code>. And I have no idea how to do that transfer.</p>",
        "id": 469470577,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1726075648
    },
    {
        "content": "<p>A kernel is a morphism in the Kleisli category, isn’t it?</p>",
        "id": 469471913,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726076101
    },
    {
        "content": "<p>If you’re opposed to using the category theory API, then you will probably have to do some duplication</p>",
        "id": 469472248,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726076230
    },
    {
        "content": "<p>Yes they are morphisms in that category, but I also don't understand why you ask. I have actually written several paragraphs to answer and then deleted them repeatedly because I kept thinking that there is something perhaps simple that I am missing, related to that question.</p>\n<p>I clearly have not enough experience with categories in Lean that are not \"some generic category\" but actually a category with objects and morphisms given by some types. I'll build a category of measurable spaces and Markov kernels, play with it, and come back with questions supported by actual code. That will be better than vague questions like the one above.</p>",
        "id": 469482502,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1726080058
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"350992\">@Rémy Degenne</span> do I understand correctly that you are asking what the most ergonomic way is to move back and forth between the unbundled language of <code>Kernel</code> and the \"bundle everything into objects and morphisms of a category\" language that is needed to apply the cool tactics?</p>",
        "id": 469482849,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1726080197
    },
    {
        "content": "<p>That's definitely something I'd like to know more about. If you have an example of code where such back-and-forth is done, I'd like to look at that.</p>",
        "id": 469483282,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1726080370
    },
    {
        "content": "<p>For categories of groups, rings, modules, etc, we typically have definitions like <code>CommRingCat.of R</code> that search for a <code>[CommRing R]</code> instance and then bundle that up together with <code>R</code> into an object of <code>CommRingCat</code></p>",
        "id": 469483642,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1726080512
    },
    {
        "content": "<p>It's not as transparent as I would like it to be.</p>",
        "id": 469483667,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1726080525
    },
    {
        "content": "<p>Doesn't category theory force you to consider objects in the same universe?</p>",
        "id": 469483733,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1726080562
    },
    {
        "content": "<p>Sorry for the confusion <span class=\"user-mention\" data-user-id=\"350992\">@Rémy Degenne</span> -- Here are some further details: First, for a specific monad <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> on a monoidal category which satisfies some assumptions, you can construct the category <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Monad/Kleisli.html#CategoryTheory.Kleisli\">CategoryTheory.Kleisli</a> . As you can see, this is just a type alias, but it has a different category structure where a morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> in there is, <em>by definition</em> a morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>M</mi><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X \\to M Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> in the original category. So, if you take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> to be the category of (bundled) measurable spaces with morphisms being measurable morphisms, and take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> to be some Giry monad, if you use this construction you get an alias for the type of measure spaces which has a different category structure where morphisms are \"kernels\", except that these kernels are defined in terms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quiver.Hom#doc\">docs#Quiver.Hom</a> . You can easily define an equivalence between such types of morphisms and the type of kernels that already exist in the measure theory library, but they won't be defeq. And yes, as <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span> mentions, this approach will force you to put some artificial universe restrictions.</p>",
        "id": 469486479,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726081634
    },
    {
        "content": "<p>Unfortunately this is the only way to use the monoidal coherence automation. If you want to stick to the unbundled approach, and avoid these universe restrictions, then you would have to develop some custom automation (e.g. similar to <code>prod_assoc%</code>)</p>",
        "id": 469487049,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726081867
    },
    {
        "content": "<p>Thanks for the explanation, I get better now how the morphisms of the category and the other kernels would be related. I'll definitely implement that category and the equivalence you mention, play with it and try to get a better idea of what results about <code>Kernel</code> I can or cant get from it.</p>",
        "id": 469493121,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1726083531
    },
    {
        "content": "<p>I hope you don't have to work too hard:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">KernelCat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Kleisli</span><span class=\"w\"> </span><span class=\"n\">MeasCat.Giry</span>\n\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">KernelCat</span>\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">KernelCat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Kleisli</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"n\">KernelCat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">MeasCat</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">X</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">KernelCat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">KernelCat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProbabilityTheory.Kernel</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f.val</span>\n<span class=\"w\">  </span><span class=\"n\">measurable'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f.property</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">KernelCat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProbabilityTheory.Kernel</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f.measurable</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 469515081,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726093044
    },
    {
        "content": "<p>In fact, if we have a class <code>ProbabilityTheory.KernelLike</code> (should we?) then you could put such an instance on homs in <code>KernelCat</code> and call it a day!</p>",
        "id": 469515217,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726093126
    },
    {
        "content": "<p>Thanks for the example! I'll experiment with the KernelLike approach you mention.</p>\n<p>That particular category won't have a particularly nice structure because our Giry monad is not the same as the Giry monad in most papers (ours does not restrict to probability measures) but defining the other monad will be easy. Proving that the category is monoidal will require more work, but I have started doing that some time ago.</p>",
        "id": 469556559,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1726118108
    }
]