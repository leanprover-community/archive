[
    {
        "content": "<p>When does <code>simp</code> unfold <code>abbrev</code>s? I don't have an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> right now, but I have a code, where <code>simp</code> fails to simplify <code>(ContinuousLinearMap.comp g f).det</code> even though <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousLinearMap.det#doc\">docs#ContinuousLinearMap.det</a> is an <code>abbrev</code>. Adding <code>ContinuousLinearMap.det</code> to the arguments of <code>simp</code> makes it work.</p>",
        "id": 570736570,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769676963
    },
    {
        "content": "<p><code>simp</code> doesn't unfold <code>abbrev</code>s, it sees through them</p>",
        "id": 570765991,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769684977
    },
    {
        "content": "<p>If you want <code>simp</code> to unfold definition you have to mark definition with <code>@[simp]</code>. <code>abbrev</code> in the context of simp I think boils down to telling <code>simp</code> that it should use simp lemmas about body of an abbrev to also simplify the definition. E.g. if you have <code>abbrev foo .. := bar ..</code> then the <code>simp</code> will use lemmas like <code>bar .. ↔ something</code> to simplify <code>foo</code>, or lemmas like <code>bar .. → something_else</code> to prove <code>something_else</code> from <code>foo ..</code>.</p>",
        "id": 570771873,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769686927
    },
    {
        "content": "<p>I'm guessing you have something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">toA</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">toA_comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toA</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">toA</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toA</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toA</span><span class=\"bp\">.</span><span class=\"n\">det</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">fail_if_success</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">guard_target</span><span class=\"w\"> </span><span class=\"bp\">=ₛ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">det</span>\n<span class=\"w\">  </span><span class=\"n\">guard_target</span><span class=\"w\"> </span><span class=\"bp\">=ₛ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toA</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">guard_target</span><span class=\"w\"> </span><span class=\"bp\">=ₛ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">toA</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toA</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 570778505,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769688942
    },
    {
        "content": "<p>To me since I know how <code>simp</code> works this is somewhat expected but I can see how it would be unintuitive/confusing</p>",
        "id": 570778706,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769688998
    },
    {
        "content": "<p>So, it doesn't see through them well enough to apply <code>B.toA_comp</code> in this context, right? What are the practical recommendations then? Drop the <code>abbrev</code>? Turn it into a <code>def</code> and mirror API?</p>",
        "id": 570813160,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769697609
    },
    {
        "content": "<p>I think you either have to mirror API or mark it with <code>@[simp]</code>? But the former is preferred usually. I think this is similar to e.g. <code>Vector</code>. We could just simp <code>Vector.map f xs</code> to <code>Vector.mk (Array.map f xs.toArray)</code>, and then all the verification API about <code>Array.map</code> would apply. But we don't do that and instead mirror verification API about <code>.map</code>. There are plenty of examples like that.</p>",
        "id": 570910739,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769727183
    },
    {
        "content": "<p>In some cases, <code>simp</code> can see through an <code>abbrev</code> and apply a theorem about the underlying definition. While the rules are trivial for <code>def</code>s, they aren't as clear (at least, to me) for <code>abbrev</code>s.</p>",
        "id": 570917016,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769730821
    },
    {
        "content": "<p>For me, <a href=\"https://lean-lang.org/doc/reference/latest/Definitions/Recursive-Definitions/#reducibility\">this part of the manual</a> suggests that <code>abbrev</code>s should be regarded as syntactic sugar by most of the core tactics.</p>",
        "id": 570917294,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769731013
    },
    {
        "content": "<p>If the current behavior (don't apply <code>B.toA_comp</code> in the example above) is the expected behavior, then it should be better documented.</p>",
        "id": 570917472,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769731148
    },
    {
        "content": "<p>I think what happens here is that given goal <code>(g.comp f).det = 0</code> Lean will try to search for theorems that match <code>(g.comp f).toA.det</code>, and of course it fails. But because <code>simp</code> doesn't unfold the definition it won't recurse into subexpressions of unfolded definition.</p>",
        "id": 570917939,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769731375
    },
    {
        "content": "<p>While this looks like a plausible explanation, I think that the behavior should be clearly documented.</p>",
        "id": 570918290,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769731586
    },
    {
        "content": "<p>Yup, I was also confused about <code>simp</code> \"not working\" with <code>abbrev</code>. Still somehow am. Tbh, even understanding the principles still doesn't really help in answering the question when and how should <code>abbrev</code> be used when programming or designing API.</p>",
        "id": 571077364,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769791641
    }
]