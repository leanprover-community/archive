[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Could you suggest a reference if a fully general version of non-Abelian group cohomology is possible to be defined? I think we tried to do some searching before formalizing this but didn't find anything more general.</p>",
        "id": 569716880,
        "sender_full_name": "Wang Jingting",
        "timestamp": 1769175487
    },
    {
        "content": "<p><a href=\"#narrow/channel/287929-mathlib4/topic/non-abelian.20group.20cohomology/near/569716880\">A message</a> was moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Question.20about.20to_additive/with/569872281\">#general &gt; Question about to_additive</a> by <span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span>.</p>",
        "id": 569876588,
        "sender_full_name": "Notification Bot",
        "timestamp": 1769268684
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"750070\">@Wang Jingting</span> I have moved your question to a more appropriate thread (the previous one is about the issues with to_additive; the below is an independent mathematical question). </p>\n<p><span class=\"user-mention silent\" data-user-id=\"750070\">Wang Jingting</span> <a href=\"#narrow/channel/113488-general/topic/Question.20about.20to_additive/near/569716880\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> Could you suggest a reference if a fully general version of non-Abelian group cohomology is possible to be defined? I think we tried to do some searching before formalizing this but didn't find anything more general.</p>\n</blockquote>\n<p>Although I don't know the area myself, my understanding is that there are exotic ways of doing nonabelian cohomology involving gerbes and other fancy things like that. </p>\n<p>Here is my understanding of group cohomology (of abelian groups). Historically humans discovered <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">H^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n\\leq 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> first, often as n-cocycles over n-coboundaries. These ideas (plus clunky calculation proofs relating different cohomology groups) were enough to push through the first proofs of global class field theory. Later on it was discovered that these constructions were a special case of a general theory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mi>n</mi></msup><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H^n(G,A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> of group cohomology, which could be used to streamline and simplify the original proofs. However it's still important to have an \"explicit\" version of the theory in low degree <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n\\leq 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>, because sometimes (for example when doing a diagram chase or a construction of an element of a cohomology group from some other mathematical object) it's really important to have access to the 1-cocycle or 2-cocycle; furthermore sometimes a 2-cocycle might contain more information than the corresponding cohomology class, which one occasionally wants to keep track of (analogous to how we sometimes pick a basis for a vector space). </p>\n<p>As a result, mathlib's set-up for group cohomology involves a general <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">H^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> definition, and then special API for degrees <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n\\leq 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> where one can define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>- and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>-cocycles explicitly (rather than having them be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>-cocycles for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n=2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>; an analogue would be being able to refer to an element of <code>ℝ</code> or  <code>ℝ × ℝ</code> rather than having to talk about an element of <code>Fin n → R</code> for n=1 or 2). We have been stress-testing this definition in the class field theory repo and it seems to be holding up well.</p>\n<p>Historically the development of abelian group cohomology in mathlib went like this: first I gave a 3rd year undergraduate the project of developing H^1 and H^2, and then I gave a Masters student the project of developing H^n for all n, and then I gave a PhD student the project of developing H^n whilst avoiding all the mistakes that I'd made when working with the other students, and got the PhD student to PR things to mathlib.</p>\n<p>With nonabelian cohomology I feel like there are several questions which we might want to consider before starting on PRing material. Firstly, should there be some kind of crazy nonabelian cohomology approach which we set things up using fancy stuff and then restrict to degree at most 2? Secondly, what should the relationship be between the abelian and the nonabelian theory? I don't immediately have the answer to either of these questions but at least I feel like they should be discussed.</p>",
        "id": 569877657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769269534
    },
    {
        "content": "<p>It might well be the case that there is a good argument for setting up the low-degree theory in an elementary way in the non-abelian setting. I am going on about gerbes and stacks and what have you but I don't know anything about the details here, all I know is that French people write complicated books about the theory. However in the abelian case I became convinced during the time I was supervising the students that developing a low-degree theory was not the best way to approach things for mathlib, and what we should do instead is what we have done in mathlib, i.e., developing a fancy theory which works in general and then making all the API to show that in low degree it could be treated exactly like the low-level definition.</p>\n<p>In your situation this simply might not apply, and perhaps the approach is to avoid all this fancy stuff and just do what you're doing. </p>\n<p>The other thing worth discussing is how to relate this to the abelian case. In the abelian case we have explicit definitions for n-cocycles and n-coboundaries for n&lt;=2; should these be generalised to the nonabelian case? Can they be generalised? If they can, should you be using these instead? I am a bit worried about relating nonabelian cohomology to abelian cohomology when the not-necessarily-abelian group is actually abelian. Hmm, looking at the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=groupCohomology.cocycles%E2%82%81#doc\">docs#groupCohomology.cocycles₁</a> maybe it will be hopeless trying to reuse this theory. At the very least I think that you might want to stick to the notation that we're using in the abelian case.</p>\n<p>These are just vague thoughts but I thought I should raise them.</p>",
        "id": 569878777,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769270464
    },
    {
        "content": "<p>Yeah, I agree with you on that the current way of formalizing (Abelian) group cohomology in mathlib is the right way to do - first develop the general theory and then specialize to n = 1, 2. </p>\n<p>For the part about relating nonabelian cohomology to abelian case, we have already constructed isomorphisms between the (explicitly constructed) non abelian group cohomology and abelian version for n = 0, 1 and proved that these isomorphisms commutes with <code>H0.map</code> and the connection homomorphism.</p>\n<p>(We also have <code>Z1</code> corresponding to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=groupCohomology.cocycles%E2%82%81#doc\">docs#groupCohomology.cocycles₁</a>, and the equivalence between them)</p>\n<p>If you think it's necessary, we could certainly change the notations to match the abelian version.</p>",
        "id": 569915940,
        "sender_full_name": "Wang Jingting",
        "timestamp": 1769304910
    },
    {
        "content": "<p>I think people may have a use for formalized nonabelian H^1 in the near future - there are applications in many areas of math. On the other hand, it may be a very long time before anyone needs a formalization of higher nonabelian cohomology.  So, I would suggest focusing on H^1 for now.<br>\nBy the way, the basic reference is Giraud’s “Cohomologie Non-abelienne” (spelling may be wrong)</p>",
        "id": 569916410,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1769305476
    },
    {
        "content": "<p>As I just said on the PR, I think that setting things up for <code>AddGroup</code> is a terrible idea. All the examples of non-abelian cohomology I know have group law multiplication, I don't know of a single example in mathematics of a group with group law written as addition which is not commutative, and finally mathlib's philosophy is \"multiplicative case first, and if you want the additive case then <code>to_additive</code> it\". So right now I would say that this PR should be multiplicativised.</p>",
        "id": 570047131,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769420608
    }
]