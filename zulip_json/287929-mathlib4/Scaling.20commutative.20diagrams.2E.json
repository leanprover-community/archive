[
    {
        "content": "<p>There has been some talk recently about making a 4-variable version of <code>IsScalarTower</code> (\"this triangle commutes\"), corresponding to \"this square commutes\". The canonical example is when B/A is an extension of integral domains and L/K is the corresponding extension of their field of fractions. The reason one might want to bundle everything up into a structure <code>IsCommSquare A B K L</code> is that sometimes you want things like Gal(L/K) to act on B (e.g. if K,L are number fields with integer rings A,B), but typeclass inference won't let that happen without something gluing L and K to B.</p>\n<p>I've been thinking about Frobenius elements recently and how to implement them in the right level of generality. Following a suggestion of Joel Riou I've been formalising <a href=\"#narrow/stream/416277-FLT/topic/Outstanding.20Tasks.2C.20V4/near/449562398\">a lemma from Bourbaki Comm Alg</a> (note: in French), and part (b) of it involves a pair of commuting squares</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>B ---&gt; B / P -----&gt; K = Frac(B/P)\n/\\       /\\        /\\\n|        |         |\n|        |         |\nA ---&gt; A / p ----&gt; k = Frac(A/p)\n</code></pre></div>\n<p>Here A,B are comm rings, P a prime ideal of B with preimage p, and k,K are the fields of fractions of A/p and B/P.  This is now two commuting squares, and if you draw in some of the missing arrows then you get something like..erm.. 11(?) IsScalarTower instances (i.e. 11 pairs of composable morphisms), most of which we seem to use in practice in the proof, and most of which cannot be discovered by typeclass inference unless you explicitly put it in there.</p>\n<p>I learnt from Jou Glasheen's FM24 project (and apparently she learnt this trick from Amelia) that if this diagram commutes then you don't need the assumption that the preimage of P is p, it follows from a diagram chase. Here's what that diagram chase looks like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RingTheory</span><span class=\"bp\">.</span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">Pointwise</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RingTheory</span><span class=\"bp\">.</span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">Over</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">FieldTheory</span><span class=\"bp\">.</span><span class=\"n\">Normal</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">algebraMap</span>\n\n<span class=\"c1\">-- Let A be a comm ring and let B be an A-algebra.</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">Mathematically I now want to say \"let P be a prime ideal of B above p of A, and</span>\n<span class=\"cm\">let `k` and `K` be the fields of fractions of the integral domains `A/p` and `B/P`.</span>\n\n<span class=\"cm\">In diagrams:</span>\n\n<span class=\"cm\">B ---&gt; B / P -----&gt; K = Frac(B/P)</span>\n<span class=\"cm\">/\\       /\\        /\\</span>\n<span class=\"cm\">|        |         |</span>\n<span class=\"cm\">|        |         |</span>\n<span class=\"cm\">A ---&gt; A / p ----&gt; k = Frac(A/p)</span>\n\n<span class=\"cm\">In Lean:</span>\n<span class=\"cm\">-/</span>\n<span class=\"c1\">-- first the objects for the LH square.</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">IsPrime</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">IsPrime</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Use a trick I learnt from Jou and which she learnt from Amelia to encode</span>\n<span class=\"w\">  </span><span class=\"c1\">-- `Ideal.comap (algebraMap A B) P = p` into the typeclass system:</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"c1\">-- this implies p ⊆ P ∩ A</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Now draw in top line of RH square</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsFractionRing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- It's convenient that `B` be a `K`-algebra but typeclass inference doesn't know this</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- It's convenient that `K` is an `A/p`-algebra so make the triangle commute</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- That's 5/6 of the objects and 3/4 of the area.</span>\n<span class=\"w\">  </span><span class=\"c1\">-- now introduce k</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsFractionRing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Turns out that it's convenient for `k` to be an `A`-algebra</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Now draw the final edge</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- and make the final triangle commute</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Turns out that we will need that other triangles commute.</span>\n<span class=\"w\">  </span><span class=\"c1\">-- For example there are now maps A -&gt; B/P -&gt; K, A -&gt; B -&gt; K, A -&gt; A/p -&gt; K, A -&gt; k -&gt; K</span>\n<span class=\"w\">  </span><span class=\"c1\">-- (all eight of these arrows are `Algebra` instances!)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- and all four pairs, when composed, give the same map A -&gt; K but we don't have `Algebra A K` yet.</span>\n\n<span class=\"c1\">-- API, should probably be elsewhere</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">obvious</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">algebraMap_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">RingHom</span><span class=\"bp\">.</span><span class=\"n\">mem_ker</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">mk_ker</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Do we want lemmas like this? This says \"If W -&gt; X -&gt; Y and X -&gt; Y -&gt; Z commute,</span>\n<span class=\"c1\">-- then Z is randomly a W-algebra, then W -&gt; X -&gt; Z commutes iff W -&gt; Y -&gt; Z does\"</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">isScalarTower_iff_isScalarTower_of_isScalarTower_isScalarTower</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"bp\">.</span><span class=\"n\">of_algebraMap_eq</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">w</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">algebraMap_apply</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">algebraMap_apply</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">algebraMap_apply</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"bp\">.</span><span class=\"n\">of_algebraMap_eq</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">w</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">algebraMap_apply</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">algebraMap_apply</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">algebraMap_apply</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Should I be proving that or adding it in our application as a hypothesis?</span>\n\n<span class=\"c1\">-- Let's now prove that the preimage of P is p; this follows from commutativity of the diagram.</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"c1\">-- we'd better now draw in that long diagonal and say that it commutes with *something*</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"c1\">-- and now this means that there are three more IsScalarTower instances which we don't</span>\n<span class=\"c1\">-- have but which we will probably want.</span>\n<span class=\"w\">    </span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">mem_comap</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">obvious</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">obvious</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">map_eq_zero_iff</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">IsFractionRing</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">map_eq_zero_iff</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">IsFractionRing</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">map_eq_zero_iff</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">RingHom</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">algebraMap_eq_smul_one</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"bp\">.</span><span class=\"n\">smul_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">smul_assoc</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">isScalarTower_iff_isScalarTower_of_isScalarTower_isScalarTower</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"bp\">.</span><span class=\"n\">of_algebraMap_eq</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">algebraMap_apply</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">algebraMap_apply</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">algebraMap_apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">algebraMap_apply</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">algebraMap_apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">congr</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">algebraMap_apply</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">algebraMap_apply</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>I've tried to add details in case anyone actually cares or can significantly golf this. But basically my point is that the way I've got things set up here it's getting as bad as differential geometry ;-) (and that is not a good thing). Should I be considering bundling up stuff into \"Let these 4 things be a commuting square\", or just pressing on regardless? Note that I haven't even started the one page long proof yet: those 100 lines are just the set-up necessary to state part (b) of the theorem (in fact they're not enough because I haven't mentioned the group G in the lemma, but the G part is short).</p>",
        "id": 468199242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725631917
    },
    {
        "content": "<p>Your <code>obvious</code> seems to be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.Quotient.eq_zero_iff_mem#doc\">docs#Ideal.Quotient.eq_zero_iff_mem</a>.</p>",
        "id": 468209474,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1725634319
    },
    {
        "content": "<p>Here's my attempt to restate part of your problem: you have a commutative diagram (of <code>algebraMap</code>s in this case), but typeclass inference needs a lot of handholding to recognize the commutativity of certain sub-diagrams.</p>",
        "id": 468295387,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1725659620
    },
    {
        "content": "<p>I'm not sure that typeclass inference is even the right tool for keeping track of all ten or so assertions of the form \"the algebra maps from X to Y, from Y to Z and from X to Z are compatible\" because some proofs of statements like this are of the form \"true for (X,Y,T) and (Y,T,Z) and (X,T,Z) hence true\" and typeclass inference doesn't want to go on a wild goose chase looking for T in case it's not there.</p>",
        "id": 468307429,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725664701
    },
    {
        "content": "<p>This is where we need some custom tactics and metaprogramming. Something that could look at some diagram encoded as a graph, and generate algebra and/or scalar tower instances on the fly as they’re needed. This <code>algebraize</code> tactic from the AIM workshop is a small step toward something like this!</p>",
        "id": 468320493,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725673682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Scaling.20commutative.20diagrams.2E/near/468320493\">said</a>:</p>\n<blockquote>\n<p>This is where we need some custom tactics and metaprogramming. Something that could look at some diagram encoded as a graph, and generate algebra and/or scalar tower instances on the fly as they’re needed. This <code>algebraize</code> tactic from the AIM workshop is a small step toward something like this!</p>\n</blockquote>\n<p>Yes, it wouldn't be too hard to let it accept a <code>CommSq</code> of <code>RingHoms</code> and add all possible <code>IsScalarTower</code> instances. But then one would need to have the individual ringhoms instead of the algebra instances as parameters, which maybe is not ideal. I think that developing API for<code>IsCommSquare A B K L</code> sounds like a good idea, as this situation is surely common enough.</p>",
        "id": 468359258,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1725691692
    },
    {
        "content": "<p>So maybe we should have a <code>smart_goose_chase</code> tactic that we can call at the beginning of a proof?</p>",
        "id": 468376054,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725697943
    },
    {
        "content": "<p>And it will add all those scalar tower instances, starting from the 4 \"fundamental\" triangles?</p>",
        "id": 468376175,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725697993
    },
    {
        "content": "<p>But you would still need 11 algebra instances?</p>",
        "id": 468376219,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725698010
    },
    {
        "content": "<p>ooh, I guess there are 6 fundamental triangles... also the horizontal pairs</p>",
        "id": 468376514,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725698094
    },
    {
        "content": "<p>My instinct, which I'll be refining on the 15 hour flight that I'm about to get on, is that one commutative square is two scalar tower triangles, and my diagram is two commutative squares (not three) and hence four scalar towers (not six or 11). </p>\n<p>Part of the argument I'm formalising involves the assertion \"WLOG p is maximal because just localise duh\", and it will be interesting to see how many hundreds of lines of code this spirals into (I'll need to make several more commuting squares). I suspect this will teach me a lot!</p>",
        "id": 468377498,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725698391
    },
    {
        "content": "<p>It is 6 because you need two scalar towers to encode the horizontal rows</p>",
        "id": 468377964,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725698521
    },
    {
        "content": "<p>Right -- I only added them because I could see that they were there. Right now I only formalised the statements of things I wanted and I'm not 100% sure exactly for which pairs (X,Y) I want to be able to explicitly claim that Y is an X-algebra. The bare minimum is the seven arrows in the diagram. And then right now you also need the two diagonals of the squares in order to use IsScalarTower to assert that the diagram commutes. But of course we only need these under the assumption that we want typeclass inference to know that the square commutes, there are other ways to say this, eg some tactic which creates coercions between any two objects in the diagram which can be reached by composing explicit arrows, without creating algebra instances. The design space seems quite big to me.</p>",
        "id": 468378930,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725699154
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Scaling.20commutative.20diagrams.2E/near/468376175\">said</a>:</p>\n<blockquote>\n<p>And it will add all those scalar tower instances, starting from the 4 \"fundamental\" triangles?</p>\n</blockquote>\n<p>This might not help if the instances are needed in the statement</p>",
        "id": 468392317,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1725705900
    },
    {
        "content": "<p>That's a good point!</p>",
        "id": 468397835,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725710008
    },
    {
        "content": "<p>Sounds like you want a macro taking in a commutative diagram and spitting out the relevant <code>IsScalarTower</code> instances, in the same style as the <code>[[VectorSpace K V]]</code> notation</p>",
        "id": 468397994,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1725710092
    },
    {
        "content": "<p>I think that instead of just moaning I might want to launch into some proofs and then see what's painful. The code above looks a bit hectic but if I can push the base change argument through then arguably we don't need any new tooling</p>",
        "id": 468398368,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725710321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Scaling.20commutative.20diagrams.2E/near/468397994\">said</a>:</p>\n<blockquote>\n<p>Sounds like you want a macro taking in a commutative diagram and spitting out the relevant <code>IsScalarTower</code> instances, in the same style as the <code>[[VectorSpace K V]]</code> notation</p>\n</blockquote>\n<p>Or maybe <code>variable_for_diagram &lt;some ASCII art&gt;</code></p>",
        "id": 468402264,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1725712509
    },
    {
        "content": "<p>Maybe another good option here is to have something that generates a structure for a given diagram, which bundles all the types. Typeclass search would then be happy to find <code>IsScalarTower s.A s.B s.C</code> etc</p>",
        "id": 468402423,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1725712620
    },
    {
        "content": "<p>What I envision wouldn’t add all possible instances, but would let you add only the instances you need when you need them.</p>",
        "id": 468439296,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725727909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Scaling.20commutative.20diagrams.2E/near/468397994\">said</a>:</p>\n<blockquote>\n<p>the <code>[[VectorSpace K V]]</code> notation</p>\n</blockquote>\n<p>Is there documentation about this notation? I haven't been able to find anything.</p>",
        "id": 468480535,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1725748197
    },
    {
        "content": "<p>It doesn't exist (yet?)</p>",
        "id": 468480904,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1725748322
    },
    {
        "content": "<p>It is <code>variable?</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">variable_alias</span><span class=\"kd\">]</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">VectorSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variable</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">VectorSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 468650639,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1725845866
    }
]