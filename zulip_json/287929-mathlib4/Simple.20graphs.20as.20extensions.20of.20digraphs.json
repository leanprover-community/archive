[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/16018\">#16018</a> I define a <code>Digraph</code> structure with only an <code>Adj</code> field and make <code>SimpleGraph</code> extend <code>Digraph</code>. But then I have to define aliases involving <code>Adj</code> in some places.</p>\n<p>What is the way to remove these aliases in a one-location way?</p>",
        "id": 463967205,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1724224949
    },
    {
        "content": "<p>It's hard. <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> had some work towards that (and I had a similar but different approach), but it currently gets stuck at multigraphs IIRC</p>",
        "id": 463967675,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724225140
    },
    {
        "content": "<p>In another thread I mentioned trying to port parts of Gonthier's 4CT Coq proof into Lean. He first defines hypermaps, which I have ported as structures with three <code>Perm</code>s.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A hypermap consists of three permutations `edge`, `node` and `face` of a dart type `D`</span>\n<span class=\"sd\">satisfying `edge * node * face = 1`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Hypermap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- \"Edge\" permutation on darts -/</span>\n<span class=\"w\">  </span><span class=\"n\">edge</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">D</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- \"Node\" permutation on darts -/</span>\n<span class=\"w\">  </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">D</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- \"Face\" permutation on darts -/</span>\n<span class=\"w\">  </span><span class=\"n\">face</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">D</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The three permutations compose to the identity -/</span>\n<span class=\"w\">  </span><span class=\"n\">enf_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">edge</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">face</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>Next he defines the <em>genus</em> of a hypermap by a formula involving the number of connected components of the graphs corresponding to each of the three <code>Perms</code>, <em>and their union</em></p>",
        "id": 463968843,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1724225545
    },
    {
        "content": "<p>Assume <code>Fintype D</code> (the Coq proof assumes this from the start) and treat the permutations as elements of the symmetric group on <code>D</code>. For a set <code>s</code> of elements of the symmetric group let <code>C</code> be the number of orbits of the group generated by <code>s</code>. Then the genus is <code>Fintype.card D + 2 * C {edge, node, face} - (C {edge} + C {node} + C {face})</code></p>",
        "id": 463970057,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1724225957
    },
    {
        "content": "<p>I am now massively stuck on trying to formalise the function <code>C</code> in an easy way</p>",
        "id": 463970771,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1724226091
    },
    {
        "content": "<p>(btw the whole proof is available at <a href=\"https://github.com/coq-community/fourcolor\">https://github.com/coq-community/fourcolor</a> and the basic definitions are in <a href=\"https://github.com/coq-community/fourcolor/blob/master/theories/hypermap.v\"><code>hypermap.v</code></a>)</p>",
        "id": 463971870,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1724226448
    },
    {
        "content": "<p>I'm thinking that digraphs are the way out of this conundrum, which is why I want to add them to mathlib</p>",
        "id": 463973792,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1724227044
    },
    {
        "content": "<p>because later on in <code>hypermap.v</code> this definition appears which crucially depends on <strong>directed paths</strong>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"w\">   </span><span class=\"n\">Moebius_path</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">&lt;=&gt;</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">Moebius</span><span class=\"w\"> </span><span class=\"n\">path</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">non</span><span class=\"bp\">-</span><span class=\"n\">trivial</span><span class=\"w\"> </span><span class=\"n\">uniq</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">-</span><span class=\"n\">path</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"w\">                 </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">additional</span><span class=\"w\"> </span><span class=\"s2\">\"cross\"</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"bp\">-</span><span class=\"n\">links</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\">     </span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"w\">                 </span><span class=\"n\">dart</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"n\">before</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"n\">dart</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\">      </span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"w\">                 </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mem2</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"w\">          </span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"c1\">--&gt; Equivalently, such a p can be described as a uniq contour cycle from x *)</span>\n<span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">closing</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"bp\">-</span><span class=\"n\">link</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">followed</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"s2\">\"cross-path\"</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">leaves</span><span class=\"w\">  </span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">cycle</span><span class=\"w\"> </span><span class=\"n\">through</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">-</span><span class=\"n\">link</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">face</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">returns</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">cycle</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">through</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"bp\">-</span><span class=\"n\">link</span><span class=\"bp\">.</span><span class=\"w\">                                                       </span><span class=\"bp\">*</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 463974221,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1724227119
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"598052\">Jeremy Tan</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Simple.20graphs.20as.20extensions.20of.20digraphs/near/463968843\">said</a>:</p>\n<blockquote>\n<p>In another thread I mentioned trying to port parts of Gonthier's 4CT Coq proof into Lean. He first defines hypermaps, which I have ported as structures with three <code>Perm</code>s.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A hypermap consists of three permutations `edge`, `node` and `face` of a dart type `D`</span>\n<span class=\"sd\">satisfying `edge * node * face = 1`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Hypermap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- \"Edge\" permutation on darts -/</span>\n<span class=\"w\">  </span><span class=\"n\">edge</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">D</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- \"Node\" permutation on darts -/</span>\n<span class=\"w\">  </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">D</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- \"Face\" permutation on darts -/</span>\n<span class=\"w\">  </span><span class=\"n\">face</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">D</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The three permutations compose to the identity -/</span>\n<span class=\"w\">  </span><span class=\"n\">enf_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">edge</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">face</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>Next he defines the <em>genus</em> of a hypermap by a formula involving the number of connected components of the graphs corresponding to each of the three <code>Perms</code>, <em>and their union</em></p>\n</blockquote>\n<p>I am currently working on bringing combinatorial maps to mathlib, I would love to collaborate on this, we are discussing this at <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths/topic/Combinatorial.20maps\">#maths &gt; Combinatorial maps</a> <br>\nI would like to have the ability to reason about infinite planar graphs, which the coq formalization doesn't cover.</p>",
        "id": 464081271,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1724252407
    },
    {
        "content": "<p>(sorry if this is off-topic but I wanted to mention it to avoid duplicating efforts)</p>",
        "id": 464081781,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1724252478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Simple.20graphs.20as.20extensions.20of.20digraphs/near/464081271\">said</a>:</p>\n<blockquote>\n<p>I would like to have the ability to reason about infinite planar graphs, which the coq formalization doesn't cover.</p>\n</blockquote>\n<p>Similarly here. It's important to have infinite planar graphs for the application Kalle and I have to statistical physics</p>",
        "id": 464083715,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724252762
    },
    {
        "content": "<p>For this function <code>C</code>, there ought to be some group theory developed somewhere for counting orbits. I'm not sure what digraphs would help you with.</p>",
        "id": 464123619,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724262581
    }
]