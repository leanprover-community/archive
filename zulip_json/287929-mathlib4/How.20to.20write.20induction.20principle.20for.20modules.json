[
    {
        "content": "<p>Suppose I proved this result:</p>\n<blockquote>\n<p>If <code>A</code> is a Noetherian ring and <code>M</code> is a finitely generated <code>A</code>-module, then there exists<br>\na chain of submodules <code>0 = M₀ ≤ M₁ ≤ M₂ ≤ ... ≤ Mₙ = M</code> of <code>M</code>, such that for each <code>0 ≤ i &lt; n</code>,<br>\n<code>Mᵢ / Mᵢ₋₁</code> is isomorphic to <code>A / pᵢ</code> for some prime ideal <code>pᵢ</code> of <code>A</code>.</p>\n</blockquote>\n<p>It gives the following induction principle: let <code>P</code> be a property for <code>A</code>-modules, such that</p>\n<ul>\n<li>it holds for zero module (it's formalized as it holds for any module which is subsingleton)</li>\n<li>it holds for <code>A / p</code> for every prime ideal <code>p</code> of <code>A</code> (to avoid universe problem, it's formalized as it holds for any module isomorphic to <code>A / p</code>)</li>\n<li>it is stable by short exact sequences</li>\n</ul>\n<p>Then <code>P</code> holds for <code>M</code> if <code>A</code> is Noetherian and <code>M</code> is finitely generated.</p>\n<p>I have the formalization of it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">IsNoetherianRing.induction_on_isQuotientEquivQuotientPrime</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsNoetherianRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module.Finite</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_subsingleton</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"o\">[</span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_quotient</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSpectrum</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_exact</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">N₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">N₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">N₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">N₂</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">N₂</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">N₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">N₃</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">N₃</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N₁</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">N₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N₂</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">N₃</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"n\">Function.Injective</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Function.Surjective</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Function.Exact</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">N₁</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">N₃</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">N₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- proof omitted</span>\n</code></pre></div>\n<p>My question is, how to make it work with <code>induction</code> tactics? For example, this result implies</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- There are only finitely many associated primes of a finitely generated module</span>\n<span class=\"sd\">over a Noetherian ring. -/</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">associatedPrimes.finite</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsNoetherianRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module.Finite</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">associatedPrimes</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"n\">IsNoetherianRing.induction_on_isQuotientEquivQuotientPrime</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"c1\">-- doesn't work</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But the <code>induction</code> tactic doesn't work. The <code>refine</code> works but I need to explicitly provide <code>P</code>.</p>\n<p>How do I rewrite the induction principle to make <code>induction</code> works?</p>",
        "id": 511873962,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744519943
    },
    {
        "content": "<p><del>Did you forget to add the <code>@[induction_eliminator]</code> attribute?</del> oh nvm, that's not what this question is about</p>",
        "id": 511882589,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744528121
    },
    {
        "content": "<p><del>i think the issue may be that you're basically writing an induction principle for <code>Type</code>, and so lean has a hard time figuring out which argument is which?</del></p>",
        "id": 511883178,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744528756
    },
    {
        "content": "<p>nope, not it either</p>",
        "id": 511884120,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744529729
    },
    {
        "content": "<p>ok, I think what basically happens is that lean just doesn't really do instance arguments to induction?</p>",
        "id": 511889403,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744534603
    },
    {
        "content": "<p>lean is complaining \"i have no clue how to find <code>[CommRing A]</code>\" because there is no explicit argument after it whose unification specifies it. For induction principles, as far as i can tell, lean only does unification, no instance synthesis</p>",
        "id": 511889521,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744534723
    },
    {
        "content": "<p>this is a result of how <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Meta/Tactic/ElimInfo.html#Lean.Meta.addImplicitTargets\">Lean.Meta.addImplicitTargets</a> is implemented</p>",
        "id": 511889539,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744534753
    },
    {
        "content": "<p>in the short term, i think you can change the <code>module A M</code> argument to explicit and supply the instance to <code>induction</code>, and that should work. In the long term, i think we can make a lean issue for this?</p>",
        "id": 511889960,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744535105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/How.20to.20write.20induction.20principle.20for.20modules/near/511889960\">said</a>:</p>\n<blockquote>\n<p>in the short term, i think you can change the <code>module A M</code> argument to explicit and supply the instance to <code>induction</code>, and that should work. In the long term, i think we can make a lean issue for this?</p>\n</blockquote>\n<p>Let me try if it works. But it sound extremely weird. Even if it works, I think I still prefer to instance variable version and use <code>refine</code> instead.</p>",
        "id": 511890243,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744535330
    },
    {
        "content": "<p>well... in a sense, you really are doing induction on the module structure, so writing something like <code>induction ‹Module A M›</code> is not completely nonsensical</p>",
        "id": 511890396,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744535478
    },
    {
        "content": "<p>to make that work, you need to make <code>M</code> a lazy implicit argument and the <code>Module A M</code> argument explicit</p>",
        "id": 511890478,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744535541
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Like So</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>import Mathlib\n\n@[elab_as_elim]\ntheorem IsNoetherianRing.induction_on_isQuotientEquivQuotientPrime\n    (A : Type u) [ha1:CommRing A] [ha2: IsNoetherianRing A]\n    ⦃M : Type v⦄ [AddCommGroup M] (_:Module A M)\n    {P : (N : Type v) → [AddCommGroup N] → [Module A N] → Prop}\n    (h_subsingleton : (N : Type v) → [AddCommGroup N] → [Module A N] →\n      [Subsingleton N] → P N)\n    (h_quotient : (N : Type v) → [AddCommGroup N] → [Module A N] →\n      (p : PrimeSpectrum A) → (N ≃ₗ[A] A ⧸ p.1) → P N)\n    (h_exact : (N₁ : Type v) → [AddCommGroup N₁] → [Module A N₁] →\n      (N₂ : Type v) → [AddCommGroup N₂] → [Module A N₂] →\n      (N₃ : Type v) → [AddCommGroup N₃] → [Module A N₃] →\n      (f : N₁ →ₗ[A] N₂) → (g : N₂ →ₗ[A] N₃) →\n      Function.Injective f → Function.Surjective g → Function.Exact f g →\n      P N₁ → P N₃ → P N₂) : P M := by\n  sorry -- proof omitted\n\n/-- There are only finitely many associated primes of a finitely generated module\nover a Noetherian ring. -/\ntheorem associatedPrimes.finite\n    (A : Type u) [CommRing A] [IsNoetherianRing A]\n    (M : Type v) [AddCommGroup M] [Module A M] [Module.Finite A M] :\n    (associatedPrimes A M).Finite := by\n  -- let foo := @IsNoetherianRing.induction_on_isQuotientEquivQuotientPrime A _ _\n  induction ‹Module A M› using IsNoetherianRing.induction_on_isQuotientEquivQuotientPrime A\n  · sorry\n  · sorry\n  · sorry\n</code></pre></div>\n</div></div>",
        "id": 511890494,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744535563
    },
    {
        "content": "<p>apparently, there already is an issue for this: <a href=\"https://github.com/leanprover/lean4/pull/4246\">lean4#4246</a></p>",
        "id": 511890794,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744535789
    },
    {
        "content": "<p>i've added a comment to the issue mentioning you ran into this today. If you think this is important, do thumbs up the issue</p>",
        "id": 511891302,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744536204
    },
    {
        "content": "<p>aside from this issue, if you are planning on PRing the induction principle in mathlib, the <code>P</code> argument should be called <code>motive</code></p>",
        "id": 511891652,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744536483
    },
    {
        "content": "<p>Thank you! Your writing make it works! So if I understand correctly, the induction variable is the <em>last</em> property of <code>M</code> I need to use? In this case it is <code>Module A M</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">IsNoetherianRing.induction_on_isQuotientEquivQuotientPrime</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsNoetherianRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">⦃</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module.Finite</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_subsingleton</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"o\">[</span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_quotient</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSpectrum</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h_exact</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">N₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">N₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">N₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">N₂</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">N₂</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">N₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">N₃</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">N₃</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N₁</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">N₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N₂</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">N₃</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"n\">Function.Injective</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Function.Surjective</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Function.Exact</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">N₁</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">N₃</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">N₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- There are only finitely many associated primes of a finitely generated module</span>\n<span class=\"sd\">over a Noetherian ring. -/</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">associatedPrimes.finite</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsNoetherianRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module.Finite</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">associatedPrimes</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"o\">‹</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">›</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"n\">IsNoetherianRing.induction_on_isQuotientEquivQuotientPrime</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h_subsingleton</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">associatedPrimes.eq_empty_of_subsingleton</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h_quotient</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h_exact</span><span class=\"w\"> </span><span class=\"n\">N₁</span><span class=\"w\"> </span><span class=\"n\">N₂</span><span class=\"w\"> </span><span class=\"n\">N₃</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"n\">hfg</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"n\">h₃</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 511892053,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744536846
    },
    {
        "content": "<p>Or should I say the induction variable is the <em>last</em> arguments in <code>P</code>?<br>\nIt turns out that the last property I need to use is <code>Module.Finite A M</code>. So I changed a little and it still works. The syntax is very counter-intuitive, though, in this case one needs to do induction on a <code>Prop</code>! <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 511892520,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744537304
    },
    {
        "content": "<p>arguments which get used as arguments to <code>P</code> in the result type of your induction principle are called targets. the values you pass to <code>induction</code> are the values of the targets which are explicit parameters in the induction principle, in the order they occur in in the principle. the other values for the targets are found via unification. In this case, the parameters <code>⦃M : Type v⦄</code>, <code>[AddCommGroup M]</code> and <code>(_ : Module A M)</code> are targets. Of those, we made only <code>_ : Module A M</code> explicit, so that's the only value you need to supply to <code>induction</code>. the other values are figured out by unification, since both of those arguments are arguments to <code>Module</code></p>",
        "id": 511892710,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744537453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/How.20to.20write.20induction.20principle.20for.20modules/near/511891652\">said</a>:</p>\n<blockquote>\n<p>aside from this issue, if you are planning on PRing the induction principle in mathlib, the <code>P</code> argument should be called <code>motive</code></p>\n</blockquote>\n<p>I see. I've checked <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.strong_induction_on#doc\">docs#Nat.strong_induction_on</a> and it's called <code>P</code> so I also call it <code>P</code>.</p>",
        "id": 511892713,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744537455
    },
    {
        "content": "<p>the <a href=\"https://leanprover-community.github.io/contribute/naming.html#induction-and-recursion-principles\">naming conventions</a> say they should be called <code>motive</code></p>",
        "id": 511892726,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744537484
    },
    {
        "content": "<p>and i think someone is working on making sure induction principles follow this convention</p>",
        "id": 511892747,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1744537510
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/How.20to.20write.20induction.20principle.20for.20modules/near/511892710\">said</a>:</p>\n<blockquote>\n<p>arguments which get used as arguments to <code>P</code> in the result type of your induction principle are called targets. the values you pass to <code>induction</code> are the values of the targets which are explicit parameters in the induction principle, in the order they occur in in the principle. the other values for the targets are found via unification. In this case, the parameters <code>⦃M : Type v⦄</code>, <code>[AddCommGroup M]</code> and <code>(_ : Module A M)</code> are targets. Of those, we made only <code>_ : Module A M</code> explicit, so that's the only value you need to supply to <code>induction</code>. the other values are figured out by unification, since both of those arguments are arguments to <code>Module</code></p>\n</blockquote>\n<p>Thank you! It's clear.</p>\n<p>The docstring for <code>induction</code> does not mention the syntax for induction on several variables. So I tried it a little bit:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">test33</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stupid</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">stupid</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">37</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"n\">test33</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">stupid</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 511893348,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744538138
    },
    {
        "content": "<p>This would be much less cumbersome if you used <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ModuleCat#doc\">docs#ModuleCat</a></p>",
        "id": 511908598,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744551020
    },
    {
        "content": "<p>I see you can't take <code>N</code> to be <code>A ⧸ p.1</code> in <code>h_quotient</code> due to universe reason, but I don't see why you don't just take <code>N₁</code> to be a submodule of <code>N₂ </code> and <code>N₃</code> the quotient module in <code>h_exact</code>.<br>\n(BTW I added some analogous induction principles <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/HopkinsLevitzki.html#IsSemiprimaryRing.induction\">IsSemiprimaryRing.induction</a> and <code>IsFiniteLength.rec</code>.)</p>",
        "id": 513275096,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1745156237
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/How.20to.20write.20induction.20principle.20for.20modules/near/513275096\">said</a>:</p>\n<blockquote>\n<p>but I don't see why you don't just take <code>N₁</code> to be a submodule of <code>N₂</code> and <code>N₃</code> the quotient module in <code>h_exact</code></p>\n</blockquote>\n<p>That's a good point. In my original design I'm paranoid by the typeclass inference problems. Let me try if it works.</p>",
        "id": 513279534,
        "sender_full_name": "Jz Pan",
        "timestamp": 1745159662
    },
    {
        "content": "<p>Ahh, because I'm cheating <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> <code>h_subsingleton</code> + <code>h_exact</code> implies <code>h_equiv</code> which means that <code>LinearEquiv</code> transfers the property <code>P</code>. If I rephrase <code>h_exact</code> as submodule and quotient, then it cannot imply <code>h_equiv</code> anymore...</p>",
        "id": 513282969,
        "sender_full_name": "Jz Pan",
        "timestamp": 1745162460
    },
    {
        "content": "<p>I see, <a href=\"https://github.com/acmepjz/lean-iwasawa/blob/29e6cdc368656d792217bf779d3dcbc01332b084/Iwasawalib/RingTheory/CharacteristicIdeal/Basic.lean#L151-L201\">the proof</a> does require the <code>h_equiv</code>. Without <code>h_equiv</code>, we would need to construct a chain of submodule of submodule ... down to the zero module in order to use the submodule/quotient module condition.</p>\n<p>One solution to this issue could be the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">Map</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">RelSeries</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"bp\">.</span><span class=\"n\">subtype</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RelSeries</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h_head</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h_last</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">subsingleton</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">induction_left</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">),</span>\n<span class=\"w\">      </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">induction_right</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">),</span>\n<span class=\"w\">      </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Note that I require <code>P</code> (<code>N ≃ₗ[A] A ⧸ p.1</code> in your case) to be stable under isomorphisms but not <code>motive</code>.<br>\nI think they can be proven by induction on the length of the RelSeries. If it's of length n+1, you can get a RelSeries of length n from 0 to the n-th term, and another one from the 1st term to M.</p>",
        "id": 513488024,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1745280063
    },
    {
        "content": "<p>Couldn't you ask to prove <code>motive M -&gt; motive N</code> if there is a linear equivalence from <code>M</code> to <code>N</code> ?</p>",
        "id": 513506085,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1745291636
    },
    {
        "content": "<blockquote>\n<p>if you are planning on PRing the induction principle in mathlib, the <code>P</code> argument should be called <code>motive</code></p>\n</blockquote>\n<p>PR created as <a href=\"https://github.com/leanprover-community/mathlib4/pull/24242\">#24242</a>, coauthored by <span class=\"user-mention\" data-user-id=\"749361\">@Nailin Guan</span></p>",
        "id": 513520099,
        "sender_full_name": "Jz Pan",
        "timestamp": 1745299913
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/channel/287929-mathlib4/topic/How.20to.20write.20induction.20principle.20for.20modules/near/513506085\">said</a>:</p>\n<blockquote>\n<p>Couldn't you ask to prove <code>motive M -&gt; motive N</code> if there is a linear equivalence from <code>M</code> to <code>N</code> ?</p>\n</blockquote>\n<p>Yes, it's natural to ask the user to prove <code>h_subsingleton</code>, <code>h_quotient</code>, <code>h_equiv</code> and <code>h_exact</code>. I just mean that under current design of <code>h_exact</code>, the <code>h_equiv</code> could be derived from <code>h_subsingleton</code> and <code>h_exact</code>.</p>",
        "id": 513520657,
        "sender_full_name": "Jz Pan",
        "timestamp": 1745300219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/How.20to.20write.20induction.20principle.20for.20modules/near/513488024\">said</a>:</p>\n<blockquote>\n<p>One solution to this issue could be the following</p>\n</blockquote>\n<p>Interesting. Let me see what does it mean. First we have a property <code>P</code> on modules which is stable under isomorphisms (<code>P M → P N</code> is harmless since we can use <code>LinearEquiv.symm</code> to get another direction).<br>\nWe have <code>0 = M₀ ≤ M₁ ≤ M₂ ≤ ... ≤ Mₙ = M</code>, such that for each <code>i</code>, <code>Mᵢ / Mᵢ₋₁</code> satisfies property <code>P</code>.<br>\n(So in our application <code>P</code> is being isomorphic to <code>A / p</code> for some <code>p</code>.)<br>\nWe also have a property <code>motive</code> which holds for zero modules... OK.</p>",
        "id": 513522129,
        "sender_full_name": "Jz Pan",
        "timestamp": 1745301042
    }
]