[
    {
        "content": "<p>I've got a structure S that's \"ugly\": it's a commutative additive and multiplicative monoid, it's MulZeroOneClass, but it doesn't distribute. Sad! Well, I've got an injective function from the reals into S, and it preserves addition, mutiplication, zero and one. (It's a <code>ZeroHom</code>, <code>OneHom</code>, <code>AddHom</code>, and <code>MulHom</code>). I thought I would state this function as a <code>RingHom</code>, naturally.</p>\n<p>But <code>RingHom</code> requires that both the input and output structures are <code>NonAssocSemiring</code>, sadly. This means I can't use it. I've jerry-rigged the following definition, but I don't like it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MinimalRing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">AddZeroClass</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">MulZeroOneClass</span><span class=\"w\"> </span><span class=\"n\">Î²</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NonAssocSemiring</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MinimalRing</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MinimalRingHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MinimalRing</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MinimalRing</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n<span class=\"w\">  </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’*</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’+</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’â‚™*</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’*â‚€</span><span class=\"w\"> </span><span class=\"n\">Î²</span>\n</code></pre></div>\n<p>I then made the appropriate <code>MinimalRingHomClass</code>, and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">MinimalRingHomClass</span><span class=\"bp\">.</span><span class=\"n\">toRingHomClass</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NonAssocSemiring</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NonAssocSemiring</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">MinimalRingHomClass</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RingHomClass</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"n\">Î²</span>\n</code></pre></div>\n<p>and instance of <code>MinimalRing</code> for my structure of interest.</p>\n<p>This gets me ... some stuff. But it's a mess and I'm wondering if there's something I should be doing differently.</p>",
        "id": 534769168,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755358203
    },
    {
        "content": "<p>A few questions:</p>\n<ul>\n<li>Why does ring hom list all four of <code>Î± â†’* Î², Î± â†’+ Î², Î± â†’â‚™* Î², Î± â†’*â‚€ Î²</code>? Isn't this highly redundant? What benefits does it have, and do I need to do that too?</li>\n<li>I could give my structure S a <code>Module Real S</code> structure, this part does work out. Then I guess my map would be a <code>LinearMap</code>, but that wouldn't say anything about multiplicative structure.</li>\n<li>I could define <code>MulSemiringAction</code>, but I also don't know if that gets me anything better.</li>\n</ul>",
        "id": 534769292,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755358331
    },
    {
        "content": "<p>(to be clear: this is not a project that I intend to try to PR to mathlib. it's a question about how/why Mathlib defines RingHom's this way, and how I should best use it.)</p>",
        "id": 534769303,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755358354
    },
    {
        "content": "<p>\"why\" is probably \"because nobody considered such exotic setups\" :)</p>",
        "id": 534771225,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1755360443
    },
    {
        "content": "<p>Sure. :) But I guess my question amounts to something more basic, like... in the definition</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MonoidHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_10</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_11</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulOneClass</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulOneClass</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">OneHom</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">â†’â‚™*</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u_10</span><span class=\"w\"> </span><span class=\"n\">u_11</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I see no reason _why_ there should be a <code>MulOneClass</code> in the definition. I mean, it makes it a \"Monoid\" Hom, but not just a \"MulOneHom\"? It should then be theorems that require the assumption <code>MulOneClass</code>. They need to assume it anyway to be able to talk about a MonoidHom.</p>\n<p>It seems as though a RingHom should (in principle) only require <code>[Add M] [Mul M] [Zero M] [One M]</code> (and likewise for <code>N</code>), and then relevant theorems use the relevant properties. Right?</p>",
        "id": 534771424,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755360646
    },
    {
        "content": "<p>My questions would be: does that actually give you a meaningful improvement? That is, are there more than about three lemmas that are true without the stronger assumptions? And would this cause a noticeable showdown? (Not saying that it would, but the kind of change that would make me nervous)</p>",
        "id": 534771599,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1755360825
    },
    {
        "content": "<p>As an example of some things that could be relaxed...</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Nat/Cast/Basic.html#Nat.uniqueRingHom\">Nat.uniqueRingHom</a> could change from <code>{R : Type u_3} [NonAssocSemiring R] : Unique (â„• â†’+* R)</code> to <code>{R : Type u_3} [AddMonoidWith R] [Mul R] : Unique (â„• â†’+* R)</code></li>\n<li>Similary for <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Int/Cast/Lemmas.html#Int.castRingHom\">Int.castRingHom</a></li>\n<li>Appropriate versions of <code>map_sub</code>, <code>map_neg</code>, <code>map_inv</code> can be derived with other moderate assumptions on the input and output types (that are not quite immediate otherwise). Having these be @simp-able would be nice.</li>\n<li>You get the ability to do <code>.comp</code>, most of the stuff about injectivity / surjectivity still holds.</li>\n<li>Most of the theory of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/Ideal/Maps.html#RingHom.ker\">RingHom.ker</a> works fine anyway, you get some ideal structure on the domain even if the codomain is ugly</li>\n</ul>",
        "id": 534772240,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755361624
    },
    {
        "content": "<p>I have no idea about slowdowns, I have no sense for such things. (Trying to learn!)</p>",
        "id": 534772258,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755361640
    },
    {
        "content": "<p>See <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/two-sided.20ideals/near/482237813\">#mathlib4 &gt; two-sided ideals @ ðŸ’¬</a> for slowdown caused by relaxing MulAction and Module. The issue is blocking some PRs.</p>",
        "id": 534772831,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1755362316
    },
    {
        "content": "<p>That is a very and complicated thread xD oh no</p>",
        "id": 534825247,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755438930
    },
    {
        "content": "<p>It seems like this choice dates back to 2020 in mathlib3: <a href=\"https://github.com/leanprover-community/mathlib3/commit/4f75760089a9a13cdeeca4a26353f93340e0e987\">https://github.com/leanprover-community/mathlib3/commit/4f75760089a9a13cdeeca4a26353f93340e0e987</a><br>\nFirst, there was <code>add_monoid_hom</code>, which only acted on <code>add_monoid</code>s. Understandable. That PR split it into <code>add_hom</code> and <code>zero_hom</code>, but then it was required that an <code>add_monoid_hom</code> actually required it to be an <code>add_monoid</code>.</p>\n<p>Then in <a href=\"https://github.com/leanprover-community/mathlib3/commit/5f1b4500f21b62968aad9bd939625cdf2b2372a6\">https://github.com/leanprover-community/mathlib3/commit/5f1b4500f21b62968aad9bd939625cdf2b2372a6</a> it was changed from <br>\n<code>structure add_monoid_hom (M : Type*) (N : Type*) [add_monoid M] [add_monoid N] extends zero_hom M N, add_hom M N</code><br>\nto<br>\n<code>structure add_monoid_hom (M : Type*) (N : Type*) [add_zero_class M] [add_zero_class N] extends zero_hom M N, add_hom M N</code> when the <code>add_zero_class</code> was introduced, relaxing associativity.</p>",
        "id": 534825748,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755439441
    },
    {
        "content": "<p>This was then preserved when it was ported: <a href=\"https://github.com/leanprover-community/mathlib4/pull/659\">https://github.com/leanprover-community/mathlib4/pull/659</a></p>",
        "id": 534825780,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755439478
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <span class=\"user-mention\" data-user-id=\"416472\">@Winston Yin (å°¹ç¶­æ™¨)</span> is there a reason not to simply have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">AddMonoidHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">ZeroHom</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddHom</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span>\n</code></pre></div>\n<p>dropping <code>AddZeroClass</code> assumptions? So that it simply states that it preserves the additive and zero structure, which is all this object itself is really doing. All downstream theorems should continue to just work, since they have all the necessary assumptions anyway; then slowly assumptions on those can be relaxed where appropriate.</p>\n<p>(And similar questions for MonoidHom, MonoidWithZeroHom, NonUnitalRingHom, and RingHom.)</p>",
        "id": 534826095,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755439775
    },
    {
        "content": "<p>Just brainstorming for a sec, not too seriously here -- out of 2^4-1 = 15 different combinations of +*01 that we can have, there are homs for 9 combinations of these. The missing six would be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">+*</span><span class=\"w\"> </span><span class=\"c1\">-- pretty weird</span>\n<span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- ?? PNatCastHom ??</span>\n<span class=\"bp\">*</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- MulZeroHom</span>\n<span class=\"mi\">01</span><span class=\"w\"> </span><span class=\"c1\">-- pretty weird</span>\n<span class=\"bp\">+*</span><span class=\"mi\">1</span><span class=\"w\">  </span><span class=\"c1\">-- pretty weird</span>\n<span class=\"bp\">+</span><span class=\"mi\">01</span><span class=\"w\"> </span><span class=\"c1\">-- AddMonoidWithOneHom</span>\n</code></pre></div>\n<p>I think <code>AddMonoidWithOneHom</code> could maybe merit existing but the others have no reason</p>",
        "id": 534826682,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755440344
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/stream/287929-mathlib4/topic/RingHom.20for.20not-a-ring/near/534826095\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <span class=\"user-mention silent\" data-user-id=\"416472\">Winston Yin (å°¹ç¶­æ™¨)</span> is there a reason not to simply have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">AddMonoidHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">ZeroHom</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddHom</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span>\n</code></pre></div>\n<p>dropping <code>AddZeroClass</code> assumptions? So that it simply states that it preserves the additive and zero structure, which is all this object itself is really doing.</p>\n</blockquote>\n<p>This has twice as many typeclass arguments so the terms are twice as big</p>",
        "id": 534851959,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755472068
    },
    {
        "content": "<p>Try instantiating with <code>NormedField M</code> and see how the two explicit terms compare</p>",
        "id": 534852028,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755472180
    },
    {
        "content": "<p>If you're lucky you get some common subterm elimination, but I don't think there's any guarantee of common subterms appearing.</p>",
        "id": 534852068,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755472225
    },
    {
        "content": "<p>I tried a version where I split out an <code>AddZero</code> class which carries the Add / Zero data. Changes needed to make things work were minimal, and benchmarks improved if anything:</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/28702\">https://github.com/leanprover-community/mathlib4/pull/28702</a></p>",
        "id": 535876222,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756003735
    },
    {
        "content": "<p>Yes, I would expect that to avoid the performance issue</p>",
        "id": 535879965,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756009984
    },
    {
        "content": "<p>Looks like the overall effect is build +0.331%, lint +0.507%, though there's known benchmark noisiness at the moment. (Also benchmark summary stopped working again?)<br>\n<a href=\"/user_uploads/3121/XwUwb2WRynDmr0V_I8F1Zyzv/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/XwUwb2WRynDmr0V_I8F1Zyzv/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1289x918\" src=\"/user_uploads/thumbnail/3121/XwUwb2WRynDmr0V_I8F1Zyzv/image.png/840x560.webp\"></a></div>",
        "id": 535903559,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1756043249
    },
    {
        "content": "<p>Instead of introducing AddZero, why don't you just use <code>[Add _] [Zero _]</code>?</p>",
        "id": 535903648,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1756043360
    },
    {
        "content": "<p>For the reason Eric mentioned above - that then the types of any <code>AddMonoidHom</code> are twice as long, because you need two separate typeclasses to be inferred</p>",
        "id": 535904279,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756044131
    },
    {
        "content": "<p>I'd be interested to see what the performance drop is for that case</p>",
        "id": 535912368,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756053287
    },
    {
        "content": "<p>As in, if it's small enough, we do that instead, to avoid the (maintainability) overhead of <code>AddZero</code>?</p>",
        "id": 535913900,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756055116
    },
    {
        "content": "<p>Some thought experiment breaking <code>Semiring R</code> down to \"atomic\" classes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddZeroClass</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Commutative</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Associative</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompatibleNSMul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulOneClass</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Associative</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">Pow</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompatibleNPow</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompatibleNatCast</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">MulZeroClass</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LeftDistribClass</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">RightDistribClass</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>AddZeroClass, MulZeroClass, MulOneClass need to be \"unbundled\" and takes Add, Zero, Mul, One instances<br>\nCompatibleNSMul takes SMul Nat, Add, Zero<br>\nCompatibleNatCast takes NatCast, Add, Zero, One<br>\nCompatibleNPow takes Pow _ Nat, Mul, One</p>\n<p>and I'd also be interested to see the performance impact ...</p>",
        "id": 535918984,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1756061001
    },
    {
        "content": "<p>If I am new to mathlib and I see these instead of [Ring R] I might panic</p>",
        "id": 535919111,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1756061110
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873350\">Weiyi Wang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/RingHom.20for.20not-a-ring/near/535919111\">said</a>:</p>\n<blockquote>\n<p>If I am new to mathlib and I see these instead of [Ring R] I might panic</p>\n</blockquote>\n<p>This is the main reason why this hasn't been done</p>",
        "id": 535919280,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756061272
    },
    {
        "content": "<p>I think there are talks to introduce something to expand <code>Ring R</code> to such a sequence of instance variable declarations. I think it's when people complained that sheafification similarly requires a long sequence of instances.</p>",
        "id": 535919298,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1756061286
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/RingHom.20for.20not-a-ring/near/535918984\">said</a>:</p>\n<blockquote>\n<p>and I'd also be interested to see the performance impact ...</p>\n</blockquote>\n<p>Based on what happened with unbundling ordered algebra I think the performance impact would be immense</p>",
        "id": 535919448,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756061447
    },
    {
        "content": "<p>Oh, it's called a macro. See <a class=\"message-link\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/pushforward.2Fpullback.20of.20sheaves/near/310409078\">#Is there code for X? &gt; pushforward/pullback of sheaves @ ðŸ’¬</a></p>",
        "id": 535919449,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1756061448
    },
    {
        "content": "<p>In general there could always be separate \"data\" classes and \"prop\" classes.</p>\n<p>e.g. for semirings you have <br>\n<code>class SemiringData T extends MulOne T, AddZero T, NatCast T, NatSMul T, NatPow T</code>. Realistically, that would be grouped together a bit more so something like<br>\n<code>extends MonoidData T, AddMonoidData T</code>.</p>\n<p>And then <code>class Semiring</code> is the mixin providing all appropriate axioms, and would look similar to the current definition of semiring (e.g. extending NonUnitalSemiring, NonAssocSemiring, MulOneClass)</p>",
        "id": 535922781,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756065219
    },
    {
        "content": "<p>This would be kind of extreme though..</p>",
        "id": 535922808,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756065256
    },
    {
        "content": "<p>In my opinion NatCast, NatSMul, NatPow are inessential data and should be unbundled. Similarly I'd like to see TopologicalSpace unbundled from UniformSpace, etc.</p>",
        "id": 535922922,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1756065440
    },
    {
        "content": "<p>If you don't require defeq for those fields and only require them to be compatible, it makes the job much easier to introduce PNatPow for Semigroup, for example.</p>",
        "id": 535923008,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1756065519
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/RingHom.20for.20not-a-ring/near/535919448\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/RingHom.20for.20not-a-ring/near/535918984\">said</a>:</p>\n<blockquote>\n<p>and I'd also be interested to see the performance impact ...</p>\n</blockquote>\n<p>Based on what happened with unbundling ordered algebra I think the performance impact would be immense</p>\n</blockquote>\n<p>Immense in which direction?</p>",
        "id": 535931712,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1756076288
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/stream/287929-mathlib4/topic/RingHom.20for.20not-a-ring/near/535913900\">said</a>:</p>\n<blockquote>\n<p>As in, if it's small enough, we do that instead, to avoid the (maintainability) overhead of <code>AddZero</code>?</p>\n</blockquote>\n<p>No, rather so that when it's large we can write down why we needed to use the approach you chose.</p>",
        "id": 535932172,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756076745
    },
    {
        "content": "<p>Finished running the comparison. The performance hit from having Add/Zero synthesized separately is, as expected, pretty bad. <a href=\"https://github.com/leanprover-community/mathlib4/pull/28889/\">https://github.com/leanprover-community/mathlib4/pull/28889/</a></p>",
        "id": 536625010,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756392792
    },
    {
        "content": "<p>Wait, why was this expected to have pretty bad performance?</p>",
        "id": 537051698,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1756712964
    },
    {
        "content": "<p>Because of the larger terms, and the fact that TC search has to run more</p>",
        "id": 537054530,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756713676
    },
    {
        "content": "<p>But we also expect the TC search to be much simpler... but maybe that pay-off only becomes apparent when a lot more of the hierarchy has been unbundled?</p>",
        "id": 537073321,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1756719990
    },
    {
        "content": "<p>The TC search will only be simpler for concrete types</p>",
        "id": 537074319,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756720331
    },
    {
        "content": "<p>Right now the issue is a theorem assuming <code>[NormedField X]</code> has to walk all the way down to <code>Zero X</code> and <code>Add X</code>, and cannot necessarily share any of its progress when doing so</p>",
        "id": 537074490,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756720391
    },
    {
        "content": "<p>Unbundling can help a little, but you're still probably in trouble when you need to define <code>Add (Foo X)</code> you need <code>IsNormedField X</code></p>",
        "id": 537076002,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756720942
    },
    {
        "content": "<p>Right, but that is quite uncommon.</p>",
        "id": 537076226,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1756721030
    },
    {
        "content": "<p>For quotient types it's pretty common I think</p>",
        "id": 537077795,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756721612
    },
    {
        "content": "<p>There is (for example) 1145 hits on Loogle for theorem statements that involve <code>Add (Prod _ _)</code>, so I think this kind of thing is fairly common.</p>\n<p><a href=\"https://loogle.lean-lang.org/?q=%28_+%3A+Prod+_+_%29+%2B+_\">https://loogle.lean-lang.org/?q=%28_+%3A+Prod+_+_%29+%2B+_</a></p>",
        "id": 537140047,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756743560
    },
    {
        "content": "<p>is <a href=\"https://github.com/leanprover-community/mathlib4/pull/28702\">#28702</a> something we could consider merging then?</p>",
        "id": 537140092,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756743583
    },
    {
        "content": "<p>Not without  a PR description explaining what it does and why it is a good ida</p>",
        "id": 537144783,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756745478
    },
    {
        "content": "<p>Oops, yes haha. Alrighty, there ya go</p>",
        "id": 537145459,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756745855
    }
]