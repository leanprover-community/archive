[
    {
        "content": "<p>Following the <a href=\"#narrow/channel/113489-new-members/topic/Why.20is.20the.20codomain.20of.20PMF.20in.20mathlib.20ENNReal.20and.20not.20NNReal\">discussion</a> on the awkwardness of <code>ENNReal</code> arithmetic in <code>PMF</code> (and <span class=\"user-mention\" data-user-id=\"282271\">@Bolton Bailey</span>'s recent WIP PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/33689\">#33689</a>), I'd like to revisit the design choice for Probability Mass Functions.</p>\n<p>Currently, we have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"bp\">‚â•</span><span class=\"mi\">0</span><span class=\"bp\">‚àû</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>As noted in the chat, this causes friction when trying perform standard arithmetic, even though we know the values are always finite.</p>\n<p>There seem to be three paths forward:</p>\n<p><strong>1. Status Quo (<code>ENNReal</code>)</strong></p>\n<ul>\n<li><strong>Pros:</strong> Sums always exist.</li>\n<li><strong>Cons:</strong> Arithmetic is painful.</li>\n</ul>\n<p><strong>2. Change the <code>FunLike</code> instance (Bolton's PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/33689\">#33689</a>)</strong><br>\nKeep the internal definition as <code>ENNReal</code>, but change the <code>FunLike</code> instance to return <code>NNReal</code>.</p>\n<ul>\n<li><strong>Pros:</strong> Improves the user experience for evaluation (<code>p x</code> returns a nice <code>NNReal</code>) without changing the underlying storage.</li>\n<li><strong>Cons:</strong> It creates a disconnect between the internal representation (<code>ENNReal</code>) and the interface (<code>NNReal</code>)..</li>\n</ul>\n<p><strong>3. Change the definition to <code>NNReal</code></strong><br>\nRefactor the type entirely:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"bp\">‚â•</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<ul>\n<li><strong>Pros:</strong> The type accurately reflects that probabilities are finite. <code>NNReal</code> makes doing standard arithmetic nicer.</li>\n<li><strong>Cons:</strong> We lose the \"sums always exist\" convenience.</li>\n</ul>\n<p><strong>Question for the community:</strong><br>\nIs the convenience of <code>ENNReal</code> summation worth the friction in arithmetic? It seems the summability burden is largely an internal implementation detail (e.g., inside <code>bind</code>), whereas the arithmetic friction is a recurring tax on every user. It feels better to pay the cost of convergence proofs once in the library structure than to force every user to deal with <code>ENNReal</code> casting.</p>\n<p>I am leaning towards <strong>Option 3</strong>, as it aligns better with the mathematical definition of a discrete probability distribution, but I would appreciate insights on whether this is the way to do it. To test things out, I rewrote <code>ProbabilityMassFunction.Basic</code> with <code>PMF</code> defined as <code>NNReal</code> valued, and it ended up taking slightly fewer lines of code than the original version. The <code>ProbabilityMassFunction.Monad</code> might be a bit trickier though.</p>",
        "id": 567504623,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1768216980
    },
    {
        "content": "<p>I might actually suggest/change my PR to a fourth option, to use a more specialized type like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=unitInterval#doc\">docs#unitInterval</a>. It seems like if we are going to change the return type to a subtype of the reals, it ought to be the subtype which consists of exactly those values it is possible for it to return. Perhaps this would make it more convenient to deal with inequalities, but I don't know how much harder it would make the algebra.</p>",
        "id": 567505746,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1768217307
    },
    {
        "content": "<p>The initial definition was in terms of NNReal functions, and it's after a lot of gained experience in this context that we decided to switch to ENNReal (see <a href=\"https://github.com/leanprover-community/mathlib3/pull/17032\">https://github.com/leanprover-community/mathlib3/pull/17032</a>). Since it was a deliberate and thought-through move, I'm not sure it's a good idea to undo it.</p>",
        "id": 567514140,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1768219684
    },
    {
        "content": "<p>Discussion at <a href=\"#narrow/channel/116395-maths/topic/.60nnreal.60.20vs.2E.20.60ennreal.60.20in.20.60pmf.60/near/303518183\">#maths &gt; &#96;nnreal&#96; vs. &#96;ennreal&#96; in &#96;pmf&#96; @ üí¨</a></p>",
        "id": 567514363,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1768219755
    },
    {
        "content": "<p>I think that I would like to see more evidence of \"arithmetic is painful\". I'd like to check that this doesn't actually mean \"arithmetic is painful if you don't know the tricks\" or \"arithmetic is painful because there is a specific tactic which would solve everything and which we don't have\" (so another potential path forward might be a concrete specification of a tactic, followed by an implementation of that tactic). Can we see some concrete examples of this pain? My understanding of tactic-writing to alleviate pain is that a good way to start is to have 5 or more self-contained examples of goals which are currently painful and should ideally be one- or two-liners if the appropriate tactic existed.</p>",
        "id": 567522128,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768221915
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> Thanks for the context. I am curious to dig a bit deeper into the \"why\" of the original switch.</p>\n<p>Is the \"summability burden\" of <code>NNReal</code> primarily an issue when <em>constructing</em> the library (e.g., proving <code>bind</code> and <code>map</code> are well-defined), or does it leak out to the end-user frequently?</p>\n<p>My current intuition is that it feels better to be diligent with summability proofs once (at the implementation level) if it guarantees the user a clean <code>NNReal</code> interface forever after. But perhaps I am missing cases where <code>summability</code> becomes a constant headache for the user as well?</p>",
        "id": 567542610,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1768226709
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I admit I don't have 5 concrete snippets ready to go‚Äîmy motivation is more that to me, a PMF taking values in <code>ENNReal</code> just feels like it is <em>lacking in moral fibre</em>. Not the best justification, I suppose... </p>\n<p>Regarding the tactic argument, I wonder if we could flip it? If the downside is proving summability, couldn't we just have a <code>summability</code> tactic? It seems cleaner to fix the definitions (<code>NNReal</code>) and automate the convergence proofs, rather than keep a \"loose\" definition (<code>ENNReal</code>) and try to build tactics to retrofit standard arithmetic onto a type designed to handle infinity.</p>",
        "id": 567542761,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1768226739
    },
    {
        "content": "<p>I have never used PMFs myself, so I can't really comment on the original motivation. But as far as I understand concrete manipulations of PMFs need summability checks all the time, not just the API construction, if I read the original thread correctly.</p>",
        "id": 567545345,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1768227321
    },
    {
        "content": "<p>That is a fair concern. Though, I suspect most of those summability checks arise from jumping from <code>HasSum</code> to <code>tsum</code> too quickly. If one stayed in <code>HasSum</code> during concrete manipulations of PMF, I would expect many of those summability issues could be avoided.</p>",
        "id": 567553373,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1768229048
    },
    {
        "content": "<p>The other thread mentioned this tactic: <a href=\"https://github.com/wvhulle/ennreal-arith\">https://github.com/wvhulle/ennreal-arith</a> (see \"Usage\" in the README). If this looks like it solves some problems then perhaps this could be upstreamed somehow. It looks to me like it might be a solution to \"arithmetic is painful\" (the only listed disadvantage to the status quo) but without an explicit list of examples of how it's painful, it's difficult to check whether this tactic is a solution.</p>",
        "id": 567560830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768230574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PMF.20Refactor.3A.20FunLike.20vs.20Definition.20Change/near/567522128\">said</a>:</p>\n<blockquote>\n<p>I'd like to check that this doesn't actually mean \"arithmetic is painful if you don't know the tricks\" or \"arithmetic is painful because there is a specific tactic which would solve everything and which we don't have\" (so another potential path forward might be a concrete specification of a tactic, followed by an implementation of that tactic).</p>\n</blockquote>\n<p>I'd argue the latter; things like <code>ring</code> and <code>field</code> work nicely for the reals but not for ENNReal, because they're not a ring, and so for \"obvious\" algebraic manipulations it sometimes feels like we're in a pre-<code>ring</code> world again. (I don't have concrete examples to hand, but I expect they'll be easy to list for anyone who works with ENNReal regularly)</p>",
        "id": 567561896,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1768230796
    },
    {
        "content": "<p>I have expressed this in other threads but I think <code>PMF</code> itself is somewhat outdated. It encourages developing API which will hold in greater generality and then need to duplication. For example your PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/33668\">#33668</a> would hold equally well for the (nonexistent) <code>MF</code>.  This is relevant even to discrete probability because you may encounter things like flat priors or sub probability measures in certain arguments (just to name some examples). Like how we don't develop a seperate API for Probability measures we instead use the class <code>IsProbabilityMeasure</code> I think it probably makes more sense to refactor to <code>MF</code> and have a sum to 1 hypothesis or possibly even better <code>[IsProbabilityMeasure p.toMeasure]</code> (with appropriate API) when you actually need it.</p>",
        "id": 567565483,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1768231522
    },
    {
        "content": "<p>As for <code>ENNReal</code> vs <code>NNReal</code> I think it may make sense to switch to the approach that the continuous distributions take with <code>PDFReal </code>and <code>PDF</code>. You first define <code>PDFReal</code> with real weights and then define <code>PDF</code> on ENNReal by composing with ENNReal. You could do the same with PMFReal and PMF. But regardless I think that the automation for ENNReal computations should (and eventually will) be improved. The reason this works nicely is that for lintegrals you use the <code>PMF/MF</code> but for (bochner) integrals the <code>toENNReal</code> \"peels off\".</p>",
        "id": 567567376,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1768231887
    },
    {
        "content": "<p>If people wanted to see the pain point that motivated me to start working on this again, it's <a href=\"https://github.com/leanprover-community/mathlib4/pull/33680/changes\">here</a>.</p>\n<p>I think that regardless of which return type is better for the funlike instance, there are probably proofs where one version would be more convenient and other proofs where another version would be more convenient. So I would like to see some kind of <code>PMF Œ± ‚Üí Œ± ‚Üí ‚Ñï‚â•0</code> function and ext-like API around it.</p>",
        "id": 567567978,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1768232015
    },
    {
        "content": "<p>Fwiw I think it makes more sense to define the (TV) metric space more generally on <code>FiniteMeasure</code> and <code>ProbabilityMeasure</code> and then have a lemma that states this reduces to a sum in the discrete case.</p>",
        "id": 567572394,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1768232907
    },
    {
        "content": "<p>We actually have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/Measure/FiniteMeasure.html#MeasureTheory.FiniteMeasure.mass\">MeasureTheory.FiniteMeasure.mass</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/Measure/ProbabilityMeasure.html#MeasureTheory.ProbabilityMeasure.instFunLike\">MeasureTheory.ProbabilityMeasure.instFunLike</a> that return NNReals, so perhaps there is another argument for making a change somewhere for the sake of consistency.</p>",
        "id": 567583745,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1768235345
    },
    {
        "content": "<p>The idea of defining TV through measure theory was discussed <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/total.20variation.20distance.20between.20two.20PMFs/with/566810511\">here</a>. <span class=\"user-mention\" data-user-id=\"756493\">@Yannick Seurin</span> might have been interested in doing work along these lines.</p>",
        "id": 567584313,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1768235471
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"223948\">David Ledvinka</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PMF.20Refactor.3A.20FunLike.20vs.20Definition.20Change/near/567565483\">said</a>:</p>\n<blockquote>\n<p>the (nonexistent) <code>MF</code></p>\n</blockquote>\n<p>Perhaps you can explain this more? Is this just the type of countably supported functions to ENNReal?</p>",
        "id": 567587800,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1768236237
    },
    {
        "content": "<p>My reluctance to personally implement measure-theory related solutions to PMF probably has to do with my unfamiliarity with the measure theory part of the library. Is there some kind of map that can take any type and give us a discrete measure space on that type, so that <code>PMF a</code> is really just the type of probability measures over this space? If so, could we just redefine all of PMF in terms of that, and inherit all the measure API directly?</p>",
        "id": 567592345,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1768237286
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> ?a -&gt; MeasurableSpace ?a</p>",
        "id": 567592391,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1768237296
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> nothing found</p>",
        "id": 567592408,
        "sender_full_name": "loogle",
        "timestamp": 1768237300
    },
    {
        "content": "<p>Ok I have found <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/MeasurableSpace/Defs.html#instDiscreteMeasurableSpace\">instDiscreteMeasurableSpace</a>, I guess this is effectively the function I was searching for. And I guess another way we could write this is just as the top element of the type of measure spaces.</p>\n<p>So I guess my next question is, is <code>PMF Œ±</code> just equivalent to <code>@MeasureTheory.ProbabilityMeasure Œ± ‚ä§</code>?</p>",
        "id": 567597782,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1768238568
    },
    {
        "content": "<p>I had in mind <code>MF : Œ± ‚Üí ‚Ñù‚â•0‚àû</code> and you include additional hypothesis when you need them. Its not clear that we even need this to be a \"named\" type (similar to how the use of <code>PDFReal</code> and <code>PDF</code> is not). It may or may not help with API. </p>\n<p>A stronger philosophical point here (which may be proven wrong) is that I believe that this kind of API or \"templating\" is necessary to work with certain concrete distributions that naturally come from PMFs/MFs but it is not a good idea to design a discrete probability API around PMF/MFs as if all your discrete distributions will come from PMF/MFs. </p>\n<p>There are lots of obvious reasons for this that come from the fact that you will likely prove facts that should be special cases of more general measure theory and also will likely cause trouble when you try to mix these together (for example a setting where you are considering discrete random variables and continuous random variables on the same probability space).</p>\n<p>However I think even in the case where you only care about discrete probability it will often not be natural to think of the distributions as coming from PMFs. In many cases, for example when you construct a random graph from some procedure it often is not natural to view it first and foremost as coming from a PMF, for example <a href=\"#narrow/channel/252551-graph-theory/topic/Random.20regular.20graphs.20are.20optimal.20expanders\">here</a>. In the setting of random graphs (or other things like this) the measure theoretic definition of TV is actually still more natural and you may use it to bound TV between distributions by exhibiting some event where you show two measures on the graph differ in probability by some amount (of course you could translate this to PMFs but I claim it is actually much more awkward in this case despite being discrete). </p>\n<p>But I do agree with you that in the case that we have measures on a discrete measure space, it should be easy to reduce to discrete objects like sums etc when desired without having to understand the measure theory library (and measure theory) well enough to unravel it. As an example, one should be able to prove that the sum of Bernoulli random variables is Binomial while understanding little to no measure theory (especially since in a case like this there is no risk that the statement is not general enough). I have work on this a little bit but just haven't found a complete solution I was happy to PR yet. I think if the (p-medium) issue solved from <a href=\"#narrow/channel/287929-mathlib4/topic/Custom.20simp.20for.20simplifying.20integrals\">this</a> thread was completed then you could get <code>simp</code> to do most of these reductions .</p>",
        "id": 567599023,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1768238896
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PMF.20Refactor.3A.20FunLike.20vs.20Definition.20Change/near/567597782\">said</a>:</p>\n<blockquote>\n<p>So I guess my next question is, is <code>PMF Œ±</code> just equivalent to <code>@MeasureTheory.ProbabilityMeasure Œ± ‚ä§</code>?</p>\n</blockquote>\n<p>Essentially yes. Though as I mentioned above we only use ProbabilityMeasure when one cares about some structure on the space as a whole (so a metric space structure would be an example)</p>",
        "id": 567599455,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1768239006
    },
    {
        "content": "<blockquote>\n<p>it is not a good idea to design a discrete probability API around PMF/MFs as if all your discrete distributions will come from PMF/MFs.</p>\n</blockquote>\n<p>Just to add that as someone who mostly only needs probability in the discrete finite case, I completely agree with this point. We should make it easy to specialise the general case to the discrete finite situation, but the theory should be developed in the general case without <code>PMF</code>.</p>",
        "id": 567599599,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1768239039
    },
    {
        "content": "<p>Thanks for the explanation!</p>",
        "id": 567601333,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1768239462
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"572064\">@Peter Pfaffelhuber</span> the discussion above is related to what you want to do.</p>\n<p>Peter told me he wanted to define a <code>DiscreteMeasure</code> type, which sounds very similar to what <span class=\"user-mention silent\" data-user-id=\"223948\">David Ledvinka</span>  calls MF in the messages above. Peter wants it to be a type, because then it's a monad and you can use do notation, for example to define a Binomial by describing the sampling of several Bernoulli and recording the successes.</p>",
        "id": 567711301,
        "sender_full_name": "R√©my Degenne",
        "timestamp": 1768294363
    },
    {
        "content": "<p>Personally, the point of the 2022 <code>NNReal</code> to <code>ENNReal</code> change convincing, since in particular, <code>Measure</code> maps <code>Set Œ± ‚Üí ENNReal</code> and I think there should be a coercion from <code>PMF</code>tp <code>Measure</code> (which does not exist yet). Thanks <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> for the pointer to <a href=\"https://github.com/wvhulle/ennreal-arith\">ennreal-arith</a>, which I will check. </p>\n<p>I am also in favour of having something like <code>MF</code> (as a type). My imagination is that they are e.g. used as the state of a point process.</p>",
        "id": 567763958,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1768311028
    },
    {
        "content": "<p>Note that I'm not vouching for the tactic, it was just something that came up in one of the other threads discussing this. I don't know anything about the tactic or its spec.</p>",
        "id": 567771586,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768312916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"223948\">David Ledvinka</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PMF.20Refactor.3A.20FunLike.20vs.20Definition.20Change/near/567565483\">schrieb</a>:</p>\n<blockquote>\n<p>I have expressed this in other threads but I think <code>PMF</code> itself is somewhat outdated. It encourages developing API which will hold in greater generality and then need no duplication. This is relevant even to discrete probability because you may encounter things like flat priors or sub probability measures in certain arguments (just to name some examples). Like how we don't develop a seperate API for Probability measures we instead use the class <code>IsProbabilityMeasure</code> I think it probably makes more sense to refactor to <code>MF</code> and have a sum to 1 hypothesis or possibly even better <code>[IsProbabilityMeasure p.toMeasure]</code> (with appropriate API) when you actually need it.</p>\n</blockquote>\n<p>I would vote for this approach. <span class=\"user-mention\" data-user-id=\"350992\">@R√©my Degenne</span>'s impression was that several people started to develop something similar as <code>MF</code> (e.g. in the SampCert-differential-privacy-project), so this is useful anyway. Using the class <code>IsProbabilityMeasure</code>would also be inline with other parts of the probability theory part of the library as far as I can see.</p>",
        "id": 567924583,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1768378969
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PMF.20Refactor.3A.20FunLike.20vs.20Definition.20Change/near/567560830\">said</a>:</p>\n<blockquote>\n<p>The other thread mentioned this tactic: <a href=\"https://github.com/wvhulle/ennreal-arith\">https://github.com/wvhulle/ennreal-arith</a> (see \"Usage\" in the README). If this looks like it solves some problems then perhaps this could be upstreamed somehow. It looks to me like it might be a solution to \"arithmetic is painful\" (the only listed disadvantage to the status quo) but without an explicit list of examples of how it's painful, it's difficult to check whether this tactic is a solution.</p>\n</blockquote>\n<p>Is ENNReal arithmetic even a little bit more difficult than real (not NNReal!) arithmetic?<br>\nIf so, it's a deal breaker.</p>\n<p>The discussion here might reflect two very different styles of doing mathematics: highly abstract ones, where explicit computations are shunned (cf. the discussion on matrices), compared to discrete mathematics (most of combinatorics, parts of probability theory, etc.), where computations are the norm, and we are more interested in dealing with concrete objects rather than working in the greatest possible generality.</p>\n<p>It's nice that Mathlib is very general, but if that makes it impossible to work concretely , then you're essentially kicking out anybody working in discrete mathematics, which would be a shame.</p>\n<p>Can you prove that a sum of independent Bernoullis has a binomial distribution? Can you prove that if you toss a coin infinitely many times, then the distribution of the first time you get heads is geometric? Can you determine the threshold for the appearance of triangles in <code>G(n,p)</code> random graphs? Can you construct a coupling between <code>G(n,p)</code> and <code>G(n,q)</code> and use it to show that the probably of monotone properties is increasing in <code>p</code>?<br>\nIf these are impossibly difficult (for anybody other than Ya√´l and Bhavik), then we have a problem.</p>",
        "id": 567934968,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1768382491
    },
    {
        "content": "<p>I don't think Mathlib is trying to be very general because it wants to kick out discrete maths.<br>\nI think it's trying to be very general because in the past we've seen many times that it pays off.<br>\nWe want to answer concrete questions, prove lemmas about concrete objects. But we don't know in advance which ones, and how many. So we try be general and abstract, in the hope that this can be applied in many cases.</p>\n<p>If it turns out that the abstractions don't apply in the concrete cases, then <em>that</em> is a problem.</p>\n<p>But the solution is not to have 370 proofs and computations that are all very similar.<br>\nBecause we don't have a tactic \"apply the same proof strategy as in lemma X, but tweak it where necessary\".</p>",
        "id": 567941306,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1768384518
    },
    {
        "content": "<p>In the PMF case, it's really the opposite: it's when people started to use it (to prove things about sums of binomials and so on) that they realized that the initial NNReal-valued definition was clumsy to work with, and that things were better with ENNReal. And that's why we switched. It wasn't an ideological decision based on a priori ideas, it was just a pragmatic move based on experimentation. And I'd argue it's the way it should be: often we have a priori ideas on good designs, and when we realize they don't work out as well as we thought, then we change.</p>",
        "id": 567942090,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1768384761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"815159\">Yuval Filmus</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PMF.20Refactor.3A.20FunLike.20vs.20Definition.20Change/near/567934968\">schrieb</a>:</p>\n<blockquote>\n<p>Can you prove that a sum of independent Bernoullis has a binomial distribution? Can you prove that if you toss a coin infinitely many times, then the distribution of the first time you get heads is geometric? Can you determine the threshold for the appearance of triangles in <code>G(n,p)</code> random graphs? Can you construct a coupling between <code>G(n,p)</code> and <code>G(n,q)</code> and use it to show that the probably of monotone properties is increasing in <code>p</code>?</p>\n</blockquote>\n<p>The first task is around <a href=\"https://github.com/pfaffelh/journal/blob/master/Journal/Notes/DiscreteMeasure.lean#L1169\">here</a> (in a slightly different setting, not PRed to Mathlib yet, but still using <code>ENNReal</code> rather than <code>NNReal</code> or <code>Real</code>). The second task is more difficult and will need the <code>MeasureTheory</code> library, since you need a probability space with a (countably) infinite number of Bernoullis. (I would be interested to try to prove this.) The other questions really deal with couplings, so they need a way to properly extend a given probability space, show that some random variables on that space have certain distributions etc. Nothing like this is in Mathlib as far as I know, but I cannot see a way around defining the probability space and using monotonicity of the underlying measure in order to prove e.g. the mentioned triangle property. </p>\n<p>In addition to what Johan and Sebastian wrote, for me the Natural Number Game is a very good example of having something very concrete, but still fun to get started with formalizing mathematics.</p>",
        "id": 567956695,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1768388600
    },
    {
        "content": "<p>What might be different in probability theory: Often, abstraction makes things easier (i.e. easier to prove, e.g. using filters rather than other tools), whereas in discrete probability theory, in the less abstract setting, computations and proofs should be easier since there are no measurability issues.</p>",
        "id": 567957142,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1768388741
    },
    {
        "content": "<p>Let me comment on the \"working with <code>ENNReal</code>\" aspect, grounded from experience in the Carleson project. (That's a project in harmonic analysis; it involves lots of manipulations of explicit integrals --- i.e., involving analysis and measure theory, but not related to probability measures or PMFs.)</p>\n<p>Initially, we tried to make all definitions take real values; this failed badly.</p>\n<ul>\n<li>many suprema involved take potentially infinite values (and even if they are finite, proving this all the time is cumbersome),</li>\n<li>mathlib has much more API for infinite suprema here,</li>\n<li>converting back and forth between <code>Real</code>, <code>NNReal</code> and <code>ENNReal</code> is painful. We have some tools for this, but by far the best way to deal with this is to avoid the conversion in the first place.</li>\n</ul>\n<p>Another story involves switching from real-values norms <code>norm</code> to extended norms <code>enorm</code>. Our initial motivation was mathematical (avoid code duplication and a tedious limiting argument), but it turns out to be useful for formalisation: many statements in mathlib actually become clearer by using <code>enorm</code> instead of <code>norm</code> or <code>nnnorm</code> (a norm, but returning non-negative real numbers). This deviates slightly from the mathematical literature, but I consider this to be a good decision all around.</p>\n<p>It did imply, however, changing some proofs from Real to <code>ENNReal</code>. Indeed, this is more painful than it should be. There's no <code>ring</code> or <code>field_simp</code> support, so you're back to long <code>rw</code> chains. <code>finiteness</code> can help a bit, by discharging finiteness conditions; overall, the experience is too cumbersome. To me, however, the right fix is to create better tactics, not to avoid ENNReal.</p>",
        "id": 567957649,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1768388901
    },
    {
        "content": "<p>A similar issue arises with polynomial degree, which is defined using WithBot, making working with it extremely awkward.<br>\nI agree that the best solution is better tactics.<br>\nThe tactic should enable doing real arithmetic whenever all the quantities involved are finite.<br>\nSimilarly, there should be a tactic that reduces WithBot arithmetic to natural arithmetic.<br>\nIn both cases, lift only goes part of the way, and the issue even stumps grind.<br>\nFor an example with WithBot, you can take a look at <a href=\"https://github.com/leanprover-community/mathlib4/pull/33194\">#33194</a>.</p>",
        "id": 568071741,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1768421710
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.natDegree#doc\">docs#Polynomial.natDegree</a> if using degree is awkward. Mathematically <code>degree</code> is \"more correct\" but <code>natDegree</code> is often more convenient.</p>",
        "id": 568087783,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768428017
    },
    {
        "content": "<p>Here is what I would like to do related to <code>PMF</code>s:</p>\n<ul>\n<li>Introduce a type <code>MF := Œ± ‚Üí ‚Ñù‚â•0‚àû</code> (MF for mass function), which is like <code>PMF</code> but no <code>HasSum 1</code> property.</li>\n<li>Change the definition of <code>toMeasure</code> from <code>PMF</code> to <code>MF.toMeasure (w : MF Œ±) : @Measure Œ± ‚ä§ := Measure.sum (fun a ‚Ü¶ (w a) ‚Ä¢ @Measure.dirac Œ± ‚ä§ a)</code>. The resulting measure is defined on the power set, so does not require  <code>MearurableSpace Œ±</code>.</li>\n<li>Probably, do not define <code>toOuterMeasure</code> as in PMF, since the outer measure defined by a (P)MF and the measure agree anyway. In addition, I know no calculations based on <code>outerMeasures</code>. Otherwise, all results for <code>PMF</code> (if they do not require <code>HasSum 1</code>) should as well be available to <code>MF</code>.</li>\n<li>Give an <code>instance LawfulMonad MF</code>, unlocking <code>do</code>-notation. For <code>map</code>, <code>pure</code>, <code>bind</code>, show that they mean the same as for <code>MF.toMeasure</code>. </li>\n<li>If <code>IsProbabilityMease Œº.toMeasure</code>, show that <code>IsProbabilityMeasure</code> is valid after applying <code>map</code>, <code>pure</code>, <code>bind</code> from the monad as well. </li>\n<li>Show that <code>MF Œ±</code> plus <code>IsProbabilityMease Œº.toMeasure</code> is the same as a <code>PMF</code>. </li>\n</ul>\n<p>Would that be a good way to proceed?</p>",
        "id": 568185324,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1768476789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PMF.20Refactor.3A.20FunLike.20vs.20Definition.20Change/near/568087783\">said</a>:</p>\n<blockquote>\n<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.natDegree#doc\">docs#Polynomial.natDegree</a> if using degree is awkward. Mathematically <code>degree</code> is \"more correct\" but <code>natDegree</code> is often more convenient.</p>\n</blockquote>\n<p>Yeah I never know which one to use. In practice <code>natDegree</code> is always easier but a lot of stuff is stated with <code>degree</code>. Some sort of <code>lia</code> extension would be very useful here.</p>",
        "id": 568287046,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1768502371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"572064\">Peter Pfaffelhuber</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PMF.20Refactor.3A.20FunLike.20vs.20Definition.20Change/near/568185324\">said</a>:</p>\n<blockquote>\n<p>Here is what I would like to do related to <code>PMF</code>s:</p>\n</blockquote>\n<p>This seems like a good suggestion, but I am still wondering if there is an even better way that does not use <code>‚ä§</code> and instead uses the countable-cocountable measure. I still don't feel like I understand this subject well, but I got the sense from (this thread <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/channel/116395-maths/topic/Are.20discrete.20measures.20determined.20by.20their.20points.3F/with/568317714\">#maths &gt; Are discrete measures determined by their points?</a> ) that this measure is perhaps easier to prove things about, while being closer to the space of things currently allowed by the PMF definition.</p>",
        "id": 568337932,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1768524623
    },
    {
        "content": "<p>I guess it's unfortunate that this particular measure isn't defined directly as an object in mathlib yet <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/The.20sigma.20algebra.20of.20countable.20and.20cocountable.20Sets/with/568336278\">#Is there code for X? &gt; The sigma algebra of countable and cocountable Sets</a></p>",
        "id": 568338276,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1768524734
    },
    {
        "content": "<p>So to try to put this proposal in <span class=\"user-mention silent\" data-user-id=\"572064\">Peter Pfaffelhuber</span> 's terms</p>\n<ul>\n<li>Introduce a type <code>MF := @Measure Œ± (countableCocountable Œ±)</code></li>\n<li>Redefine <code>PMF (Œ±)</code> as a subtype of <code>MF</code> with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsProbabilityMeasure#doc\">docs#IsProbabilityMeasure</a></li>\n<li>The definition of <code>toMeasure</code> is just the value itself </li>\n<li>(if we want a measure for a different measurableSpace structure on Œ±, as in the current definition, we <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/Measure/Map.html#MeasureTheory.Measure.map\">MeasureTheory.Measure.map</a> over the identity)</li>\n<li>define <code>toOuterMeasure</code> Using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure.toOuterMeasure#doc\">docs#MeasureTheory.Measure.toOuterMeasure</a></li>\n<li>Give the monads</li>\n<li>Again, <code>MF Œ±</code>¬†plus¬†<code>IsProbabilityMeasure Œº.toMeasure</code>¬†is the same as a¬†<code>PMF</code> by definition.</li>\n</ul>",
        "id": 568340315,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1768526343
    },
    {
        "content": "<p>In order to define <code>map</code> in the sense of a <code>LawfulMonad</code>, every function needs to be measurable. I can only see this working if I take <code>@Measure Œ± ‚ä§</code>. In your suggestion, I did not see how this would improve computing things with <code>MF</code>s.</p>",
        "id": 568373097,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1768549155
    },
    {
        "content": "<p>The sigma algebra of countable and cocountable sets is rather poor (ie very few sets), while in general you prefer to have more measurable sets. For instance the Dirac mass is often defined over the power set, I don‚Äôt understand why you would like to restrict measurable sets.</p>",
        "id": 568379385,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1768551824
    },
    {
        "content": "<p>Just for the record, as the lack of automation in ENNReal has been mentioned in this thread:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"bp\">‚Åª¬π</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>doesn't seem to be covered by our standard automation as far as I can tell.</p>",
        "id": 568438011,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1768571233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PMF.20Refactor.3A.20FunLike.20vs.20Definition.20Change/near/568379385\">said</a>:</p>\n<blockquote>\n<p>I don‚Äôt understand why you would like to restrict measurable sets.</p>\n</blockquote>\n<p>I guess I had assumed that if a PMF is a summable function, which therefore has countable support, it would make more sense for MF to also be only functions of countable support, and that might let us avoid the things mentioned in this thread (<a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/channel/116395-maths/topic/Are.20discrete.20measures.20determined.20by.20their.20points.3F/with/568409822\">#maths &gt; Are discrete measures determined by their points?</a> ) where I am told that determining if two <code>@Measure Œ± ‚ä§</code> are equal on the basis of the measures of their points being equal depends on the existence of some cardinal that can't be proved in ZFC.</p>\n<p>Perhaps the issue is just that my intuitions about what a \"mass function\" means are wrong.</p>",
        "id": 568477176,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1768581679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PMF.20Refactor.3A.20FunLike.20vs.20Definition.20Change/near/568287046\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PMF.20Refactor.3A.20FunLike.20vs.20Definition.20Change/near/568087783\">said</a>:</p>\n<blockquote>\n<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.natDegree#doc\">docs#Polynomial.natDegree</a> if using degree is awkward. Mathematically <code>degree</code> is \"more correct\" but <code>natDegree</code> is often more convenient.</p>\n</blockquote>\n<p>Yeah I never know which one to use. In practice <code>natDegree</code> is always easier but a lot of stuff is stated with <code>degree</code>. Some sort of <code>lia</code> extension would be very useful here.</p>\n</blockquote>\n<p><code>degree</code> carries more information. If <code>p.degree = 0</code> then <code>p</code> must be constant and non-zero, but it <code>p.natDegree = 0</code> then all you know is <code>p</code> is constant. So I stick to <code>degree</code>, unless I do need a natural number (to pass it into a function, for instance).</p>",
        "id": 568481652,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1768583027
    },
    {
        "content": "<p>Yeah but then I can't use <code>lia</code> <span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span></p>",
        "id": 568481900,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1768583109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PMF.20Refactor.3A.20FunLike.20vs.20Definition.20Change/near/568477176\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PMF.20Refactor.3A.20FunLike.20vs.20Definition.20Change/near/568379385\">said</a>:</p>\n<blockquote>\n<p>I don‚Äôt understand why you would like to restrict measurable sets.</p>\n</blockquote>\n<p>I guess I had assumed that if a PMF is a summable function, which therefore has countable support, it would make more sense for MF to also be only functions of countable support, and that might let us avoid the things mentioned in this thread (<a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/channel/116395-maths/topic/Are.20discrete.20measures.20determined.20by.20their.20points.3F/with/568409822\">#maths &gt; Are discrete measures determined by their points?</a> ) where I am told that determining if two <code>@Measure Œ± ‚ä§</code> are equal on the basis of the measures of their points being equal depends on the existence of some cardinal that can't be proved in ZFC.</p>\n<p>Perhaps the issue is just that my intuitions about what a \"mass function\" means are wrong.</p>\n</blockquote>\n<p>But if you cannot distinguish measures by just looking at singletons restricting the measurable sets won't solve the problem. A mass function is a way to represent a measure which is only composed of atoms, i.e. it is a sum of Dirac masses (each mass being multiplied by a coefficient).</p>",
        "id": 568485177,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1768584068
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"815159\">Yuval Filmus</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PMF.20Refactor.3A.20FunLike.20vs.20Definition.20Change/near/567934968\">said</a>:</p>\n<blockquote>\n<p>Can you construct a coupling between <code>G(n,p)</code> and <code>G(n,q)</code> and use it to show that the probably of monotone properties is increasing in <code>p</code>?</p>\n</blockquote>\n<p><code>G(n,p)</code> and <code>G(n,q)</code> are not in mathlib yet, currently in a PR by <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> <a href=\"https://github.com/leanprover-community/mathlib4/pull/31364\">#31364</a>. However <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> had already done this argument in Lean 3 and I spoke with him on how to update the argument to our current state of probability in Mathlib. We demonstrate here the use of this coupling argument to prove a lemma which can be used to deduce the fact you mention above (without an additional coupling argument). Our proof is not optimized (could be both golfed and API added to mathlib) but I think it actually demonstrates why it is important for Probability Theory to have a cohesive API. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">ProbabilityTheory</span><span class=\"w\"> </span><span class=\"n\">unitInterval</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">ProbabilityTheory</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"n\">Œ©</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">Œ©</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">Œ©</span><span class=\"o\">}</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bernoulli_prop_measure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">ofReal</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">dirac</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">True</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">ofReal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">dirac</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">False</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> I don't use `setBer` and abuse the Set/Prop defeq throughout the file just to make things a bit easier for the demonstration. -/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bernoulli_prop_iid_measure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">infinitePi</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">bernoulli_prop_measure</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">uniform_indicator_hasLaw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ©</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hU</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasLaw</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">‚Ñô</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">HasLaw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bernoulli_prop_measure</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">map_eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">ext_of_singleton</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">prop</span>\n<span class=\"w\">    </span><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">enter</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">AEMeasurable</span><span class=\"bp\">.</span><span class=\"n\">map_map_of_aemeasurable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">map_apply_of_aemeasurable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">measurability</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hU</span><span class=\"bp\">.</span><span class=\"n\">map_eq</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"w\">    </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"bp\">‚ü©</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bernoulli_prop_measure</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq_iff_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iff_true</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ioc</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_one'</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"bp\">‚ü©</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bernoulli_prop_measure</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsProbabilityMeasure</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">hasLaw_bernoulli_iid_of_uniform_iid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ©</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hU</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">HasLaw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hU'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iIndepFun</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">HasLaw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bernoulli_prop_iid_measure</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">map_eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">bernoulli_prop_iid_measure</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">iIndepFun_iff_map_fun_eq_infinitePi_map‚ÇÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">œâ</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">œâ</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">enter</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">uniform_indicator_hasLaw</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hU</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map_eq</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">iIndepFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">P</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hU'</span><span class=\"bp\">.</span><span class=\"n\">comp</span>\n<span class=\"w\">    </span><span class=\"n\">fun_prop</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Proof that the bernoulli_prop_iid_measure is monotonic in `p` on any `UpperSet` using a coupling argument. -/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ùìï</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hùìï_meas</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSet</span><span class=\"w\"> </span><span class=\"n\">ùìï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hùìï</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsUpperSet</span><span class=\"w\"> </span><span class=\"n\">ùìï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Monotone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">bernoulli_prop_iid_measure</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">ùìï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">hpq</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">Œ©</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hŒ©</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hU_law</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hU_indep</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">exists_iid</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">‚Ñô</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- Sample i.i.d Uniform RVs `U i` for each `i : Œπ`</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> Couple `bernoulli_prop_iid_measure Œπ p` and `bernoulli_prop_iid_measure Œπ q` by \"generating\" both with `U`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hasLaw_bernoulli_iid_of_uniform_iid</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">hU_law</span><span class=\"w\"> </span><span class=\"n\">hU_indep</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_eq</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hasLaw_bernoulli_iid_of_uniform_iid</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">hU_law</span><span class=\"w\"> </span><span class=\"n\">hU_indep</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_eq</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">map_apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">measurability</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">map_apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">measurability</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">measure_mono</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">œâ</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hùìï</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">œâ</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">‚äÜ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">œâ</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">setOf_subset_setOf</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>Although this is a discrete probability problem, and the objects involved could in theory be defined using <code>PMF</code> any natural formal translation of the proof would have to use the Unit Interval in some way. (I say \"natural\" because I believe you could construct the coupling using only discrete spaces but it would be harder and necessarily further from the paper argument).</p>",
        "id": 568488741,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1768585157
    },
    {
        "content": "<p>Nice approach for the coupling! (Percolation would be another nice example.) </p>\n<p>If the goal is to show monotonicity, it would suffice to take two values <code>(p q : ‚Ñù‚â•0‚àû) (hp : p ‚â§ 1) (hq : q ‚â§ 1) (hqq : p ‚â§ q)</code> and some <code>bernoulli p hp</code> and <code>bernoulli (q - p) _</code>, and add them to have <code>bernoulli p _</code> for the coupling. This would not leave the space of <code>PMF</code>s.</p>",
        "id": 568515352,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1768594243
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"572064\">Peter Pfaffelhuber</span> <a href=\"#narrow/channel/287929-mathlib4/topic/PMF.20Refactor.3A.20FunLike.20vs.20Definition.20Change/near/568515352\">said</a>:</p>\n<blockquote>\n<p>Nice approach for the coupling! (Percolation would be another nice example.) </p>\n<p>If the goal is to show monotonicity, it would suffice to take two values <code>(p q : ‚Ñù‚â•0‚àû) (hp : p ‚â§ 1) (hq : q ‚â§ 1) (hqq : p ‚â§ q)</code> and some <code>bernoulli p hp</code> and <code>bernoulli (q - p) _</code>, and add them to have <code>bernoulli p _</code> for the coupling. This would not leave the space of <code>PMF</code>s.</p>\n</blockquote>\n<p>If you add (actually, take the maximum of) <code>Ber(p)</code> and <code>Ber(q-p)</code> you don't get what you want. The second Bernoulli should have bias <code>(q‚Äìp)/(1‚Äìp)</code>.<br>\nAnother approach would be to directly sample both variables: <code>(0,0)</code> w.p. <code>1‚Äìp</code>, <code>(0,1)</code> w.p. <code>q‚Äìp</code>, <code>(1,1)</code> w.p. <code>p</code>. The marginals would have laws <code>Ber(p)</code> and <code>Ber(q)</code>.<br>\nThe approach using <code>U(0,1)</code> has the advantage that we get a coupling of <code>G(n,p)</code> for all <code>p</code> at once. This allows us to state results such as \"a.a.s., <code>G(n,p)</code> becomes connected the moment the last isolated vertex disappears\".<br>\nIt would be nice if all of these arguments would be easy to state.</p>\n<p>Another nice nugget is to show that if you sample <code>G(‚Ñï,p)</code> for any constant <code>p</code>, then almost surely you get the same graph (up to isomorphism), known as the countable random graph or Erdos‚ÄìRado graph, which also has simple explicit constructions. The probabilistic part of the proof boils down to Borell‚ÄìCantelli, and involves some easy calculation.</p>\n<p>We would know that we have a workable theory of discrete probability when results such as these become manageable to prove.</p>",
        "id": 568528291,
        "sender_full_name": "Yuval Filmus",
        "timestamp": 1768599540
    },
    {
        "content": "<p>Thanks for correcting by Bernoulli-calculation. Just one quick note: If you have a probability space with multiple (infinitely many?) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">U(0,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> random variables, you certainly leave the space of discrete probability (although the objects you aim to construct are discrete). One of my goals is to introduce <code>do</code>-notation, such that you are able to write something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">binom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"bp\">‚â•</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"bp\">‚â•</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">MassFunction</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">Head</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">coin</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">Head</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">binom</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>This will at the moment (i.e. restrictions in <code>do</code> notation) not work if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">U(0,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> random variables are used.</p>",
        "id": 568584607,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1768653938
    },
    {
        "content": "<p>I started to PR my ideas to mathlib (<a href=\"https://github.com/leanprover-community/mathlib4/pull/34138\">#34138</a>)</p>",
        "id": 569141772,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1768949444
    },
    {
        "content": "<p>Thanks, <span class=\"user-mention\" data-user-id=\"223948\">@David Ledvinka</span> for the review! Can we please discuss the consequences of changing </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toMeasure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MassFunction</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">dirac</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>to a version where the sigma-algebra is a variable which defaults to <code>‚ä§</code>, i.e.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toMeasure'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MassFunction</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mŒ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"o\">[</span><span class=\"n\">mŒ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">dirac</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">mŒ±</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>At first glance, this means that all calculations with <code>toMeasure'</code> involving some <code>s : Set Œ±</code> will need to show/assume <code>MeasurableSet s</code>.   I want to avid this, since (i) as a more accessible approach to discrete probability, measurability should never be an issue for <code>MassFunction</code>, (ii) often it simply depends on the sigma-algebra if measurability is in fact true, so I will have to assume several things about <code>mŒ±</code> in various places and (iii) in the (not yet PRed) code treating <code>MassFunction</code> as a monad, I will have to require <code>MeasurableSpace Œ± = ‚ä§</code>.</p>\n<p>For the standard finite/countable types, there are things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/MeasurableSpace/Instances.html#Bool.instMeasurableSpace\">Bool.instMeasurableSpace</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/MeasurableSpace/Instances.html#Nat.instMeasurableSpace\">Nat.instMeasurableSpace</a>, giving the correct <code>‚ä§</code> sigma-algebra anyway. </p>\n<p>However, there is the case, where one wants to define something like a binomial distribution on <code>‚Ñù</code>, which is equipped with the Borel sigma-algebra. In this case, it is unclear how to proceed. </p>\n<p>My suggestion would be to use a trimmed version of <code>binomial.toMeasure</code> to the Borel sigma-algebra, instead of carrying around the sigma-algebra in many lemmas. So, my suggestion is to provide some API to show equality of a sum of diracs in case they are not defined on <code>‚ä§</code>.</p>",
        "id": 569848632,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1769244026
    },
    {
        "content": "<p>As an example, I would try to show:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">coinReal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"bp\">‚â•</span><span class=\"mi\">0</span><span class=\"bp\">‚àû</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MassFunction</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"bp\">‚â•</span><span class=\"mi\">0</span><span class=\"bp\">‚àû</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"bp\">‚â•</span><span class=\"mi\">0</span><span class=\"bp\">‚àû</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsProbabilityMeasure</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">indicator</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"o\">(</span><span class=\"n\">coinReal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toMeasure</span><span class=\"bp\">.</span><span class=\"n\">trim</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_top</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 569849615,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1769244781
    },
    {
        "content": "<p>I just wanted the flexibility for <code>toMeasure</code> and wasn't asking you to provide the API for the rest of MassFunction, since in this case I think it would be provided with API for diracs and sums of measures anyway. I  thought you wouldnt have to change any of the rest of your code, however I didn't actually test it and appears it doesnt work this way. In this case I would just provide a secondary <code>toMeasure</code> (with whatever name) with this feature.</p>",
        "id": 569860992,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1769256389
    },
    {
        "content": "<p>Also its worth noting that you may run into the problem you describe even with finite and countable types. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mŒ©‚ÇÅ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">infer_instance</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mŒ©‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mŒ©‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">mŒ©‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- error</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mŒ©‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">mŒ©‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mŒ©‚ÇÅ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mŒ©‚ÇÇ</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">constructor</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">measurability</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Œº</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">dirac</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Œº'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"o\">[</span><span class=\"bp\">‚ä§</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">dirac</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">‚Ñï</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œº</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Œº'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- error</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Type mismatch</span>\n<span class=\"cm\">  Œº'</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  @Measure (‚Ñï √ó ‚Ñï) ‚ä§</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  @Measure (‚Ñï √ó ‚Ñï) Prod.instMeasurableSpace -/</span>\n</code></pre></div>",
        "id": 569862791,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1769257857
    }
]