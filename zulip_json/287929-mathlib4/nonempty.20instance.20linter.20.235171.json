[
    {
        "content": "<p>In Lean 3 we used to have a linter that required that for every type you defined a <code>Nonempty</code> instance (for at least some specialization of the arguments!).</p>\n<p>It isn't implemented in Lean 4, and there are many porting notes, linking to <a href=\"https://github.com/leanprover-community/mathlib4/pull/5171\">#5171</a>, about its absence.</p>\n<p>I don't think we miss this linter much ...? It's occasionally useful, but mostly only in alerting you that your definition is wrong, which if you do anything nontrivial you'll find out about soon enough.</p>\n<p>I propose that we just delete all these porting notes.</p>",
        "id": 494482634,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1737177507
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/20824\">#20824</a></p>",
        "id": 494485685,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1737180393
    },
    {
        "content": "<p>Story time: Two years ago I defined binomial random graphs as those graph-valued random variables <code>G : Ω → SimpleGraph V</code> for some measure space <code>Ω</code> such that the law of <code>fun ω ↦ (G ω).edgeSet</code> is a sequence of Bernoulli measures. Just last week, <span class=\"user-mention\" data-user-id=\"449070\">@Yijun Leng</span> noticed (in <a href=\"https://github.com/leanprover-community/LeanCamCombi/pull/16\">LeanCamCombi#16</a>) that this is nonsense: I was asking each self-loop (edges <code>s(v, v)</code> from a vertex <code>v</code> to itself) to exist with probability <code>p</code>. You can see the fix in <a href=\"https://github.com/leanprover-community/LeanCamCombi/pull/17\">LeanCamCombi#17</a>.</p>",
        "id": 494492039,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1737186466
    },
    {
        "content": "<p>Concretely, I had written down a predicate which was (almost) never true, and which stayed around in my repository for several years.</p>",
        "id": 494492175,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1737186570
    },
    {
        "content": "<p>Having the nonempty linter around probably wouldn't have saved me though. The only way to show that binomial random graphs exist over any ground set <code>V</code> is to build the product measure, which is done in KolmogorovExtension (but not yet upstreamed to mathlib), so I would likely have simply nolinted my definition anyway.</p>",
        "id": 494492312,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1737186661
    },
    {
        "content": "<p>I think linters that remind people to write instances are a generally good thing</p>",
        "id": 494504674,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737196015
    },
    {
        "content": "<p>Especially since we now have <code>partial</code> as a language feature that depends on <code>Nonempty</code></p>",
        "id": 494504704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737196034
    },
    {
        "content": "<p>So my vote would be to implement the linter rather than dropping the porting notes</p>",
        "id": 494504730,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737196055
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, if there is a concrete plan to implement said linter, I'd be happy to wait for it. But if not, I don't think there is anything to be gained from waiting. Note that the porting notes here about about <code>@[nolint]</code>s that were removed, so if we were to implement such a linter, it would of course tell us exactly where such <code>@[nolint]</code>s need to be restored.</p>",
        "id": 494506024,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1737197088
    },
    {
        "content": "<p>Given we are a year and a half after the port, with no evidence of anyone being interested in writing such a linter, I don't think we can assume it is going to happen without positive evidence.</p>",
        "id": 494506089,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1737197157
    },
    {
        "content": "<p>How difficult would writing that linter be? Is there some description would it would do (other than trying to read the Lean 3 code... which <em>I</em> would rather not do)?</p>",
        "id": 494512257,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1737201862
    },
    {
        "content": "<p>As indicated above, I am happier <em>not</em> having this linter, I think it was counterproductive.</p>\n<p>But the spec was (I think):</p>\n<ul>\n<li>for every <code>structure</code> or <code>inductive</code> <code>C x y z</code></li>\n<li>check that there exists a definition marked <code>instance</code> in the environment with type after binders <code>Nonempty (C x y z)</code> for some values of <code>x y z</code>. (it's fine if these are specialized arbitrarily, even to constants)</li>\n</ul>",
        "id": 494512585,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1737202107
    },
    {
        "content": "<p>That spec sounds right to me</p>",
        "id": 494518642,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737206428
    },
    {
        "content": "<p>Maybe swap \"every structure\" for \"every declaration of type <code>Type*</code>\"</p>",
        "id": 494518678,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737206459
    },
    {
        "content": "<p>That sounds even more unpleasant to me. :-)</p>",
        "id": 494580372,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1737242526
    },
    {
        "content": "<p>I guess that would be annoying in category theory, but for thinks like <code>MulOpposite</code> would be painless</p>",
        "id": 494580502,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737242657
    },
    {
        "content": "<p>I think it's not worth having a linter. The problem it solves is very minor, and I think it's not worth the (even very small!) associated computational cost.</p>",
        "id": 494580512,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1737242668
    },
    {
        "content": "<p>I think the computational cost is negligeable; the human cost to write it is probably not justified by the linter itself, but seems like a nice metaprogramming exercise that ends up providing non-zero value for someone who wants practice</p>",
        "id": 494580730,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737242853
    },
    {
        "content": "<p>How funny—I drafted message yesterday offering to clear some debt by porting this very linter just as something fun to do, but was holding off on sending it :)</p>\n<p>I think it might be worth having a general \"missing instance\" linter—<code>Nonempty</code> and <code>Inhabited</code> are a bit specialized, but maybe we want to know about other instances as well. </p>\n<p>The useful question here is \"what instances do we generally want when possible?\"</p>",
        "id": 494580950,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1737243046
    },
    {
        "content": "<p>This is actually a little tricky once you start thinking about <code>Nonempty</code> and <code>Inhabited</code>. (The following is from my draft.)</p>\n<p>Since <code>Inhabited Foo</code> gets us <code>Nonempty Foo</code>, it's clear in the case of non-parameterized instances that we want <code>Inhabited</code> when possible, and <code>Nonempty</code> otherwise.</p>\n<p>But for parameterized \"container-like\" types, it seems we actually want two instances. Consider</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span>\n</code></pre></div>\n<p>This gives us <code>instInhabitedFoo {α} [Inhabited α] : Inhabited (Foo α)</code>.</p>\n<p>But let's say we only have <code>Nonempty α</code>. This is not sufficient to give us <code>Nonempty (Foo α)</code>, since we can't provide the <code>Inhabited α</code> required by <code>instInhabitedFoo</code>.</p>\n<p>I'd hazard that, in this case, we also want to make sure we have e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"bp\">‹_›⟩</span>\n</code></pre></div>\n<p>(or whichever way is best to write the term itself), possibly with <code>(priority := low)</code> if we want to get <code>Nonempty</code> from <code>Inhabited</code> when possible.</p>",
        "id": 494580965,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1737243055
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/nonempty.20instance.20linter.20.235171/near/494580512\">said</a>:</p>\n<blockquote>\n<p>I think it's not worth having a linter. The problem it solves is very minor, and I think it's not worth the (even very small!) associated computational cost.</p>\n</blockquote>\n<p>It's not the computational cost that matters, it is having to turn off the annoying linter!!</p>",
        "id": 494581164,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1737243228
    },
    {
        "content": "<p>I agree the linter could be annoying, but as we saw not long ago, there is non-negligible startup cost from all the (probably only syntax?) linters we have running, and since we run CI all the time, even an environment linter gets a bunch of use. I realize this may not be high computational cost, but my claim is that the linter isn't even worth the low computational cost (let alone the annoyance).</p>",
        "id": 494597237,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1737256831
    },
    {
        "content": "<p>Here's my understanding of the history of this linter:</p>\n<ul>\n<li>Originally, Gabriel added an Inhabited linter, because many basic types were missing Inhabited instances. That helped push people toward implementing them.</li>\n<li>Near the end of the Lean 3 days, we realized that Inhabited instances for most types were really arbitrary. We compromised and switched it to a Nonempty linter, since that at least didn't pollute the Inhabited instances with random values just to satisfy the linter. (Inhabited doesn't have a spec, but it makes sense for it to be, in some sense, the \"default\" value for a type.)</li>\n<li>Now in the Lean 4 days we've been surviving without any such linter. Maybe its need has passed.</li>\n</ul>\n<p>In my experience, the big problem with the Inhabited/Nonempty linter is that it would incentivize creating useless Inhabited/Nonempty instances just to appease the linter. It felt like cheating to turn the linter off for a particular type.</p>",
        "id": 494597653,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737257206
    },
    {
        "content": "<p>Have we had any issues with missing Inhabited/Nonempty instances recently? If not, then it sounds like we don't need it anymore. Mathlib's grown up :-)</p>",
        "id": 494597794,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737257301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/nonempty.20instance.20linter.20.235171/near/494506024\">said</a>:</p>\n<blockquote>\n<p>Note that the porting notes here about about <code>@[nolint]</code>s that were removed, so if we were to implement such a linter, it would of course tell us exactly where such <code>@[nolint]</code>s need to be restored.</p>\n</blockquote>\n<p>This sounds like an excellent argument to remove the porting notes. We're not really throwing away any information.<br>\nI'm going to <del>merge</del> delegate the PR now, and we can see later whether the linter reappears or not.<br>\n(I personally think we should not have the linter.)</p>",
        "id": 494787009,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1737373015
    }
]