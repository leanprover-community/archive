[
    {
        "content": "<p>In some proof, after <code>congr</code> I'm left with the goal <code>inst✝ = Fintype.subtype s H</code>.<br>\nDoes <code>congr</code> in Lean 4 not know about <code>Subsingleton.elim</code>?</p>",
        "id": 322218702,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1674115566
    },
    {
        "content": "<p>Should we have a <code>congr!</code> that knows about <code>Subsingleton.elim</code>? And then mathport can translate <code>congr</code> to <code>congr!</code>.</p>",
        "id": 338754285,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1677653663
    },
    {
        "content": "<p><code>congr</code> doesn't seem to know about iffs either, and I ported some instances of it as <code>apply iff_of_eq; congr</code>. This was part of mathlib's <code>congr'</code> (<a href=\"https://github.com/leanprover-community/mathlib/blob/8195826f5c428fc283510bc67303dd4472d78498/src/tactic/congr.lean#L43\">implemented here</a>)</p>",
        "id": 338777778,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677661860
    },
    {
        "content": "<p>Maybe it would be nice if a <code>congr!</code> would try doing \"<code>rfl</code> lifting,\" where it synthesizes and applies a theorem <code>a = b -&gt; R a b</code> if the target <code>R</code> is reflexive.</p>",
        "id": 338778814,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677662153
    },
    {
        "content": "<p>Though that could be considered to be be too aggressive (it'd apply even to <code>a &lt;= b</code>). Maybe applying to just reflexive &amp; symmetric relations is a better default.</p>",
        "id": 338779371,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677662316
    },
    {
        "content": "<p>Or alternatively there could be an attribute for <code>congr!</code> lemmas in general. Then both <code>Subsingleton.elim</code> and <code>rfl</code> lifting lemmas could plug into this.</p>",
        "id": 338779801,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677662429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/congr.20and.20subsingleton.2Eelim/near/338779371\">said</a>:</p>\n<blockquote>\n<p>Though that could be considered to be be too aggressive (it'd apply even to <code>a &lt;= b</code>).</p>\n</blockquote>\n<p>I think this is fine for the <code>congr' n</code> version where the depth can be specified</p>",
        "id": 338786881,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677664262
    },
    {
        "content": "<p>Another shortcoming of <code>congr</code> is that it does not know about <code>pi_congr</code></p>",
        "id": 338813907,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1677671241
    },
    {
        "content": "<p>Here's a prototype:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>prototype of congr!</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">Copyright (c) 2023 Kyle Miller. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Kyle Miller</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Relation.Rfl</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.RunCmd</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Multiset.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Basic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># The `congr!` tactic</span>\n\n<span class=\"cm\">This is a more powerful version of the `congr` tactic.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Asserts the given congruence theorem as fresh hypothesis, and then applies it.</span>\n<span class=\"sd\">Return the `fvarId` for the new hypothesis and the new subgoals.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">applyCongrThm</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">congrThmType</span> <span class=\"n\">congrThmProof</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mvarId</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.assert</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkFreshUserName</span> <span class=\"bp\">`</span><span class=\"n\">h_congr_thm</span><span class=\"o\">)</span> <span class=\"n\">congrThmType</span> <span class=\"n\">congrThmProof</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">fvarId</span><span class=\"o\">,</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.intro1P</span>\n  <span class=\"k\">let</span> <span class=\"n\">mvarIds</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.apply</span> <span class=\"o\">(</span><span class=\"n\">mkFVar</span> <span class=\"n\">fvarId</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"n\">synthAssignedInstances</span> <span class=\"o\">:=</span> <span class=\"n\">false</span> <span class=\"o\">}</span>\n  <span class=\"n\">mvarIds.mapM</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mvarId.tryClear</span> <span class=\"n\">fvarId</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Try applying user-provided congruence lemmas. If any are applicable,</span>\n<span class=\"sd\">returns a list of new goals.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.MVarId.userCongr</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mvarId.withContext</span> <span class=\"k\">do</span>\n    <span class=\"n\">mvarId.checkNotAssigned</span> <span class=\"bp\">`</span><span class=\"n\">userCongr</span><span class=\"bp\">?</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvarId.getType'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eqOrIff</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">lhs.getAppFn.cleanupAnnotations.constName</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n    <span class=\"k\">let</span> <span class=\"n\">congrTheorems</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getSimpCongrTheorems</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"n\">name</span>\n    <span class=\"c1\">-- Note: congruence theorems are in provided in decreasing order of priority.</span>\n    <span class=\"n\">for</span> <span class=\"n\">congrTheorem</span> <span class=\"k\">in</span> <span class=\"n\">congrTheorems</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span> <span class=\"n\">observing</span><span class=\"bp\">?</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">cinfo</span> <span class=\"bp\">←</span> <span class=\"n\">getConstInfo</span> <span class=\"n\">congrTheorem.theoremName</span>\n        <span class=\"k\">let</span> <span class=\"n\">us</span> <span class=\"bp\">←</span> <span class=\"n\">cinfo.levelParams.mapM</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkFreshLevelMVar</span>\n        <span class=\"k\">let</span> <span class=\"n\">proof</span> <span class=\"o\">:=</span> <span class=\"n\">mkConst</span> <span class=\"n\">congrTheorem.theoremName</span> <span class=\"n\">us</span>\n        <span class=\"k\">let</span> <span class=\"n\">ptype</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateTypeLevelParams</span> <span class=\"n\">cinfo</span> <span class=\"n\">us</span>\n        <span class=\"n\">applyCongrThm</span><span class=\"bp\">?</span> <span class=\"n\">mvarId</span> <span class=\"n\">ptype</span> <span class=\"n\">proof</span>\n      <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">mvars</span> <span class=\"o\">:=</span> <span class=\"n\">res</span> <span class=\"k\">then</span>\n        <span class=\"n\">return</span> <span class=\"n\">mvars</span>\n    <span class=\"n\">return</span> <span class=\"n\">none</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Try to convert an `Iff` into an `Eq` by applying `iff_of_eq`.</span>\n<span class=\"sd\">If successful, returns the new goal, and otherwise returns the original `MVarId`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.MVarId.iffOfEq</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">MVarId</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mvarId.withContext</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">[</span><span class=\"n\">mvarId</span><span class=\"o\">]</span> <span class=\"bp\">←</span> <span class=\"n\">observing</span><span class=\"bp\">?</span> <span class=\"k\">do</span> <span class=\"n\">mvarId.apply</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">iff_of_eq</span> <span class=\"o\">[])</span> <span class=\"bp\">|</span> <span class=\"n\">return</span> <span class=\"n\">mvarId</span>\n    <span class=\"n\">return</span> <span class=\"n\">mvarId</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Try to convert an `Eq` into an `Iff` by applying `propext`.</span>\n<span class=\"sd\">If successful, then returns then new goal, otherwise returns the original `MVarId`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.MVarId.propext</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">MVarId</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mvarId.withContext</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">[</span><span class=\"n\">mvarId</span><span class=\"o\">]</span> <span class=\"bp\">←</span> <span class=\"n\">observing</span><span class=\"bp\">?</span> <span class=\"k\">do</span> <span class=\"n\">mvarId.apply</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">propext</span> <span class=\"o\">[])</span> <span class=\"bp\">|</span> <span class=\"n\">return</span> <span class=\"n\">mvarId</span>\n    <span class=\"n\">return</span> <span class=\"n\">mvarId</span>\n\n<span class=\"sd\">/-- Helper theorem for `LEan.MVar.liftReflToEq`. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Lean.MVarId.rel_of_eq_and_refl</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hxy</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">hxy</span> <span class=\"bp\">▸</span> <span class=\"n\">h</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Use a `refl`-tagged lemma to convert the goal into an `Eq`. If this can't be done, returns</span>\n<span class=\"sd\">the original `MVarId`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.MVarId.liftReflToEq</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">MVarId</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">mvarId.checkNotAssigned</span> <span class=\"bp\">`</span><span class=\"n\">liftReflToEq</span>\n  <span class=\"k\">let</span> <span class=\"n\">tgt</span> <span class=\"bp\">←</span> <span class=\"n\">withReducible</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mvarId.getType'</span>\n  <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">rel</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">tgt</span> <span class=\"bp\">|</span> <span class=\"n\">return</span> <span class=\"n\">mvarId</span>\n  <span class=\"k\">if</span> <span class=\"n\">rel.isAppOf</span> <span class=\"bp\">`</span><span class=\"n\">Eq</span> <span class=\"k\">then</span>\n    <span class=\"c1\">-- No need to lift Eq to Eq</span>\n    <span class=\"n\">return</span> <span class=\"n\">mvarId</span>\n  <span class=\"k\">let</span> <span class=\"n\">reflLemmas</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">Mathlib.Tactic.reflExt.getState</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">getMatch</span> <span class=\"n\">rel</span>\n  <span class=\"n\">for</span> <span class=\"n\">lem</span> <span class=\"k\">in</span> <span class=\"n\">reflLemmas</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span> <span class=\"n\">observing</span><span class=\"bp\">?</span> <span class=\"k\">do</span>\n      <span class=\"c1\">-- First create an equality relating the LHS and RHS</span>\n      <span class=\"c1\">-- and reduce the goal to proving that LHS is related to LHS.</span>\n      <span class=\"k\">let</span> <span class=\"o\">[</span><span class=\"n\">mvarIdEq</span><span class=\"o\">,</span> <span class=\"n\">mvarIdR</span><span class=\"o\">]</span> <span class=\"bp\">←</span>\n            <span class=\"n\">mvarId.apply</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkConstWithFreshMVarLevels</span> <span class=\"bp\">``</span><span class=\"n\">Lean.MVarId.rel_of_eq_and_refl</span><span class=\"o\">)</span>\n        <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n      <span class=\"c1\">-- Then fill in the proof of the latter by reflexivity.</span>\n      <span class=\"k\">let</span> <span class=\"o\">[]</span> <span class=\"bp\">←</span> <span class=\"n\">mvarIdR.apply</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkConstWithFreshMVarLevels</span> <span class=\"n\">lem</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n      <span class=\"n\">return</span> <span class=\"n\">mvarIdEq</span>\n    <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">mvarId</span> <span class=\"o\">:=</span> <span class=\"n\">res</span> <span class=\"k\">then</span>\n      <span class=\"n\">return</span> <span class=\"n\">mvarId</span>\n  <span class=\"n\">return</span> <span class=\"n\">mvarId</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Try to close the goal using `Subsingleton.elim`. Returns whether or not it succeeds.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.MVarId.subsingletonElim</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">[]</span> <span class=\"bp\">←</span> <span class=\"n\">observing</span><span class=\"bp\">?</span> <span class=\"k\">do</span> <span class=\"n\">mvarId.apply</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Subsingleton.elim</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span><span class=\"o\">])</span>\n    <span class=\"bp\">|</span> <span class=\"n\">return</span> <span class=\"n\">false</span>\n  <span class=\"n\">return</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Lean.MVarId.proofIrrelHeq</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">[]</span> <span class=\"bp\">←</span> <span class=\"n\">observing</span><span class=\"bp\">?</span> <span class=\"k\">do</span> <span class=\"n\">mvarId.apply</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">proof_irrel_heq</span> <span class=\"o\">[])</span>\n    <span class=\"bp\">|</span> <span class=\"n\">return</span> <span class=\"n\">false</span>\n  <span class=\"n\">return</span> <span class=\"n\">true</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Try to apply `pi_congr`. This is similar to `Lean.MVar.congrImplies?`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.MVarId.congrPi</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">observing</span><span class=\"bp\">?</span> <span class=\"k\">do</span> <span class=\"n\">mvarId.apply</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkConstWithFreshMVarLevels</span> <span class=\"bp\">``</span><span class=\"n\">pi_congr</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Try to apply `funext`, but only if it is obviously an equality of two functions</span>\n<span class=\"sd\">(we do not want this to apply to equalities of sets).</span>\n<span class=\"sd\">\"Obvious\" means that the type of the terms being equated is a pi type.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.MVarId.obviousFunext</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">observing</span><span class=\"bp\">?</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">tgt</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.getType'</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tgt.eq</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n    <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">forallE</span> <span class=\"bp\">..</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.instantiateMVars</span> <span class=\"n\">ty</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n    <span class=\"n\">mvarId.apply</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkConstWithFreshMVarLevels</span> <span class=\"bp\">``</span><span class=\"n\">funext</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Try to apply `Function.hfunext`, returning the new goals if it succeeds.</span>\n<span class=\"sd\">Like `Lean.MVarId.obviousFunext?`, we only do so if both sides of the `HEq` are terms</span>\n<span class=\"sd\">of pi types. This is to prevent unfolding of things like `Set`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.MVarId.obviousHfunext</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">observing</span><span class=\"bp\">?</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">tgt</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.getType'</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ty1</span><span class=\"o\">,</span> <span class=\"n\">ty2</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tgt.heq</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n    <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">forallE</span> <span class=\"bp\">..</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.instantiateMVars</span> <span class=\"n\">ty1</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n    <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">forallE</span> <span class=\"bp\">..</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.instantiateMVars</span> <span class=\"n\">ty2</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n    <span class=\"n\">mvarId.apply</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkConstWithFreshMVarLevels</span> <span class=\"bp\">``</span><span class=\"n\">Function.hfunext</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The list of passes used by `Lean.MVarId.congrCore!`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.MVarId.congrPasses</span><span class=\"bp\">!</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">MVarId</span> <span class=\"bp\">→</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n  <span class=\"o\">[</span><span class=\"n\">userCongr</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">congr</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">hcongr</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">obviousFunext</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">obviousHfunext</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">congrImplies</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">congrPi</span><span class=\"bp\">?</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Convert a goal into an `Eq` goal if possible (since we have a better shot at those).</span>\n<span class=\"sd\">Also try to dispatch the goal using an assumption, `Subsingleton.Elim`, or definitional equality. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.MVarId.preCongr</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"c1\">-- User congr lemmas might have created additional hypotheses.</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.intros</span>\n  <span class=\"c1\">-- Next, turn `HEq` and `Iff` into `Eq`</span>\n  <span class=\"k\">let</span> <span class=\"n\">mvarId</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.heqOfEq</span>\n  <span class=\"c1\">-- This is a good time to check whether we have a relevant hypothesis.</span>\n  <span class=\"k\">if</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.assumptionCore</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">mvarId</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.iffOfEq</span>\n  <span class=\"c1\">-- Now try definitional equality. No need to try `mvarId.hrefl` since we already did  `heqOfEq`.</span>\n  <span class=\"n\">try</span> <span class=\"n\">withReducible</span> <span class=\"n\">mvarId.refl</span><span class=\"bp\">;</span> <span class=\"n\">return</span> <span class=\"n\">none</span> <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n  <span class=\"c1\">-- Now we go for (heterogenous) equality via subsingleton considerations</span>\n  <span class=\"k\">if</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.subsingletonElim</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n  <span class=\"k\">if</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.proofIrrelHeq</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n  <span class=\"n\">return</span> <span class=\"n\">some</span> <span class=\"n\">mvarId</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Lean.MVarId.congrCore</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> We do `liftReflToEq` here rather than in `preCongr!` since we don't want it to stick</span>\n<span class=\"cm\">     if there are no relevant congr lemmas. -/</span>\n  <span class=\"k\">let</span> <span class=\"n\">mvarId</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.liftReflToEq</span>\n  <span class=\"n\">for</span> <span class=\"n\">pass</span> <span class=\"k\">in</span> <span class=\"n\">congrPasses</span><span class=\"bp\">!</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">mvarIds</span> <span class=\"bp\">←</span> <span class=\"n\">pass</span> <span class=\"n\">mvarId</span> <span class=\"k\">then</span>\n      <span class=\"n\">return</span> <span class=\"n\">mvarIds</span>\n  <span class=\"n\">throwTacticEx</span> <span class=\"bp\">`</span><span class=\"n\">congr</span><span class=\"bp\">!</span> <span class=\"n\">mvarId</span> <span class=\"s2\">\"failed to apply congruence\"</span>\n\n<span class=\"sd\">/-- A pass to clean up after `Lean.MVarId.preCongr!` and `Lean.MVarId.congrCore!`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.MVarId.postCongr</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">mvarId</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.preCongr</span><span class=\"bp\">!</span> <span class=\"bp\">|</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n  <span class=\"c1\">-- Convert `p = q` to `p ↔ q`, which is likely the more useful form:</span>\n  <span class=\"k\">let</span> <span class=\"n\">mvarId</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.propext</span>\n  <span class=\"k\">if</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.assumptionCore</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n  <span class=\"n\">return</span> <span class=\"n\">some</span> <span class=\"n\">mvarId</span>\n\n<span class=\"sd\">/-- A more insistent version of `Lean.MVarId.congrN`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.MVarId.congrN</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">depth</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">1000000</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">go</span> <span class=\"n\">depth</span> <span class=\"n\">mvarId</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n  <span class=\"n\">return</span> <span class=\"n\">s.toList</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">post</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">StateRefT</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">mvarId</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.postCongr</span><span class=\"bp\">!</span> <span class=\"bp\">|</span> <span class=\"n\">return</span>\n    <span class=\"n\">modify</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">push</span> <span class=\"n\">mvarId</span><span class=\"o\">)</span>\n  <span class=\"n\">go</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">StateRefT</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">mvarId</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.preCongr</span><span class=\"bp\">!</span> <span class=\"bp\">|</span> <span class=\"n\">return</span>\n    <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">post</span> <span class=\"n\">mvarId</span>\n      <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">mvarIds</span> <span class=\"bp\">←</span> <span class=\"n\">observing</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">MetaM</span><span class=\"o\">)</span> <span class=\"n\">mvarId.congrCore</span><span class=\"bp\">!</span>\n          <span class=\"bp\">|</span> <span class=\"n\">post</span> <span class=\"n\">mvarId</span>\n        <span class=\"n\">mvarIds.forM</span> <span class=\"o\">(</span><span class=\"n\">go</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">congr</span><span class=\"bp\">!</span><span class=\"o\">)</span> <span class=\"s2\">\"congr! \"</span> <span class=\"o\">(</span><span class=\"n\">num</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">congr</span><span class=\"bp\">!</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">hugeDepth</span> <span class=\"o\">:=</span> <span class=\"mi\">1000000</span>\n  <span class=\"k\">let</span> <span class=\"n\">depth</span> <span class=\"o\">:=</span> <span class=\"n\">n.map</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">getNat</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">getD</span> <span class=\"n\">hugeDepth</span>\n  <span class=\"n\">liftMetaTactic</span> <span class=\"k\">fun</span> <span class=\"n\">g</span> <span class=\"bp\">↦</span> <span class=\"n\">g.congrN</span><span class=\"bp\">!</span> <span class=\"n\">depth</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">inst1</span> <span class=\"n\">inst2</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inst1</span> <span class=\"bp\">=</span> <span class=\"n\">inst2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span> <span class=\"mi\">2</span>\n  <span class=\"c1\">-- ⊢ 1 + n = n + 1</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[congr]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">List.map_congr'</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hfg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">List.map</span> <span class=\"n\">f</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">List.map</span> <span class=\"n\">g</span> <span class=\"n\">ys</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"n\">exact</span> <span class=\"n\">List.map_congr</span> <span class=\"n\">hfg</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ys</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">List.map</span> <span class=\"n\">f</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">List.map</span> <span class=\"n\">g</span> <span class=\"n\">ys</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span>\n  <span class=\"c1\">-- given x : α and x ∈ xs then ⊢ f x = g x</span>\n  <span class=\"n\">subst_vars</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span>\n  <span class=\"c1\">-- ⊢ q ↔ q ∧ r</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hq</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">hq</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">assumption</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">two_mul</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hq</span> <span class=\"o\">:</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">hp</span> <span class=\"n\">hq</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span>\n</code></pre></div>\n</div></div>",
        "id": 338911956,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677692799
    },
    {
        "content": "<p>Along with some examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">inst1</span> <span class=\"n\">inst2</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inst1</span> <span class=\"bp\">=</span> <span class=\"n\">inst2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span> <span class=\"n\">using</span> <span class=\"mi\">2</span>\n  <span class=\"c1\">-- ⊢ 1 + n = n + 1</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[congr]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">List.map_congr'</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hfg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">List.map</span> <span class=\"n\">f</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">List.map</span> <span class=\"n\">g</span> <span class=\"n\">ys</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"n\">exact</span> <span class=\"n\">List.map_congr</span> <span class=\"n\">hfg</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ys</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">List.map</span> <span class=\"n\">f</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">List.map</span> <span class=\"n\">g</span> <span class=\"n\">ys</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span>\n  <span class=\"c1\">-- given x : α and x ∈ xs then ⊢ f x = g x</span>\n  <span class=\"n\">subst_vars</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span>\n  <span class=\"c1\">-- ⊢ q ↔ q ∧ r</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hq</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">hq</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">assumption</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">two_mul</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 338912031,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677692817
    },
    {
        "content": "<p>Features:</p>\n<ul>\n<li>It can apply user <code>congr</code> lemmas</li>\n<li>It can use <code>refl</code> lemmas to lift goals to proving an <code>Eq</code></li>\n<li>It knows about <code>funext</code>, <code>propext</code>, and <code>congr_pi</code></li>\n<li>It knows about <code>Subsingleton</code></li>\n<li>Rather than leaving a goal as <code>p = q</code>, it will turn it back to <code>p &lt;-&gt; q</code></li>\n</ul>",
        "id": 338912343,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677692899
    },
    {
        "content": "<p>There's a bug if you use it on expressions involving <code>Set</code> at the moment, but <code>congr</code> has the same issue (see <a href=\"#narrow/stream/270676-lean4/topic/mkCongrSimp.3F.20error.20for.20Set/near/338881269\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/mkCongrSimp.3F.20error.20for.20Set/near/338881269</a>)</p>",
        "id": 338913405,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677693158
    },
    {
        "content": "<p>One feature I didn't mention is that, to support being able to apply user <code>congr</code> lemmas recursively, it does <code>intros</code> for you. For example, <code>List.map_congr'</code> in the examples has an extra membership hypothesis.</p>\n<p>If you need to name the extra hypotheses, I think a reasonable interface is that you can follow it up with <code>rename_i</code>.</p>",
        "id": 338916315,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677693891
    },
    {
        "content": "<p>Could you also take a list of names via a <code>with</code> clause?</p>",
        "id": 338917232,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1677694149
    },
    {
        "content": "<p>That would make it a lot more complex, since it would need to thread that list of available names through everything.</p>\n<p>I was sort of thinking about how <code>with</code> clauses were a solution to the problem that Lean 3 had no concept of inaccessible names.</p>",
        "id": 338918197,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677694402
    },
    {
        "content": "<p>I remember that in lean3 <code>congr</code> (or <code>congr'</code>) also knows <a href=\"https://leanprover-community.github.io/mathlib_docs/find/proof_irrel_heq\">docs#proof_irrel_heq</a> and <code>ext</code> knows <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.hfunext\">docs#function.hfunext</a>. But in lean4 they do not know.</p>",
        "id": 338949823,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1677702794
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"455791\">@Yuyang Zhao</span> Thanks, I added <code>proof_irrel_heq</code>.</p>\n<p>I why <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.hfunext#doc\">docs4#Function.hfunext</a> isn't tagged with <code>@[ext]</code>. Is this a limitation with <code>ext</code> or due to some other reason?</p>",
        "id": 338951885,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677703528
    },
    {
        "content": "<p><code>ext</code> lemmas in Lean4 are required to output an <code>Eq</code> iirc.</p>",
        "id": 338953616,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1677704162
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 338971085,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1677710783
    },
    {
        "content": "<p>There's a PR for <code>congr!</code>: <a href=\"https://github.com/leanprover-community/mathlib4/pull/2566\">mathlib4#2566</a></p>\n<p>Part of it is changing <code>convert</code> to use it instead of <code>congr</code>, since that's closer to how <code>convert</code> worked in mathlib3, and this is also a good test to see how whether <code>congr!</code> is an improvement.</p>",
        "id": 338986424,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677719560
    },
    {
        "content": "<p>Maybe now's a good time for a request for comment about <code>congr!</code> before I get too much deeper into getting mathlib4 to compile.</p>",
        "id": 338986482,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677719622
    },
    {
        "content": "<p>I've been able to compile mathlib4 locally with the new <code>congr!</code>-powered <code>convert</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/2566\">mathlib4#2566</a></p>",
        "id": 339152983,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677775892
    },
    {
        "content": "<p>It seems to me that there were no regressions (other than needing to be explicit with some universe variables, since otherwise <code>Subsingleton.elim</code> is overly eager to turn <code>Sort _</code> into <code>Prop</code>).</p>",
        "id": 339153377,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677775976
    },
    {
        "content": "<p>Of course, since it's able to dig deeper into expressions sometimes a given <code>convert</code> might now need a <code>using nn</code> to limit it from going too far.</p>",
        "id": 339154198,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677776155
    },
    {
        "content": "<p>Great news!</p>",
        "id": 339169995,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1677780037
    },
    {
        "content": "<p>PLMC = Paris Lean Meta Club</p>\n<p>you guys are our life line <span aria-label=\"life preserver\" class=\"emoji emoji-1f6df\" role=\"img\" title=\"life preserver\">:life_preserver:</span> <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 339170345,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1677780127
    },
    {
        "content": "<p>I'm excited that <code>congr!</code> knows about user congruence lemmas. I'd tried changing <code>congr'</code> to do this in mathlib3, but getting it to work with <code>with</code>-variables in a robust way, and then figuring out how to get mathlib to compile after these changes, it was too much work.</p>",
        "id": 339171440,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677780443
    },
    {
        "content": "<p>Here's an example of what user congruence lemmas give us:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"n\">n</span> <span class=\"k\">in</span> <span class=\"n\">Finset.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">n</span> <span class=\"k\">in</span> <span class=\"n\">Finset.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span> <span class=\"c1\">-- automatically applies Finset.sum_congr</span>\n  <span class=\"n\">rename_i</span> <span class=\"n\">n</span> <span class=\"n\">h</span>\n  <span class=\"c1\">-- h : n ∈ Finset.Icc 0 5</span>\n  <span class=\"c1\">-- ⊢ n - 5 = 0</span>\n  <span class=\"n\">apply</span> <span class=\"n\">tsub_eq_zero_of_le</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 339172764,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677780794
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/congr.20and.20subsingleton.2Eelim/near/339153377\">said</a>:</p>\n<blockquote>\n<p>It seems to me that there were no regressions (other than needing to be explicit with some universe variables, since otherwise <code>Subsingleton.elim</code> is overly eager to turn <code>Sort _</code> into <code>Prop</code>).</p>\n</blockquote>\n<p>This ended up being straightforward to implement a fix. Rather than using <code>Lean.MVarId.apply</code> to apply the <code>Subsingleton.elim</code> lemma, the trick was to take the goal <code>lhs = rhs</code> and use <code>mkAppM ``Subsingleton.elim #[lhs, rhs]</code> and assign the resulting proof directly.</p>\n<p>The key is that <code>mkAppM</code> uses <code>withNewMCtxDepth</code> so it doesn't unify any metavariables. (That way <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instSubsingleton#doc\">docs4#instSubsingleton</a> doesn't give Lean any bright ideas that things would be much easier if that <code>Sort _</code> were just <code>Prop</code>.)</p>",
        "id": 339203374,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677790629
    },
    {
        "content": "<p>I thought I'd mention that I've been working on further improvements to <code>congr!</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/2606\">mathlib4#2606</a>.</p>\n<p>Something I noticed is that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.mkCongrSimp?#doc\">docs4#Lean.Meta.mkCongrSimp?</a> can generate lemmas that are more specialized than you might like. For example, in <code>f x = g y</code> it can only generate lemmas like <code>forall a b, a = b -&gt; f a = f b</code>, where <code>f</code> is the same on both sides. Also, when there are dependent types it can make certain arguments to an application fixed. This is all fine for congr lemmas for simp, but if our aim is to be able to equate every part of the two sides of anything and everything, this isn't sufficient.</p>\n<p>Internally, <code>congr!</code> is happy working with <code>HEq</code>,  so in this PR there's a congruence lemma generator that's similar to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.mkHCongrWithArity#doc\">docs4#Lean.Meta.mkHCongrWithArity</a>, but it has a couple extra features.</p>\n<ol>\n<li>It can make use of <code>Subsingleton</code> instances to omit hypotheses immediately.</li>\n<li>For each successive hypothesis, it includes all the previous equalities between variables this particular argument depends on (so for example, if you want to prove the equality <code>⟨a, x⟩ = ⟨b, y⟩</code> by <code>congr!</code>, the second goal will end up with <code>a = b</code> in the context).</li>\n<li>You can request that the function and/or certain arguments be fixed (we can look at the arguments of the functions we're doing <code>congr!</code> on to see which ones are defeq), which can help produce <code>HEq</code>-free goals.</li>\n</ol>\n<p>This last feature also helps <code>to_additive</code> since the resulting congruence lemma is more amenable to being to-additivized, otherwise you get bare algebraic functions that aren't applied to anything amidst a mess of Eq/HEq recursors.</p>",
        "id": 341164222,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1678556368
    },
    {
        "content": "<p>Sometimes, though, this new congruence generator is <em>too</em> good at finding a way to make two sides of something equal, so the PR also needs to pepper mathlib with <code>using</code> clauses to limit it. I'm also limiting <code>congr!</code>'s ability to unfold definitions by only permitting reducible transparency by default; there are some places where <code>convert</code> was being used to deliberately unfold definitions, in a questionably reliable way, so either these have been rewritten or <code>convert</code> has been given a configuration option to use default transparency.</p>",
        "id": 341164239,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1678556376
    },
    {
        "content": "<p>To give an example of it being too good and doing congruence is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">prime</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">prime</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">prime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"n\">h</span>\n  <span class=\"c1\">-- goal 1: ⊢ HAdd.hAdd = HMul.hMul -- specialized to `Nat -&gt; Nat -&gt; Nat`</span>\n  <span class=\"c1\">-- goal 2: ⊢ n = 2</span>\n</code></pre></div>\n<p>There are two solutions. One is to use <code>using 2</code> to get <code>⊢ n + n = 2 * n</code>. The other is to use a pre-defined collection of configuration options that keep <code>convert</code>/<code>congr!</code> from equating different functions.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">prime</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">prime</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">prime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">unfoldSameFun</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n  <span class=\"c1\">-- goal: ⊢ n + n = 2 * n</span>\n</code></pre></div>\n<p>These options allow definition unfolding at default transparency and also disallow congruence between partially-applied functions, and it makes it behave sort of like <code>congr</code> but with extra bells and whistles. This <code>.unfoldSameFun</code> config is not necessarily better or worse than the default <code>congr!</code> settings, but you can get different results with them, some worse some better.</p>",
        "id": 341164240,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1678556377
    },
    {
        "content": "<p>Something I don't fully understand is a certain pattern I've seen a number of times, where <code>convert</code> is used for <code>Funlike</code> in a seemingly trivial way, for example closing a goal with <code>by convert FunLike.ext_iff.1 hfg using 0</code>.</p>\n<p>In every case, <code>using 0</code> works for these (which means the goal is just closed by <code>Iff.rfl</code>!). I think this is all being used as a fancy way to elaborate without an expected type, but I couldn't get other tricks for this to work in these cases. If anyone is interested, you can look for <code>using 0</code> in the PR.</p>",
        "id": 341164585,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1678556554
    }
]