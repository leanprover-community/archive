[
    {
        "content": "<p>I'm trying to write a positivity extension for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=StarOrderedRing#doc\">docs#StarOrderedRing</a> to make use of things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_star_self_nonneg#doc\">docs#mul_star_self_nonneg</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=conjugate_nonneg#doc\">docs#conjugate_nonneg</a>. By cargo cult coding from the basic positivity extensions, I can make the former work fairly easily. However, when I try to generalize to make it handle multiple forms simultaneously by matching on the expression, I get errors. What am I doing wrong here in the second attempt?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Mathlib.Meta.Positivity</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Expr</span> <span class=\"n\">Qq</span>\n\n<span class=\"sd\">/-- The `positivity` extension which identifies expressions of the form `star a * a`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">positivity</span> <span class=\"n\">_</span> <span class=\"bp\">*</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Mul.mul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">evalStarMul</span> <span class=\"o\">:</span> <span class=\"n\">PositivityExt</span> <span class=\"n\">where</span> <span class=\"n\">eval</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"n\">zα</span> <span class=\"n\">pα</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">_a</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">NonUnitalSemiring</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">_a'</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">StarOrderedRing</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"n\">assumeInstancesCommute</span>\n  <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">))))</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"bp\">←</span> <span class=\"n\">withReducible</span> <span class=\"o\">(</span><span class=\"n\">whnf</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"not *\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">_e_eq</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"bp\">=</span><span class=\"n\">Q</span> <span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">_f_eq</span><span class=\"o\">⟩</span> <span class=\"bp\">←</span> <span class=\"n\">withDefault</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">withNewMCtxDepth</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">assertDefEqQ</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">u.succ</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">HMul.hMul</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">_s_eq</span><span class=\"o\">⟩</span> <span class=\"bp\">←</span> <span class=\"n\">withDefault</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">withNewMCtxDepth</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">assertDefEqQ</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">u.succ</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Star.star</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">_a_eq_b</span><span class=\"o\">⟩</span> <span class=\"bp\">←</span> <span class=\"n\">withDefault</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">withNewMCtxDepth</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">assertDefEqQ</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n  <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nonnegative</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">star_mul_self_nonneg</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">star</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">positivity</span> <span class=\"c1\">-- works! yay!</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">positivity</span> <span class=\"n\">_</span> <span class=\"bp\">*</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Mul.mul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">evalStarMul'</span> <span class=\"o\">:</span> <span class=\"n\">PositivityExt</span> <span class=\"n\">where</span> <span class=\"n\">eval</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"n\">zα</span> <span class=\"n\">pα</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">whnfR</span> <span class=\"n\">e</span>\n  <span class=\"k\">let</span> <span class=\"n\">_inst₁</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">NonUnitalSemiring</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">_inst₂</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">StarOrderedRing</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"n\">assumeInstancesCommute</span>\n  <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">((</span><span class=\"n\">star</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">_a_eq_b</span><span class=\"o\">⟩</span> <span class=\"bp\">←</span> <span class=\"n\">withDefault</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">withNewMCtxDepth</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">assertDefEqQ</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n    <span class=\"k\">let</span> <span class=\"n\">_e_eq</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"bp\">=</span><span class=\"n\">Q</span> <span class=\"o\">(</span><span class=\"n\">star</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n    <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nonnegative</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">star_mul_self_nonneg</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">))</span>\n    <span class=\"c\">/-</span>\n<span class=\"cm\">    type mismatch</span>\n<span class=\"cm\">      star_mul_self_nonneg «$a»</span>\n<span class=\"cm\">    has type</span>\n<span class=\"cm\">      0 ≤ star «$a» * «$a» : Prop</span>\n<span class=\"cm\">    but is expected to have type</span>\n<span class=\"cm\">      0 ≤ $e✝ : Prop</span>\n<span class=\"cm\">    -/</span>\n</code></pre></div>",
        "id": 401438114,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1699650556
    },
    {
        "content": "<p>Separate but connected question: is it possible to make <code>positivity</code> attributes scoped? when I tried to do that I got \"invalid attribute <code>positivity</code>, must be global\"</p>",
        "id": 401438393,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1699650784
    },
    {
        "content": "<p>It was the case in Lean 3. Not anymore <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 401438658,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699651012
    },
    {
        "content": "<p>nevermind, this is just because I called it <code>e</code> again in the first <code>let</code> so the original was inaccessible. Ignore the noise.</p>",
        "id": 401439556,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1699651746
    },
    {
        "content": "<p>Why can't it be scoped anymore?</p>",
        "id": 401440418,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1699652446
    },
    {
        "content": "<p>No clue. Probably it simply hasn't been implemented?</p>",
        "id": 401440439,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699652474
    },
    {
        "content": "<p>scoped extensions have to be implemented individually, it's just a matter of implementation work</p>",
        "id": 401440444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699652476
    },
    {
        "content": "<p>it's also a bit slower/more complicated than global-only attributes</p>",
        "id": 401440467,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699652506
    },
    {
        "content": "<p>See <code>Std.Tactic.LabelAttr</code> for a minimal example of how to set up removable attributes.</p>\n<p>(These label attributes are for cases where we're not doing any work when adding the attribute: we just need to know if it is there or not.)</p>\n<p>Someone needs to add this functionality to the positivity attribute.</p>",
        "id": 401452565,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1699662119
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 401457406,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1699664721
    }
]