[
    {
        "content": "<p>I would like to add an API for divisors, a standard tool in complex analysis to keep track of pole/vanishing orders of meromorphic objects, typically functions or differential forms. In principle that is very easy: the textbook definition for a divisor on a domain <code>U</code> is a function to <code>ℤ</code> whose support is locally finite in <code>U</code>. In lean, I guess this translates to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Divisor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ</span>\n<span class=\"w\">  </span><span class=\"n\">supportInU</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">U</span>\n<span class=\"w\">  </span><span class=\"n\">supportDiscreteWithinU</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"bp\">=ᶠ</span><span class=\"o\">[</span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">codiscreteWithin</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Divisor</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Divisor</span><span class=\"bp\">.</span><span class=\"n\">toFun</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">coe</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Divisor</span><span class=\"bp\">.</span><span class=\"n\">toFun</span>\n</code></pre></div>\n<p>I think that I should give the set of divisors the structure of a partially ordered group, so users can work with standard tactics on expressions involving divisors. I am, however, fairly new to lean and struggling to set up the necessary structures/classes/types/instances correctly. Any help is greatly appreciated. </p>\n<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  You probably know the answer to my question right away ... perhaps you could point me to code that I can copy, or help me with a little template that I can use as a starting point? Thanks!</p>",
        "id": 499997150,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1739699903
    },
    {
        "content": "<p>There are indeed plenty of examples in mathlib. If you look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFunLike#doc\">docs#DFunLike</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SetLike#doc\">docs#SetLike</a> and uncollapse \"Instances\", you will be given a list of similar constructions</p>",
        "id": 499997371,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1739700123
    },
    {
        "content": "<p>Hopefully that's enough to get you started. Feel free to come back with more specific questions once you have them <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 499997412,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1739700152
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Thanks for your very quick answer, I will look at this ... and probably come back to you soon.</p>",
        "id": 499998101,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1739700834
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"679664\">@Stefan Kebekus</span> Do you know about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp#doc\">docs#Finsupp</a> ?</p>",
        "id": 500000607,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1739703144
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> No, I did not know that. That seems like code I can easily copy, thank you!</p>\n<p>... und schöne Grüße nach Bayreuth.</p>",
        "id": 500000753,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1739703278
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">}</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">→₀</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- Finsupp.instAddCommGroup</span>\n</code></pre></div>\n<p>It comes with an abelian group instance <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> <br>\n(But note that here <code>U</code> is promoted to a subtype of <code>ℂ</code>.)</p>\n<p>Grüße nach Freiburg!</p>",
        "id": 500000906,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1739703393
    },
    {
        "content": "<p>(I realize that you want discrete, not finite, though. So you will indeed have to copy and adapt the code.)</p>",
        "id": 500001033,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1739703533
    },
    {
        "content": "<p>Yes, I will need to adapt. But maybe this is now doable...</p>",
        "id": 500001063,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1739703574
    },
    {
        "content": "<p>The API for divisors is now available as <a href=\"https://github.com/leanprover-community/mathlib4/pull/22357\">PR 22357</a>. Thanks to everyone for your generous help.</p>\n<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> If you have the time for a review…</p>",
        "id": 502207686,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1740638793
    },
    {
        "content": "<p>Maybe more generally you should define <code>locally of finite support function</code> as a generalization to <code>Finsupp</code>?</p>",
        "id": 502331025,
        "sender_full_name": "Jz Pan",
        "timestamp": 1740674762
    },
    {
        "content": "<p>The API for divisors is now available in mathlib. Thank you for all your help!  As soon as PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/22292\">#22292</a> (characterize level sets of the order for analytic/meromorphic functions) is reviewed and merged, I can define the divisor of a meromorphic function.</p>",
        "id": 504374949,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1741514139
    },
    {
        "content": "<p>I was discussing algebraic cycles with <span class=\"user-mention\" data-user-id=\"673690\">@Raphael Douglas Giles</span> the other day. And it turns out that if <code>X</code> is a scheme, then an algebraic cycle on <code>X</code> is exactly the same as your <code>Divisor X</code> (except that <code>X</code> is not a topological field).</p>\n<p>So I'm coming around to the idea that maybe we should drop that field condition from your definition. Of course it would be weird to call it <code>Divisor</code> when <code>X</code> is a higher dimensional scheme, because we're now also talking about algebraic cycles in higher degrees (aka codimension).</p>\n<p>After all, an algebraic cycle (non-homogeneous, because we'll add the grading by subgroups later) is a formal sum of integral closed subschemes, but we might as well take a formal sum of the generic points.<br>\nAnd the sum has to be locally finite, but that's exactly the condition that you also have.<br>\nAnd a sum of generic points is locally finite if and only if the sum of integral closed subschemes is locally finite.</p>",
        "id": 505818473,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742021795
    },
    {
        "content": "<p>This reminds me of Fulton's <em>Intersection Theory</em></p>\n<p><a href=\"/user_uploads/3121/mvUyKuwH6UQ7De1qeagWh7V5/2025-03-15-153149.png\">2025-03-15 153149.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/mvUyKuwH6UQ7De1qeagWh7V5/2025-03-15-153149.png\" title=\"2025-03-15 153149.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"936x227\" src=\"/user_uploads/thumbnail/3121/mvUyKuwH6UQ7De1qeagWh7V5/2025-03-15-153149.png/840x560.webp\"></a></div>",
        "id": 505820844,
        "sender_full_name": "Jz Pan",
        "timestamp": 1742023933
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I think you are right, the proposed definition for \"cycle\" will work on analytic spaces and analytic schemes, modulo the question of whether \"locally finite\" or \"discrete\" is the correct definition [would have to think]. I guess the same (or something very close) will also work in more general settings [ind-schemes, algebraic spaces, stacks, Riemann-Zariski-Spaces, Berkovich analytic spaces, p-Adic nonarchimedian, …]. But we have no definition for a super-type that comprises all these spaces.</p>",
        "id": 505839353,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1742038687
    },
    {
        "content": "<p>Dear all, in private communication with Comellin, we considered the following way out: We rename \"DivisorOn U\" and make ourselves honest by calling it what it really is: \"Function.discretesuppWithin U ℤ\", defined for arbitrary topological spaces. The method \"MeromorphicOn.divisor f U\" will then simply return an object of type \"Function.discretesuppWithin U ℤ\", which is no big deal.</p>",
        "id": 505839412,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1742038747
    },
    {
        "content": "<p>If people here agree to this suggestion, I would be glad to implement that. To avoid chaos, I would however wait until <a href=\"https://github.com/leanprover-community/mathlib4/pull/22819\">PR 22819</a> is merged.</p>",
        "id": 505840477,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1742039560
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"366779\">@Jz Pan</span> Thanks for pointing that out! Note, however, that the setting is more involved in the complex analytic case we consider here. The topological space underlying a complex space is more involved and definitively not Noetherian. This brings up the \"local finiteness\" condition that is so much easier in algebraic geometry.</p>",
        "id": 505840682,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1742039713
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I started implementing this suggestion, but I got a little stuck. Could you please have a look at the file <code>Mathlib/Analysis/Meromorphic/Divisor/Basic.lean</code> in branch <code>origin/kebekus/divisor.2</code>? </p>\n<p>Never mind the file name and the out-of-date docstrings … there are a few lines that do not compile, and I cannot fix that because I have no clue what your optimized code is doing.</p>\n<p>Thanks!</p>",
        "id": 507706066,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1742810454
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"679664\">@Stefan Kebekus</span> I took the liberty of pushing a tiny patch directly to that branch.</p>",
        "id": 507720515,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742813731
    },
    {
        "content": "<p>To fix the final error, I changed <code>OrderedAddCommGroup</code> to <code>LinearOrderedAddCommGroup</code>. Because the latter is a <code>Lattice</code>, while the former is not...</p>",
        "id": 507721984,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742814046
    },
    {
        "content": "<p>I don't know if this still matches your intentions.</p>",
        "id": 507722040,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742814060
    },
    {
        "content": "<p>Thanks for the quick &amp; helpful response! That was exactly what I needed.</p>",
        "id": 507727914,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1742815403
    },
    {
        "content": "<p>I'm wondering, for the application of this stuff to algebraic cycles on schemes, should we change the condition that the support is discrete to say that the support is locally finite (and then in your case where k is a T1 space using your theorem to translate into your current definition)? I think in the case of schemes these definitions shouldn't be equivalent, but maybe I'm missing something</p>",
        "id": 507728193,
        "sender_full_name": "Raphael Douglas Giles",
        "timestamp": 1742815460
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"673690\">@Raphael Douglas Giles</span> Message arrived. I will need a while to think.</p>",
        "id": 507728640,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1742815551
    },
    {
        "content": "<p>I have now implemented Johan's and Raphael's suggestions -- there is a new type class <code>Function.locallyFinsuppWithin</code> and two files, <code>Mathlib/Analysis/Analytic/Divisor.lean</code> and <code>Mathlib/Analysis/Meromorphic/Divisor.lean</code> that define divisors for analytic functions in one variable and for meromorphic functions, respectively. The code now uses the new method <code>WithTop.untop₀</code> that was discussed earlier in a different thread.</p>\n<p>The result is available as PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/23296\">#23296</a>.</p>\n<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> If you can find some time to look at the PR…</p>",
        "id": 508008131,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1742905557
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"679664\">@Stefan Kebekus</span> Thanks! Do you think it's easy to do the renaming in a separate PR? That should be a quick merge. And then the diff of this PR will be much smaller.</p>",
        "id": 508019802,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742908644
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Thanks for the prompt reply. I am unsure what precisely \"renaming\" refers to.</p>\n<ul>\n<li>Renaming of the file? -- Probably yes. </li>\n<li>Renaming of the type class? -- Probably no, for two reasons. First: the type class is used in the *Divisor.lean files. Second: Following Raphael's suggestion, we also change the API from \"disceteWithin\" to the new \"locallyFinsuppWithin\". This is reflected by changes in the construction of the divisor.<br>\nI am unsure if that answers your questions. Does it?</li>\n</ul>",
        "id": 508030380,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1742911176
    },
    {
        "content": "<p>Just the file rename should already help make the diff of the current PR more legible.<br>\nIn fact, I'm surprised that <code>git</code> doesn't recognize this as a rename...</p>",
        "id": 508031232,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742911338
    },
    {
        "content": "<p>Ok. I will see what I can do and come back to you.</p>",
        "id": 508031384,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1742911367
    },
    {
        "content": "<p>Merci!</p>",
        "id": 508031678,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742911429
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  Voliá. Here is a new PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/23302\">#23302</a>.</p>",
        "id": 508039930,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1742913130
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"679664\">@Stefan Kebekus</span> Thanks! That diff is much easier to review.</p>",
        "id": 508042937,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742913779
    },
    {
        "content": "<p>3 small comments, but basically ready to merge.</p>",
        "id": 508042976,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742913788
    },
    {
        "content": "<p>Small comments are addressed.</p>",
        "id": 508044870,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1742914161
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Files are moved to their final location in PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/23328\">#23328</a>.</p>",
        "id": 508195513,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1742973043
    }
]