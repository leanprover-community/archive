[
    {
        "content": "<p>Can anything be done to avoid this? This code</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">ProbabilityTheory</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>produces</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Ambiguous</span><span class=\"w\"> </span><span class=\"n\">term</span>\n<span class=\"w\">  </span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span>\n<span class=\"n\">Possible</span><span class=\"w\"> </span><span class=\"n\">interpretations</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">‚à´</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">8</span><span class=\"w\"> </span><span class=\"bp\">‚àÇ?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">6</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n\n<span class=\"w\">  </span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span>\n</code></pre></div>\n<p>but I'd like it to produce</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">prove</span><span class=\"w\"> </span><span class=\"n\">index</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">valid</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">possible</span><span class=\"w\"> </span><span class=\"n\">solutions</span><span class=\"o\">:</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>(continued from <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/Kernel.20error.20in.20list.20index.20notation/near/540125047\">#lean4 &gt; Kernel error in list index notation @ üí¨</a> )</p>",
        "id": 540216773,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758197391
    },
    {
        "content": "<p>Can the elaborator for <code>‚à´</code> tell Lean that it certainly isn't a match, and let Lean try the other syntax instead?</p>",
        "id": 540216929,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758197440
    },
    {
        "content": "<p>Beating a dead horse here, but yes, something can be done to avoid this: don't use <code>[ ]</code> in any notations besides getElem and List!</p>",
        "id": 540218196,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1758197755
    },
    {
        "content": "<p>Would <code>Lean.Elab.throwUnsupportedSyntax</code> if we can't type <code>L</code> as a <code>Measure</code> work here?</p>",
        "id": 540218656,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758197879
    },
    {
        "content": "<p>Oh, maybe the other answer here is that we should define a <code>GetElem</code> instance for measures?</p>",
        "id": 540218807,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758197920
    },
    {
        "content": "<p>What could we use in the probability notation, that looks somewhat like standard math (so looks like the current P[...] notation) and is not some weird unicode thing that looks like [ ] but isn't?</p>",
        "id": 540218869,
        "sender_full_name": "R√©my Degenne",
        "timestamp": 1758197938
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Probability.20theorem.20notation.20clashes.20with.20GetElem/near/540218807\">said</a>:</p>\n<blockquote>\n<p>Oh, maybe the other answer here is that we should define a <code>GetElem</code> instance for measures?</p>\n</blockquote>\n<p>This has the weirdness that it doesn't expand directly to the integral, and we have to rewrite back and forth with <code>GetElem</code></p>",
        "id": 540220193,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758198337
    },
    {
        "content": "<p>Somehow I failed to minimise it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Expectation</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Real</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">ProbabilityTheory</span>\n\n<span class=\"c1\">-- https://github.com/leanprover-community/mathlib4/blob/ea6efff623794bdbaf004a17d17eb98316155442/Mathlib/Probability/Notation.lean#L48</span>\n<span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"kn\">macro</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">noWs</span><span class=\"w\"> </span><span class=\"s2\">\"[\"</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"s2\">\"]\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Expectation</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">P</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">ProbabilityTheory</span>\n\n<span class=\"c1\">-- failed to prove index is valid ...</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">ProbabilityTheory</span>\n\n<span class=\"c1\">-- ‚ä¢ Expectation i L = Expectation i L</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 540220334,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758198379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Probability.20theorem.20notation.20clashes.20with.20GetElem/near/540218196\">said</a>:</p>\n<blockquote>\n<p>Beating a dead horse here, but yes, something can be done to avoid this: don't use <code>[ ]</code> in any notations besides getElem and List!</p>\n</blockquote>\n<p>I can't test it yet (because I failed to minimise it above), but I think in my experience with the other PR it seems to work if we put <code>atomic(\"[\" stuff \"]\")</code></p>",
        "id": 540220436,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758198412
    },
    {
        "content": "<p>also just generally I disagree with this suggestion</p>",
        "id": 540220659,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758198479
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350992\">R√©my Degenne</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Probability.20theorem.20notation.20clashes.20with.20GetElem/near/540218869\">said</a>:</p>\n<blockquote>\n<p>What could we use in the probability notation, that looks somewhat like standard math (so looks like the current P[...] notation) and is not some weird unicode thing that looks like [ ] but isn't?</p>\n</blockquote>\n<p>Possibly something like <code>ùîº[X; P]</code> (which mimics <code>Var[X; P]</code>)?</p>",
        "id": 540222125,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1758198913
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Probability.20theorem.20notation.20clashes.20with.20GetElem/near/540220334\">said</a>:</p>\n<blockquote>\n<p>Somehow I failed to minimise it:</p>\n</blockquote>\n<p>Maybe Lean gives priority to notation defined in the current file when it's otherwise unclear?</p>",
        "id": 540225869,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758200003
    },
    {
        "content": "<p>I think it's because <code>Expectation</code> is too simple</p>",
        "id": 540227129,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758200358
    },
    {
        "content": "<p>could you please try to minimise it?</p>",
        "id": 540227458,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758200447
    },
    {
        "content": "<p>i added <code>[Field Œ≤]</code> to <code>Expectation</code> but still didn't get the same error message</p>",
        "id": 540227573,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758200480
    },
    {
        "content": "<p>I'd think that if you're defining a <code>term noWs \"[\" term \"]\"</code> syntax, you can't have that and have the list indexing notation at the same time. (Note that this problem doesn't apply to the polynomial notation that we're working on now, because in that notation the thing between the square brackets does not parse as a <code>term</code>)</p>",
        "id": 540228409,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758200712
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatCast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Wrapper</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œº</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">macro</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">noWs</span><span class=\"w\"> </span><span class=\"s2\">\"[\"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"s2\">\"]\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ambiguous</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 540228736,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758200783
    },
    {
        "content": "<p>thanks!</p>",
        "id": 540228771,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758200794
    },
    {
        "content": "<p>and <code>atomic</code> doesn't solve it...</p>",
        "id": 540228936,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758200836
    },
    {
        "content": "<p>I think you have to have the parsing for the notation exactly match the GetElem one</p>",
        "id": 540229207,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758200912
    },
    {
        "content": "<p>I can't work out the relevance of <code>NatCast</code> here...</p>",
        "id": 540232319,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758201742
    },
    {
        "content": "<p><code>set_option trace.Meta.synthInstance true</code> has some surprising outputs</p>",
        "id": 540232358,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758201753
    },
    {
        "content": "<p>Wow, that's interesting. It's looking for a way to coerce <code>List Nat</code> into <code>Wrapper ?_</code>. For that it asks if anything coerces into <code>Wrapper ?_</code>. And it finds your instance, showing that <code>Nat</code> may coerce to it. Importantly, this means that it gets stuck, instead of failing outright. And if all possible options get stuck, then the parsing is ambiguous.</p>",
        "id": 540234141,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758202200
    },
    {
        "content": "<p>Indeed, <code>instance {Œ± : Type} : Coe Œ± (Wrapper Œ±) := sorry</code> is sufficient to trigger this</p>",
        "id": 540239053,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758203337
    },
    {
        "content": "<p>And in fact, the trouble with the probability notation can be fixed with</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gd\">-scoped macro:max P:term noWs \"[\" X:term \"]\" : term =&gt; `(‚à´ x, ‚Üë($X x) ‚àÇ$P)</span>\n<span class=\"gi\">+scoped macro:max P:term noWs \"[\" X:term \"]\" : term =&gt; `(‚à´ x, $X x ‚àÇ$P)</span>\n</code></pre></div>\n<p>though presumably this causes issues elsewhere</p>",
        "id": 540240491,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758203682
    },
    {
        "content": "<p>we can change the <code>(priority :=</code> of the macros right</p>",
        "id": 540242692,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758204262
    },
    {
        "content": "<p>Priority on notation I believe means that if one fails the other is never tried</p>",
        "id": 540246277,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758205163
    },
    {
        "content": "<p>Having realized that actually this isn't a blocker for me, I think what I'd like to see here is that the error message is extended to something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Ambiguous</span><span class=\"w\"> </span><span class=\"n\">term</span>\n<span class=\"w\">  </span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span>\n<span class=\"n\">Possible</span><span class=\"w\"> </span><span class=\"n\">interpretations</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">‚à´</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">8</span><span class=\"w\"> </span><span class=\"bp\">‚àÇ?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">6</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n<span class=\"w\">    </span><span class=\"n\">which</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"o\">:</span>\n<span class=\"w\">       </span><span class=\"n\">could</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">synthesize</span><span class=\"w\"> </span><span class=\"n\">placeholder</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"w\">  </span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span>\n<span class=\"w\">    </span><span class=\"n\">which</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"o\">:</span>\n<span class=\"w\">       </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">prove</span><span class=\"w\"> </span><span class=\"n\">index</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">valid</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">possible</span><span class=\"w\"> </span><span class=\"n\">solutions</span><span class=\"o\">:</span>\n</code></pre></div>\n<p>Is this possible given the semantics of overloaded notation, or do I have an incorrect mental model of the elaboration order?</p>",
        "id": 540353282,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758242600
    },
    {
        "content": "<p>(in fact the kernel issue was the problem that mattered, which is now fixed)</p>",
        "id": 540353313,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758242622
    },
    {
        "content": "<p>Somehow I'd be happier using a notation if it did not <em>always</em> cause a nonsensical type class search for <code>GetElem</code></p>",
        "id": 540379168,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758261922
    },
    {
        "content": "<p>Does that happen here even if the probability interpretation elaborates correctly?</p>",
        "id": 540402261,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758271114
    },
    {
        "content": "<p>If the priority is the same, doesn't it need to try elaborating both syntaxes to see whether there is an ambiguity?</p>",
        "id": 540445569,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758285575
    }
]