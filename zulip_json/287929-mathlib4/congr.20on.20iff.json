[
    {
        "content": "<p>Currently <code>congr</code> can break down goals of the form <code>f as = f bs</code> and <code>HEq (f as) (f bs)</code>, is it possible / desirable to extend this to goals of the form <code>f as ↔ f bs</code>?</p>",
        "id": 496171922,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1737997519
    },
    {
        "content": "<p><code>congr!</code> can do that</p>",
        "id": 496176013,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737998735
    },
    {
        "content": "<p>congr! can!</p>",
        "id": 496176083,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1737998760
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">congr!</span>\n</code></pre></div>",
        "id": 496176212,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1737998788
    },
    {
        "content": "<p>I'm not sure there are any cases where you want to use <code>congr</code> instead of <code>congr!</code>, though there are some extensions to <code>congr</code> syntax that are sometimes convenient, like the ones for doing <code>ext1</code> between congr steps.</p>",
        "id": 496176549,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737998888
    },
    {
        "content": "<p>While <code>congr!</code> doesn't have that feature, it does have the ability to apply funext automatically, to enter lambdas. It can enter foralls too.</p>",
        "id": 496176698,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737998940
    },
    {
        "content": "<p>Oops, I should have known that! I was already using the fact that <code>congr</code> can apply <code>funext</code> <del>: I generally use <code>congr</code> rather than <code>congr!</code> since it can enter lambdas and it gives me finer control over which <code>ext</code> lemmas get used, which I often need.</del> (edit: might be misremembering here)</p>",
        "id": 496177157,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1737999069
    },
    {
        "content": "<p>Thanks both!</p>",
        "id": 496177175,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1737999072
    },
    {
        "content": "<p>Could you give an example of where the ext feature is helpful? (By the way, <code>congr!</code> accepts rcases patterns in its <code>with</code> clause.)</p>",
        "id": 496181786,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738000566
    },
    {
        "content": "<p>Yes the rcases patterns are super useful! I don't have a concrete example to hand - I will try to remember this and provide one the next time it shows up - but the general pattern is that the <code>ext</code> goes too far. For instance, if I have a goal about the equality of the cardinality of two sets, it might congr into a set equality, then use extensionality and give me some elements; but I'd rather stay on the level of equality of sets because I have other hypotheses involving set equalities.</p>",
        "id": 496182724,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1738000873
    },
    {
        "content": "<p>Can't you control this with the numeric argument? Or does that only control the matching depth not the ext depth?</p>",
        "id": 496183217,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738001032
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/congr.20on.20iff/near/496183217\">said</a>:</p>\n<blockquote>\n<p>Or does that only control the matching depth not the ext depth?</p>\n</blockquote>\n<p>Exactly this, I believe. Although now that I think about it, I'm only going off the fact that <code>congr</code> documentation tells you how to control both, and <code>congr!</code> documentation doesn't tell me how to control the ext depth, so I assumed it doesn't let me. I'm not sure I ever properly checked if it does!</p>",
        "id": 496183308,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1738001055
    },
    {
        "content": "<p><code>congr!</code> depth controls funext depth too; it counts funext as a congr step</p>",
        "id": 496185211,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738001753
    },
    {
        "content": "<p>Okay I managed to dig out an example where I use <code>congr 1 with ...</code> then finish the proof with a simp + aesop call, but (after a couple of attempts) none of the obvious options in congr! make the proof work as cleanly. Would it be useful to minimise this?</p>",
        "id": 496186059,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1738002045
    },
    {
        "content": "<p>Possibly!</p>",
        "id": 496186168,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738002081
    },
    {
        "content": "<p>Or at least it could be useful to know what at a high level <code>congr ... with</code> is doing that is useful.</p>",
        "id": 496186254,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738002109
    },
    {
        "content": "<p>It seems to me like <code>congr! 1 with</code> is not going far enough, and <code>congr! 2 with</code> is going too far, but <code>congr 1 with</code> is getting it exactly where I want</p>",
        "id": 496186491,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1738002189
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Card</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">ncard</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">Coprime</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">Coprime</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">ncard</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- congr! 1 with ⟨a, b⟩</span>\n<span class=\"w\">  </span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"c1\">-- congr! 2 with ⟨a, b⟩</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">mk_one_one</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span>\n</code></pre></div>\n<p>Here is the example as I currently have it - I hope this is small enough to make it clear to you what's going on?</p>",
        "id": 496187465,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1738002507
    },
    {
        "content": "<p>I see. Doing <code>ext</code> is sort of problematic, because it's a step that goes in the opposite direction of  congr, and it would cause infinite loops.</p>\n<p>Here's how you can do it as separate steps:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">Coprime</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">ncard</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">congr!</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">mk_one_one</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span>\n</code></pre></div>\n<p>In more detail, <code>congr! 1; ext ⟨a, b⟩</code> is doing what <code>congr 1 with ⟨a, b⟩</code> is doing, and the result is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">{(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">Coprime</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"bp\">↔</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">{(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">Coprime</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Applying <code>congr! 1</code> to this brings us right back to the goal before the first <code>congr! 1</code>.</p>\n<p>By the way, funext in <code>congr!</code> is handled carefully. It is sure to only try funext if at least one of the two sides of the equality is a <code>fun</code>. Since otherwise, if it starts with <code>f = g</code> and uses <code>funext</code> to turn it into <code>f x = g x</code>, then the next congr step reduces this to <code>f = g</code>, and we loop.</p>",
        "id": 496192152,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738004160
    },
    {
        "content": "<p>I see, thanks for the explanation. Nonetheless I hope this makes it clearer why the behaviour of <code>congr</code> is sometimes more convenient in practice: I end up with a shorter proof, and I can use the fact that congr/congr! can do an ext step rather than needing to do it manually with <code>ext</code></p>",
        "id": 496192704,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1738004347
    },
    {
        "content": "<p>Is using a <code>with</code> clause to tack on a \"free\" <code>ext</code> shorter? You still have to write <code>with</code>.</p>\n<p>I'm not sure I understand the logic of making <code>congr</code> use <code>ext</code> per se. Why not have special clauses for other tactics too?</p>\n<p>Or, why not <code>congr! 1; ext ⟨a, b⟩</code>, which is the same number of characters as <code>congr! 1 with ⟨a, b⟩</code>?</p>",
        "id": 496193354,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738004583
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/congr.20on.20iff/near/496193354\">said</a>:</p>\n<blockquote>\n<p>I'm not sure I understand the logic of making <code>congr</code> use <code>ext</code> per se. Why not have special clauses for other tactics too?</p>\n</blockquote>\n<p>Isn't this precisely what <code>congr!</code> does here too? As you mentioned earlier:</p>\n<blockquote>\n<p>While <code>congr!</code> doesn't have that feature, it does have the ability to apply funext automatically, to enter lambdas.</p>\n</blockquote>\n<p>Or am I misunderstanding your meaning somewhere?</p>",
        "id": 496193892,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1738004783
    },
    {
        "content": "<p>Similarly, <code>congr!</code> also uses <code>with</code> notation, so both of these points apply equally to <code>congr</code> and <code>congr!</code>. The distinction - to me - is that these two tactics both apply congruence lemmas and extensionality lemmas in various ways, and in the situation above one of them works while the other fails. One of the features of <code>congr!</code> according to its documentation is that it uses funext, and similarly for <code>congr</code>: I personally would prefer to use a congruence + funext tactic in a way which doesn't require me to use funext myself.</p>",
        "id": 496194811,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1738005182
    },
    {
        "content": "<p>This is the subtle detail:<br>\n<span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/congr.20on.20iff/near/496192152\">said</a>:</p>\n<blockquote>\n<p>By the way, funext in <code>congr!</code> is handled carefully. It is sure to only try funext if at least one of the two sides of the equality is a <code>fun</code>. Since otherwise, if it starts with <code>f = g</code> and uses <code>funext</code> to turn it into <code>f x = g x</code>, then the next congr step reduces this to <code>f = g</code>, and we loop.</p>\n</blockquote>\n<p>It's not that it uses extensionality exactly, but that it's willing to eta expand one side to make it possible to use funext. It won't eta expand both sides.</p>\n<p>Funext for <code>congr!</code> means transforming</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">|-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>into</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"bp\">|-</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">B</span>\n</code></pre></div>\n<p>The <code>with</code> clause is purely for naming (and possibly destructuring) the introduced <code>x</code>.</p>",
        "id": 496199689,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738007103
    },
    {
        "content": "<p>The <code>congr ... with</code>'s notion of extensionality is more like eta expanding both sides, which is problematic as it goes in the exact opposite direction of what <code>congr</code> is trying to do.</p>",
        "id": 496199820,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738007155
    },
    {
        "content": "<p>I think I see now - you're saying that <code>congr!</code> isn't meant to be viewed as \"congruence and extensionality\", but instead \"congruence and extensionality in certain cases\".</p>",
        "id": 496200897,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1738007538
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/congr.20on.20iff/near/496199820\">said</a>:</p>\n<blockquote>\n<p>The <code>congr ... with</code>'s notion of extensionality is more like eta expanding both sides, which is problematic as it goes in the exact opposite direction of what <code>congr</code> is trying to do.</p>\n</blockquote>\n<p>Is there a plan to deprecate / disallow <code>congr</code> because of it being problematic in this way?</p>",
        "id": 496200984,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1738007570
    },
    {
        "content": "<p>Playing with it some more in the example you give, I wonder why</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>doesn't loop, similarly with <code>congr 3 with x</code>, <code>congr 4 with x</code> etc.</p>",
        "id": 496201147,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1738007635
    },
    {
        "content": "<p>Ah, it's just a macro for <code>congr &lt;;&gt; ext x</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">macro_rules</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">cfg</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">depth</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ps</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">cfg</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">depth</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ps</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">cfg</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">cfg</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">depth</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ps</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">[:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 496202665,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738008164
    },
    {
        "content": "<p>That explains it! And <code>rcongr</code> instead detects when the loop can happen and quits</p>",
        "id": 496203019,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1738008284
    },
    {
        "content": "<p>I didn't even know <code>rcongr</code> existed.</p>",
        "id": 496203396,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738008434
    }
]