[
    {
        "content": "<p>Hi everyone.</p>\n<p>How does the proof of  <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Defs.html#Filter.filter_eq\">#filter_eq</a> works?</p>\n<p>In general, if you have a class where one field is the \"base set\" for the class, how can you prove that two terms of that class type are equal when the underlying sets are equal?</p>\n<p>Thanks in advance for the answers.</p>",
        "id": 486256271,
        "sender_full_name": "Esteban Martínez Vañó",
        "timestamp": 1733389744
    },
    {
        "content": "<p>All fields of the <code>Filter</code> structure except for <code>sets</code> are propositions so their values are equal by definition when you have two filters, and the Lean kernel knows this. That’s why the proof is so automatic.</p>",
        "id": 486259755,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1733390933
    },
    {
        "content": "<p>The usual approach to such proofs is to use the <code>ext</code> attribute to auto-generate the proof. The reason why we don’t use it here is because we want the extensionality lemmas to be stated in terms of <code>∈</code> instead of <code>.sets</code>.</p>",
        "id": 486259950,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1733390992
    },
    {
        "content": "<p>You can read documentation about the <code>ext</code> attribute at <a href=\"https://github.com/leanprover/lean4/blob/ffac974dba799956a97d63ffcb13a774f700149c/src/Lean/Elab/Tactic/Ext.lean\">https://github.com/leanprover/lean4/blob/ffac974dba799956a97d63ffcb13a774f700149c/src/Lean/Elab/Tactic/Ext.lean</a></p>",
        "id": 486260320,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1733391086
    },
    {
        "content": "<p>I see.</p>\n<p>So, for example, if I define the following class</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PFilter</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">point</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"n\">point_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">point</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"n\">point_in</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">sets</span>\n</code></pre></div>\n<p>I know how to prove the lemma</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PFilter</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">sets</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">sets</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">G</span>\n</code></pre></div>\n<p>using the <code>ext</code> tactic, but how can it be proven if we don't use it?</p>",
        "id": 486263563,
        "sender_full_name": "Esteban Martínez Vañó",
        "timestamp": 1733392075
    },
    {
        "content": "<p>You can do <code>cases</code> on <code>F</code> and <code>G</code> to start</p>",
        "id": 486280160,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733397285
    },
    {
        "content": "<p>As Kevin wrote, this kind of proof works by hitting everything in sight with <code>cases</code>. You can use <code>rcases</code> do recursively doing <code>cases</code> (that’s what the <code>r</code> stands for). You get</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PFilter</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">sets</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">sets</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">A'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">B'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">D'</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d'</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">c'</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This kind of proof is painful to write by hand everywhere, hence the existence of the <code>ext</code> attribute gadget.</p>",
        "id": 486292351,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1733401294
    },
    {
        "content": "<p>And I hope your definition of <code>PFilter</code> is only an reduced version of your actual definition because otherwise it is a very bad idea.</p>",
        "id": 486292525,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1733401346
    },
    {
        "content": "<p>I see. I didn't know how to recover all the fields of <code>F</code> and <code>G</code>, but now I see it is by using <code>rcases</code>.</p>\n<p>Everything understood. Thanks!</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Understanding.20equality.20on.20Filter/near/486292525\">ha dicho</a>:</p>\n<blockquote>\n<p>And I hope your definition of <code>PFilter</code> is only an reduced version of your actual definition because otherwise it is a very bad idea.</p>\n</blockquote>\n<p>It is a dismiss definition because I've seen it is not worth it as some results (like the ones about the membership relation on filters) are not inferred and it is simplier to just take the desired element in a filter. Is that the reason it is a bad idea or are there more reasons? <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n<p>Anyway, I think the doubt was interesting and, although I've dismissed the definition, I still wanted to know how it can be done.</p>",
        "id": 486297983,
        "sender_full_name": "Esteban Martínez Vañó",
        "timestamp": 1733403122
    },
    {
        "content": "<p>The bad idea is to have a field point and immediately ask it is nothing but the parameter A. This point field is pure noise. But I guess the actual definition you have in mind is more interesting.</p>",
        "id": 486301173,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1733404069
    },
    {
        "content": "<p>Yes, it is not a good idea, and indeed that's now what I really wanted to express.</p>",
        "id": 486302669,
        "sender_full_name": "Esteban Martínez Vañó",
        "timestamp": 1733404544
    }
]