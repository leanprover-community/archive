[
    {
        "content": "<p>I have an idea how we can merge two definitions of an indexed product of measures (finite product of σ-finite measures and an infinite product of probability measures) into one. We define the typeclass</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- todo: better name</span>\n<span class=\"kd\">class</span> <span class=\"n\">MeasureFamily</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">MeasurableSpace</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Measure</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">sigmaFinite</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">SigmaFinite</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"n\">isProbabilityMeasure</span> <span class=\"o\">:</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">cofinite</span><span class=\"o\">,</span> <span class=\"n\">IsProbabilityMeasure</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>with an instance assuming <code>[Finite ι]</code> and an instance assuming <code>[∀ i, IsProbabilityMeasure (μ i)]</code>.<br>\nThen we define one instance assuming <code>[MeasureFamily μ]</code> (we use the current construction for the non-probability finite product part and another construction for the probability part) and prove lemmas about it.</p>",
        "id": 395985429,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1696986491
    },
    {
        "content": "<p>What do you think? I do understand that this is a nontrivial refactor.</p>",
        "id": 395985457,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1696986508
    },
    {
        "content": "<p>If I try it, then how should I call the new typeclass?</p>",
        "id": 395985479,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1696986522
    },
    {
        "content": "<p>Restricted infinite products are a generalisation of this. Here you have infinitely many spaces of infinite measure but each is equipped with a preferred subspace of measure 1. Each element in the restricted product must be outside the preferred subspace only finitely often but the finite bad set can depend on the element. So it's a direct limit of the construction you explain above.</p>",
        "id": 396001728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696995695
    },
    {
        "content": "<p><del>What is the σ-algebra of measurable sets in this case?</del><br>\nWe can have this definition but it can be added later because it leads to a measure on a different type, not the pi type.</p>",
        "id": 396005349,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1696997891
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Measure.20on.20an.20infinite.20product/near/395985479\">said</a>:</p>\n<blockquote>\n<p>If I try it, then how should I call the new typeclass?</p>\n</blockquote>\n<p><code>IsCofinitelyProbabilityMeasure</code>? Not great...</p>",
        "id": 396022840,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1697007571
    },
    {
        "content": "<p>That's a good idea. But do we already have the product of infinitely many probability measures?</p>",
        "id": 396025396,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1697008619
    },
    {
        "content": "<p>Not yet.</p>",
        "id": 396081126,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1697028259
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>, has anything moved on that front? <span class=\"user-mention\" data-user-id=\"727171\">@Kin Yau James Wong</span> and I need the infinite product of probability measures to construct a (trivial) Gibbs measure</p>",
        "id": 452288536,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1721292682
    },
    {
        "content": "<p>Not yet.</p>",
        "id": 452346330,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1721309683
    },
    {
        "content": "<p>If you're going to work on this, I suggest that we talk about it first.</p>",
        "id": 452346620,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1721309756
    },
    {
        "content": "<p>Yeah, this is one of the first things we need for our project, so we need to work on this/convince you to do it for us</p>",
        "id": 452350054,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1721310663
    },
    {
        "content": "<p>It has been done by Etienne Marion in his M1 internship with me, but it's not PRed to mathlib yet.</p>",
        "id": 452358952,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1721312671
    },
    {
        "content": "<p>Do you have any pointers for me?</p>",
        "id": 452365123,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1721314336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Measure.20on.20an.20infinite.20product/near/452288536\">schrieb</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span>, has anything moved on that front? <span class=\"user-mention silent\" data-user-id=\"727171\">Kin Yau James Wong</span> and I need the infinite product of probability measures to construct a (trivial) Gibbs measure</p>\n</blockquote>\n<p>Isn't this a simple example of the Kolmogorv Extension Theorem? <span class=\"user-mention\" data-user-id=\"350992\">@Rémy Degenne</span>  and I have worked this out, but still need to PR this to Mathlib. <a href=\"https://github.com/RemyDegenne/kolmogorov_extension4\">https://github.com/RemyDegenne/kolmogorov_extension4</a></p>",
        "id": 452412022,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1721326867
    },
    {
        "content": "<p>Yes it is</p>",
        "id": 452422707,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1721330223
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"572064\">@Peter Pfaffelhuber</span>, I see <code>MeasureTheory.independentFamily</code> in your repo. However:</p>\n<ul>\n<li>Do we really need all those topological assumptions? I would the infinite product of probability doesn't require anything like that (but maybe I'm just ignorant).</li>\n<li>There's no API for it <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></li>\n</ul>",
        "id": 452569847,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1721395658
    },
    {
        "content": "<p>If you don't want topological assumptions, you need to restrict the index type. If you index over N, you don't need any assumption and can use the Ionescu-Tulcea theorem. This is what Etienne has done with Sébastien.</p>",
        "id": 452570406,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1721395830
    },
    {
        "content": "<p>I see. In our case, we care about <code>ℤⁿ</code>, so we would rather assume countability of the index type than topological stuff on the codomain</p>",
        "id": 452571118,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1721396052
    },
    {
        "content": "<p>Do you know where I can find Etienne's project?</p>",
        "id": 452571150,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1721396065
    },
    {
        "content": "<p>About making different cases co-exist in Mathlib. I think that we should define the pi measure in some highly non-constructive way (e.g., the infimum of all measures such that for all <code>s : ι → Set α</code> with <code>Set.Finite {i | μ i (s i) &gt; 1}</code>, the measure of <code>Set.pi Set.univ s</code> is <code>≥ tprod fun i ↦ μ i (s i)</code> (not sure about <code>&gt; 1</code> vs <code>≠ 1</code>; not sure if we need to require <code>Countable ι</code>, <code>Set.Countable {i | s i ≠ univ}</code>, or none). Then we can have a <code>Prop</code>-valued typeclass saying that a given family of measures admits a measure such that we have <code>= tprod ...</code>. This way we can have instances with different assumptions and theorems assuming this TC.</p>",
        "id": 452579769,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1721398310
    },
    {
        "content": "<p>You don't need topological assumptions for the product mesure, whatever the index set. Etienne has proved that. I'm currently getting the code in a reasonable state, should be ready today.</p>",
        "id": 452612700,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1721406178
    },
    {
        "content": "<p>This sounds like Corollary 8.25 in Kallenberg (Foundations of Modern Probability, 3rd edition). (If you have any dependency between coordinates, however, you will need some topological structure of the underlying spaces, as far as I know.)</p>",
        "id": 452614658,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1721406626
    },
    {
        "content": "<p>Sorry, I misread the thread and wrote nonsense. I meant that the extension theorem we used actually required assumptions in general.<br>\nThe special case of the product measure is different.</p>",
        "id": 452616504,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1721407096
    },
    {
        "content": "<p>You can find the definition of the general product measure in <a href=\"https://github.com/sgouezel/kolmogorov_extension4/blob/master/KolmogorovExtension4/MesureProduit2.lean\">https://github.com/sgouezel/kolmogorov_extension4/blob/master/KolmogorovExtension4/MesureProduit2.lean</a>. See <code>productMeasure</code> in this file, with some basic API after the definition.</p>",
        "id": 452650490,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1721417371
    },
    {
        "content": "<p>(now <a href=\"https://github.com/sgouezel/kolmogorov_extension4/blob/master/KolmogorovExtension4/ProductMeasure.lean\">https://github.com/sgouezel/kolmogorov_extension4/blob/master/KolmogorovExtension4/ProductMeasure.lean</a>)</p>",
        "id": 453734925,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1721836986
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/22555\">#22555</a> just got merged, so infinite products of probability measures are now in Mathlib <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 507996788,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1742902290
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/31364\">#31364</a> I use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure.infinitePi#doc\">docs#MeasureTheory.Measure.infinitePi</a> to define the binomial distribution. The one thing I really want to do is to compute its PMF. Unfortunately, no lemma in the <code>infinitePi</code> API tells you what happens if you evaluate it on a cylinder set with infinitely many coordinates, and indeed <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure.infinitePi_pi#doc\">docs#MeasureTheory.Measure.infinitePi_pi</a> is prefixed with a TODO to generalise to infinite sets. Is anyone working on that generalisation?</p>",
        "id": 554554891,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1762686941
    },
    {
        "content": "<p>Not as far as I know</p>",
        "id": 554555450,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1762687540
    },
    {
        "content": "<p>Is the binomial random graph the same as the Erdös-Renyi random graph? I am not absolutely sure about your question, but the countable infinite product is not countable (except for trivial cases), so I am in doubt that the infinite product you refer here should have a PMF (which has at most countable support).</p>",
        "id": 554571174,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1762702367
    },
    {
        "content": "<p>I don't like saying \"Erdös-Rényi random graph\" because, although binomial random graphs were originally studied by them mostly, they first defined another kind of random graphs (uniformly random graph with <code>n</code> vertices and <code>e</code> edges).</p>",
        "id": 554571298,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1762702488
    },
    {
        "content": "<p>Peter, I agree, but here I am taking the infinite product of measures, cofinitely many of which are dirac deltas. Therefore, it is morally a finite product.</p>",
        "id": 554571386,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1762702575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Measure.20on.20an.20infinite.20product/near/554571298\">said</a>:</p>\n<blockquote>\n<p>I don't like saying \"Erdös-Rényi random graph\" </p>\n</blockquote>\n<p>But when you will write a file docstring for your random graph file in the PR you should definitely include a mention of that name. It took me time to see what you meant with a binomial random graph, but I instantly know what an Erdös-Rényi random graph is. The name is quite standard in parts of the literature.</p>",
        "id": 554571525,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1762702708
    },
    {
        "content": "<p>I don't disagree with that. The PR is WIP <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 554571569,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1762702756
    },
    {
        "content": "<p>This is a bit tangential since I think the TODO should be done regardless but I think perhaps the better approach would be to define <code>BinomialRandom</code>on the whole space and then define <code>BinomialRandomOn</code> by mapping the measure with the inclusion. Then <code>infinitePi</code> will just reduce to <code>Measure.pi</code> when <code>u</code> is finite.</p>",
        "id": 554572039,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1762703204
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Measure.20on.20an.20infinite.20product/near/554571386\">schrieb</a>:</p>\n<blockquote>\n<p>Peter, I agree, but here I am taking the infinite product of measures, cofinitely many of which are dirac deltas. Therefore, it is morally a finite product.</p>\n</blockquote>\n<p>Ah, I see. So, the <code>infinitePi_pi</code> on a <code>Set ι</code> should need that<code>t i</code> has measure 1 for almost all <code>i</code> (which is true in your case). Otherwise the right hand side is 0 in many cases.</p>",
        "id": 554572049,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1762703211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"223948\">David Ledvinka</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Measure.20on.20an.20infinite.20product/near/554572039\">said</a>:</p>\n<blockquote>\n<p>This is a bit tangential since I think the TODO should be done regardless but I think perhaps the better approach would be to define <code>BinomialRandom</code>on the whole space and then define <code>BinomialRandomOn</code> by mapping the measure with the inclusion. Then <code>infinitePi</code> will just reduce to <code>Measure.pi</code> when <code>u</code> is finite.</p>\n</blockquote>\n<p>That was in fact my original approach, but then Bhavik remarked that it was a bit stupid to pass to a product indexed by a subtype then add back the missing bits, when you could instead set the missing bits to be irrelevant straight away.</p>",
        "id": 554572224,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1762703383
    },
    {
        "content": "<p>To me it seems a similar argument would apply to \"If I want to define a volume on a sphere in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>, rather than defining the volume on the sphere and then embedding I should just define the volume directly on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>\" yet the first approach seems natural to me. From a practical matter I think the map approach is nice for issues precisely like this where the subtype has nicer properties (like finite, countable etc...) but I suppose if its just the practical matter one could just prove equivalence with such a definition.</p>",
        "id": 554574257,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1762705204
    }
]