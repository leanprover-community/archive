[
    {
        "content": "<p>I'm trying to prove the second noncomputable def, however I keep getting the following error with obtain: tactic 'cases' failed, nested error:<br>\ntactic 'induction' failed, recursor 'Exists.casesOn' can only eliminate into Prop. However, I'm not getting this error with the first noncomputable def. I am only using the first one to try to get the obtain to work. I'm not sure why one would work, but not the other.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">FinitePresentation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">FinitePresentation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hfpB</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">FinitePresentation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">L</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hL</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fL</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hK</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hFree</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hFinite</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hFG</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">FinitePresentation</span><span class=\"bp\">.</span><span class=\"n\">equiv_quotient</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">tensorProdEquiv</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">FinitePresentation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hfpB</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">FinitePresentation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">L</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hL</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fL</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hK</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hFree</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hFinite</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hFG</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">FinitePresentation</span><span class=\"bp\">.</span><span class=\"n\">equiv_quotient</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 489358057,
        "sender_full_name": "Madison Crim",
        "timestamp": 1734388236
    },
    {
        "content": "<p>The first is a Prop and you should use <code>lemma</code> rather than <code>def</code> for it.<br>\nFor the second you need to use the <code>choose</code> tactic.</p>",
        "id": 489358341,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1734388345
    },
    {
        "content": "<p>Yes, I originally had it as a theorem, but I thought maybe it being a noncomputable def was the issue. Using choose worked thank you. Do you know why obtain wouldn't work here?</p>",
        "id": 489359524,
        "sender_full_name": "Madison Crim",
        "timestamp": 1734388759
    },
    {
        "content": "<p>You might want to read <a href=\"https://lean-forward.github.io/logical-verification/2018/41_notes.html\">this</a> starting from Large elimination. What's happening in the first example is small elimination.</p>",
        "id": 489360376,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1734389093
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 489360890,
        "sender_full_name": "Madison Crim",
        "timestamp": 1734389284
    },
    {
        "content": "<p>As you can probably imagine, when you're writing Lean tactics, Lean is secretly making some function piece by piece -- the goals that you see in tactic mode are the holes where the definition is incomplete. The <code>cases</code>, <code>obtain</code>, <code>induction</code> etc etc tactics are secretly applying functions called recursors, which are made automatically whenever the user creates an inductive type. For example this code</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n</code></pre></div>\n<p>creates a new type <code>MyNat</code>, a new term <code>MyNat.zero</code> of this type, a new function <code>MyNat.succ</code> from <code>MyNat</code> to <code>MyNat</code>, and a secret fourth thing <code>MyNat.rec</code> which is the principle of recursion and induction (it works for types and props, because it has <code>Sort u</code> as its conclusion, and <code>Sort u</code> means \"either <code>Prop</code> or <code>Type u</code>\"). </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">MyNat</span><span class=\"bp\">.</span><span class=\"n\">rec</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">@MyNat.rec : {motive : MyNat → Sort u_1} →</span>\n<span class=\"cm\">  motive MyNat.zero → ((a : MyNat) → motive a → motive a.succ) → (t : MyNat) → motive t</span>\n\n<span class=\"cm\">i.e.</span>\n\n<span class=\"cm\">\"for any function `motive` from the naturals to propositions or types, if you can make</span>\n<span class=\"cm\">`motive 0`, and also `motive (n+1)` given a term of type `motive n`, then</span>\n<span class=\"cm\">you can make terms of type `motive t` for any natural t\"</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>If you have some goal which is a proposition involving <code>n : MyNat</code>, then <code>induction n</code> basically does <code>apply MyNat.rec</code>,<br>\nlets <code>t</code> be <code>n</code>, fills in the last goal and opens two new goals corresponding to the inputs of <code>MyNat.rec</code> which are the zero case and the <code>succ</code> case. </p>\n<p>If you look at <code>Exists.rec</code> though, it says something a bit different:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">rec</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Exists.rec.{u} {α : Sort u} {p : α → Prop} {motive : Exists p → Prop} (intro : ∀ (w : α) (h : p w), motive ⋯)</span>\n<span class=\"cm\">  (t : Exists p) : motive t</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>The motive only takes values in <code>Prop</code>. This means in practice that if your goal isn't a theorem statement, then <code>cases h</code>/<code>obtain ... := h</code>/<code>induction h</code> won't work if <code>h : \\exists x, p x</code> because Lean can't make the relevant function which tactic mode makes because things don't match up. The reason the recursor only takes values in <code>Prop</code> is basically because <code>Exists</code> itself is a Prop,<br>\nand moving from the Prop universe to the Type universe is fraught with danger in type theory; you allow it to happen and your theory can become inconsistent. Moving from Prop to Type is exactly what the type theory axiom of choice does, but this is an extra axiom in Lean's theory.</p>",
        "id": 489364086,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734390525
    }
]