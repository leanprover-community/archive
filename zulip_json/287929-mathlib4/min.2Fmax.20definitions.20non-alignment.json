[
    {
        "content": "<p>In mathlib3:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">min_def</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"k\">else</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">max_def</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">max</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"k\">else</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>in mathlib4:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">min_def</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"k\">else</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">max_def</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">max</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"n\">b</span> <span class=\"k\">else</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> you ported the mathlib4 lines. I am running into this clash in trying to (ab)use <code>OrderDual</code> defeq for <code>LinearOrder (OrderDual _)</code>. Do we want to prefer the mathlib3 style of swapping the inequality, or the current mathlib4 style of swapping the then-else branches?</p>",
        "id": 308492361,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1667863487
    },
    {
        "content": "<p>Those definitions ultimately derive from the lean 4 implementation of max and min, which uses that order deliberately so that <code>(min a b, max a b)</code> can get optimized using common subexpression elimination to only involve one comparison</p>",
        "id": 308492567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667863586
    },
    {
        "content": "<p>That said, the max/min support in <code>LinearOrder</code> was hacked together without too much thought so it's totally fine if you have a better approach as long as it still allows for custom max/min implementations</p>",
        "id": 308492816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667863707
    },
    {
        "content": "<p>OK -- do we want to then align <code>max_def</code> to have a non <code>LinearOrder.max_def ..</code> proof?</p>",
        "id": 308492906,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1667863751
    },
    {
        "content": "<p>basically, naked <code>max_def</code> and <code>LinearOrder.max_def</code> aren't syntactically equal</p>",
        "id": 308492942,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1667863773
    },
    {
        "content": "<p>or, we can change it in both places, and have a smarter autoParam proof?</p>",
        "id": 308493052,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1667863816
    },
    {
        "content": "<p>What does mathlib do? We should probably do that</p>",
        "id": 308493120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667863827
    },
    {
        "content": "<p>seems like we probably want to align <code>max</code> to match lattice join</p>",
        "id": 308493160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667863849
    },
    {
        "content": "<p>I see, mathlib is using a separate <code>linear_order</code> from lattices because it is mostly in core</p>",
        "id": 308493455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667864017
    },
    {
        "content": "<p>In the meantime, here's what the <code>LinearOrder (OrderDual _)</code> proof looks like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"bp\">ᵒᵈ</span> <span class=\"n\">where</span>\n  <span class=\"n\">__</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstanceAs</span> <span class=\"o\">(</span><span class=\"n\">PartialOrder</span> <span class=\"n\">α</span><span class=\"bp\">ᵒᵈ</span><span class=\"o\">)</span>\n  <span class=\"n\">le_total</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">le_total</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n  <span class=\"n\">decidable_le</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstanceAs</span> <span class=\"o\">(</span><span class=\"n\">DecidableRel</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"n\">decidable_lt</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstanceAs</span> <span class=\"o\">(</span><span class=\"n\">DecidableRel</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"n\">min</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">max</span> <span class=\"n\">α</span> <span class=\"n\">_</span>\n  <span class=\"n\">max</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">min</span> <span class=\"n\">α</span> <span class=\"n\">_</span>\n  <span class=\"n\">min_def</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"k\">let</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n    <span class=\"k\">let</span> <span class=\"n\">b'</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">b</span>\n    <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Max.mk</span> <span class=\"n\">α</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">max</span> <span class=\"n\">a'</span> <span class=\"n\">b'</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">b'</span> <span class=\"bp\">≤</span> <span class=\"n\">a'</span> <span class=\"k\">then</span> <span class=\"n\">a'</span> <span class=\"k\">else</span> <span class=\"n\">b'</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">max_def</span><span class=\"o\">]</span>\n    <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">hab</span> <span class=\"n\">hba</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">le_antisymm</span> <span class=\"n\">hba</span> <span class=\"n\">hab</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">not_le</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n      <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"o\">(</span><span class=\"n\">hab.trans</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›)</span> <span class=\"o\">(</span><span class=\"n\">lt_irrefl</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">max_def</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"k\">let</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n    <span class=\"k\">let</span> <span class=\"n\">b'</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">b</span>\n    <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Min.mk</span> <span class=\"n\">α</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">min</span> <span class=\"n\">a'</span> <span class=\"n\">b'</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">b'</span> <span class=\"bp\">≤</span> <span class=\"n\">a'</span> <span class=\"k\">then</span> <span class=\"n\">b'</span> <span class=\"k\">else</span> <span class=\"n\">a'</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">min_def</span><span class=\"o\">]</span>\n    <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">hab</span> <span class=\"n\">hba</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">le_antisymm</span> <span class=\"n\">hab</span> <span class=\"n\">hba</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">not_le</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n      <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"o\">(</span><span class=\"n\">hab.trans</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›)</span> <span class=\"o\">(</span><span class=\"n\">lt_irrefl</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 308493975,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1667864332
    },
    {
        "content": "<p>those proofs seem unnecessarily long. It should just be an application of <code>max_comm</code> to convert between the two possible interpretations</p>",
        "id": 308494128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667864404
    },
    {
        "content": "<p>also, isn't there already a proof of this?</p>",
        "id": 308494228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667864469
    },
    {
        "content": "<p>so something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">min_def</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"k\">let</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n    <span class=\"k\">let</span> <span class=\"n\">b'</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">b</span>\n    <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Max.mk</span> <span class=\"n\">α</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">max</span> <span class=\"n\">a'</span> <span class=\"n\">b'</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">b'</span> <span class=\"bp\">≤</span> <span class=\"n\">a'</span> <span class=\"k\">then</span> <span class=\"n\">a'</span> <span class=\"k\">else</span> <span class=\"n\">b'</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">max_comm</span><span class=\"o\">,</span> <span class=\"n\">max_def</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>?</p>",
        "id": 308494268,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1667864499
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/d78a3d45bf33119f21ca18cfd2f822b747cc9a98/Mathlib/Order/Basic.lean#L420-L429\">https://github.com/leanprover-community/mathlib4/blob/d78a3d45bf33119f21ca18cfd2f822b747cc9a98/Mathlib/Order/Basic.lean#L420-L429</a></p>",
        "id": 308494275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667864502
    },
    {
        "content": "<p>ah, I overwrote it =C. Thanks.</p>",
        "id": 308494336,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1667864523
    },
    {
        "content": "<blockquote>\n<p>seems like we probably want to align <code>max</code> to match lattice join</p>\n</blockquote>\n<p>In fact I have a branch to core that does exactly this, but I guess rather open it to std4 now</p>",
        "id": 308496698,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1667865877
    },
    {
        "content": "<p>Oh wait, is <code>LinearOrder</code> in mathlib now?</p>",
        "id": 308496729,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1667865895
    },
    {
        "content": "<p>It is, but only as an ad-hoc port.</p>",
        "id": 308496914,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1667866000
    },
    {
        "content": "<p>The whole order hierarchy is part of mathlib4 now, so these kinds of refactors are presumbably easier (except that we still care about mathlib alignment so we would rather backport something like this if possible)</p>",
        "id": 308500411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1667868286
    },
    {
        "content": "<p>Oh I like that!</p>",
        "id": 308548235,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1667900259
    },
    {
        "content": "<p>Should we rename <code>LinearOrder.min</code> to <code>LinearOrder.inf</code>?</p>",
        "id": 362325359,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1685495136
    },
    {
        "content": "<p>So that we don't need to rename fields in <code>extends</code></p>",
        "id": 362325383,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1685495161
    },
    {
        "content": "<p>And so that we don't accidentally forget to rename them</p>",
        "id": 362325440,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1685495172
    },
    {
        "content": "<p>As I previously said, I don't think we ever need <code>min</code> and <code>max</code> at all.</p>",
        "id": 362365154,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1685517363
    },
    {
        "content": "<p>It's quite practical for pedagogical purposes and lemma naming, but those have other solutions than \"duplicate a few hundred lemmas for a special case\".</p>",
        "id": 362365408,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1685517442
    },
    {
        "content": "<p>So I'm happy for you to do whatever you want with those, as I'm hoping I will one day crush their parasitic existence.</p>",
        "id": 362365656,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1685517508
    },
    {
        "content": "<p>I'm fine with removing them completely in favor of <code>sup</code>/<code>inf</code> but this (a) needs approval from other maintainers; (b) should not be done before the port is done.</p>",
        "id": 362508053,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1685550162
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> what exactly are those \"other solutions\" you are contemplating?</p>",
        "id": 362537598,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1685557140
    },
    {
        "content": "<p>Here are the solutions I'm aware of, from most radical to least radical:</p>\n<ol>\n<li>Drop <code>min</code>/<code>max</code> entirely and rename all lemmas.</li>\n<li>Drop <code>min</code>/<code>max</code> as definitions but keep as a naming convention that <code>inf</code>/<code>sup</code> on a linear order is called <code>min</code>/<code>max</code>.</li>\n<li>Turn <code>min</code>/<code>max</code> from definitions to input-only notations.</li>\n<li>Turn <code>min</code>/<code>max</code> from definitions to notations that pretty-print only in the presence of a <code>linear_order</code> instance.</li>\n<li>Keep the status quo.</li>\n</ol>\n<p>2 is my favourite, I would also be happy with 1 and 3, but 4 is IMO past the reasonable in that it tries to be very backwards compatible with an arbitrary core Lean 3 convention.</p>",
        "id": 362543053,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1685558558
    },
    {
        "content": "<p>Note that there are ramifications for the corresponding <code>finset</code> declarations, which are also partially duplicated (three way in the case of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sup\">docs#finset.sup</a> !). For those, I would go for 1 because their limited use doesn't justify an exception to the naming convention.</p>",
        "id": 362543608,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1685558720
    },
    {
        "content": "<p>Yeah, 2 is nice IMO.</p>",
        "id": 362543729,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1685558758
    },
    {
        "content": "<p>2 seems a bit confusing (compared to 1), because to guess the name of a lemma you have to work out whether your result holds only in linear orders or not</p>",
        "id": 362543830,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685558786
    },
    {
        "content": "<p>That's usually pretty obvious, eg <a href=\"https://leanprover-community.github.io/mathlib_docs/find/min_le_iff\">docs#min_le_iff</a></p>",
        "id": 362543990,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1685558836
    },
    {
        "content": "<p>I should point out that 2 is already the solution used in <code>Sup</code> vs <code>cSup</code>. <code>tsub</code> vs <code>sub</code> is quite similar, except that lemmas are purposefully duplicated from the <code>tsub</code> name to the <code>sub</code> precisely to avoid what Eric is complaining about (and because there it's actually quite hard to figure out the correct generality of a lemma).</p>",
        "id": 362544571,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1685558988
    },
    {
        "content": "<p>The easiest path to any of those solutions is probably 5 -&gt; 3 -&gt; 4 and 5 -&gt; 3 -&gt; 2 -&gt; 1 (as in, it's no more work to implement those in order rather than implementing the end one directly).</p>",
        "id": 362545047,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1685559119
    },
    {
        "content": "<p>Things like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/with_top.coe_infi\">docs#with_top.coe_infi</a> don't really fit the cInf/Inf rule there</p>",
        "id": 362545625,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685559246
    },
    {
        "content": "<p>They do, in the sense that lemmas that apply to both situations get the simpler name.</p>",
        "id": 362546278,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1685559424
    },
    {
        "content": "<p>I don't like the \"2. <code>inf</code> is called <code>min</code> in theorem names\" approach. If we can teach ring theorists the zero ideal is called <code>bot</code> then we can teach them that the minimum is called <code>inf</code>.</p>",
        "id": 362679587,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1685610429
    },
    {
        "content": "<p>I am a little worried that this change would make Lean much less mathematician-friendly: if I see <code>inf 2 3</code>, my first instinct is \"surely you meant <code>min 2 3</code>\".  I would argue that, just like <code>bot</code> and <code>top</code>, this would add an extra layer of separation between Lean and informal mathematics.</p>",
        "id": 362704034,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685615616
    },
    {
        "content": "<p>why have a separate definition <code>inf</code>? it's just the product</p>",
        "id": 362709012,
        "sender_full_name": "Reid Barton",
        "timestamp": 1685616539
    },
    {
        "content": "<p>I have come over to the idea that if mathematicians learn the basic definitions of lattice theory and its notations then they're in a much better position to find theorems in the library in general, so I typically teach this early now</p>",
        "id": 362711214,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685617065
    }
]