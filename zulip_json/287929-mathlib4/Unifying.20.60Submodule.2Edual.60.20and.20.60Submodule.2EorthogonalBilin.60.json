[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/34007\">#34007</a> I propose an implementation of <code>Submodule.dual</code> as an analogue of the existing <code>PointedCone.dual</code>. This PR is a bottleneck for the upcoming cone duality theory and needed for <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/with/571291442\">polyhedral cones</a>. <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> pointed out the similarity to <code>Submodule.orthogonalBilin</code> and asked whether these concepts can be unified. I am open for it, but feel not competent in judging how this should be done in detail.</p>\n<p>Both \"dual\" and \"orthogonalBilin\" are based on a bi(semi)linear pairing <code>B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] M</code> but with complementary generality:</p>\n<ul>\n<li>\"orthogonalBilin\" assumes that <code>M₁</code> and <code>M₂</code> are identical.</li>\n<li>\"dual\" currently assumes an <code>R</code>-bilinear pairing, and <code>M</code> is the base ring <code>R</code>.</li>\n</ul>\n<p>Also \"dual\" takes in a set, whereas \"orthogonalBilin\" takes in a submodule.</p>",
        "id": 571291195,
        "sender_full_name": "Martin Winter",
        "timestamp": 1769956449
    },
    {
        "content": "<p><strong>Questions:</strong></p>\n<ol>\n<li>First and foremost, is it the right move to unify these concept? They are related, but express slightly different intent. Note that there are also <code>dualAnnihilator</code> and <code>dualCoannihilator</code> that are further special cases (see <code>dual_dualCoannihilator</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/34007\">#34007</a>). Should they exist independently?</li>\n<li>How to unify? I suppose the unification should be build on the maximally general <code>B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] M</code>. Do we want \"orthogonalBilin\" to take in a set as opposed to a submodule?</li>\n<li>Which terminology should survive? I feel like \"orthogonal\" is a relation between submodules in the same space. So, should \"dual\" be the primary terminology? Should \"orthogonalBilin\" be an optional terminology for when <code>M₁</code> = <code>M₂</code>?</li>\n<li>Given that <code>Submodule.dual</code> is a bottleneck for polyhedral cones and that the unifaction seems nontrivial, should it be a priority <em>now</em>?</li>\n</ol>",
        "id": 571291200,
        "sender_full_name": "Martin Winter",
        "timestamp": 1769956452
    },
    {
        "content": "<p>I assume you meant <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span></p>",
        "id": 571292814,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1769957896
    },
    {
        "content": "<p>I would argue that \"dual\" is a very confusing terminology, and <em>orthogonal</em> is much better. The word \"orthogonal\" seems quite standard (in the French speaking undergraduate literature) at least in the case of the pairing between a finite dimensional vector space and its dual. (There are actually two notions of left or right orthogonal, but it may be ok to use only one because the other can be deduced by using the flip.)</p>",
        "id": 571303870,
        "sender_full_name": "Joël Riou",
        "timestamp": 1769968243
    },
    {
        "content": "<p>Submodule.dual is confusing in three ways: 1) there is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Dual#doc\">docs#Module.Dual</a> for the actual dual of a module ; 2) that notion depends on the choice of a pairing ; 3) in the classical case, it would represent the dual of the quotient module.</p>",
        "id": 571311179,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1769975385
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 571343781,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770005530
    },
    {
        "content": "<blockquote>\n<p>Which terminology should survive? I feel like \"orthogonal\" is a relation between submodules in the same space. So, should \"dual\" be the primary terminology?</p>\n</blockquote>\n<p>I agree with this, I've never seen the word \"orthogonal\" used outside of this context. We already use the word for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Dual#doc\">docs#Module.Dual</a>, and I think we should use the same word here.</p>",
        "id": 571344087,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770005772
    },
    {
        "content": "<p>...oh wait, this takes a bilinear map rather than being the true dual. So yeah, I think we should find another name.</p>",
        "id": 571344277,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770005920
    },
    {
        "content": "<p>This is for convex polytopes, right? Is there a reason we can't just take a dual polytope to live in the dual space?</p>",
        "id": 571344578,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770006173
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Unifying.20.60Submodule.2Edual.60.20and.20.60Submodule.2EorthogonalBilin.60/near/571311179\">said</a>:</p>\n<blockquote>\n<p>Submodule.dual is confusing in three ways: 1) there is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Dual#doc\">docs#Module.Dual</a> for the actual dual of a module [...]</p>\n</blockquote>\n<p>I consider this a feature, not a bug: using <code>Dual.eval</code> as a pairing, <code>Submodule.dual</code> would live in <code>Module.Dual</code>. This would be consistent terminology.</p>\n<p>If we don't want \"dual\", I would still hope for a term of comparable length. Statements that contain \"orthogonalBilin\" more than once (of which there will be plenty) are rather cumbersome to parse. Can we have \"ortho\"?</p>",
        "id": 571518521,
        "sender_full_name": "Martin Winter",
        "timestamp": 1770063969
    },
    {
        "content": "<p>While we are at it, I have another question:</p>\n<ol start=\"5\">\n<li>why do we have a separate <code>BilinForm.orthogonal</code>? The only difference to <code>orthogonalBilin</code> (besides the namespace) seems to be that it takes a bilinear form rather than a bilinear map.  It even implements a lot of the same lemmas. Can't we just use <code>orthogonalBilin</code> in place of <code>orthogonal</code> everywhere (and then rename the former to the latter)?</li>\n</ol>",
        "id": 571518547,
        "sender_full_name": "Martin Winter",
        "timestamp": 1770063979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Unifying.20.60Submodule.2Edual.60.20and.20.60Submodule.2EorthogonalBilin.60/near/571344578\">said</a>:</p>\n<blockquote>\n<p>This is for convex polytopes, right? Is there a reason we can't just take a dual polytope to live in the dual space?</p>\n</blockquote>\n<p>For convex cones at this time, but convex polytopes eventually.</p>\n<p>Note that defining the dual with respect to a general pairing is not a feature of my PR but is already the case for <code>PointedCone.dual</code>. I am merely consistent with it.<br>\nWe had a discussion <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/near/536327499\">here</a> where I also opposed the pairing in <code>dual</code>. What convinced me eventually is that the following two common use cases are covered very easily:</p>\n<ul>\n<li>ideally the dual of the dual lives in the same space as the original cone. We can get from the dual cone back using the pairing <code>B.flip</code>. This is especially important in infinite dimensions where a module is not isomorphic to its double dual.</li>\n<li>in Euclidean spaces we can choose a pairing that gives us the dual in the same space again.</li>\n</ul>",
        "id": 571518555,
        "sender_full_name": "Martin Winter",
        "timestamp": 1770063984
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384542\">Justus Springer</span> <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/near/536353155\">said</a>:</p>\n<blockquote>\n<p>It's true we don't gain any generality in a mathematical sense. After all, for any pair of vector spaces <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> with a perfect pairing, we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>≅</mo><msup><mi>N</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">M \\cong N^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>. But we gain flexibility in Lean, as it might happen that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is not definitionally equal to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">N^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>. If we only allow the \"canonical\" dual, we would then have to carry around the isomorphism all the time, as in the example with the double dual Yael mentions.</p>\n</blockquote>\n<p>Well, this convinces me.</p>",
        "id": 571518750,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770064059
    }
]