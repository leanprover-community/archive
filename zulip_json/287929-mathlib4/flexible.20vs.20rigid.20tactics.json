[
    {
        "content": "<p>I think all the tactic combinators like <code>done</code>, <code>skip</code>, <code>try</code>, <code>any_goals</code>, <code>all_goals</code> should be allowed</p>",
        "id": 427782429,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871132
    },
    {
        "content": "<p>Ok, I think that the way in which the \"following tactic\" is selected means that the tactic following the combinator will be flagged as well (unless it is whitelisted).  This is the intended behaviour, right?  I.e., the combinator should not be a stop-gag, just a see-through tactic that passes on the decision to the next one.</p>\n<p>Do you agree?</p>",
        "id": 427782779,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871240
    },
    {
        "content": "<p>I don't really like the current logic of your linter. I think a more pertinent logic would be to mark locations (hypotheses/goals) as \"non-squeezedly simped\" and forbidding \"rigid\" tactics from using those assumptions</p>",
        "id": 427783206,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871390
    },
    {
        "content": "<p>Eg this should be allowed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h0</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h2</span>\n</code></pre></div>\n<p>but neither of these should</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h0</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h0</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h0</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h0</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h1</span>\n</code></pre></div>",
        "id": 427783421,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871464
    },
    {
        "content": "<p>Yaël, I do not really understand what you are proposing... what is a  \"non-squeezedly simped\" location?</p>",
        "id": 427783422,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871465
    },
    {
        "content": "<p>Maybe I should specify: currently, the \"next tactic\" is \"the next tactic that acts on a goal that a <code>simp</code> produced\".</p>",
        "id": 427783551,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871516
    },
    {
        "content": "<p>It is <em>not</em> the next tactic that you type.</p>",
        "id": 427783608,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871540
    },
    {
        "content": "<p>(or rather, it need not be, although often it will be.)</p>",
        "id": 427783643,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871556
    },
    {
        "content": "<p>That sounds really brittle. That means that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>is forbidden but</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span>\n<span class=\"n\">ring</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>is not</p>",
        "id": 427783652,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871560
    },
    {
        "content": "<p>Do you understand my proposition better now?</p>",
        "id": 427783756,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871584
    },
    {
        "content": "<p>Yes, I think that I understand.  You would like something like a cache of \"after <code>simp</code> locations\" that are only allowed actions by \"flexible\" tactics, including <code>simp, ring,...</code>, but, for instance, not <code>rw</code>.</p>",
        "id": 427784085,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871693
    },
    {
        "content": "<p>I wonder whether this should come after a first implementation of the linter, though...</p>",
        "id": 427784139,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871716
    },
    {
        "content": "<p>This seems more like a \"non-terminal <code>flexible tactic</code> follower\" linter to me.</p>",
        "id": 427784270,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871768
    },
    {
        "content": "<p>I think it's worth exploring! If we merge your linter now, we're at risk of teachings seas of beginners the wrong style</p>",
        "id": 427784300,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871781
    },
    {
        "content": "<p>This is certainly a very good suggestion, but I think that focusing on <code>simp</code> might already be productive.</p>",
        "id": 427784316,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871792
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60simp.60.20followers/near/427784270\">said</a>:</p>\n<blockquote>\n<p>This seems more like a \"non-terminal <code>flexible tactic</code> follower\" linter to me.</p>\n</blockquote>\n<p>Yes, that's exactly what it is, because simp is really no special here</p>",
        "id": 427784400,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60simp.60.20followers/near/427784300\">said</a>:</p>\n<blockquote>\n<p>I think it's worth exploring! If we merge your linter now, we're at risk of teachings seas of beginners the wrong style</p>\n</blockquote>\n<p>Ok, this is possible, but it is also possible that they can then learn a better style later on.</p>",
        "id": 427784420,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871825
    },
    {
        "content": "<p>Mathport experience would like to disagree...</p>",
        "id": 427784459,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871843
    },
    {
        "content": "<p>I claim that the correct implementation is so different to your current one that it's not worth trying to incrementally get to the correct one from yours</p>",
        "id": 427784534,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871878
    },
    {
        "content": "<p>Ok, so maybe the tactics that I am placing in the whitelist should be all allowed and should never be followed by anything else.</p>\n<p>This is probably not that hard to implement, although I have not really given this much thought.</p>",
        "id": 427784560,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871891
    },
    {
        "content": "<p>Also, you already ripped out most of the benefits from your linter by PRing fixes to the errors you found locally</p>",
        "id": 427784686,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871930
    },
    {
        "content": "<p>More errors will come, but only with a better logic</p>",
        "id": 427784720,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60simp.60.20followers/near/427784534\">said</a>:</p>\n<blockquote>\n<p>I claim that the correct implementation is so different to your current one that it's not worth trying to incrementally get to the correct one from yours</p>\n</blockquote>\n<p>The current suggestion is very far from v1 of the linter, not, I think, from v2 that I am testing right now.</p>",
        "id": 427784729,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871949
    },
    {
        "content": "<p>I think you should not allow specific tactics but instead disallow specific rigid tactics</p>",
        "id": 427784797,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60simp.60.20followers/near/427784686\">said</a>:</p>\n<blockquote>\n<p>Also, you already ripped out most of the benefits from your linter by PRing fixes to the errors you found locally</p>\n</blockquote>\n<p>Very few of those PRs have been merged and have conflicts now.  I am planning to close them, if the newer version of the linter is definitely an improvement.</p>",
        "id": 427784838,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871996
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60simp.60.20followers/near/427784797\">said</a>:</p>\n<blockquote>\n<p>I think you should not allow specific tactics but instead disallow them</p>\n</blockquote>\n<p>As I am thinking of this right now, there are only two categories, right?  The category of tactics that can only act on goals on which a flexible tactic has not yet acted, and the flexible tactics, right?  You are saying that a tactic if automatically flexible, unless it is blacklisted?</p>",
        "id": 427785128,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872099
    },
    {
        "content": "<p>Nono, sorry I clarified</p>",
        "id": 427785198,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872131
    },
    {
        "content": "<p>(the two perspective are easy to implement, it seems to be that we are simply deciding what the default category of each tactic is)</p>",
        "id": 427785202,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872134
    },
    {
        "content": "<p>The default should be rigid. This is what I'm claiming</p>",
        "id": 427785258,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872161
    },
    {
        "content": "<p>Ok, I agree.  By default, everything is like <code>rw</code> (which I consider the default rigid tactic).</p>",
        "id": 427785342,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872186
    },
    {
        "content": "<p>And if a goal/location has been produced/touched by a flexible tactic, then only flexible tactics are allowed to touch it.</p>",
        "id": 427785428,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872221
    },
    {
        "content": "<p>... or use it!</p>",
        "id": 427785539,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872264
    },
    {
        "content": "<p>(the \"location part\" I am not too sure about -- the current linter is implemented thinking about goals, but the linting framework does have access to the context.)</p>",
        "id": 427785663,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872294
    },
    {
        "content": "<p>Actually, it's not merely \"touched by a flexible tactic\" that's bad but \"potentially touched\"</p>",
        "id": 427785689,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872304
    },
    {
        "content": "<p>\"potentially touched\" might include everything, though?  Do you mean that <code>simp_all</code> makes everything flexible, even if it actually just modifies one hypothesis?</p>",
        "id": 427785864,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872376
    },
    {
        "content": "<p>So the correct rule is:</p>\n<blockquote>\n<p>Only flexible tactics are allowed to target or use locations which have been previously been targeted by flexible tactics (regardless of whether said flexible tactics actually changed those locations)</p>\n</blockquote>",
        "id": 427785896,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872387
    },
    {
        "content": "<p>Yes, <code>simp at *</code> means that no rigid tactic can target anything in that context anymore. If you then do <code>have := something_not_from_context</code>, that can be touched by a rigid tactic however,</p>",
        "id": 427786161,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872474
    },
    {
        "content": "<p>I understand your point, although I wonder whether this requires knowledge of what each tactic <em>could</em> do...  E.g., when you see a <code>simp</code>, you should figure out whether it is <code>at</code> and what the <code>at</code> locations are.  I think that this would be very hard to maintain as a linter.</p>",
        "id": 427786201,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872488
    },
    {
        "content": "<p>Yes, but luckily there aren't many flexible tactics</p>",
        "id": 427786285,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872513
    },
    {
        "content": "<p>Regardless, information on targeted locations should be part of the tactic framework long term</p>",
        "id": 427786428,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872559
    },
    {
        "content": "<p>To avoid scope-creep, what do you think of focusing on goals, rather than locations, to begin with?</p>",
        "id": 427786432,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872561
    },
    {
        "content": "<p>I don't see how that could give you anything sensible</p>",
        "id": 427786504,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872584
    },
    {
        "content": "<p>There are too many ways the goal-based heuristic could go wrong</p>",
        "id": 427786599,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60simp.60.20followers/near/427786599\">said</a>:</p>\n<blockquote>\n<p>There are too many ways the goal-based heuristic could go wrong</p>\n</blockquote>\n<p>While this is true, I also think that for most proofs, the goal heuristic is actually good.</p>",
        "id": 427787008,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872750
    },
    {
        "content": "<p>Yes, but I really really do not want false linter positives</p>",
        "id": 427787144,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872783
    },
    {
        "content": "<p>(Also, I am aware of my abilities and, while I can see myself coding the linter with locations and all, I can also see the result as being unusably slow...)</p>",
        "id": 427787242,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60simp.60.20followers/near/427787144\">said</a>:</p>\n<blockquote>\n<p>Yes, but I really really do not want false linter positives</p>\n</blockquote>\n<p>You can view it as \"Every silencing of the linter is a todo\"...</p>",
        "id": 427787356,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872852
    },
    {
        "content": "<p>I am going to move all this conversation to a separate topic, is that alright?</p>",
        "id": 427787603,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872937
    },
    {
        "content": "<p>(assuming that I can...)</p>",
        "id": 427787629,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872945
    },
    {
        "content": "<p>49 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/.02klzzwxh.3A0000.03.20followers\">#mathlib4 &gt; <code>simp</code> followers</a> by <span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span>.</p>",
        "id": 427787981,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710873065
    },
    {
        "content": "<p>Ok, to seriously implement this rigid vs flexible linter, I need to see what kind of information hides in the <code>MetavarContext</code> that the linter offers.</p>",
        "id": 427788492,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710873239
    },
    {
        "content": "<p>Just to be clear, what you are suggesting is that, after a flexible tactic that potentially changes all locations, that metavariable can (almost) only be closed by flexible tactics: e.g. <code>assumption, tauto, linarith,..., have+something else,...</code> and <code>have</code> or something similar is the only way in which rigid tactics can play again there, and then only on the new hypotheses that have been introduced.</p>",
        "id": 427790233,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710873850
    },
    {
        "content": "<p>I agree that this would make proofs much less brittle.  It may also be somewhat of an added burden to write proofs in this \"flexible-vs-rigid\" style.</p>",
        "id": 427790567,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710873967
    },
    {
        "content": "<p>I don't think it will be much burden since this is already how we write most proofs</p>",
        "id": 427801416,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710878206
    },
    {
        "content": "<p>Some iteration of the \"non-terminal <code>simp</code>\" linter produces the output below.  Currently, the linter only looks at <code>simp</code> and <code>simp_all</code>, but this is easy to expand.  What the linter is <em>supposed</em> to do is check if some tactics that are likely to break with small changes to the <code>simp</code> output follow <code>simp</code>.</p>\n<p>The linter makes an effort to flag <code>simp at h; rw [h]</code> as well as <code>simp at h; rw at h</code>.</p>\n<p>The lnter should not flag <code>simp at h1; rw [h2] at h3</code>, assuming that <code>h1</code> is different from <code>h2, h3</code>.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Linted</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Mathlib/Init/Data/Nat/Bitwise.lean</span>\n    <span class=\"n\">cases</span> <span class=\"n\">bodd</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cond</span><span class=\"o\">,</span> <span class=\"n\">not</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Mathlib/Control/Applicative.lean</span>\n  <span class=\"n\">simp</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">map</span><span class=\"o\">,</span> <span class=\"n\">Seq.seq</span><span class=\"o\">,</span> <span class=\"n\">functor_norm</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">commutative_map</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Mathlib/Data/Nat/Defs.lean</span>\n  <span class=\"bp\">·</span> <span class=\"n\">by_contra</span> <span class=\"n\">h'</span><span class=\"bp\">;</span> <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">h'</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.le_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h'</span>\n    <span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span> <span class=\"n\">h'</span>\n\n<span class=\"c1\">-- Mathlib/Data/List/ReduceOption.lean</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">eq_comm</span> <span class=\"n\">_</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Option.not_isSome_iff_eq_none</span><span class=\"o\">,</span> <span class=\"n\">Decidable.imp_iff_not_or</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Mathlib/Order/Compare.lean</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">xy</span><span class=\"o\">:</span><span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">by_cases</span> <span class=\"n\">yx</span><span class=\"o\">:</span><span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cmpLE</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">Ordering.swap</span><span class=\"o\">]</span>\n  <span class=\"n\">cases</span> <span class=\"n\">not_or_of_not</span> <span class=\"n\">xy</span> <span class=\"n\">yx</span> <span class=\"o\">(</span><span class=\"n\">total_of</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Mathlib/Data/Nat/PSub.lean</span>\n  <span class=\"n\">cases</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">psub</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"k\">show</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- Mathlib/Tactic/Sat/FromLRAT.lean</span>\n    <span class=\"n\">induction</span> <span class=\"n\">as₁</span> <span class=\"k\">with</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">b</span> <span class=\"n\">as₁</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">bs</span> <span class=\"bp\">↦</span> <span class=\"n\">ih</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ_add</span> <span class=\"bp\">..</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n\n<span class=\"c1\">-- Mathlib/Order/Iterate.lean</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hf.seq_le_seq</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">intros</span> <span class=\"bp\">&lt;;&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">iterate_succ'</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">iterate_succ</span><span class=\"o\">,</span> <span class=\"n\">comp_apply</span><span class=\"o\">,</span> <span class=\"n\">id_eq</span><span class=\"o\">,</span> <span class=\"n\">le_refl</span><span class=\"o\">]</span>\n  <span class=\"n\">case</span> <span class=\"n\">hx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">H</span> <span class=\"n\">_</span>\n\n<span class=\"c1\">-- Mathlib/Data/Nat/Bitwise.lean</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">two_mul</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_mul_div_left</span><span class=\"o\">]</span>\n  <span class=\"n\">cases</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">h3</span><span class=\"o\">,</span> <span class=\"n\">h4</span><span class=\"o\">]</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">split_ifs</span>\n\n<span class=\"c1\">-- Mathlib/Data/Nat/Size.lean</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">IH</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">shiftLeft'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">⊢</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">size_bit</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_succ</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Mathlib/Data/List/Lattice.lean</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">l₂</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">bagInter_nil_iff_inter_nil</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span>\n\n<span class=\"c1\">-- Mathlib/Analysis/MeanInequalities.lean</span>\n    <span class=\"n\">le_of_lt</span> <span class=\"n\">hpq.symm.pos</span><span class=\"o\">,</span> <span class=\"n\">le_of_lt</span> <span class=\"n\">hpq.symm.one_div_pos</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">convert</span> <span class=\"n\">this</span> <span class=\"n\">using</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"o\">[</span><span class=\"n\">skip</span><span class=\"bp\">;</span> <span class=\"n\">congr</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"o\">[</span><span class=\"n\">skip</span><span class=\"bp\">;</span> <span class=\"n\">skip</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">skip</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"bp\">&lt;;&gt;</span>\n\n<span class=\"c1\">-- Mathlib/RingTheory/Polynomial/Cyclotomic/Eval.lean</span>\n      <span class=\"n\">and_self_iff</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">intro</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">linarith</span>\n\n<span class=\"c1\">-- Mathlib/MeasureTheory/Integral/MeanInequalities.lean</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hi₀</span><span class=\"o\">]</span>\n      <span class=\"k\">have</span> <span class=\"n\">h2p</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n\n<span class=\"c1\">-- Mathlib/Geometry/Euclidean/Sphere/Power.lean</span>\n    <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Classical.not_not</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">]</span>\n  <span class=\"n\">exacts</span> <span class=\"o\">[</span><span class=\"n\">hab</span> <span class=\"o\">(</span><span class=\"n\">vsub_left_cancel</span> <span class=\"n\">hab₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"n\">hcd</span> <span class=\"o\">(</span><span class=\"n\">vsub_left_cancel</span> <span class=\"n\">hcd₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Mathlib/MeasureTheory/Function/LpSeminorm/TriangleInequality.lean</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LpAddConst_of_one_le</span> <span class=\"n\">h'p</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">snorm_add_le</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span> <span class=\"n\">h'p</span>\n\n<span class=\"c1\">-- Mathlib/Analysis/InnerProductSpace/PiL2.lean</span>\n  <span class=\"c1\">-- Porting note: `LinearIsometryEquiv.trans_assoc` doesn't trigger in the `simp` above</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">LinearIsometryEquiv.trans_assoc</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Mathlib/MeasureTheory/Function/LpSpace.lean</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">q_zero</span><span class=\"o\">]</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">p_zero</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"c1\">-- Mathlib/Analysis/Matrix.lean</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">unitOf</span><span class=\"o\">]</span>\n  <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">h</span>\n\n<span class=\"c1\">-- Mathlib/MeasureTheory/Function/SimpleFuncDenseLp.lean</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">edist_comm</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"n\">edist_eq_coe_nnnorm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mod_cast</span> <span class=\"n\">this</span>\n\n<span class=\"c1\">-- Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean</span>\n  <span class=\"n\">interval_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp_all</span> <span class=\"bp\">&lt;;&gt;</span>\n    <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"o\">(</span><span class=\"n\">hb2</span> <span class=\"bp\">▸</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">Nat.mod_mod_of_dvd</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">decide</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">∣</span> <span class=\"mi\">8</span><span class=\"o\">))</span> <span class=\"n\">zero_ne_one</span>\n\n<span class=\"c1\">-- Mathlib/Probability/Process/Stopping.lean</span>\n    <span class=\"bp\">·</span> <span class=\"kd\">set_option</span> <span class=\"n\">tactic.skipAssignedInstances</span> <span class=\"n\">false</span> <span class=\"k\">in</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hij</span><span class=\"o\">]</span>\n      <span class=\"n\">convert</span> <span class=\"bp\">@</span><span class=\"n\">MeasurableSet.empty</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Filtration.seq</span> <span class=\"n\">f</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Mathlib/Probability/Kernel/Disintegration/Density.lean</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">κ</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">countablePartitionSet</span> <span class=\"n\">n</span> <span class=\"n\">x</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"c1\">-- Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Instances.lean</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hr'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"bp\">⊢</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hx.symm.le</span>\n\n<span class=\"c1\">-- Mathlib/NumberTheory/NumberField/CanonicalEmbedding.lean</span>\n    <span class=\"n\">Prod.snd_neg</span><span class=\"o\">,</span> <span class=\"n\">Complex.norm_eq_abs</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"bp\">⊢</span>\n  <span class=\"n\">convert</span> <span class=\"n\">hx</span> <span class=\"n\">using</span> <span class=\"mi\">3</span>\n</code></pre></div>\n</div></div>",
        "id": 430388342,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711803734
    },
    {
        "content": "<p>Let me know if something from the output above looks like something that the linter should handle differently (i.e. should allow it).</p>\n<p>[I gave one line of context before each flag, which sometimes may not be enough to reconstruct what the issue was.]</p>",
        "id": 430388367,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711803763
    },
    {
        "content": "<p>I'm not sure about the <code>induction as with simp</code> thing. Is <code>simp</code> not an identifier there?</p>",
        "id": 430390028,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711805108
    },
    {
        "content": "<p>I assume that in the <code>RingTheory.Polynomial\nCyclotomic.Eval</code> example the above tactic is a simp operating on the goal that's focused?</p>",
        "id": 430390120,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711805187
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">q_zero</span><span class=\"o\">]</span>\n<span class=\"n\">by_cases</span> <span class=\"n\">p_zero</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>should be legal since <code>by_cases</code> doesn't operate on the goal.</p>",
        "id": 430390188,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711805271
    },
    {
        "content": "<p>Similarly for the <code>Probability.Kernel.Disintegration.Density</code> one</p>",
        "id": 430390254,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711805328
    },
    {
        "content": "<p>No, <code>induction as with simp</code> runs <code>simp</code> on each of the new subgoals</p>",
        "id": 430390684,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1711805722
    },
    {
        "content": "<p>That's quite confusing given the <code>induction'</code> syntax <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 430391787,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711806638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/430390188\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">q_zero</span><span class=\"o\">]</span>\n<span class=\"n\">by_cases</span> <span class=\"n\">p_zero</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>should be legal since <code>by_cases</code> doesn't operate on the goal.</p>\n</blockquote>\n<p>Yes, there are still some rough edges around flagging <code>simp</code> when a new goal is created by the tactic.</p>\n<p>However, what I pasted there is the first failure in each file with basically no extra filter, so this is promising!</p>",
        "id": 430399483,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711813342
    },
    {
        "content": "<p>The \"flexible\" linter is essentially ready: <a href=\"https://github.com/leanprover-community/mathlib4/pull/11821\">#11821</a></p>\n<p>The PR above only defines the linter and adds a test file: the linter is not running on any file other than the test.</p>\n<p>There is a separate PR where I added the linter to most of mathlib: you can find it here: <a href=\"https://github.com/leanprover-community/mathlib4/pull/11822\">#11822</a>.</p>\n<p><a href=\"https://gist.github.com/adomani/2f7afc4bc515da47c3ff5c6e3f3bbbed\">Here is a gist</a> with the linter warnings from a separate run: there are approximately 230 files that the linter flags.  I scanned quickly a few of them and the linter seems to be doing its job!</p>",
        "id": 430619088,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711987739
    },
    {
        "content": "<p>One situation that the linter <em>does not</em> handle correctly is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>  <span class=\"c1\">-- h : True</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>Clearly, <code>assumption</code> is using <code>h</code>, but since <code>h</code> is not part of the syntax of the tactic, the linter is unaware of that.</p>\n<p>The linter <em>does</em> flag</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>  <span class=\"c1\">-- h : True</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 430619372,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711987810
    },
    {
        "content": "<p>Btw, if anyone feels like going through the gist above and knock down a few non-terminal simps, I would be more than thrilled!</p>",
        "id": 430619654,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711987890
    },
    {
        "content": "<p>(Also, while the whole setup would allow tactics other than <code>simp</code> to be flexible, I am only linting <code>simp</code> at the moment: already as it, it will be quite a lot of work to make <code>mathlib</code> compliant.)</p>",
        "id": 430619813,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711987943
    },
    {
        "content": "<p>While going through some of the lints, this is the most controversial that I found so far: is the pattern</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">...</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">split_ifs</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>acceptable?  What if the final <code>simp</code> is <code>exact</code> or <code>rw</code>?</p>",
        "id": 430744155,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712048520
    },
    {
        "content": "<p>I personally am not a huge fan of the <code>&lt;;&gt;</code>-combinator, because I usually value more clarity than saving space and I find that it more often obscures, rather than explain.</p>\n<p>In some cases, my solution has been to unlint, in others to squeeze, in others still to split the <code>&lt;;&gt;</code> combinators, depending on context.</p>",
        "id": 430744769,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712048696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/430744155\">said</a>:</p>\n<blockquote>\n<p>While going through some of the lints, this is the most controversial that I found so far: is the pattern</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">...</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">split_ifs</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>acceptable?  What if the final <code>simp</code> is <code>exact</code> or <code>rw</code>?</p>\n</blockquote>\n<p>Surely that's fine iff the final tactic is flexible?</p>",
        "id": 430744906,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712048750
    },
    {
        "content": "<p>Well, <code>if</code> could in theory be resolved by a better <code>simp</code> and then <code>split_ifs</code> would fail.</p>",
        "id": 430745074,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712048796
    },
    {
        "content": "<p>I am not sure that I consider <code>split_if</code> flexible.  Are you saying that <code>split_ifs</code> should simply be allowed as a <code>simp</code> follower?</p>",
        "id": 430745246,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712048859
    },
    {
        "content": "<p>I think <code>split_ifs</code> is neither flexible nor rigid. It's just a combinator</p>",
        "id": 430745415,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712048903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/430745074\">said</a>:</p>\n<blockquote>\n<p>Well, <code>if</code> could in theory be resolved by a better <code>simp</code> and then <code>split_ifs</code> would fail.</p>\n</blockquote>\n<p>In that case, you just remove the combinator, which should be a pretty obvious step to take</p>",
        "id": 430745507,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712048938
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/430745074\">said</a>:</p>\n<blockquote>\n<p>Well, <code>if</code> could in theory be resolved by a better <code>simp</code> and then <code>split_ifs</code> would fail.</p>\n</blockquote>\n<p>Most flexible tactics have this behavior</p>",
        "id": 430745527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712048945
    },
    {
        "content": "<p>simp can always produce something that the next tactic can't handle, flexible or otherwise</p>",
        "id": 430745616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712048973
    },
    {
        "content": "<p>but it's not dependent on the nitty gritty details of the goal, so it's flexible</p>",
        "id": 430745689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712049001
    },
    {
        "content": "<p>Right, I agree that this is the behaviour of most flexible tactics, and the linter is trying to mitigate this by only allowing flexible tactics to follow flexible tactics.  There are <em>a lot</em> of rigid tactics following flexible ones already as is, so I am trying to find some common ground...</p>",
        "id": 430745790,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712049028
    },
    {
        "content": "<p>Anyway, I'll add <code>split_ifs</code> to the ignored list, which means that the linter would</p>\n<ul>\n<li>not complain on <code>simp &lt;;&gt; split_ifs &lt;;&gt; simp</code> but</li>\n<li>would complain on <code>simp &lt;;&gt; split_ifs &lt;;&gt; rw</code></li>\n</ul>",
        "id": 430745963,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712049092
    },
    {
        "content": "<p>Another question: should this proof be allowed, or should <code>simp</code> be squeezed?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">multiplicity</span><span class=\"o\">,</span> <span class=\"n\">rootMultiplicity</span><span class=\"o\">,</span> <span class=\"n\">Part.Dom</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">congr</span>\n</code></pre></div>\n<p>Note that there is an underlying decision that <code>congr</code> is allowed as a <code>simp</code> follower, so really the question is whether the <code>funext</code> jammed in there is acceptable or whether it is reason for preferring a <code>simp only</code> instead.</p>",
        "id": 431547995,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712329960
    },
    {
        "content": "<p>The last congr solves the goal? Too bad simp can't handle it on its own</p>",
        "id": 431554121,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1712331735
    },
    {
        "content": "<p>Yes, this is the full declaration:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Mathlib/Algebra/Polynomial/Div.lean</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">rootMultiplicity_eq_multiplicity</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">DecidableRel</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">∣</span> <span class=\"bp\">·</span><span class=\"o\">)]</span>\n    <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">rootMultiplicity</span> <span class=\"n\">a</span> <span class=\"n\">p</span> <span class=\"bp\">=</span>\n      <span class=\"k\">if</span> <span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">multiplicity</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">(</span><span class=\"n\">multiplicity_X_sub_C_finite</span> <span class=\"n\">a</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">multiplicity</span><span class=\"o\">,</span> <span class=\"n\">rootMultiplicity</span><span class=\"o\">,</span> <span class=\"n\">Part.Dom</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">congr</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">polynomial.root_multiplicity_eq_multiplicity</span> <span class=\"n\">Polynomial.rootMultiplicity_eq_multiplicity</span>\n</code></pre></div>",
        "id": 431554294,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712331796
    },
    {
        "content": "<p>and this is the goal before the last <code>congr</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Nat.find</span> <span class=\"bp\">⋯</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.find</span> <span class=\"bp\">⋯</span>\n</code></pre></div>\n<p><span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>",
        "id": 431554516,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712331853
    },
    {
        "content": "<p>Is it expected that adding</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">pp.deepTerms</span> <span class=\"n\">true</span><span class=\"bp\">/</span><span class=\"n\">false</span> <span class=\"k\">in</span> <span class=\"c1\">-- I tried both</span>\n</code></pre></div>\n<p>before the declaration, I still see the <code>...</code>?</p>",
        "id": 431557457,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712332726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/431554516\">said</a>:</p>\n<blockquote>\n<p>and this is the goal before the last <code>congr</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Nat.find</span> <span class=\"bp\">⋯</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.find</span> <span class=\"bp\">⋯</span>\n</code></pre></div>\n<p><span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>\n</blockquote>\n<p>I feel like the predicate argument to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.find#doc\">docs#Nat.find</a> should be explicit</p>",
        "id": 431562818,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712334411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/431557457\">said</a>:</p>\n<blockquote>\n<p>Is it expected that adding</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">pp.deepTerms</span> <span class=\"n\">true</span><span class=\"bp\">/</span><span class=\"n\">false</span> <span class=\"k\">in</span> <span class=\"c1\">-- I tried both</span>\n</code></pre></div>\n<p>before the declaration, I still see the <code>...</code>?</p>\n</blockquote>\n<p>I've been using <code>set_option pp.proofs.threshold 37</code> to expand <code>...</code>.</p>",
        "id": 431569392,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712336552
    },
    {
        "content": "<p>Thanks Kevin!  This is the goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"n\">Nat.find</span> <span class=\"o\">(</span><span class=\"n\">multiplicity_X_sub_C_finite</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">Eq.mpr_not</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n  <span class=\"n\">Nat.find</span>\n    <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">PartENat.find</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∣</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"bp\">▸</span>\n      <span class=\"n\">multiplicity_X_sub_C_finite</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">Eq.mpr_not</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 431583012,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712341870
    },
    {
        "content": "<p>(I tried 0 and it didn't work so I tried 37 and it worked great)</p>",
        "id": 431606415,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712352179
    },
    {
        "content": "<p>I've just noticed that something we left out of the discussion is that tactics have different flexibility regarding their inputs and outputs eg in <code>simp [ha] at hb</code> we have</p>\n<ul>\n<li><code>ha</code> is a rigid input</li>\n<li><code>hb</code> is a flexible input</li>\n<li><code>hb</code> is a flexible output</li>\n</ul>",
        "id": 440258539,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716447077
    },
    {
        "content": "<p>And, perhaps more subtly, <code>ha</code> is a rigid output in <code>have ha : Foo := by simpa using hb</code> but a flexible output in <code>have ha := by simpa using hb</code></p>",
        "id": 440258708,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716447167
    },
    {
        "content": "<p>I'm not quite sure how to classify <code>ha</code> in intermediate situations like <code>have ha : Foo _ := by simpa using hb</code>. I guess it should be considered rigid even if it allows <code>have ha : _ := by simpa using hb</code> to leave <code>ha</code> rigid</p>",
        "id": 440258892,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716447250
    },
    {
        "content": "<p>On the front of the flexible vs rigid, I was pretty happy with the linter output.  However, I personally find that there is no uniformly good way of pleasing the linter: replacing <code>simp [tacs]</code> with </p>\n<ul>\n<li>the output of <code>simp? [tacs]</code> hides what <code>tacs</code> is and is often too verbose;</li>\n<li><code>simp? [tacs] says ...</code> is again very verbose and also means that you still have to update the list of tactics when the simp-set changes;</li>\n<li><code>suffices ...</code> can again be very verbose, when the goals are long.</li>\n</ul>\n<p>Overall, while a non-terminal <code>simp</code> (or rigid tactic following a flexible one more generally) is not great for stability, I am not sure that the alternatives that are currently available are really an net improvement.</p>",
        "id": 440264542,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716449903
    },
    {
        "content": "<p>I have been thinking about a possible alternative.  Here is an initial idea.</p>\n<p>If a <code>simp</code> no longer works on a branch, but was present in <code>master</code>, then squeezing it in master would tell you what to use.  How about we write a tactic <code>squeeze_me_earlier</code> that takes a tactic as input (initially just <code>simp</code>) and</p>\n<ul>\n<li>checks out <code>master</code>,</li>\n<li>downloads the cache,</li>\n<li>attempts to find the correct <code>simp</code>;</li>\n<li>runs <code>simp?</code> recording the output;</li>\n<li>checks out the branch in development;</li>\n<li>says <code>Try this: [recorded output of `simp?`]</code>.</li>\n</ul>\n<p>This could also be something that runs in CI, possibly applying to <code>simp</code>s that break downstream of your changes, maybe in an untouched file, to begin with.</p>",
        "id": 440266043,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716450540
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/15101\">#15101</a> fixes about a hundred warnings from the \"flexible tactic\" linter, in a way that is hopefully non-controversial. <a href=\"https://github.com/leanprover-community/mathlib4/pull/15102\">#15102</a> was also found by the linter, and is a small performance improvement in itself.</p>",
        "id": 453687607,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1721825886
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/15130\">#15130</a> has a few more</p>",
        "id": 453967946,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1721918564
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/15318\">#15318</a> has a few more</p>",
        "id": 455900557,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1722595655
    },
    {
        "content": "<p>Update: I have finished going through all warnings on mathlib. <a href=\"https://github.com/leanprover-community/mathlib4/pull/13812\">#13812</a> either disables the linter with a comment, or fixes its warning. The fixes have been split into <a href=\"https://github.com/leanprover-community/mathlib4/pull/15318\">#15318</a>.<br>\nFor the manual suppressions, I can see a few trends</p>\n<ul>\n<li>a category theory pattern: simp followed by coherence (I have always allowed the linter)</li>\n<li>a number of errors are about simp followed by erw, with a comment pointing to <a href=\"https://github.com/leanprover/lean4/pull/2644\">lean4#2644</a>: I've left those as is, as fixing the underlying issue will also fix this linter warning</li>\n<li><code>&lt;;&gt; simp</code> (say, for two goals created by <code>by_cases</code> or <code>induction</code>), followed by some further proof. The simp sets are usually different, and sometimes long enough be unreadable when spelled out</li>\n<li>there are surely more, for which I'd need to look at the suppressions myself</li>\n</ul>",
        "id": 456368738,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1722795682
    },
    {
        "content": "<p>I just merged master and fixed CI again: compared to <code>master</code>, enabling the flexible linter requires</p>\n<ul>\n<li>two minor fixes (three lines, will PR soon) and</li>\n<li>187 individual linter suppressions (commented)<br>\nTo be honest, this number does not seem absurdly high --- just from the churn perspective, one could even <em>enable</em> the linter by default (with a clear note that this may be disabled easily).</li>\n</ul>",
        "id": 462619684,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1723749003
    },
    {
        "content": "<p>Out of these 187 exceptions,</p>\n<ul>\n<li>14 are because of <a href=\"https://github.com/leanprover/lean4/pull/2644\">lean4#2644</a>/related to simp and erw</li>\n<li>5 are about simp followed by coherence</li>\n<li>4 exceptions are about simp followed by exact, which cannot be combined into <code>simpa</code></li>\n<li>most remaining exceptions are cases where either<ul>\n<li>the set of simp lemmas is long enough that squeezing it is ugly</li>\n<li>simp is applied to several goals, often with different (and/or quite large) simp sets</li>\n</ul>\n</li>\n</ul>",
        "id": 462620596,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1723749317
    },
    {
        "content": "<p>I'm not sure how flexible the flexible linter is, but do tactic patterns like <code>field_simp; linear_combination</code> go through with no complaints? I believe <code>field_simp</code> is just a juiced up version of <code>simp</code> and <code>linear_combination</code> is just a juiced up version of <code>ring</code>. I'm asking this because I use this pattern quite a lot in my files.</p>",
        "id": 474792241,
        "sender_full_name": "David Ang",
        "timestamp": 1728038031
    },
    {
        "content": "<p>I know that <code>simp; ring</code> is fine, but if <code>field_simp</code> is tagged as a <code>simp</code> but <code>linear_combination</code> is <em>not</em> tagged as a <code>ring</code> then it would complain, since <code>linear_combination</code> is not in the list of flexible tactics.</p>",
        "id": 474792571,
        "sender_full_name": "David Ang",
        "timestamp": 1728038157
    },
    {
        "content": "<p>Neither <code>field_simp</code>, nor <code>linear_combination</code> are \"flexible: this means that, by default, they are rigid.  Hence, <code>simp; field_simp</code> counts as a non-terminal simp and the linter would flag it.</p>",
        "id": 474805447,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728042383
    },
    {
        "content": "<p>It is easy to add more tactics to the \"flexible\" list and maybe there is a case for <code>field_simp</code> to be flexible.  I am not sure that <code>linear_combination</code> should count as flexible, though, since it is quite fixed to exact shapes, I think.</p>",
        "id": 474805683,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728042464
    },
    {
        "content": "<p>I think of <code>field_simp</code> and <code>linear_combination</code> as flexible, FWIW</p>",
        "id": 474805788,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1728042490
    },
    {
        "content": "<p>With <code>linear_combination</code>, also if it uses a hypothesis that has been the target of <code>simp</code>?</p>",
        "id": 474806498,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728042726
    },
    {
        "content": "<p>Surely yes?</p>",
        "id": 474806842,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1728042857
    },
    {
        "content": "<p>I view it as somewhat brittle, since that hypothesis could change with an increase/decrease in the simp-set and it is not clear that <code>linear_combination</code> would be able to cope.</p>",
        "id": 474807002,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728042929
    },
    {
        "content": "<p>But it is almost no work to make <code>linear_combination</code> and <code>field_simp</code> flexible, and I am happy to add them!</p>",
        "id": 474807069,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728042958
    },
    {
        "content": "<p>I'd argue that they are flexible, unless you change their default normalisation (and I'm very guilty of this)</p>",
        "id": 474811330,
        "sender_full_name": "David Ang",
        "timestamp": 1728044493
    },
    {
        "content": "<p>Ok, here is an example which is maybe not too contrived of why I am not completely convinced that <code>linear_combination</code> is flexible:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">--simp at h2  -- uncomment to break `linear_combination`</span>\n<span class=\"w\">  </span><span class=\"n\">linear_combination</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">*</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n</code></pre></div>",
        "id": 474812376,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728044886
    },
    {
        "content": "<p>Yeah, I don't think it is</p>",
        "id": 474812438,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1728044910
    },
    {
        "content": "<p>Of course, any tactic could be broken by doing something different before it, so really <em>everything</em> is rigid.</p>",
        "id": 474812495,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728044938
    },
    {
        "content": "<p><code>field_simp</code> is a difficult one, though</p>",
        "id": 474812507,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1728044942
    },
    {
        "content": "<p>But my mental model is that <code>simp</code> is \"truly\" flexible, while <code>linear_combination</code> is \"somewhat flexible\", but not so much.</p>",
        "id": 474812557,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728044964
    },
    {
        "content": "<p>If this is the case, then arguably <code>field_simp; linear_combination</code> should be flagged, but it's not?</p>",
        "id": 474812757,
        "sender_full_name": "David Ang",
        "timestamp": 1728045040
    },
    {
        "content": "<p>Something probably has to be done about <code>field_simp</code>, but I view <code>field_simp</code> as a \"normalization\" tactic: it should (in theory) produce a reliably equal result from a range of inputs, like <code>norm_num</code>: this, to me, makes it look like a tactic that can follow a flexible one and can be followed by whatever.</p>",
        "id": 474813042,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728045136
    },
    {
        "content": "<p>(Right now, though, I think that <code>field_simp</code> is purely rigid and cannot follow a flexible one.)</p>",
        "id": 474813086,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728045154
    },
    {
        "content": "<p>So, I think that <code>field_simp; linear_combination</code> is ok, the linter correctly does not flag it, but for the wrong reason!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 474813312,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728045243
    },
    {
        "content": "<p>But doesn't <code>field_simp</code> do everything that <code>simp</code> does, except for three lemmas that surely doesn't make it a lot more flexible than <code>simp</code>? I'm now also confused about <code>norm_num</code> because isn't it just <code>norm_num1; simp</code>?</p>",
        "id": 474813546,
        "sender_full_name": "David Ang",
        "timestamp": 1728045335
    },
    {
        "content": "<p>To give a little bit of extra context, the \"flexible\" linter started as a \"non-terminal <code>simp</code> linter\".  It evolved in splitting tactics into \"flexible\" and \"rigid\": a \"rigid\" tactic cannot follow a \"flexible\" one, since the output of a flexible one is unreliable and could break the rest of the proof.</p>",
        "id": 474813557,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728045341
    },
    {
        "content": "<p>In development, some tactics actually take a variety of inputs and convert them to normal form, like <code>norm_num</code>: if you stray a little from the initial input, chances are that <code>norm_num</code> will return the same result.</p>",
        "id": 474813712,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728045392
    },
    {
        "content": "<p>Such tactics can more reliably be followed by rigid ones, since it would be a big jump to make them normalize to something different.</p>",
        "id": 474813777,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728045416
    },
    {
        "content": "<p>These tactics are \"stoppers\": they can follow a flexible one, since they can adapt to multiple outputs, but have \"fewer\" outputs, so can be followed by rigid ones.</p>",
        "id": 474813851,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728045447
    },
    {
        "content": "<p>In this context, there is always some discretion of \"how big of a change you expect the typical change to be\".</p>",
        "id": 474813930,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728045477
    },
    {
        "content": "<p>Of course, a big enough change will break whatever.</p>",
        "id": 474813981,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728045487
    },
    {
        "content": "<p>Here is my concern: take your example above and replace <code>simp</code> with <code>norm_num</code> or <code>field_simp</code>, and they both break</p>",
        "id": 474814071,
        "sender_full_name": "David Ang",
        "timestamp": 1728045532
    },
    {
        "content": "<p>But the kind of <code>simp</code> inside <code>norm_num</code> and <code>field_simp</code> is not \"all <code>simp</code> lemmas\", but \"a curated list of lemmas, some that are <code>simp</code>, some that make sense in this context.</p>",
        "id": 474814080,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728045536
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"464700\">David Ang</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/474814071\">said</a>:</p>\n<blockquote>\n<p>Here is my concern: take your example above and replace <code>simp</code> with <code>norm_num</code> or <code>field_simp</code>, and they both break</p>\n</blockquote>\n<p>Right, so I view this as evidence that <code>linear_combination</code> is \"rigid\".  As for <code>norm_num</code> and <code>field_simp</code>, they of course can normalize to something different, but I view this as more rare.</p>",
        "id": 474814404,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728045644
    },
    {
        "content": "<p>If your point of view is \"a change in the previous tactic <em>may</em> break the next\", then nothing would be allowed.</p>",
        "id": 474814510,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728045679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"464700\">David Ang</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/474812757\">said</a>:</p>\n<blockquote>\n<p>If this is the case, then arguably <code>field_simp; linear_combination</code> should be flagged, but it's not?</p>\n</blockquote>\n<p>Given that <code>field_simp</code> is meant as a preprocessor to tactics like <code>ring</code> and <code>linear_combination</code>, it would be very damageable to forbid <code>field_simp; linear_combination</code>!</p>",
        "id": 474814572,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1728045703
    },
    {
        "content": "<p>Right, the example above with <code>field_simp</code> instead of <code>simp</code> breaks <code>linear_combination</code>, but it is unlikely that a <em>working</em> pair <code>field_simp; linear_combination</code> would break after a change in <code>field_simp</code>.</p>",
        "id": 474814891,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728045820
    },
    {
        "content": "<p>Whereas a working pair <code>simp; linear_combination</code> is less likely to continue working, as <code>simp</code> evolves.</p>",
        "id": 474815056,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728045862
    },
    {
        "content": "<p>Right, but your \"change\" in <code>field_simp</code> (that is unlikely to break) refers exclusively to changes in <code>field_simps</code></p>",
        "id": 474815305,
        "sender_full_name": "David Ang",
        "timestamp": 1728045942
    },
    {
        "content": "<p>Yes, I expect <code>field_simp</code> to converge to some normal form that is \"highly unlikely\" to change: an expression of the form <code>2 * x / 2</code> should be normalized to <code>x</code> no matter how many times <code>field_simp</code> is reimplemented.</p>",
        "id": 474815539,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728046016
    },
    {
        "content": "<p>Whereas whether that same expression is simplified or not by a <code>simp</code> lemma depends more unreliably on the <code>simp</code> set.</p>",
        "id": 474815648,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728046056
    },
    {
        "content": "<p>That's why I consider <code>field_simp; something_else</code> \"robust\": the <code>something_else</code> is using a \"field normal form\".  Something unusual has to have happened for the notion of \"field normal form\" to have changed.</p>",
        "id": 474815960,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728046164
    },
    {
        "content": "<p>Maybe my concern is better phrased like this: currently we have tactics (e.g. <code>field_simp</code> or <code>norm_num</code>) that are basically <code>(do something); simp</code>, and you argue that we can put them before doing something rigid. On the other hand, I could may well do <code>(do something); simp; (do something rigid)</code>, which should have identical behaviour but is flagged.</p>",
        "id": 474815964,
        "sender_full_name": "David Ang",
        "timestamp": 1728046166
    },
    {
        "content": "<p>They are not a \"free\" <code>simp</code>, they are a \"controlled <code>simp</code>\".</p>",
        "id": 474816031,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728046192
    },
    {
        "content": "<p>You should view them more as <code>simp only</code>s.</p>",
        "id": 474816058,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728046201
    },
    {
        "content": "<p>How controlled are they? I don't know exactly how they're defined but the docs tell me e.g.: <code>field_simp [hx, hy]</code> is a short form for <code>simp (disch := field_simp_discharge) [-one_div, -one_divp, -mul_eq_zero, hx, hy, field_simps]</code>, which is quite far from being a <code>simp only</code>?</p>",
        "id": 474816572,
        "sender_full_name": "David Ang",
        "timestamp": 1728046347
    },
    {
        "content": "<p>From the doc-string of <code>field_simp</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"ss\">`field_simp</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">expression</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">field</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">expression</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">form</span><span class=\"w\"> </span><span class=\"ss\">`n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">`</span>\n<span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">neither</span><span class=\"w\"> </span><span class=\"ss\">`n</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">nor</span><span class=\"w\"> </span><span class=\"ss\">`d</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"n\">division</span><span class=\"w\"> </span><span class=\"n\">symbol</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">just</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">simplifier</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">carefully</span>\n<span class=\"n\">crafted</span><span class=\"w\"> </span><span class=\"n\">simpset</span><span class=\"w\"> </span><span class=\"n\">named</span><span class=\"w\"> </span><span class=\"ss\">`field_simps</span><span class=\"bp\">`</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 474816627,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728046366
    },
    {
        "content": "<p>There are about 40 <code>field_simps</code> lemmas.</p>",
        "id": 474817109,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728046525
    },
    {
        "content": "<p>Right, then shouldn't the implementation be closer to <code>simp only [field_simps]</code> rather than <code>simp [field_simps]</code>?</p>",
        "id": 474817152,
        "sender_full_name": "David Ang",
        "timestamp": 1728046538
    },
    {
        "content": "<p>I think David's point is that it does not use <code>only</code></p>",
        "id": 474817173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728046545
    },
    {
        "content": "<p>likewise for <code>norm_num</code></p>",
        "id": 474817185,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728046549
    },
    {
        "content": "<p>The <code>field_simps</code> set of lemmas is indeed added to the simpset when applying <code>field_simp</code>, but almost nothing is removed if I recall correctly, so adding new simp lemmas will definitely change the outcome of <code>field_simp</code>. In terms of rigidity, <code>simp</code> and <code>field_simp</code> should definitely be on the same line.</p>",
        "id": 474817190,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1728046551
    },
    {
        "content": "<p>Or should we change that? I'm not sure I want <code>field_simp</code> to go changing random things in my goal</p>",
        "id": 474817354,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1728046603
    },
    {
        "content": "<p>Or we could have both</p>",
        "id": 474817374,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1728046610
    },
    {
        "content": "<p>Ok, so I can then make <code>field_simp</code> flexible and then <code>linear_combination</code> would not be allowed to follow it.</p>",
        "id": 474817401,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728046621
    },
    {
        "content": "<p><code>field_simp only</code>?</p>",
        "id": 474817427,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728046633
    },
    {
        "content": "<p>you can already do this for <code>norm_num</code></p>",
        "id": 474817457,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728046644
    },
    {
        "content": "<p>So <code>only</code> would mean \"just <code>field_simps</code> (plus whatever you explicitly add)\"?</p>",
        "id": 474817621,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728046684
    },
    {
        "content": "<p>That would probably be clearly a stopper tactic!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 474817719,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1728046718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/474817457\">said</a>:</p>\n<blockquote>\n<p>you can already do this for <code>norm_num</code></p>\n</blockquote>\n<p>You mean <code>norm_num1</code>? Or can we do <code>norm_num only</code>?</p>",
        "id": 474818174,
        "sender_full_name": "David Ang",
        "timestamp": 1728046853
    },
    {
        "content": "<p>I do think having <code>field_simp only</code> would be very nice, but I don't know how well this works in practice because if I remember correctly the 40 lemmas in <code>field_simps</code> doesn't actually do very much without calling all of <code>simp</code></p>",
        "id": 474818739,
        "sender_full_name": "David Ang",
        "timestamp": 1728046995
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"464700\">David Ang</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/474818174\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/474817457\">said</a>:</p>\n<blockquote>\n<p>you can already do this for <code>norm_num</code></p>\n</blockquote>\n<p>You mean <code>norm_num1</code>? Or can we do <code>norm_num only</code>?</p>\n</blockquote>\n<p>Both. <code>norm_num1</code> doesn't use the simplifier at all, and <code>norm_num only</code> uses the simplifier with the usual meaning of <code>simp only</code></p>",
        "id": 474834147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1728051671
    }
]