[
    {
        "content": "<p>Mathlib has a lot of types for \"sub-Foos of a Foo\" – e.g. subgroups, submonoids, subrings, etc – which all use the <code>SetLike</code> typeclass to record that they coerce to subsets of the parent.</p>\n<p>In many cases these sub-Foo types have lattice or semilattice structures (sup, inf, top, bottom, etc), which are frequently, but not always, compatible with coercion to Set; e.g. for subgroups of a group, <code>inf</code> is intersection, but <code>sup</code> is something else (the subgroup generated by the two given subgroups). The API for these is defined separately in each case, leading to a great deal of duplicated code. </p>\n<p>I think this could be factored out by using typeclasses asserting \"this SetLike class has an <code>inf</code> compatible with set intersection\", something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">LawfulInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Min</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe_inf'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">b</span>\n</code></pre></div>\n<p>and similarly for <code>top</code>, <code>bot</code>, <code>sInf</code>, etc. Then we can develop all the API once for an arbitrary <code>SetLike</code> satisfying the appropriate <code>LawfulXXX</code> typeclasses, rather than proving lemmas like <code>mem_inf</code> etc over and over again.</p>\n<p>What's the opinion of the community on this? Would this be a worthwhile refactor? This would be quite a lot of work to implement, so I wanted to ask for opinions here first.</p>",
        "id": 493227096,
        "sender_full_name": "David Loeffler",
        "timestamp": 1736720515
    },
    {
        "content": "<p>Isn't there a recent thread involving <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> and <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> (among others) about this?</p>",
        "id": 493227214,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1736720634
    },
    {
        "content": "<p>I thought the consensus there was to stop creating the <code>LE</code> instance from <code>SetLike</code> directly.</p>",
        "id": 493227329,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1736720720
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"400289\">@Artie Khovanov</span></p>",
        "id": 493227402,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1736720781
    },
    {
        "content": "<p><a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Abstracting.20out.20.2Eclosure.2C.20.2Eadjoin\">#mathlib4 &gt; Abstracting out .closure, .adjoin</a></p>",
        "id": 493227425,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1736720805
    },
    {
        "content": "<p>Great minds think alike :p<br>\n<span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span> see my proposal in progress at <a href=\"https://github.com/leanprover-community/mathlib4/pull/20621\">#20621</a></p>",
        "id": 493227462,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736720845
    },
    {
        "content": "<p>Note that \"LawfulSInf\" is pretty much always true and implies \"LawfulTop\", \"LawfulInf\", and the existence of a <code>CompleteLattice</code> structure<br>\nOTOH \"LawfulSSup\", \"LawfulSup\", \"LawfulBot\" are pretty much always false, and when they're true it's for a \"genuinely mathematical\" reason, rather than just the fact that these substructures are given by a single carrier field and then a bunch of closure conditions.<br>\nSo I've just gone with the one typeclass for simplicity.</p>",
        "id": 493227540,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736720909
    },
    {
        "content": "<blockquote>\n<p>\"LawfulSSup\", \"LawfulSup\", \"LawfulBot\" are pretty much always false</p>\n</blockquote>\n<p>LawfulSup and LawfulBot are true for some interesting SetLikes, e.g. open sets in a topological space. But these aren't really of the nature of \"subFoo's of a Foo\".</p>",
        "id": 493227741,
        "sender_full_name": "David Loeffler",
        "timestamp": 1736721081
    },
    {
        "content": "<p>Indeed. Obviously you could also build out those abstractions, but I'm not sure how much they would be reused.</p>",
        "id": 493227816,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736721129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/proposal.3A.20lattice.20operations.20on.20.60SetLike.60s.3F/near/493227462\">said</a>:</p>\n<blockquote>\n<p>Great minds think alike :p<br>\n<span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> see my proposal in progress at <a href=\"https://github.com/leanprover-community/mathlib4/pull/20621\">#20621</a></p>\n</blockquote>\n<p>\"Files changed: 154\" - ouch!</p>",
        "id": 493227817,
        "sender_full_name": "David Loeffler",
        "timestamp": 1736721130
    },
    {
        "content": "<p>Those changes are mostly from the PR it depends on (<a href=\"https://github.com/leanprover-community/mathlib4/pull/20638\">#20638</a>)<br>\nIn my draft, I've only done the full refactor for one substructure -- the simplest (<code>Subsemigroup</code>) -- as a proof of concept. When completed, this refactor will change hundreds of files, mostly to rename usages of previously-duplicated theorems.</p>",
        "id": 493227933,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736721229
    },
    {
        "content": "<p>Just out of interest, can you prove a version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subsemigroup.mem_iSup_of_directed#doc\">docs#Subsemigroup.mem_iSup_of_directed</a> for a <code>LatticeSetLike</code>?</p>",
        "id": 493228142,
        "sender_full_name": "David Loeffler",
        "timestamp": 1736721375
    },
    {
        "content": "<p>Yes, I should be able to -- after all, the infima determine the suprema.<br>\nLet me try now.</p>",
        "id": 493228183,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736721436
    },
    {
        "content": "<p>I think it needs more axioms than you currently have: I think it's false for closed subspaces of topological vector spaces (which are preserved by arbitrary intersections, but not by filtered unions).</p>",
        "id": 493229244,
        "sender_full_name": "David Loeffler",
        "timestamp": 1736722405
    },
    {
        "content": "<p>As yep, the missing axiom is basically the conclusion of <code>mem_iSup_of_directed</code><br>\nIt says that the embedding into the power set reflects directed unions</p>",
        "id": 493229331,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736722481
    },
    {
        "content": "<p>Proving this is a bit different each time (you might need to induct on different closure axioms), but the consequences are always the same. I think abstracting it out is outside of the scope of my current refactor, but of course you or anyone else is very welcome to have a go!</p>",
        "id": 493229460,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1736722598
    },
    {
        "content": "<p>It's funny that so many people have come to this conclusion at roughly the same time.</p>",
        "id": 493320513,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736765973
    },
    {
        "content": "<p>May I suggest that we merge the two threads of discussion, going forward?<br>\nLet's continue with <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Abstracting.20the.20substructure.20lattice.20construction\">#mathlib4 &gt; Abstracting the substructure lattice construction</a>, since that thread is slightly older.</p>",
        "id": 493320704,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1736766025
    }
]