[
    {
        "content": "<p>In which cases we prefer <code>RingHomClass.toRingHom</code> over <code>RingEquiv.toRingHom</code> in which cases the converse?<br>\nI found most semi-linear equiv use the former one. However, when synethizing instance about <code>Functor.IsEquivalence</code>, I found <code>ModuleCat.restrictScalars_isEquivalence_of_ringEquiv</code> using <code>RingEquiv.toRingHom</code>. So I am a bit confused.</p>",
        "id": 560732351,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1764319723
    },
    {
        "content": "<p>I think <code>RingEquiv.toRingHom</code> is preferred, since it allows for better simplification.</p>",
        "id": 561133709,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1764588744
    },
    {
        "content": "<p>I think we are getting rid of <code>RingEquiv.toRingHom</code> (or maybe make it an abbrev of <code>RingHomClass.toRingHom</code> for dot notation), see <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/should.20one.20explicit.20coercions.3F/near/558911760\">#mathlib4 &gt; should one explicit coercions? @ üí¨</a>.</p>",
        "id": 561135005,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1764589168
    },
    {
        "content": "<p>However as in semi linear equiv, <code>RingHomClass.toRingHom</code> is used every where. This is the confusing part.</p>",
        "id": 561136381,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1764589600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/RingHomClass.2EtoRingHom.20vs.20RingEquiv.2EtoRingHom/near/561135005\">said</a>:</p>\n<blockquote>\n<p>I think we are getting rid of <code>RingEquiv.toRingHom</code> (or maybe make it an abbrev of <code>RingHomClass.toRingHom</code> for dot notation), see <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/should.20one.20explicit.20coercions.3F/near/558911760\">#mathlib4 &gt; should one explicit coercions? @ üí¨</a>.</p>\n</blockquote>\n<p>No, <code>RingEquiv.toRingHom</code> will stay and <code>RingHomClass.toRingHom e</code> will simplify to <code>RingEquiv.toRingHom e</code>.</p>",
        "id": 561137120,
        "sender_full_name": "Christian Merten",
        "timestamp": 1764589824
    },
    {
        "content": "<p>What's the benefit of having two ways of spelling the same thing other than enabling dot notation?</p>",
        "id": 561149992,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1764593486
    },
    {
        "content": "<p>The point is we are getting rid of <code>RingHomClass.toRingHom</code> eventually so there will only be one way in the end. See <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Mathlib.27s.20morphism.20hierarchy/with/558812628\">#mathlib4 &gt; Mathlib's morphism hierarchy</a></p>",
        "id": 561150437,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1764593609
    },
    {
        "content": "<p>If you get rid of RingHomClass.toRingHom and you also want <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHom.ker#doc\">docs#RingHom.ker</a> to take RingHom rather than RingHomClass, then how do you apply <code>RingHom.ker</code> to an <code>AlgEquiv</code>? (You can still apply it to <code>AlgHom</code> since it extends <code>RingHom</code> so we can't get rid of <code>AlgHom.toRingHom</code>.)</p>",
        "id": 561157182,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1764595298
    },
    {
        "content": "<p>My idea was (but not sure if this ended up in the consensus) that <code>RingEquiv.toRingHom</code> and <code>AlgEquiv.toRingEquiv</code> will become the new coercions, so we'd write <code>RingHom.ker (‚Üëe)</code>.</p>",
        "id": 561163086,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1764596654
    },
    {
        "content": "<p>If <code>e : AlgEquiv R A B</code> then <code>e.toAlgHom.toRingHom</code> and <code>e.toRingEquiv.toRingHom</code> form a non-reducibly-defeq diamond:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ‚Çê</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">toAlgHom</span><span class=\"bp\">.</span><span class=\"n\">toRingHom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">toRingEquiv</span><span class=\"bp\">.</span><span class=\"n\">toRingHom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">with_reducible</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>so I think it's better to use <code>RingHomClass.toRingHom</code> as the normal form (we can provide lemma to rewrite it to both sides of the diamond). <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> doesn't like <code>FooHomClass.toFooHom</code> being coercions, but I think it's fine.</p>",
        "id": 561166449,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1764597403
    },
    {
        "content": "<p>Have you read Jireh's post? In particular this section</p>\n<blockquote>\n<p>Another issue is that we (and I have certainly been guilty of this before I saw the light) have implemented¬†<em>definitions</em>¬†which take a term of a morphism¬†<em>class</em>¬†(rather than a morphism itself) as a parameter. At first, this seems appealing, but the problem is that doing doesn't really create a single definition, but in some sense it is a definition schema, with one new definition for each instance of the morphism class. For example, since¬†<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgHom#doc\">docs#AlgHom</a>¬†is an instance of¬†<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHomClass#doc\">docs#RingHomClass</a>, and since¬†<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHom.ker#doc\">docs#RingHom.ker</a>¬†takes a term of a¬†<code>RingHomClass</code>¬†as an argument, if¬†<code>f : A ‚Üí‚Çê[R] B</code>¬†is an algebra homomorphism we have both¬†<code>RingHom.ker f</code>¬†and¬†<code>RingHom.ker (‚Üëf : A ‚Üí+* B)</code>, and these are not trivially equal. Thus we would need additional API to go between them. So, we should restrict definitions to explicit morphisms, instead of morphism classes in order to avoid proliferating definitions.</p>\n</blockquote>",
        "id": 561171898,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1764598649
    },
    {
        "content": "<p>So, how about this : I add a version <code>RingHomInvPair e.toRingHom e.symm.toRingHom</code> and refactor as much as I can foresee? Is this the correct way? (I am dealing with these kind of stuffs.)</p>",
        "id": 561195572,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1764603363
    },
    {
        "content": "<p>I read the post and I think this \"another issue\" you quoted is more important, and the previous issue is less. Namely, I agree <code>RingHom.ker</code> should take a <code>RingHom</code> but I don't care whether it's <code>RingHom.ker (‚Üëf)</code> or <code>RingHom.ker (.ofClass f)</code>.<br>\nI also think it would be nice to write <code>f.toRingHom.ker</code>, but it would be ideal that <code>f.toRingHom</code> is reducibly defeq to <code>RingHom.ofClass f</code> (currently called <code>RingHomClass.toRingHom f</code>). Unfortunately for the projections generated by <code>extends</code> (like <code>AlgHom.toRingHom</code>) we cannot achieve this.</p>",
        "id": 561203764,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1764605048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/RingHomClass.2EtoRingHom.20vs.20RingEquiv.2EtoRingHom/near/561203764\">said</a>:</p>\n<blockquote>\n<p>Namely, I agree <code>RingHom.ker</code> should take a <code>RingHom</code> but I don't care whether it's <code>RingHom.ker (‚Üëf)</code> or <code>RingHom.ker (.ofClass f)</code>.</p>\n</blockquote>\n<p>Right, the biggest issue I think is <em>definitions parameterized over hom classes</em>, which is exacerbated by the <code>.ofClass</code> constructors being coercions.</p>\n<p>If <code>f</code> is a term of a <em>fixed</em> morphism type, I think it might be okay to use <code>.ofClass f</code> to get down to a lower morphism type. Just be prepared that there may not be many lemmas available for it. Although myself I would probably opt for <code>AlgEquiv.toRingEquiv.toRingHom</code>, diamond notwithstanding.</p>",
        "id": 561277850,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1764624373
    }
]