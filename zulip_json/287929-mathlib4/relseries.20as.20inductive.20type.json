[
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RelSeries#doc\">docs#RelSeries</a> is currently defined as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RelSeries</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">castSucc</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which I find rather hard to work with, because of the <code>Fin.castSucc</code>, <code>Fin.succ</code> etc. At first glance it seemed to me that this could instead be an inductive type  on two constructors, but after trying some things, I am no longer convinced it is possible in a useful way. What is certainly possible is to define the type of <code>RelSeries</code> with fixed head as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">RelSeries'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rel</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">singleton</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RelSeries'</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hxy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RelSeries'</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RelSeries'</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>I can imagine that this simplifies things, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RelSeries#doc\">docs#RelSeries</a> would be a sigma type on top of that, where most of the api is developed for <code>RelSeries'</code>.</p>\n<p>What do people think? Is it really not possible to give a direct definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RelSeries#doc\">docs#RelSeries</a> that gives useful induction principles?</p>",
        "id": 501838612,
        "sender_full_name": "Christian Merten",
        "timestamp": 1740498316
    },
    {
        "content": "<p>Alternatively, we can of course just add this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">RelSeries</span><span class=\"bp\">.</span><span class=\"n\">inductionOn</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rel</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RelSeries</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">singleton</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RelSeries</span><span class=\"bp\">.</span><span class=\"n\">singleton</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RelSeries</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RelSeries</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 501839119,
        "sender_full_name": "Christian Merten",
        "timestamp": 1740498387
    },
    {
        "content": "<p>Surely using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Chain%27#doc\">docs#List.Chain'</a> works better here?</p>",
        "id": 501843994,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740499224
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RelSeries.Equiv#doc\">docs#RelSeries.Equiv</a> which is the equiv with the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Chain%27#doc\">docs#List.Chain'</a> definition.</p>",
        "id": 501844128,
        "sender_full_name": "Christian Merten",
        "timestamp": 1740499253
    },
    {
        "content": "<p>I think adding the recursive principle as a def (since afaict it should work for <code>Sort</code> too) would be best, for the same reason why Vector isn't an inductive type</p>",
        "id": 501844799,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740499409
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/287929-mathlib4/topic/relseries.20as.20inductive.20type/near/501844128\">said</a>:</p>\n<blockquote>\n<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RelSeries.Equiv#doc\">docs#RelSeries.Equiv</a> which is the equiv with the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Chain%27#doc\">docs#List.Chain'</a> definition.</p>\n</blockquote>\n<p>But also that is rather painful, since you still don't get nice induction principles.</p>",
        "id": 501844969,
        "sender_full_name": "Christian Merten",
        "timestamp": 1740499450
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/relseries.20as.20inductive.20type/near/501844799\">said</a>:</p>\n<blockquote>\n<p>I think adding the recursive principle as a def (since afaict it should work for <code>Sort</code> too) would be best, for the same reason why Vector isn't an inductive type</p>\n</blockquote>\n<p>What is that reason?</p>",
        "id": 501845079,
        "sender_full_name": "Christian Merten",
        "timestamp": 1740499480
    },
    {
        "content": "<p>I guess it's not quite the same reason, but in general I think it's better to reuse existing types and predicates rather than defining new ones, since recreating the API will be lots easier</p>",
        "id": 501845999,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740499702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/relseries.20as.20inductive.20type/near/501845999\">said</a>:</p>\n<blockquote>\n<p>I guess it's not quite the same reason, but in general I think it's better to reuse existing types and predicates rather than defining new ones, since recreating the API will be lots easier</p>\n</blockquote>\n<p>I just found this <a class=\"stream-topic\" data-stream-id=\"144837\" href=\"/#narrow/channel/144837-PR-reviews/topic/StrictSeries.20.214.233858.2C.20.214.233852/with/356952195\">#PR reviews &gt; StrictSeries !4#3858, !4#3852</a>, where there was some discussion on that.</p>",
        "id": 501847105,
        "sender_full_name": "Christian Merten",
        "timestamp": 1740499989
    },
    {
        "content": "<p>and where Kim suggested both your suggestion and my <code>RelSeries'</code> from above.</p>",
        "id": 501847258,
        "sender_full_name": "Christian Merten",
        "timestamp": 1740500042
    }
]