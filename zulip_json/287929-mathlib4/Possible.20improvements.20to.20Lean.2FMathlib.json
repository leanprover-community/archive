[
    {
        "content": "<p>I kept a list of things I noticed I think could be improved in Lean/Mathlib. Some easier and some harder to fix. I'm not sure of the most efficient way to deal with these, so I'll just post this list, and I'm wondering which of these points people agree with.</p>\n<h1>Mathlib</h1>\n<p>(1) <code>norm_cast</code> doesn't use <code>Fin.cast_val_eq_self</code>, i.e. doesn't simplify <code>Nat.cast (Fin.val n)</code> to <code>n</code>.<br>\n(2) <code>cases (r:ℚ)</code> should replace <code>r</code> with <code>_ / _</code> instead of an application of <code>Rat.mk'</code>.<br>\n(3) <code>push_neg</code> should be aware of <code>Infinite</code>, <code>Finite</code>, <code>Set.Infinite</code> and <code>Set.Finite</code>.<br>\n  This should be easy to implement since <code>push_neg</code> isn't imported where these are defined.<br>\n(4) <code>add_self</code> should be the lemma <code>two_mul</code> in the opposite rewrite direction,<br>\n  as this is the more simplifying direction of the rewrite. (similarly <code>mul_self</code>)<br>\n(5) a <code>ring_nf</code> option to normalize a ring equality <code>a = b</code> to <code>a - b = 0</code>.<br>\n  This helps when terms are on different sides of <code>=</code> in different places.<br>\n(6) I want to be able to add something to both sides of an equation.<br>\n  It is possible to add the same thing on both sides with <code>add_left_inj _</code>.<br>\n  But I also want to be able to add <code>h : a = b</code> (i.e. add <code>a</code> to one side and <code>b</code> to the other)<br>\n<code>linear_combination</code> does this, but for some reason it is a terminal tactic.<br>\n  Not all such goals are terminated by <code>linear_combination</code>.</p>\n<h1>Lean</h1>\n<p>(7) <code>Not.imp</code> should be an alias of <code>mt</code>, instead of having its arguments swapped,<br>\n  to match lemmas like <code>And.imp</code> and <code>Exists.imp</code>.<br>\n(8) <code>suffices</code> should work with incremental elaboration,<br>\n  when working inside the <code>suffices</code> block, just like with <code>have</code>.<br>\n(9) in <code>conv</code> mode, <code>simp</code>, <code>unfold</code>, etc should throw errors when doing nothing (like they usually do)<br>\n(10) simp should keep variable names:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">20</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- `y` turns into `x`</span>\n</code></pre></div>\n<p>(11) The apply tactic should deal with autoparams, instead of creating a goal of type <code>autoParam _ _</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">ncard</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">trans</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">ncard_inter_le_ncard_right</span>\n<span class=\"w\">  </span><span class=\"c1\">-- case ht</span>\n<span class=\"w\">  </span><span class=\"c1\">-- n : ℕ</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ autoParam {a | a = n}.Finite _auto✝</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- n : ℕ</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ {a | a = n}.ncard ≤ 1</span>\n</code></pre></div>\n<p>(12) higher order unification that can solve unifications of the form <code>?P n.val =?= ...</code> where <code>...</code> contains <code>n.val</code>.<br>\n  This should be an opt-in configuration in <code>simp</code>, <code>rw</code> etc. This is also useful for rewriting with something like <code>← Classical.skolem</code><br>\n(13) An improved version of kabstract/generalize that avoids \"motive not type correct\" by<br>\n  only abstracting the abstractable terms.<br>\n  For example, if the goal is something like<br>\n<code>\n  f : ℕ → ℕ\n  h : ∀ (n : ℕ), f n = f (n + 1)\n  ⊢ (5 : Fin 10) = 5 ∧ f 0 = f 10\n  </code><br>\n  Then I want <code>induction 10</code> (or <code>rw</code>) to realize which <code>10</code> can be inducted on,<br>\n  and that the <code>10</code> in <code>Fin 10</code> cannot be abstracted.<br>\n  This can be done in a way that doesn't inhibit performance,<br>\n  by only doing this after encountering the motive type error.<br>\n  The way to implement this, is to create a metavariable hole for each occurrence of <code>10</code>,<br>\n  and then run <code>check</code> on this expression. This will instantiate some of these metavariables to<br>\n<code>10</code> if that is needed for typechecking. Then the remaining metaviarbles can be abstracted.</p>",
        "id": 499085779,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739303004
    },
    {
        "content": "<p>1-6 sound good to me, but need separate threads if you're hoping to persuade others to implement them. :-) PRs welcome for all those.</p>",
        "id": 499121028,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739319223
    },
    {
        "content": "<p>9, definitely, PR welcome</p>",
        "id": 499121044,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739319237
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> is working on 10</p>",
        "id": 499121091,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739319247
    },
    {
        "content": "<p>11, PR welcome, I think</p>",
        "id": 499121105,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739319256
    },
    {
        "content": "<p>8 sounds non-controversial, but perhaps Sebastian is best placed to implement it?</p>",
        "id": 499121148,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739319301
    },
    {
        "content": "<p>8 is probably a task for Sebastian U, or at least to wait for him to write an account of how to enable incremental elaboration for more tactics.</p>",
        "id": 499121159,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739319302
    },
    {
        "content": "<p>No opinion on 7</p>",
        "id": 499121500,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739319521
    },
    {
        "content": "<p>12 will have to wait, we don't have bandwidth for that</p>",
        "id": 499121528,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739319549
    },
    {
        "content": "<p>13 seems like a good experiment, and without promising merging, I'd be very interested to see a performant implementation</p>",
        "id": 499121558,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739319576
    },
    {
        "content": "<blockquote>\n<p><code>linear_combination</code> does this, but for some reason it is a terminal tactic.</p>\n</blockquote>\n<p>This was the behavior of <code>linear_combination</code> at one point. IIRC it was changed for technical reasons that I can't remember (<span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> ?)</p>",
        "id": 499123272,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1739320657
    },
    {
        "content": "<p>(6) Can be done with <code>congr()</code></p>",
        "id": 499139075,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1739330243
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Possible.20improvements.20to.20Lean.2FMathlib/near/499121091\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> is working on 10</p>\n</blockquote>\n<p>To be precise: I have added the <code>binderNameHint</code> in <a href=\"https://github.com/leanprover/lean4/pull/6947\">https://github.com/leanprover/lean4/pull/6947</a> which allows you to annotate rewrite rules such that binder names are preserved. This leaves the task of actually using it all the rewrite rules that have binders on the right hand side.</p>\n<p>In the example given, it seems the <code>x</code> comes from not from a rewrite rule, but from a congruence rule (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sum_congr#doc\">docs#Finset.sum_congr</a>), so unfortunately, <code>binderNameHint</code> isn't quite applicable there yet.</p>\n<p>I reproduced the issue on nightly (using <code>List.map</code> to avoid mathlib), and this needs more work before it works for congruence rules:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>section no_congr\n/--\nerror: tactic &#39;fail&#39; failed\nxs : List Nat\n⊢ xs = List.map (fun y =&gt; 1 + y) xs\n-/\n#guard_msgs in\nexample : xs = List.map (fun y =&gt; 1 + (y + 1 - 1)) xs := by\n  simp\n  fail\n\nend no_congr\n\nsection with_congr\n\n/--\ninfo: List.map_congr_left.{u_1, u_2} {α✝ : Type u_1} {l : List α✝} {α✝¹ : Type u_2} {f g : α✝ → α✝¹}\n  (h : ∀ (a : α✝), a ∈ l → f a = g a) : List.map f l = List.map g l\n-/\n#guard_msgs in\n#check List.map_congr_left\n\nattribute [local congr] List.map_congr_left\n\n/--\nerror: tactic &#39;fail&#39; failed\nxs : List Nat\n⊢ xs = List.map (fun a =&gt; 1 + a) xs\n-/\n#guard_msgs in\nexample : xs = List.map (fun y =&gt; 1 + (y + 1 - 1)) xs := by\n  simp -- NB: Changes variable name!\n  fail\n\nend with_congr\n\nsection with_congr_hint\n\n-- Trying to use the binderNameHint on a congruence rule\n\n\n--  this loops:\ntheorem List.map_congr_left&#39; {f g : α → β}  (h : ∀ (a : α), a ∈ l → (f a = g a)) : List.map f l = List.map (fun x =&gt; binderNameHint x f (g x)) l  :=\n  List.map_congr_left h\n\n-- this is not effective\ntheorem List.map_congr_left&#39;&#39; {f g : α → β}  (h : ∀ (a : α), a ∈ l → (binderNameHint a f (f a) = g a)) : List.map f l = List.map g l  := List.map_congr_left h\n\nattribute [congr] List.map_congr_left&#39;&#39;\n\n/--\nerror: tactic &#39;fail&#39; failed\nxs : List Nat\n⊢ xs = List.map (fun a =&gt; 1 + a) xs\n-/\n#guard_msgs in\nexample : xs = List.map (fun y =&gt; 1 + (y + 1 - 1)) xs := by\n  simp -- the binderNameHint is not effective on congruence rules yet :-()\n  fail\n\nend with_congr_hint\n</code></pre></div>\n</div></div>\n<p>Noted at issue <a href=\"https://github.com/leanprover/lean4/issues/7052\">https://github.com/leanprover/lean4/issues/7052</a></p>",
        "id": 499200589,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739357117
    },
    {
        "content": "<p>Possible fix for <code>binderNameHint</code> in congruence rules in <a href=\"https://github.com/leanprover/lean4/pull/7053\">lean4#7053</a>.</p>",
        "id": 499214766,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739361655
    },
    {
        "content": "<p>I've created PRs for the first 4 points now:<br>\n(1) <a href=\"https://github.com/leanprover-community/mathlib4/pull/21775\">#21775</a><br>\n(2) <a href=\"https://github.com/leanprover-community/mathlib4/pull/21767\">#21767</a> in addition to a <code>cases</code> eliminator for <code>Rat</code>, I've also added <code>Int.induction_on</code> as the default <code>induction</code> eliminator for <code>Int</code>.<br>\n(3) <a href=\"https://github.com/leanprover-community/mathlib4/pull/21769\">#21769</a> Unfortunately the extra import of <code>Mathlib.Data.Finite.Defs</code>is quite large. The question is whether this is OK, or if <code>push_neg</code> needs to be reimplemented to be extensible.<br>\n(4) <a href=\"https://github.com/leanprover-community/mathlib4/pull/21761\">#21761</a></p>",
        "id": 499265399,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739374919
    },
    {
        "content": "<p>For 3, I think extensibility of push_neg is the right thing to do</p>",
        "id": 499265835,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739374993
    },
    {
        "content": "<p>Do you think is should use the discrimination tree infrastructure of <code>simp</code> for applying lemmas? Currently it is implemented with a simple <code>match</code> on the name of the head constant after the <code>not</code>.</p>",
        "id": 499266296,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739375102
    },
    {
        "content": "<p>I guess we could also use the simpler <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.HeadIndex#doc\">docs#Lean.HeadIndex</a></p>",
        "id": 499266665,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739375194
    },
    {
        "content": "<p>Extensibility looks a lot more future-proof.</p>",
        "id": 499266735,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1739375210
    },
    {
        "content": "<p>For the sake of the bots, I'll repost the PRs, one per message.</p>",
        "id": 499268995,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739375782
    },
    {
        "content": "<p>(1) <a href=\"https://github.com/leanprover-community/mathlib4/pull/21775\">#21775</a></p>",
        "id": 499269030,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739375790
    },
    {
        "content": "<p>(2) <a href=\"https://github.com/leanprover-community/mathlib4/pull/21767\">#21767</a> in addition to a cases eliminator for Rat, I've also added Int.induction_on as the default induction eliminator for Int.</p>",
        "id": 499269044,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739375794
    },
    {
        "content": "<p>(3) <a href=\"https://github.com/leanprover-community/mathlib4/pull/21769\">#21769</a> Unfortunately the extra import of Mathlib.Data.Finite.Defsis quite large. The question is whether this is OK, or if push_neg needs to be reimplemented to be extensible.</p>",
        "id": 499269060,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739375798
    },
    {
        "content": "<p>(4) <a href=\"https://github.com/leanprover-community/mathlib4/pull/21761\">#21761</a></p>",
        "id": 499269068,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739375800
    },
    {
        "content": "<p>I really want <code>push_neg</code> to become extensible so that it can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.nonempty_iff_ne_empty#doc\">docs#Finset.nonempty_iff_ne_empty</a></p>",
        "id": 499273922,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1739376952
    },
    {
        "content": "<p>I think it already does that?</p>",
        "id": 499274279,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739377035
    },
    {
        "content": "<p>Nope, it does that for <code>Set</code>, not for <code>Finset</code> (which makes it even more irritating)</p>",
        "id": 499274420,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1739377071
    },
    {
        "content": "<p>Would extensionality here just amount to a simp set?</p>",
        "id": 499275937,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739377455
    },
    {
        "content": "<p>(in fact, is the whole tactic anything other than a simp set?)</p>",
        "id": 499276026,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739377479
    },
    {
        "content": "<p><del>It differs from just a simp set because it doesn't traverse the whole expression, only pushing the head negation.</del> Yes, a simp set should do the job for extensibility.</p>",
        "id": 499276720,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739377673
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span>  Thanks for posting these, do you mind if I add some of them to a tactic improvements tracking issue I maintain (<a href=\"https://github.com/leanprover-community/mathlib4/pull/10361\">#10361</a>)?</p>",
        "id": 499278841,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1739378234
    },
    {
        "content": "<p>I was looking at <code>push_cast</code> as inspiration for how to implement <code>push_neg</code>, but then I noticed that they both don't throw errors when doing nothing. So let's make that item (14) on the list: <code>push_cast</code> and <code>norm_cast</code> should throw an error when doing nothing.</p>",
        "id": 499287251,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739380547
    },
    {
        "content": "<p>\"Doing nothing\" should be caught by the <code>unusedTactic</code> linter, right?</p>",
        "id": 499290861,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739381599
    },
    {
        "content": "<p>Yes, but not when you are in the middle of writing a proof, only when the proof is complete. I want the tactic to tell me \"hey, I shouldn't exeist\" as soon as I write it.</p>",
        "id": 499291321,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739381743
    },
    {
        "content": "<p>That might be achievable: the linter explicitly shuts up if there are errors, but it need not do it.</p>",
        "id": 499291820,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739381886
    },
    {
        "content": "<p>When there are errors, it may be less clear that the tactic is really not doing anything, but if there is enough information available to read the state before and after the tactic, it may be reliable.</p>",
        "id": 499291980,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739381932
    },
    {
        "content": "<p>I just never tried it on syntax that was not fully formed.</p>",
        "id": 499292039,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739381948
    },
    {
        "content": "<p>I didn’t pay attention to the Lean 4 port of push_neg but I can tell you why the Lean 3 version was not a simp set. The main point was to keep variable names.</p>",
        "id": 499313245,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1739388824
    },
    {
        "content": "<p>I mean bound variables of course.</p>",
        "id": 499313271,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1739388836
    },
    {
        "content": "<p>Yes, and the rewrite rule of <code>¬ a = b</code> → <code>a ≠ b</code> cannot be expressed using simp, because this lemma is applicable to its own result.</p>",
        "id": 499314013,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739389064
    },
    {
        "content": "<p>But, what we can do is to keep the implementation for pushing negation through forall and exists, and the <code>¬ a = b</code> → <code>a ≠ b</code> rule, and let all the other rewrites be handled by a simp set.</p>",
        "id": 499314347,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739389161
    },
    {
        "content": "<p>On <a href=\"https://github.com/leanprover-community/mathlib4/pull/10361\">#10361</a>, I saw that people would like to generalize the <code>push_neg</code> tactic for other constants. I think that this can be done nicely using a single simp set for all <code>push</code> lemmas. Then the user could specify e.g. <code>push not</code>, which then would mean that it would only try to rewrite with these push lemmas on subexpressions that have head constant <code>not</code>.</p>",
        "id": 499315237,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739389447
    },
    {
        "content": "<p>Another reason for not using a simp lemma is to implement the option <code>push_neg.use_distrib</code>, which determines how to simplify <code>¬ (p ∧ q)</code></p>",
        "id": 499317566,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739390276
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span>, in the following example, <code>simp</code> still changes the bound variable name on the current nightly, which is because <code>exists_prop_congr</code> doesn't use the <code>binderNameHint</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- `x` turns into `h`</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 499932178,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739640045
    },
    {
        "content": "<p>Oh, yes, I just added the <code>binderNameHint</code> mechanism.  When, whether and how to annotate all simp lemmas in the standard library and mathlib is completely open yet :-)</p>\n<p>(And maybe <code>binderNameHint</code> isn’t the final word here, and there could be more automatic cleverness in simp)</p>",
        "id": 499946032,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739649750
    },
    {
        "content": "<p>(Note that this one is a congr lemma, not a simp lemma)</p>",
        "id": 499946143,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1739649857
    },
    {
        "content": "<p>Right; I should have said “lemma used by simp”</p>",
        "id": 499946169,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739649887
    }
]