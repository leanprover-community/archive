[
    {
        "content": "<p>I have a question about the simplifications rules in Turing.Tape ( Mathlib/Computability/Tape.lean ). Specifically, the theorem <code>Tape.write_mk'</code> uses <code>R.cons a</code> on the lhs and it would fit in my case, but it turns out that the following theorem from the same file is applied first (because my <code>R</code> is a <code>ListBlank.mk l</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ListBlank</span><span class=\"bp\">.</span><span class=\"n\">cons_mk</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Γ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">ListBlank</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ListBlank</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ListBlank</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This one rewrites the <code>R.cons a</code> into a different form such that <code>Tape.write_mk'</code> is no longer applicable and there is no similar simplification rule using the <code>ListBlank.mk (a :: l)</code> notation.</p>\n<p>Of course I can fix my proof by using <code>simp only</code> etc but it's still a bit unsatisfying. Is there anything that can be done to the simplification rules in this file?</p>",
        "id": 546675946,
        "sender_full_name": "chris477",
        "timestamp": 1761224928
    },
    {
        "content": "<p>well you (and the maintainers) will have to choose simp normal forms such that everything has one simp path</p>",
        "id": 546676444,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761225060
    },
    {
        "content": "<p>or if there are two simp NFs, make sure that both paths reach the destination</p>",
        "id": 546676524,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761225079
    },
    {
        "content": "<p>it's library building and it's a hard decision and it's not always obvious the first time and there's trial and error involved</p>",
        "id": 546676603,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761225099
    },
    {
        "content": "<p>a local solution would be using <code>simp [-ListBlank.cons_mk]</code> instead. A global solution would be to adapt <code>Tape.write_mk'</code> to instead apply to <code>ListBlank.mk (a :: l)</code> (or <em>add</em> that version as an additional simp lemma)</p>",
        "id": 546680964,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1761226281
    },
    {
        "content": "<p>i'm a bit surprised that this hasn't been caught earlier, i thought we had a linter checking that simp lemmas are in simp normal form?</p>",
        "id": 546681165,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1761226334
    },
    {
        "content": "<p>(which this one evidently <del>isn't</del> is, somewhat surprisingly)</p>",
        "id": 546681210,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1761226345
    },
    {
        "content": "<p>I think one reason could be that <code>ListBlank.cons_mk</code> requires the <code>ListBlank.mk l</code> constructor while <code>Tape.write_mk'</code> works with arbitrary <code>ListBlank</code>s. I can try adding a version of <code>Tape.write_mk'</code> that uses <code>ListBlank.mk (a :: l)</code>.</p>",
        "id": 546681730,
        "sender_full_name": "chris477",
        "timestamp": 1761226468
    },
    {
        "content": "<p>ahhh of course, that makes more sense</p>",
        "id": 546685473,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1761227410
    },
    {
        "content": "<p>I’ll create a pr!</p>",
        "id": 546685733,
        "sender_full_name": "chris477",
        "timestamp": 1761227465
    },
    {
        "content": "<p>-&gt; <a href=\"https://github.com/leanprover-community/mathlib4/pull/30821\">https://github.com/leanprover-community/mathlib4/pull/30821</a></p>",
        "id": 546700844,
        "sender_full_name": "chris477",
        "timestamp": 1761230898
    }
]