[
    {
        "content": "<p>I suggest that we redefine <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=VitaliFamily#doc\">docs#VitaliFamily</a> this way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">VitaliFamily</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œº</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Small sets of the family \"centered\" at a given point. -/</span>\n<span class=\"w\">  </span><span class=\"n\">filterAt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">filterAt_le_smallSets_nhds</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">filterAt</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ùìù</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">smallSets</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- All sets of the family are measurable. -/</span>\n<span class=\"w\">  </span><span class=\"n\">eventually_measurableSet</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ·∂†</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">filterAt</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">MeasurableSet</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The filter `filterAt x` is nontrivial for all `x`.</span>\n\n<span class=\"sd\">  TODO: review if we actually need it.</span>\n<span class=\"sd\">  -/</span>\n<span class=\"w\">  </span><span class=\"n\">filterAt_neBot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">filterAt</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">NeBot</span>\n<span class=\"w\">  </span><span class=\"n\">exists_covering</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">frequently_filterAt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚àÉ·∂†</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">filterAt</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">MapsTo</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">PairwiseDisjoint</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚â§·µê</span><span class=\"o\">[</span><span class=\"n\">Œº</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚ãÉ</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n</code></pre></div>\n<p>This highlights the fact that everything depends on <code>filterAt</code> only. Also, it gets rid of the metric and moves countability of <code>t</code> to the definition instead of deducing it from <code>SecondCountableTopology</code>. I'm not sure yet if we can define families that use something other than <code>(nhds x).smallSets  ‚äì ùìü _</code> for <code>filterAt</code>. CC: <span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span></p>",
        "id": 565302762,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1766596420
    },
    {
        "content": "<p>UPD: yes, we can redefine <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Vitali.vitaliFamily#doc\">docs#Vitali.vitaliFamily</a> to take <code>iSup</code> over all <code>C</code>.</p>",
        "id": 565304222,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1766597597
    },
    {
        "content": "<p>Are you motivated by an example which is not covered by the current theory but which becomes possible with the generalization?</p>",
        "id": 565306754,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1766599672
    },
    {
        "content": "<p>The proof I have in mind can be done with the current definitions, if you use a family of vitally families. However, it becomes more elegant with the family I described above.</p>",
        "id": 565310514,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1766602961
    },
    {
        "content": "<p>I'm on a phone now, I'll write down the details when I get home.</p>",
        "id": 565310540,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1766602993
    },
    {
        "content": "<p>Here are the details. Let <code>f : E ‚Üí F</code> be a map from a finite dimensional space <code>E</code>, <code>n = dim E</code>, to a normed space. If <code>f</code> is differentiable on <code>s</code> with derivative <code>f'</code>, and <code>f'.ker</code> is nontrivial at all points of <code>s</code>. Then <code>ŒºH[n] (f '' s) = 0</code>. This is a version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.addHaar_image_eq_zero_of_det_fderivWithin_eq_zero#doc\">docs#MeasureTheory.addHaar_image_eq_zero_of_det_fderivWithin_eq_zero</a> with weaker assumptions on the codomain. With the family I've described above, we can use a version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=VitaliFamily.measure_le_of_frequently_le#doc\">docs#VitaliFamily.measure_le_of_frequently_le</a> with <code>œÅ</code> being an outer measure, namely a large number multiplied by the pullback of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OuterMeasure.mkMetric%27.pre#doc\">docs#OuterMeasure.mkMetric'.pre</a> for some fixed <code>d &gt; 0</code>, and take <code>s = {x} + (scaling by a factor of C in the direction of ker f') '' ball 0 Œµ</code> to show that the liminf is zero.</p>",
        "id": 565314476,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1766606674
    },
    {
        "content": "<p>Of course, we can rewrite this proof with the current definition, but IMHO these are 2 nice tricks (generalizing Vitali families and generalizing measure differentiation to outer measures).</p>",
        "id": 565314562,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1766606769
    },
    {
        "content": "<p>Also, I think that we can prove something like <code>œÅ s ‚â§ ‚à´‚Åª x in s, (liminf of the ratio) ‚àÇŒº</code></p>",
        "id": 565316643,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1766608857
    },
    {
        "content": "<p>... for an outer measure <code>œÅ</code>. Then we just show that <code>liminf</code> is zero.</p>",
        "id": 565316692,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1766608905
    },
    {
        "content": "<p>I've started generalizing stuff to outer measures in <a href=\"https://github.com/leanprover-community/mathlib4/pull/33269\">#33269</a>. It doesn't build right now, because we don't auto coerce measures to outer measures (also, because I've changed the definition to use <code>liminf</code>).</p>",
        "id": 565341835,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1766640791
    },
    {
        "content": "<p>I'm not sure I understand the advantages of the new definition compared to the current one, i.e., is the definition really more general (does it give access to new Vitali families) or is it just for ease of use? I think there several criteria for a definition:</p>\n<p>a) Elegance<br>\nb) Generality<br>\nc) Ease of use of the definition to prove theorems<br>\nd) Ease of construction of instances of the definition<br>\ne) How close is it to the informal litterature</p>\n<p>I have the impression that your definition is more elegant, and easier to use to prove theorems, so better wrt a) and c). However, I also have the impression that it will be slightly more complicated to construct Vitali families using this definition, i.e., d) is a little bit worse. Also, it is further away from the informal litterature (the bible there is Federer, and I had tried to follow it rather closely when defining Vitali families). </p>\n<p>Given this, I'd say the tie-breaker would be b): if the new definition gives access to new interesting examples, then we should probably go for it. Otherwise, I would probably keep the current definition, but add some API to make your applications easier: in the end, if the definitions are equivalent, then the precise definition we use shouldn't be important because everything can be hidden behind suitable API, so keeping the current definition seems to be less work.</p>",
        "id": 565354683,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1766654112
    },
    {
        "content": "<p>The only example I have in mind where the two definitions differ is the one above (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Vitali.vitaliFamily#doc\">docs#Vitali.vitaliFamily</a> without fixed constant <code>C</code>). With the current definition, one can manually apply a theorem (e.g., something like <code>ŒΩ s ‚â§ ‚à´‚Åª x in s, v.limRatio Œº ŒΩ ‚àÇŒº</code> for an outer measure <code>ŒΩ</code>, where <code>limRatio</code> is redefined to be <code>liminf</code>) to each Vitali family with a specific <code>C</code>, then take the limit as <code>C ‚Üí ‚àû</code>, but this may require an extra swapping of an integral and a limit.</p>",
        "id": 565378916,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1766677597
    },
    {
        "content": "<p>Can you elaborate on what you mean by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Vitali.vitaliFamily#doc\">docs#Vitali.vitaliFamily</a> without a fixed constant <code>C</code>? It is not obvious to me that the new definition would satisfy the covering property (<code>exists_covering</code> in your notation). If that's indeed the case that it works for the covering lemma without a fixed <code>C</code>, it would definitely be worth changing the definition to be able to cover it (or would the old definition also work without a fixed <code>C</code>? What is the difference that would make it work for the new definition but not the old one?)</p>",
        "id": 565389490,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1766694716
    },
    {
        "content": "<p>Take <code>filterAt x := ‚®Ü C, (old filterAt)</code></p>",
        "id": 565389693,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1766695068
    },
    {
        "content": "<p>Then a family is a fine subfamily on iff for each point, there exists <code>C</code> (that depends on this point) such that (old property for being fine at <code>x</code> with this <code>C</code>).</p>",
        "id": 565389725,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1766695141
    },
    {
        "content": "<p>I'll try to formally prove <code>exists_covering</code> for this filter tonight (it's less straightforward than I thought).</p>",
        "id": 565389810,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1766695281
    },
    {
        "content": "<p>AFAICT, it doesn't work. I probably can prove that there exists a cover of total measure (<code>tsum</code>) <code>‚â§ Œº s + Œµ</code>, but not a disjoint cover required by the definition. I'm sorry for wasting your time.</p>",
        "id": 565397331,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1766708578
    }
]