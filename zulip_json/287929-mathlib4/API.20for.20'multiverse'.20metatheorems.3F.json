[
    {
        "content": "<p><a href=\"#narrow/channel/287929-mathlib4/topic/Non-standard.20analysis/near/572439735\">This is related to the conversation in the thread about non-standard analysis</a>, but I was actually also thinking about something related independently.</p>\n<p>There a number of places in mathematical logic where one builds multiple models of ZFC and then uses the fact that standard theorems relativize to these various models, with the three most common constructions being forcing extension, inner models, and ultrapowers. This is typically used for independence results, but it also has a couple of applications for proving positive theorems:</p>\n<ul>\n<li>Non-standard analysis can be formalized in terms of 'taking an ultrapower of the whole universe' (which doesn't seem too hard to define in terms of the existing ultrapower machinery in Mathlib).</li>\n<li>Shoenfield absoluteness allows you to transfer certain low-complexity statements from forcing extensions and inner models to the ground model. For example, you can use this to turn a proof of a statement about the natural numbers in ZFC + CH into a ZFC theorem (and even a ZF theorem). Historically this has actually been used a couple of times in the context of model theory (although one can typically find a proof that avoids this technique).</li>\n</ul>\n<p>In the context of independence results, this is also important whenever you want to prove the independence of something that needs a lot of machinery from outside set theory. For instance, in order to prove the independence of the Whitehead problem, one step you need to take is proving that every Whitehead group is free in L. While L is relatively easy to define in the ZFSet library, there is no mechanism I know of to then immediately start talking about the category of abelian groups inside L.</p>\n<p>I know this is a pretty open-ended question because these constructions might end up looking pretty different from each other in Lean, but has anyone thought about the feasibility of doing something like this? For instance, if I have a small model of a fragment of Lean or ZFC, I want to be able to just talk about their internal categories of abelian groups or their internal version of measure theory and in particular apply existing theorems in Mathlib there.</p>",
        "id": 572632298,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770567750
    },
    {
        "content": "<p>I already mentioned this in a topic of dream projects: It should be possible to build \"logical quotation\". As an inspiration, I take the Qq library, here we can write things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">â‰ </span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">â‰ </span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">â‰ </span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">e</span>\n</code></pre></div>\n<p>So we construct <code>e</code> by naturally writing it but it is stored as an (meta) expression, not a Lean object. So we can decompose it, and observe that it starts with a quantifier, etc. However, since Qq is used for metaprogramming, and not for logic, it doesn't store definitions with it (only the definition names occuring in the expression).</p>\n<p>So I envision a logical quotation that would capture also all the definitions this depends on, With that, we could then make logical claims about such expressions such as unprovability.</p>\n<p>I don't think it is necessary for non-standard analysis -- first I thought it was but later I realized that a lot of non-standard analysis (in general ultra-product stuff) could be done natively in Lean. But I see logical quotation as the only sensible way how to talk about undecidability.</p>\n<p>And by the way, regarding universes, I hope we agree we can just mostly live in Lean's <code>Type</code> (or up to the Mathlib's 5 universes), if we really want large cardinals, we could assume them (as assumptions, or axioms) inside Type 0.</p>",
        "id": 572633397,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1770568764
    },
    {
        "content": "<p>I was also thinking about the <code>q( )</code> macro.</p>",
        "id": 572633849,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770569149
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek OlÅ¡Ã¡k</span> <a href=\"#narrow/channel/287929-mathlib4/topic/API.20for.20'multiverse'.20metatheorems.3F/near/572633397\">said</a>:</p>\n<blockquote>\n<p>And by the way, regarding universes, I hope we agree we can just mostly live in Lean's <code>Type</code> (or up to the Mathlib's 5 universes), if we really want large cardinals, we could assume them (as assumptions, or axioms) inside Type 0.</p>\n</blockquote>\n<p>I mean, is there any reason to think that the number of universes used by Mathlib isn't going to grow over time?</p>",
        "id": 572633885,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770569182
    },
    {
        "content": "<p>Many people have thought about such things for a long time. Let me ping <span class=\"user-mention\" data-user-id=\"128280\">@ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’</span> specifically who seems to be doing related things at the moment.</p>",
        "id": 572633967,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1770569247
    },
    {
        "content": "<p>Personally, I think a viable approach to such things is to go via the syntactic category construction, and rely more heavily on categorical logic semantics, although I recognize that not everyone is comfortable with the category theory library.</p>",
        "id": 572634191,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1770569418
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/API.20for.20'multiverse'.20metatheorems.3F/near/572633885\">said</a>:</p>\n<blockquote>\n<p>I mean, is there any reason to think that the number of universes used by Mathlib isn't going to grow over time?</p>\n</blockquote>\n<p>I just meant that there is no reason to stretch Lean's universe system to its limits (when it cannot get to very large cardinals anyway). No problem if a few more universes will get added over time for convenience / ignorance.</p>",
        "id": 572634194,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1770569418
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/API.20for.20'multiverse'.20metatheorems.3F/near/572634191\">said</a>:</p>\n<blockquote>\n<p>Personally, I think a viable approach to such things is to go via the syntactic category construction, and rely more heavily on categorical logic semantics, although I recognize that not everyone is comfortable with the category theory library.</p>\n</blockquote>\n<p>How would you envision this working with something like L?</p>",
        "id": 572634339,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770569548
    },
    {
        "content": "<p>Oh sorry, I misunderstood. You're talking about applying this at the level of syntax, not semantics.</p>",
        "id": 572634434,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770569619
    },
    {
        "content": "<p>yes exactly.</p>",
        "id": 572634473,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1770569652
    },
    {
        "content": "<p>If you want abelian groups in L, you would define the category of abelian groups internally in the syntactic category of L.</p>",
        "id": 572634523,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1770569676
    },
    {
        "content": "<p>(If needed, you can then pass to models by applying functors, etc.)</p>",
        "id": 572634556,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1770569692
    },
    {
        "content": "<p>A lot of classical mathematical logicians would have a bit of difficulty defining the word functor. I'm concerned that if you built the framework for doing independence results using a lot of category theory, you'd have difficulty finding, say, set theorists willing to work with it.</p>",
        "id": 572635316,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770570247
    },
    {
        "content": "<p>yeah, I understand. I think this is where good automation like analogues of <code>q(...)</code> could help.</p>",
        "id": 572635369,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1770570287
    },
    {
        "content": "<p>One difference here is that the <code>q()</code> elaborator is only used in tactics, so is typically not considered part of the trusted codebase. If you're using something to form theorem statements, you're now trusting the complex elaborator to really build the right expression in your meta theory.</p>",
        "id": 572636146,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1770570890
    },
    {
        "content": "<p>This is of course always true whenever an elaborator is used to create a definition.</p>",
        "id": 572638699,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1770573114
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/API.20for.20'multiverse'.20metatheorems.3F/near/572633967\">said</a>:</p>\n<blockquote>\n<p>Many people have thought about such things for a long time. Let me ping <span class=\"user-mention silent\" data-user-id=\"128280\">ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’</span> specifically who seems to be doing related things at the moment.</p>\n</blockquote>\n<p>The <code>q(..)</code>-like construct we have there is an elaborator <code>tm%{e}</code> (currently on <a href=\"https://github.com/sinhp/HoTTLean/pull/168\">this branch</a>) that, given a Lean term <code>e</code> that is well-typed w.r.t. a subset of Lean's type theory (e.g. without <code>Prop</code>), produces a Lean proof of this well-typedness fact (according to rules for MLTT that we have formalized). In principle this can be used to reason internally to any model of type theory (we also have formalized certain classes of models).</p>\n<p>I don't know much about the constructible hierarchy, so I can't say whether it's relevant. Additionally, for talking about 'abelian groups in C' one may prefer to use something that doesn't require a full model of type theory (?), e.g. Lawvere theories.</p>",
        "id": 572674465,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1770608443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek OlÅ¡Ã¡k</span> <a href=\"#narrow/channel/287929-mathlib4/topic/API.20for.20'multiverse'.20metatheorems.3F/near/572633397\">said</a>:</p>\n<blockquote>\n<p>So I envision a logical quotation that would capture also all the definitions this depends on, With that, we could then make logical claims about such expressions such as unprovability.</p>\n</blockquote>\n<p>I am confused about a detail: why do you want to record all definitions used there, rather than just the axioms? In the elaborator I mentioned above, we record typing derivations w.r.t. a 'theory signature', namely a list of the axioms used, since those are ultimately what needs to be justified manually in any model construction.</p>",
        "id": 572674714,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1770608636
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’</span> <a href=\"#narrow/channel/287929-mathlib4/topic/API.20for.20'multiverse'.20metatheorems.3F/near/572674714\">said</a>:</p>\n<blockquote>\n<p>I am confused about a detail: why do you want to record all definitions used there, rather than just the axioms? In the elaborator I mentioned above, we record typing derivations w.r.t. a 'theory signature', namely a list of the axioms used, since those are ultimately what needs to be justified manually in any model construction.</p>\n</blockquote>\n<p>Because only together with the definitions, the term has a full meaning. The specific envisioned use-case I was showing was stating</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">continuum_hypothesis_undecidable</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Undecidable</span><span class=\"w\"> </span><span class=\"n\">lq</span><span class=\"o\">(</span><span class=\"n\">Cardinal</span><span class=\"bp\">.</span><span class=\"n\">aleph</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Cardinal</span><span class=\"bp\">.</span><span class=\"n\">beth</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>To capture the meaning of this statement, we need to know the definitions of <code>Cardinal.aleph</code> and <code>Cardinal.beth</code>. If they are represented only as strings (<code>Lean.Name</code>s to be more precise), this has no meaning.</p>",
        "id": 572805119,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1770649343
    },
    {
        "content": "<p>I imagined this being done so that any such definition would get automatically constructed <code>meta</code>-variant (for example when requested by the logical quotation). So it would create <code>Cardinal.aleph.meta</code>, <code>RelEmbedding.trans.meta</code>, etc which contains the analog of <code>Expr</code> (but including definitions). Of course, for meta-reasoning projects, it would be useful to precompute certain basic constants.</p>",
        "id": 572812646,
        "sender_full_name": "Mirek OlÅ¡Ã¡k",
        "timestamp": 1770651009
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek OlÅ¡Ã¡k</span> <a href=\"#narrow/channel/287929-mathlib4/topic/API.20for.20'multiverse'.20metatheorems.3F/near/572812646\">said</a>:</p>\n<blockquote>\n<p>I imagined this being done so that any such definition would get automatically constructed <code>meta</code>-variant (for example when requested by the logical quotation). So it would create <code>Cardinal.aleph.meta</code>, <code>RelEmbedding.trans.meta</code>, etc which contains the analog of <code>Expr</code> (but including definitions). Of course, for meta-reasoning projects, it would be useful to precompute certain basic constants.</p>\n</blockquote>\n<p>Right, I see! In HoTTLean this is achieved by a <code>@[reflect]</code> attribute that produces <code>someDefinition.reflection</code>, a structure containing the <code>Expr</code> and the typehood proof. Then when you refer to <code>someDefinition</code> inside <code>lq(..)</code>, under the hood <code>someDefinition.reflection</code> is made use of.</p>",
        "id": 572852909,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1770660416
    }
]