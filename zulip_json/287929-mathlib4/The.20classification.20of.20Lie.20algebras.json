[
    {
        "content": "<p>I'd like to invite people to consider helping add the classification of semisimple Lie algberas to Mathlib. I think this is a very useful result with many applications and adding it to Mathlib would open up future formalisation prospects as well as exercise parts of our algebra library in a non-trivial way.</p>",
        "id": 418498429,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1706444892
    },
    {
        "content": "<p>A few years ago I put some of the basics of Lie algebra theory in place and in recent months I took up the theory again. I'd guess that maybe six months of single-person effort remains to finish the result.</p>",
        "id": 418498469,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1706444961
    },
    {
        "content": "<p>To give a sense of where we are, I have created a project here: <a href=\"https://github.com/orgs/leanprover-community/projects/17/views/1?pane=info\">https://github.com/orgs/leanprover-community/projects/17/views/1?pane=info</a></p>\n<p>Most of the items in this project are fairly non-trivial but some are probably only a few days of work (modulo time to familiarise with this corner of the library). For example: <a href=\"https://github.com/leanprover-community/mathlib4/issues/10073\">https://github.com/leanprover-community/mathlib4/issues/10073</a> <em>should</em> be easy enough.</p>\n<p>Anyone should feel free to break down these tasks or add new items.</p>",
        "id": 418498693,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1706445170
    },
    {
        "content": "<p>In my procrastination time, I've shown that regular elements exist in free Lie algebras of rank <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> over domains with at least <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> elements. From there it is a little computation to get the existence of Cartan subalgebras in those same Lie algebras. Should probably be done a few days from now. (Depending on the amount of procrastination time that I get.)</p>",
        "id": 419928243,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707167229
    },
    {
        "content": "<p>I managed to get <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.End.exists_isNilpotent_isSemisimple#doc\">docs#Module.End.exists_isNilpotent_isSemisimple</a> into master today which I expect to need for <a href=\"https://github.com/leanprover-community/mathlib4/pull/10064\">#10064</a></p>",
        "id": 420301526,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1707325790
    },
    {
        "content": "<p>Sooner or later I will probably also need this result:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Semisimple</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.FieldTheory.Perfect</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Module.End</span> <span class=\"n\">K</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Module.End.isSemisimple_add_of_commute</span> <span class=\"o\">[</span><span class=\"n\">PerfectField</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"n\">K</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">comm</span> <span class=\"o\">:</span> <span class=\"n\">Commute</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f.IsSemisimple</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">g.IsSemisimple</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">IsSemisimple</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- Your proof here!</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>so if somebody wants to take that on, I'd be very grateful :-)</p>",
        "id": 420301834,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1707325890
    },
    {
        "content": "<p>What's the maths proof?</p>",
        "id": 420328343,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707334525
    },
    {
        "content": "<p>I haven't decided!</p>",
        "id": 420329945,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1707335112
    },
    {
        "content": "<p>The obvious route is to prove that for semisimple endomorphisms <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.End.generalizedEigenspace#doc\">docs#Module.End.generalizedEigenspace</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.End.eigenspace#doc\">docs#Module.End.eigenspace</a> coincide, pass to the algebraic closure, invoke <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.End.iSup_generalizedEigenspace_eq_top#doc\">docs#Module.End.iSup_generalizedEigenspace_eq_top</a> to see that semisimple means diagonalisable in this case, observe that this is an iff, and then argue that commuting diagonalisable endomorphisms are simultaneously diagonalisable.</p>",
        "id": 420330165,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1707335197
    },
    {
        "content": "<p>I think to get back from the algebraic closure to the original coefficients, you'll need to use that the field is perfect and possibly prove the converse of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isSemisimple_of_squarefree_aeval_eq_zero#doc\">docs#isSemisimple_of_squarefree_aeval_eq_zero</a></p>",
        "id": 420330472,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1707335342
    },
    {
        "content": "<p>There might also be a slick proof!</p>",
        "id": 420330672,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1707335419
    },
    {
        "content": "<p>Also, even just filling in any of the gaps in our eigenspace theory indicated above would be very helpful!</p>",
        "id": 420330685,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1707335426
    },
    {
        "content": "<p>I'm going to try experimenting in this thread by dropping in formal statements of non-trivial gaps in the library which it would be useful to get filled. Here's one that would really help:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.JordanChevalley</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Lie.Killing</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">LieAlgebra</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LieRing</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LieAlgebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">CharZero</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsSemisimple</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"c1\">-- Or maybe just `[PerfectField K] [IsKilling K L]` suffices?</span>\n\n<span class=\"c1\">-- Bourbaki Chap. I, §6.3, Proposition 3 (page 52)</span>\n<span class=\"c1\">-- See also Fulton &amp; Harris, Proposition C.17 (page 482)</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_isNilpotent_isSemisimple</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">,</span>\n      <span class=\"n\">_root_.IsNilpotent</span> <span class=\"o\">(</span><span class=\"n\">ad</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n      <span class=\"n\">Module.End.IsSemisimple</span> <span class=\"o\">(</span><span class=\"n\">ad</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n      <span class=\"bp\">⁅</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"bp\">⁆</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span>\n      <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"bp\">⁅</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁆</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">⁅</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"bp\">⁆</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n      <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"bp\">⁅</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁆</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">⁅</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"bp\">⁆</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n      <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">LieAlgebra</span>\n</code></pre></div>",
        "id": 420483898,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1707406599
    },
    {
        "content": "<p>I have formalized a proof of the existence of Cartan subalgebras. More precisely: let <code>L</code> be a finite-dimensional Lie algebra over a field <code>K</code>. If <code>K</code> has more elements than the dimension of <code>L</code>, then <code>L</code> has a Cartan subalgebra.<br>\n(In general it is an open problem in Lie theory whether large Lie algebras over small fields have Cartan subalgebras.)</p>\n<p>The proof needs</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">finrank_maximalGeneralizedEigenspace</span> <span class=\"o\">:</span>\n    <span class=\"n\">finrank</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">φ.maximalGeneralizedEigenspace</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">natTrailingDegree</span> <span class=\"o\">(</span><span class=\"n\">φ.charpoly</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>\n<p>and I bashed through a proof with the available tools. But it seems that there are gaps in our Eigenspace library that could easily house the NSA parking lot. However, I didn't have the time and energy to fill those gaps as prerequisite for this result in Lie theory, so I took the shortest path to my end goal.</p>",
        "id": 421185518,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707807252
    },
    {
        "content": "<p>What are the assumptions on <code>K</code>?</p>",
        "id": 421188098,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707808997
    },
    {
        "content": "<p>In the lemma that I quote, <code>K</code> is a field, and <code>\\phi</code> is an endomorphism of a findim VS over K.</p>",
        "id": 421188237,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707809103
    },
    {
        "content": "<p>Ok, I still think that your \"weaker\" version is likely true, but I have not thought of a fully-formed proof yet.</p>",
        "id": 421188807,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707809499
    },
    {
        "content": "<p>Btw, any reason for the parentheses around <code>φ.charpoly</code>?</p>",
        "id": 421188909,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707809542
    },
    {
        "content": "<p>(also, sorry for not reading the text before the statement of the lemma, where you had already explained that <code>K</code> was a field)</p>",
        "id": 421188989,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707809596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/The.20classification.20of.20Lie.20algebras/near/421188909\">said</a>:</p>\n<blockquote>\n<p>Btw, any reason for the parentheses around <code>φ.charpoly</code>?</p>\n</blockquote>\n<p>No! Just copypasta</p>",
        "id": 421190625,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707810524
    },
    {
        "content": "<p>I feel we should take the time to formalize all of basic linear algebra before embarking in this (more exciting) world…</p>",
        "id": 421222205,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1707822711
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> can you formalise the statements of what is missing, or even approximations to the statements?</p>",
        "id": 421239965,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707829552
    },
    {
        "content": "<p>Well... for starters there is the lemma that I mentioned above.</p>",
        "id": 421240534,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707829757
    },
    {
        "content": "<p>There is basically very little connection between the characteristic polynomial and eigenvectors/spaces.</p>",
        "id": 421240579,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707829778
    },
    {
        "content": "<p>But it's a bit hard to describe the gap precisely. It's just that there's a lot of API missing.</p>",
        "id": 421240722,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707829822
    },
    {
        "content": "<p>For things like this, it would be good if we had <code>json</code> files that told us which statements from standard reference texts are done, and which ones are missing.</p>",
        "id": 421240830,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707829876
    },
    {
        "content": "<p>Indeed, it would be interesting, and probably instructive,  to have Rudin/Lang/Matsumura/Bourbaki projects that formalize every statement of the book within mathlib's language. (No real proof should be added, only invocations of mathlib's proofs. And if proofs are needed, their adequate version should be added to mathlib.)</p>",
        "id": 421241481,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1707830125
    },
    {
        "content": "<p>Anyway, while I agree that we should definitely work on this, I think there is also some momentum for the Lie theory project at the moment. And I don't think that should necessarily be postponed until LA is done.</p>",
        "id": 421242152,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707830398
    },
    {
        "content": "<p>I've said this to people offline but just to say it publically -- Tom Hales was very excited a few years ago that Oliver had even <em>stated</em> the classification, because he already felt that this was important. The proof will be a real milestone.</p>",
        "id": 421245422,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707831559
    },
    {
        "content": "<p>The relevant mathematics I know only deals with the complex lie algebra case, and I don't know what generalizes and what doesn't. I am interested in (eventually - I'm still learning the basics of Lean) working on the root system theory part, <a href=\"https://github.com/leanprover-community/mathlib4/issues/10067\">https://github.com/leanprover-community/mathlib4/issues/10067</a>. Is it still true that over any field of char=0 that the root systems are classified by Dynkin Diagrams?</p>",
        "id": 430921369,
        "sender_full_name": "Xela",
        "timestamp": 1712121703
    },
    {
        "content": "<p>Yes I believe this is true because a root system induces a Q-structure and because they behave well with respect to base change.</p>",
        "id": 431186225,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1712182487
    },
    {
        "content": "<p>I'm not expert though and we have some here. Perhaps <span class=\"user-mention\" data-user-id=\"630477\">@Scott Carnahan</span> could comment?</p>",
        "id": 431186526,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1712182609
    },
    {
        "content": "<p>Over any field of characteristic zero, the finite crystallographic root systems are classified by finite type Dynkin diagrams.</p>",
        "id": 431398248,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1712263216
    },
    {
        "content": "<p>You've convinced me <span class=\"user-mention\" data-user-id=\"630477\">@Scott Carnahan</span> : would you be interested in convincing Lean?</p>",
        "id": 431409499,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1712267967
    },
    {
        "content": "<p>Absolutely.  Sorry I haven't made much progress on Lie algebras recently - I've been distracted by Hahn series.</p>",
        "id": 431433846,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1712284024
    },
    {
        "content": "<p>No need to apologize! We're all crazy busy. And having a smooth Hahn series PR is also great!</p>",
        "id": 431438542,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1712287514
    },
    {
        "content": "<blockquote>\n<p>feat(Algebra/Lie): existence of Cartan subalgebras <a href=\"https://github.com/leanprover-community/mathlib4/pull/12297\">#12297</a></p>\n</blockquote>\n<p>This PR contains a thoroughly documented 200-line monster proof that leads to a 10-line corollary proving the existence of Cartan subalgebras.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">exists_IsCartanSubalgebra_of_finrank_le_card</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">finrank</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"bp\">≤</span> <span class=\"bp\">#</span><span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">LieSubalgebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">IsCartanSubalgebra</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 435512892,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1714105796
    },
    {
        "content": "<p>I would be very happy to have some reviews of the monster proof. I don't think there are many reusable components. And extracting local definitions <code>let</code> into stand-alone definitions means that they will depend on parameters which makes their use in the monster proof awkard.<br>\nThings like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">χ</span> <span class=\"o\">:</span> <span class=\"n\">Polynomial</span> <span class=\"o\">(</span><span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">:=</span> <span class=\"n\">lieCharpoly</span> <span class=\"n\">K</span> <span class=\"n\">E</span> <span class=\"n\">x</span> <span class=\"n\">u</span>\n  <span class=\"k\">let</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">Polynomial</span> <span class=\"o\">(</span><span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">:=</span> <span class=\"n\">lieCharpoly</span> <span class=\"n\">K</span> <span class=\"n\">Q</span> <span class=\"n\">x</span> <span class=\"n\">u</span>\n</code></pre></div>\n<p>would no longer be <code>χ</code> and <code>ψ</code> whenever used, but would be <code>χ K E x y</code> and <code>ψ K E x y</code> all over the place. Which I think is not an improvement.</p>",
        "id": 435513251,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1714106062
    },
    {
        "content": "<p>Having a look.</p>",
        "id": 435517999,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1714109804
    },
    {
        "content": "<p>If you really want to split you can extract the case <code>r = finrank K L</code> and maybe one or two <code>suffices</code>, like <code>suffices χ = X ^ r</code>, but it is a bit strange.  The  proof is very fast on my computer, so I don't think it is a real problem to keep it.</p>",
        "id": 435519401,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1714110928
    },
    {
        "content": "<p>Thanks for the review!</p>",
        "id": 435521514,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1714112372
    },
    {
        "content": "<p>\"Dimension of L is at most cardinality of K??\" That's my review</p>",
        "id": 435555198,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714125808
    },
    {
        "content": "<blockquote>\n<p>The condition that F has at least dim L elements cannot be omitted from<br>\ntheorem 1, as is shown by the following example. [...]</p>\n</blockquote>\n<p>Donald W. Barnes - On Cartan subalgebras of Lie algebras (1967)</p>\n<p>I'm probably misunderstanding everything, but maybe the first theorem is \"just a stepping stone\" for the second.</p>",
        "id": 435558167,
        "sender_full_name": "Richard Copley",
        "timestamp": 1714126977
    },
    {
        "content": "<p>It's very cool that we're proving everything in the right generality here. I know that this has been one of Oliver's design decisions in setting up the theory all the way through, even when it's made some proofs far more work.</p>",
        "id": 435558626,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714127158
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/The.20classification.20of.20Lie.20algebras/near/435555198\">said</a>:</p>\n<blockquote>\n<p>\"Dimension of L is at most cardinality of K??\" That's my review</p>\n</blockquote>\n<p>Sorry, I'm being obtuse... am I missing a typo?</p>",
        "id": 435565580,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1714130072
    },
    {
        "content": "<p>The condition is rather surprising, I almost commented \"there must be a typo\" before checking that this is the actual statement.</p>",
        "id": 435568194,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1714131244
    },
    {
        "content": "<p>Probably it's less surprising if you've just proved the theorem :-)</p>",
        "id": 435586742,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714138133
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/The.20classification.20of.20Lie.20algebras/near/435513251\">said</a>:</p>\n<blockquote>\n<p>I would be very happy to have some reviews of the monster proof. I don't think there are many reusable components. And extracting local definitions <code>let</code> into stand-alone definitions means that they will depend on parameters which makes their use in the monster proof awkard.<br>\nThings like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">χ</span> <span class=\"o\">:</span> <span class=\"n\">Polynomial</span> <span class=\"o\">(</span><span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">:=</span> <span class=\"n\">lieCharpoly</span> <span class=\"n\">K</span> <span class=\"n\">E</span> <span class=\"n\">x</span> <span class=\"n\">u</span>\n  <span class=\"k\">let</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">Polynomial</span> <span class=\"o\">(</span><span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">:=</span> <span class=\"n\">lieCharpoly</span> <span class=\"n\">K</span> <span class=\"n\">Q</span> <span class=\"n\">x</span> <span class=\"n\">u</span>\n</code></pre></div>\n<p>would no longer be <code>χ</code> and <code>ψ</code> whenever used, but would be <code>χ K E x y</code> and <code>ψ K E x y</code> all over the place. Which I think is not an improvement.</p>\n</blockquote>\n<p>I want to strongly refute this message, although I have no strong opinion about what we should do with this proof. It is definitely possible to split this monster proof into lemmas with almost no impact on the existing proof, and certainly none of what Johan described above. This is something we learned from large scale project (specifically sphere eversion here). I created a branch with <a href=\"https://github.com/leanprover-community/mathlib4/commit/f0faf4e74da9efc027be869a8f130cb98c52e572\">this commit</a>. The only change is the proof scripts are adding the line <code>setup_notation</code> at the beginning of most lemmas and three extra <code>change</code> lines because <code>omega</code> was confused. Otherwise each proof is copy-pasted from the original proof. The lemma <em>statements</em> have a couple of extra <code>P.</code>. </p>\n<p>The main trick is to introduce a ad-hoc structure holding the assumptions of the monster proof, and then some <code>abbrev</code> replace the definitions. Again I don’t strongly claim that we should merge this commit into Johan’s branch and finish the factoring out job (at some point I got too hungry to continue). I do claim that such a split is possible. One could argue that Sebastian’s work on incremental compilation will soon make that knowledge obsolete, but right now this is nice to know IMHO.</p>",
        "id": 435624951,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714150406
    },
    {
        "content": "<p>There is a little lie in my message: the new proofs also delete a couple of explicit unfoldings that are no longer necessary.</p>",
        "id": 435625368,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714150527
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span></p>",
        "id": 435625445,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714150555
    },
    {
        "content": "<p>Aah, very nice!</p>",
        "id": 435625569,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1714150595
    },
    {
        "content": "<p>That <code>setup_notation</code> macro is great. Do we have similar examples in mathlib already?</p>",
        "id": 435625678,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1714150633
    },
    {
        "content": "<p>The line length linter doesn’t think this macro is great. But this is only because I can never remember how to write a macro that produces a quoted <code>tacticSeq</code>.</p>",
        "id": 435626151,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714150802
    },
    {
        "content": "<p>I don’t think we use this kind of splitting methodology in Mathlib. We certainly use it a lot in sphere eversion.</p>",
        "id": 435626282,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714150832
    },
    {
        "content": "<p>And now I really need to find food.</p>",
        "id": 435626357,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714150870
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span>  I wish I could find a baguette, but I’m in the USA this year… This is great, but there are some tradeoffs.</p>",
        "id": 435632419,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714153470
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/The.20classification.20of.20Lie.20algebras/near/435625678\">said</a>:</p>\n<blockquote>\n<p>That <code>setup_notation</code> macro is great. Do we have similar examples in mathlib already?</p>\n</blockquote>\n<p>I think that some generalization of this should indeed be added to mathlib. I'm envisioning some new commands that create the structure along with the <code>setup_notation</code> macro automatically.</p>",
        "id": 435633298,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1714153827
    },
    {
        "content": "<p>Note that my example does more than creating lets for the fields, it also does it for some later definitions.</p>",
        "id": 435634005,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714154078
    },
    {
        "content": "<p>It's a bit hard to read the diff on github with the link to the commit above due to all of the CI errors being placed inline in the diff. Does anyone know how to temporarily turn off those error messages?</p>",
        "id": 435634410,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1714154242
    },
    {
        "content": "<p>Oh indeed. It wasn’t like that in the beginning, the linter kicked off later.</p>",
        "id": 435635278,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714154524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/The.20classification.20of.20Lie.20algebras/near/435586742\">said</a>:</p>\n<blockquote>\n<p>Probably it's less surprising if you've just proved the theorem :-)</p>\n</blockquote>\n<p>There is a classic proof of the Nullstellensatz for uncountable fields that builds on the same idea: a finitely (countably would work) generated (associative and commutative) K-algebra is algebraic.</p>",
        "id": 435655923,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1714163816
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span> Btw, see the message about custom notation for long proofs that Patrick wrote above. It is relevant to our breakfast discussion at CIRM last month.</p>",
        "id": 435965563,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1714372457
    },
    {
        "content": "<p>In the ongoing proof of Sion/von Neumann minimax theorem (with <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> ) we have similar constructions, we took them out of the proof using ‘private‘ definitions and lemmas, but a more systematic way would be simpler!</p>",
        "id": 436622168,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1714629850
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/The.20classification.20of.20Lie.20algebras/near/435634410\">said</a>:</p>\n<blockquote>\n<p>It's a bit hard to read the diff on github with the link to the commit above due to all of the CI errors being placed inline in the diff. Does anyone know how to temporarily turn off those error messages?</p>\n</blockquote>\n<p>For any PR or commit, just add \".diff\" to the URL, like:<br>\n<a href=\"https://patch-diff.githubusercontent.com/raw/leanprover-community/mathlib4/pull/12297.diff\">https://patch-diff.githubusercontent.com/raw/leanprover-community/mathlib4/pull/12297.diff</a><br>\n<a href=\"https://github.com/leanprover-community/mathlib4/commit/f0faf4e74da9efc027be869a8f130cb98c52e572.diff\">https://github.com/leanprover-community/mathlib4/commit/f0faf4e74da9efc027be869a8f130cb98c52e572.diff</a></p>",
        "id": 436649892,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1714641240
    },
    {
        "content": "<p>Unexpected career changes have meant that I've spent very little time working on Mathlib's Lie theory in recent months. Nevertheless <em>some</em> progress has been made, e.g., we now know root spaces are 1-dimensional <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LieAlgebra.IsKilling.finrank_rootSpace_eq_one#doc\">docs#LieAlgebra.IsKilling.finrank_rootSpace_eq_one</a>.</p>",
        "id": 440651662,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1716657875
    },
    {
        "content": "<p>We are also tantalisingly close to the really nice result that  the roots of a Lie algebra are a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RootSystem#doc\">docs#RootSystem</a>. To be precise, the following two <code>sorry</code>s capture exactly what remains to be done:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Lie</span><span class=\"bp\">.</span><span class=\"n\">Weights</span><span class=\"bp\">.</span><span class=\"n\">Killing</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">RootSystem</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">LieAlgebra</span><span class=\"bp\">.</span><span class=\"n\">IsKilling</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">LieModule</span><span class=\"w\"> </span><span class=\"n\">Module</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CharZero</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LieRing</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LieAlgebra</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">IsKilling</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LieSubalgebra</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">IsCartanSubalgebra</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsTriangularizable</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">reflectRoot</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Weight</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hα</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">IsNonZero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hβ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"bp\">.</span><span class=\"n\">IsNonZero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Weight</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coroot</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">weightSpace_ne_bot'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> Several proofs of this. Probably best (though not shortest) is</span>\n<span class=\"cm\">      Bourbaki, Ch. VIII §2.2 Lemma 1 (page 80 of English translation, 88 of PDF)</span>\n\n<span class=\"cm\">      Approximate plan:</span>\n<span class=\"cm\">        1. define exponential of nilpotent things (independent of Lie theory)</span>\n<span class=\"cm\">        2. prove exponential of element with nilpotent adjoint endomorphism gives `LieEquiv`</span>\n<span class=\"cm\">           (slightly more is true: exponential of any nilpotent `LieDerivation` gives `LieEquiv`)</span>\n<span class=\"cm\">        3. prove adjoint endomorphism of element of rootspace is nilpotent</span>\n<span class=\"cm\">        4. establish the identities in Bourbaki lemma 1 for `θ := exp e * exp (- f) * exp e`</span>\n<span class=\"cm\">           where `e` and `f` belong to an `sl₂` triple associated to `α` provided by</span>\n<span class=\"cm\">           `exists_isSl2Triple_of_weight_isNonZero`.</span>\n<span class=\"cm\">    -/</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">reflectRoot_ne_zero</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Weight</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hα</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">IsNonZero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hβ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"bp\">.</span><span class=\"n\">IsNonZero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">reflectRoot</span><span class=\"w\"> </span><span class=\"n\">hα</span><span class=\"w\"> </span><span class=\"n\">hβ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">IsNonZero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The root system of a finite-dimensional Lie algebra with non-degenerate Killing form over a</span>\n<span class=\"sd\">field of characteristic zero, relative to a splitting Cartan subalgebra. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">rootSystem</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">RootSystem</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Weight</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">IsNonZero</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Dual</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">RootSystem</span><span class=\"bp\">.</span><span class=\"n\">mk'</span>\n<span class=\"w\">    </span><span class=\"n\">IsReflexive</span><span class=\"bp\">.</span><span class=\"n\">toPerfectPairingDual</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">inj'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">congr_fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\">  </span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">coroot</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">inj'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hα</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">β</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hβ</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">root_apply_coroot</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hα</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">β</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hβ</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Embedding</span><span class=\"bp\">.</span><span class=\"n\">coeFn_mk</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsReflexive</span><span class=\"bp\">.</span><span class=\"n\">toPerfectPairingDual_toLin</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">comp_apply</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_range</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">exists</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_prop</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">reflectRoot</span><span class=\"w\"> </span><span class=\"n\">hα</span><span class=\"w\"> </span><span class=\"n\">hβ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">reflectRoot_ne_zero</span><span class=\"w\"> </span><span class=\"n\">hα</span><span class=\"w\"> </span><span class=\"n\">hβ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">span_weight_isNonZero_eq_top</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">LieAlgebra</span><span class=\"bp\">.</span><span class=\"n\">IsKilling</span>\n</code></pre></div>",
        "id": 440651676,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1716657894
    },
    {
        "content": "<p>All the technology exists to close these sorries (I've even sketched an approach in a code comment) so I'm posting this here in case somebody fancies being the first person to formalise a really nice result.</p>",
        "id": 440651778,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1716657992
    },
    {
        "content": "<p>This is really great!</p>",
        "id": 440653677,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716660111
    },
    {
        "content": "<p>For everybody interested, let me advertise the Github project that is tracking progress towards the classification of semisimple Lie algebras: <a href=\"https://github.com/orgs/leanprover-community/projects/17\">https://github.com/orgs/leanprover-community/projects/17</a></p>",
        "id": 440653778,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716660190
    },
    {
        "content": "<p>I filled the second sorry just for fun</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">reflectRoot_ne_zero</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Weight</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hα</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">IsNonZero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hβ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"bp\">.</span><span class=\"n\">IsNonZero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">reflectRoot</span><span class=\"w\"> </span><span class=\"n\">hα</span><span class=\"w\"> </span><span class=\"n\">hβ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">IsNonZero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coroot</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">add_left_injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coroot</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">root_apply_coroot</span><span class=\"w\"> </span><span class=\"n\">hα</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_two</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">congr_fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sub_eq_zero</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coroot</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">reflectRoot</span><span class=\"w\"> </span><span class=\"n\">hα</span><span class=\"w\"> </span><span class=\"n\">hβ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">reflectRoot</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hβ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 440655638,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1716662299
    },
    {
        "content": "<p>Okay I have <code>RootSystem {α : Weight K H L // α.IsNonZero} K (Dual K H) H</code> and <code>(rootSystem H).IsCrystallographic</code> and <code>(rootSystem H).IsReduced</code> sorry free <a href=\"https://gist.github.com/erdOne/495e37bd797dd4e06ff82a623dcfd4a5\">here</a> and I can finally start doing what I should have been working on today.</p>",
        "id": 440721871,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1716738442
    },
    {
        "content": "<p>No way, that's amazing! Not for the first time what I thought was a 100:1 shot at nerd-sniping worked. Thanks so much.</p>",
        "id": 440723895,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1716740419
    },
    {
        "content": "<p>Of course now you must PR it :)</p>",
        "id": 440723904,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1716740432
    },
    {
        "content": "<p>Incidentally your lemma <code>coroot_injective</code> essentially exists as <code>coroot_eq_iff</code> (this was only added to master yesterday so maybe you hadn't picked it up).</p>",
        "id": 440723956,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1716740495
    },
    {
        "content": "<p>Anyway thanks again, this is marvellous and you've even established reduced and crystallographic which I hadn't asked for because I felt it would be too much.</p>",
        "id": 440724063,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1716740600
    },
    {
        "content": "<p>Very cool!</p>",
        "id": 440731778,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716748876
    },
    {
        "content": "<p>First batch of PRs: <a href=\"https://github.com/leanprover-community/mathlib4/pull/13258\">#13258</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/13259\">#13259</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/13260\">#13260</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/13261\">#13261</a></p>",
        "id": 440736837,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1716754045
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/13265\">#13265</a> proves that Lie algebras with non-degenerate Killing form are semisimple.</p>",
        "id": 440771114,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716784508
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> I kicked the middle two on the queue, and reviewed the 4th.</p>",
        "id": 440772183,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716785201
    },
    {
        "content": "<p>New PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/13298\">#13298</a></p>",
        "id": 440973088,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1716878406
    },
    {
        "content": "<p>Final PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/13307\">#13307</a></p>",
        "id": 441034273,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1716900990
    },
    {
        "content": "<p>Kudos to <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> !</p>",
        "id": 441053485,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716906663
    },
    {
        "content": "<p>Get it in in time for the Month in Mathlib!</p>",
        "id": 441053586,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716906707
    },
    {
        "content": "<p>There are two more subprojects of <a href=\"https://github.com/orgs/leanprover-community/projects/17/views/1\">https://github.com/orgs/leanprover-community/projects/17/views/1</a> in progress. And they might land soon!</p>",
        "id": 441054722,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716907039
    },
    {
        "content": "<p>Thanks to Johan and Andrew's recent work we can now do things like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Lie</span><span class=\"bp\">.</span><span class=\"n\">Weights</span><span class=\"bp\">.</span><span class=\"n\">RootSystem</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Lie</span><span class=\"bp\">.</span><span class=\"n\">CartanMatrix</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Lie</span><span class=\"bp\">.</span><span class=\"n\">CartanExists</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">LieAlgebra</span><span class=\"w\"> </span><span class=\"n\">LieSubalgebra</span><span class=\"w\"> </span><span class=\"n\">IsKilling</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsAlgClosed</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CharZero</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- These are admittedly non-trivial. Closing them would go a long way to removing any slight doubts</span>\n<span class=\"c1\">-- about the correctness of our `Matrix.ToLieAlgebra` definition.</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e₈</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsKilling</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e₈</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsCartanSubalgebra</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">engel</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">    </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">exists_isCartanSubalgebra_engel</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e₈</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">exists_isCartanSubalgebra_engel</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e₈</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Construct `e₈`, take a Cartan subalgebra, take the roots, and prove they are a root system.</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">rootSystem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">engel</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">exists_isCartanSubalgebra_engel</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e₈</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>which I think is quite satisfying.</p>",
        "id": 441082001,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1716916482
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"695266\">@Mitchell Lee</span>'s <a href=\"#narrow/stream/287929-mathlib4/topic/Progress.20on.20Coxeter.20groups/near/440788952\">work on Coxeter groups</a> will allow the construction of a root system over an arbitrary field (if you have it over ℤ the you have it over any commutative ring) associated to a Coxeter matrix, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/GroupTheory/Coxeter/Matrix.html#CoxeterMatrix.E%E2%82%88\">CoxeterMatrix.E₈</a>. We can then aim to show that both root systems are isomorphic. The faitufulness of the geometric representation would show every Weyl group is isomorphic to a Coxeter group.</p>",
        "id": 441088343,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1716919143
    },
    {
        "content": "<p>Yes, I think we're on a roll!</p>",
        "id": 441088858,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716919310
    },
    {
        "content": "<blockquote>\n<p>feat(Algebra/Lie): Killing Lie algebras are semisimple <a href=\"https://github.com/leanprover-community/mathlib4/pull/13265\">#13265</a></p>\n</blockquote>",
        "id": 441095944,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716922080
    },
    {
        "content": "<p>This is now merged. Thanks <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> for the reviews!</p>",
        "id": 441686678,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717156109
    },
    {
        "content": "<p>We do not yet have the notion of a base of a root system (simple roots) and the corresponding Cartan matrix, do we? Or maybe I missed something...</p>",
        "id": 441940414,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717264787
    },
    {
        "content": "<p>We do not have the notion yet.  I got a bit stuck here, because when you split an infinite root system into positive and negative cones, you can have a system of simple roots (\"simple root\" meaning a positive root that is not a nontrivial sum of positive roots) that is not linearly independent.  Perhaps \"base\" should be reserved for the linearly independent case.</p>",
        "id": 441943186,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1717266068
    },
    {
        "content": "<p>Aha! Thanks for illuminating the subtleties of the infinite-dimensional case</p>",
        "id": 441948663,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717268518
    },
    {
        "content": "<p>I will try to spend more time on roots, since the rest of the classification seems to be progressing rapidly.</p>",
        "id": 441951709,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1717269937
    }
]