[
    {
        "content": "<p>Here's an interesting, and initially quite confusing, slowdown, which I think might be one cause of the slowness in <code>Mathlib.RepresentationTheory.GroupCohomology.Basic</code> (and which I don't have a strategy to fix):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.RepresentationTheory.GroupCohomology.Basic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Rep</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Rep.ofMulAction</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(((</span><span class=\"n\">HomologicalComplex.X</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.resolution</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- quick</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">maxHeartbeats</span> <span class=\"mi\">400000</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ModuleCat.mk</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Rep.ofMulAction</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"n\">ModuleCat.mk</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(((</span><span class=\"n\">HomologicalComplex.X</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.resolution</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span> <span class=\"c1\">-- sloooow</span>\n</code></pre></div>\n<p>So we have <code>X = Y</code> with a quick <code>rfl</code> proof, and then <code>T X = T Y</code> and the <code>rfl</code> proof is slow! (8+ seconds on a decent machine). How can that be? Well here's the signature of <code>ModuleCat.mk</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">ModuleCat.mk.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">isAddCommGroup</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"n\">carrier</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">isModule</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">carrier</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ModuleCat</span> <span class=\"n\">R</span>\n</code></pre></div>\n<p>and here's the relevant trace:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.isDefEq</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">8</span><span class=\"bp\">.</span><span class=\"mi\">076313</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">ModuleCat.mk</span>\n      <span class=\"o\">(</span><span class=\"n\">Rep.ofMulAction</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span>\n        <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=?=</span> <span class=\"n\">ModuleCat.mk</span> <span class=\"o\">(</span><span class=\"n\">HomologicalComplex.X</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.resolution</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">133820</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">Rep.ofMulAction</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span> <span class=\"bp\">=?=</span> <span class=\"n\">HomologicalComplex.X</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.resolution</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span> <span class=\"bp\">▶</span>\n  <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"bp\">.</span><span class=\"mi\">588565</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">CategoryTheory.Preadditive.homGroup</span> <span class=\"o\">(</span><span class=\"n\">Rep.ofMulAction</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n        <span class=\"n\">A</span> <span class=\"bp\">=?=</span> <span class=\"n\">CategoryTheory.Preadditive.homGroup</span>\n        <span class=\"o\">(</span><span class=\"n\">HomologicalComplex.X</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.resolution</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">A</span> <span class=\"bp\">▶</span>\n  <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">353870</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">CategoryTheory.Linear.homModule</span> <span class=\"o\">(</span><span class=\"n\">Rep.ofMulAction</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n        <span class=\"n\">A</span> <span class=\"bp\">=?=</span> <span class=\"n\">CategoryTheory.Linear.homModule</span> <span class=\"o\">(</span><span class=\"n\">HomologicalComplex.X</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.resolution</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">A</span> <span class=\"bp\">▶</span>\n</code></pre></div>\n<p>So it's taking only 0.1 second to check that <code>X = Y</code>, but typeclass inference has been used to find abelian group and k-module structures on <code>X</code> and <code>Y</code> and it's taking a long time to verify that these are equal too. You can explicitly verify that the group instance is slow:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.RepresentationTheory.GroupCohomology.Basic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Rep</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Rep.ofMulAction</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(((</span><span class=\"n\">HomologicalComplex.X</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.resolution</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- very quick</span>\n\n<span class=\"c1\">-- also all quick</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">i1</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">Rep.ofMulAction</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">i2</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">(((</span><span class=\"n\">HomologicalComplex.X</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.resolution</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">inferInstance</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">maxHeartbeats</span> <span class=\"mi\">600000</span> <span class=\"k\">in</span> <span class=\"c1\">-- 500000 not good enough</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">i1</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">i2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- sloooow</span>\n</code></pre></div>\n<p>There's a bunch of these in the traces in <code>RepresentationTheory.GroupCohomology.Basic</code>. How might one proceed to speed these up?</p>",
        "id": 378959297,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690410725
    },
    {
        "content": "<p>I don't think that's a good test; you're asking lean to equate the fully quantified instances. This is fast:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">i1</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">n</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">i2</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">n</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 379070512,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690449457
    },
    {
        "content": "<p>But typeclass inference is doing that test tens of times in <code>GroupCohomology.Basic</code>. Or are you telling me it's not? What does the trace above mean?</p>",
        "id": 379137814,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690460867
    },
    {
        "content": "<p>The trace is taken from a proof in that file with elevated maxHeartbeats</p>",
        "id": 379138303,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690460954
    },
    {
        "content": "<p>I find it unlikely that it's equating the unapplied instance</p>",
        "id": 379151618,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690463193
    },
    {
        "content": "<p>wait -- I claim that on current master</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.RepresentationTheory.GroupCohomology.Basic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Rep</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Rep.ofMulAction</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(((</span><span class=\"n\">HomologicalComplex.X</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.resolution</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- very quick</span>\n\n<span class=\"c1\">-- also all quick</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">i1</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">Rep.ofMulAction</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">i2</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">(((</span><span class=\"n\">HomologicalComplex.X</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.resolution</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">inferInstance</span>\n\n<span class=\"c1\">-- set_option maxHeartbeats 300000 in -- this fixes it</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">i1</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">n</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">i2</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">n</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">without the heartbeat bump I get</span>\n<span class=\"cm\">(deterministic) timeout at 'isDefEq', maximum number of heartbeats (200000) has been reached (use 'set_option maxHeartbeats &lt;num&gt;' to set the limit)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>the rfl is failing unless heartbeats are bumped (in particular it's not fast)</p>",
        "id": 379190908,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690469371
    },
    {
        "content": "<p>What do <code>i1</code> and <code>i2</code> look like term-wise?</p>",
        "id": 379198112,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1690470465
    },
    {
        "content": "<p>Possibly related or not. But in <code>AlgebraicGeometry.Morphisms.RingHomProperties</code> there were way to many round trips between the type + instance and the object of the bundled category. These got layered and (I suspect) slowed things down</p>",
        "id": 379199123,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1690470610
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">maxHeartbeats</span> <span class=\"mi\">300000</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">i1</span> <span class=\"n\">n</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">i2</span> <span class=\"n\">n</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">i1</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">i2</span>\n  <span class=\"n\">delta</span> <span class=\"n\">inferInstance</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">⊢ CategoryTheory.Preadditive.homGroup (Rep.ofMulAction k G (Fin (n + 1) → G)) A =</span>\n<span class=\"cm\">  CategoryTheory.Preadditive.homGroup (HomologicalComplex.X (GroupCohomology.resolution k G) n) A</span>\n<span class=\"cm\">-/</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 379201423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690470964
    },
    {
        "content": "<p>What is <code>homGroup</code> finding?</p>",
        "id": 379202773,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1690471198
    },
    {
        "content": "<p>Sorry for the delay. With <code>pp.all</code> on the two terms are</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CategoryTheory.Preadditive.homGroup.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Rep.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">DivInvMonoid.toMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Group.toDivInvMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Action.instCategoryAction.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.moduleCategory.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">MonCat.of.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">DivInvMonoid.toMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Group.toDivInvMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">))))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Action.instPreadditiveActionInstCategoryAction.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.moduleCategory.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">MonCat.of.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">DivInvMonoid.toMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Group.toDivInvMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">)))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.instPreadditiveModuleCatModuleCategory.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Rep.ofMulAction.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">DivInvMonoid.toMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Group.toDivInvMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"n\">Fin</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">HAdd.hAdd.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">instHAdd.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"n\">instAddNat</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n            <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">instOfNatNat</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"bp\">→</span>\n        <span class=\"n\">G</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">mulAction.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n        <span class=\"o\">(</span><span class=\"n\">Fin</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">HAdd.hAdd.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">instHAdd.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"n\">instAddNat</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">instOfNatNat</span> <span class=\"mi\">1</span><span class=\"o\">))))</span>\n        <span class=\"o\">(</span><span class=\"k\">fun</span>\n            <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span>\n              <span class=\"n\">Fin</span>\n                <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">HAdd.hAdd.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">instHAdd.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"n\">instAddNat</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n                  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">instOfNatNat</span> <span class=\"mi\">1</span><span class=\"o\">))))</span> <span class=\"bp\">↦</span>\n          <span class=\"n\">G</span><span class=\"o\">)</span>\n        <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">DivInvMonoid.toMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Group.toDivInvMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">))</span>\n        <span class=\"k\">fun</span>\n          <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span>\n            <span class=\"n\">Fin</span>\n              <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">HAdd.hAdd.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">instHAdd.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"n\">instAddNat</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n                <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">instOfNatNat</span> <span class=\"mi\">1</span><span class=\"o\">))))</span> <span class=\"bp\">↦</span>\n        <span class=\"bp\">@</span><span class=\"n\">Monoid.toMulAction.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">DivInvMonoid.toMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Group.toDivInvMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">))))</span>\n    <span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CategoryTheory.Preadditive.homGroup.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Rep.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">DivInvMonoid.toMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Group.toDivInvMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Action.instCategoryAction.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.moduleCategory.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">MonCat.of.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">DivInvMonoid.toMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Group.toDivInvMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">))))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Action.instPreadditiveActionInstCategoryAction.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.moduleCategory.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">MonCat.of.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">DivInvMonoid.toMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Group.toDivInvMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">)))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.instPreadditiveModuleCatModuleCategory.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">HomologicalComplex.X.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Rep.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">DivInvMonoid.toMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Group.toDivInvMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">)))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Action.instCategoryAction.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.moduleCategory.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">MonCat.of.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">DivInvMonoid.toMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Group.toDivInvMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">))))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CategoryTheory.Preadditive.preadditiveHasZeroMorphisms.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Rep.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">DivInvMonoid.toMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Group.toDivInvMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">)))</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Action.instCategoryAction.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.moduleCategory.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">MonCat.of.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">DivInvMonoid.toMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Group.toDivInvMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">))))</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Action.instPreadditiveActionInstCategoryAction.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.moduleCategory.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">MonCat.of.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">DivInvMonoid.toMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Group.toDivInvMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">)))</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ModuleCat.instPreadditiveModuleCatModuleCategory.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">))))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ComplexShape.down.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">AddRightCancelMonoid.toAddRightCancelSemigroup.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">AddCancelMonoid.toAddRightCancelMonoid.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span>\n            <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">AddCancelCommMonoid.toAddCancelMonoid.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span>\n              <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OrderedCancelAddCommMonoid.toCancelAddCommMonoid.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span>\n                <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">StrictOrderedSemiring.toOrderedCancelAddCommMonoid.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat.strictOrderedSemiring</span><span class=\"o\">)))))</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CanonicallyOrderedCommSemiring.toOne.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat.canonicallyOrderedCommSemiring</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">GroupCohomology.resolution.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">DivInvMonoid.toMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Group.toDivInvMonoid.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">G</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">)))</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n    <span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 379811049,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690639657
    },
    {
        "content": "<p>Not sure if that's the answer to your question.</p>\n<p>Is this a code smell? It's in <code>RepresentationTheory.Rep</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">Rep</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">change</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">((</span><span class=\"n\">forget₂</span> <span class=\"o\">(</span><span class=\"n\">Rep</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ModuleCat</span> <span class=\"n\">k</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">Rep</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">change</span> <span class=\"n\">Module</span> <span class=\"n\">k</span> <span class=\"o\">((</span><span class=\"n\">forget₂</span> <span class=\"o\">(</span><span class=\"n\">Rep</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ModuleCat</span> <span class=\"n\">k</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 379811636,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690639812
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">Rep</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">ModuleCat.isAddCommGroup</span> <span class=\"n\">V.V</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">Rep</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">ModuleCat.isModule</span> <span class=\"n\">V.V</span>\n</code></pre></div>\n<p>doesn't seem to make much difference (in the declaration I'm profiling, at least)</p>",
        "id": 379822977,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690642584
    },
    {
        "content": "<p>OK so I am completely blocked on this one. Here's a summary.</p>\n<p>There are some declarations in the group cohomology files which still take over a minute to compile. What this seems to boil down to is the initially contradictory fact that you can write a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> in Lean and find elements <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>=</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X=Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>≠</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(X)\\not=f(Y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span>! Here's how:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foobar</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">foo.bar</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span>\n<span class=\"kd\">def</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">foobar</span> <span class=\"n\">X</span> <span class=\"bp\">≠</span> <span class=\"n\">foobar</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">zero_ne_one</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This apparent contradiction comes about because even though <code>X</code> and <code>Y</code> are definitionally equal, they're not syntactically equal, so typeclass inference can find unequal terms of type <code>foo X</code> and <code>foo Y</code>.</p>\n<p>So now imagine that <code>X = (Rep.ofMulAction k G (Fin (n + 1) → G) ⟶ A)</code> and <code>Y = (((HomologicalComplex.X (GroupCohomology.resolution k G) n)) ⟶ A)</code> as above. These two types are definitionally but not syntactically equal, and <code>rfl</code> is quick to show this. They are also both <code>k</code>-modules, and in particular <code>AddCommGroup</code>s, and typeclass inference knows this. However, if we use <code>ModuleCat.mk (R := k)</code> to turn them both into terms of type <code>ModuleCat k</code> and now it is not so obvious that they are still defeq, precisely because of the phenomenon above: we checked they were defeq as types, but now we're claiming they're equal as <code>k</code>-modules so we need to check that e.g. the <code>AddCommGroup</code> structures on them are also defeq, and as the example above shows, this really does need to be checked. And this is exactly the sort of problem which Lean 4 is not very good at: big terms with algebra structures on top of them and definitional equality. Lean 4 wants to take absolutely everything apart and things get super-huge. On my machine Lean will spend 0.1 seconds checking <code>X = Y</code> but it will spend 3 seconds checking that the terms of type <code>AddCommGroup X</code> and <code>AddCommGroup Y</code> found by typeclass inference are also defeq (because it turns out that they are). The thing is, this is all over the group cohomology files and is I believe now the main reason that these files are slow.</p>\n<p>So what to do about it? I wondered whether we could make the two <code>AddCommGroup</code> instances \"more obviously defeq\" but I really don't have a clue how to do it.</p>",
        "id": 379898756,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690669898
    },
    {
        "content": "<p>Would it be possible to introduce an auxiliary explicit isomorphism (or <code>AddEquiv</code>, whatever structure we have), which would just be a kind of <code>rfl</code>, and prove equational lemmas for it. If this fails to improve the situation, the definition of this iso could be made irreducible.</p>",
        "id": 389359271,
        "sender_full_name": "Joël Riou",
        "timestamp": 1693986715
    },
    {
        "content": "<p>Yes Mario also suggested that this might be the way to go. The take home message here seems to be that the following principle is wrong: \"in category theory, you shouldn't talk about equality of objects, but actually you can make an exception when the proof is <code>rfl</code>.\"</p>",
        "id": 389362222,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1693987801
    },
    {
        "content": "<p>The original example is sped up significantly with the changes in <a href=\"https://github.com/leanprover-community/mathlib4/pull/6759\">#6759</a>.  It takes &lt; 100000 heartbeats (for a bound) and the profiler time drops to ~3s instead of ~8s.</p>",
        "id": 389362471,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1693987889
    },
    {
        "content": "<p>I came back to thinking about this. <span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span> what is the status of <a href=\"https://github.com/leanprover-community/mathlib4/pull/6759\">#6759</a>?</p>\n<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> I tried to implement (my understanding of) your suggestion but the naive approach remains problematic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.RepresentationTheory.GroupCohomology.Basic</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Rep</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- quick</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">Opposite.op</span> <span class=\"o\">(</span><span class=\"n\">HomologicalComplex.X</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.resolution</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">unop</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">Rep.ofMulAction</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- 8 seconds on my fast machine</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.profiler</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">Opposite.op</span> <span class=\"o\">(</span><span class=\"n\">HomologicalComplex.X</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.resolution</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">unop</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">Rep.ofMulAction</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">LinearEquiv.refl</span> <span class=\"n\">k</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>The proof that <code>X</code> and <code>Y</code> are equal is <code>rfl</code> and quick, but proving they're isomorphic is slow because typeclass inference finds different <code>k</code>-module structures (and different abelian group structures) on the two terms (which are definitionally isomorphic but not syntactically isomorphic). But perhaps one should just take this slowness on the chin once when creating the isomorphism, and then hope it's quick to use.</p>",
        "id": 390075939,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694304964
    },
    {
        "content": "<p>oh actually this does work: writing the post above forced me to collect my thoughts and in fact just putting in the isomorphism explicitly works straight out of the box. In Mathlib.RepresentationTheory.GroupCohomology from around line 117 one can do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Rep</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- we have to pay here, it takes 8 seconds on my fast machine but (just) doesn't require a maxheartbeats bump.</span>\n<span class=\"sd\">/-- hack -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">Opposite.op</span> <span class=\"o\">(</span><span class=\"n\">HomologicalComplex.X</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.resolution</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">unop</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">Rep.ofMulAction</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">LinearEquiv.refl</span> <span class=\"n\">k</span> <span class=\"n\">_</span>\n\n<span class=\"c1\">-- and now we reap the benefits:</span>\n\n<span class=\"c1\">-- no longer true</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Porting note: linter says the statement doesn't typecheck, so we add `@[nolint checkType]` -/</span>\n\n<span class=\"c1\">-- no longer needed</span>\n<span class=\"c1\">-- set_option maxHeartbeats 700000 in</span>\n\n<span class=\"sd\">/-- The theorem that our isomorphism `Fun(Gⁿ, A) ≅ Hom(k[Gⁿ⁺¹], A)` (where the righthand side is</span>\n<span class=\"sd\">morphisms in `Rep k G`) commutes with the differentials in the complex of inhomogeneous cochains</span>\n<span class=\"sd\">and the homogeneous `linearYonedaObjResolution`. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">d_eq</span> <span class=\"o\">:</span>\n    <span class=\"n\">d</span> <span class=\"n\">n</span> <span class=\"n\">A</span> <span class=\"bp\">=</span>\n      <span class=\"c1\">-- adding (foo n A).trans makes everything quick and the same proof still works</span>\n      <span class=\"o\">((</span><span class=\"n\">foo</span> <span class=\"n\">n</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">diagonalHomEquiv</span> <span class=\"n\">n</span> <span class=\"n\">A</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toModuleIso.inv</span> <span class=\"bp\">≫</span>\n        <span class=\"o\">(</span><span class=\"n\">linearYonedaObjResolution</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">d</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">≫</span>\n          <span class=\"c1\">-- also add it here</span>\n          <span class=\"o\">((</span><span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">diagonalHomEquiv</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">A</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toModuleIso.hom</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">f</span> <span class=\"n\">g</span>\n  <span class=\"o\">[</span><span class=\"n\">rest</span> <span class=\"n\">of</span> <span class=\"n\">proof</span> <span class=\"n\">omitted</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Note that the proof still works :-)</p>",
        "id": 390078937,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694306819
    },
    {
        "content": "<p>Next problem in the file boils down to this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.linearYonedaObjResolution</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">GroupCohomology.linearYonedaObjResolution</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>(5 seconds on a fast machine). This is why <code>erw</code> is slow in the proof of <code>inhomogeneousCochains</code> causing a heartbeat bump to 2400000,</p>",
        "id": 390119181,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1694335368
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/6759\">#6759</a> is effectively <a href=\"https://github.com/leanprover-community/mathlib4/pull/6965\">#6965</a> and <a href=\"https://github.com/leanprover/lean4/pull/2478\">lean4#2478</a>. I should put the first back on the rails momentarily.</p>",
        "id": 390375994,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1694460971
    },
    {
        "content": "<p>I was curious if Sebastian's recent caching improvements were relevant here. Kevin's example is still slow even on the whnf-cache-unfold branch (together with the whnf tracing improvements). It still takes 10s and nothing whnf-related appears in the trace, just lots of defeq checks: <br>\n<a href=\"/user_uploads/3121/IlRAZquwZkCACrNsrEIOmRh-/flame_GroupCohomology.svg\">flame_GroupCohomology.svg</a></p>",
        "id": 395310650,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1696617138
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/ModuleCat.2Emk.20slowness/near/390078937\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- we have to pay here, it takes 8 seconds on my fast machine but (just) doesn't require a maxheartbeats bump.</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">Opposite.op</span> <span class=\"o\">(</span><span class=\"n\">HomologicalComplex.X</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.resolution</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">unop</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">Rep.ofMulAction</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">LinearEquiv.refl</span> <span class=\"n\">k</span> <span class=\"n\">_</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>The following is even faster, using 40664 heartbeats rather than 178352 for the version above.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">Opposite.op</span> <span class=\"o\">(</span><span class=\"n\">HomologicalComplex.X</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.resolution</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">unop</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">Rep.ofMulAction</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n  <span class=\"n\">map_add'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">map_smul'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n  <span class=\"n\">left_inv</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">right_inv</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 395320213,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1696621926
    },
    {
        "content": "<p>How am I as an end user supposed to spot or understand that this change will have any effect whatsoever?</p>",
        "id": 395335764,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696630639
    },
    {
        "content": "<p>That spelling is faster because for <code>id</code> lean only has to agree that the types are the same, but for the <code>.refl</code> it also needs to agree that the instances are the same</p>",
        "id": 395337226,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696631835
    },
    {
        "content": "<p>Surely the instance work just moves to proving that <code>map_add'</code> is rfl?</p>",
        "id": 395377389,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696658876
    },
    {
        "content": "<p>Indeed, but now we only have to check that the add fields are equal, not the whole instance</p>",
        "id": 395382545,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696662623
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/ModuleCat.2Emk.20slowness/near/390119181\">said</a>:</p>\n<blockquote>\n<p>Next problem in the file boils down to this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">GroupCohomology.linearYonedaObjResolution</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">GroupCohomology.linearYonedaObjResolution</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>~9500 heartbeats with <a href=\"https://github.com/leanprover/lean4/pull/2644\">lean4#2644</a> and <a href=\"https://github.com/leanprover/lean4/pull/2478\">lean4#2478</a> -- you can play with a working copy of mathlib at <a href=\"https://github.com/leanprover-community/mathlib4/pull/7645\">#7645</a></p>",
        "id": 396355442,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1697140563
    }
]