[
    {
        "content": "<p>I would like to propose some small refactors to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.MonoCoprod#doc\">docs#CategoryTheory.Limits.MonoCoprod</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.CoproductsDisjoint#doc\">docs#CategoryTheory.Limits.CoproductsDisjoint</a>.</p>\n<ol>\n<li>Make <code>CoproductDisjoint</code> and <code>CoproductsDisjoint</code> a <code>Prop</code>, to be in line with <code>HasCoimit</code>, <code>PreservesCoimit</code> etc. by wrapping the outputs in <code>Nonempty</code>.</li>\n<li>Generalize <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.CoproductDisjoint#doc\">docs#CategoryTheory.Limits.CoproductDisjoint</a> to families of objects, i.e. replace <code>CoproductDisjoint</code> by:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CoproductDisjoint</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">nonempty_isInitial_of_ne</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cofan</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsColimit</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PullbackCone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">inj</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">inj</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsLimit</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsInitial</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">pt</span><span class=\"o\">)</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">BinaryCoproductDisjoint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">CoproductDisjoint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WalkingPair</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">))</span>\n</code></pre></div>\n<ol start=\"3\">\n<li>Do the same for <code>MonoCoprod</code> (maybe <code>MonoCoprodOfShape</code>?). Currently the typeclass way to imply \"all coproduct inclusions from coproducts indexed by <code>ι : Type r</code> are monos\" is to say: <code>[MonoCoprod C] [∀ {κ : Type r}, HasColimitsOfShape (Discrete κ) C]</code> (this implies what we want by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.MonoCoprod.mono_inj#doc\">docs#CategoryTheory.Limits.MonoCoprod.mono_inj</a>). It would be nice to say <code>[MonoCoprodOfShape ι]</code> instead.</li>\n</ol>\n<p>Comments appreciated!</p>",
        "id": 524752624,
        "sender_full_name": "Christian Merten",
        "timestamp": 1750267285
    },
    {
        "content": "<p>A related question is the following: What is the \"right\" mathematical definition of \"disjoint coproducts\". I claim the current <code>CoproductDisjoint</code> only makes sense if the category has pullbacks (if pullbacks don't exist, the condition is empty). So the standard trick to avoid it would be to ask for something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CoproductDisjoint'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">nonempty_isInitial_of_ne</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cofan</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsColimit</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">{</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">comm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">inj</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">inj</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsInitial</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which is a stronger condition than the original one also in the case when pullbacks exist (they coincide when initial objects are strict).</p>",
        "id": 524753343,
        "sender_full_name": "Christian Merten",
        "timestamp": 1750267587
    },
    {
        "content": "<p>This (latter) distinction was intentional in <code>CoproductDisjoint</code>: precisely that the condition is empty if there is no pullback of those two objects. The intuition is that \"every intersection of the objects is empty\", which is indeed vacuous if there are no intersections</p>",
        "id": 524754062,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1750267852
    },
    {
        "content": "<p>For your question 2 about generalising to arbitrary coproducts and not just binary ones: I agree. I also agree about wrapping the outputs in <code>Nonempty</code>.</p>",
        "id": 524754182,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1750267888
    },
    {
        "content": "<p>I hope you're also planning to keep that the coprojections are monos, and you're just omitting that here for space!</p>",
        "id": 524754472,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1750268013
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60MonoCoprod.60.20and.20.60DisjointCoproduct.60/near/524754472\">said</a>:</p>\n<blockquote>\n<p>I hope you're also planning to keep that the coprojections are monos, and you're just omitting that here for space!</p>\n</blockquote>\n<p>Yes, I omitted them for brevity</p>",
        "id": 524754615,
        "sender_full_name": "Christian Merten",
        "timestamp": 1750268079
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60MonoCoprod.60.20and.20.60DisjointCoproduct.60/near/524754062\">said</a>:</p>\n<blockquote>\n<p>This (latter) distinction was intentional in <code>CoproductDisjoint</code>: precisely that the condition is empty if there is no pullback of those two objects. The intuition is that \"every intersection of the objects is empty\", which is indeed vacuous if there are no intersections</p>\n</blockquote>\n<p>I'll keep it like this then, in all my applications pullbacks exist anyway.</p>",
        "id": 524754899,
        "sender_full_name": "Christian Merten",
        "timestamp": 1750268206
    },
    {
        "content": "<p>If you are happy to do this quite painful work, you are very much welcome!</p>",
        "id": 524754947,
        "sender_full_name": "Joël Riou",
        "timestamp": 1750268232
    },
    {
        "content": "<p>Do you have particular applications in mind?</p>",
        "id": 524754979,
        "sender_full_name": "Joël Riou",
        "timestamp": 1750268244
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60MonoCoprod.60.20and.20.60DisjointCoproduct.60/near/524754979\">said</a>:</p>\n<blockquote>\n<p>Do you have particular applications in mind?</p>\n</blockquote>\n<p>I need that the yoneda embedding from schemes to Zariski sheafs preserves coproducts, and I believe the right condition for this statement in the context of a subcanonical topology <code>J</code> on a category <code>C</code> is that</p>\n<ol>\n<li>The family of coproduct inclusions in <code>C</code> is a covering wrt. <code>J</code>.</li>\n<li>Coproducts are disjoint in <code>C</code>.</li>\n</ol>",
        "id": 524755375,
        "sender_full_name": "Christian Merten",
        "timestamp": 1750268443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60MonoCoprod.60.20and.20.60DisjointCoproduct.60/near/524753343\">said</a>:</p>\n<blockquote>\n<p>A related question is the following: What is the \"right\" mathematical definition of \"disjoint coproducts\". I claim the current <code>CoproductDisjoint</code> only makes sense if the category has pullbacks (if pullbacks don't exist, the condition is empty). So the standard trick to avoid it would be to ask for something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CoproductDisjoint'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">nonempty_isInitial_of_ne</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cofan</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsColimit</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">{</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">comm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">inj</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">inj</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsInitial</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which is a stronger condition than the original one also in the case when pullbacks exist (they coincide when initial objects are strict).</p>\n</blockquote>\n<p>I think this doesn't work in the case that strict initial objects don't exist: in the category of sets and partial functions, we should have disjoint coproducts, but I could take X1 = X2 = Y = singleton, then the coproduct of X1 and X2 should be disjoint, and I'll take f,g as undefined everywhere, but Y isn't initial.</p>",
        "id": 524755622,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1750268553
    },
    {
        "content": "<p>Given that <code>CoproductDisjoint</code> is a leaf file right now, is it okay if I don't first rename <code>CoproductDisjoint</code> to <code>BinaryCoproductDisjoint</code>, deprecate <code>CoproductDisjoint</code>, wait one deprecation cycle and then introduce the indexed version, but instead just don't have any deprecations?</p>",
        "id": 524756687,
        "sender_full_name": "Christian Merten",
        "timestamp": 1750269076
    },
    {
        "content": "<p>deprecations are (as i understand it) also for downstream projects and PRs?</p>",
        "id": 524757365,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750269400
    },
    {
        "content": "<p>which is to say, if you think that none of those use these definitions...</p>",
        "id": 524757429,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750269435
    },
    {
        "content": "<p>yes ..., but leaf files in Mathlib are typically also rarely used downstream</p>",
        "id": 524757478,
        "sender_full_name": "Christian Merten",
        "timestamp": 1750269454
    },
    {
        "content": "<p>Here is the <code>DisjointCoproduct</code> part: <a href=\"https://github.com/leanprover-community/mathlib4/pull/26122\">#26122</a>.</p>",
        "id": 524782487,
        "sender_full_name": "Christian Merten",
        "timestamp": 1750280128
    },
    {
        "content": "<p>I’m a bit late to the party here, but there is a general definition of \"disjoint (binary) coproducts\" in <a href=\"https://www.math.ias.edu/~lurie/papers/HTT.pdf\">Lurie's Higher topos theory</a> (just after the proof of 6.1.1.4), which seems opposite to the one we take: the hypothesis is that the top left corner of the square is initial and that the square is a pushout, and the conclusion is that then the square is also a pullback.</p>\n<p>A related lemma in HTT is 6.1.5.1, but there is an assumption on universality of colimits (the universality of colimits seems to be used to show that initial objects are strict initial).</p>",
        "id": 525208865,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1750592675
    },
    {
        "content": "<p>If an initial object exists and pullbacks of coproduct inclusions exist, they are equivalent I believe.</p>\n<p>Lurie also says \"More informally, to say that coproducts are disjoint is to say that the intersection of X and<br>\nY inside the union X ∐ Y is empty.\" which seems to correspond to mathlibs definition of disjoint coproduct.</p>",
        "id": 525209248,
        "sender_full_name": "Christian Merten",
        "timestamp": 1750593300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60MonoCoprod.60.20and.20.60DisjointCoproduct.60/near/525209248\">said</a>:</p>\n<blockquote>\n<p>If an initial object exists and pullbacks of coproduct inclusions exist, they are equivalent I believe.</p>\n</blockquote>\n<p>I think this is what 6.1.5.1 proves (with the extra \"initial is strict initial\").</p>",
        "id": 525209331,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1750593414
    },
    {
        "content": "<p>Note also that the version we have in mathlib corresponds to the definition in the Elephant, and in the nLab (which also has a version for arbitrary coproducts), so I think it's reasonable to keep this as is</p>",
        "id": 525211155,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1750596138
    },
    {
        "content": "<p>My guess is that proving equivalence with the two definitions (under some mild hyps) would be a nice addition, regardless of which definition is taken.</p>",
        "id": 525213451,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1750599034
    }
]