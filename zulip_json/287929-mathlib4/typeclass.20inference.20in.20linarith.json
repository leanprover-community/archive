[
    {
        "content": "<p>I noticed that a typical linarith call seems to spend a lot of time on typeclass inference of things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddRightStrictMono#doc\">docs#AddRightStrictMono</a>.  For example, inspect the output of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Linarith</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedField</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">}</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">profiler</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">profiler</span><span class=\"bp\">.</span><span class=\"n\">threshold</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">18</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n</code></pre></div>",
        "id": 481035265,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730948024
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/18714\">#18714</a> I experimented with \"hard-coding\" typeclass inference, by duplicating lemmas to linarith-specific versions which assume at least the bare-minimum linarith typeclass, namely <code>OrderedSemiring</code>.  (This was already done on most lemmas which get used in linarith, but a few had been missed.)</p>\n<p>I'm trying to see how this affects performance.</p>\n<ul>\n<li>Do I read correctly from the output of \"!bench\" that the speedcenter is down again?</li>\n<li>Do I read correctly from the <a href=\"https://github.com/leanprover-community/mathlib4/pull/18714#issuecomment-2461145597\">message after</a> that that this change decreases instruction count by 0.8%?  Is that good?</li>\n</ul>",
        "id": 481035274,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730948029
    },
    {
        "content": "<p>That's quite good!</p>",
        "id": 481037680,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1730949879
    },
    {
        "content": "<p>I think that's <em>very</em> good for such a small change.</p>",
        "id": 481038680,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1730950743
    },
    {
        "content": "<p>OK, but am I actually reading that message correctly? :)</p>",
        "id": 481038721,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730950798
    },
    {
        "content": "<p>I think so, but let's wait for someone who actually knows something about benchmarks to chime in!</p>",
        "id": 481038812,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1730950862
    },
    {
        "content": "<table>\n<thead>\n<tr>\n<th>File</th>\n<th>Instructions</th>\n<th>%</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>build</code></td>\n<td>-111.850⬝10⁹</td>\n<td>(-0.8%)</td>\n</tr>\n<tr>\n<td><code>Mathlib.Tactic.Linarith.Lemmas</code></td>\n<td>+2.82⬝10⁹</td>\n<td>(+36.53%)</td>\n</tr>\n</tbody>\n</table>",
        "id": 481038844,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730950897
    },
    {
        "content": "<p>It looks like the benchmark bot is munging decimals here, and misrepresenting the actual result, which on the speedcenter is only -0.08%.</p>",
        "id": 481042226,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1730953345
    },
    {
        "content": "<p>We really need to fix that. Could someone ping whoever wrote the summary bot?</p>",
        "id": 481042243,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1730953361
    },
    {
        "content": "<p>Unfortunately, <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>, -0.08% is probably noise.</p>",
        "id": 481042256,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1730953375
    },
    {
        "content": "<p>Even if there is no library-wide performance improvement, this is still a good change to make!</p>",
        "id": 481042278,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1730953394
    },
    {
        "content": "<p>Thanks for the explanation!  Is there any chance of the speedcenter coming back soon?  That would give more fine-grained performance information, right?</p>",
        "id": 481042571,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730953614
    },
    {
        "content": "<p>A similar change in the linear-combination-for-inequalities code gave a <a href=\"https://github.com/leanprover-community/mathlib4/blob/ccc281fd98e36cfd28c319e853c133bca515d104/MathlibTest/ring_compare.lean#L58-L62\">50% performance improvement</a> (for a certain choice of denominator).</p>",
        "id": 481042741,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730953712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/channel/287929-mathlib4/topic/typeclass.20inference.20in.20linarith/near/481042571\">said</a>:</p>\n<blockquote>\n<p>Is there any chance of the speedcenter coming back soon?</p>\n</blockquote>\n<p>I think I was clicking in the wrong place -- I see it now.  But I had half-remembered that the speedcenter shows time spend on broad classes of task, like \"typeclass inference\" -- that's not the case?  It just shows per-file times?</p>",
        "id": 481043448,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730954205
    },
    {
        "content": "<p>It does seem to be the case that, with this change, a few dozen analysis files get around 2% faster, which is suggestive of a genuine speedup in linarith.</p>",
        "id": 481043765,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730954430
    },
    {
        "content": "<p>I wonder what the right approach would be here.  Should we have special \"performance\" test suites for each of the major algebraic tactics?</p>",
        "id": 481043824,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1730954486
    },
    {
        "content": "<p>I did some profiling myself in the past (for compiled rather than interpreted linarith), and also concluded that typeclass search was significant. Rewriting linarith to use Qq like ring would make (almost) all of this search happen when building <code>Linarith.lean</code>, rather than each time the tactic is used.</p>",
        "id": 481087284,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1730975030
    },
    {
        "content": "<p>I experimented a bit more and I believe the linarith speedup this change gives is real, even if it is modest on the scale of the whole library (but after all, half the library doesn't even import linarith!):</p>\n<p>I added a <a href=\"https://github.com/leanprover-community/mathlib4/blob/0b7d59ca2c2218e5e5dbc3aa7be155b0feda6845/MathlibTest/linarith.lean#L274-L286\">performance test</a> to the test file, eliminating the \"verification\" step (done by <code>ring</code>) so as to test just the <code>linarith</code> part.  This example takes 3318 heartbeats on current mathlib, and 1647 heartbeats when linarith is tweaked to reduce typeclass inference.</p>\n<p>I looked at the list of files where the summary bot reports an order-10^9 improvement in instruction count: they indeed seem to be files which are actually heavy users of linarith.</p>\n<p>I looked at the linarith calls in the file which sees the biggest improvement: the linarith calls are all in the theorem <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.small_alternating_pow_of_small_tripling#doc\">docs#Finset.small_alternating_pow_of_small_tripling</a>, and this theorem speeds up (on my laptop) from 3.648s to 3.264s.</p>",
        "id": 481578457,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731257624
    },
    {
        "content": "<p>Given this, I think it's worth considering <a href=\"https://github.com/leanprover-community/mathlib4/pull/18714\">#18714</a> as a serious PR, not just an experiment.  I've cleaned it up and it's ready for review.</p>",
        "id": 481579176,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731258178
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/channel/287929-mathlib4/topic/typeclass.20inference.20in.20linarith/near/481578457\">said</a>:</p>\n<blockquote>\n<p>I looked at the linarith calls in the file which sees the biggest improvement: the linarith calls are all in the theorem <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.small_alternating_pow_of_small_tripling#doc\">docs#Finset.small_alternating_pow_of_small_tripling</a>, and this theorem speeds up (on my laptop) from 3.648s to 3.264s.</p>\n</blockquote>\n<p>That's very good news! These calculations are all supposed to be trivial, but became weirdly slow on my laptop after I implemented Bhavik's suggestion to use <code>nlinarith</code> rather than <code>calc</code></p>",
        "id": 481579946,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1731258753
    },
    {
        "content": "<p>How easy is it to use the newish flame graph profiling tools to see where the other time is spent in linarith?</p>",
        "id": 481580310,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731259031
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/typeclass.20inference.20in.20linarith/near/481579946\">said</a>:</p>\n<blockquote>\n<p>Bhavik's suggestion to use <code>nlinarith</code> rather than <code>calc</code></p>\n</blockquote>\n<p>(to be clear, this was a suggestion to use <code>nlinarith</code> to solve an easy nonlinear system rather than giving a 4-line calc proof! Except it's actually 8 lots of <code>nlinarith</code>)</p>",
        "id": 481581589,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1731260057
    },
    {
        "content": "<p>For <code>nlinarith</code>, there's more optimization which could be done: the same process I just carried out for the lemmas used in core <code>linarith</code> could also be carried out for the <code>nlinarith</code>-preprocessor lemmas.</p>",
        "id": 481582851,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731261135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/typeclass.20inference.20in.20linarith/near/481580310\">said</a>:</p>\n<blockquote>\n<p>How easy is it to use the newish flame graph profiling tools to see where the other time is spent in linarith?</p>\n</blockquote>\n<p>This a tool for exploring specific examples, right?  Do you have an example in mind to look at?</p>",
        "id": 481582881,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731261169
    },
    {
        "content": "<p>I was thinking the one you discussed above would be fine</p>",
        "id": 481586430,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731264175
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Here are profiler outputs <a href=\"/user_uploads/3121/etk6Kt_d2LEHkk81lAR1-9Cb/profile-before.json\">before</a> and <br>\n<a href=\"/user_uploads/3121/_mifqSAUchRg2fvRv5fBfu4Q/profile-after.json\">after</a> the suggested typeclass-inference change (<a href=\"https://github.com/leanprover-community/mathlib4/pull/18714\">#18714</a>), on the following example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Linarith</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">testSorryTac</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TacticM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getMainTarget</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">sorryAx</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">closeMainGoalUsing</span><span class=\"w\"> </span><span class=\"ss\">`sorry</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">e</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedField</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">18</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">linarith</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">config</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">discharger</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">testSorryTac</span><span class=\"o\">})</span>\n</code></pre></div>",
        "id": 482689559,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731702318
    },
    {
        "content": "<p>Anything in particular you wanted to know from the flame graph?  On my laptop the timing before and after is ~107 ms, ~59ms respectively.</p>",
        "id": 482689794,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1731702444
    },
    {
        "content": "<p>The aim behind the flame graph suggestion was to track down other key contributors to the runtime, not to evaluate your PR which I'm already sold on the premise of</p>",
        "id": 482690247,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731702664
    },
    {
        "content": "<p>(for instance, in my own profiling on some very large problems, I found <a href=\"https://github.com/leanprover-community/batteries/pull/1036\">https://github.com/leanprover-community/batteries/pull/1036</a> to have a significant effect)</p>",
        "id": 482690458,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731702743
    }
]