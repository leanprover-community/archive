[
    {
        "content": "<p>I would like to extend my automatic differentiation tactic to <code>mfderiv</code> but what scares me is the <code>I'</code> parameter in <code>mfderiv_comp</code>. When give expression <code>mfderiv I I'' (g âˆ˜ f)</code> how am I supposed to figure out what <code>I'</code>?</p>\n<p>Maybe I can forget about using <code>mfderiv_comp</code> and only use theorems in their \"compositional form\"(as I call it in<code>fun_prop</code>) like <code>mfderiv_add</code> which does not introduce a new free variable on rhs. However, to generate efficient code(something I care about) I need to properly handle let bindings and for them I'm forced to use some kind of general composition theorem.</p>\n<p>I'm also a bit unsure about the statement of <code>mfderiv_add</code>, on lhs <code>mfderiv I (modelWithCornersSelf ğ•œ E') (f + g) z</code> cannot it happen that I would have a product model instead of <code>(modelWithCornersSelf ğ•œ E')</code>? Then I could not apply <code>mfderiv_add</code>. </p>\n<p>I have no experience using <code>mfderiv</code> and I would appreciate someone's opinion on how to deal with <code>I'</code> in <code>mfderiv_comp</code>. Is there some reasonable heuristic that would work in 90% cases we care about?</p>",
        "id": 492920441,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1736505088
    }
]