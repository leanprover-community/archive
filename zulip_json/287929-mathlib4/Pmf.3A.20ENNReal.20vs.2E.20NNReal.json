[
    {
        "content": "<p>Probability mass functions are <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Probability/ProbabilityMassFunction/Basic.html#Pmf\">currently defined</a> as </p>\n<blockquote>\n<p>A probability mass function, or discrete probability measures is a function α → ℝ≥0∞ such that the values have (infinite) sum 1.</p>\n</blockquote>\n<p>I wonder why ENNReal is used here as the codomain – surely there can never be an ∞  if the norming conditions doesn’t hold? <br>\nMight it be nicer to use NNReal there, so that one doesn’t have to worry about ∞ when applying a Pmf or doing proofs about it?</p>",
        "id": 382768556,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1691446147
    },
    {
        "content": "<p>I'm not sure why it's like that, but one guess: measures take values in ENNReal, so for parallelism it's nice. It's also a complete lattice, and that makes various things behave nicer. I'm not sure if any of these are sufficient to justify the design decision though.</p>",
        "id": 382769313,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1691446552
    },
    {
        "content": "<p>Yeah, the connection with measures was also my guess. But <code>Pmf.toMeasure</code>could coerce to <code>ENNReal</code> in the right place… I’ll see if I get to a point where this is actually impeding me. Maybe it’s fine to just use <code>toReal</code> where necessary, although my gut feeling leans towards sticking to <code>NNReal</code> as long as possible.</p>",
        "id": 382770427,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1691447068
    },
    {
        "content": "<p>Yeah, I think the bigger issue may be having the complete lattice handy, but probably this is also only a minor convenience. If you are using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENNReal.toReal#doc\">docs#ENNReal.toReal</a> a bunch, then my gut feeling is that switching to <code>ℝ≥0</code> would be preferable (but I have not thought a long time about this, and I'm not familiar with the probability theory part of the library).</p>",
        "id": 382811940,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1691466187
    },
    {
        "content": "<p>The initial design what using <code>NNReal</code>-valued functions, and we switched to <code>ENNReal</code>-later on for the reasons you're mentioning above -- clearer relationships with measures, and avoiding summability issues.</p>",
        "id": 382831427,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1691475003
    },
    {
        "content": "<p>It might be one of those trade offs where the general theory (connection to measurements etc) is easier with one, and concrete applications (calculating specific probabilities and expectations) is easier with the other. I see more of the former in mathlib right now.</p>",
        "id": 382835623,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1691476055
    },
    {
        "content": "<p>Yes, definitely. For concrete applications, it is likely that we will need more API hiding away the concrete definition -- but such an efficient API can only be constructed while doing the applications, and seeing what would be handy there.</p>",
        "id": 382839876,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1691477241
    },
    {
        "content": "<p>There was some previous discussion around <a href=\"#narrow/stream/113488-general/topic/elementary.20probability.20advice/near/306104564\">here</a> (not specific to pmfs, but maybe \"elementary\"/concrete probability more generally). In particular, I think there is a relatively convincing case that for concrete applications much of the API might use <code>Real</code> instead of either <code>NNReal</code> or <code>ENNReal</code>. The tactics (<code>ring</code>, <code>linarith</code>, ...) are much better at handling reals than those other types.</p>",
        "id": 382975368,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1691504443
    },
    {
        "content": "<p>The only \"advantage\" of <code>NNReal</code> seems to be guaranteed nonnegativity by bundling (which is why I made for example the fun-like coercion from <code>FiniteMeasure</code> and <code>ProbabilityMeasure</code> an <code>NNReal</code>). But I think even this is outweighed by some <code>positivity</code> extensions, and the other advantages of reals are much more substantial. (In particular I plan to revisit the fun-like coe choice for finite measures and probability measures.)</p>\n<p>The advantage of <code>ENNReal</code> is of course the direct link to <code>Measure</code>s and <code>lintegral</code>s (by contrast <code>integral</code>s are going to have some more tedious aspects anyway, because integrability guarantees are always needed to avoid junk values). But I think the advantages of <code>Real</code>s for many concrete applications still look significant. Of course the only way is to try...</p>",
        "id": 382975718,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1691504518
    },
    {
        "content": "<p>I'm currently (slowly) PRing the remaining parts of the portmanteau theorem (e.g. <a href=\"https://github.com/leanprover-community/mathlib4/pull/6253\">#6253</a> and <a href=\"https://github.com/leanprover-community/mathlib4/commit/1149cc8757d647a13e883af44e0fd55f8be5ae74#diff-e4d93551f14df30bf38949ad9c3ad03b1a938c96eefd1b9bf8320e0e7f7f6890\">this branch</a>) and will continue with some API of convergence in distribution afterwards, including probably at least some example cases of distributions. Maybe I'll learn something about the concrete applications along the way. <span aria-label=\"fingers crossed\" class=\"emoji emoji-1f91e\" role=\"img\" title=\"fingers crossed\">:fingers_crossed:</span> I'm of course very interested in hearing about your (and others') experiments in concrete probability!</p>",
        "id": 382976568,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1691504684
    },
    {
        "content": "<p>Kalle, I <em>really</em> doubt that using <code>ℝ</code> is the way to go here. I think the automatic nonnegativity gained by bundling is extremely useful, the <code>positivity</code> tactic (or even <code>gcongr</code>) notwithstanding. Moreover, if one ever wants to apply <code>linarith</code>, all one needs to do is apply <code>Subtype.ext</code> or <code>NNReal.coe_le_coe</code>.</p>",
        "id": 382982005,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1691505694
    },
    {
        "content": "<p>Ok, interesting.</p>\n<p>I currently deal with a lot of <code>NNReal</code> and <code>ENNReal</code>-valued things, which are much more tedious to manipulate than I think they should be. I get a feeling that working with reals would make a lot of pain go away. (Incidentally, the direct reason for the generalization <a href=\"https://github.com/leanprover-community/mathlib4/pull/6107\">#6107</a> of some limsup/liminf results to conditionally complete linear orders is that I am simplifying the proof of one implication in portmanteau by getting out of <code>ENNReal</code>s). The point about <code>linarith</code> is good --- in principle it should be a matter of just invoking one extra coercion step (or in the worst case one per each transitively chained inequality?). But for example just letting <code>ring</code> cancel out things in obvious simplification steps instead of making sure that each and every truncated subtraction satisfies what it needs is a frequent pain that should in my opinion be avoidable.</p>\n<p>But I have not really experimented with using <code>Real</code>s in probability yet, so I'm only speculating about the practical difference. I'm obviously happy to stick to what is found out to be the smoothest (or least rough) way.</p>",
        "id": 382991652,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1691507451
    },
    {
        "content": "<p>In the concrete case of Pmfs it seems particularly strange to allow infinity, since by definition the function has to be real valued everywhere. Of course one can cast to ENNReal when connecting to measures, but that direction is presumably simpler than dealing with toReal when getting the probability of a certain outcome.</p>",
        "id": 382996926,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1691508388
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"373986\">@Kalle Kytölä</span> how often are you dealing with subtraction (because this is a fair point, but perhaps we just need better tactic support for <code>tsub</code>)? Can you point me to some example code?</p>",
        "id": 383000038,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1691508971
    },
    {
        "content": "<p>I think more common than subtraction is simplifications involving cancellations (say wanting to invoke <code>ring</code>).</p>\n<p>But sorry, I don't currently remember a very clear case, it is just an overall feeling of where I struggle in Lean vs. math, or maybe as a fairer comparison, in probability Lean vs. e.g. algebra, topology, and analysis Lean (ok, analysis definitely has its own difficulties <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>). But almost surely (i.e. with probability <code>1 : ENNReal</code> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>) I'll find some examples again in the near future, and I'll let you know!</p>\n<p>It is likely that I'm doing some things suboptimally, and I will be happy to learn better ways to avoid the difficulties. I still believe more experimentation by many people will be valuable. I will at least try to provide concrete examples of where I feel <code>NNReal</code>s turn out more difficult than needed and maybe at some later point even test refactoring and seeing if reals are in fact any easier (since this is what I certainly haven't done yet).</p>",
        "id": 383004451,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1691509752
    },
    {
        "content": "<p>This is what I am working towards (in <a href=\"https://github.com/leanprover-community/mathlib4/pull/6454\">https://github.com/leanprover-community/mathlib4/pull/6454</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">integral_eq_sum</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSingletonClass</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Pmf</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∫</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"o\">(</span><span class=\"n\">p.toMeasure</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toReal</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"bp\">…</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bernoulli_expectation</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ENNReal</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∫</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">cond</span> <span class=\"n\">b</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"bp\">∂</span><span class=\"o\">((</span><span class=\"n\">bernoulli</span> <span class=\"n\">p</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toMeasure</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">p.toReal</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">integral_eq_sum</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>It works, but it seems pretter if the <code>Pmf</code> in <code>p a</code> would return a NNReal to begin with, and if the bernoulli distribution parameter was not allowed to be infinite.</p>",
        "id": 383081291,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1691529465
    },
    {
        "content": "<p>Actually, <code>pmf</code>s were previously defined to have codomain <code>NNReal</code>. See <a href=\"https://github.com/leanprover-community/mathlib/blame/286e6bab2e0abc62086fa8a1f02ed7ca4765ad74/src/probability/probability_mass_function/basic.lean\">line 13</a>. I don't know why that changed.</p>",
        "id": 383086241,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1691531125
    },
    {
        "content": "<p>It was changed in <a href=\"https://github.com/leanprover-community/mathlib/commit/e50b8c261b0a000b806ec0e1356b41945eda61f7\">https://github.com/leanprover-community/mathlib/commit/e50b8c261b0a000b806ec0e1356b41945eda61f7</a>. I'll finish what I want to do with the current setting, and afterwards maybe try to go back and compare. (My gut feeling is that the sweet spot is to define the pmf function to have codomain NNReal, but still do all the integreals and measures in ENNReal, to reap the benefits of easy integration.)</p>",
        "id": 383087223,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1691531501
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Pmf.3A.20ENNReal.20vs.2E.20NNReal/near/383000038\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"373986\">Kalle Kytölä</span> how often are you dealing with subtraction (because this is a fair point, but perhaps we just need better tactic support for <code>tsub</code>)? Can you point me to some example code?</p>\n</blockquote>\n<p>What I said in my original response (below) is stupid or at least sloppy:<br>\n<span class=\"user-mention silent\" data-user-id=\"373986\">Kalle Kytölä</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Pmf.3A.20ENNReal.20vs.2E.20NNReal/near/383004451\">said</a>:</p>\n<blockquote>\n<p>I think more common than subtraction is simplifications involving cancellations (say wanting to invoke <code>ring</code>).</p>\n</blockquote>\n<p>Of course <code>NNReal</code> allows for cancellations of just additions (but <code>ENNReal</code> doesn't). So as you correctly suggest, in my trouble with <code>NNReal</code> I must be using subtractions somewhere. At least one place where those come from is passing to probabilities of complements: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">P</mi><mo stretchy=\"false\">[</mo><msup><mi>A</mi><mi>c</mi></msup><mo stretchy=\"false\">]</mo><mo>=</mo><mn>1</mn><mo>−</mo><mi mathvariant=\"sans-serif\">P</mi><mo stretchy=\"false\">[</mo><mi>A</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathsf{P}[A^c] = 1 - \\mathsf{P}[A]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathsf\">P</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathsf\">P</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">]</span></span></span></span> (which is something one does in math without noticing: for example to lower bound a probability one typically upper bounds the complementary probability).</p>\n<p>One concrete use of complements in the portmanteau theorem is to pass from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">lim inf</mi><mo>⁡</mo><msub><mi>μ</mi><mi>i</mi></msub><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo><mo>≥</mo><mi>μ</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\liminf \\mu_i[G] \\ge \\mu[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">lim</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathrm\" style=\"margin-right:0.07778em;\">inf</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> for open sets <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">lim sup</mi><mo>⁡</mo><msub><mi>μ</mi><mi>i</mi></msub><mo stretchy=\"false\">[</mo><mi>F</mi><mo stretchy=\"false\">]</mo><mo>≤</mo><mi>μ</mi><mo stretchy=\"false\">[</mo><mi>F</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\limsup \\mu_i[F] \\le \\mu[F]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">lim</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathrm\">sup</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mclose\">]</span></span></span></span> for closed sets <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> (complements of open sets <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>) --- and vice versa.</p>\n<p>Also for example any inclusion-exclusion formulas involve (something like) complements, and thus subtraction of probabilities.</p>\n<p>I recognize these are not yet the concrete difficulties you were asking for --- I will look for examples and return to this. But I think I generally claim that subtractions are not evil in probability (although they may be in measure theory).</p>",
        "id": 383101234,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1691538131
    },
    {
        "content": "<p>Still not a great concrete example of difficulty in probability (because it has to do with an obvious API hole), but in <a href=\"https://github.com/leanprover-community/mathlib4/pull/6455\">#6455</a> I suggest to add 8 easy <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">lim inf</mi><mo>⁡</mo></mrow><annotation encoding=\"application/x-tex\">\\liminf</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">lim</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathrm\" style=\"margin-right:0.07778em;\">inf</span></span></span></span></span> / <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">lim sup</mi><mo>⁡</mo></mrow><annotation encoding=\"application/x-tex\">\\limsup</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">lim</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathrm\">sup</span></span></span></span></span> lemmas which don't work quite as symmetrically as one would hope. The 4 which involve addition work in at least <code>ℝ</code>, <code>ℝ≥0</code>, and <code>ℝ≥0∞</code>. The other 4, which involve subtraction, apply currently only to <code>ℝ</code>, although mathematically they should work in <code>ℝ≥0</code> and <code>ℝ≥0∞</code> also. (But I hope these 4 can still be temporarily accepted with less than optimal typeclass assumptions, because their applicability in <code>ℝ</code> is a part of how I plan to simplify one of the missing portmanteau implications... by converting manipulations from <code>ℝ≥0∞</code> to <code>ℝ</code> to avoid trouble.)</p>",
        "id": 383101942,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1691538507
    },
    {
        "content": "<p>I spend some time (probably too much) to see what breaks if I change Pmfs to be NNReal-valued. My first attempt to just rewrite stuff turned out to be too tricky, so now in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7155\">mathlib4#7155</a> I do something less invasive, but that would only be a first step towards another sweet spot (if there is one). Maybe one can have the definition to be real-valued, but do computations with infinite sums in <code>ℝ≥0∞</code> (for example by starting the prof with <code>ENNReal.coe_injecive</code>). But I’m not going to push this much further at this point.</p>",
        "id": 391130700,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1694772615
    }
]