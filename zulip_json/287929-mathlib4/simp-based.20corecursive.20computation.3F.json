[
    {
        "content": "<p>Hi there! I'm working on a tactic to compute asymptotics of real functions based on <a href=\"https://www21.in.tum.de/~eberlm/pdfs/real_asymp.pdf\">this paper</a>. The idea is to approximate functions using asymptotic series, perform computations on these series, and use the fact that a function is asymptotically equivalent to the leading term of its series. By \"compute,\" I mean that for functions <code>f</code> and <code>g</code> with corresponding asymptotic series <code>F</code> and <code>G</code>, we can approximate <code>f + g</code> using <code>F + G</code> (where <code>+</code> is the operation on series), and similarly to other operations (<code>*</code>, <code>/</code>, <code>log</code>, <code>exp</code>, <code>sin</code>, etc.).</p>\n<p>The most natural way to work with infinite series computationally is to implement them as a coinductive type, with operations defined corecursively. While Lean doesn't directly support coinductive types, they can be simulated (see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27#doc\">docs#Stream'</a> for example).</p>\n<p>So, I think the tactic should work like this:</p>\n<ol>\n<li>Transform an expression representing a function into an expression representing its asymptotic series</li>\n<li>Apply a lemma that reduces the computation of the function's asymptotic to finding the leading term of the series</li>\n<li>Compute this leading term</li>\n</ol>\n<p>My main question is how to implement the third phase. My idea is to simulate lazy computation by reducing the target expression to the form <code>destruct e</code>, where <code>e</code> is an expression of some coinductive type (like <code>Stream'</code>). Then, reduce <code>e</code> to either <code>nil</code>, <code>cons hd tl</code>, or <code>corec f a</code>, which we know how to destruct, and then repeat until computation completed or some limit <code>maxUnfoldSteps</code> of destructions reached (to prevent infinite computation).</p>\n<p>I will be happy to hear your suggestions on the tactic in general too.</p>",
        "id": 480198766,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1730537344
    },
    {
        "content": "<p>I canâ€™t help at all, but I want to encourage you working on this, this is great!</p>",
        "id": 480212981,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1730549213
    },
    {
        "content": "<p>What is your question? How to do this concretely?</p>",
        "id": 480215321,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730550891
    },
    {
        "content": "<p>I am quite new in metaprogramming. I'd like to know if my approach is adequate, is it doable? Also, maybe someone has already done something similar? Of course I will be glad to see some concrete examples!</p>",
        "id": 480215955,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1730551435
    },
    {
        "content": "<p><a href=\"https://github.com/lecopivo/SciLean\">https://github.com/lecopivo/SciLean</a> SciLean has automatic differentiation, that might be similar</p>",
        "id": 480217134,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730552457
    },
    {
        "content": "<p>My question is more about handling corecursive computation, but thank you, I'll take a look!</p>",
        "id": 480218305,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1730553545
    },
    {
        "content": "<p>There is <a href=\"https://github.com/avigad/qpf\">https://github.com/avigad/qpf</a> for coinductive data</p>",
        "id": 480218458,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1730553692
    }
]