[
    {
        "content": "<p>Hi, this is my first post. I'm a Lean newbie. I'm hoping to use it for category theory eventually, so I'm trying to familiarise myself with the relevant parts of MathLib while also learning the language.</p>\n<p>One question I have is, in MathLib.Data.Opposite and the various places it's imported, why do we have separate <code>op</code> and <code>unop</code> operations, instead of having <code>op</code> be an involution?</p>\n<p>Naïvely, I would have expected the opposite of a quiver to be defined something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">my_op</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>so that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>X</mi><mtext>op</mtext></msup><msup><mo stretchy=\"false\">)</mo><mtext>op</mtext></msup><mo>=</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">(X^\\text{op})^\\text{op} = X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">op</span></span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">op</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">op_op_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">my_op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">my_op</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This can probably be carried over to categories straightforwardly.</p>\n<p>I assume there are good reasons not to do it that way, but I'd like to understand what they are, so that I can get a better feeling for how to work with opposite categories in practice.</p>",
        "id": 571186697,
        "sender_full_name": "Nathaniel Virgo",
        "timestamp": 1769857054
    },
    {
        "content": "<p>Doing so was making too easy to write mathematically meaningless definitions or statements because of abuse of definitional equalities. The trend in the category theory library is to use one-field structures in order to prevent this from happening.</p>",
        "id": 571187676,
        "sender_full_name": "Joël Riou",
        "timestamp": 1769857966
    },
    {
        "content": "<p>In lean, the phrase \"let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> be a category, and let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mover><mo stretchy=\"true\" minsize=\"3.0em\">→</mo><mpadded width=\"+0.6em\" lspace=\"0.3em\"><mi>f</mi></mpadded></mover><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X \\xrightarrow{f} Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1191em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel x-arrow\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1081em;\"><span style=\"top:-3.322em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight x-arrow-pad\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"svg-align\" style=\"top:-2.689em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"hide-tail\" style=\"height:0.522em;min-width:1.469em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"0.522em\" viewBox=\"0 0 400000 522\" preserveAspectRatio=\"xMaxYMin slice\"><path d=\"M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.011em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> be a morphism in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>\" corresponds to the lean code of <code>{C : Type u} [Category.{v} C] {X Y : C} (f : X ⟶ Y)</code>. in order to figure out what <code>X ⟶ Y</code> means, lean needs to figure out what instance of <code>Quiver</code> to use here. It does that by looking at the type of <code>X</code> and <code>Y</code> (which is <code>C</code>), and then looking for an <code>instance</code> of <code>Quiver</code> for that type, which it finds via <code>Category.toQuiver</code>. If there are multiple <code>instance</code>s of <code>Quiver C</code> lean will behave unpredictable and sometimes choose one, sometimes choose the other, and this in general leads to a bad user experience.<br>\n<strong>In short, having multiple <code>instance</code>s of <code>Quiver</code> for the same type is bad.</strong></p>\n<p>If we were to have such a notion of <code>op</code>, in order to state this equality, we would need* <code>op (op X) : C</code>. However, this is only possible if the type of <code>op</code> is* <code>C -&gt; C</code>, so we would also need to define an instance of the opposite category structure on <code>C</code>, which we have decided leads to too much confusion. As Joël said, in the category theory library this was mitigated by making the type <code>Opposite C</code> distinct from <code>C</code> at even the strongest reducibility, using one-field structures. Now, the statement that <code>op</code> is (categorically) an involution is captured by <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Opposites.html#CategoryTheory.opOpEquivalence\">CategoryTheory.opOpEquivalence</a></p>\n<p>*: there is in lean the notion of \"reducibility\" and \"irreducibility\" meaning that for certain declarations, lean sometimes doesn't unfold the definition. one can make use of this in order to define <code>Opposite C := C</code>, and define the opposite category on <code>Opposite C</code> rather than <code>C</code> itself, and so long as you make sure to give your variables the correct type, this works... However it turns out that if you don't consistently insert coercions either way to help lean realize if you're working with <code>Opposite C</code> or <code>C</code>, you again get the same issue where lean is confused about what category you're working with.</p>",
        "id": 571188995,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769859202
    }
]