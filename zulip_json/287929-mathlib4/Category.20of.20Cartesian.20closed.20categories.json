[
    {
        "content": "<p>As far as I know, we don't currently have the category of ccc's in mathlib. If I'm overlooking it or maybe it's been done in another project, I'd appreciate it being pointed out.</p>\n<p>For <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Cat#doc\">docs#CategoryTheory.Cat</a>, we work with a structure that bundles the objects. Would it make sense to do something similar for ccc's? My first thought is that you would need to bundle the additional typeclass instances (i.e. <code>Category</code> and <code>Limits.HasFiniteProducts</code>).</p>",
        "id": 474354852,
        "sender_full_name": "Chris Henson",
        "timestamp": 1727889754
    },
    {
        "content": "<p>Following up, I almost have this done. The one proof I have left and am struggling with a bit is that <code>CartesianClosedFunctor</code> composes.  Here's how far I got:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasFiniteProducts</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CartesianClosed</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasFiniteProducts</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CartesianClosed</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasFiniteProducts</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CartesianClosed</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">â¥¤</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">â¥¤</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">PreservesLimitsOfShape</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Discrete</span><span class=\"w\"> </span><span class=\"n\">WalkingPair</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PreservesLimitsOfShape</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Discrete</span><span class=\"w\"> </span><span class=\"n\">WalkingPair</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CCF_F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CartesianClosedFunctor</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CCF_G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CartesianClosedFunctor</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">compCartesianClosedFunctor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CartesianClosedFunctor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">â‹™</span><span class=\"w\">  </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">comparison_iso</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"c1\">-- right type, but a bit unsure if this is correct...</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">inv_F</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">F_inv_r</span><span class=\"o\">,</span><span class=\"n\">F_inv_l</span><span class=\"bp\">âŸ©âŸ©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CCF_F</span><span class=\"bp\">.</span><span class=\"n\">comparison_iso</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">out</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">inv_G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">G_inv_r</span><span class=\"o\">,</span><span class=\"n\">G_inv_l</span><span class=\"bp\">âŸ©âŸ©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CCF_G</span><span class=\"bp\">.</span><span class=\"n\">comparison_iso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">out</span>\n<span class=\"w\">  </span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">rightAdjointSquare</span><span class=\"bp\">.</span><span class=\"n\">hcomp</span><span class=\"w\"> </span><span class=\"n\">inv_G</span><span class=\"w\"> </span><span class=\"n\">inv_F</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Is this headed in the right direction?</p>",
        "id": 475917749,
        "sender_full_name": "Chris Henson",
        "timestamp": 1728493235
    },
    {
        "content": "<p>Sorry for only responding to this thread now...<br>\n<span class=\"user-mention\" data-user-id=\"420917\">@Sina H ð“ƒµ</span> you have CCC's right?â€¯Or only LCCC's?</p>",
        "id": 476496084,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1728712004
    },
    {
        "content": "<p>No worries! I've seen LCCCs in the polynomial functor repo, but I don't think CCCs? I'm working on categorical semantics for polymorphism and dependent types, so I'll need both.</p>",
        "id": 476545254,
        "sender_full_name": "Chris Henson",
        "timestamp": 1728759568
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> Completely missed this! sorry, not good with Zulip! CCCs were already in mathlib before LCCCs in <code>Mathlib.CategoryTheory.Closed.Cartesian</code><br>\nAnd LCCCs are now in a branch that is in the PR review <a href=\"https://github.com/leanprover-community/mathlib4/pull/21525\">#21525</a></p>",
        "id": 499750779,
        "sender_full_name": "Sina Hazratpour ð“ƒµ",
        "timestamp": 1739541865
    },
    {
        "content": "<p>But to answer your question, i think we don't have a category/2-category of CCCs or LCCCs in mathlib. In Poly project you cited, there is a category and bicategory of polynomial functors but morphims are not <code>CartesianClosedFunctor</code>. </p>\n<p>I think it would be nice to have category (or 2-category) of CCCs and LCCCs. <br>\nThis would be a categorification of the category of Heyting algebras with homs defined by <code>HeytingHom</code>. Also, it would be give a basis for later obtaining  a category of elementary toposes where the homs are defined by logical mophisms which are basically <code>CartesianClosedFunctor</code>. </p>\n<p>Can you say a few words about the context of your project?</p>",
        "id": 499752152,
        "sender_full_name": "Sina Hazratpour ð“ƒµ",
        "timestamp": 1739542187
    }
]