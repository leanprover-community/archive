[
    {
        "content": "<p>In  <a href=\"https://github.com/leanprover-community/mathlib4/pull/2280\">!4#2280</a>, there's the local definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[to_additive</span>\n<span class=\"kd\">      \"Addition of ultrafilters given by\\n`∀ᶠ m in U+V, p m ↔ ∀ᶠ m in U, ∀ᶠ m' in V, p (m+m')`.\"]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Ultrafilter.hasMul</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Mul</span> <span class=\"o\">(</span><span class=\"n\">Ultrafilter</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">mul</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">*</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">U</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">V</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">local</span> <span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">Ultrafilter.hasMul</span> <span class=\"n\">Ultrafilter.hasAdd</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> We could have taken this as the definition of `U * V`, but then we would have to prove that it</span>\n<span class=\"cm\">defines an ultrafilter. -/</span>\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Ultrafilter.eventually_mul</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">Ultrafilter</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀ᶠ</span> <span class=\"n\">m</span> <span class=\"k\">in</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"bp\">*</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">m</span> <span class=\"k\">in</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">m'</span> <span class=\"k\">in</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">m'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Iff.rfl</span>\n</code></pre></div>\n<p>Later, in <code>Ultrafilter.semigroup</code> (line 70, marked by a <code>-- porting note</code>), we get a very slow typechecking. If I turn on <code>set_option trace.Meta.synthInstance true</code>, we get a very convoluted typechecking for <code>Ultrafilter.hasMul</code>, ending in <code>result Semigroup.toMul</code> and for <code>Ultrafilter.eventually_mul</code> we get an even longer typechecking with far more failure ending in exactly the same place.</p>\n<p>But the instances should be short-circuited by the <code>attribute [local instance]</code>....</p>\n<p>Later at line 139 <code>exists_idempotent_ultrafilter_le_FP</code> we have a very odd proof state, where Lean 4 claims there are no goals, but what's really happening is that Lean can't fill in the placeholders at  <code>obtain ⟨U, hU, U_idem⟩ := exists_idempotent_in_compact_subsemigroup _ S _ _ _</code>. It takes some work to get Lean to realize that's what's happening but it's easiest to see if you do a <code>have h := &lt;lhs&gt;</code>.</p>\n<p>After some experimentation, I <em>think</em> what's happening is that there's a timeout here in filling in the placeholders, and it leaves the tactic state confused? Certainly, if, e.g., I replace one of the placeholders with <code>(by library_search)</code>, I get an actual timeout. I believe if we fix typeclass resolution for <code>Ultrafilter</code> we'll fix this issue as well...</p>",
        "id": 327855330,
        "sender_full_name": "Arien Malec",
        "timestamp": 1676402317
    },
    {
        "content": "<p>(The third  and final issue at line 190 is one where the types check similarly on Lean 3 and Lean 4 but Lean 4 doesn't believe the types are as desired).</p>",
        "id": 327855739,
        "sender_full_name": "Arien Malec",
        "timestamp": 1676402468
    },
    {
        "content": "<p>Can I throw all this in the general <a href=\"https://github.com/leanprover/lean4/issues/2055\">https://github.com/leanprover/lean4/issues/2055</a> bucket?</p>",
        "id": 328156400,
        "sender_full_name": "Arien Malec",
        "timestamp": 1676525064
    }
]