[
    {
        "content": "<p>Why are the notations <code>⨅ x ∈ s, f x</code> and <code>⨆ x ∈ s, f x</code>, for <code>s</code> a subset of the domain of <code>f</code>, defined the way they are?</p>\n<p>I was expecting that <code>⨅ x ∈ s, f x</code> was just a more compact way of writing <code>⨅ x : ↑s, f ↑x</code>, i.e. the iInf over <code>s</code> coerced to a type. But it's really <em>not</em> the same!</p>\n<p>Mathlib's definition seems to be that <code>⨅ x ∈ s, f s</code> expands to a nested infimum, <code>⨅ x, ⨅ (_ : x ∈ s), f s</code>, with the inner infimum over the type of proofs of <code>x ∈ s</code>. But if <code>x</code> isn't in <code>s</code>, then <code>⨅ (_ : x ∈ s), f s</code> is the infimum of the empty set. If the target of f doesn't have a top element, then this is a meaningless question and so the return value is junk. But then the outer infimum is <code>⨅ x, if x ∈ s then f s else JUNK</code>, and if <code>s</code> isn't the whole domain and the junk value happens to be strictly smaller than anything in <code>f '' s</code>, then we get nonsense.</p>\n<p>For example, one can prove that <code>⨅ x ∈ ({1} : Set ℝ), x = 0</code>. I find this rather disturbing!</p>\n<p>What is the reasoning behind this decision about how to interpret <code>⨅ x ∈ s, f x</code>? Why is it not defined to be inf / sup over the subtype defined by <code>s</code>?</p>",
        "id": 472565284,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727208293
    },
    {
        "content": "<p>Perhaps the idea is you should be using <code>sInf</code> instead? Either way, this feels like a clear oversight, or at least a weird design decision without proper documentation.</p>",
        "id": 472567175,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1727209171
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span></p>",
        "id": 472567179,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1727209175
    },
    {
        "content": "<p>That's a design decision predating me</p>",
        "id": 472567423,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727209287
    },
    {
        "content": "<p>but the rationale is that you can actually put any predicate in that notation, and it does the same as what a forall would do</p>",
        "id": 472567618,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727209370
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/287929-mathlib4/topic/sup.20and.20inf.20over.20sets/near/472565284\">said</a>:</p>\n<blockquote>\n<p>What is the reasoning behind this decision about how to interpret <code>⨅ x ∈ s, f x</code>? Why is it not defined to be inf / sup over the subtype defined by <code>s</code>?</p>\n</blockquote>\n<p>Also note that you then need to precompose f with Subtype.val</p>",
        "id": 472567746,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727209433
    },
    {
        "content": "<p>Anyway, it's not impossible to change the notation but it would need to be clearly motivated and it will have fallout: eg lemmas about nested suprema/infima currently apply to <code>\\Sup x \\in s, f x</code>. With your proposal, they wouldn't anymore</p>",
        "id": 472568118,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727209591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/sup.20and.20inf.20over.20sets/near/472567618\">said</a>:</p>\n<blockquote>\n<p>but the rationale is that you can actually put any predicate in that notation, and it does the same as what a forall would do</p>\n</blockquote>\n<p>I don't think so; it seems to be specific to predicates of the form <code>x ∈ s</code>, if I understand the code for <code>iSup_delab</code> in <code>Mathlib.Order.SetNotation</code> correctly.</p>",
        "id": 472568238,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727209652
    },
    {
        "content": "<p>You should read the notation to see how Lean elaborates the notation. Delaborator may be a partial inverse.</p>",
        "id": 472574014,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1727212089
    },
    {
        "content": "<p>A more general situation is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hij</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">{(</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)}</span>\n</code></pre></div>",
        "id": 472582090,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727216452
    },
    {
        "content": "<p><code>⨆ i ∈ s,</code> is just a shorthand for <code>⨆ (i : ℕ) (_ : i ∈ s),</code></p>",
        "id": 472582156,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727216487
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I am not sure what point you are making with that comment. In what sense is that a more general situation? (Note that your code produces an unevaluated metavariable and a linter warning.)</p>",
        "id": 472617377,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727243092
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span> Thanks for flagging this. I agree that this is a footgun. If we can remove it that would be great. Atm I can't see through the ramifications of switching to quantifying over the subtype. Would that break a lot of mathlib? Would working with it become awkward? Or can we get a smooth API for it?</p>",
        "id": 472828698,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727334866
    },
    {
        "content": "<p>A downside of working with subtypes is that it becomes much more complex to exchange two binders; instead of rewriting by <code>iSup_comm</code>, you have to build the equiv</p>",
        "id": 472838418,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727338107
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Can you be more specific about the kind of \"exchanging two binders\" you have in mind? The cases I'm asking about are where the \"inner\" iInf / iSup is over proofs of a proposition which depends on the index variable of the \"outer\" iInf / iSup, so clearly it's not meaningful to exchange them anyway. Are you thinking of cases where we have multiple index variables (or multiple predicates), so we really have 3 or more binders?</p>",
        "id": 472843731,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727339900
    },
    {
        "content": "<p>Yes, precisely</p>",
        "id": 472845008,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727340336
    },
    {
        "content": "<p>If you have two predicates involved, we'd just be rewriting <code>{x // p x \\and q x}</code> to {x // q x \\and p x}<code> using </code>Or.comm`, wouldn't we?</p>",
        "id": 472862269,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727345912
    },
    {
        "content": "<p>I think we'd get a nested subtype if we aren't careful</p>",
        "id": 472863157,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727346223
    },
    {
        "content": "<p>The rewrite won't work if anything inside the binder uses <code>x.prop.1</code> and <code>x.prop.2</code>, which need to be exchanged</p>",
        "id": 472875601,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727350726
    },
    {
        "content": "<p>Note that even</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">and_comm</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>does not work</p>",
        "id": 472875752,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727350793
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> yet again I am unsure what you expect your example to demonstrate. Note that</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">and_comm</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>works fine.</p>",
        "id": 472888848,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727355014
    },
    {
        "content": "<p>That's not a particularly good example, since it involves equality of types. Here's a more realistic one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">and_comm</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">and_comm</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 472889628,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727355227
    },
    {
        "content": "<p>Yes, your last example works; but it is proving 0 = 0, when I am pretty sure that most mathematicians would agree that the infimum of the set {x : ℕ | 0 &lt; x &lt; 10} should be 1:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⨅</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_zero_eq</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">ciInf_le_of_le'</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">lt_self_iff_false</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">ofNat_pos</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">and_true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">iInf_of_empty</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_refl</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I am not sure that it is a strong argument for the status quo that we can easily prove that one highly misleading junk answer is equal to another equally bad one.</p>",
        "id": 472895544,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727356798
    },
    {
        "content": "<p>Edited, I meant to use <code>iSup</code></p>",
        "id": 472895687,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727356830
    },
    {
        "content": "<p>I don't disagree that there is a footgun here</p>",
        "id": 472895783,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727356858
    },
    {
        "content": "<p>Basically the current elaborator for <code>\\inf x, x \\in s</code> never gives a useful answer, unless <code>\\bot \\in s</code>, right?</p>",
        "id": 472897326,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727357294
    },
    {
        "content": "<p>I don't think <code>s</code> is relevant to whether it's useful</p>",
        "id": 472897488,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727357348
    },
    {
        "content": "<p>It's better to have a correct definition that is hard to work with than a bad definition that is easy to manipulate</p>",
        "id": 472897542,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727357365
    },
    {
        "content": "<p>That argument would lead to defining <code>a / b : Option K</code> instead of <code>a / b : K</code> in fields</p>",
        "id": 472897614,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727357387
    },
    {
        "content": "<p>Which is to say, there's a gray area of compromises</p>",
        "id": 472897736,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727357410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/sup.20and.20inf.20over.20sets/near/472897326\">said</a>:</p>\n<blockquote>\n<p>Basically the current elaborator for <code>\\inf x, x \\in s</code> never gives a useful answer, unless <code>\\bot \\in s</code>, right?</p>\n</blockquote>\n<p>The issue isn't about the set <code>s</code>, it's about the type in which the function takes values. For <code>f : X → Y</code>, our def of <code>⨅  x ∈ s, f x</code> is almost always the wrong answer unless <code>Y</code> has a bottom element (and dually for <code>⨆</code> and top elements).</p>",
        "id": 472898214,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727357528
    },
    {
        "content": "<p>(I suspect that the authors of the code mostly had in mind the cases of <code>Y</code> being either <code>Set α</code> for some <code>α</code>, or <code>ENNReal</code>.)</p>",
        "id": 472898749,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727357669
    },
    {
        "content": "<p>To be more concrete:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⨅</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- because of junk values for `x` outside the interval</span>\n<span class=\"bp\">⨅</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>I agree this is a footfun, and I would be happy to change the way that <code>⨅ x ∈ s</code> elaborates. This notation is from Lean 3, where \"duplicate the binder\" was basically the only thing we can do.<br>\nThough Eric raises a good point, it would be sad if that makes it harder to reason about infima (especially in complete lattices, where the two definitions coincide).</p>",
        "id": 472899222,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1727357800
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/287929-mathlib4/topic/sup.20and.20inf.20over.20sets/near/472899222\">said</a>:</p>\n<blockquote>\n<p>Though Eric raises a good point, it would be sad if that makes it harder to reason about infima (especially in complete lattices, where the two definitions coincide).</p>\n</blockquote>\n<p>Yeah, this would be <em>very</em> sad.</p>",
        "id": 473789592,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1727713683
    },
    {
        "content": "<p><a href=\"#narrow/stream/287929-mathlib4/topic/sup.20and.20inf.20over.20sets/near/473789592\">A message</a> was moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/triangle.20ineq.20for.20finite.20sums.2Fprods\">#mathlib4 &gt; triangle ineq for finite sums/prods</a> by <span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span>.</p>",
        "id": 473829661,
        "sender_full_name": "Notification Bot",
        "timestamp": 1727723453
    },
    {
        "content": "<p>Even disregarding the foot gun argument, I think it's weird that we have these two distinct ways to write a supremum over a complete lattice.</p>",
        "id": 475433866,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1728349469
    },
    {
        "content": "<p>And that's disregarding <code>Sup (f '' s)</code></p>",
        "id": 475434036,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1728349548
    },
    {
        "content": "<p>It's really jarring to see theorems being spelled out in these different alternatives with little consistency. A couple of the primes being tagged by the linter are the fault of this.</p>",
        "id": 475435468,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1728350333
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/7227\">mathlib4#7227</a> I was exploring a way to process binders that had an actual concept of bounded quantification, i.e. quantifiers that have a binder type and an object over which the binding is happening. This was to move away from Lean-3-style binder elaboration where it nests the expansions.</p>\n<p>A motivation for this was that summation notation over finsets is special-cased (i.e., it doesn't use <code>notation3</code>'s binder facilities) since it's not amenable to this Lean-3-style \"use nested sums\" elaboration, since <code>Finset</code> is restricted to <code>Type _</code>, so it's not possible to sum over proofs. The <code>∑ x ∈ s, f x</code> syntax needs to expand to a <code>Finset.sum s (fun x : X =&gt; f x)</code> expression, with a binder type <code>X</code>, a binding object <code>s</code>, and the function to sum.</p>\n<p>The binder elaborator in the PR is pretty flexible (and maybe too flexible). For example, it's easy to do cute things like define binders like <code>∑ x + y = 5, f x y</code>. You don't even need to redefine the <code>∑</code> syntax — it's extensible. The following macro says \"when expanding a <code>a + b = n</code> binder for some finset-focused notation, expand it as a <code>(a, b) ∈ Finset.Nat.antidiagonal n</code> binder.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">macro_rules</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">binder</span><span class=\"bp\">%</span><span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">%</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">binder</span><span class=\"bp\">%</span><span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">%</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">antidiagonal</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>The idea still needs refinement, but maybe it'll be useful at some point.</p>",
        "id": 475437585,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1728351734
    },
    {
        "content": "<p>This thread was mentioned recently, and I wanted to mention that I'm still pulling at it, but this time with potential core support.</p>\n<p>The rough idea so far is that binder elaboration ought to result in the following data:</p>\n<ul>\n<li>a binding name <code>x</code></li>\n<li>a binding domain <code>T</code></li>\n<li>an (optional) binding predicate <code>T -&gt; Prop</code></li>\n</ul>\n<p>If there's a binding predicate, I suppose it could be called a <em>bounded</em> binder (maybe <em>predicated</em> binder is better?) We currently call the syntax <em>extended</em> binders.</p>\n<p>Basic examples:</p>\n<ul>\n<li><code>(x : T)</code> is unrestricted binding, with no binding predicate.</li>\n<li><code>(x ∈ s)</code> with <code>s : Set T</code> has binding name <code>x</code>, binding domain <code>T</code>, and binding predicate <code>x ∈ s</code> (convention: this a proposition, but thinking of it as a function of <code>x</code> makes it a predicate).</li>\n<li><code>(n &gt; 0)</code> with <code>0 : Nat</code> has binding name <code>n</code>, binding domain <code>ℕ</code>, and binding predicate <code>n &gt; 0</code>.</li>\n</ul>\n<p>Mathlib's <code>notation3</code> scoped notations can make use of this system by letting there be different expansions depending on whether or not the binder has a predicate.</p>\n<p>For example, perhaps one would have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=iSup#doc\">docs#iSup</a> for the unbounded case and an actual <code>biSup</code> for the predicated case. Maybe something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">biSup</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SupSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>A non-dependent version would likely be much better for rewriting though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">biSup</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SupSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>(Congruence lemmas could supply the fact that <code>p</code> is true when simplifying the body of <code>s</code>.)</p>\n<p>Possibly <code>notation3</code> could specially support <code>x ∈ s</code> predicates. This could be useful for <code>Finset.prod</code>/<code>Finset.sum</code>-style operators that use some term (rather than a predicate) for the bounded domain. I think filters could make use of this as well, e.g. <code>∀ᶠ x ∈ f, p x</code> rather than <code>∀ᶠ x in f, p x</code> (I think this is nice, since filters are \"generalized sets\" right? But maybe this is too confusing, given the existence of the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.instMembership#doc\">docs#Filter.instMembership</a> instance.)</p>\n<p>Something that's missing here in this proposal compared to <a href=\"https://github.com/leanprover-community/mathlib4/pull/7227\">mathlib4#7227</a> is the concept of \"domain types\". This lets the binders expand differently depending on whether one is working with types/sets, finsets, filters, etc. For example, that PR has the facility to have <code>(x &lt; 10)</code> in the finset domain type to expand as <code>Finset.Iio 10</code>.</p>",
        "id": 520725159,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748366072
    }
]