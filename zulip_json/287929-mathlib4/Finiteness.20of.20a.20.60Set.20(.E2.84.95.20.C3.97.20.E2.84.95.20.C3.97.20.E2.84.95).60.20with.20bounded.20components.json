[
    {
        "content": "<p>What's the shortest way to prove that a <code>Set</code> of tuples of natural numbers is finite, given that all components of tuples in the set are bounded?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.CardEmbedding</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Linarith</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Defs</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">hk</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">zagierSet</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">t.1</span> <span class=\"bp\">*</span> <span class=\"n\">t.1</span> <span class=\"bp\">+</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">t.2.1</span> <span class=\"bp\">*</span> <span class=\"n\">t.2.2</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zagierSet_lower_bound</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">zagierSet</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">zagierSet</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_setOf_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"o\">(</span><span class=\"n\">by_contra</span> <span class=\"n\">q</span><span class=\"bp\">;</span> <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">q</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">le_zero_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">q</span><span class=\"bp\">;</span> <span class=\"n\">subst</span> <span class=\"n\">q</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply_fun</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">%</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_mod</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">cases'</span> <span class=\"o\">(</span><span class=\"n\">Nat.dvd_prime</span> <span class=\"n\">hk.out</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">dvd_of_mul_left_eq</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"n\">e</span> <span class=\"bp\">&lt;;&gt;</span>\n    <span class=\"o\">(</span><span class=\"n\">subst</span> <span class=\"n\">e</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hk</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hk.out</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zagierSet_upper_bound</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">zagierSet</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span> <span class=\"bp\">∧</span> <span class=\"n\">z</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">hz</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">zagierSet_lower_bound</span> <span class=\"n\">k</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">zagierSet</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_setOf_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">nlinarith</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">fintypeZagierSet</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">zagierSet</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Defs</span>\n</code></pre></div>",
        "id": 384308970,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691857402
    },
    {
        "content": "<p>You can embed it into a type that’s known to be finite and use <code>Fintype.ofInjcetive</code>.</p>",
        "id": 384309775,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1691857628
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.ofInjective#doc\">docs#Fintype.ofInjective</a></p>",
        "id": 384309835,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1691857648
    },
    {
        "content": "<p>It's probably easier to stay with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite#doc\">docs#Set.Finite</a> for the proof (e.g you have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite.subset#doc\">docs#Set.Finite.subset</a>) and then use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite.fintype#doc\">docs#Set.Finite.fintype</a></p>",
        "id": 384310184,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1691857743
    },
    {
        "content": "<p>With the proven bounds, it should be easy to embed it in <code>Fin (k+2) x Fin (k+1) x Fin (k+ 1)</code></p>",
        "id": 384310536,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1691857830
    },
    {
        "content": "<p>(The context is Zagier's \"one-sentence proof\" of the sum of two squares theorem, from Wikipedia, using cardinalities of involutions)</p>",
        "id": 384310599,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691857851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Finiteness.20of.20a.20.60Set.20.28.E2.84.95.20.C3.97.20.E2.84.95.20.C3.97.20.E2.84.95.29.60.20with.20bounded.20components/near/384310184\">said</a>:</p>\n<blockquote>\n<p>It's probably easier to stay with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite#doc\">docs#Set.Finite</a> for the proof (e.g you have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite.subset#doc\">docs#Set.Finite.subset</a>) and then use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite.fintype#doc\">docs#Set.Finite.fintype</a></p>\n</blockquote>\n<p>like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">finiteZagierSet</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">zagierSet</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Finite</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 384311444,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691858093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"598052\">Jeremy Tan</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Finiteness.20of.20a.20.60Set.20.28.E2.84.95.20.C3.97.20.E2.84.95.20.C3.97.20.E2.84.95.29.60.20with.20bounded.20components/near/384310599\">said</a>:</p>\n<blockquote>\n<p>(The context is Zagier's \"one-sentence proof\" of the sum of two squares theorem, from Wikipedia, using cardinalities of involutions)</p>\n</blockquote>\n<p>I also tried this long ago in lean 3, hopefully it is much easier now with the development of mathlib. At the time I remember finiteness statements like this being a nightmare</p>",
        "id": 384311489,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1691858106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"598052\">Jeremy Tan</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Finiteness.20of.20a.20.60Set.20.28.E2.84.95.20.C3.97.20.E2.84.95.20.C3.97.20.E2.84.95.29.60.20with.20bounded.20components/near/384311444\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Finiteness.20of.20a.20.60Set.20.28.E2.84.95.20.C3.97.20.E2.84.95.20.C3.97.20.E2.84.95.29.60.20with.20bounded.20components/near/384310184\">said</a>:</p>\n<blockquote>\n<p>It's probably easier to stay with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite#doc\">docs#Set.Finite</a> for the proof (e.g you have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite.subset#doc\">docs#Set.Finite.subset</a>) and then use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite.fintype#doc\">docs#Set.Finite.fintype</a></p>\n</blockquote>\n<p>like this?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">fintypeZagierSet</span> <span class=\"o\">:</span> <span class=\"n\">Set.Finite</span> <span class=\"o\">(</span><span class=\"n\">zagierSet</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><code>Set.Finite</code> isn't a typeclass, so this should just be a lemma</p>",
        "id": 384311683,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1691858180
    },
    {
        "content": "<p>oeps</p>",
        "id": 384311763,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691858219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Finiteness.20of.20a.20.60Set.20.28.E2.84.95.20.C3.97.20.E2.84.95.20.C3.97.20.E2.84.95.29.60.20with.20bounded.20components/near/384310536\">said</a>:</p>\n<blockquote>\n<p>With the proven bounds, it should be easy to embed it in <code>Fin (k+2) x Fin (k+1) x Fin (k+ 1)</code></p>\n</blockquote>\n<p><code>Fin (k + 2) × Fin (k + 1) × Fin (k + 1)</code> isn't a set…</p>",
        "id": 384314533,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691859194
    },
    {
        "content": "<p>Yes, your original message asked for a fintype instance…</p>",
        "id": 384315014,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1691859387
    },
    {
        "content": "<p>This doesn't work</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">finiteZagierSet</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">zagierSet</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Finite</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine'</span> <span class=\"bp\">@</span><span class=\"n\">Set.Finite.subset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">Set.univ</span> <span class=\"n\">inferInstance</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 384315072,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691859415
    },
    {
        "content": "<p>What I was suggesting is to define an injective map from the type associated to your set into this product of Fins, then use the lemma I mentioned to prove that the type associated to your set is a fintype. If you want a proof using <code>Set.Finite</code> then this approach might not be the best.</p>",
        "id": 384315669,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1691859576
    },
    {
        "content": "<p>Unfortunately I’m away from my computer for the rest of the day, so I can’t help much with actual lean code</p>",
        "id": 384315894,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1691859622
    },
    {
        "content": "<p>I think I got the right statement</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">zagierSetEmbedding</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"bp\">//</span> <span class=\"n\">t</span> <span class=\"bp\">∈</span> <span class=\"n\">zagierSet</span> <span class=\"n\">k</span><span class=\"o\">}</span> <span class=\"bp\">↪</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 384316904,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691859980
    },
    {
        "content": "<p>That shouldn’t be an instance</p>",
        "id": 384317259,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1691860107
    },
    {
        "content": "<p>And you don’t necessarily need subtype notation</p>",
        "id": 384317321,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1691860128
    },
    {
        "content": "<p>I think you might have an easier time showing that it's equal to <code>(Finset.Ioc 0 (k + 1)).product &lt;| (Finset.Ioc 0 k)).product &lt;| Finset.Ioc 0 k)</code> filtered by the obvious relation</p>",
        "id": 384317353,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1691860136
    },
    {
        "content": "<p>Maybe contained in, as opposed to equal to?</p>",
        "id": 384317506,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1691860197
    },
    {
        "content": "<p>That way you don’t need any relation, and should still suffice for <code>Set.Finite</code></p>",
        "id": 384317673,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1691860245
    },
    {
        "content": "<p>Also, probably <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.Icc#doc\">docs#Finset.Icc</a> ?</p>",
        "id": 384317744,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1691860282
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Finiteness.20of.20a.20.60Set.20.28.E2.84.95.20.C3.97.20.E2.84.95.20.C3.97.20.E2.84.95.29.60.20with.20bounded.20components/near/384317353\">said</a>:</p>\n<blockquote>\n<p>I think you might have an easier time showing that it's equal to <code>(Finset.Ioc 0 (k + 1)).product &lt;| (Finset.Ioc 0 k)).product &lt;| Finset.Ioc 0 k)</code> filtered by the obvious relation</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">LocallyFiniteOrder</span> <span class=\"n\">ℕ</span>\n</code></pre></div>",
        "id": 384318458,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691860521
    },
    {
        "content": "<p>I hope that only means you are missing an import</p>",
        "id": 384318540,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1691860549
    },
    {
        "content": "<p>yeah, the required instance is in <code>Data.Nat.Interval</code></p>",
        "id": 384318687,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691860606
    },
    {
        "content": "<p>Seems a bit better now</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Interval</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Linarith</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Defs</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">hk</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">zagierSet</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">t.1</span> <span class=\"bp\">*</span> <span class=\"n\">t.1</span> <span class=\"bp\">+</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">t.2.1</span> <span class=\"bp\">*</span> <span class=\"n\">t.2.2</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">zagierSet_lower_bound</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">zagierSet</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">zagierSet</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_setOf_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"o\">(</span><span class=\"n\">by_contra</span> <span class=\"n\">q</span><span class=\"bp\">;</span> <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">q</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">le_zero_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">q</span><span class=\"bp\">;</span> <span class=\"n\">subst</span> <span class=\"n\">q</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply_fun</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">%</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_mod</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">cases'</span> <span class=\"o\">(</span><span class=\"n\">Nat.dvd_prime</span> <span class=\"n\">hk.out</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">dvd_of_mul_left_eq</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"n\">e</span> <span class=\"bp\">&lt;;&gt;</span>\n    <span class=\"o\">(</span><span class=\"n\">subst</span> <span class=\"n\">e</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hk</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hk.out</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">zagierSet_upper_bound</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">zagierSet</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span> <span class=\"bp\">∧</span> <span class=\"n\">z</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">hz</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">zagierSet_lower_bound</span> <span class=\"n\">k</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">zagierSet</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_setOf_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">nlinarith</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">zagierFinset</span> <span class=\"o\">:=</span>\n  <span class=\"o\">((</span><span class=\"n\">Ioc</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">product</span> <span class=\"o\">((</span><span class=\"n\">Ioc</span> <span class=\"mi\">0</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">product</span> <span class=\"o\">(</span><span class=\"n\">Ioc</span> <span class=\"mi\">0</span> <span class=\"n\">k</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">filter</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">zagierSetEquiv</span> <span class=\"o\">:</span> <span class=\"n\">zagierSet</span> <span class=\"n\">k</span> <span class=\"bp\">≃</span> <span class=\"n\">zagierFinset</span> <span class=\"n\">k</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">⟩,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">hz</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">zagierSet_upper_bound</span> <span class=\"n\">k</span> <span class=\"n\">h</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n    <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Defs</span>\n</code></pre></div>",
        "id": 384320000,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691861112
    },
    {
        "content": "<p>You should be showing <code>zagierSet k = zagierFinset k</code>!</p>",
        "id": 384320985,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1691861486
    },
    {
        "content": "<p>It's 1:30am here...</p>",
        "id": 384321273,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691861566
    },
    {
        "content": "<p>I should be sleeping but the thrill is preventing me from doing that</p>",
        "id": 384321335,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691861586
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 384321996,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691861823
    },
    {
        "content": "<p>What's the correct theorem to show that two sets are equal by showing that every element of one set is contained in the other?</p>",
        "id": 384323330,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691862266
    },
    {
        "content": "<p>A documentation search doesn't turn up anything</p>",
        "id": 384323419,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691862311
    },
    {
        "content": "<p>oh, wait, <code>ext</code> might do it</p>",
        "id": 384323486,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691862337
    },
    {
        "content": "<p>whee</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">zagierSet_eq</span> <span class=\"o\">:</span> <span class=\"n\">zagierSet</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">zagierFinset</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">⟩</span>\n  <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">unfold</span> <span class=\"n\">zagierSet</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">zagierFinset</span><span class=\"bp\">;</span> <span class=\"n\">simp_all</span>\n    <span class=\"k\">have</span> <span class=\"n\">lb</span> <span class=\"o\">:=</span> <span class=\"n\">zagierSet_lower_bound</span> <span class=\"n\">k</span> <span class=\"n\">h</span>\n    <span class=\"k\">have</span> <span class=\"n\">ub</span> <span class=\"o\">:=</span> <span class=\"n\">zagierSet_upper_bound</span> <span class=\"n\">k</span> <span class=\"n\">h</span>\n    <span class=\"n\">apply</span> <span class=\"n\">mem_product.2</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n    <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">lb.1</span><span class=\"o\">,</span> <span class=\"n\">ub.1</span><span class=\"o\">⟩</span>\n    <span class=\"n\">apply</span> <span class=\"n\">mem_product.2</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨⟨</span><span class=\"n\">lb.2.1</span><span class=\"o\">,</span> <span class=\"n\">ub.2.1</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">lb.2.2</span><span class=\"o\">,</span> <span class=\"n\">ub.2.2</span><span class=\"o\">⟩⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">unfold</span> <span class=\"n\">zagierFinset</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">zagierSet</span><span class=\"bp\">;</span> <span class=\"n\">simp_all</span>\n</code></pre></div>",
        "id": 384326412,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691863377
    },
    {
        "content": "<p><code>(zagierSet k).Finite </code> should follow trivially from there, though you probably don't need it at all now you have the finset</p>",
        "id": 384334053,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1691866198
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Finiteness.20of.20a.20.60Set.20.28.E2.84.95.20.C3.97.20.E2.84.95.20.C3.97.20.E2.84.95.29.60.20with.20bounded.20components/near/384317353\">said</a>:</p>\n<blockquote>\n<p>I think you might have an easier time showing that it's equal to <code>(Finset.Ioc 0 (k + 1)).product &lt;| (Finset.Ioc 0 k)).product &lt;| Finset.Ioc 0 k)</code> filtered by the obvious relation</p>\n</blockquote>\n<p>/me screams in unused notation</p>",
        "id": 384351492,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1691875261
    },
    {
        "content": "<p>I never set up a global input method and didn't have lean open. Indeed, using notation for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.product#doc\">docs#Finset.product</a> would be better</p>",
        "id": 384351558,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1691875319
    },
    {
        "content": "<p>This is the key theorem used in Zagier's proof – not sure how to go from here</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Dynamics.PeriodicPts</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Card</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.ModEq</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Function</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">card_fixedPoints_modEq_card</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">fixedPoints</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">≡</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">α</span> <span class=\"o\">[</span><span class=\"n\">MOD</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 384406002,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691907391
    },
    {
        "content": "<p>There needs to be some statement that \"<code>α</code> decomposes into its orbits under <code>f</code>\" but no idea where that is</p>",
        "id": 384409747,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691909285
    },
    {
        "content": "<p>The orbit-stabiliser theorem may help, but how do I put a group structure on the function application?</p>",
        "id": 384411917,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1691910353
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.End#doc\">docs#Function.End</a></p>",
        "id": 384424670,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1691915067
    },
    {
        "content": "<p>Probably the quickest way in mathlib is to use the fact that the submonoid generated by your fixed morphism is finite, hence actually a group</p>",
        "id": 384551543,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1691948553
    },
    {
        "content": "<p>Searching the docs I found <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/GroupTheory/PGroup.html#IsPGroup.card_modEq_card_fixedPoints\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/GroupTheory/PGroup.html#IsPGroup.card_modEq_card_fixedPoints</a></p>",
        "id": 384551794,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1691948645
    },
    {
        "content": "<p>OK, I'm really confused now</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Dynamics.PeriodicPts</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Card</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.ModEq</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.GroupAction.Quotient</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.PGroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Submonoid.Membership</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">id</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Function</span> <span class=\"n\">Submonoid</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">iterClosure</span> <span class=\"o\">:</span> <span class=\"n\">Submonoid</span> <span class=\"o\">(</span><span class=\"n\">Function.End</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">powers</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">groupIterClosure</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">iterClosure</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">inv</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"kd\">by</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">iterClosure</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_powers_iff</span><span class=\"o\">]</span>\n    <span class=\"n\">use</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n  <span class=\"n\">mul_left_inv</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I don't know how to get from <code>HPow</code> to <code>Nat.iterate</code> in the first sorry</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝²</span><span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">α</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">α</span>\n<span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"n\">hf</span><span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">id</span>\n<span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">iterClosure</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">f</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 385013391,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692080241
    },
    {
        "content": "<p><code>MonoidHom.coe_pow</code> doesn't work because it expects <code>Monoid.End</code> rather than the type of f, which is <code>Function.End</code></p>",
        "id": 385013665,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692080341
    },
    {
        "content": "<p>I do not really know the <code>End</code>-part of mathlib, but maybe there is a missing lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">missing</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Function.End</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">^</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">k</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">iterate_succ'</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">pow_succ</span><span class=\"o\">]</span>\n      <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">groupIterClosure</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">iterClosure</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">inv</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"kd\">by</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">iterClosure</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_powers_iff</span><span class=\"o\">]</span>\n    <span class=\"n\">use</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span>\n    <span class=\"n\">apply</span> <span class=\"n\">missing</span><span class=\"bp\">?</span><span class=\"o\">⟩</span>\n  <span class=\"n\">mul_left_inv</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 385018013,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692081847
    },
    {
        "content": "<p>Note that I have a PR making <code>missing?</code> true definitionally.</p>",
        "id": 385022558,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1692083227
    },
    {
        "content": "<p>It seems that missing API in Lean is a synonym for \"Yaël has a PR for it\".</p>",
        "id": 385024546,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692083775
    },
    {
        "content": "<p>... or Eric!</p>",
        "id": 385035463,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1692086768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Finiteness.20of.20a.20.60Set.20.28.E2.84.95.20.C3.97.20.E2.84.95.20.C3.97.20.E2.84.95.29.60.20with.20bounded.20components/near/385022558\">said</a>:</p>\n<blockquote>\n<p>Note that I have a PR making <code>missing?</code> true definitionally.</p>\n</blockquote>\n<p>Yes. Where is it?</p>",
        "id": 385052496,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692090717
    },
    {
        "content": "<p>Is it <a href=\"https://github.com/leanprover-community/mathlib4/pull/862\">#862</a>?!</p>",
        "id": 385053792,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692091016
    },
    {
        "content": "<p>I'd argue we're missing some API for type-casting with <code>Function.End</code> and <code>Monoid.End</code>, which is why <code>missing?</code> is missing</p>",
        "id": 385056215,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692091521
    },
    {
        "content": "<p>I don't know how to deal with the build failures in <a href=\"https://github.com/leanprover-community/mathlib4/pull/862\">#862</a></p>",
        "id": 385064645,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692093364
    },
    {
        "content": "<p>The failures in <code>Algebra.Group.Units</code> mention <code>rfl</code> but <code>rfl</code> is nowhere to be found</p>",
        "id": 385064755,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692093393
    },
    {
        "content": "<p>the <code>rfl</code> is in the default value for a field you didn't provide</p>",
        "id": 385095991,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692100449
    },
    {
        "content": "<p>Now Lean simply refuses to rewrite the <code>*</code> in the goal state before the sorry (<code>g^[p - 1] * g = 1</code>) to function composition</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Dynamics.PeriodicPts</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Card</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.ModEq</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.GroupAction.Quotient</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.PGroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Submonoid.Membership</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Function.End</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">id</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Function</span> <span class=\"n\">Submonoid</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pow_eq_iterate</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">^</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">k</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">iterate_succ'</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">pow_succ</span><span class=\"o\">]</span>\n      <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">iterClosure</span> <span class=\"o\">:</span> <span class=\"n\">Submonoid</span> <span class=\"o\">(</span><span class=\"n\">Function.End</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">powers</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">groupIterClosure</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">iterClosure</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"kd\">by</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">iterClosure</span> <span class=\"n\">at</span> <span class=\"n\">hg</span> <span class=\"bp\">⊢</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_powers_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hg</span> <span class=\"bp\">⊢</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hg</span>\n    <span class=\"n\">use</span> <span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">pow_eq_iterate</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">pow_mul</span><span class=\"o\">]⟩</span>\n  <span class=\"n\">mul_left_inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"n\">mk_mul_mk</span><span class=\"o\">]</span>\n    <span class=\"n\">congr</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 385133330,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692108283
    },
    {
        "content": "<p>wait…</p>",
        "id": 385134742,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692108492
    },
    {
        "content": "<p>yeah this works</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Dynamics.PeriodicPts</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Card</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.ModEq</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.GroupAction.Quotient</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.PGroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Submonoid.Membership</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Function.End</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">id</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Function</span> <span class=\"n\">Submonoid</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pow_eq_iterate</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">^</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">k</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">iterate_succ'</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">pow_succ</span><span class=\"o\">]</span>\n      <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">groupIterClosure</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_powers_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hg</span> <span class=\"bp\">⊢</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hg</span>\n    <span class=\"n\">use</span> <span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">pow_eq_iterate</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">pow_mul</span><span class=\"o\">]⟩</span>\n  <span class=\"n\">mul_left_inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"n\">mk_mul_mk</span><span class=\"o\">]</span>\n    <span class=\"n\">congr</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">pow_eq_iterate</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">pow_succ'</span><span class=\"o\">,</span>\n      <span class=\"n\">Nat.sub_add_cancel</span> <span class=\"o\">(</span><span class=\"n\">one_le_two.trans</span> <span class=\"o\">(</span><span class=\"n\">Nat.Prime.two_le</span> <span class=\"n\">hp.out</span><span class=\"o\">))]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_powers_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hg</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hg</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">pow_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">pow_mul</span><span class=\"o\">,</span> <span class=\"n\">pow_eq_iterate</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">pow_eq_iterate</span><span class=\"o\">,</span> <span class=\"n\">iterate_id</span><span class=\"o\">]</span>\n    <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 385136398,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692108807
    },
    {
        "content": "<p>(<code>hp</code> being the Fact that <code>p</code> is prime)</p>",
        "id": 385136458,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692108823
    },
    {
        "content": "<p>This is much better, but how can I prove the last instance below (with the sorry)?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.PGroup</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Key</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Function.End</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">id</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Function</span> <span class=\"n\">Submonoid</span>\n\n<span class=\"sd\">/-- A shim theorem. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">pow_eq_iterate</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">^</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">k</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">iterate_succ'</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">pow_succ</span><span class=\"o\">]</span>\n      <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">groupPowers</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_powers_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hg</span> <span class=\"bp\">⊢</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hg</span>\n    <span class=\"n\">use</span> <span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">pow_eq_iterate</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">pow_mul</span><span class=\"o\">]⟩</span>\n  <span class=\"n\">mul_left_inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"n\">mk_mul_mk</span><span class=\"o\">]</span>\n    <span class=\"n\">congr</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">pow_eq_iterate</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">pow_succ'</span><span class=\"o\">,</span>\n      <span class=\"n\">Nat.sub_add_cancel</span> <span class=\"o\">(</span><span class=\"n\">one_le_two.trans</span> <span class=\"o\">(</span><span class=\"n\">Nat.Prime.two_le</span> <span class=\"n\">hp.out</span><span class=\"o\">))]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_powers_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hg</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hg</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">pow_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">pow_mul</span><span class=\"o\">,</span> <span class=\"n\">pow_eq_iterate</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">pow_eq_iterate</span><span class=\"o\">,</span> <span class=\"n\">iterate_id</span><span class=\"o\">]</span>\n    <span class=\"n\">rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">mulActionPowers</span> <span class=\"o\">:</span> <span class=\"n\">MulAction</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">one_smul</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">mul_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">isPGroup_of_powers</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">IsPGroup</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">groupPowers</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">IsPGroup</span>\n  <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span>\n  <span class=\"n\">use</span> <span class=\"mi\">1</span>\n  <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">congr</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_powers_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hg</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hg</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">pow_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">pow_mul</span><span class=\"o\">,</span> <span class=\"n\">pow_eq_iterate</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">pow_eq_iterate</span><span class=\"o\">,</span> <span class=\"n\">iterate_id</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">MulAction.fixedPoints</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"n\">Set.fintypeSubset</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">key</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">IsPGroup.card_modEq_card_fixedPoints</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">isPGroup_of_powers</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Key</span>\n</code></pre></div>",
        "id": 385154348,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692112164
    },
    {
        "content": "<p>Since <code>MulAction.fixedPoints (powers f) α</code> is of type <code>Set α</code> and <code>α</code> is already a <code>Fintype</code>, there should be an obvious lemma I am missing</p>",
        "id": 385155795,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692112417
    },
    {
        "content": "<p><code>exact?</code> finds the answer for me</p>",
        "id": 385156736,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1692112577
    },
    {
        "content": "<p>My code's gotten big enough that I've pushed all of it to the <code>zagier</code> branch on mathlib4:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/tree/zagier\">https://github.com/leanprover-community/mathlib4/tree/zagier</a></p>\n<p>I now have a problem at the sorry on L145 of <code>Mathlib/NumberTheory/Zagier.lean</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">sq_add_sq_of_nonempty_fixedPoints</span>\n    <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">MulAction.fixedPoints</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">zagierSubtype</span> <span class=\"n\">k</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">⟩,</span> <span class=\"n\">he</span><span class=\"o\">⟩,</span> <span class=\"n\">hf</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hn</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">MulAction.mem_fixedPoints</span><span class=\"o\">,</span> <span class=\"n\">Subtype.forall</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mem_powers</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">hk</span><span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Nat.Prime</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"n\">xyz</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">he</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">zagierSet</span> <span class=\"n\">k</span>\n<span class=\"n\">hf</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Function.End</span> <span class=\"o\">(</span><span class=\"n\">zagierSubtype</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">)),</span>\n  <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">b</span> <span class=\"o\">}</span> <span class=\"bp\">•</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">),</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">he</span> <span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">),</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">he</span> <span class=\"o\">}</span>\n<span class=\"n\">this</span><span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">obvInvo</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">}</span> <span class=\"bp\">•</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">),</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">he</span> <span class=\"o\">}</span> <span class=\"bp\">=</span>\n  <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">),</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">he</span> <span class=\"o\">}</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>I want to simplify <code>this</code> to the condition that <code>y = z</code> but I can't get through the <code>•</code> of subtypes</p>",
        "id": 385304537,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692144885
    },
    {
        "content": "<p>Here <code>obvInvo</code> is the obvious involution in Zagier's proof <code>(x, y, z) -&gt; (x, z, y)</code>. Its fixed points correspond to representations of a <code>4k+1</code> prime as a sum of two squares</p>",
        "id": 385305446,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692145334
    },
    {
        "content": "<p>Then there is a more complicated involution (not yet defined in the branch), defined piecewise, which Zagier shows to have exactly one fixed point <code>(1, 1, k)</code>. His argument then goes</p>\n<ul>\n<li>since there is exactly 1 fixed point of the complicated involution, <code>Odd (Fintype.card (zagierSubtype k))</code></li>\n<li>therefore <code>(MulAction.fixedPoints (powers (obvInvo k)) (zagierSubtype k)).Nonempty</code> by modular considerations</li>\n<li>the fixed point of <code>obvInvo</code> gives a representation of <code>4 * k + 1</code> as a sum of two squares.</li>\n</ul>",
        "id": 385306081,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692145633
    },
    {
        "content": "<p>I thought that we already had a proof that primes which are 1 mod 4 are the sum of two squares</p>",
        "id": 385377770,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692172073
    },
    {
        "content": "<p>But not a proof that fits in the title of a PR.</p>",
        "id": 385400810,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1692173873
    },
    {
        "content": "<p>Right, now how do I get from <code>this</code> to <code>y = z</code>?</p>",
        "id": 385425172,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692178843
    },
    {
        "content": "<p>I would guess <code>congr_arg subtype.val this</code> followed by <code>dsimp</code></p>",
        "id": 385425570,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692178990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Finiteness.20of.20a.20.60Set.20.28.E2.84.95.20.C3.97.20.E2.84.95.20.C3.97.20.E2.84.95.29.60.20with.20bounded.20components/near/385425570\">said</a>:</p>\n<blockquote>\n<p>I would guess <code>congr_arg subtype.val this</code> followed by <code>dsimp</code></p>\n</blockquote>\n<p>Doesn't work. I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">sq_add_sq_of_nonempty_fixedPoints</span>\n    <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">MulAction.fixedPoints</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">zagierSubtype</span> <span class=\"n\">k</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">⟩,</span> <span class=\"n\">he</span><span class=\"o\">⟩,</span> <span class=\"n\">hf</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hn</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">MulAction.mem_fixedPoints</span><span class=\"o\">,</span> <span class=\"n\">Subtype.forall</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mem_powers</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">apply_fun</span> <span class=\"n\">Subtype.val</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n</code></pre></div>\n<p>but in the goal state <code>this</code> still has outside <code>SMul</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">this</span><span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">({</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">obvInvo</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">}</span> <span class=\"bp\">•</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">),</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">he</span> <span class=\"o\">})</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 385439245,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692184349
    },
    {
        "content": "<p>It looks like a dsimp lemma is missing. Does <code>change _ • _ = _</code> at <code>this</code> help?</p>",
        "id": 385439391,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692184410
    },
    {
        "content": "<p>Which instance is that <code>•</code>?</p>",
        "id": 385439413,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692184421
    },
    {
        "content": "<p>That <code>change</code> doesn't work either. The <code>SMul</code> instance is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">HSMul.hSMul</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">zagierSubtype</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zagierSubtype</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">instHSMul</span>\n  <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">obvInvo</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">),</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">he</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">zagierSubtype</span> <span class=\"n\">k</span>\n</code></pre></div>",
        "id": 385439830,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692184591
    },
    {
        "content": "<p>(bear in mind you can now pull the <code>zagier</code> branch)</p>",
        "id": 385439864,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692184604
    },
    {
        "content": "<p>What's the <code>instHSMul</code> there?</p>",
        "id": 385439872,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692184608
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">instHSMul</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">zagierSubtype</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">MulAction.toSMul</span> <span class=\"o\">:</span> <span class=\"n\">HSMul</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">zagierSubtype</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zagierSubtype</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 385439937,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692184640
    },
    {
        "content": "<p>And the <code>MulAction.toSMul</code>? you want to trace it back until you're past all the <code>Foo.toBar</code> instances</p>",
        "id": 385439966,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692184657
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">MulAction.toSMul</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">zagierSubtype</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">toMonoid</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">mulActionPowers</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">SMul</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">zagierSubtype</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 385440007,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692184675
    },
    {
        "content": "<p>Is <code>mulActionPowers</code> your own instance?</p>",
        "id": 385440078,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692184692
    },
    {
        "content": "<p>Yes (it's defined in L92 of <code>Zagier.lean</code> in the branch)</p>",
        "id": 385440162,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692184727
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">mulActionPowers</span> <span class=\"o\">:</span> <span class=\"n\">MulAction</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">one_smul</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">mul_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 385440183,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692184734
    },
    {
        "content": "<p>Does <code>rw [Submonoid.smul_def] at this</code> (then <code>dsimp</code>) make progress?</p>",
        "id": 385440298,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692184771
    },
    {
        "content": "<p>Now _that_ works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">sq_add_sq_of_nonempty_fixedPoints</span>\n    <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">MulAction.fixedPoints</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">zagierSubtype</span> <span class=\"n\">k</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">⟩,</span> <span class=\"n\">he</span><span class=\"o\">⟩,</span> <span class=\"n\">hf</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hn</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">MulAction.mem_fixedPoints</span><span class=\"o\">,</span> <span class=\"n\">Subtype.forall</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mem_powers</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">apply_fun</span> <span class=\"n\">Subtype.val</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Submonoid.smul_def</span><span class=\"o\">,</span> <span class=\"n\">End.smul_def</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 385440594,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692184887
    },
    {
        "content": "<p>After the <code>dsimp</code> I have <code>this: ↑(obvInvo k { val := (x, y, z), property := he }) = (x, y, z)</code></p>",
        "id": 385440620,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692184899
    },
    {
        "content": "<p>Sounds like you forgot to teach lean that <code>obvInvo</code> was obvious</p>",
        "id": 385440933,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692185037
    },
    {
        "content": "<p>Full proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">sq_add_sq_of_nonempty_fixedPoints</span>\n    <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">MulAction.fixedPoints</span> <span class=\"o\">(</span><span class=\"n\">powers</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">zagierSubtype</span> <span class=\"n\">k</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">⟩,</span> <span class=\"n\">he</span><span class=\"o\">⟩,</span> <span class=\"n\">hf</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hn</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">MulAction.mem_fixedPoints</span><span class=\"o\">,</span> <span class=\"n\">Subtype.forall</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"o\">(</span><span class=\"n\">obvInvo</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mem_powers</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">apply_fun</span> <span class=\"n\">Subtype.val</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Submonoid.smul_def</span><span class=\"o\">,</span> <span class=\"n\">End.smul_def</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">obvInvo</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">zagierSet</span> <span class=\"n\">at</span> <span class=\"n\">he</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">he</span>\n  <span class=\"n\">use</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this.1</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">he</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 385441210,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692185146
    },
    {
        "content": "<p>THE PROOF IS FINISHED<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/6629\">#6629</a></p>",
        "id": 385634074,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692264150
    },
    {
        "content": "<p>This is a <a href=\"https://leanprover-community.github.io/mathlib4_docs/Counterexamples/SorgenfreyLine.html#Counterexample.SorgenfreyLine\">really long line</a>!</p>",
        "id": 385648079,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692269350
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> I have responded to your reviews</p>",
        "id": 385808401,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692329670
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253861\">@Thomas Browning</span> how to prove the sorry below? The function is in <code>GroupTheory.Perm.Cycle.Type</code> after <code>card_compl_support_modEq</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The number of fixed points of a `p ^ n`-th root of the identity function over a finite set</span>\n<span class=\"sd\">and the set's cardinality have the same residue modulo `p`, where `p` is a prime. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">card_modEq_card_fixedPoints_of_pow_prime</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Function.End</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Fintype.card</span> <span class=\"n\">α</span> <span class=\"bp\">≡</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">f.fixedPoints</span> <span class=\"o\">[</span><span class=\"n\">MOD</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"kd\">by</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">Function.LeftInverse</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Function.comp_apply</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n      <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">pow_succ'</span><span class=\"o\">,</span>\n      <span class=\"n\">Nat.sub_add_cancel</span> <span class=\"o\">(</span><span class=\"n\">pow_pos</span> <span class=\"n\">hp.out.pos</span> <span class=\"n\">n</span><span class=\"o\">)]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">congrFun</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"kd\">by</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">Function.RightInverse</span><span class=\"o\">,</span> <span class=\"n\">Function.LeftInverse</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Function.comp_apply</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n      <span class=\"k\">show</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">pow_succ</span><span class=\"o\">,</span>\n      <span class=\"n\">Nat.sub_add_cancel</span> <span class=\"o\">(</span><span class=\"n\">pow_pos</span> <span class=\"n\">hp.out.pos</span> <span class=\"n\">n</span><span class=\"o\">)]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">congrFun</span> <span class=\"n\">hf</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"n\">hσ</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">f.fixedPoints</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">support</span> <span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"bp\">ᶜ.</span><span class=\"n\">card</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"bp\">▸</span> <span class=\"o\">(</span><span class=\"n\">card_compl_support_modEq</span> <span class=\"n\">hσ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">f.fixedPoints</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">support</span> <span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">Fintype.card_coe</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Set.ext_iff</span><span class=\"o\">,</span> <span class=\"n\">Function.IsFixedPt</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 386546280,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692689098
    },
    {
        "content": "<p>Yes, it's more painful than it ought to be. I answered on github.</p>",
        "id": 386547681,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1692689718
    },
    {
        "content": "<p>It does not seem to help if I define <code>npow</code> on <code>instMonoidEnd</code> as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Monoid</span> <span class=\"o\">(</span><span class=\"n\">Function.End</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n  <span class=\"n\">mul</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">∘</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">mul_one</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">one_mul</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">npow</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span>\n  <span class=\"n\">npow_zero</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">npow_succ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Function.iterate_succ'</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 386554654,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692692445
    },
    {
        "content": "<blockquote>\n<p>However, a less hacky way might be to override npow in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/GroupTheory/GroupAction/Defs.html#instMonoidEnd\">instMonoidEnd</a></p>\n</blockquote>\n<p>Yeah, I've overridden it, now what?</p>",
        "id": 386555504,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692692777
    },
    {
        "content": "<p>I don't think you should be refactoring that in that PR</p>",
        "id": 386571283,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692698240
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I have not committed the <code>npow</code> override to my PR</p>",
        "id": 386583477,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1692702614
    }
]