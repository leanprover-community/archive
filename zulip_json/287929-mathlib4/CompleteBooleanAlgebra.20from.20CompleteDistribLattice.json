[
    {
        "content": "<p>How do I turn a complete distributive lattice into a complete Boolean algebra?<br>\nA year ago this was easy: just define <code>compl</code> and prove <code>inf_compl_le_bot</code> and <code>top_le_sup_compl</code>.</p>\n<p>Since <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>'s refactor of complete distributive lattices this is now much harder.<br>\nEither I use <code>CompleteDistribLattice.ofMinimalAxioms</code>. This means that <code>compl</code> instance already exists, and I have to prove that an unfriendly definition is the same as the definition I want.<br>\nand now I have two goals <code>sdiff_eq</code> and <code>himp_eq</code> involving two operations that I don't care about and they're not <code>rfl</code> anymore.<br>\nOr I use the constructor for <code>CompleteDistribLattice</code> and I have to give the operations <code>himp</code> and <code>sdiff</code> that I don't care about, and then I have to prove lemmas about (and having defined them in terms of complements does not make these properties entirely trivial).<br>\nWhy don't these fields have default values?</p>",
        "id": 484544656,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1732636240
    },
    {
        "content": "<p>For reference, this was all I had to do a year ago: <a href=\"https://github.com/fpvandoorn/LeanCourse23/blob/master/LeanCourse/Lectures/Lecture11.lean#L478-L498\">https://github.com/fpvandoorn/LeanCourse23/blob/master/LeanCourse/Lectures/Lecture11.lean#L478-L498</a></p>",
        "id": 484545232,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1732636393
    },
    {
        "content": "<p>This is for the same reason as to why we are slowly moving away from default values altogether: they are very prone to invisibly creating diamonds</p>",
        "id": 484545583,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732636467
    },
    {
        "content": "<p>For people reading: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompleteBooleanAlgebra#doc\">docs#CompleteBooleanAlgebra</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompleteDistribLattice#doc\">docs#CompleteDistribLattice</a></p>",
        "id": 484545853,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732636553
    },
    {
        "content": "<p>I disagree with the objective to make beginners suffer so that we maybe avoid a diamond.</p>",
        "id": 484545939,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1732636568
    },
    {
        "content": "<p>Sorry, I don't understand what you are complaining about anymore</p>\n<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/CompleteBooleanAlgebra.20from.20CompleteDistribLattice/near/484544656\">said</a>:</p>\n<blockquote>\n<p>now I have two goals <code>sdiff_eq</code> and <code>himp_eq</code> involving two operations that I don't care about and they're not <code>rfl</code> anymore.</p>\n</blockquote>\n<p>Why are they not <code>rfl</code>? Can you provide a MWE?</p>",
        "id": 484546117,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732636627
    },
    {
        "content": "<p>The usual way to fill in those \"not default but morally default\" arguments is to do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">sdiff_eq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">himp_eq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>What I understand from your message is that this doesn't work. I am surprised!</p>",
        "id": 484546393,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732636707
    },
    {
        "content": "<p>Not quite minimal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">SpecialFunctions</span><span class=\"bp\">.</span><span class=\"n\">Trigonometric</span><span class=\"bp\">.</span><span class=\"n\">Deriv</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">Calculus</span><span class=\"bp\">.</span><span class=\"n\">Deriv</span><span class=\"bp\">.</span><span class=\"n\">Prod</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">Calculus</span><span class=\"bp\">.</span><span class=\"n\">Deriv</span><span class=\"bp\">.</span><span class=\"n\">Pow</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">BigOperators</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"n\">Topology</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The goal of the following exercise is to prove that</span>\n<span class=\"cm\">the regular open sets in a topological space form a complete boolean algebra.</span>\n<span class=\"cm\">`U ⊔ V` is given by `interior (closure (U ∪ V))`.</span>\n<span class=\"cm\">`U ⊓ V` is given by `U ∩ V`. -/</span>\n\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"n\">isOpen</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsOpen</span><span class=\"w\"> </span><span class=\"n\">carrier</span>\n<span class=\"w\">  </span><span class=\"n\">regular'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">interior</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"n\">carrier</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">carrier</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> We write some lemmas so that we can easily reason about regular open sets. -/</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"bp\">.</span><span class=\"n\">carrier</span>\n<span class=\"w\">  </span><span class=\"n\">coe_injective'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">congr</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_def</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">regular</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">interior</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">regular'</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">carrier_eq_coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe_injective</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\"> First we want a complete lattice structure on the regular open sets.</span>\n<span class=\"cm\">We can obtain this from a so-called `GaloisCoinsertion` with the closed sets.</span>\n<span class=\"cm\">This is a pair of maps</span>\n<span class=\"cm\">* `l : RegularOpens X → Closeds X`</span>\n<span class=\"cm\">* `r : Closeds X → RegularOpens X`</span>\n<span class=\"cm\">with the properties that</span>\n<span class=\"cm\">* for any `U : RegularOpens X` and `C : Closeds X` we have `l U ≤ C ↔ U ≤ r U`</span>\n<span class=\"cm\">* `r ∘ l = id`</span>\n<span class=\"cm\">If you know category theory, this is an *adjunction* between orders</span>\n<span class=\"cm\">(or more precisely, a coreflection).</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The closure of a regular open set. Of course mathlib knows that the closure of a set is closed.</span>\n<span class=\"cm\">(the `simps` attribute will automatically generate the simp-lemma for you that</span>\n<span class=\"cm\">`(U.cl : Set X) = closure (U : Set X)`</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">cl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Closeds</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">isClosed_closure</span><span class=\"bp\">⟩</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The interior of a closed set. You will have to prove yourself that it is regular open. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">TopologicalSpace</span><span class=\"bp\">.</span><span class=\"n\">Closeds</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Closeds</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">interior</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"bp\">⟩</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Now let's show the relation between these two operations. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">cl_le_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Closeds</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">cl</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">cl_int</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">cl</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext1</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">regular</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> This gives us a GaloisCoinsertion. -/</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">gi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GaloisCoinsertion</span><span class=\"w\"> </span><span class=\"n\">cl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Closeds</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">gc</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cl_le_iff</span>\n<span class=\"w\">  </span><span class=\"n\">u_l_le</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">hC</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">int</span>\n<span class=\"w\">  </span><span class=\"n\">choice_eq</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">hC</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> It is now a general theorem that we can lift the complete lattice structure from `Closeds X`</span>\n<span class=\"cm\">to `RegularOpens X`. The lemmas below give the definitions of the lattice operations. -/</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">completeLattice</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompleteLattice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">GaloisCoinsertion</span><span class=\"bp\">.</span><span class=\"n\">liftCompleteLattice</span><span class=\"w\"> </span><span class=\"n\">gi</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">coe_inf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">cl</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">cl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">coe_sup</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">interior</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">cl</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">cl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">coe_top</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Closeds</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">coe_bot</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Closeds</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">coe_sInf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"n\">interior</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⋂₀</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cl</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">coe_sSup</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"n\">interior</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⋃₀</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cl</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> We still have to prove that this gives a distributive lattice.</span>\n<span class=\"cm\">Warning: these are hard. -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">completeDistribLattice</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompleteDistribLattice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">CompleteDistribLattice</span><span class=\"bp\">.</span><span class=\"n\">ofMinimalAxioms</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">completeLattice</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"n\">inf_sSup_le_iSup_inf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"n\">iInf_sup_le_sup_sInf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- this now creates diamonds</span>\n<span class=\"c1\">-- instance : HasCompl (RegularOpens X) where</span>\n<span class=\"c1\">--   compl U := Closeds.int ⟨(U : Set X)ᶜ, U.isOpen.isClosed_compl⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">coe_compl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">U</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">interior</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- I guess I have to prove this now</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompleteBooleanAlgebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">__</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CompleteDistribLattice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"c1\">-- { inferInstanceAs (CompleteDistribLattice (RegularOpens X)) with</span>\n<span class=\"w\">  </span><span class=\"n\">inf_compl_le_bot</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">top_le_sup_compl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">U</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_def</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ_subset_iff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">ᶜ</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">gcongr</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">subset_closure</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">le_sup_inf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact?</span>\n<span class=\"w\">  </span><span class=\"n\">sdiff_eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- error</span>\n<span class=\"w\">  </span><span class=\"n\">himp_eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- error</span>\n</code></pre></div>",
        "id": 484546896,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1732636843
    },
    {
        "content": "<p>That is unexpected <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span> I have a hunch that this is coming from a Lean change to how metavariables in <code>where</code>/<code>{}</code> notation are handled. Could you bisect on the Lean version?</p>",
        "id": 484548256,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732637236
    },
    {
        "content": "<p>(I would offer to do it but my wrist is still painful and I need to prepare two talks...)</p>",
        "id": 484548330,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732637262
    },
    {
        "content": "<p>I am unable to do that myself.</p>",
        "id": 484549282,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1732637536
    },
    {
        "content": "<p>So what is the intended way to give a complete Boolean algebra from a complete lattice? I want to prove <br>\n<code>inf_sSup_le_iSup_inf</code>/<code>iInf_sup_le_sup_sInf</code>/<code>inf_compl_le_bot</code>/<code>top_le_sup_compl</code> and nothing else.</p>",
        "id": 484550967,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1732638070
    },
    {
        "content": "<p>Note that my example above does not do this, because it also requires me to show that an inconveniently defined complement is equal to my complement. I want to provide the complement myself.</p>",
        "id": 484551382,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1732638203
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/CompleteBooleanAlgebra.20from.20CompleteDistribLattice/near/484548256\">said</a>:</p>\n<blockquote>\n<p>That is unexpected <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span> I have a hunch that this is coming from a Lean change to how metavariables in <code>where</code>/<code>{}</code> notation are handled. Could you bisect on the Lean version?</p>\n</blockquote>\n<p>Why do you even expect <code>himp_eq</code> to be <code>rfl</code> when it's defined by <a href=\"https://github.com/leanprover-community/mathlib4/blob/e6b14d47d78f3846fbf3c5d50bb1eccd71abc6e5/Mathlib/Order/CompleteBooleanAlgebra.lean#L159C3-L159C35\">this line</a>?</p>",
        "id": 484556901,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1732639961
    },
    {
        "content": "<p><del>Ah wait, you are using <code>ofMinimalAxioms</code>!</del></p>",
        "id": 484557082,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732640032
    },
    {
        "content": "<p><del>Sorry, I had completely missed that somehow. If you want to define your own <code>compl</code>, you shouldn't use it</del></p>",
        "id": 484557195,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732640055
    },
    {
        "content": "<p>I am more and more confused. I now think this doesn't anything have to do with my refactor, except for the fact that it incidentally reordered some parents in the order hierarchy</p>",
        "id": 484559890,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732640909
    },
    {
        "content": "<p>I think if you actually read my questions, that I nowhere have a problem that could be caused by reordering parents, and I do have problems with</p>\n<ul>\n<li><code>CompleteDistribLattice</code> counterintuitively providing a <code>HasCompl</code> instance</li>\n<li>If I want to define a <code>CompleteDistribLattice</code> with my own <code>HasCompl</code> instance, I have to prove things that I don't want to prove.</li>\n</ul>",
        "id": 484608290,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1732660814
    },
    {
        "content": "<p>I guess I can do what I want mostly by just ignoring <code>CompleteDistribLattice</code>. Do you agree that we should add the following to Mathlib, to conveniently allow what I want?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">CompleteBooleanAlgebra</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">CompleteBooleanAlgebra</span><span class=\"bp\">.</span><span class=\"n\">MinimalAxioms</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n<span class=\"w\">    </span><span class=\"n\">CompleteDistribLattice</span><span class=\"bp\">.</span><span class=\"n\">MinimalAxioms</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">HasCompl</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">inf_compl_le_bot</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">⊥</span>\n<span class=\"w\">  </span><span class=\"n\">top_le_sup_compl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">ᶜ</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">CompleteBooleanAlgebra</span><span class=\"bp\">.</span><span class=\"n\">ofMinimalAxioms</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompleteBooleanAlgebra</span><span class=\"bp\">.</span><span class=\"n\">MinimalAxioms</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompleteBooleanAlgebra</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">      </span><span class=\"bp\">__</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"n\">le_sup_inf</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CompleteDistribLattice</span><span class=\"bp\">.</span><span class=\"n\">ofMinimalAxioms</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">toMinimalAxioms</span>\n<span class=\"w\">        </span><span class=\"n\">le_sup_inf</span>\n</code></pre></div>",
        "id": 484608432,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1732660894
    },
    {
        "content": "<p>The issue here is:</p>\n<blockquote>\n<p>This sets <code>a ⇨ b := sSup {c | c ⊓ a ≤ b}</code>, <code>aᶜ := a ⇨ ⊥</code>, <code>a \\ b := sInf {c | a ≤ b ⊔ c}</code> and<br>\n<code>￢a := ⊤ \\ a</code>. -/</p>\n</blockquote>\n<p>in the docs for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompleteDistribLattice.ofMinimalAxioms#doc\">docs#CompleteDistribLattice.ofMinimalAxioms</a></p>",
        "id": 484628195,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732673905
    },
    {
        "content": "<p>Generally, the <code>ofMinimalAxioms</code> constructors pick bad defeqs that probably don't compose very well across \"joins\" in the hierarchy</p>",
        "id": 484628313,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732673999
    },
    {
        "content": "<p>I think in particular the axioms are <em>too</em> minimal for your use-case, since you wanted to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasCompl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RegularOpens</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>",
        "id": 484628583,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732674182
    }
]