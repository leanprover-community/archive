[
    {
        "content": "<p>The product of two functions can be written as <code>f * g</code> or <code>fun x ‚Ü¶ f x * g x</code>. These are defeqs, but syntactically different, so <code>rw</code> with a lemma formulated using the first form will not apply for the second form, and conversely. The first form is nicer to read and to write, but often one ends up with the second one, so both have their advantages. In some parts of the library, a \"solution\" to this has been to write two forms for each lemma, one with <code>f * g</code> and one with <code>fun x ‚Ü¶ f x * g x</code> (one of them being primed). This works pretty well, but leads to a lot of code duplication. Should we go on with the duplication, or settle on one form? (For instance, in probability theory, the product of two random variables <code>X</code> and <code>Y</code> will almost always be written in the first form <code>X * Y</code>).</p>\n<p>This came up in the review of <a href=\"https://github.com/leanprover-community/mathlib4/pull/21502\">#21502</a>.</p>",
        "id": 501264041,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740229943
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/22183\">#22183</a> ran into this issue as well</p>",
        "id": 501275384,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1740237136
    },
    {
        "content": "<p>Does the same issue arise for sums, differences, powers?</p>",
        "id": 501290649,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1740249142
    },
    {
        "content": "<p>For n-ary sums, the two are not defeq, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Pi.sum_def#doc\">docs#Pi.sum_def</a> <del>can translate</del> doesn't exist</p>",
        "id": 501290813,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740249287
    },
    {
        "content": "<p>ideally, i think, we'd like simp normal form to reflect the right form for this, right?</p>",
        "id": 501291386,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740249799
    },
    {
        "content": "<p>is there an issue with making the reverse of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Pi.mul_def#doc\">docs#Pi.mul_def</a> a <code>simp</code> lemma?</p>",
        "id": 501291493,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740249857
    },
    {
        "content": "<p>Would simp need to try that on every function it encounters?</p>",
        "id": 501291696,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1740249984
    },
    {
        "content": "<p>i don't know, that's why i'm asking <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 501293293,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740251404
    },
    {
        "content": "<p>Yes, because <code>#discr_tree_key</code> prints <code>*</code></p>",
        "id": 501293807,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740251853
    },
    {
        "content": "<p>Unless <span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span>'s discrtree rewrite is upstreamed, or we override <code>simp</code> in mathlib to use the downstream version</p>",
        "id": 501293878,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740251896
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> As the author of <a href=\"https://github.com/leanprover-community/mathlib4/pull/21502\">#21502</a>, thanks for bringing this up here.</p>",
        "id": 501346353,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1740294453
    },
    {
        "content": "<p>From a user's perspective, I believe that mathlib should support both <code>f * g</code> and <code>fun x ‚Ü¶ f x * g x</code>. Both version have their use cases. If I had to choose, I would definitively take <code>f * g</code>, for the following reasons:</p>\n<ul>\n<li>The notation <code>fun x ‚Ü¶ f x * g x</code> has a tendency to exponentially grow -- think <code>fun y ‚Ü¶ f y * (fun x ‚Ü¶ g x * h x) y</code>. </li>\n<li>In my (limited) experience, the simlifier is not nearly as good with complicated expressions of the form <code>fun y ‚Ü¶ f y * (fun x ‚Ü¶ g x * h x) y</code> as it is when treating functions as ring elements. When simplifying with messy computations, I started to constantly formulate (and apply) trivial lemmas (have : something = something else := by rfl; rw [this]; clear this), which quickly became quite painful.</li>\n</ul>",
        "id": 501347291,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1740295331
    },
    {
        "content": "<p>From a contributor's perspective, I prefer the solution formulating relevant lemmas twice [unless some form of automatization exists], which reduces complexity and improves readability of my code at the expense of duplicating lemmas. On the other side, I do understand the concerns (\"combinatorial explosion\").</p>\n<p>Personally, I could live with any decision, even if not my preferred one. However, I do feel strongly that <strong>we should have a policy</strong> here. As a newcomer, I found that mathlib is rather inconsistent in this respect and I have received conflicting advice how to proceed, which is of course a bit frustrating.</p>",
        "id": 501348135,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1740296198
    },
    {
        "content": "<p>[off-topic: Re: <code>have : X=Y := by rfl, rw [this], clear this</code>: you might like the <code>change</code> tactic (although this approach can get very verbose). ]</p>",
        "id": 501354389,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740302125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/501354389\">said</a>:</p>\n<blockquote>\n<p>[off-topic: Re: <code>have : X=Y := by rfl, rw [this], clear this</code>: you might like the <code>change</code> tactic (although this approach can get very verbose). ]</p>\n</blockquote>\n<p>The combo <code>conv</code> + <code>change</code> can make it a bit less verbose</p>",
        "id": 501354946,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1740302552
    },
    {
        "content": "<p>also, possibly <code>rw [show X=Y from rfl]</code></p>",
        "id": 501354978,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740302586
    },
    {
        "content": "<p>a hack i've heard about is <code>rw [(id rfl : X=Y)]</code></p>",
        "id": 501355018,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740302637
    },
    {
        "content": "<p>With <code>rw</code> working how it does right now, I think we can't avoid having the form <code>fun x ‚Ü¶ f x * g x</code>, since that's the way that multiplication appears most when inside more complicated expressions (and it's also the better form for tactics like <code>fun_prop</code>). So if we also want the <code>f * g</code> version because it's nicer in some contexts, we just need both.<br>\nA related issue is that Mathlib is inconsistent on which of the two lemmas should be primed.</p>",
        "id": 501356830,
        "sender_full_name": "R√©my Degenne",
        "timestamp": 1740304370
    },
    {
        "content": "<p>So could the convention be: there should always be the version with <code>fun x ‚Ü¶ f x * g x</code>, this is the main version, and it is without prime. And the PR author may add a primed version for <code>f * g</code>, but this is not mandatory.</p>",
        "id": 501359225,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740305477
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <span class=\"user-mention\" data-user-id=\"703970\">@Etienne Marion</span> <span class=\"user-mention\" data-user-id=\"350992\">@R√©my Degenne</span>  Thanks for the off-topic hints. I was not aware of these tricks.</p>",
        "id": 501359924,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1740305647
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"679664\">@Stefan Kebekus</span> , could you adapt <a href=\"https://github.com/leanprover-community/mathlib4/pull/21502\">#21502</a> to this convention? It means the primed and unprimed versions should be swapped.</p>",
        "id": 501366377,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740310019
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> Will do, tomorrow morning at the latest. [Update 25Feb25, 10:00: Done]</p>",
        "id": 501366418,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1740310064
    },
    {
        "content": "<p>I'm not super happy with this convention since it makes it sound like <code>f * g</code> is a second class citizen</p>",
        "id": 501366500,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1740310121
    },
    {
        "content": "<p>Should our naming convention allocate a token to <code>fun x =&gt;</code>, so as to avoid primes?</p>",
        "id": 501369757,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740312956
    },
    {
        "content": "<p>That was my back-of-the-mind thought, yes</p>",
        "id": 501371116,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1740314242
    },
    {
        "content": "<p>so then <code>fun x ‚Ü¶ f x * g x</code> would be something like <code>fun_apply_mul_apply</code>? i'm not sure that's better, tbh</p>",
        "id": 501371535,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740314646
    },
    {
        "content": "<p>Let's take a concrete example. In the lemmas</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">applied_form</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AnalyticWithinAt</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">AnalyticWithinAt</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">z</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">unapplied_form</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AnalyticWithinAt</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">AnalyticWithinAt</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">z</span>\n</code></pre></div>\n<p>how would you name them? The proposal above is <code>applied_form = AnalyticWithinAt.pow</code> and <code>unapplied_form = AnalyticWithinAt.pow'</code>. I can start a poll once people give me some propositions. Since it seems most people agree that the normal form should be the applied one, I'd keep the shortest <code>AnalyticWithinAt.pow</code> for the applied form, but I'm all ears for other propositions.</p>",
        "id": 501372301,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740315291
    },
    {
        "content": "<p>Some existing precedent: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sum_add_distrib#doc\">docs#Finset.sum_add_distrib</a> is stated as <code>(s.sum fun x =&gt; f x + g x) = (s.sum fun x =&gt; f x) + (s.sum fun x =&gt; g x)</code> not <code>s.sum (f + g) = s.sum f + s.sum g</code>.</p>",
        "id": 501374347,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740317016
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/501354389\">said</a>:</p>\n<blockquote>\n<p>[off-topic: Re: <code>have : X=Y := by rfl, rw [this], clear this</code>: you might like the <code>change</code> tactic (although this approach can get very verbose). ]</p>\n</blockquote>\n<p>It's said that there is a syntax <code>change X with Y</code> and <code>change X with Y at h</code></p>",
        "id": 501380922,
        "sender_full_name": "Jz Pan",
        "timestamp": 1740321548
    },
    {
        "content": "<p>Another off-topic question: Do I need to <code>open scoped Pointwise</code> to use the notation <code>f * g</code>?</p>",
        "id": 501380953,
        "sender_full_name": "Jz Pan",
        "timestamp": 1740321581
    },
    {
        "content": "<p>Another off-topic question: Do I need to <code>open scoped Pointwise</code> to use the notation <code>f * g</code>?</p>",
        "id": 501380964,
        "sender_full_name": "Jz Pan",
        "timestamp": 1740321593
    },
    {
        "content": "<p>No, <code>open scoped Pointwise</code> is only needed for pointwise operators on <code>Set</code>s and related objects</p>",
        "id": 501381183,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740321744
    },
    {
        "content": "<p>From the perspective of <code>fun_prop</code>:</p>\n<ol>\n<li>stating a theorem as <code>Continuous fun x =&gt; f x * g x</code> talks about continuity of <code>*</code> in the first and the second argument</li>\n<li>stating a theorem as <code>Continuous (f * g)</code> talks about continuity of <code>*</code> in the third argument</li>\n</ol>\n<p>In a way they are just different theorems. Of course <code>fun_prop</code> could do some reduction a exploit the fact that <code>fun x =&gt; f x * g x</code> and <code>f * g</code> are defeq but currently this is not happening.</p>\n<p>The proper way of formulating continuity of multiplication in all three arguments for <code>fun_prop</code> is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">fun_prop</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">continuous_mul'''</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ContinuousMul</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"bp\">‚Üø</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"bp\">‚Üø</span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span>\n\n<span class=\"c1\">-- now these work</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span>\n</code></pre></div>\n<p>The current approach of <code>fun_prop</code> does not scale to arbitrary arity of <code>*</code> i.e. you need a separate theorem for every possible arity.</p>",
        "id": 501404623,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1740340042
    },
    {
        "content": "<p>On the other hand this approach works even in cases where <code>fun x =&gt; f x * g x</code> is not defeq <code>f * g</code>.  Which is in some sense true for <code>Polynomial</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- fail</span>\n</code></pre></div>\n<p>In case we would have <code>CoeFun (Polynomial ‚Ñù) (fun _ =&gt; ‚Ñù ‚Üí ‚Ñù)</code> this would result in a confusing fact that  <code>f * g</code> is not defeq to  <code>fun x =&gt; f x * g x</code>.</p>",
        "id": 501405056,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1740340382
    },
    {
        "content": "<p>I haven't got any other suggestions. Still, here is a poll. In the lemmas</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">applied_form</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AnalyticWithinAt</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">AnalyticWithinAt</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">z</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">unapplied_form</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AnalyticWithinAt</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">AnalyticWithinAt</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">z</span>\n</code></pre></div>\n<p>how should we call the first lemma and the second lemma?</p>",
        "id": 501467331,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740382982
    },
    {
        "content": "<p>/poll <br>\n<code>AnalyticWithinAt.pow</code> and <code>AnalyticWithinAt.pow'</code><br>\n<code>AnalyticWithinAt.pow</code> and <code>AnalyticWithinAt.pow_unapplied</code><br>\n<code>AnalyticWithinAt.pow'</code> and <code>AnalyticWithinAt.pow</code><br>\n<code>AnalyticWithinAt.pow_applied</code> and <code>AnalyticWithinAt.pow</code><br>\n<code>AnalyticWithinAt.pow_applied</code> and <code>AnalyticWithinAt.pow_unapplied</code><br>\nOther suggestions</p>",
        "id": 501467654,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740383088
    },
    {
        "content": "<p>There seems to be a consensus for \"no prime for the applied version, prime the unapplied version if needed\". I am therefore planning to add the following paragraph to the naming conventions. Comments and improvements welcome!</p>\n<h3>Applied and unapplied forms of functions</h3>\n<p>The product of two functions <code>f</code> and <code>g</code> can be denoted equivalently as <br>\n<code>fun x ‚Ü¶ f x * g x</code> or <code>f * g</code>. These expressions are definitionally equal, but not syntactically, which<br>\nmeans that <code>rw</code> will not apply to one of them a theorem given with the other form. Therefore, it is<br>\nsometimes convenient to have variants of the statements using the two forms. The main form should always<br>\nbe in terms of the applied version <code>fun x ‚Ü¶ f x * g x</code>. <br>\nThe other form can be given postfixing the name of the theorem with a prime. <br>\nFor instance, the fact that the product of two continuous functions is continuous is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"bp\">.</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>and one may also have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"bp\">.</span><span class=\"n\">mul'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The same goes for addition, subtraction, negation and powers of functions.</p>",
        "id": 501733139,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740469851
    },
    {
        "content": "<p>I think probably \"eta-expanded\" is more accurate than \"applied\"</p>",
        "id": 501743387,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740473517
    },
    {
        "content": "<p>Yes, <code>mul_eta</code> and <code>mul</code> seems like a good naming pair</p>",
        "id": 501755675,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1740477356
    },
    {
        "content": "<p>S√©bastien, note that mobile Zulip users can't add options to polls, and I happen to have forcedly been a mobile Zulip user for the past five days</p>",
        "id": 501755919,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1740477426
    },
    {
        "content": "<p>It it not <em>just</em> eta expansion! Eta expansion of <code>f * g</code> is <code>fun x =&gt; (f * g) x</code> which reduces to <code>fun x =&gt; f x * g x</code> with <code>dsimp</code> lemma <code>Pi.mul_apply</code>. This makes a big difference when writing a tactic that has to deal with this.</p>",
        "id": 501768251,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1740480740
    },
    {
        "content": "<p>I am also not to thrilled to see <code>eta</code> appearing in user-facing names...</p>",
        "id": 501772765,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740481567
    },
    {
        "content": "<p>I wasn't suggesting it should appear in the name, merely that it should appear in the docs; I would argue that the description of the one we are assigning the unprimed name here is \"use the eta expanded spelling\" combined with \"use the simp-normal form\"</p>",
        "id": 501774115,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740481860
    },
    {
        "content": "<p>My comment was addressing Ya√´l's:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/501755675\">said</a>:</p>\n<blockquote>\n<p>Yes, <code>mul_eta</code> and <code>mul</code> seems like a good naming pair</p>\n</blockquote>",
        "id": 501774406,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1740481917
    },
    {
        "content": "<p>If we don't use <code>*</code> notation. The expression <code>fun x =&gt; HMul.hMul f g x</code>(eta expanded <code>f*g</code>) is actually more similar(from lambda calculus perspective) to <code>fun x =&gt; HMul.hMul c x</code>(e.g. <code>continuous_mul_left</code>) or <code>fun x =&gt; HMul.hMul x c</code>(e.g. <code>continuous_mul_right</code>) rather than <code>fun x =&gt; HMul.hMul (f x) (g x)</code> (e.g. <code>Continuous.mul</code>)</p>",
        "id": 501775242,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1740482067
    },
    {
        "content": "<p>I'm not thrilled putting a naming convention with primes being formalized in our conventions, and would prefer something like <code>AnalyticWithinAt.pow_unapplied</code>, except that <code>_unapplied</code> is too long. Maybe <code>AnalyticWithinAt.powFun</code> or <code>AnalyticWithinAt.powPi</code> for the <code>f ^ n</code> version? (since it's the power operation on functions or on the Pi-type.)</p>",
        "id": 501782790,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1740483789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/501755919\">said</a>:</p>\n<blockquote>\n<p>S√©bastien, note that mobile Zulip users can't add options to polls, and I happen to have forcedly been a mobile Zulip user for the past five days</p>\n</blockquote>\n<p>If you tell me an option you want me to add, I can do it myself!</p>",
        "id": 501782848,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740483814
    },
    {
        "content": "<p>The relevant rewrite lemma showing the equvalence of the two forms is <code>Pi.mul_def</code>. So a name with <code>mulPi</code>, <code>mul_pi</code> or <code>mul_Pi</code> in the place of <code>mul</code> seems reasonable for the version that multiplies the Œ† types.</p>",
        "id": 501784177,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740484238
    },
    {
        "content": "<p>Ok, let me run a new poll with these propositions (and discarding all those that got 0 in the first poll). In the lemmas</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">applied</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">unapplied</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>how should the lemmas be named?</p>",
        "id": 501786321,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740484740
    },
    {
        "content": "<p>/poll<br>\n<code>Continuous.mul</code> and <code>Continuous.mul'</code><br>\n<code>Continuous.mul</code> and <code>Continuous.mul_pi</code><br>\n<code>Continuous.mul</code> and <code>Continuous.mul_unapplied</code><br>\n<code>Continuous.mul</code> and <code>Continuous.mulPi</code><br>\nOther propositions</p>",
        "id": 501786647,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740484801
    },
    {
        "content": "<p>Wait, maybe we can't add options to polls anymore at all?</p>",
        "id": 501787987,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1740485033
    },
    {
        "content": "<p>What would be the option you would like to add?</p>",
        "id": 501790573,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740485678
    },
    {
        "content": "<p>In terms of pi vs Pi capitalization, I presume <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=small_Pi#doc\">docs#small_Pi</a> is wrong and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=deriv_pi#doc\">docs#deriv_pi</a> correct?</p>",
        "id": 501791159,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740485799
    },
    {
        "content": "<p><code>mul_eta</code>/<code>mul</code></p>",
        "id": 501791187,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1740485804
    },
    {
        "content": "<p>Yes, I can't add another option to the poll. Let me do it below.</p>",
        "id": 501799925,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740488296
    },
    {
        "content": "<p>/poll <br>\n<code>Continuous.mul_eta</code> and <code>Continuous.mul</code></p>",
        "id": 501800002,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740488321
    },
    {
        "content": "<p>The winner of the poll is <code>Continuous.mul</code> and <code>Continuous.mul_pi</code>.</p>",
        "id": 502060938,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740580262
    },
    {
        "content": "<p>Here is the text I will soon add to the naming convention. Comments welcome, again!</p>\n<h3>Expanded and unexpanded forms of functions</h3>\n<p>The product of two functions <code>f</code> and <code>g</code> can be denoted equivalently as <br>\n<code>fun x ‚Ü¶ f x * g x</code> or <code>f * g</code>. These expressions are definitionally equal, but not syntactically, which<br>\nmeans that <code>rw</code> will not apply to one of them a theorem given with the other form. Therefore, it is<br>\nsometimes convenient to have variants of the statements using the two forms. The main form should always<br>\nbe in terms of the expanded version <code>fun x ‚Ü¶ f x * g x</code>. <br>\nThe other form can be given postfixing the name of the theorem with <code>_pi</code>, as it corresponds to using<br>\nthe operation defined on the <code>Pi</code> type instead of the pointwise operation.<br>\nFor instance, the fact that the product of two continuous functions is continuous is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"bp\">.</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>and one may also have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"bp\">.</span><span class=\"n\">mul_pi</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The same goes for addition, subtraction, negation and powers of functions.</p>",
        "id": 502061529,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740580402
    },
    {
        "content": "<p>What about composition? I.e., <code>g ‚àò f</code> versus <code>fun x ‚Ü¶ g (f x)</code>? I realize this isn't a <code>pi</code> issue, but we do have both versions running around in various places, e.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Continuous.comp#doc\">docs#Continuous.comp</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Continuous.comp%27#doc\">docs#Continuous.comp'</a>.</p>",
        "id": 502098216,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1740589294
    },
    {
        "content": "<p>I think we really need to make the point-free version the default, and add a token that says \"eta-expand, run dsimp\"</p>",
        "id": 502099685,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1740589684
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span>, are you saying that for <code>f * g</code> or for <code>g ‚àò f</code>?</p>",
        "id": 502100493,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740589922
    },
    {
        "content": "<p>Both</p>",
        "id": 502100576,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1740589935
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/502099685\">said</a>:</p>\n<blockquote>\n<p>I think we really need to make the point-free version the default, and add a token that says \"eta-expand, run dsimp\"</p>\n</blockquote>\n<p>Can you explain why you want the point free example as default?</p>\n<p>Here is a (not super important) case why I like the expanded version better: If I have <code>\\all x, f x = f2 x</code> then this is much easier to apply to <code>fun x =&gt; f x * g x</code> than to <code>f * g</code>.</p>",
        "id": 502172256,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1740616820
    },
    {
        "content": "<p>Somewhat related: it would be nice to have a tactic that eta-expands all partially applied functions in your goal (or a hypothesis). Maybe this already exists?</p>",
        "id": 502172317,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1740616863
    },
    {
        "content": "<p>Besides the <code>f + g</code> vs <code>fun x =&gt; f x + g x</code> debate, there is also the <code>f x + g x</code> vs <code>(f + g) x</code> debate, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.integral_integral_add#doc\">docs#MeasureTheory.integral_integral_add</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.integral_integral_add%27#doc\">docs#MeasureTheory.integral_integral_add'</a>. What is the plan with naming these?</p>",
        "id": 502172529,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740616967
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/502172317\">said</a>:</p>\n<blockquote>\n<p>Somewhat related: it would be nice to have a tactic that eta-expands all partially applied functions in your goal (or a hypothesis). Maybe this already exists?</p>\n</blockquote>\n<p>It turns out there is an <code>eta_expand</code> tactic <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>\n<p><del>Edit: looking at the implementation, it seems to not work perfectly, and only eta expand terms that are applications. So a free variable <code>(f : a -&gt; b)</code> will not get expanded to <code>fun x =&gt; f x</code> <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></del></p>",
        "id": 502172618,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740617025
    },
    {
        "content": "<p>I would like to make a comment on the <code>mul_pi</code> name: are we really certain that we want to call <code>(¬∑ * ¬∑)</code> for functions <code>mul_pi</code>? <br>\nI am very strongly in favor of the Lean 4 convention where 1 operation has no underscores in it, and different operators names in a lemma name are separated by an underscore. The current suggestion is like calling <code>(¬∑ + ¬∑)</code> on the natural numbers <code>add_nat</code>... And we decided a while ago that operations like <code>Nat.cast</code> should be named <code>natCast</code> in lemmas (when <code>cast</code> itself is ambiguous). This suggest <code>piMul</code>, which would also be fine by me.<br>\n(sorry for the bikeshedding)</p>",
        "id": 502172925,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1740617193
    },
    {
        "content": "<p>BTW, the location of <code>'</code> on <code>prod</code> lemmas is inconsistent too (encountered while working on <a href=\"https://github.com/leanprover-community/mathlib4/pull/22195\">#22195</a>, not fixing in that PR).</p>",
        "id": 502173167,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1740617345
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/502172529\">said</a>:</p>\n<blockquote>\n<p>Besides the <code>f + g</code> vs <code>fun x =&gt; f x + g x</code> debate, there is also the <code>f x + g x</code> vs <code>(f + g) x</code> debate, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.integral_integral_add#doc\">docs#MeasureTheory.integral_integral_add</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.integral_integral_add%27#doc\">docs#MeasureTheory.integral_integral_add'</a>. What is the plan with naming these?</p>\n</blockquote>\n<p>I would name <code>(f + g) x</code> the same way as what we decide for <code>f + g</code>. For integrals we just never write the eta-reduced form because of the notation, and <code>fun x =&gt; (f + g) x</code> is the same as <code>f + g</code>, without any unfolding.</p>",
        "id": 502173308,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1740617427
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/502172618\">said</a>:</p>\n<blockquote>\n<p>It turns out there is an <code>eta_expand</code> tactic <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>\n<p>Edit: looking at the implementation, it seems to not work perfectly, and only eta expand terms that are applications. So a free variable <code>(f : a -&gt; b)</code> will not get expanded to <code>fun x =&gt; f x</code> <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>\n</blockquote>\n<p>This is not entirely right, since at least the following example works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Common</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">eta_expand</span>\n<span class=\"w\">  </span><span class=\"n\">guard_target</span><span class=\"w\"> </span><span class=\"bp\">=‚Çõ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 502173659,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1740617636
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>, I think the question here is whether <code>(¬∑ * ¬∑)</code> for functions should be thought of as a separate operation to <code>mul</code>, or whether the <code>pi</code> is describing the arguments of <code>mul</code>.</p>\n<p>e.g. <code>mul_one</code> multiplies a <code>one</code>, and <code>mul_pi</code> multiplies two <code>pi</code>s.</p>",
        "id": 502174638,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740618136
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/502172256\">said</a>:</p>\n<blockquote>\n<p>Here is a (not super important) case why I like the expanded version better: If I have <code>\\all x, f x = f2 x</code> then this is much easier to apply to <code>fun x =&gt; f x * g x</code> than to <code>f * g</code>.</p>\n</blockquote>\n<p>Perhaps that hypothesis would be better phrased point free / un<code>funext</code> as well, as <code>f = f2</code>.</p>",
        "id": 502178433,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1740620271
    },
    {
        "content": "<p>But in general, I agree that overall in the library, the prevalence of syntactic rewriting tools leads away from using things like partial applications via \\. .</p>",
        "id": 502178581,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1740620373
    },
    {
        "content": "<p>As Jovan says, in my mind <code>mul_pi</code> means that it's a <code>mul</code> (which refers to the symbol <code>*</code>), and it's on <code>Pi</code> objects (which refers to <code>f</code> and <code>g</code>), so that's why it has an underscore.</p>",
        "id": 502214358,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740642015
    },
    {
        "content": "<p>For composition, just for coherence I'd go for <code>comp</code> and <code>comp_pi</code> (although the argument is less compelling there)</p>",
        "id": 502214445,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740642059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/502214358\">said</a>:</p>\n<blockquote>\n<p>As Jovan says, in my mind <code>mul_pi</code> means that it's a <code>mul</code> (which refers to the symbol <code>*</code>), and it's on <code>Pi</code> objects (which refers to <code>f</code> and <code>g</code>), so that's why it has an underscore.</p>\n</blockquote>\n<p>So now if you see <code>x * y</code> in a lemma you need to know whether <code>x</code> and <code>y</code> are functions and not</p>",
        "id": 502327843,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1740673918
    },
    {
        "content": "<p>I'm not sure what you mean. If you see <code>Continuous (f * g)</code>, it's obviously for functions, and then you use <code>Continuous.mul_pi</code>. Do you have a relevant example in mind where you think it could create confusion?</p>",
        "id": 502333464,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740675383
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/502099685\">said</a>:</p>\n<blockquote>\n<p>I think we really need to make the point-free version the default, and add a token that says \"eta-expand, run dsimp\"</p>\n</blockquote>\n<p>By \"default\", I interpret this to mean \"the one that gets the name <code>mul</code>\". I completely agree with Ya√´l here, and I think this is the key:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/502327843\">said</a>:</p>\n<blockquote>\n<p>So now if you see <code>x * y</code> in a lemma you need to know whether <code>x</code> and <code>y</code> are functions and not</p>\n</blockquote>\n<p>I think we do need another token for the eta-expanded, dsimp'ed version. <code>pi</code> was reasonable idea except that it doesn't fit <code>fun x ‚Ü¶ g (f x))</code> at all.</p>",
        "id": 502363245,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1740685094
    },
    {
        "content": "<p>The thing is that the expanded version is the one that is useful most of the time, so that's the one that should get the shortest name. The poll above shows that most people support this. Note that a typical function looks like <code>fun x ‚Ü¶ x * exp (- x^2 / 2)</code>, which is quite painful to write in a point-free way, so I don't think switching by default to the point-free version is a sensible move.</p>",
        "id": 502364067,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740685382
    },
    {
        "content": "<p>But because there is literally no other syntax in the unapplied form, it both:</p>\n<ol>\n<li>forces us to use different conventions for <code>x * y</code> depending on whether these are functions or not (which is tremendously counterintuitive and I think will lead to much frustration for both reviewers and contributors)</li>\n<li>makes it hard to come up with a good name for the unapplied version because there is no token for syntax that isn't present!</li>\n</ol>\n<p>I think if we come up with a short enough token for the applied form it wouldn't be problematic. </p>\n<p>Also, it's not entirely clear to me that the expanded for is always most useful, although in certain areas of the library that's definitely the case (e.g., integration). I do wonder if the original poll would reach the same consensus given these more recent comments, but I won't push for it unless someone other than Ya√´l or I agrees.</p>",
        "id": 502366343,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1740686222
    },
    {
        "content": "<p>I would suggest simply:</p>\n<ol>\n<li><code>fn_mul</code> for <code>fun x ‚Ü¶ f x * g x</code></li>\n<li><code>mul</code> for <code>f * g</code>.</li>\n</ol>",
        "id": 502366712,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1740686368
    },
    {
        "content": "<p>I have no strong opinion, but I agree that this option needs to be considered as it's the one that matches best with what we actually write</p>",
        "id": 502367271,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1740686563
    },
    {
        "content": "<p>Thank you Jireh for articulating my thoughts so well <span aria-label=\"folded hands\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"folded hands\">:folded_hands:</span></p>",
        "id": 502368512,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1740687025
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> , do you think could you run another poll, keeping the options in the previous one that had some support, and explaining the new option and why you think it's better? Hopefully this will help everyone choose an option having all the information in mind.</p>",
        "id": 502368804,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740687132
    },
    {
        "content": "<p>I suggest a different naming convention:</p>\n<ol>\n<li><code>fn_mul</code>¬†for¬†<code>fun x ‚Ü¶ f x * g x</code> (hereafter referred to as <em>applied</em>)</li>\n<li><code>mul</code>¬†for¬†<code>f * g</code> (hereafter referred to as <em>unapplied</em>)</li>\n</ol>\n<p>A <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/501467331\">previous poll</a> had concluded that the \"default\" version (i.e., unprimed / shorter name) should be the applied one because it is used more often. A <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/501786647\">later poll</a> determined that the names for these should be <code>mul</code> (applied) and <code>mul_pi</code> (unapplied).</p>\n<p>However, since that poll there has since been more discussion about some downsides of these choices. In particular, because there is literally no other syntax besides <code>*</code> in the unapplied form:</p>\n<ol>\n<li>it forces us to use different conventions for¬†<code>f * g</code>¬†depending on whether these are functions or not (which is counterintuitive and I think will lead to much frustration for both reviewers and contributors)</li>\n<li>it makes it hard to come up with a good name for the unapplied version because there is no token for syntax that isn't present!</li>\n<li>related to (2), the <code>pi</code> naming convention doesn't accommodate things like <code>fun x ‚Ü¶ g (f x)</code> vs. <code>g ‚àò f</code>.</li>\n</ol>\n<p>My suggested convention (<code>fn_mul</code> for applied, <code>mul</code> for unapplied), has some benefits:</p>\n<ol>\n<li>matches the visible syntax reasonably well</li>\n<li>is relatively short for both applied and unapplied versions</li>\n<li>extends to other settings like <code>‚àò</code> (or even <code>id</code> for <code>id</code> vs. <code>fn_self</code> or <code>fn_id</code> for <code>fun x ‚Ü¶ x</code>)</li>\n<li>doesn't fracture the naming conventions for <code>*</code> based on whether or not the arguments are functions</li>\n</ol>\n<p>So let's run another poll:</p>",
        "id": 502460571,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1740698822
    },
    {
        "content": "<p>/poll What should the naming conventions be (applied and unapplied)<br>\n<code>Continuous.mul</code> and <code>Continuous.mul'</code><br>\n<code>Continuous.mul</code> and <code>Continuous.mul_pi</code><br>\n<code>Continuous.mul</code> and <code>Continuous.mulPi</code><br>\n<code>Continuous.fn_mul</code> and <code>Continuous.mul</code></p>",
        "id": 502460714,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1740698902
    },
    {
        "content": "<p>I added an option, because I'm not sure why we would (confusingly?) refer to the <code>fun</code> token as <code>fn</code>.</p>",
        "id": 502467641,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1740702796
    },
    {
        "content": "<p>Although there appears to be precedent, which may be enough to settle that.</p>",
        "id": 502467679,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1740702823
    },
    {
        "content": "<p>There is overwhelming support for the last suggestion. This would give the following paragraph, to be added to the naming convention.</p>\n<h3>Expanded and unexpanded forms of functions</h3>\n<p>The product of two functions <code>f</code> and <code>g</code> can be denoted equivalently as <br>\n<code>f * g</code> or <code>fun x ‚Ü¶ f x * g x</code>. These expressions are definitionally equal, but not syntactically, which<br>\nmeans that <code>rw</code> will not apply to one of them a theorem given with the other form. Therefore, it is<br>\nsometimes convenient to have variants of the statements using the two forms. To distinguish between them,<br>\nstatements involving the first unexpanded form are written using just <code>mul</code>, while lemmas using<br>\nthe second expanded form should instead use <code>fun_mul</code>.</p>\n<p>For instance, the fact that the product of two continuous functions is continuous is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"bp\">.</span><span class=\"n\">fun_mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"bp\">.</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The same goes for addition, subtraction, negation, powers and composition of functions.</p>",
        "id": 502603492,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740756257
    },
    {
        "content": "<p>I am not specifying here if PR authors should use one form, or the other, or both, leaving that to the discretion of the authors. Does this sound reasonable?</p>",
        "id": 502603846,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740756353
    },
    {
        "content": "<p>I am concerned about the amount of non-backward-compatible breakage (in mathlib &amp; in downstream projects) that will arise if/when the definition of <code>Continuous.mul</code> gets changed to match this change to the style guide. </p>\n<p>(Since the name <code>Continuous.mul</code> will remain in use, but won't mean the same as before, there is no way we can handle this with deprecations.)</p>",
        "id": 502605972,
        "sender_full_name": "David Loeffler",
        "timestamp": 1740756937
    },
    {
        "content": "<p>Note that both statements are defeq, so in 99% of the situations nothing should break. For instance, if you were proving continuity with <code>(hf.add hg).mul ha</code>, the same proof will remain valid.</p>",
        "id": 502606668,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740757131
    },
    {
        "content": "<p>Well, I guess the only way to find out is to try...</p>",
        "id": 502606866,
        "sender_full_name": "David Loeffler",
        "timestamp": 1740757191
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> what you have written above looks pretty good, although can we pick an example other than <code>Continuous (f * g)</code>? Indeed, as you pointed out with the defeq comment, this particular issue will essentially never arise for <code>Continuous.mul</code> because one doesn't rewrite with this. Maybe <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Topology.IsInducing.of_comp_iff#doc\">docs#Topology.IsInducing.of_comp_iff</a> would be slightly more relevant? Or other examples. I have some (like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=cfc_mul#doc\">docs#cfc_mul</a>), but they are too specialized for the naming conventions page.</p>",
        "id": 502655353,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1740772374
    },
    {
        "content": "<p>Could you also mention the examples of identity and composition explicitly? My understanding is that we will write <code>fun_id</code> for <code>fun x =&gt; x</code> and <code>fun_comp</code> for <code>fun x =&gt; f (g x)</code></p>",
        "id": 502667538,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740777189
    },
    {
        "content": "<p>I have yet another question: should we say that the use of <code>fun_</code> is mandatory, or just useful to disambiguate when needed? For instance, in</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"bp\">.</span><span class=\"n\">comp‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">he</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I wouldn't rename it to <code>Continuous.fun_comp‚ÇÇ</code> because we won't ever write the unexpanded version. No objection here?</p>",
        "id": 502719702,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740812913
    },
    {
        "content": "<p>Yes, I think the <code>fun_comp</code> can only be used for a (normal) composition of 2 functions.</p>",
        "id": 502725791,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740818648
    },
    {
        "content": "<p>I agree the <code>fun_</code> is there for disambiguation. But my hope is that in (almost) all cases where the <code>fun_</code> version of a lemma exist, there is also a regular version.</p>",
        "id": 502725868,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740818732
    },
    {
        "content": "<p>I'd vote only for disambiguation</p>",
        "id": 502728182,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1740820857
    },
    {
        "content": "<p>ok, another try:</p>\n<h3>Unexpanded and expanded forms of functions</h3>\n<p>The composition of two functions <code>f</code> and <code>g</code> can be denoted equivalently as <br>\n<code>f ‚àò g</code> or <code>fun x ‚Ü¶ f (g x)</code>. These expressions are definitionally equal, but not syntactically, which<br>\nmeans that <code>rw</code> will not apply to one of them a theorem given with the other form. Therefore, it is<br>\nsometimes convenient to have variants of the statements using the two forms. If one needs to <br>\ndistinguish between them, statements involving the first unexpanded form are written using just <code>comp</code>, <br>\nwhile lemmas using the second expanded form should instead use <code>fun_comp</code>. If there is no need to<br>\ndisambiguate because a lemma is given using only the expanded form, the prefix <code>fun_</code> is not required.</p>\n<p>For instance, the fact that the composition of two functions is inducing (whatever that means) is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">IsInducing</span><span class=\"bp\">.</span><span class=\"n\">fun_comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsInducing</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsInducing</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsInducing</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">IsInducing</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsInducing</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsInducing</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsInducing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The same goes for multiplication,  addition, subtraction, negation and powers of functions.</p>",
        "id": 502781579,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740859098
    },
    {
        "content": "<p>It might be good to mention that Tactics like <code>apply?</code> and <code>fun_prop</code>, just like <code>rw</code>, do not apply one form to the other form, since the example isn't a <code>rw</code> lemma. And I'd suggest to also include the example with multiplication, as it is what this conversation started about.</p>",
        "id": 502783320,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740860190
    },
    {
        "content": "<p>ok, another try. I've switched back to the multiplication of two functions, as the <code>fun_prop</code> argument makes it clear why we need the two forms.</p>\n<h3>Unexpanded and expanded forms of functions</h3>\n<p>The multiplication of two functions <code>f</code> and <code>g</code> can be denoted equivalently as <br>\n<code>f * g</code> or <code>fun x ‚Ü¶ f x * g x</code>. These expressions are definitionally equal, but not syntactically (and they don't<br>\nshare the same key in indexing trees), which means that tools like <code>rw</code>, <code>fun_prop</code> or <code>apply?</code> <br>\nwill not use a theorem with one form on an expression with the other form. Therefore, it is<br>\nsometimes convenient to have variants of the statements using the two forms. If one needs to <br>\ndistinguish between them, statements involving the first unexpanded form are written using just <code>mul</code>, <br>\nwhile lemmas using the second expanded form should instead use <code>fun_mul</code>. If there is no need to<br>\ndisambiguate because a lemma is given using only the expanded form, the prefix <code>fun_</code> is not required.</p>\n<p>For instance, the fact that the multiplication of two continuous functions is continuous is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"bp\">.</span><span class=\"n\">fun_mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"bp\">.</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Both theorems deserve tagging with the <code>fun_prop</code> attribute.</p>\n<p>The same goes for addition, subtraction, negation, powers and compositions of functions.</p>",
        "id": 502846176,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740911746
    },
    {
        "content": "<p>I think a caveat is that let's say I have a property <code>P</code> and write <code>theorem P.mul (hf : P f) (hg : P g) : P fun x ‚Ü¶ f x * g x</code>. I don't need <code>fun_</code> disambiguation per the convention above. (And for most properties, this is the form that should always exist first, because I can then <code>rw</code>/<code>apply?</code>/<code>fun_prop</code> using this form on more complicated expressions like <code>fun x =&gt; f x * Real.exp (x + g x)</code>.) Then a month later someone wants to add the pointfree version <code>theorem P.mul (hf : P f) (hg : P g) : P (f * g)</code>. They can't add this without renaming the existing <code>P.mul</code> to <code>P.fun_mul</code>, and you can't add a <code>@[deprecated] alias</code> for this rename either because <code>P.mul</code> is taken by the new form.</p>",
        "id": 502879734,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1740935240
    },
    {
        "content": "<p>Also, shouldn't there be a limit to how complicated something is before you should only write it in <code>fun</code> form? What about <code>f * (g ‚àò h)</code>? <code>f * (g ‚àò (-h))</code>? <code>id * f</code>? <code>f ^ 2</code>? <code>2 ‚Ä¢ f / g</code>? <code>-flip f</code>? <code>Real.exp ‚àò f</code>? <code>id * (Real.exp ‚àò (-f))</code>? I am pretty sure at some extent, this form of <a href=\"https://wiki.haskell.org/Pointfree\">pointfreeism</a> is very discouraged. (I know the current version above is only a naming/token convention, and the discretion to use which is left to PR authors, so this would perhaps be a separate convention).</p>",
        "id": 502880275,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1740935574
    },
    {
        "content": "<p>Also related is <code>id'</code> vs <code>id</code>: by the convention above every <code>id'</code> should be named something like <code>fun_self</code></p>",
        "id": 502880796,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1740935899
    },
    {
        "content": "<p>For the first question: yes, that's true, but it's not so bad since both are defeq (and for <code>apply?</code> or <code>fun_prop</code> the new version will be picked up automatically). So I agree it's not perfect, but nothing is perfect!</p>\n<p>For the second question, let's trust the PR authors and reviewers for making a good choice.</p>",
        "id": 502884739,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740938547
    },
    {
        "content": "<p>You're right, they are defeq so shouldn't be that bad</p>",
        "id": 502885302,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1740938984
    },
    {
        "content": "<p>Should <code>id</code> be names <code>fun_self</code> or <code>fun_id</code>? <code>fun_id</code> follows the <code>fun_comp</code> naming, but may be more confusing since there is no identity inside of the <code>fun</code>.</p>",
        "id": 502911706,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740958517
    },
    {
        "content": "<p>I would say <code>fun_self</code>, just following the symbols in the statement.</p>",
        "id": 502955001,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1740985695
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 502955612,
        "sender_full_name": "Attila Vajda",
        "timestamp": 1740986026
    }
]