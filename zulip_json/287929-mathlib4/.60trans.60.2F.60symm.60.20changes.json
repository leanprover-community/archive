[
    {
        "content": "<p>This is certainly not the most pressing issue, but I’ve re(written/factored) <code>trans</code> and <code>symm</code> (and <code>rfl</code>, in a minor way) to match the whole target, not just relation, and to do so after <code>whnfR</code>. (PR pending) This means that they handle reducible relations, and you can e.g. use <code>symm</code> directly on a goal of type <code>¬ (a = b)</code>.</p>\n<p>You can also use <code>trans</code> on goals of the form <code>p → q</code>. We do this through an intermediate deprecated reducible <code>Implies</code> head. Being a little sleep deprived, I had forgotten in the porting meeting why I had also felt the need to put this head on the hypotheses of the trans lemma; the reason is that <code>trans</code> actually uses the arguments of this head to extract and handle the “bridge” hypothesis <code>y</code> in trans lemmas, which are always of the form <code>x ~ y → y ~ z → x ~ z</code>.</p>\n<p>However, we want to banish <code>Implies</code>, and in general usually want these reducible heads to disappear before they reach the user (this is an assumption on my part, though). I can either</p>\n<ol>\n<li>simply always <code>whnfR</code> the new goal types</li>\n<li>test for reducibility of the constant head when registering the trans lemma, then store a flag in the extension saying whether to <code>whnfR</code></li>\n<li>introduce some syntax like <code>@[transR]</code> to let the user control whether the head is unfolded via whnfR (seems like too many knobs but thought I’d mention it).</li>\n</ol>\n<p>(1) seems like the best option to me currently, assuming the overhead for <code>whnfR</code>ing a goal is minimal—it’s simple and uniform—so that’s my plan unless there are other opinions! :)</p>",
        "id": 363852657,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1686004713
    }
]