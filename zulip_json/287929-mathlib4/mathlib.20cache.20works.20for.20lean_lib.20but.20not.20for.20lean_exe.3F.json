[
    {
        "content": "<p>Hi, I have a question about the mathlib cache.</p>\n<p>When I do<br>\n<code>$ lake new testproject math\n$ cd testproject\n$ printf \"import Mathlib\" &gt; Testproject.lean\n$ lake build</code><br>\nit seems to use the cache.</p>\n<p>But when I append another lean_exe target to the end of the file (for example via<br>\n<code>$ printf \"[[lean_exe]]\\nname = \\\"main\\\"\\nroot = \\\"Testproject\\\"\" &gt;&gt; lakefile.toml</code>)<br>\nand then try to build that lean_exe target:<br>\n<code>$ lake build main</code></p>\n<p>Then it continues running from 7xxx/13xxx, for example:<br>\n<code>â¡¿ [7197/13952] Running Mathlib.Logic.Nontrivial.Defs:c.o...</code></p>\n<p>So it seems to me that the cache only works for lean_lib targets, but not for building lean_exe targets?<br>\nBut maybe I'm just confused.</p>\n<p>(Versions:<br>\n<code>$ elan --version\nelan 4.1.2 (58e8d545e 2025-05-26)\n$ lake --version\nLake version 5.0.0-src+7c3ca70 (Lean version 4.22.0-rc3)</code>)</p>",
        "id": 529969835,
        "sender_full_name": "David Richter",
        "timestamp": 1753134115
    },
    {
        "content": "<p>The cache only contains olean files not .o files</p>",
        "id": 529982803,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753143731
    },
    {
        "content": "<p>The latter are a lot more platform dependent</p>",
        "id": 529982813,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753143744
    },
    {
        "content": "<p>It's very unlikely you actually need to import mathlib at compile time in your executable though</p>",
        "id": 529982869,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753143800
    },
    {
        "content": "<p>Kinda makes sense. Is there a way to avoid compiling the mathlib, when I import mathlib in an executable target, but only use something from mathlib in a proof? For example importing mathlib to prove termination of a function.</p>",
        "id": 530088270,
        "sender_full_name": "David Richter",
        "timestamp": 1753171017
    },
    {
        "content": "<p>Have you already used #min_imports to at least only import the bits of mathlib you actually used?</p>",
        "id": 530094091,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753173073
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> can comment on whether this is something that later iterations of the module system can hope to help with; having  \"proof-only\" depencies which are excluded from compilation.</p>",
        "id": 530094288,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753173137
    },
    {
        "content": "<p>Hmm, that could be an interesting additional phase, a <code>noncomputable import</code> if you will. But it would be great to have clear data on its impact first, e.g. measured time overhead for significant projects</p>",
        "id": 530099465,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1753174965
    },
    {
        "content": "<p>My fear is that such projects will never produce such data, and will instead say \"I guess we can't depend on mathlib\" and then rebuild the theory they need from scratch</p>",
        "id": 530099637,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753175025
    },
    {
        "content": "<p>But I guess it makes a big difference whether <span class=\"user-mention\" data-user-id=\"687543\">@David Richter</span> needs FLT to prove termination or whether they need something lightweight from <code>Mathlib.Data</code></p>",
        "id": 530099873,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753175093
    },
    {
        "content": "<p>Could <code>lean_exe</code> do some dependency analysis to skip modules whose IR isn't actually needed? Or does the presence of initializers make this unsound?</p>",
        "id": 530100141,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753175185
    },
    {
        "content": "<p>That, and it would mean native compilation would have to wait for elaboration of <em>all</em> modules to finish first</p>",
        "id": 530100470,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1753175313
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/channel/287929-mathlib4/topic/mathlib.20cache.20works.20for.20lean_lib.20but.20not.20for.20lean_exe.3F/near/530099465\">said</a>:</p>\n<blockquote>\n<p>could be an interesting additional phase, a <code>noncomputable import</code> if you will</p>\n</blockquote>\n<p>I guess you need some error message work here, so that whenin <code>C.lean</code>  you <code>import B</code> which <code>noncomputable import A</code>s, you get an error telling you to <code>import A</code> if you want to compile <code>a x</code>.</p>",
        "id": 530100979,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753175474
    },
    {
        "content": "<p>I got a project from someone else and was trying to figure out why the cache was not working. I suppose the person waited for everything to compile once, some (long) time ago, forgot about it, and only when sharing the development the problem became apparent again.</p>\n<p>A warning that building mathlib in an exectuable target cannot use the cache would be useful, for the reason of platform-specific compilation. This may have pointed me in the correct direction. I'm not sure which tool would be responsible for this warning though. Lake build?</p>\n<p>I suppose it would be convenient to be able to <code>noncomputable import</code> mathlib stuff, because currently is surprising that building (even the same file) for either a library target or a executable target makes such a big difference in compile time. I suppose this could increase the amount of people that use mathlib, but not develop it? Currently one would rather rewrite the proof trying to not depend on mathlib in the executable. I haven't thought about this from the perspective of writing large projects, I'm more in the mindspace of having a simple project with a few files, and being surprised that switching between an library target and an executable target makes such a big difference in compile time.</p>",
        "id": 530190334,
        "sender_full_name": "David Richter",
        "timestamp": 1753204397
    },
    {
        "content": "<blockquote>\n<p>Currently one would rather rewrite the proof trying to not depend on mathlib in the executable.</p>\n</blockquote>\n<p>I want to be very clear that \"not depending on mathlib (the project)\" is a very different goal than \"not using <code>import Mathlib</code>\"</p>",
        "id": 530191992,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753205131
    },
    {
        "content": "<p>Can you run <code>#min_imports</code> in your file and replace <code>import Mathlib</code> with what it suggests?</p>",
        "id": 530192117,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753205179
    },
    {
        "content": "<p>Sorry, this might not be very interesting. I figured out, it did depended on nothing... :)</p>\n<p>I imagine the person who wrote the code happened to import 'Mathlib.Tactic', as a general way to write proofs everywhere, but then eventually simplified the code to not use it?</p>",
        "id": 530192942,
        "sender_full_name": "David Richter",
        "timestamp": 1753205497
    }
]