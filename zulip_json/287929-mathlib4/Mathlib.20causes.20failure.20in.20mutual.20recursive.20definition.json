[
    {
        "content": "<p>I've run into an issue were a mutually recursive definition, without <code>termination_by</code> hint, suddenly fails to compile after importing mathlib.<br>\nHere is a MWE</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Order.Ring.Canonical</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OrderedCancelAddCommMonoid</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">Nat.commSemiring</span><span class=\"o\">,</span> <span class=\"n\">Nat.linearOrder</span> <span class=\"k\">with</span>\n    <span class=\"n\">lt</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.lt</span><span class=\"o\">,</span> <span class=\"n\">add_le_add_left</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">Nat.add_le_add_left</span><span class=\"o\">,</span>\n    <span class=\"n\">le_of_add_le_add_left</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">Nat.le_of_add_le_add_left</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n\n<span class=\"c1\">-- The failure seems specific to that instance, if we have a different instance with `sorry`,</span>\n<span class=\"c1\">-- then the mutual def below will compile without failure</span>\n<span class=\"c1\">-- instance : OrderedCancelAddCommMonoid ℕ := sorry</span>\n\n<span class=\"kd\">mutual</span>\n  <span class=\"kd\">inductive</span> <span class=\"n\">Expr</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n    <span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Com</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n    <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span>\n\n  <span class=\"kd\">inductive</span> <span class=\"n\">Com</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ret</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Com</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"kd\">mutual</span>\n  <span class=\"c1\">-- `fail to show termination`, but only if the `OrderedCancelAddCommMonoid` instance is defined</span>\n  <span class=\"kd\">def</span> <span class=\"n\">Expr.eval</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">c.eval</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">Com.eval</span> <span class=\"o\">:</span> <span class=\"n\">Com</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ret</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">e.eval</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Oddly enough, the failure is tied to an instance of <code>OrderedCancelAddCommMonoid ℕ</code>. Without this instance, the mutual def compiles, but with the instance, Lean fails to show termination.</p>\n<p>For reference, the misbehaving instance is implied by the <code>LinearOrderedCommSemiring ℕ</code> instance in <code>Mathlib.Data.Nat.Order.Basic</code> (so importing that file also causes the error by itself).</p>\n<p>The workaround is easy, just adding an explicit termination hint, but I am very curious what is happening here. How does the existence of this typeclass instance cause a failure in the termination checker?</p>",
        "id": 381913437,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1691166728
    },
    {
        "content": "<p>Briefly: the termination checker is running tactics, and my guess is that the import is changing the simp set, and thus the behaviour of a simp call. Not at a computer now, but have a look at <code>WFTactics.lean</code> in the Lean 4 repository to see the default behaviour.</p>",
        "id": 382025941,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1691206847
    },
    {
        "content": "<p>Thank you, <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>. That's super helpful.</p>",
        "id": 382068669,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691224683
    },
    {
        "content": "<p>I am currently trying to debug this. I will see if I can install a custom lean build and see if I can dbg_trace this. What I find interesting is that the error message is different from what I expect. I would have expected:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Constructs a proof of decreasing along a well founded relation, by applying</span>\n<span class=\"sd\">lexicographic order lemmas and using `ts` to solve the base case. If it fails,</span>\n<span class=\"sd\">it prints a message to help the user diagnose an ill-founded recursive definition. -/</span>\n<span class=\"n\">macro</span> <span class=\"s2\">\"decreasing_with \"</span> <span class=\"n\">ts</span><span class=\"o\">:</span><span class=\"n\">tacticSeq</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span>\n   <span class=\"o\">(</span><span class=\"n\">simp_wf</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Prod.Lex.right</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Prod.Lex.left</span><span class=\"o\">)</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">PSigma.Lex.right</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">PSigma.Lex.left</span><span class=\"o\">)</span>\n    <span class=\"n\">first</span>\n    <span class=\"bp\">|</span> <span class=\"n\">done</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">ts</span>\n    <span class=\"bp\">|</span> <span class=\"n\">fail</span> <span class=\"s2\">\"failed to prove termination, possible solutions:</span>\n<span class=\"s2\">  - Use `have`-expressions to prove the remaining goals</span>\n<span class=\"s2\">  - Use `termination_by` to specify a different well-founded relation</span>\n<span class=\"s2\">  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal\"</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Yet, we get the slightly different one about mutual inductives being the problem.</p>",
        "id": 382069194,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691224805
    },
    {
        "content": "<p>I wonder if there is an easier way to debug this than installing my custom lean4 build and updating the prelude.</p>",
        "id": 382069879,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691224982
    },
    {
        "content": "<p>Could I maybe copy some of the lean4 code in my own file, run some #eval line, and check there if the decreasing_with thing works?</p>",
        "id": 382070047,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691225024
    },
    {
        "content": "<p>The elaborator will only show the error message from trying structural recursion (which does not exist for mutuals), you can force it to show the wf error using</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 382071503,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691225396
    },
    {
        "content": "<p>No need to rebuild Lean, you can locally override <code>decreasing_tactic</code>: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=tacticDecreasing_tactic#doc\">docs#tacticDecreasing_tactic</a></p>",
        "id": 382072045,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691225547
    },
    {
        "content": "<p>These are the magic hints. Thank you.</p>",
        "id": 382072565,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691225649
    },
    {
        "content": "<p>Combining the <code>termination_by</code> with <code>trace.Meta.Tactic.simp.rewrite</code> suggests that the instance enables an <em>additional</em> rewrite, which might screw up the goal for the remaining tactics</p>",
        "id": 382072926,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691225707
    },
    {
        "content": "<p>OK. I made some mini-progress debugging this. This very example goes through if I add the following theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Nat.zero_lt_one_plus_n</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}:</span>  <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I am not yet sure where things diverge, but I find it interesting that this trivial identity is not in the mathlib simp set.</p>",
        "id": 382117921,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691235812
    },
    {
        "content": "<p>When trying to proof this identity, simp using:</p>\n<p><code>theorem Nat.zero_lt_succ (n : Nat) : LT.lt 0 (succ n) :=\n  succ_le_succ (zero_le n)</code></p>\n<p>does not work.</p>\n<p>This is 0 &lt; succ n, which seems to be pretty much 0 &lt; 1 + n. I feel there is only some notation in the way.</p>",
        "id": 382120182,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691236256
    },
    {
        "content": "<p><code>succ n</code> is <code>n + 1</code></p>",
        "id": 382120271,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1691236277
    },
    {
        "content": "<p>I see: by <code>rw [Nat.add_comm]; simp</code> works.</p>",
        "id": 382120568,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691236340
    },
    {
        "content": "<p>I am curious what's the mathlib solution to these trivial identities. Should we just rely on linarith or would it make sense to add a simpl lemma that turns 1 + n into n + 1?</p>",
        "id": 382120811,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691236398
    },
    {
        "content": "<p>I think it is not clear when to use non-equalities in the simp set, because almost any theorem could be a simp set candidate in that case</p>",
        "id": 382121463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691236561
    },
    {
        "content": "<p>it does seem a bit like overfitting to have precisely <code>0 &lt; 1 + n</code> as a simp lemma</p>",
        "id": 382121661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691236605
    },
    {
        "content": "<p>In LLVM we an informal canonical form, where we always move constants to the right.</p>",
        "id": 382121672,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691236607
    },
    {
        "content": "<p>what happens if you <code>simp [add_comm]</code>?</p>",
        "id": 382121753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691236625
    },
    {
        "content": "<p>simp also has a canonical form for AC rewriting, which it uses in permutation rules like this</p>",
        "id": 382121911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691236664
    },
    {
        "content": "<p>This means, we need to not have rewrites for '0 + m' and 'm + 0', but always first move the 0 to the right.</p>",
        "id": 382121932,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691236669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Mathlib.20causes.20failure.20in.20mutual.20recursive.20definition/near/382121753\">said</a>:</p>\n<blockquote>\n<p>what happens if you <code>simp [add_comm]</code>?</p>\n</blockquote>\n<p>This works.</p>",
        "id": 382122051,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691236688
    },
    {
        "content": "<p>but it is not enabled by default, you have to pass <code>add_comm, add_left_comm, add_assoc</code> explicitly</p>",
        "id": 382122099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691236702
    },
    {
        "content": "<p>Interesting.</p>",
        "id": 382122145,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691236715
    },
    {
        "content": "<p>I guess I was mostly curious why the termination proof broke for such a simple example.</p>",
        "id": 382122250,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691236736
    },
    {
        "content": "<p>I am not sure if there is anything actionable to do in this case.</p>",
        "id": 382122405,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691236777
    },
    {
        "content": "<p>The simp-ish thing used in termination proofs is a bit more powerful and should handle proofs of <code>0 &lt; 1 + n</code></p>",
        "id": 382122493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691236795
    },
    {
        "content": "<p>It seemingly does not, no?</p>",
        "id": 382122627,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691236814
    },
    {
        "content": "<p>because that's exactly the kind of goal that comes up in proofs about <code>sizeOf</code></p>",
        "id": 382122660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691236817
    },
    {
        "content": "<p>I think something in the mathlib simp set messed it up</p>",
        "id": 382122699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691236828
    },
    {
        "content": "<p>OK.</p>",
        "id": 382122745,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691236842
    },
    {
        "content": "<p>If I add <code>@[simp] theorem x {m : Nat}:  0 &lt; 1 + m := by sorry</code> then it works again.</p>",
        "id": 382122820,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691236856
    },
    {
        "content": "<p>without a simp marker?</p>",
        "id": 382122877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691236869
    },
    {
        "content": "<p>With.</p>",
        "id": 382122940,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691236884
    },
    {
        "content": "<p>I am not sure how to debug this further. I can see that wrong simp lemmas may make simp run into a direction that avoids pattern to be found. But can adding simp lemmas in mathlib make simp less powerful for such a trivial identity?</p>",
        "id": 382123559,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691237020
    },
    {
        "content": "<p>That is interesting.</p>",
        "id": 382123727,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691237052
    },
    {
        "content": "<p>My best guess without digging further is that the additional simp lemma uses a representation of <code>0</code> that the final <code>simp_arith</code> doesn't recognize</p>",
        "id": 382124365,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1691237182
    },
    {
        "content": "<p>The subgoal generated by</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp.rewrite</span> <span class=\"n\">true</span>\n<span class=\"kd\">mutual</span>\n  <span class=\"c1\">-- `fail to show termination`, but only if the `OrderedCancelAddCommMonoid` instance is defined</span>\n  <span class=\"kd\">def</span> <span class=\"n\">Expr.eval</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">c.eval</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">Com.eval</span> <span class=\"o\">:</span> <span class=\"n\">Com</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ret</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">e.eval</span>\n<span class=\"kd\">end</span>\n<span class=\"n\">decreasing_by</span>\n  <span class=\"n\">simp_wf</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Prod.Lex.right</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Prod.Lex.left</span><span class=\"o\">)</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">PSigma.Lex.right</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">PSigma.Lex.left</span><span class=\"o\">)</span>\n  <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">arith</span> <span class=\"o\">:=</span> <span class=\"n\">true</span> <span class=\"o\">})</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>is <code>Zero.zero ≤ m</code>, indicating that the Zero typeclass is causing problems</p>",
        "id": 382124952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691237325
    },
    {
        "content": "<p>Wow, that really shows me how to debug this.</p>",
        "id": 382125914,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691237554
    },
    {
        "content": "<p>Interestingly, <code>example {m : Nat }: Zero.zero ≤ m := by simp_arith</code> fails with and without the OrderedCalcelAddCommMonoid. Given that this is as canonical as it gets, I guess this should be simplified.</p>",
        "id": 382127164,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691237839
    },
    {
        "content": "<p>Maybe this is relevant: <a href=\"#narrow/stream/287929-mathlib4/topic/0.F0.9F.94.B6.20.28.22zero.20diamond.22.29/near/257669888\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/0.F0.9F.94.B6.20.28.22zero.20diamond.22.29/near/257669888</a></p>",
        "id": 382157069,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691245298
    },
    {
        "content": "<p>A diamond between ofNat and Zero</p>",
        "id": 382157125,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691245314
    },
    {
        "content": "<p>OK. I have made some progress. It seems the following can be proven with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">}:</span> <span class=\"n\">Zero.zero</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">decide</span><span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">arith</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">})</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Zero.zero</span><span class=\"o\">,</span> <span class=\"n\">Nat.zero_eq</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>similarly I need </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">}:</span> <span class=\"n\">Zero.zero</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">One.one</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n   <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.zero_eq</span><span class=\"o\">,</span> <span class=\"n\">Nat.succ_pos'</span><span class=\"o\">,</span> <span class=\"n\">Zero.zero</span><span class=\"o\">,</span> <span class=\"n\">One.one</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>to prove the following one. </p>\n<p>It seems to me I need to include <code>Zero.zero</code> and <code>One.one</code> in my simp set explicitly to make theorems that contain these work. Is this typical. I find that somehow surprising.</p>",
        "id": 382164464,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691247299
    },
    {
        "content": "<p>And indeed, adding <code>attribute [simp] Zero.zero One.one</code> makes the proof reliably go through.</p>",
        "id": 382166925,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691247905
    },
    {
        "content": "<p>I think instead you should be writing <code>Zero.zero : ℕ</code> back into <code>0 : ℕ</code>, etc?</p>",
        "id": 382235869,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1691276429
    },
    {
        "content": "<p>What do you mean by </p>\n<blockquote>\n<p>writing <code>Zero.zero : ℕ</code> back into <code>0 : ℕ</code>,</p>\n</blockquote>\n<p>I interpret that as you asking for a theorem that maps <code>Zero.zero: ℕ</code> back to <code>0: ℕ</code>. I tested it and the following works as well:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Nat_Zero_eq_zero</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Zero.zero</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Zero.zero</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Nat_One_eq_one</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">One.one</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">One.one</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I am not surprised by it and assumed that <code>@[simp] Zero.zero</code> pretty much would do the same thing. So I suspect I misunderstood and wonder if you maybe meant sth different? In general, I am a little surprised that apparently typeclasses allow us to write statements generic over types that rely on <a href=\"http://Zero.zero\">Zero.zero</a> and that smoothly generalize to Nat, and at the same time the typeclass gets in the way of such a trivial identity. I read over <a href=\"https://leanprover.github.io/theorem_proving_in_lean/type_classes.html\">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html</a>, but did not find such cases mentioned. Is there maybe a better source to learn about type classes.</p>",
        "id": 382256773,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691287013
    },
    {
        "content": "<p>I've done some more investigation. It seems that it is <code>simp { arith := true }</code> that introduces the <code>Zero.zero</code>. This <code>simp { arith := true }</code> also has different behaviour depending on which <code>0</code> is used. If the instance <code>OfNat Nat 0</code> comes via <code>Zero.toOfNat0</code>, then <code>simp { arith := true }</code> fails to prove <code>0 &lt; 1 + m</code> but it succeeds when the instance is <code>instOfNatNat</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Order.Ring.Canonical</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OrderedCancelAddCommMonoid</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">Nat.commSemiring</span><span class=\"o\">,</span> <span class=\"n\">Nat.linearOrder</span> <span class=\"k\">with</span>\n    <span class=\"n\">lt</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.lt</span><span class=\"o\">,</span> <span class=\"n\">add_le_add_left</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">Nat.add_le_add_left</span><span class=\"o\">,</span>\n    <span class=\"n\">le_of_add_le_add_left</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">Nat.le_of_add_le_add_left</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">lt_add_iff_pos_left</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">arith</span> <span class=\"o\">:=</span> <span class=\"n\">true</span> <span class=\"o\">})</span> <span class=\"n\">only</span> <span class=\"c1\">-- goal is `Zero.zero ≤ m`</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">arith</span> <span class=\"o\">:=</span> <span class=\"n\">true</span> <span class=\"o\">})</span> <span class=\"n\">only</span> <span class=\"c1\">--No goals</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">ℕ</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">Zero.toOfNat0</span><span class=\"o\">))</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">arith</span> <span class=\"o\">:=</span> <span class=\"n\">true</span> <span class=\"o\">})</span> <span class=\"n\">only</span> <span class=\"c1\">-- goal is `Zero.zero ≤ m`</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">ℕ</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">instOfNatNat</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">arith</span> <span class=\"o\">:=</span> <span class=\"n\">true</span> <span class=\"o\">})</span> <span class=\"n\">only</span> <span class=\"c1\">-- No goals</span>\n</code></pre></div>",
        "id": 382598668,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1691409163
    },
    {
        "content": "<p>Where can I see the code for what <code>simp (config := { arith := true }) only</code> does?</p>",
        "id": 382599473,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1691409332
    },
    {
        "content": "<p>My guess is that the problem is in <code>toLinearExpr</code> in <code>Lean.Meta.Tactic.LinearArith.Nat.Basic</code></p>",
        "id": 382607406,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1691410853
    },
    {
        "content": "<p>It seems <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> looked into this recently (a year ago)?</p>",
        "id": 382610820,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691411547
    },
    {
        "content": "<p>Maybe it's just a case of adding <code>Zero.zero</code> (and <code>One.one</code>)  to <code>isNatProjInst</code>in <code>Lean.Meta.Offset</code></p>",
        "id": 382611252,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1691411642
    },
    {
        "content": "<p>I think what's going on is the following. Lean sees <code>@OfNat.ofNat ℕ 0 (Zero.toOfNat0)</code>. It runs <code>Lean.Meta.Linear.Nat.ToLinear.toLinearExpr</code>. This function then calls <code>isNatProjInst</code> on the head symbol, and it is true because the head symbol is <code>OfNat.ofNat</code> which is in the list given by <code>isNatProjInst</code>. It then runs <code>unfoldProjInst?</code> on this, which I guess is where <code>Zero.zero</code> comes from. It doesn't unfold any further however, because <code>Zero.zero</code> is not in the list given in <code>isNatProjInst</code>. </p>\n<p>Adding <code>Zero.zero</code> to the list in <code>unfoldProjInst</code> might fix this, but it seems a little hacky and unstable, because I still don't think it would work if the <code>Zero</code> instance itself came from <code>AddMonoid</code> or something.</p>",
        "id": 382619134,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1691413038
    },
    {
        "content": "<p>Or maybe <code>unfoldProjInst?</code> is smart enough to keep unfolding in these cases. This seems likely, but I don't fully understand this function.</p>",
        "id": 382621435,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1691413452
    },
    {
        "content": "<p>one issue with this is that <code>unfoldProjInst?</code> is defined in lean core and <code>Zero</code> is defined in mathlib</p>",
        "id": 382625916,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691414280
    },
    {
        "content": "<p>But it doesn't matter because it's just checking the name. But yes it's ugly</p>",
        "id": 382626765,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1691414420
    },
    {
        "content": "<p>Maybe <code>Zero</code> has to go back to core</p>",
        "id": 382626945,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1691414454
    },
    {
        "content": "<p>Or we need an attribute or something that we can mark <code>Zero</code> with this attribute.</p>",
        "id": 382627183,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1691414491
    },
    {
        "content": "<p>I don't see why we want to unfold numbers in the first place, that sounds bad?</p>",
        "id": 382627573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691414557
    },
    {
        "content": "<p>It struck me as a little strange to unfold addition to <code>Nat.add</code> and so on.</p>",
        "id": 382630525,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1691415108
    },
    {
        "content": "<p>Maybe this is a different discussion, but do we even need <code>Zero</code> to be a separate typeclass from <code>OfNat</code>? Could we somehow make it a surface-level alias?</p>",
        "id": 382632261,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1691415437
    },
    {
        "content": "<p>yes, we get into diamond issues otherwise</p>",
        "id": 382636570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691416158
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Mathlib.20causes.20failure.20in.20mutual.20recursive.20definition/near/382627573\">said</a>:</p>\n<blockquote>\n<p>I don't see why we want to unfold numbers in the first place, that sounds bad?</p>\n</blockquote>\n<p>AFAIU this is all about the following two files. where we aim to turn an Expr into a Nat.Linear.Expr. It seems the algorithm is rather simple. It matches for known constructors, calls unfoldProjInst? if possible and otherwise assumes anything that cannot be unfolded is a parameter. This roughly makes sense to me. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I don't fully understand what you said above. Are you saying <code> if let some e ← unfoldProjInst? e then</code> should be completely dropped? I am not yet seeing why this is particularly bad and would avoid introducing <a href=\"http://Zero.zero\">Zero.zero</a>.</p>\n<p>In particular, I am not yet sure where the <a href=\"http://Zero.zero\">Zero.zero</a> actually gets introduced. <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>, did you find the line where this happens? unfolding sizeOf certainly does not yield a zero. Does some of the lean code itself introduce the zero?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">toLinearExpr</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">LinearExpr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Expr.lit</span> <span class=\"o\">(</span><span class=\"n\">Literal.natVal</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">num</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Expr.mdata</span> <span class=\"n\">_</span> <span class=\"n\">e</span>              <span class=\"bp\">=&gt;</span> <span class=\"n\">toLinearExpr</span> <span class=\"n\">e</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Expr.const</span> <span class=\"bp\">``</span><span class=\"n\">Nat.zero</span> <span class=\"bp\">..</span>    <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">num</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Expr.app</span> <span class=\"bp\">..</span>                 <span class=\"bp\">=&gt;</span> <span class=\"n\">visit</span> <span class=\"n\">e</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Expr.mvar</span> <span class=\"bp\">..</span>                <span class=\"bp\">=&gt;</span> <span class=\"n\">visit</span> <span class=\"n\">e</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>                           <span class=\"bp\">=&gt;</span> <span class=\"n\">addAsVar</span> <span class=\"n\">e</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">visit</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">LinearExpr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">e.getAppFn</span>\n    <span class=\"k\">match</span> <span class=\"n\">f</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Expr.mvar</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">eNew</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">e</span>\n      <span class=\"k\">if</span> <span class=\"n\">eNew</span> <span class=\"bp\">!=</span> <span class=\"n\">e</span> <span class=\"k\">then</span>\n        <span class=\"n\">toLinearExpr</span> <span class=\"n\">eNew</span>\n      <span class=\"k\">else</span>\n        <span class=\"n\">addAsVar</span> <span class=\"n\">e</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Expr.const</span> <span class=\"n\">declName</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">numArgs</span> <span class=\"o\">:=</span> <span class=\"n\">e.getAppNumArgs</span>\n      <span class=\"k\">if</span> <span class=\"n\">declName</span> <span class=\"bp\">==</span> <span class=\"bp\">``</span><span class=\"n\">Nat.succ</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">numArgs</span> <span class=\"bp\">==</span> <span class=\"mi\">1</span> <span class=\"k\">then</span>\n        <span class=\"n\">return</span> <span class=\"n\">inc</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">toLinearExpr</span> <span class=\"n\">e.appArg</span><span class=\"bp\">!</span><span class=\"o\">)</span>\n      <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">declName</span> <span class=\"bp\">==</span> <span class=\"bp\">``</span><span class=\"n\">Nat.add</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">numArgs</span> <span class=\"bp\">==</span> <span class=\"mi\">2</span> <span class=\"k\">then</span>\n        <span class=\"n\">return</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">toLinearExpr</span> <span class=\"o\">(</span><span class=\"n\">e.getArg</span><span class=\"bp\">!</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">toLinearExpr</span> <span class=\"o\">(</span><span class=\"n\">e.getArg</span><span class=\"bp\">!</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n      <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">declName</span> <span class=\"bp\">==</span> <span class=\"bp\">``</span><span class=\"n\">Nat.mul</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">numArgs</span> <span class=\"bp\">==</span> <span class=\"mi\">2</span> <span class=\"k\">then</span>\n        <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">evalNat</span> <span class=\"o\">(</span><span class=\"n\">e.getArg</span><span class=\"bp\">!</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">mulL</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">toLinearExpr</span> <span class=\"o\">(</span><span class=\"n\">e.getArg</span><span class=\"bp\">!</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n        <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">evalNat</span> <span class=\"o\">(</span><span class=\"n\">e.getArg</span><span class=\"bp\">!</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n          <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">mulR</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">toLinearExpr</span> <span class=\"o\">(</span><span class=\"n\">e.getArg</span><span class=\"bp\">!</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"n\">k</span>\n          <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">addAsVar</span> <span class=\"n\">e</span>\n      <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">isNatProjInst</span> <span class=\"n\">declName</span> <span class=\"n\">numArgs</span> <span class=\"k\">then</span>\n        <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">unfoldProjInst</span><span class=\"bp\">?</span> <span class=\"n\">e</span> <span class=\"k\">then</span>\n          <span class=\"n\">toLinearExpr</span> <span class=\"n\">e</span>\n        <span class=\"k\">else</span>\n          <span class=\"n\">addAsVar</span> <span class=\"n\">e</span>\n      <span class=\"k\">else</span>\n        <span class=\"n\">addAsVar</span> <span class=\"n\">e</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">addAsVar</span> <span class=\"n\">e</span>\n</code></pre></div>\n<p>which aims to fill this data-structure:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Nat.Linear</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Expr</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">num</span>  <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span>  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Var</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">add</span>  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mulL</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mulR</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span>\n</code></pre></div>",
        "id": 382819631,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691470623
    },
    {
        "content": "<p>unfolding the <code>OfNat</code> application yields a <a href=\"http://Zero.zero\">Zero.zero</a></p>",
        "id": 382819735,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691470681
    },
    {
        "content": "<p>I was looking at the <code>example (m c : ℕ) : sizeOf c &lt; 1 + m + sizeOf c := by</code> example. unfolding sizeOf does not reach OfNat.</p>",
        "id": 382820094,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691470891
    },
    {
        "content": "<p>there is a mathlib simp lemma taking that goal to <code>0 &lt; 1 + m</code></p>",
        "id": 382820218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691470946
    },
    {
        "content": "<p>Ahhhh</p>",
        "id": 382820236,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691470956
    },
    {
        "content": "<p>where <code>0</code> is spelled using an instance chain involving <code>Zero</code></p>",
        "id": 382820264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691470975
    },
    {
        "content": "<p>because it's a theorem about additive monoids</p>",
        "id": 382820299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691470992
    },
    {
        "content": "<p>Ah, now I see. If we use more generic simp lemmas, than <a href=\"http://Zero.zero\">Zero.zero</a> will eventually pop up.</p>",
        "id": 382820453,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691471060
    },
    {
        "content": "<p>And then <code>simp (config := { arith := true }) only</code> cannot interpret it.</p>",
        "id": 382820495,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691471094
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Mathlib.20causes.20failure.20in.20mutual.20recursive.20definition/near/382627573\">said</a>:</p>\n<blockquote>\n<p>I don't see why we want to unfold numbers in the first place, that sounds bad?</p>\n</blockquote>\n<p>How would this help?</p>",
        "id": 382820549,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691471112
    },
    {
        "content": "<p>if we see a <code>OfNat n</code> application, we commit to interpreting the expression as <code>.nat n</code> and assert defeq of the instance to the nat instance, instead of unfolding things</p>",
        "id": 382820692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691471164
    },
    {
        "content": "<p>That seems to make sense.</p>",
        "id": 382820965,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691471288
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 382820997,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1691471298
    }
]