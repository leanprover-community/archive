[
    {
        "content": "<p>Could I ask what the current plans are (if any) for refactors to turn things that were once irreducible type syonyms into one-fieldstructures?</p>\n<p>Mathlib.Algebra.Opposites has <code>PreOpposite</code> from which <code>MulOpposite</code>and <code>AddOpposite</code> are defined, but <code>Additive</code> and <code>Multiplicative</code> are very much still type synonyms, and I think from the comments around the necessity for <code>PreOpposite</code> that this is deliberate.</p>\n<p>The situation in Order-land confuses me though. For one thing, we seem to have Mathlib.Order.TypeTags (in which WithBot and WithTop are defined). I am not sure what \"type tags\" is meant to mean here - in Mathlib.Algebra.Group.TypeTags.Basic it refers to <code>Additive</code> and <code>Multiplicative</code>, but unlike with WithBot and WithTop (which actively add an element by defining them both as synonyms of Option) <code>Additive</code> etc. are more what I would think of as a \"tag\" because they are equivalent to the original type.</p>\n<p>Then we have Mathlib.Order.Synonym, which is where type synonyms are defined, apparantly. The documentation implies <code>OrderDual</code>, <code>Lex</code> and <code>Colex</code> are all found here. In fact OrderDual is defined in Mathlib.Order.Basic, I assume for some kind of dependency reason, but it is strange to me to do that there and not define it in Mathlib.Order.Defs, which doesn't to be fair currently exist. All of these I think are defined as type synonyms.</p>\n<p>(There is also Mathlib.Algebra.Group.WithOne.Defs in which <code>WithOne</code> and <code>WithZero</code> are both defined - this is quite similar to WithBot and WithTop though.)</p>\n<p>I'm asking about this not because I particularly want to push a solution (I do think single-element structures for everything feels most \"right\" to me but that may not actually be useful in practice), but more that I feel consious that the current situation is a diversity of approaches which are confusingly heterogenous. I would be quite prepared to put some hours in to helping out with or even leading part of any necessary refactor, but currently I don't think I understand what the current consensus is or even if there is one.</p>",
        "id": 570988731,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769768189
    },
    {
        "content": "<p>(I may have missed some examples of this design pattern above - I would appreciate knowing about them as I don't want to miss part of the picture. But I think this is a good slice of the examples I commonly encounter.)</p>",
        "id": 570988943,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769768235
    },
    {
        "content": "<p>It may be most appropriate to write this up as an issue in GitHub and seek consensus there rather than on a Zulip thread - I would also be happy to do that. In general I want to be a good-mannered and productive contributor to Mathlib - it's getting on for six years on and off of being in the Lean community now so I do feel I should \"PR responsibly\" for sure.</p>",
        "id": 570989181,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769768304
    },
    {
        "content": "<p>Sometimes it feels a bit like I do things the wrong way and get told off without much guidance on how to improve which is why I've been more reticient to contribute to Mathlib in recent times: so I hope this post, at least, is considered productive.</p>",
        "id": 570990006,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769768559
    },
    {
        "content": "<p>Personally I don't like single-<strong>field</strong> structures. (When I see \"single-element\" I think of subsingletons.) I think they introduce artificial non-defeqs which complicate proofs (need to transport across isomorphism), and are not the right solution to defeq abuse; the solution should be some automation to flag decls whose type make use of non-reducible defeqs (just insert <code>with_reducible</code> and see if they still typecheck?).</p>",
        "id": 570990563,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1769768733
    },
    {
        "content": "<p>Yeah, I see that argument. I like the artifical non-defeqs though: I don't think you can separate \"defeqs that are good\" and \"defeqs that are bad\" cleanly, certainly.</p>",
        "id": 571022628,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769778263
    },
    {
        "content": "<p>We do certainly use single field structures in at least a handful of instances though, so if we did come to the consensus they weren't the best way to handle it, there would still be stuff to change.</p>",
        "id": 571022872,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769778327
    },
    {
        "content": "<p>Doesn't the module system solve defeq abuse since you can remove the <code>@[expose]</code>?</p>",
        "id": 571109147,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1769801523
    },
    {
        "content": "<p>Quite possibly! That would be good.</p>",
        "id": 571110824,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769802082
    },
    {
        "content": "<p>I like the idea of single-field structures in principle, but the def-eq (ab)use they inhibit is just far too convenient in my opinion. I recently wrote <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/CompleteLattice/PiLex.html\">this file</a> where half of the theorems are proven via <code>OrderDual</code> def-eq shenanigans.</p>",
        "id": 571110831,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769802084
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> who I believe had some strong opinions about this topic.</p>",
        "id": 571110868,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769802096
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Single-element.20structures.20and.20type.20synonyms/near/571110831\">said</a>:</p>\n<blockquote>\n<p>I like the idea of single-field structures in principle, but the def-eq (ab)use they inhibit is just far too convenient in my opinion. I recently wrote (this file)[https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/CompleteLattice/PiLex.html] where half of the theorems are proven via <code>OrderDual</code> def-eq shenanigans.</p>\n</blockquote>\n<p>Yeah I mean I think I use it all the time. It's such a pain to work with the dual without it as well. But it does feel odd sometimes.</p>",
        "id": 571110962,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769802130
    },
    {
        "content": "<p>i have to say the only reason that i know why <code>OrderDual</code> hasn't gone the way of the 1-field structure yet, is the fact that <code>OrderDual (WithTop X) = WithBot (OrderDual X)</code> is abused, and fixing these specific occurrences is more tedious than the usual fix of inserting <code>toDual</code>, <code>ofDual</code>, and <code>congrArg</code> in the right places</p>",
        "id": 571111611,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769802367
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 571111677,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769802402
    },
    {
        "content": "<p>and even then, i believe nowadays the duplication should just be fixed by <code>to_dual</code>, no?</p>",
        "id": 571112060,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769802536
    },
    {
        "content": "<p>I was looking at it yesterday (and being frustrated by the fact it's defined in Order. Basic)! I think it would be doable but it might be a little harder than you would think. Also we would probably want to change the definition of OrderDual.toDual and ofDual - currently these are defined as equivs but this isn't consistent with other places where there's a separate equiv function. Or we should change all the other places, idk.</p>",
        "id": 571113019,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769802837
    },
    {
        "content": "<p>A lot of the duplication will be fixed by <code>to_dual</code>, yes. But I don't think it'll solve 100% of all our problems. For instance, I have no idea how I would be able to get it to work with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lex#doc\">docs#Lex</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Colex#doc\">docs#Colex</a>.</p>",
        "id": 571113022,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769802840
    }
]