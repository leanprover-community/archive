[
    {
        "content": "<p>I'm trying to use Euler's theorem, as implemented in <a href=\"https://github.com/leanprover-community/mathlib4/blob/7766bcc46ae69e55b32297edb59448f2e1fe1dde/Mathlib/FieldTheory/Finite/Basic.lean#L474\">https://github.com/leanprover-community/mathlib4/blob/7766bcc46ae69e55b32297edb59448f2e1fe1dde/Mathlib/FieldTheory/Finite/Basic.lean#L474</a></p>\n<p>However, even using it in the most basic form doesn't seem to work: see <a href=\"https://live.lean-lang.org/#code=import%20Mathlib.FieldTheory.Finite.Basic%0A%0Aopen%20Nat%0Aopen%20Finite%0A%0Aexample%20%7Bx%20n%20%3A%20%E2%84%95%7D%20(h0%20%3A%20Coprime%20x%20n)%20%3A%20x%20%5E%20%CF%86%20n%20%E2%89%A1%201%20%5BMOD%20n%5D%20%3A%3D%20by%20rw%20%5BNat.ModEq.pow_totient%20h0%5D%0A\">here</a>.</p>\n<p>It looks like <code>rw</code> is looking for an expression like <code>x ^ φ n % n</code> and won't accept something like <code>x ^ φ n ≡ 1 [MOD n]</code>.</p>\n<p>What am I doing wrong?</p>",
        "id": 401508194,
        "sender_full_name": "ElCondor",
        "timestamp": 1699706226
    },
    {
        "content": "<p>The <code>rw</code> tactic will <em>only</em> eat theorems of the form <code>A = B</code> or <code>A ↔ B</code>. And when it eats one of these, it will change all <code>A</code>s to <code>B</code>s. You don't have this set-up, because you have a congruence, not an equality. You could turn it into an equality in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mi>n</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z/n\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathbb\">Z</span></span></span></span>, but Lean is picky about these things.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">Coprime</span> <span class=\"n\">x</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">φ</span> <span class=\"n\">n</span> <span class=\"bp\">≡</span> <span class=\"mi\">1</span> <span class=\"o\">[</span><span class=\"n\">MOD</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Nat.ModEq.pow_totient</span> <span class=\"n\">h0</span>\n</code></pre></div>",
        "id": 401520418,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1699717134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Cannot.20use.20.60Nat.2EModEq.2Epow_totient.60.20.28Euler's.20theorem.29/near/401520418\">said</a>:</p>\n<blockquote>\n<p>The <code>rw</code> tactic will <em>only</em> eat theorems of the form <code>A = B</code> or <code>A ↔ B</code>. And when it eats one of these, it will change all <code>A</code>s to <code>B</code>s. You don't have this set-up, because you have a congruence, not an equality. You could turn it into an equality in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mi>n</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z/n\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathbb\">Z</span></span></span></span>, but Lean is picky about these things.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">Coprime</span> <span class=\"n\">x</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">φ</span> <span class=\"n\">n</span> <span class=\"bp\">≡</span> <span class=\"mi\">1</span> <span class=\"o\">[</span><span class=\"n\">MOD</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Nat.ModEq.pow_totient</span> <span class=\"n\">h0</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>OK I understand.</p>\n<p>I switched to using <code>ZMod</code> instead, and I was able to prove a part of what I want (proving a result related to RSA) using these: <a href=\"https://live.lean-lang.org/#code=import%20Mathlib.Data.ZMod.Basic%0Aimport%20Mathlib.RingTheory.IntegralDomain%0Aimport%20Mathlib.FieldTheory.Finite.Basic%0A%0Aopen%20Nat%0Aopen%20ZMod%0A%0Atheorem%20rsa_correctness%20%7Bm%20e%20d%20k%20p%20q%20n%20%3A%20%E2%84%95%7D%0A%20%20(hp%20%3A%20p.Prime)%20(hq%20%3A%20q.Prime)%20(hde%20%3A%20e%20*%20d%20%3D%201%20%2B%20%CF%86%20(p%20*%20q)%20*%20k)%20(hm%20%3A%20m%20%3C%20p%20*%20q)%20%3A%20m%20%3D%20((m%20%5E%20e)%20%5E%20d)%20%25%20(p%20*%20q)%20%3A%3D%20by%0A%20%20%20%20have%20pq_gt_1%20%3A%20p%20*%20q%20%3E%201%20%3A%3D%20sorry%0A%20%20%20%20by_cases%20h%20%3A%20m.Coprime%20(p%20*%20q)%0A%20%20%20%20%7B%0A%20%20%20%20%20%20let%20M%20%3A%20Units%20(ZMod%20(p%20*%20q))%20%3A%3D%20ZMod.unitOfCoprime%20_%20h%0A%20%20%20%20%20%20have%20eq0%20%3A%20(M%20%5E%20e)%20%5E%20d%20%3D%20M%20%3A%3D%20by%20calc%0A%20%20%20%20%20%20%20%20(M%20%5E%20e)%20%5E%20d%20%3D%20M%20%5E%20(e%20*%20d)%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%3D%20by%20rw%20%5B%3C-pow_mul%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20_%20%20%20%20%20%20%20%3D%20M%20%5E%20(1%20%2B%20%CF%86%20(p%20*%20q)%20*%20k)%20%20%20%3A%3D%20by%20rw%20%5Bhde%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20_%20%20%20%20%20%20%20%3D%20M%20*%20(M%20%5E%20%CF%86%20(p%20*%20q))%20%5E%20k%20%20%20%3A%3D%20by%20rw%20%5Bpow_add%2C%20pow_one%2C%20pow_mul%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20_%20%20%20%20%20%20%20%3D%20M%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%3D%20by%20rw%20%5BZMod.pow_totient%20M%5D%3B%20simp%0A%20%20%20%20%7D%0A%20%20%20%20%7B%0A%20%20%20%20%20%20sorry%0A%20%20%20%20%7D%0A\">see live</a>.</p>\n<p>Now using <code>eq0 : (M ^ e) ^ d = M</code> (in terms of <code>(ZMod (p * q))ˣ</code> objects) I'd like to switch back to <code>m = ((m ^ e) ^ d) % (p * q)</code> (in terms of integers).</p>\n<p>I guess that involves coercions at some point but honestly I have no idea how to proceed. Would someone be able to help me? (regarding the first case of <code>by_cases</code> only, I'll try to implement the other one on my own)</p>",
        "id": 401778298,
        "sender_full_name": "ElCondor",
        "timestamp": 1699886758
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"o\">{</span>\n      <span class=\"k\">let</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Units</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">*</span> <span class=\"n\">q</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">ZMod.unitOfCoprime</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n      <span class=\"k\">have</span> <span class=\"n\">eq0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">^</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"k\">calc</span>\n        <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">^</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">M</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">)</span>               <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">&lt;-</span><span class=\"n\">pow_mul</span><span class=\"o\">]</span>\n            <span class=\"n\">_</span>       <span class=\"bp\">=</span> <span class=\"n\">M</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">*</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">k</span><span class=\"o\">)</span>   <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hde</span><span class=\"o\">]</span>\n            <span class=\"n\">_</span>       <span class=\"bp\">=</span> <span class=\"n\">M</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">^</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">*</span> <span class=\"n\">q</span><span class=\"o\">))</span> <span class=\"bp\">^</span> <span class=\"n\">k</span>   <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_add</span><span class=\"o\">,</span> <span class=\"n\">pow_one</span><span class=\"o\">,</span> <span class=\"n\">pow_mul</span><span class=\"o\">]</span>\n            <span class=\"n\">_</span>       <span class=\"bp\">=</span> <span class=\"n\">M</span>                         <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ZMod.pow_totient</span> <span class=\"n\">M</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n      <span class=\"c1\">-- eq0 is an equality in (Z/pqZ)^*. Change it to an equality in Z/pqZ</span>\n      <span class=\"n\">replace</span> <span class=\"n\">eq0</span> <span class=\"o\">:=</span> <span class=\"n\">congrArg</span> <span class=\"n\">Units.val</span> <span class=\"n\">eq0</span>\n      <span class=\"c1\">-- now move the \"invisible to mathematicians\" map from (Z/pqZ)^* to Z/pqZ so that</span>\n      <span class=\"c1\">-- it applies directly to M, not (M^e)^d</span>\n      <span class=\"n\">push_cast</span> <span class=\"n\">at</span> <span class=\"n\">eq0</span>\n      <span class=\"c1\">-- Now turn M back into m</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">unitOfCoprime</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">eq0</span>\n      <span class=\"c1\">-- now move the \"invisible to mathematicians\" map from Z to Z/pqZ so it applies</span>\n      <span class=\"c1\">-- to (m^e)^d not m</span>\n      <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"n\">eq0</span>\n      <span class=\"c1\">-- now use the lemma saying (↑a : ZMod n) = (↑b : ZMod n) ↔ a % n = b % n</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat_cast_eq_nat_cast_iff'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">eq0</span>\n      <span class=\"c1\">-- and now we can rewrite it in the goal</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq0</span><span class=\"o\">]</span>\n      <span class=\"c1\">-- and finally apply the lemma saying a % b = a if a &lt; b</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">mod_eq_of_lt</span> <span class=\"n\">hm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"o\">}</span>\n</code></pre></div>\n<p>This really is harder than it should be, but there's my effort.</p>",
        "id": 401785946,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1699888844
    }
]