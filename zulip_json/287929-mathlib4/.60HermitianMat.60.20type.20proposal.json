[
    {
        "content": "<p>After lots of issues with <code>Matrix.IsHermitian</code> essentially being used \"as if it were data\" (see <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/Force.20visibility.20of.20certain.20proof.20terms/near/493965205\">#lean4 &gt; Force visibility of certain proof terms @ üí¨</a> ), we made a <code>HermitianMat</code> type that works a lot cleaner. In particular:</p>\n<ul>\n<li>For things involving eigenvalues, you can now write things like <code>(n ‚Ä¢ A + B ^ 3).eigenvalues</code> instead of <code>((hA.smul n).add (hB.pow 3)).eigenvalues</code>.</li>\n<li>This makes rewriting of terms actually doable in the normal way. Having to rewrite equalities of Hermitian matrices was pretty much hell otherwise.</li>\n<li>Traces now give the \"right\" type: the trace of a <code>HermitianMat n ‚Ñö</code> is a ‚Ñö and the trace of a <code>HermitianMat n NNReal</code> is an NNReal, but the trace of a <code>HermitianMat n ‚ÑÇ</code> or <code>[RCLike ùïú] HermitianMat n ùïú</code>is a ‚Ñù. It figures out the correct type via a new <code>IsMaximalSelfAdjoint</code> typeclass.</li>\n<li>Similarly, you can take the inner product of two HermitianMats and get the 'right' type out.</li>\n</ul>\n<p>This is pretty important in our quantum information project, where \"trace of a Hermitian matrix\" or \"trace of a Hermitian matrix against another\" (the inner product) is a fundamental object that needs to be interpreted as a real number. We have the lemmas that this flexible notion of trace respects the properties you expect it to.</p>\n<p>Before shaping this up into a PR for Mathlib, I was looking for feedback. I think the <code>IsMaximalSelfAdjoint</code> trick is neat, but others might dislike it / find it hacky. Also wondering if there are any missing things about converting <code>HermitianMat</code> back and forth with <code>Matrix</code> - like, I have the coercion, it's a subtype, etc. but maybe there are other helper lemmas I'm missing.</p>",
        "id": 497024493,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738335203
    },
    {
        "content": "<p>Is the proposed type different to <code>selfAdjoint (Matrix _ _ _)</code>?</p>",
        "id": 497048795,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738342533
    },
    {
        "content": "<p>I guess this might be the same. I did look at that very briefly but I wasn't sure what kinds of problems I would get by defining my data to be of type <code>AddSubgroup ..</code>.</p>\n<p>And the main thing was that I wanted trace/inner products. And, carrying around a whole bunch of <code>selfAdjoint (Matrix n n R)</code> at each point felt like it would be so painfully verbose...</p>",
        "id": 497057645,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738345673
    },
    {
        "content": "<p>Oh, and things like square roots / logs / eigenvalues that would only make sense if it's a matrix</p>",
        "id": 497057831,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738345738
    },
    {
        "content": "<p>Oops: I realized I forgot to include the actual code that I'm proposing. <a href=\"https://github.com/Timeroot/Lean-QuantumInfo/blob/main/QuantumInfo/ForMathlib/HermitianMat.lean\">https://github.com/Timeroot/Lean-QuantumInfo/blob/main/QuantumInfo/ForMathlib/HermitianMat.lean</a></p>",
        "id": 497063895,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738347930
    },
    {
        "content": "<p>I encourage you to use the continuous functional calculus. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=cfc#doc\">docs#cfc</a> there is already an instance for Hermitian matrices.</p>",
        "id": 497082885,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738355241
    },
    {
        "content": "<p>And indeed, as Eric suggests, I think you just want to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SelfAdjoint#doc\">docs#SelfAdjoint</a> for some things.</p>",
        "id": 497083070,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738355323
    },
    {
        "content": "<p>Yes, I looked at those! And tried, and didn't have a good time. Really I wanted the fact that I can do traces and inner products of Hermitian matrices and get reals out, and I couldn't find any way to do things like that in cfc</p>",
        "id": 497084648,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738356006
    },
    {
        "content": "<p>If there's a better way, I am definitely all ears</p>",
        "id": 497084681,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738356020
    },
    {
        "content": "<p>Btw this also lets you take the trace of <code>HermitianMat n1 (Matrix n2 n2 R)</code> and get out a <code>HermitianMat n2 R</code>, which I think is pretty nice</p>",
        "id": 497089286,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738357874
    },
    {
        "content": "<p>I meant you should use the <code>cfc</code> for square roots, logs, etc.</p>",
        "id": 497097587,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738361609
    },
    {
        "content": "<p>Oh! Yes that I agree with, I want to but just hadn't a need to myself yet</p>",
        "id": 497098894,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738362189
    },
    {
        "content": "<p>okay, I've just had a look at the code. Here are a few comments:</p>\n<ol>\n<li>You're duplicating a lot of the <code>SelfAdjoint</code> API, which suggests that this is actually what you want to use.</li>\n<li>Why do you want to create an inner product only for Hermitian matrices? It works just as well as a complex-valued inner product for all matrices (and then you can show that it takes real values on hermitian pairs).</li>\n<li>Likewise, the trace is just the matrix trace, and you can simply show that it's real when the matrix is selfadjoint.</li>\n</ol>\n<p>I guess the key question is this: why do you want to get back to <code>‚Ñù</code> so badly? Please note: I'm not claiming there are no valid reasons.</p>\n<p>One thing you could do: get an equivalence between <code>SelfAdjoint ùïú ‚âÉ‚Çó·µ¢[‚Ñù] ‚Ñù</code>. Then, if you wanted, you could create bundled maps (like <code>SelfAdjoint.matrixTrace</code>) from <code>SelfAdjoint (Matrix n n R)</code> to <code>SelfAdjoint R</code> and via this equivalence above you could get them in <code>‚Ñù</code> when <code>R := ùïú</code>. I haven't thought through all the consequences of this idea, but it's the idea that comes to me if you desperately want to end up back in <code>‚Ñù</code>.</p>",
        "id": 497100490,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738362986
    },
    {
        "content": "<p>We were initially doing what you suggested in points 2 &amp; 3: a complex trace and inner product, which is valued in C, and we prove is real. We got decently far with this and it works, but it became a pain when this gets mixed up into other definitions.</p>\n<p>Context: We're trying to prove results from quantum information theory. The matrices all are complex, but most of the discipline (you could argue) is about bounding real numbers that emerge as inner products of Hermitian matrices. (The trace is of course the special case of inner product with the identity.)</p>\n<p>For example: von Neumann entropy is Tr(M * M.log). Conditional entropy is similar but involves a partial trace as well. Relative entropy is something like Tr(A * (A.log - B.log)). These real numbers obey many inequalities; for instance relative entropy is jointly convex in its two arguments (which is a significantly nontrivial result we're working to establish in Lean). Other numbers have operational interpretations as probabilities. Many times we need to extend the values to ENNReal or EReal, and there are lots of limsup's and liminf's.</p>\n<p>So one option is you define the value with Matrix.trace, and now your entropy values are all complex. That's pretty bad; you can use <code>ComplexOrder</code> for simple inequalities, but you can't use EReal and most Filter lemmas fall apart. We really <em>must</em> get back to reals. So, we define these quantities with <code>Complex.re (...).trace</code> so that you have a real number. You get all your lemmas in a row that indeed this trace is purely real, but now you're pushing these facts in and out of <a href=\"http://Complex.re\">Complex.re</a> every step.</p>\n<p>It became a huge pain, which is why we decided to refactor it this way: define a \"Matrix.rinner\" (real inner) function that has the <a href=\"http://Complex.re\">Complex.re</a> already, only accepts Hermitian matrices, and then it has many nice simp lemmas. But then we ran into these problems with <code>IsHermitian</code> being a Prop we were passing in everywhere, which made actually doing algebra and rewrites impossible. So the solution we settled on was bundling the IsHermitian with the matrix -- <code>HermitianMat</code>.</p>",
        "id": 497102598,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738363967
    },
    {
        "content": "<p>I hope this sort of motivates it</p>",
        "id": 497102661,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738364007
    },
    {
        "content": "<p>Sure, that's reasonable motivation, but it doesn't explain why you opt for <code>HermitianMat</code> over <code>SelfAdjoint</code>.</p>",
        "id": 497103260,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738364369
    },
    {
        "content": "<p>I'll take a look at you suggestion about the Selfadjoint trace. That sounds promising</p>",
        "id": 497103283,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738364380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60HermitianMat.60.20type.20proposal/near/497103260\">said</a>:</p>\n<blockquote>\n<p>Sure, that's reasonable motivation, but it doesn't explain why you opt for <code>HermitianMat</code> over <code>SelfAdjoint</code>.</p>\n</blockquote>\n<p>I guess I didn't think about taking that and equipping it with the trace and inner I wanted. I'll give it a shot!</p>",
        "id": 497103398,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738364416
    },
    {
        "content": "<p>By the way, I would first do the inner product on all matrices (if we don't already have it), then create a bundled one for <code>SelfAdjoint</code>.</p>",
        "id": 497103543,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738364511
    },
    {
        "content": "<p>also, I'm sure that <span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span> has plenty of things to say about all this.</p>",
        "id": 497103606,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738364531
    },
    {
        "content": "<p>Alright, I changed the code at the link. Now it's a type alias:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">HermitianMat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddGroup</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">StarAddMonoid</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">selfAdjoint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>That gets me most of the instances that I want. The <code>selfAdjoint</code> only provides inv and zpow instances when you're working over a field (which matrices are not), so I give my own instances for that. This also lets me give the <code>FunLike</code> instance so that it acts like a matrix, and now I can work with my <code>HermitianMat</code> type and use <code>.trace</code> and <code>.inner</code>. I didn't bundle the trace as a hom yet. But the other cfc operations on HermitianMat work -- I have rpow and log.</p>\n<p>(Side note: Why does CFC.log require a norm, and CFC.rpow require other stuff? Both definitions work fine without that.)</p>",
        "id": 497132021,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738387068
    },
    {
        "content": "<p>I'm thinking that if I add the requirement on <code>IsMaximalSelfAdjoint</code> that <code>selfadjMap</code> maps all non-self-adjoint values to 0, then it becomes a subsingleton, which is pretty nice</p>",
        "id": 497132095,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738387105
    },
    {
        "content": "<p>The main issue with this is that we multiply hermitian matrices all the time, and of course <code>AB</code> is not necessarily hermitian for hermitian <code>A</code> and <code>B</code>. For instance, how do we deal with <code>tr(AB)</code>? We'd like this to be real, but <code>AB</code> is not hermitian in general.</p>",
        "id": 497167295,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1738418807
    },
    {
        "content": "<p>Alex, this is a plug for my own paper, so you can take it with a grain of salt: <a href=\"https://arxiv.org/abs/2501.15639\">https://arxiv.org/abs/2501.15639</a>. Among other things, it may help explain the value of unbundling, at least in certain circumstances.</p>",
        "id": 497169658,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738420954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60HermitianMat.60.20type.20proposal/near/497132021\">said</a>:</p>\n<blockquote>\n<p>(Side note: Why does CFC.log require a norm, and CFC.rpow require other stuff? Both definitions work fine without that.)</p>\n</blockquote>\n<p>That's probably mostly an accident. I would just tell you to change it, but I've been meaning to write a library note about what <code>variable</code> assumptions one should choose when developing general CFC theory.</p>",
        "id": 497169847,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738421112
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Fr√©d√©ric Dupuis</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60HermitianMat.60.20type.20proposal/near/497167295\">said</a>:</p>\n<blockquote>\n<p>The main issue with this is that we multiply hermitian matrices all the time, and of course <code>AB</code> is not necessarily hermitian for hermitian <code>A</code> and <code>B</code>. For instance, how do we deal with <code>tr(AB)</code>? We'd like this to be real, but <code>AB</code> is not hermitian in general.</p>\n</blockquote>\n<p>I think this is the point of <code>HermitianMat.inner</code>.</p>",
        "id": 497170106,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738421349
    },
    {
        "content": "<p>Yeah, my view is (and was, before using Lean) that we really don't multiply Hermitian matrices. The inner product is really the Hadamard product, because it's the dot product as a real module. </p>\n<p>Sometimes we multiply them, but really it's \"conjugate one by another\", which is a separate thing; and sometimes we take their commutator or anticommutator (divided by i, ideally), which are again separate bilinear maps from Hermitian matrices to themselves.</p>",
        "id": 497174429,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738424640
    },
    {
        "content": "<p>selfAdjoint already has <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsSelfAdjoint.conjugate#doc\">docs#IsSelfAdjoint.conjugate</a> which captures the second thing - I plan to bundle that into an operation, at least within the quantuminfo repo</p>",
        "id": 497174727,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738424850
    },
    {
        "content": "<p>Oh I see, I missed the part about <code>inner</code>.</p>",
        "id": 497175996,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1738425798
    },
    {
        "content": "<p>Alex, forgive my ignorance about physics / quantum information theory, but isn't iterated measurement exactly multiplication of selfadjoint matrices? What else is the Heisenberg uncertainty principle than the statement that certain selfadjoints (position and momentum) don't commute? In C*-algebra theory, I multiply selfadjoint elements all the time.</p>\n<p>Now, honestly, if <code>HermitianMat</code> is really that useful (even as an <code>abbrev</code>), I'm happy for that to be the case. I just want to make sure that we truly can't solve your issues with existing machinery.</p>",
        "id": 497177064,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738426621
    },
    {
        "content": "<p>Good question! But I see it like this: you've got a density matrix rho, and some measurement; the measurement is most generally a POVM, a collection of PSD Hermitian matrices that sum to the identity. Call them M_j.</p>\n<p>Then you get outcome j with probability Tr(rho * M_j), and in that event, your new state is (M_j / ‚àöTr(rho * M_j)) * rho * (M_j / ‚àöTr(rho * M_j)). So, you get outcomes by inner products, and you update your state by conjugation.</p>\n<p>The uncertainty principle then comes about as, if you conjugate by A and then B, that's different than the opposite order, unless they commute; similarly, the outcome probabilities will change.</p>",
        "id": 497177755,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738427182
    },
    {
        "content": "<p>If you're interested in developing quantum information in Lean on large scale, I think specializing everything to matrices on day 1 is not the way to go. It's very tempting to do like on paper and only worry about finite dimensions, but I would argue that in the early stages (which is very much where we are right now), the right level of generality is C*-algebras. All the basic constructions live there: the functional calculus, completely positive maps (which I'm working on now), etc. Working at that level of generality usually doesn't make proofs harder in Lean (at least now that we have the CFC :-)), and the big bonus is (1) that we can PR our work to mathlib, and (2) it leaves the door open to infinite-dimensional quantum information -- it wouldn't be so nice if the answer to \"how do I define Gaussian states\" were \"sorry, we only do finite dimensions, you'll have to rewrite everything from scratch\". And if, at some point, we feel the need to go with finite dimensions for now because the infinite-dimensional case would take us a bit too far afield (say, when defining the von Neumann entropy), then I think it's best to do it in a way that is easy to generalize later, for instance by using a <code>[FiniteDimensional A]</code> assumption instead of having matrices hardcoded in.</p>\n<p>I guess what I'm trying to say is: join us! :-)</p>",
        "id": 497215939,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1738461089
    },
    {
        "content": "<p>Haha, I appreciate that. :)<br>\nI understand and respect the reasoning you give; it makes sense. But, I am inclined to keep with matrices, for essentially three reasons.</p>\n<p>First: I know essentially nothing about C*-algebras / functional analysis. While I might be able to learn enough to muddle my way through some proofs, any definitions and theorems I write would probably be overly specialized, or wrong definitions in some subtle way. So in that sense, I don't think I'm very qualified to 'join' you. <span aria-label=\"smiling face with tear\" class=\"emoji emoji-1f972\" role=\"img\" title=\"smiling face with tear\">:smiling_face_with_tear:</span></p>\n<p>Second: The theorems I've got the most interest in proving are pretty much all restricted to the finite-dimensional case anyway. I would like to do things with quantum channel capacities, quantum circuits, maybe a proof that GHZ+W states are the only two types of entanglement for qutrits; I think these would be very nice to have formalized. And, by and large, they're only applicable to the finite dimensional case. Gaussian states are certainly a good example of why people would want to do something infinite dimensional, but it's just a large motivation to me.</p>\n<p>And third: I <em>am</em> trying to keep the repository (both what I write, and what a few others have been contributing) with a reasonable level of API separation, so that if - eventually - all of the definitions are available in mathlib to start doing (infinite-dimensional) quantum theory, it should be portable without a total rewrite. This is in part why I think that encapsulating most of the stuff I need into a HermitianMat type is desirable. By doing it all in terms of <code>HermitianMat.trace</code>, I could hope that eventually HermitianMat just gets Find-and-replaced for \"HermitianTracialOperator\" or similar, and most theorems can be fixed up without too much intervention.</p>",
        "id": 497285539,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738525956
    },
    {
        "content": "<p>I recognize that none of those reasons are relevant to wanting <code>HermitianMat</code> in Mathlib of course.<br>\nIs it fair to say: it seems like the benefit of including this in Mathlib is not clear at the moment; we'll try to \"battle-test\" it a bit more in quantumInfo, and maybe in a few months or something see if it has proven to be useful+workable enough to upstream?</p>",
        "id": 497286381,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738526620
    },
    {
        "content": "<p>It sounds like a wonderful opportunity for you to learn stuff about the infinite dimensional case.</p>",
        "id": 497293752,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1738532589
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60HermitianMat.60.20type.20proposal/near/497285539\">said</a>:</p>\n<blockquote>\n<p>First: I know essentially nothing about C*-algebras / functional analysis. While I might be able to learn enough to muddle my way through some proofs, any definitions and theorems I write would probably be overly specialized, or wrong definitions in some subtle way. So in that sense, I don't think I'm very qualified to 'join' you. <span aria-label=\"smiling face with tear\" class=\"emoji emoji-1f972\" role=\"img\" title=\"smiling face with tear\">:smiling_face_with_tear:</span></p>\n</blockquote>\n<p>I'm actually in the same boat here: all of my work in quantum information has been in finite dimensions, and I'm not that comfortable with C*-algebras and von Neumann algebras either. It turns out that it's not that big of a problem, as long as there are operator algebra experts around (i.e. <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> ) to make sure I'm not doing anything crazy, and I am indeed learning a lot about the infinite-dimensional case in the process.</p>",
        "id": 497312145,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1738546499
    },
    {
        "content": "<p>Alex, you're at Waterloo, right? There should be plenty of people there from whom you can learn C-*algebra theory. Although I'm happy to help you out too.</p>",
        "id": 497312288,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738546601
    },
    {
        "content": "<p>Haha, I appreciate all the optimism, and certainly learning about C*-algebras would be rewarding, but also there's only so much time in a day. :') I don't know if it will reach a high-enough priority for me.</p>",
        "id": 497478720,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738599296
    },
    {
        "content": "<p>But, ok, I'll mentally save it as \"things I really should learn\".</p>",
        "id": 497478796,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738599311
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span> , your comment is encouraging, maybe I'll give it a shot at some point.</p>",
        "id": 497478928,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738599349
    },
    {
        "content": "<p>And Alex, to be clear, the benefits go in both directions. Having you around to pressure me / us about the finite dimensional case is valuable.</p>",
        "id": 497479517,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738599475
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span> mathlib always wants stuff in the biggest generality that it makes reasonable sense. So you should just work in this generality and <em>pretend</em> that you're doing the finite-dimensional case. A lot of the early proofs won't need it and if you do need it later on then just assume it from that point on. But the definitions have to be in the right generality, even if the theorems only work in the finite dimensional case</p>",
        "id": 497501324,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738605853
    }
]