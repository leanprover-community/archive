[
    {
        "content": "<p>I saw that <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/Integral/RieszMarkovKakutani.html#rieszContentAux\">rieszContentAux</a> does not have the proof that <code>rieszContent</code> is a Borel measure on <code>X</code>. For this purpose, following Rudin \"Real and complex analysis\", one needs certain variations of Urysohn's lemma. I wrote them here.<br>\n<a href=\"https://github.com/yoh-tanimoto/mathlib4/blob/yoh/yoh/RMK/urysohn.lean\">https://github.com/yoh-tanimoto/mathlib4/blob/yoh/yoh/RMK/urysohn.lean</a></p>\n<p>Will this be useful? <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> </p>\n<p>I could make a pull request, but I think the file needs some refactoring, in particular, one should be able to use <code>prod_mem</code> in the induction, but I haven't found a way. Could someone help?</p>",
        "id": 434005302,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1713432483
    },
    {
        "content": "<p>If you'll open a PR (even with <code>sorry</code>s), it will be much easier for other people to comment/review: e.g., one can switch to your branch, get olean cache, and fix a <code>sorry</code> or two.</p>",
        "id": 434269090,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713493298
    },
    {
        "content": "<p>The <code>WIP</code> tag for PR (and possibly also the <code>help-needed</code>) are precisely designed for this.</p>",
        "id": 434324971,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1713519534
    },
    {
        "content": "<p>thanks for your comments!<br>\nJust PRed <a href=\"https://github.com/leanprover-community/mathlib4/pull/12266\">#12266</a></p>",
        "id": 434353394,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1713530231
    },
    {
        "content": "<p>Are you aware that we already have some material on contents, like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Content.measure_eq_content_of_regular#doc\">docs#MeasureTheory.Content.measure_eq_content_of_regular</a> (and all this file), which shows how a content automatically gives a measure under quite minimal assumptions? I guess the idea of the initial authors was to check these abstract assumptions for their Riesz content, instead of redoing everything by hand.</p>",
        "id": 434356651,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1713531277
    },
    {
        "content": "<p>(The standard reference for this approach is Halmos' book on measure theory, instead of Rudin).</p>",
        "id": 434357987,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1713531698
    },
    {
        "content": "<p>ah no, I wasn't! Thank you very much, I was wondering why <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/Integral/RieszMarkovKakutani.html#rieszContentAux\">rieszContentAux</a> remained at that point. But it seems that additivity is missing?</p>",
        "id": 434358701,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1713531927
    },
    {
        "content": "<p>Yes, you are right, additivity is missing, there are definitely things that still have to be done!</p>",
        "id": 434360240,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1713532435
    },
    {
        "content": "<p>ok, if no one else is working on it, I will try to do that (I did it to some extent following Rudin, but it shouldn't be to difficult to adapt to <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/Measure/Content.html#MeasureTheory.Content.measure_eq_content_of_regular\">MeasureTheory.Content.measure_eq_content_of_regular</a></p>",
        "id": 434360872,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1713532640
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"513978\">@Jesse Reimann</span> <span class=\"user-mention\" data-user-id=\"373986\">@Kalle Kytölä</span> is there any plan to expand <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/Integral/RieszMarkovKakutani.html#rieszContentAux\">rieszContentAux</a>?</p>",
        "id": 434363433,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1713533409
    },
    {
        "content": "<p>I am very sorry that this has stalled.</p>\n<p>Jesse wrote a proof of the Riesz representation theorem on compact Hausdorff spaces in Lean3 in 2022. The intention was (and still is) to PR that to Mathlib. The proof used <code>NNReal</code>-valued bounded continuous functions (partly because nonnegativity is used in measure theory and partly to phrase the positive linear functional assumption concisely).</p>\n<p>The main unsatisfactory thing about the implemented proof was related to the fact that with <code>NNReal</code> values, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BoundedContinuousFunction#doc\">docs#BoundedContinuousFunction</a> has no (truncated) subtraction or multiplication, so those were built in ad hoc ways in the proof (they are used slightly more in Riesz proof compared to for example the characterizations of weak convergence of probability measures, but both would benefit from having subtraction and multiplication). We therefore intended to first generalize the type-classes in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BoundedContinuousFunction.instSub#doc\">docs#BoundedContinuousFunction.instSub</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BoundedContinuousFunction.instMul#doc\">docs#BoundedContinuousFunction.instMul</a> before fully porting the content from Lean3 to Lean4 and PRing. (I'll ask a question below on the best ways to do that with the current state.)</p>\n<p>Unfortunately we have not yet gotten to it (the semester and other things got in the way soon after Mathlib4 came into proper existence).</p>",
        "id": 434415114,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1713551783
    },
    {
        "content": "<p>My planned refactors to allow subtraction and multiplication of bounded continuous nonnegative functions involved introducing type classes <code>HasBoundedSub</code>, <code>HasBoundedMul</code> (perhaps with better naming) and perhaps refactoring the boundedness assumption in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BoundedContinuousFunction#doc\">docs#BoundedContinuousFunction</a> to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bornology.IsBounded#doc\">docs#Bornology.IsBounded</a>. We discussed these a bit with <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> in the summer. But actually since the summer, some metric boundedness phrasings were changed in Mathlib4, so I don't know (and have not thought about it much) what is currently the best way to generalize the subtraction and multiplication in <code>BoundedContinuousFunction</code>.</p>",
        "id": 434415230,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1713551841
    },
    {
        "content": "<p>I'm in a workshop with lectures to prepare for another week + epsilon, but after that I would have a bit more time to think about what is the best way. But I also do not want to hold back any alternative approaches to Riesz representation theorem which are satisfactorily implemented and don't suffer from the <code>NNReal</code>-valuedness issue that we had in our approach! (Although I would still think those issues are worth addressing even just as general improvements of Mathlib.)</p>",
        "id": 434415535,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1713551974
    },
    {
        "content": "<p>I see, thanks for clarifying the background! Actually I am trying to write everything under <code>Λ : C(X, ℝ) →ₗ[ℝ] ℝ) (hΛ : ∀ (f : C(X, ℝ)), 0 ≤ f → 0 ≤ Λ f)</code>, because I didn't know until today that it was better to use <code>EEReal</code> for the measure theory. I think I will see how far I can go with this.</p>",
        "id": 434441592,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1713563793
    },
    {
        "content": "<p>On the other hand, it is natural to use <code>Λ : C(X, ℝ) →ₗ[ℝ] ℝ) (hΛ : ∀ (f : C(X, ℝ)), 0 ≤ f → 0 ≤ Λ f)</code> when one wants to apply this to prove, for example, the spectral decomposition in infinite dimensional Hilbert space (or even <code>ℂ</code>)</p>",
        "id": 434442464,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1713564318
    },
    {
        "content": "<p>There is also the issue that, currently, the linear functional is defined on bounded continuous functions. However, for Riesz-Markov-Kakutani on locally compact spaces, one should rather work with linear functionals on continuous functions with compact support. I don't know if we even have the bundled version of this space!</p>",
        "id": 434473081,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1713592065
    },
    {
        "content": "<p>Yes, the main reasons we chose <code>BoundedContinuousFunction</code> in the compact case was that (a) it matches with weak convergence of finite measures and (b) it had a good topology instance already so for example stating that every positive linear functional automatically became continuous did not involve introducing any new topologies.</p>\n<p>But indeed for locally compact spaces one can no longer use <code>BoundedContinuousFunction</code>. We did not do the locally compact case (just thought a bit about the reduction of that to the compact case), and did not think about whether the implementation should bundle continuity and compact support. I suppose <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> will soon face such choices in the C*-algebra theory?</p>",
        "id": 434475753,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1713594825
    },
    {
        "content": "<p>How do you mean? Note: we do have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZeroAtInftyContinuousMap#doc\">docs#ZeroAtInftyContinuousMap</a> in case that's what you're referring to.</p>",
        "id": 434480176,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713599399
    },
    {
        "content": "<p>In general I won't need the space of continuous functions with compact support (at least not until people want to start doing noncommutative geometry, but that's a long way of I think)</p>",
        "id": 434480385,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713599598
    },
    {
        "content": "<p>I wrote the density of the space of compactly supported continuous functions in <code>C₀</code> here<br>\n<a href=\"https://github.com/yoh-tanimoto/mathlib4/blob/master/yoh/C_c/C_c.lean\">https://github.com/yoh-tanimoto/mathlib4/blob/master/yoh/C_c/C_c.lean</a></p>\n<p>If it's useful, I will add it to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZeroAtInftyContinuousMap#doc\">docs#ZeroAtInftyContinuousMap</a></p>",
        "id": 434480883,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1713600142
    },
    {
        "content": "<p>just PRed the linear-functional version <a href=\"https://github.com/leanprover-community/mathlib4/pull/12290\">#12290</a></p>",
        "id": 434513103,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1713628067
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"382902\">@Yoh Tanimoto</span>, certainly the density result would be nice. Although I think it can be written a bit more concisely. For example, there's no need to get an actual sequence. You can just start with an arbitrary epsilon and then get a function with compact support within that epsilon. This will simplify the proof a bunch. The existence of a sequence (if we wanted it at some point, would follow from the fact that the space is first countable; it's even metrizable).</p>",
        "id": 434525015,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713638641
    },
    {
        "content": "<p>I'll have some comments on <a href=\"https://github.com/leanprover-community/mathlib4/pull/12290\">#12290</a>. But first, a question: where do you need the space to be <code>Normal</code>? I would have expected that locally compact Hausdorff (which implies <em>locally</em> normal) to be enough.</p>",
        "id": 434525139,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713638740
    },
    {
        "content": "<p>OK, thanks for your comment! I will remove the part taking the sequence. May I add you as a reviewer  to <a href=\"https://github.com/leanprover-community/mathlib4/pull/12290\">#12290</a>?</p>\n<p>As for <a href=\"https://github.com/leanprover-community/mathlib4/pull/11290\">#11290</a>, I use <code>NormalSpace X</code> wherever I apply the version of Urysohn's lemma <a href=\"https://github.com/leanprover-community/mathlib4/pull/12266\">#12266</a> that uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Separation.html#normal_separation\">normal_separation</a>. Maybe that can be done with weaker assumption?</p>",
        "id": 434525630,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1713639160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"382902\">Yoh Tanimoto</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/434525630\">said</a>:</p>\n<blockquote>\n<p>May I add you as a reviewer to <a href=\"https://github.com/leanprover-community/mathlib4/pull/12290\">#12290</a>?</p>\n</blockquote>\n<p>sure</p>",
        "id": 434530196,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713643644
    },
    {
        "content": "<p>My point is that, without having actually read the proof in any detail, I <em>suspect</em> it suffices to apply this lemma after you have already restricted yourself to a compact subset of your space (in which case, for closed sets <em>within</em> this set, the normal separation would be valid without assuming <code>NormalSpace X</code>).</p>",
        "id": 434530411,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713643833
    },
    {
        "content": "<p>OK, I will check the proof of my lemma</p>",
        "id": 434574808,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1713691807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/434473081\">said</a>:</p>\n<blockquote>\n<p>There is also the issue that, currently, the linear functional is defined on bounded continuous functions. However, for Riesz-Markov-Kakutani on locally compact spaces, one should rather work with linear functionals on continuous functions with compact support. I don't know if we even have the bundled version of this space!</p>\n</blockquote>\n<p>A bundled version of <code>ContDiff</code> and then a few restrictions of that (adding <code>HasCompactSupport</code> or something about integrability of iterated derivatives) would have been useful to me as well recently, I started a bare-bones version for PNT+ for functions defined on <code>\\R</code> but a proper version with appropriate generality would likely have its place in Mathlib</p>",
        "id": 434578137,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1713694977
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/434578137\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/434473081\">said</a>:</p>\n<blockquote>\n<p>There is also the issue that, currently, the linear functional is defined on bounded continuous functions. However, for Riesz-Markov-Kakutani on locally compact spaces, one should rather work with linear functionals on continuous functions with compact support. I don't know if we even have the bundled version of this space!</p>\n</blockquote>\n<p>A bundled version of <code>ContDiff</code> and then a few restrictions of that (adding <code>HasCompactSupport</code> or something about integrability of iterated derivatives) would have been useful to me as well recently, I started a bare-bones version for PNT+ for functions defined on <code>\\R</code> but a proper version with appropriate generality would likely have its place in Mathlib</p>\n</blockquote>\n<p>I did a start on that this summer in <a href=\"https://github.com/leanprover-community/mathlib4/tree/AD_tests_functions\">branch#AD_tests_functions</a>, which depend on the (very out of date) <a href=\"https://github.com/leanprover-community/mathlib4/pull/5912\">#5912</a>. The main pitfall I fell into (outside of slow continuous linear map instances, which were terrible at the time and are not fully solved AFAIK) is that I wanted to be able to choose the differentiability degree, to be able to state the isomorphism between \"distributions with order less than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>\" and \"distributions where you only require the test functions to be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">C^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>\", and <code>ENat</code> arithmetics made me give up...</p>",
        "id": 434587412,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1713704750
    },
    {
        "content": "<p>Note that the continuous case will have to be done independently because its assumptions are way weaker. The reason I didn't start with this is that the algebraic boilerplate gets super long if we want to have assumptions as fine as for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousMap#doc\">docs#ContinuousMap</a>, but this is a bad reason, and I'd be happy to help setting it up if needed.</p>",
        "id": 434587864,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1713705161
    },
    {
        "content": "<p>Also, some note about the only mathematically interesting thing, which is defining the topology: in the context of distribution theory, the natural topology to put on test functions is <em>not</em> the supremum of the topologies when you fix the compact set, it's the \"locally convex enveloppe\" of it. I don't know if one wants to do the same thing in the continuous case (maybe it doesn't change anything, I haven't thought about it).</p>",
        "id": 434588104,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1713705380
    },
    {
        "content": "<p>And is that choice of topology consistent across different areas of mathematics, or is it really specific to distribution theory ?</p>",
        "id": 434588133,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1713705425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"382902\">Yoh Tanimoto</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/434442464\">said</a>:</p>\n<blockquote>\n<p>On the other hand, it is natural to use <code>Λ : C(X, ℝ) →ₗ[ℝ] ℝ) (hΛ : ∀ (f : C(X, ℝ)), 0 ≤ f → 0 ≤ Λ f)</code> when one wants to apply this to prove, for example, the spectral decomposition in infinite dimensional Hilbert space (or even <code>ℂ</code>)</p>\n</blockquote>\n<p>I think I agree with this. In general I'm not a big fan of abusing the <code>NNReal</code>-modules trick, e.g to talk about pointed convex cones, or other positivity constraints, but I do recognize that it allows for some nice code-factorization. In this case though, intuitively I would say we don't gain anything from it, even on the interface with measure theory, since one still has to convert between <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NNReal#doc\">docs#NNReal</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENNReal#doc\">docs#ENNReal</a> anyway.</p>\n<p>That said, I remember that Kalle had good arguments when we talked about it last summer. I don't remember them exactly, but I'm ready to be convinced again.</p>",
        "id": 434588688,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1713705861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> updated, added a version that finds <code>g</code> in an neighbourhood and commented out the version taking a sequence.<br>\n<a href=\"https://github.com/yoh-tanimoto/mathlib4/blob/yoh/yoh/C_c/C_c.lean\">https://github.com/yoh-tanimoto/mathlib4/blob/yoh/yoh/C_c/C_c.lean</a></p>",
        "id": 434609442,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1713724273
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> to remove the <code>NormalSpace</code> assumption and use only <code>LocallyCompactSpace</code> and <code>T2Space</code>, I guess I will need something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">T2Space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">H1</span> <span class=\"o\">:</span> <span class=\"n\">IsCompact</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H2</span> <span class=\"o\">:</span> <span class=\"n\">IsCompact</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H3</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">SeparatedNhds</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">T2Space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">H1</span> <span class=\"o\">:</span> <span class=\"n\">IsCompact</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H2</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">IsOpen</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">IsOpen</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">Disjoint</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Are there such lemmas already in mathlib? I couldn't find in the file <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Separation.html#t2_separation_compact_nhds\">Mathlib.Topology.Separation</a></p>",
        "id": 434698105,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1713777537
    },
    {
        "content": "<p>I don't know if we have these exact results, but they follow easily from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCompact.disjoint_nhdsSet_left#doc\">docs#IsCompact.disjoint_nhdsSet_left</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCompact.disjoint_nhdsSet_right#doc\">docs#IsCompact.disjoint_nhdsSet_right</a>. Let me look if I find something more direct</p>",
        "id": 434699070,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1713777830
    },
    {
        "content": "<p>ah ok, it was in that file on Compact sets, thanks!</p>",
        "id": 434700406,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1713778239
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"382902\">@Yoh Tanimoto</span> one might want a version using trinary. It would also be nice to see it used in Gel'fand duality.</p>",
        "id": 435671206,
        "sender_full_name": "Dean Young",
        "timestamp": 1714172863
    },
    {
        "content": "<p>I don't understand that comment. Also, note we already have Gelfand duality.</p>",
        "id": 435671623,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714173212
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>  Let <code>X</code> be a compact Hausdorff topological space, in which we have that, for any closed disjoint subsets <code>C₁</code> and <code>C₂</code>, there are open disjoint neighborhoods containing each. </p>\n<p>Lemma: let <code>x,y : X</code> be distinct points. There is a continuous function <code>f : X ⭢ [0,1]</code> such that <code>f x = 0</code> and <code>f y = 1</code>.</p>\n<p>The proposed proof-strategy is to define trinary-nth-digit-functions <code>dₙ : X ⭢  {0,1,2}</code> such that, defining the function <code>f : X ⭢ [0,1]</code> such that <code>f</code> has trinary expansion <code>d₀d₁d₂...</code>, <code>f</code> is continuous, <code>f x = 0</code>, and <code>f y = 1</code>, using induction.</p>\n<p>The use of trinary reflects two ends and a middle arising from the condition involving disjoint neighborhoods and use of closures where appropriate.</p>",
        "id": 435681197,
        "sender_full_name": "Dean Young",
        "timestamp": 1714181984
    },
    {
        "content": "<p>Given this lemma, we can conclude that <code>φ : X ⭢ C*-alg(C(X,ℝ),ℝ)</code> is injective using that <code>φ x</code> and <code>φ y</code> are different on the <code>f</code> shown to exist in the lemma.</p>",
        "id": 435681655,
        "sender_full_name": "Dean Young",
        "timestamp": 1714182355
    },
    {
        "content": "<p>Thanks for letting me know about the Gel'fand proof being in there. For surjectivity of <code>φ : X ⭢ C*-alg(C(X,ℝ),ℝ)</code>, I think I like something like this: fix <code>ν :  C*-alg(C(X,ℝ),ℝ)</code>, which we aim to show is contained in the image of <code>φ</code> define <code>p x := ∃(f : X ⭢ [0,∞)),ν f = 0,(∃ U : Neighborhood(x),∀(y : U),f y = 0)</code>.</p>\n<p>Lemma: there is <code>x</code> such that <code>¬ p x</code>. For a contradiction, suppose that <code>∀(x:X),p x </code>. Using compactness of <code>X</code>, we can conclude that there are finitely many functions <code>f₁,...,fₙ : X ⭢ ℝ</code>, whose zero-sets cover <code>X</code>, and which have <code>ν fᵢ ≠ 0</code>. Define <code>Πᵢ fᵢ</code>.  Then <code>0 ≠ Πᵢ ν(fᵢ) = ν (Πᵢ fᵢ )= ν (0) =  0</code>, which contradiction shows the lemma.</p>\n<p>From the lemma we have an <code>x</code> such that <code>¬ p x</code> for this <code>ν</code>. It follows that <code>ν = φ x</code>. </p>\n<p>A similar proof can be found <a href=\"https://mathoverflow.net/questions/339566/norms-as-points-in-cx\">here</a>.</p>\n<p>Edit: Jireh pointed out that this should be balanced ternary. It has an error as is.</p>",
        "id": 435682730,
        "sender_full_name": "Dean Young",
        "timestamp": 1714183264
    },
    {
        "content": "<p>It's still not clear to me what you're trying to do. What is <code>φ</code>? From what you wrote, it definitely seems like you're trying to construct one of the natural isomorphisms in Gelfand duality, but as I said, we already have it: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WeakDual.CharacterSpace.homeoEval#doc\">docs#WeakDual.CharacterSpace.homeoEval</a>. We also have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=gelfandStarTransform#doc\">docs#gelfandStarTransform</a>, and the naturality is included in that file too.</p>",
        "id": 435685434,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714186443
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> The two goals are the first lemma concerning separation with use of trinary and proving Gel'fand duality. The mentioned <code>φ</code> is the same as the one you mention, with the construction skipped here, and no naturality shown either.</p>\n<p>Overall I was interested in the use of trinary and how it related to the normal separation condition.</p>\n<p>It's possible I misread the topic (it's a variation of the proof and not the result). To sum it up, the use of trinary and construction of <code>dᵢ</code> is potentially easier than other approaches.</p>",
        "id": 435688948,
        "sender_full_name": "Dean Young",
        "timestamp": 1714190273
    },
    {
        "content": "<p>Do you mean you would like to use trinary to prove Urysohn's lemma?</p>",
        "id": 435742531,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1714213004
    },
    {
        "content": "<p>(just FYI: it's ternary)</p>",
        "id": 435755242,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714222638
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"382902\">@Yoh Tanimoto</span>  it looks like a proof of Urysohn's lemma which uses trinary in the construction of a functional <code>f : X ⭢ [0,1]</code>, constructing each digit <code>dᵢ</code> separately.</p>",
        "id": 435767346,
        "sender_full_name": "Ron Z.",
        "timestamp": 1714232476
    },
    {
        "content": "<p>ok, I'm not sure if mathlib wants the same theorem with a different proof.<br>\nWhat is your thought? <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span></p>",
        "id": 435769313,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1714233785
    },
    {
        "content": "<p>You might have to modify it to use binary. Let <code>X</code> be a normal topological space, so that for any disjoint closed subsets <code>C₁,C₂</code>, you can take the interior of the complement of the neighborhood of <code>C₁</code> instead of just any neighborhood. This suggests binary.</p>",
        "id": 435770585,
        "sender_full_name": "Ron Z.",
        "timestamp": 1714234859
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"711507\">@Ron Z.</span> sorry, you're right. They have to be binary digits, and the <code>C₁</code> and <code>C₂</code> in question have to have closures which cover in some way. That makes me think it must be not much different than the proof they have.</p>",
        "id": 435773555,
        "sender_full_name": "Dean Young",
        "timestamp": 1714237333
    },
    {
        "content": "<p>I don't think that we want 2 proofs of exactly the same theorem. However, if you have a proof that implies the currently available versions of the theorem as well as some new versions, then we can drop the old proof.</p>",
        "id": 435775961,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1714239767
    },
    {
        "content": "<p>Note: I'm not an expert in this area of math (I mean, I don't know what versions are true, what's the right generality to cover many versions in few theorems etc). I've just fomalized a version of Urysohn's lemma I needed for a partition of unity.</p>",
        "id": 435776104,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1714239896
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> Sorry, I think you must be right. </p>\n<p><span class=\"user-mention\" data-user-id=\"382902\">@Yoh Tanimoto</span> He's saying that the logic matches the use of balanced ternary: <a href=\"https://en.wikipedia.org/wiki/Balanced_ternary\">https://en.wikipedia.org/wiki/Balanced_ternary</a></p>\n<p>In the function from ternary expansions to the interval, two functions <code>I → I</code> are featured, while expansions ending in all 0s or all 1s are not allowed. These end in T (terminates).</p>\n<p>It seems like there are versions related to barycentric subdivision as well. I'll keep these thoughts around and return to the thread if these simplicial analogues amount to anything.</p>",
        "id": 435893270,
        "sender_full_name": "Dean Young",
        "timestamp": 1714325293
    },
    {
        "content": "<p>no, all I was saying is that the English term for base 3 is \"ternary\", not \"trinary\", nothing more. I've given no real thought to the rest of the construction.</p>\n<p>But as Yury said, unless this construction does something for us that we can't already do (e.g., gives more general theorems, give additional theorems, or unifies and simplifies proof techniques), then we don't actually need a second proof.</p>\n<p>That's not to say that you shouldn't pursue this if it interests you! Only that in the end it may not end up in Mathlib.</p>",
        "id": 435894803,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714326834
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>  ok, thanks professor Loreaux.</p>",
        "id": 436173775,
        "sender_full_name": "Dean Young",
        "timestamp": 1714441602
    },
    {
        "content": "<p>Pertaining to the hiccups that made Riesz-Markov-Kakutani PRs on compact Hausdorff spaces stall originally, and as far as I understand, also in <span class=\"user-mention silent\" data-user-id=\"382902\">Yoh Tanimoto</span>'s recent attempt to use <code>ℝ≥0</code> values:</p>\n<p>I made <a href=\"https://github.com/leanprover-community/mathlib4/pull/12559\">#12559</a> which enables subtraction for nonnegative bounded continuous functions. If the model (new type class <code>BoundedSub</code> and otherwise minimal changes) is considered reasonable, I will do a similar PR to enable also multiplication of nonnegative bounded continuous functions.</p>",
        "id": 436558905,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1714591428
    },
    {
        "content": "<p>I made <a href=\"https://github.com/leanprover-community/mathlib4/pull/12402\">#12402</a> for the type of compactly supported functions and <a href=\"https://github.com/leanprover-community/mathlib4/pull/12459\">#12459</a> which is needed for additivity. It would be nice to have some more stuff such as <code>HMul C(X, ℝ) C_c(X, ℝ) C_c(X, ℝ)</code>.</p>",
        "id": 436564404,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1714593852
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"382902\">@Yoh Tanimoto</span> for <a href=\"https://github.com/leanprover-community/mathlib4/pull/12402\">#12402</a>, I've been meaning to comment but I've been a bit busy on another project. We'll want to topologize the compactly supported functions with the inductive limit topology, and then ensure that the metric you put on them generates that same topology definitionally. Unfortunately, I fear this is not an entirely trivial task.</p>",
        "id": 436567387,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714595228
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> do I remember that you had some work on the topology for compactly supported continuous functions, or was that for smooth test functions?</p>",
        "id": 436567427,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714595256
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> sorry, I didn't mean to hurry you, and thanks for reviewing!<br>\nDo we want the inductive limit topology or the uniform topology? For some applications, I think the uniform topology is more natural for <code>C_c</code>.</p>",
        "id": 436570384,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1714596537
    },
    {
        "content": "<p>I would have expected the inductive limit topology would be the more natural one most of the time, but maybe others disagree.</p>",
        "id": 436575322,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714598652
    },
    {
        "content": "<p>Because it's the one induced by the inclusion in the continuous functions, which has the compact-open topology.</p>",
        "id": 436575467,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714598711
    },
    {
        "content": "<p>I want to catch up everything more properly (here and everywhere else, sorry for people waiting for any kind of answer for me) so I'm just passing by.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/436567427\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> do I remember that you had some work on the topology for compactly supported continuous functions, or was that for smooth test functions?</p>\n</blockquote>\n<p>It was for smooth test functions but it wasn't completed. Anyways, I have quite clear ideas about how to do it (for the inductive limit topology), so as soon as I get a bit more organized (which is soon, hopefully) I'd be happy to help with that.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/436575322\">said</a>:</p>\n<blockquote>\n<p>I would have expected the inductive limit topology would be the more natural one most of the time, but maybe others disagree.</p>\n</blockquote>\n<p>I agree with Jireh here (modulo the point I raised <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/434588104\">here</a>), and I think if we want the uniform one we would use the subtype of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BoundedContinuousFunction#doc\">docs#BoundedContinuousFunction</a> instead ? But this is a bit of a naive answer maybe.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/436575467\">said</a>:</p>\n<blockquote>\n<p>Because it's the one induced by the inclusion in the continuous functions, which has the compact-open topology.</p>\n</blockquote>\n<p>I don't think it does ? Or am I misunderstanding what you mean by inductive limit topology ?</p>",
        "id": 436585889,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1714604286
    },
    {
        "content": "<p>I think <code>C_c</code> can be equipped with the compact-open topology, if it can also carry separately the uniform metric (or maybe a coercion to <code>BoundedContinuousFunction</code> or <code>ZeroAtInftyContinuousMaps</code>?)</p>",
        "id": 436639235,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1714637422
    },
    {
        "content": "<p>Am I right that, for Riesz-Markov-Kakutani, one doesn't need to put any topology on <code>C_c</code>?</p>",
        "id": 436650254,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1714641364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/436585889\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/436575467\">said</a>:</p>\n<blockquote>\n<p>Because it's the one induced by the inclusion in the continuous functions, which has the compact-open topology.</p>\n</blockquote>\n<p>I don't think it does ? Or am I misunderstanding what you mean by inductive limit topology ?</p>\n</blockquote>\n<p>Oops! You're right. Sorry.</p>",
        "id": 436652996,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714642334
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/436650254\">said</a>:</p>\n<blockquote>\n<p>Am I right that, for Riesz-Markov-Kakutani, one doesn't need to put any topology on <code>C_c</code>?</p>\n</blockquote>\n<p>For RMK you are right! I just want to apply it to the proof of the spectral theorem and for this it would be nice if <code>C_c</code> were equipped with the uniform metric.</p>",
        "id": 436672611,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1714649596
    },
    {
        "content": "<p>In that case you probably want to work with the subtype of bounded continuous functions with compact support. You can bundle it as an ideal.</p>",
        "id": 436684151,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714653592
    },
    {
        "content": "<p>Exactly which proof are you planning to follow for the spectral theorem? I'm asking because we'll likely want a version that works in any von Neumann algebra, not just all bounded operators. (And there's still a lot of von Neumann algebra theory that needs to be developed.)</p>",
        "id": 436684765,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714653798
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/436684151\">said</a>:</p>\n<blockquote>\n<p>In that case you probably want to work with the subtype of bounded continuous functions with compact support. You can bundle it as an ideal.</p>\n</blockquote>\n<p>Ah, I thought about defining a subtype, but I didn't know how to bundle operations (that <code>C_c</code>is closed under sum and product for example). By ideal do you mean this (and the product with ContinuousMap<code> remains in </code>C_c`)? Is there an example I can follow?</p>\n<p>I tend to follow Rudin \"Functional Analysis\", but I would welcome if you have suggestions. I agree that it would be nice to have a version applicable to von Neumann algebras! I think the following version is the best? If <code>A</code> is a ((un)bounded) self-adojint operator on a Hilbert space <code>H</code>, then there is a measure space <code>M, μ</code> and a unitary <code>U : H → MeasureTheory.Lp 2 μ</code> such that <code>U * A * (star U)</code> is a multiplication operator?</p>",
        "id": 436689334,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1714655216
    },
    {
        "content": "<p>by the way, if one wants to define the support of a distribution <code>ϕ</code>, is it reasonable to restrict to a finite-dimensional vector spaces? I would define it as the complement of the union of all open sets <code>U</code> where any test function supported in <code>U</code> is annihilated by <code>ϕ</code>. But then I would need that such a union has the same property. It can be done if I assume <code>LocallyCompactSpace</code> for the vector space, but then it is finite dimensional. <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> <span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span></p>",
        "id": 436694025,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1714656488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"382902\">Yoh Tanimoto</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/436689334\">said</a>:</p>\n<blockquote>\n<p>By ideal do you mean this (and the product with ContinuousMap <code>remains in</code> C_c`)? Is there an example I can follow?</p>\n</blockquote>\n<p>No, I mean the product of a compactly supported function and a bounded continuous function is compactly supported. Of course, the same is true of continuous functions, but you get the wrong topology if you make it a subtype of those.</p>",
        "id": 436713441,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714661826
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"382902\">Yoh Tanimoto</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/436689334\">said</a>:</p>\n<blockquote>\n<p>If <code>A</code> is a ((un)bounded) self-adojint operator on a Hilbert space <code>H</code>, then there is a measure space <code>M, μ</code> and a unitary <code>U : H → MeasureTheory.Lp 2 μ</code> such that <code>U * A * (star U)</code> is a multiplication operator?</p>\n</blockquote>\n<p>No, I don't think that is the standard version we should have (although having it <em>in addiiton</em> to the primary one would be okay). Also, you're going to run into major headaches with unbounded operators. Perhaps <span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> has already thought about that quite a bit.</p>\n<p>For the bounded operators though, we'll want the Borel functional calculus, and I think we should proceed by defining projection-valued measures. But there's lots of work to do before we get there.</p>",
        "id": 436714141,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714662007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/436713441\">said</a>:</p>\n<blockquote>\n<p>No, I mean the product of a compactly supported function and a bounded continuous function is compactly supported. Of course, the same is true of continuous functions, but you get the wrong topology if you make it a subtype of those.</p>\n</blockquote>\n<p>yes, but how do you implement it, do you have to use a constructor every time like <code>`⟨f.1 * g.1, HasCompactSupport_mul f.2 g.2⟩</code>or is there any better way?</p>",
        "id": 436721903,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1714664212
    },
    {
        "content": "<p>just try making a term of type <code>Ideal (α →ᵇ β)</code> with carrier <code>{ f | HasCompactSupport f}</code>. Then (after doing that) you can add some constructor which takes a continuous function, and a function with compact support, and produces a bounded continuous function, and you can show that this too has compact support (so it is in the ideal).</p>",
        "id": 436722420,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714664365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/436714141\">said</a>:</p>\n<blockquote>\n<p>No, I don't think that is the standard version we should have (although having it <em>in addiiton</em> to the primary one would be okay). Also, you're going to run into major headaches with unbounded operators. Perhaps <span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> has already thought about that quite a bit.</p>\n<p>For the bounded operators though, we'll want the Borel functional calculus, and I think we should proceed by defining projection-valued measures. But there's lots of work to do before we get there.</p>\n</blockquote>\n<p>Yes, for that one would like to define weak/strong operator topologies as well.</p>",
        "id": 436722782,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1714664470
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/436722420\">said</a>:</p>\n<blockquote>\n<p>just try making a term of type <code>Ideal (α →ᵇ β)</code> with carrier <code>{ f | HasCompactSupport f}</code>. Then (after doing that) you can add some constructor which takes a continuous function, and a function with compact support, and produces a bounded continuous function, and you can show that this too has compact support (so it is in the ideal).</p>\n</blockquote>\n<p>mmm ok, I started to define <code>C_c</code> as an extension of <code>ContinuousMap</code> by following the way of <code>ZeroAtInfty</code>, and  <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span> seemed to like it (<a href=\"https://github.com/leanprover-community/mathlib4/pull/12290\">#12290</a>). Should I change to this?</p>",
        "id": 436724007,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1714664853
    },
    {
        "content": "<p>It's not that I think you should change it. We should definitely have a separate <code>C_c</code> type, but that one should be equipped with the inductive limit topology (IMHO), and so you <em>can't</em> equip it with the uniform metric. So we should have <em>both</em> the separate type, and this ideal in the bounded continuous functions. And after we have both, we can have an algebra isomorphism between them.</p>",
        "id": 436724429,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714664982
    },
    {
        "content": "<p>ah ok!</p>",
        "id": 436724631,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1714665027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"382902\">Yoh Tanimoto</span> <a href=\"#narrow/stream/287929-mathlib4/topic/variations.20of.20Urysohn's.20lemma/near/436694025\">said</a>:</p>\n<blockquote>\n<p>by the way, if one wants to define the support of a distribution <code>ϕ</code>, is it reasonable to restrict to a finite-dimensional vector spaces? I would define it as the complement of the union of all open sets <code>U</code> where any test function supported in <code>U</code> is annihilated by <code>ϕ</code>. But then I would need that such a union has the same property. It can be done if I assume <code>LocallyCompactSpace</code> for the vector space, but then it is finite dimensional. <span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span></p>\n</blockquote>\n<p>I feel like I'm about to say something stupid, but nontrivial test functions do not exist outside of finite dimensional vector spaces anyway, right ? Because it would give you a nonempty open set contained in a compact set.</p>",
        "id": 436874696,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1714739785
    },
    {
        "content": "<p>sorry, I was sloppy about \"test function\" and \"Schwartz function\". If we mean by \"test function\" a smooth function with compact support, then yes!</p>\n<p>so I should have said as follows:  \"I would define it as the complement of the union of all open sets <code>U</code> where any Schwartz  function supported in <code>U</code> is annihilated by <code>ϕ</code>\"</p>",
        "id": 436883757,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1714742905
    },
    {
        "content": "<p>I made this <a href=\"https://github.com/leanprover-community/mathlib4/pull/12459\">#12459</a>, but it gets a lint error \"2800 file contains 2615 lines, try to split it up\". What should I do? <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span></p>",
        "id": 437007121,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1714814936
    },
    {
        "content": "<p>Update the exceptions file</p>",
        "id": 437008917,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1714816840
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/master/scripts/style-exceptions.txt\">https://github.com/leanprover-community/mathlib4/blob/master/scripts/style-exceptions.txt</a></p>",
        "id": 437008957,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1714816885
    },
    {
        "content": "<p>thank you, it worked!</p>",
        "id": 437022144,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1714829157
    }
]