[
    {
        "content": "<p>I would imagine this has been discussed before but: is there any progress on a tactic alike <code>to_additive</code> that converts a theorem to its order-dual version?</p>",
        "id": 486753168,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1733650477
    },
    {
        "content": "<p>Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">SuccPred</span><span class=\"bp\">.</span><span class=\"n\">Limit</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Order</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_order_dual</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">-- IsPredLimit a ‚Üî a ‚â† ‚ä§ ‚àß IsPredPrelimit a</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isSuccLimit_iff'</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OrderBot</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsSuccLimit</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"bp\">‚ä•</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">IsSuccPrelimit</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">isSuccLimit_iff</span>\n</code></pre></div>",
        "id": 486753335,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1733650631
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span></p>",
        "id": 486753628,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1733650882
    },
    {
        "content": "<p>No more than last time, at least as much as I'm aware of. <span class=\"user-mention\" data-user-id=\"132603\">@Calle S√∂nne</span> was interested in the category theoretical version but has since been plagued with painful wrists like me</p>",
        "id": 486754980,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1733652033
    },
    {
        "content": "<p>One complication here is that you would expect it to sometimes reorder arguments</p>",
        "id": 486765320,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1733660364
    },
    {
        "content": "<p>And sometimes you want it to generate <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>‚àí</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^n - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7477em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> lemmas for some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n &gt; 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></p>",
        "id": 486776968,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1733670280
    },
    {
        "content": "<p>I would imagine that even this basic version could already get rid of a lot of cruft throughout the library</p>",
        "id": 486807771,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1733695931
    },
    {
        "content": "<p>Other examples of order duals would include <code>Sup</code> and <code>Inf</code>, or <code>IsMin</code> and <code>IsMax</code>, or <code>IsLUB</code> and <code>IsGLB</code>, ...</p>",
        "id": 486807819,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1733695995
    },
    {
        "content": "<p>I've started playing around with using the <code>to_additive</code> infrastructure to make an <code>order_dual</code> tactic in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21719\">#21719</a>. (<a href=\"https://github.com/leanprover-community/mathlib4/pull/21696\">#21696</a> is where I'm putting non-<code>order_dual</code>-specific changes to <code>to_additive</code>.) I'm a relative newcomer to metaprogramming, so I'd be happy to collaborate with anyone who's interested!</p>\n<p>I'm currently stuck on a decidable instance which isn't getting translated:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"n\">ite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"n\">argument</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n</code></pre></div>",
        "id": 499009948,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739280639
    },
    {
        "content": "<p>I look forward to this very much!  In my experiments, the main issue was generating the \"correct\" ordering of the variable names in the statements, plus some twisted difficulty with associativity for statements involving more than 2 elements.</p>",
        "id": 499029104,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739286001
    },
    {
        "content": "<p>Ah, sounds like your experiments may have proceeded farther than mine... if you've got any notes or old code still lying around I'd love to take a look.</p>",
        "id": 499030693,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739286385
    },
    {
        "content": "<p>I think that <a href=\"https://github.com/leanprover-community/mathlib4/pull/12528\">#12528</a> was one of the latest experiments that I had.  It is not at all polished!</p>",
        "id": 499032848,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739286975
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> I had a quick look at <a href=\"https://github.com/leanprover-community/mathlib4/pull/12528\">#12528</a> and it looks like you implemented some useful functions! I'm still working on figuring out the <code>to_additive</code> machinery, but hopefully what you wrote can be plugged in somewhere...</p>",
        "id": 499131470,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739325483
    },
    {
        "content": "<p>As a general progress report, the very simple approach of just replacing the multiplicative-&gt;additive dictionaries with an order-dual dictionary and using <code>to_additive</code>'s <code>reorder</code> to reverse the arguments of every <code>‚â§</code> in sight in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21719\">#21719</a>  is now stuck at <code>LinearOrder.lean</code> and <code>WithBot.lean</code> with different issues. I'll keep digging into what's going on so I can try to ask more focused questions later, but any experts with spare time are welcome to take a look and suggest / push fixes.</p>",
        "id": 499132814,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739326287
    },
    {
        "content": "<p>If I remember correctly, I did not hook into the <code>to_additive</code> machinery, but made a simple syntactic translation, so I think that your approach probably complements nicely the one that I had started.</p>",
        "id": 499177062,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739350163
    },
    {
        "content": "<p>I am definitely interested in this automation and I have had it in the back of my mind for a while: I'll help, but also do remind me, in case I get distracted by other projects!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 499177259,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739350215
    },
    {
        "content": "<p>I made some progress on understanding what is broken in <code>LinearOrder.lean</code>. It turns out the na√Øve approach of just swapping the arguments to <code>‚â§</code> is incompatible with the definition of <code>max</code> that we're using. Compare:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">min</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>If we just swap the arguments of <code>‚â§</code>, then <code>min</code> would get translated to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>(which is actually what mathlib3 used up until <a href=\"https://github.com/leanprover-community/mathlib3/pull/17470\">mathlib3#17470</a>). </p>\n<p>Now if we change the definition of <code>max</code> back to this, then <code>order_dual</code> seems to work quite well translating theorems about min and max... until we try to define a linear order on the natural numbers, where all hell breaks loose because max is defined in core with the first definition -- which is of course the reason that we had to land <a href=\"https://github.com/leanprover-community/mathlib3/pull/17470\">mathlib3#17470</a> in the first place.</p>\n<p>It is possible to manually apply the attribute to any lemmas whose proofs unfold <code>max</code> or <code>min</code> to <code>‚â§</code>, so I'll try doing that next. I'm hoping we eventually get to a point where the max / min API gets sealed off and <code>order_dual</code> can take over.</p>",
        "id": 499372660,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739418027
    },
    {
        "content": "<p>or maybe core just has the wrong definition of max</p>",
        "id": 499834445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739568923
    },
    {
        "content": "<p>and possibly things have changed enough that we can actually have the backport go the other way around</p>",
        "id": 499834524,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739568962
    },
    {
        "content": "<p>I haven't made it that much further yet but so far the <code>min</code> <code>max</code> messiness seems to be contained to a handful of lemmas.</p>",
        "id": 499840001,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739570954
    },
    {
        "content": "<p>I mean sure we can keep working around this but I think the only reason we backported at the time was because core is annoying to PR to and it still kinda is but less so</p>",
        "id": 499840159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739571021
    },
    {
        "content": "<p>I'm almost certain whoever wrote that definition of max did not think about this issue at all and just wrote the first ordering that came to mind</p>",
        "id": 499840263,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739571076
    },
    {
        "content": "<p>My first reaction was certainly the same: wow things would be much cleaner if we just switched the definition back. But as I tag more and more lemmas with <code>order_dual</code>  I'm less and less sure that I'm not just imposing my own arbitrary choices when I tell the tactic to re-order variables.</p>",
        "id": 499840823,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739571335
    },
    {
        "content": "<p>Today's progress update (all work can be found in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21719\">#21719</a>): As always, any feedback / questions here or on the PR is welcome!</p>\n<p>I've now managed to tag most lemmas where the <code>order_dual</code> applies through the start of <code>Order.Basic</code>. Up to now I've been doing it all \"by feel\", so I think now is a good time to try and put the process into words, if just for my own benefit. So far most of the declarations <code>order_dual</code> has been applied to are just simple statements about <code>&lt;</code> and <code>‚â§</code>, with a few that mention <code>min</code> and <code>max</code>; I did do some tests with <code>WithBot</code> and <code>WithTop</code> as well, but maybe I'll talk about those in a later post. </p>\n<p>First, everything starts at the top of <a href=\"https://github.com/leanprover-community/mathlib4/blob/916de1187bc9ebeefd327879a48905a477f6e9ed/Mathlib/Order/Defs/PartialOrder.lean#L28\">Order.Defs.PartialOrder</a>, where I decided that <code>order_dual</code> should transform <code>a ‚â§ b</code> to <code>b ‚â§ a</code> (and similarly <code>a &lt; b</code> should be transformed to <code>b &lt; a</code>, etc.):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">GE</span><span class=\"bp\">.</span><span class=\"n\">ge</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">GE</span><span class=\"bp\">.</span><span class=\"n\">ge</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">GT</span><span class=\"bp\">.</span><span class=\"n\">gt</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">GT</span><span class=\"bp\">.</span><span class=\"n\">gt</span>\n</code></pre></div>\n<p>Here you can see the use of <code>to_additive</code>'s <code>reorder</code> option to swap the arguments of these functions.</p>\n<p>Now that these have been registered, <code>order_dual</code> can transform theorems or defs that mention any of these functions to their dual versions, where \"dual\" just means that the LHS and RHS of every <code>‚â§</code>, <code>&lt;</code>, etc. in sight have been swapped. Note that a theorem like <code>le_rfl : a ‚â§ a</code> is manifestly self-dual so there's no reason to tag it with <code>order_dual</code> as the default behavior is to do nothing.</p>\n<p>So now suppose we have a declaration where <code>order_dual</code> actually transforms it into something different. Consider the resulting dual declaration:</p>\n<p>Case 1: Most of the time, the transformed version is just some slight variation of the original theorem that no one has needed up until now. For the time being, I'm manually naming these theorems as the original name + <code>OD</code> as a suffix:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">le_of_lt_or_eqOD</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">-- {a b : Œ±} (h : b &lt; a ‚à® a = b) : b ‚â§ a</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">le_of_lt_or_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">le_of_eq</span>\n<span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">le_of_eq_or_ltOD</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">-- {a b : Œ±} (h : a = b ‚à® b &lt; a) : b ‚â§ a</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">le_of_eq_or_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">le_of_eq</span><span class=\"w\"> </span><span class=\"n\">le_of_lt</span>\n</code></pre></div>\n<p>It's a bit unfortunate that this leads to a bunch of new trivial theorems, but we need to add these variants so that <code>order_dual</code> will know how to transform the source theorems properly when they show up in proofs later on.</p>\n<p>Case 2: Sometimes we get lucky and the transformed version of a theorem is secretly the same theorem except with some arguments permuted. In that case we just register the theorem as the dual version of itself with <code>reorder</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">lt_iff_le_not_le</span><span class=\"kd\">]</span>\n<span class=\"c1\">-- note that swapping the LHS and RHS of &lt; and ‚â§ below yields:</span>\n<span class=\"c1\">-- b &lt; a ‚Üî b ‚â§ a ‚àß ¬¨a ‚â§ b</span>\n<span class=\"c1\">-- which is also what we get if we swap a and b</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lt_iff_le_not_le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">lt_iff_le_not_le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>Case 3: Sometimes we get even more lucky and the transformed theorem happens to be one that is proved later on in the file. This is the happy case where <code>order_dual</code> will let us delete lines of code (though I'm just commenting things out for now):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trans</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">gt_of_gt_of_ge</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lt_of_lt_of_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_le_not_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">not_le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trans</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">gt_of_ge_of_gt</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lt_of_le_of_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_le_not_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">not_le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- @[trans] lemma gt_of_gt_of_ge (h‚ÇÅ : a &gt; b) (h‚ÇÇ : b ‚â• c) : a &gt; c := lt_of_le_of_lt h‚ÇÇ h‚ÇÅ</span>\n<span class=\"c1\">-- @[trans] lemma gt_of_ge_of_gt (h‚ÇÅ : a ‚â• b) (h‚ÇÇ : b &gt; c) : a &gt; c := lt_of_lt_of_le h‚ÇÇ h‚ÇÅ</span>\n</code></pre></div>\n<p>One thing that I've been treating inconsistently is whether I should identify variations that use <code>ge</code> and <code>gt</code> as the same as the ones with <code>le</code> and <code>lt</code>. Also, case is still relatively rare so far, but I expect that the proportion will be higher for pairs of theorems about <code>min</code> <code>max</code> <code>top</code> <code>bot</code>, etc. rather than these theorems about <code>le</code> and <code>lt</code>.</p>\n<p>I think we eventually want special <code>order_dual self</code> syntax for <code>order_dual</code> to verify case 2, since it's easy to screw up the reordering. Also, it would be nice to have some automation to search for case 3 theorems as well, since searching for defeq theorems later in the file with a different name than expected is a bit annoying. Previously I was also trying to use <code>reorder</code> to try to match up the output of <code>order_dual</code> with later declarations, but I kept making mistakes, so I ended up undoing all of those and using <code>reorder</code> only when we get back the original declaration. Maybe there's some way to use automation here as well?</p>\n<p>I haven't given much thought at all to how <code>order_dual</code> should be changing the names of theorems like these at all - this might help with identifying case 3 declarations. Right now, <code>order_dual</code> only knows to change <code>min</code> to <code>max</code>, <code>bot</code> to <code>top</code>, <code>sup</code> to <code>inf</code>, so theorems about <code>lt</code> and <code>le</code> just end up with the same name.</p>",
        "id": 499882068,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739595581
    },
    {
        "content": "<p>(I don't mean to sidetrack you but my sincere thanks for this! It'll really come in handy in a lot of places)</p>",
        "id": 499884309,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1739597708
    },
    {
        "content": "<p>I think it's fine and even expected that <code>lt</code> and <code>le</code> should be kept the same. The only exception is when this would lead to the entire name being the same for two different theorems, which ime is where a lot of these <code>ge</code>/<code>gt</code> theorems come from.</p>",
        "id": 499884589,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1739597999
    },
    {
        "content": "<p>Are you planning to hit a certain tagging goal before PRing the tactic? I think it's important to have a working proof of concept before we get this into Mathlib, but tagging everything that could be tagged is complete overkill at this point.</p>",
        "id": 499884678,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1739598070
    },
    {
        "content": "<p>Yeah, I‚Äôm not sure how far I should tag before cleaning up the tactic changes. I kind of want to see if I can get to lattices, but maybe it‚Äôs already useful enough?</p>",
        "id": 499887054,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739600461
    },
    {
        "content": "<p>(If anyone feels like pushing some commits tagging more lemmas and defs to my branch while I‚Äôm sleeping I certainly don‚Äôt mind!)</p>",
        "id": 499887225,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739600618
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/499882068\">said</a>:</p>\n<blockquote>\n<p>Case 3: Sometimes we get even more lucky and the transformed theorem happens to be one that is proved later on in the file. This is the happy case where <code>order_dual</code> will let us delete lines of code (though I'm just commenting things out for now):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trans</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">gt_of_gt_of_ge</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lt_of_lt_of_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_le_not_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">not_le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trans</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">gt_of_ge_of_gt</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lt_of_le_of_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_le_not_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">not_le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- @[trans] lemma gt_of_gt_of_ge (h‚ÇÅ : a &gt; b) (h‚ÇÇ : b ‚â• c) : a &gt; c := lt_of_le_of_lt h‚ÇÇ h‚ÇÅ</span>\n<span class=\"c1\">-- @[trans] lemma gt_of_ge_of_gt (h‚ÇÅ : a ‚â• b) (h‚ÇÇ : b &gt; c) : a &gt; c := lt_of_lt_of_le h‚ÇÇ h‚ÇÅ</span>\n</code></pre></div>\n</blockquote>\n<p>By the way, I don't exactly consider this example a win, the <code>order_dual</code> tactic produces a proof from scratch by \"copy paste\" while the original proof was much shorter because it's defeq to an existing lemma</p>",
        "id": 499918318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739629579
    },
    {
        "content": "<p>given the additional issue about <code>gt</code> here I would be enclined to just tag the latter lemma rather than trying to translate it</p>",
        "id": 499918509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739629747
    },
    {
        "content": "<p>Yeah, that makes sense! This is along the lines of something I mentioned at the end of my message, but one thing about tagging lemmas after the fact with <code>existing</code> is that <code>order_dual</code> no longer goes through the proof and checks that things translate properly, so it's easy to accidentally add a tag that's nonsense. What I've been doing is temporarily generating a new lemma and then checking with an <code>example</code> that it is indeed defeq to the other declaration - it'd be nice if there was some kind of automated checking here (though I haven't thought through exactly what I want, I guess).</p>",
        "id": 499919118,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739630219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/499919118\">said</a>:</p>\n<blockquote>\n<p>but one thing about tagging lemmas after the fact with <code>existing</code> is that <code>order_dual</code> no longer goes through the proof and checks that things translate properly, so it's easy to accidentally add a tag that's nonsense</p>\n</blockquote>\n<p>that sounds fixable? <code>order_dual</code> / <code>to_additive</code> should be able to validate these at attribute application time</p>",
        "id": 499925644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739635168
    },
    {
        "content": "<p>Yes, we're open to change the definitions up in Lean, but I'd like to be presented with a \"yes, it all works, including Mathlib, and people have signed off on the fact the change really makes tactic implementations easier\" PR if possible. I don't have time to do this myself right now.</p>",
        "id": 499968190,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739670533
    },
    {
        "content": "<p>I finally found some time this week to come back to this and I've added the <code>order_dual self</code> syntax that I mentioned earlier, so tagging self-dual lemmas is now a lot less verbose. </p>\n<p>I also attempted to add some validation for <code>order_dual self</code> and <code>order_dual existing</code> to check that the type of the declaration generated by <code>order_dual</code> (after variable reordering) is indeed defeq to the type of the original declaration itself (for <code>self</code>) or the type of the provided declaration (for <code>existing</code>), respectively. However, I'm getting mismatches where there just seems to be a difference in a universe variable:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>order_dual failed validation!\ntgt type:\n‚àÄ {Œ± : Type u_2} [self : Preorder Œ±] (a b c : Œ±), a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c,\ntransformed type:\n‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] (a b c : Œ±), a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c\n</code></pre></div>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/ba1dc0721375f4ff78952e683ae23140c81aade0/Mathlib/Tactic/ToAdditive/Frontend.lean#L1675-L1683\">The main validation code consists of these 8 lines or so</a>, and I was already well outside my metaprogramming comfort zone when I wrote them, so there's probably some obvious mistake(s). </p>\n<p>Before PRing, I also need to refactor things to separate out the parts of the code which are specific to <code>to_additive</code>, so I would appreciate it anyone has any suggestions on how to do this cleanly; more generally, any comments about the current state of the meta code are very welcome!</p>",
        "id": 505520343,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741898068
    },
    {
        "content": "<p>I do not know how <code>AttrM</code> works, but couldn't you try to combine the two <code>MetaM.run</code>s into a single one?</p>",
        "id": 505522539,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741898818
    },
    {
        "content": "<p>I think that the universe level information may be stored in the <code>MetaM</code> state somewhere and maybe the two runs do not keep track of the same assignments?</p>",
        "id": 505522661,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741898858
    },
    {
        "content": "<p>Thanks Damiano! However, I tried putting <code>isDefEq</code> into the same function that generates the order dual type in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21719/commits/a4cc18836952566c2a70a5dc51237e68d8a70d24\">the next commit</a> and unfortunately I'm still getting the same errors.</p>",
        "id": 505525356,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741899806
    },
    {
        "content": "<p>Ok, so maybe \"manually\" creating fresh (universe) metavariables before unification might help?</p>",
        "id": 505525551,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741899858
    },
    {
        "content": "<p>How does <code>to_additive</code> do it?</p>",
        "id": 505525641,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741899886
    },
    {
        "content": "<p>I'm not sure that <code>to_additive</code> has this check.</p>",
        "id": 505525716,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741899906
    },
    {
        "content": "<p>In fact, today I was goofing around and you can actually place multiple copies of the <code>to_additive</code> attribute on the same declaration and you get new \"identical\" declarations.</p>",
        "id": 505525857,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741899954
    },
    {
        "content": "<p>(You need to give them manually different names, though, since the environment catches the name clash otherwise.)</p>",
        "id": 505525979,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741899981
    },
    {
        "content": "<p>In that case I would instantiate one with universe variables and the other one with fresh universe metavariables, and do a defeq check on those. Then do it the other way around too to be safe.</p>",
        "id": 505526322,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741900103
    },
    {
        "content": "<p>OK, thanks! I guess the issue is the one that Kyle mentioned in <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/Checking.20defeq.20in.20Command/near/389771514\">#lean4 &gt; Checking defeq in Command @ üí¨</a> . Unfortunately his snippet starts with <code>Name</code>s not <code>Expr</code>s. Is there an easy way to refresh universe metavariables in my use case?</p>\n<p>For reference here's the current checking code (far from an MWE, see <a href=\"https://github.com/leanprover-community/mathlib4/pull/21719\">#21719</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">checkDeclType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BundledExtensions</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">srcDecl</span><span class=\"w\"> </span><span class=\"n\">tgtDecl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ConstantInfo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">srcDecl.updateName</span><span class=\"w\"> </span><span class=\"n\">tgt</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">reorder.flatten</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">decl.updateLevelParams</span><span class=\"w\"> </span><span class=\"n\">decl.levelParams.swapFirstTwo</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">applyReplacementFun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">reorderForall</span><span class=\"w\"> </span><span class=\"n\">reorder</span>\n<span class=\"w\">    </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">expand</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">unfoldAuxLemmas</span><span class=\"w\"> </span><span class=\"n\">decl.type</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">‚ü®</span><span class=\"n\">exp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"n\">tgtDecl.type</span><span class=\"o\">‚ü©</span>\n</code></pre></div>\n<p>and I guess I need to do more setup with <code>exp</code> and <code>tgtDecl.type</code> before passing them to <code>isDefEq</code>.</p>\n<p><strong>edit</strong>: this was resolved in <a class=\"message-link\" href=\"/#narrow/channel/239415-metaprogramming-.2F-tactics/topic/checking.20if.20two.20Exprs.20are.20defeq/near/506000231\">#metaprogramming / tactics &gt; checking if two Exprs are defeq @ üí¨</a></p>",
        "id": 505530995,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741901949
    },
    {
        "content": "<p>You can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.ConstantInfo.instantiateTypeLevelParams#doc\">docs#Lean.ConstantInfo.instantiateTypeLevelParams</a></p>",
        "id": 505533386,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741902948
    },
    {
        "content": "<p>If I understand correctly, Bryan wants to do this for the \"new\" expr, the one that does not have a corresponding declaration.</p>",
        "id": 505533599,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741903037
    },
    {
        "content": "<p><del>You can <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.ConstantInfo.updateType#doc\">docs#Lean.ConstantInfo.updateType</a> an existing declaration.</del></p>",
        "id": 505534910,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741903582
    },
    {
        "content": "<p>You mentioned having trouble with the order on <code>WithBot</code>and <code>WithTop</code>. Note that there is some ongoing work on refactoring these definitions at <a href=\"https://github.com/leanprover-community/mathlib4/pull/19668\">#19668</a>, by <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span>.</p>",
        "id": 505556365,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741914406
    },
    {
        "content": "<p>For the time being I've just turned the validation error into a <code>logInfo</code> so I can continue. Interestingly, I'm now seeing panics in later files coming from the <code>reorderForall</code> function where sometimes the validation function is sending an expression with too few arguments. So there's probably something else wrong in my approach here...</p>",
        "id": 505573545,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741922940
    },
    {
        "content": "<p>In the <code>reorderForall</code> function, you accidentally replaced <code>mkForallFVars</code> by <code>mkLambdaFVars</code>, which gives the mismatch.</p>",
        "id": 505665716,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741956316
    },
    {
        "content": "<p>Ah that was silly of me! Fixing that does get rid of most of the mismatches, but it looks like there are still two remaining coming from: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">reorderForall tried to reorder a list that was too small:</span>\n<span class=\"cm\">forall {Œ± : Type.{u_2}} [self : LinearOrder.{u_2} Œ±],</span>\n<span class=\"cm\">  DecidableRel.{succ u_2, succ u_2} Œ± Œ± (fun (x1._@.Mathlib.Order.Defs.LinearOrder._hyg.636 : Œ±)</span>\n<span class=\"cm\">    (x2._@.Mathlib.Order.Defs.LinearOrder._hyg.636 : Œ±) =&gt;</span>\n<span class=\"cm\">  LE.le.{u_2} Œ± (Preorder.toLE.{u_2} Œ± (PartialOrder.toPreorder.{u_2} Œ± (LinearOrder.toPartialOrder.{u_2} Œ± self))) x1._@.Mathlib.Order.Defs.LinearOrder._hyg.636 x2._@.Mathlib.Order.Defs.LinearOrder._hyg.636)</span>\n<span class=\"cm\">#[_uniq.1658, _uniq.1659]</span>\n<span class=\"cm\">[[2, 3]]</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">decidableLE</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">reorderForall tried to reorder a list that was too small:</span>\n<span class=\"cm\">forall {Œ± : Type.{u_2}} [self : LinearOrder.{u_2} Œ±],</span>\n<span class=\"cm\">  DecidableRel.{succ u_2, succ u_2} Œ± Œ± (fun (x1._@.Mathlib.Order.Defs.LinearOrder._hyg.661 : Œ±)</span>\n<span class=\"cm\">    (x2._@.Mathlib.Order.Defs.LinearOrder._hyg.661 : Œ±) =&gt;</span>\n<span class=\"cm\">  LT.lt.{u_2} Œ± (Preorder.toLT.{u_2} Œ± (PartialOrder.toPreorder.{u_2} Œ± (LinearOrder.toPartialOrder.{u_2} Œ± self))) x1._@.Mathlib.Order.Defs.LinearOrder._hyg.661 x2._@.Mathlib.Order.Defs.LinearOrder._hyg.661)</span>\n<span class=\"cm\">#[_uniq.1691, _uniq.1692]</span>\n<span class=\"cm\">[[2, 3]]</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">decidableLT</span>\n</code></pre></div>\n<p>in <code>Order.Defs.LinearOrder</code>. </p>\n<p>If I had to guess, probably the functions from <code>to_additive</code> don't handle <code>DecidableRel</code> well?</p>",
        "id": 505672895,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741958387
    },
    {
        "content": "<p>A priori <code>DecidableRel</code> is not a forall. Only after unfolding it, does it become a forall (Luckily it is reducible, so in the <code>reducible</code> transparency it is a forall). So the fix is probably to replace some ForallTelescope by ForallTelescopeReducing. (And making sure you are in the <code>reducible</code> tranparency)</p>",
        "id": 505677818,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741959611
    },
    {
        "content": "<p>Although I'm not sure if reducing abbreviations is wanted in general. To avoid unnecessarily unfolding reducibles, you can use ForallBoundedTelescopeReducing (or something like that). This one only unfolds up to how many foralls you want to have.</p>",
        "id": 505680683,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741960348
    },
    {
        "content": "<p>I don't think I fully understand what the role/purpose is of reordering the arguments in <code>LinearOrder.decidableLE</code>. Can you explain why they should be swapped?</p>",
        "id": 505714274,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741968796
    },
    {
        "content": "<p>I can't say I fully understand it either, but without the reordering it seems like the instance doesn't apply when we need it to. <del>Looks like the first failure is <code>lt_trichotomy</code>:</del> (edit: let me look for the actual first failure...)</p>",
        "id": 505718709,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741969980
    },
    {
        "content": "<p>I looked at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Decidable.lt_or_eq_of_le#doc\">docs#Decidable.lt_or_eq_of_le</a>, and I'm confused why this theorem exists, because it is weaker than <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=lt_or_eq_of_le#doc\">docs#lt_or_eq_of_le</a>. I thought mathlib was a classical mathematics library.</p>",
        "id": 505719790,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741970281
    },
    {
        "content": "<p>I think that it is a classical mathematical library <em>outside the <code>Decidable</code> namespace</em>.</p>",
        "id": 505720038,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741970340
    },
    {
        "content": "<p>This theorem dates back to the core lean 3 repository. I'm not sure anyone would mind if it disappeared</p>",
        "id": 505720544,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1741970466
    },
    {
        "content": "<p>OK, if I remove <code>Decidable</code> from the proof of <code>lt_trichotomy</code>, then <code>order_dual</code> (without reordering in <code>LinearOrder.decidableLE</code>) is happy with it, however things blow up just a little bit further below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">application type mismatch</span>\n<span class=\"cm\">  dite (a ‚â§ b)</span>\n<span class=\"cm\">argument has type</span>\n<span class=\"cm\">  Decidable ((fun x1 x2 ‚Ü¶ x1 ‚â§ x2) b a)</span>\n<span class=\"cm\">but function has type</span>\n<span class=\"cm\">  ‚àÄ [h : Decidable (a ‚â§ b)],</span>\n<span class=\"cm\">    (a ‚â§ b ‚Üí b &lt; a ‚à® a ‚â§ b) ‚Üí (¬¨a ‚â§ b ‚Üí b &lt; a ‚à® a ‚â§ b) ‚Üí b &lt; a ‚à® a ‚â§ b</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">lt_or_leOD</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lt_or_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">hba</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">hba</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">lt_of_not_ge</span><span class=\"w\"> </span><span class=\"n\">hba</span>\n</code></pre></div>",
        "id": 505722441,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741970969
    },
    {
        "content": "<p>Can you show this with <code>pp.explicit</code>? The problem is in the invisible instance.</p>",
        "id": 505723963,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741971318
    },
    {
        "content": "<p>Sure, here you go!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">dite</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLT</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">decidableLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"n\">argument</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Decidable</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"bp\">‚àÄ</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">      </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)],</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span>\n<span class=\"w\">        </span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLT</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span>\n<span class=\"w\">          </span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLT</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span>\n<span class=\"w\">        </span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLT</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 505724343,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741971412
    },
    {
        "content": "<p>It's the classic \"<code>(if a ‚â§ b then a else b) = (if b ‚â§ a then b else a)</code> is not defeq\", no?</p>",
        "id": 505724737,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1741971519
    },
    {
        "content": "<p>I think the easiest way to fix this would just be to reorder the arguments to <code>LinearOrder.decidableLE</code>.</p>",
        "id": 505725915,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741971831
    },
    {
        "content": "<p>Right, the proof was working when <code>attribute [order_dual self (reorder := 3 4)] LinearOrder.decidableLE</code> was not commented out, so (as in the short version of the error) I think it's just that the known decidability of  <code>‚â§</code> doesn't apply to <code>(fun x2 x1 ‚Ü¶ x1 ‚â§ x2)</code>.</p>",
        "id": 505726020,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741971849
    },
    {
        "content": "<p>It looks like you need to change <a href=\"https://github.com/leanprover-community/mathlib4/blob/b6bf9080892e7d60f3397b51efee21fa0988021a/Mathlib/Tactic/ToAdditive/Frontend.lean#L973-L981\">these lines</a> to a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.forallBoundedTelescope#doc\">docs#Lean.Meta.forallBoundedTelescope</a>.</p>",
        "id": 505728700,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741972670
    },
    {
        "content": "<p>Thanks! Looks like that worked. Now it's just the issue with the universe names confusing <code>isDefEq</code>.</p>",
        "id": 505730599,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741973208
    },
    {
        "content": "<p>In your implementation, you didn't pass a bound to <code>forallBoundedTelescope</code>, which kind of defeats the purpose of using <code>forallBoundedTelescope</code> over <code>forallTelescopeReducing</code>. You can instead pass it the bound <code>reorder.flatten.max?</code> (and if the <code>Option</code> value is none, then don't telescope at all, since there is nothing to reorder)</p>",
        "id": 505747372,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741978714
    },
    {
        "content": "<p>Makes sense! I guess I'll do the same thing with <code>lambdaBoundedTelescope</code> in <code>reorderLambda</code>.</p>",
        "id": 505751356,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741980110
    },
    {
        "content": "<p>Oh and I said earlier to use the <code>reducible</code> transparency, but I take that back, because now that we're using a bounded telescope, it will only reduce if explicitly told to do so. (Assuming you didn't modify the transparency yourself, it's set to <code>default</code> by default, so you don't need to change it)</p>",
        "id": 505752532,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741980590
    },
    {
        "content": "<p>Right, I didn't change the transparency at all. </p>\n<p>Here's what I have now (I had to add a <code>+1</code> to the bound but it works):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Reorder pi-binders. See doc of `reorderAttr` for the interpretation of the argument -/</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">reorderForall</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">maxReorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">reorder.flatten.max</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">forallBoundedTelescope</span><span class=\"w\"> </span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">maxReorder</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">xs.size</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">maxReorder</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"n\">mkForallFVars</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs.permute</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">reorder</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">      </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"n\">dbg_trace</span><span class=\"w\"> </span><span class=\"s2\">\"reorderForall tried to reorder a list that was too small:</span><span class=\"se\">\\n</span><span class=\"err\">\\</span>\n<span class=\"s2\">          {src}</span><span class=\"se\">\\n</span><span class=\"s2\">{xs}</span><span class=\"se\">\\n</span><span class=\"s2\">{reorder}\"</span>\n<span class=\"w\">        </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">src</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">src</span>\n\n<span class=\"sd\">/-- Reorder lambda-binders. See doc of `reorderAttr` for the interpretation of the argument -/</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">reorderLambda</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">maxReorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">reorder.flatten.max</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">lambdaBoundedTelescope</span><span class=\"w\"> </span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">maxReorder</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">xs.size</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">maxReorder</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs.permute</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">reorder</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">      </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"n\">dbg_trace</span><span class=\"w\"> </span><span class=\"s2\">\"reorderLambda tried to reorder a list that was too small:</span><span class=\"se\">\\n</span><span class=\"err\">\\</span>\n<span class=\"s2\">          {src}</span><span class=\"se\">\\n</span><span class=\"s2\">{xs}</span><span class=\"se\">\\n</span><span class=\"s2\">{reorder}\"</span>\n<span class=\"w\">        </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">src</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">src</span>\n</code></pre></div>",
        "id": 505753479,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741980937
    },
    {
        "content": "<p>I would write \"if xs.size = maxReorder + 1\" (although this shouldn't change the effect of the code)</p>",
        "id": 505754150,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741981200
    },
    {
        "content": "<p>Is there a reason to prefer that over <code>xs.size &gt; maxReorder</code>?</p>",
        "id": 505757249,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741982421
    },
    {
        "content": "<p>I think it makes it more readable, and it would throw an error if we accidentally passed the wrong bound to the bounded telescope</p>",
        "id": 505757573,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741982561
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span>, I've had a look at the <code>decidableLE</code> issue, and one solution I've found is to define <code>decidableGE</code>, which is the dual of <code>decidableLE</code>, as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">DecidableGT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">DecidableGE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"n\">DecidableGT</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">DecidableLT</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"n\">DecidableGE</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">DecidableLE</span>\n</code></pre></div>\n<p>However, I think a cleaner solution would be to refactor <code>DecidableLE</code> to not be an <code>abbrev</code>, but instead a structure. Then we can tag its projection function with <code>order_dual</code></p>",
        "id": 513404031,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745243575
    },
    {
        "content": "<p>Thanks for taking a look! Right, I thought briefly about having a dual class, but it does indeed seem messy. <code>DecidableLE</code> and friends are defined in core, right? I wonder if they had some specific reasons for making it an abbrev rather than a structure. </p>\n<p>I also wonder if there's a way to use metaprogramming to have <code>order_dual</code> reorder the arguments to instances appropriately when the type contains <code>‚â§</code> or something else tagged with the \"reorder\" attribute.</p>",
        "id": 513405215,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745243999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/513405215\">said</a>:</p>\n<blockquote>\n<p>I also wonder if there's a way to use metaprogramming to have <code>order_dual</code> reorder the arguments to instances appropriately when the type contains <code>‚â§</code> or something else tagged with the \"reorder\" attribute.</p>\n</blockquote>\n<p>I presume you're talking about for example <code>lt_or_eq_of_le</code>, where <code>order_dual</code> gives the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">dite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n</code></pre></div>\n<p>Although it is true that swapping <code>a</code> and <code>b</code> here solves the problem, I think this is hard to acomplish automatically. The same problem would be solved by either making <code>decidableLE</code> a structure, or giving it a dual <code>decidableGE</code>.</p>",
        "id": 513406455,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745244419
    },
    {
        "content": "<p>I think core only defined <code>DecidableLE</code> quite recently. Before that it was just <code>DecidableRel LE.le</code> (which would work better with <code>order_dual</code>). Anyways I think there is no real downside to defining <code>DecidableLE</code> as a structure.</p>",
        "id": 513407279,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745244692
    },
    {
        "content": "<p>Right, I see how making <code>DecidableLE</code> a structure or giving it a dual will solve the issue, but I'd like to better understand why it'd be hard to deal with instances automatically.</p>\n<p>It's certainly out of reach of my current metaprogramming abilities, but doesn't something like the following algorithm work? Whenever the proof that we're dualizing contains an instance term, first dualize its type and note all reordered arguments, then use that to swap the arguments to the instance?</p>",
        "id": 513407711,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745244875
    },
    {
        "content": "<p>In any case, let's ping <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> to see whether making <code>DecidableLE</code> a structure in core would be acceptable.</p>",
        "id": 513407841,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745244936
    },
    {
        "content": "<p>In the part where you say \"first dualize its type\", what exactly would <code>decidableLE Œ±</code> be dualized to? I think in your model it wouldn't be dualized. So then \"note all reordered arguments\" would have to look at something else than the usual <code>reorder</code></p>",
        "id": 513408838,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745245307
    },
    {
        "content": "<p>Ah, OK I see now. I was imagining that we could see through the abbrev, but obviously that doesn't happen for free...</p>",
        "id": 513409444,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745245534
    },
    {
        "content": "<p>Why doesn't <code>reorder</code> just work?</p>",
        "id": 513411146,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745246166
    },
    {
        "content": "<p>What <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> wanted to do is reorder arguments <code>a</code> and <code>b</code> in <code>inst b a</code>. But <code>inst</code> is a local variable, so it cannot be globally tagged with <code>reorder</code>.</p>",
        "id": 513412744,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745246753
    },
    {
        "content": "<p>Just reorder on <code>DecidableLE</code> then, it's a <code>@[reducible, inline] def</code> defined in Prelude</p>",
        "id": 513413850,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247165
    },
    {
        "content": "<p>or does that not work for some reason</p>",
        "id": 513413867,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247176
    },
    {
        "content": "<p>Do it the same way you reorder <code>LE.le</code></p>",
        "id": 513414243,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247323
    },
    {
        "content": "<p>Which arguments of <code>DecidableLE</code> do you want to swap? It only takes 2 arguments: a type and an instance.</p>",
        "id": 513414523,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745247426
    },
    {
        "content": "<p><del>The third and fourth argument :)</del></p>",
        "id": 513414595,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247452
    },
    {
        "content": "<p>wait, that doesn't work</p>",
        "id": 513414634,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247467
    },
    {
        "content": "<p>hmmmmmm</p>",
        "id": 513414712,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247491
    },
    {
        "content": "<p>I guess the best way to do this is to reorder <code>inst</code></p>",
        "id": 513414858,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247551
    },
    {
        "content": "<p>Since it's a local variable, it must have been introduced into the context at some point</p>",
        "id": 513414923,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247580
    },
    {
        "content": "<p>Then you can just mark it as reorder when it's introduced</p>",
        "id": 513415017,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247604
    },
    {
        "content": "<p>and that's based on the type</p>",
        "id": 513415041,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247613
    },
    {
        "content": "<p>I guess this is the price you pay for having dependent types</p>",
        "id": 513415418,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247721
    },
    {
        "content": "<p>Maybe this could be a new attribute? Something like <code>type_reorder</code></p>",
        "id": 513415676,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247825
    },
    {
        "content": "<p>I think this may cause some problems if you have both <code>decidableLE</code> and <code>decidableRel LE.le</code>. Because one of them gets dualized by swapping the arguments to the local instance, and the other by dualizing the type of the local instance. So we end up with two reducibly defEq expressions that get dualized to two non-defEq expressions. This could give rise to very obscure failures</p>",
        "id": 513420085,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745249339
    },
    {
        "content": "<p>oh, I can see how that could cause problems</p>",
        "id": 513421179,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745249733
    },
    {
        "content": "<p>Is there a library design constraint lurking here? Something more general than \"don't use abbrevs to define classes if you want to be able to use <code>order_dual</code>\".</p>",
        "id": 513448459,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745259954
    },
    {
        "content": "<p>What sort of constraint do you mean? In my experience, using <code>abbrev</code>s to define classes can lead to trouble, but it is convenient because it saves you from writing many instances.</p>\n<p>I had a go at implementing <code>DecidableLE</code> as a structure,  but to be able to use that, I think we'd need to rewrite all type class instances such as e.g. <code>instance (a b : Int16) : Decidable (a ‚â§ b)</code> into the form <code>instance : DecidableLE Int16</code>, which is kind of annoying to do for all of Lean and Mathlib.</p>\n<p>On the other hand, using the <code>abbrev</code> <code>DecidableGE</code> isn't actually that bad, because type class search can automatically infer <code>DecidableLE</code> and <code>DecidableGE</code> from eachother.</p>",
        "id": 513449005,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745260149
    },
    {
        "content": "<p>OK, I was a bit hesitant to add another class, but if <code>DecidableGE</code> doesn't end up being too hard to work with then we can go with that. One minor downside is that theorems that use <code>DecidableLE</code> can't be self-dual anymore, but I don't think there are that many theorems which use <code>DecidableLE</code> anyways.</p>",
        "id": 513462485,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745265915
    },
    {
        "content": "<p>Can typeclass infer <code>DecidableGE</code> from <code>DecidableLE</code>?</p>",
        "id": 513462791,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745266058
    },
    {
        "content": "<p>Yes, because they unfold to <code>‚àÄ a b, Decidable a ‚â§ b</code>, and <code>‚àÄ a b, Decidable b ‚â§ a</code> respectively. And Lean introduces the ‚àÄ variables as metavariables.</p>",
        "id": 513463107,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745266209
    },
    {
        "content": "<p>I made some progress using the approach with <code>DecidableGE</code> and pushed my changes. Some comments:</p>\n<ul>\n<li>When I write <code>@[order_dual self (attr := simp)]</code>, does it apply the <code>simp</code> tag once or twice to the same lemma? I tried instead writing <code>@[simp, order_dual self]</code>, but then the linter complains that it wants 'both' lemmas tagged with <code>simp</code></li>\n<li>I generally prefer to not change statements of lemmas in the process of using <code>order_dual</code>. For example I noticed you set <code>ge_trans</code> to be the dual of <code>le_trans</code>, but this means that it is now defined in terms of <code>‚â§</code> instead of <code>‚â•</code>. Instead, by reordering the arguments in the right way, <code>le_trans</code> and <code>ge_trans</code> can both be self-dual.</li>\n<li>\n<p>I know there was the idea to change the definition of <code>max</code> or <code>min</code> in core to make it a bit more convenient for <code>order_dual</code>. But I think there is actually a good reason for the specific definitions in core, which is written in a comment at <code>maxOfLe</code> and <code>minOfLe</code>:<br>\n<code>-- Marked inline so that `min x y + max x y` can be optimized to a single branch.</code><br>\n  So I think the point is that <code>min</code> and <code>max</code> have the same condition so that using both of them together generates efficient code.</p>\n</li>\n<li>\n<p>To make tagging easier, would it be sensible to have special support for <code>alias</code>es? If A is an alias of B, then the dual of A should just be the dual of B.</p>\n</li>\n<li>To make tagging easier, can there be a syntax (or lack of syntax) to indicate that the dual name should be the name followed by <code>OD</code>, if the name would otherwise be the same?</li>\n</ul>",
        "id": 513480195,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745275155
    },
    {
        "content": "<blockquote>\n<p>When I write <code>@[order_dual self (attr := simp)]</code>, does it apply the <code>simp</code> tag once or twice to the same lemma?</p>\n</blockquote>\n<p>Good question. <a href=\"https://github.com/leanprover-community/mathlib4/blob/49360a0442d6adc904f18913fd8b39fc1176a457/Mathlib/Tactic/ToAdditive/Frontend.lean#L1641\"><code>applyAttributes</code></a> and <a href=\"https://github.com/leanprover-community/mathlib4/blob/49360a0442d6adc904f18913fd8b39fc1176a457/Mathlib/Tactic/ToAdditive/Frontend.lean#L1688\"><code>copyMetadata</code></a> don't check if <code>src</code> and <code>tgt</code> are the same; is applying attributes not idempotent?</p>\n<p>The other bullet points / suggestions sound good to me other than the last one. The <code>OD</code> suffix was basically me being lazy and putting off thinking about names, so I'm hesitant to make it a permanent default; I'm fine if we make it a temporary syntax / convention though (i.e. add a TODO in the comments).</p>",
        "id": 513483631,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745277150
    },
    {
        "content": "<p>I would suggest making better names, but if you're just testing and the names are temporary then I guess it's fine.</p>",
        "id": 513483997,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745277391
    },
    {
        "content": "<p>I think whether attribute application is idempotent depends on the implementation of that attribute, (i.e. does it use a HashSet or an Array)</p>",
        "id": 513528479,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745304051
    },
    {
        "content": "<p>For the names, the main case in which I didn't know how to do the naming is if the theorem contains both ‚â§ and =, like <code>le_of_eq</code>. Because the order dual swaps the arguments in ‚â§ but not in =, so it's almost the same theorem again. Do we pick a keyword to append to the name? Like <code>le_of_eq_swapped</code>?</p>",
        "id": 513529029,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745304276
    },
    {
        "content": "<p>Some more points:</p>\n<ul>\n<li>Attribute syntax: I noticed that the syntax of <code>order_dual</code> takes the arguments self, existing, (reorder := ..) and (attr := ..), in any order (and even multiple times). I think it would be nicer for consistency to pick one order and enforce that. I've been going for <code>order_dual (self/existing)? attr? reorder? name?</code>.</li>\n<li>Syntax hovering: it would be nice if the attribute syntax had better hover information. This should include an example of the attribute syntax and the required order of arguments (from the above point), and also the hover information for the <code>attr :=</code> attributes. And more generally a basic explanation of <code>order_dual</code>.</li>\n<li><code>simp</code> Iff lemmas: for iff lemmas tagged with <code>simp</code>, lean uses some weird auxiliary lemma instead of just applying prop_ext every time. I ran into this issue yesterday and I could solve it by squeezing the <code>simp</code>, but that isn't a nice solution.</li>\n</ul>",
        "id": 513531140,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745305107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Order.20dual.20tactic/near/513529029\">said</a>:</p>\n<blockquote>\n<p>For the names, the main case in which I didn't know how to do the naming is if the theorem contains both ‚â§ and =, like <code>le_of_eq</code>. Because the order dual swaps the arguments in ‚â§ but not in =, so it's almost the same theorem again. Do we pick a keyword to append to the name? Like <code>le_of_eq_swapped</code>?</p>\n</blockquote>\n<p>Naming convention is <code>ge_of_eq</code></p>",
        "id": 513538265,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745307548
    },
    {
        "content": "<p>Do you mean that out of these three</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">le_of_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"n\">le_of_eq'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"n\">ge_of_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â•</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>the middle one should be called <code>ge_of_eq</code>?</p>",
        "id": 513538674,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745307694
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">le_trans'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"n\">ge_trans</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â•</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â•</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â•</span><span class=\"w\"> </span><span class=\"n\">c</span>\n</code></pre></div>\n<p>These two lemmas both exist, but your convention seems to imply <code>le_trans'</code> should be called <code>ge_trans</code>?</p>",
        "id": 513549464,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745310788
    },
    {
        "content": "<p>actually, in my opinion that one should be <code>le_comp</code></p>",
        "id": 513549802,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745310893
    },
    {
        "content": "<p>since it's precisely the difference between <code>comp</code> and <code>trans</code>, applied to <code>le</code></p>",
        "id": 513549934,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745310937
    },
    {
        "content": "<p>So would you suggest removing the current <code>ge_trans</code> in favour of the current <code>le_trans'</code>?</p>",
        "id": 513550065,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745310966
    },
    {
        "content": "<p>i don't see why yet</p>",
        "id": 513550287,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745311045
    },
    {
        "content": "<p>I find it a bit confusing with the <code>‚â§</code> vs <code>‚â•</code> notation and <code>le</code> vs <code>ge</code> naming. For the notation, appart from a few exceptions, we always use <code>‚â§</code>. And I thought that this should be reflected in the name: always use <code>le</code> for <code>‚â§</code>. But <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> is suggesting to use <code>ge</code> in the name for <code>‚â§</code> if the lemma is  generated by the order dual tactic. Don't you think that this would be very confusing?</p>",
        "id": 513551516,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745311419
    },
    {
        "content": "<p>yes. i guess the issue is that in our typical naming scheme, we hardly track where which free variables end up, which is <em>typically</em> precisely the difference between <code>le</code> and <code>ge</code></p>",
        "id": 513552638,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745311734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/513551516\">said</a>:</p>\n<blockquote>\n<p>@Ya√´l Dillies is suggesting to use <code>ge</code> in the name for <code>‚â§</code> if the lemma is generated by the order dual tactic. Don't you think that this would be very confusing?</p>\n</blockquote>\n<p>No, this is not the naming convention. The naming convention is approximately</p>\n<ol>\n<li>Turn <code>foo_le_bar</code> into <code>bar_le_foo</code></li>\n<li>If that fails (because eg <code>foo</code> = <code>bar</code> or there is another ambiguity), instead replace <code>le</code> with <code>ge</code></li>\n</ol>",
        "id": 513552961,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745311826
    },
    {
        "content": "<p>So far I'm mostly looking at lemmas where the two sides of <code>le</code> are free variables, so point 1 doesn't apply.</p>",
        "id": 513553187,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745311894
    },
    {
        "content": "<p>Then <code>le</code> ‚Üí <code>ge</code> it is. But I must warn you that point 1 really is the one that applies most often in practice</p>",
        "id": 513553349,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745311936
    },
    {
        "content": "<p>(I know it makes the naming algorithm much harder, there's a reason why I failed to write <code>to_dual</code> for several years!)</p>",
        "id": 513553427,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745311964
    },
    {
        "content": "<p>i guess it might be best if we can reserve an option to explicitly name the dual lemma?</p>",
        "id": 513553604,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745312026
    },
    {
        "content": "<p>Oh right, should we call it <code>to_dual</code> instead of <code>order_dual</code>? It is really about any kind of dual.</p>",
        "id": 513553757,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745312063
    },
    {
        "content": "<p>Yes, we can choose to override the the automatically generated name for the dual lemma</p>",
        "id": 513553857,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745312097
    },
    {
        "content": "<p>Yes, eg <span class=\"user-mention\" data-user-id=\"132603\">@Calle S√∂nne</span> is hoping to steal all your work on this tactic and apply it to category theory <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 513553863,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745312101
    },
    {
        "content": "<p>Ok, I'll make a PR to clean up some of these lemmas to use the <code>gt</code> and <code>ge</code> naming, but using <code>&lt;</code> and <code>‚â§</code>. But first I have <a href=\"https://github.com/leanprover-community/mathlib4/pull/24277\">#24277</a> to remove some <code>@[trans]</code> annotations.</p>",
        "id": 513589618,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745323088
    },
    {
        "content": "<p>If we want <code>to_dual</code> to dualize both order-theoretically and category-theoretically at the same time, then it might already be possible to start tagging theorems now with the current state of the attribute.</p>",
        "id": 513604914,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745327120
    },
    {
        "content": "<p>Some of the changes to the <code>to_additive</code> infrastructure should probably be PR-ed before <code>to_dual</code> itself. Your check that <code>to_additive existing</code> does the correct thing is very useful, and will probably find some mistakes in mathlib. (In fact I found one by accident here <a href=\"https://github.com/leanprover-community/mathlib4/pull/24283\">#24283</a>).</p>\n<p>Additionally I think <code>reorderForall</code> and <code>reorderLambda</code> should throw an error if the permutation numbers are out of bounds.</p>",
        "id": 513612937,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745329060
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span>, I'm trying to replace lemmas about <code>&gt;</code> with lemmas about <code>&lt;</code>, but still calling them <code>gt</code> when appropriate. Do you think the following lemmas should use <code>ge</code>/<code>gt</code> in the name?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">lt_or_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"n\">lt_or_lt_of_ne</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>the naming conventions seem to suggest the names I wrote, but the names <code>lt_or_ge</code> and <code>lt_or_gt_of_ne</code> also seem natural.</p>",
        "id": 514468034,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745618341
    },
    {
        "content": "<p>Both pairs of names are fine (and possibly we should have both)</p>",
        "id": 514468477,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745618569
    },
    {
        "content": "<p>cf <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=le_or_lt#doc\">docs#le_or_lt</a></p>",
        "id": 514468490,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745618578
    },
    {
        "content": "<p>Do you also think <code>Ne.lt_of_le' : b ‚â† a ‚Üí a ‚â§ b ‚Üí a &lt; b</code> should be renamed to <code>Ne.gt_of_ge</code>?</p>",
        "id": 514487732,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745632617
    },
    {
        "content": "<p>This one is a bit tougher in the sense that I think of it as having the <code>!=</code> reversed, not the <code>&lt;=</code> and <code>&lt;</code></p>",
        "id": 514508145,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745650230
    },
    {
        "content": "<p>I have tagged a bunch of category theory results now with <code>order_dual</code>. I ran into a few issues:</p>\n<ul>\n<li>Applying attributes in the case of <code>order_dual self</code>. I write <code>@[simp, order_dual self (reorder := ..)]</code>, but the linter complains that it wants <code>@[order_dual self (attr := simp) (reorder := ..)]</code>. So if we want the first form, then we should change the linter to complain about the second option instead of the first.</li>\n<li>Higher order functions. A few functions require swapping arguments inside an argument in order to be <code>order_dual</code> to themself, such as <code>Prefunctor.mk {V : Type u‚ÇÅ} [Quiver V] {W : Type u‚ÇÇ} [Quiver W] (obj : V ‚Üí W) (map : {X Y : V} ‚Üí (X ‚ü∂ Y) ‚Üí (obj X ‚ü∂ obj Y)) : V ‚•§q W</code> (need to swap <code>X</code> and <code>Y</code>). I could imagine extending the <code>reorder</code> syntax to support this, but that seems overly complicated, and otherwise we can just have such constants not be self-dual.</li>\n<li><code>IsThin</code> suffers the same problem as <code>decidableLE</code>, so we get the dual <code>IsThin'</code> which is equivalent to <code>IsThin</code>.</li>\n<li>When tagging a structure projection function with <code>order_dual (reorder := ..)</code>, the reordering doesn't apply if the projection is in the form of an <code>Expr.proj</code>. So I think we need to refold all of the <code>Expr.proj</code> expressions into their projection functions before transforming the expression. This comes up because the <code>reassoc</code> attribute creates such proof terms.</li>\n</ul>",
        "id": 514533280,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745669571
    },
    {
        "content": "<p>I noticed there is a special meaning when the number <code>0</code> appears in the <code>reorder := ..</code> syntax, which swaps the order of the first two universe variables. I think this is very confusing, and it isn't used or documented anywhere. Should we remove it?</p>",
        "id": 514533685,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745669886
    },
    {
        "content": "<p>Have you considered using <code>==</code> instead of <code>isDefEq</code> to check that the generated and actual order dual expressions are the same? I would expect that they should satisfy <code>==</code>.</p>",
        "id": 514533777,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745669992
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/514533685\">said</a>:</p>\n<blockquote>\n<p>I noticed there is a special meaning when the number <code>0</code> appears in the <code>reorder := ..</code> syntax, which swaps the order of the first two universe variables. I think this is very confusing, and it isn't used or documented anywhere. Should we remove it?</p>\n</blockquote>\n<p>I didn't realize this was unused. Maybe <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> has an opinion on this? (It seems the feature was added along with the reorder syntax in <a href=\"https://github.com/leanprover-community/mathlib/pull/7888\">!3#7888</a>)</p>",
        "id": 514536455,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745671940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/514533777\">said</a>:</p>\n<blockquote>\n<p>Have you considered using <code>==</code> instead of <code>isDefEq</code> to check that the generated and actual order dual expressions are the same? I would expect that they should satisfy <code>==</code>.</p>\n</blockquote>\n<p>I didn't consider it at all -- do you think it'd be beneficial? I can test it out when I have a chance, but if you're currently hacking on <code>order_dual</code>, maybe you're better poised to do so at the moment. I'd be interested to know the results.</p>",
        "id": 514536533,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745672031
    },
    {
        "content": "<p>I also renamed it to <code>to_dual</code> just now <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 514536629,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745672113
    },
    {
        "content": "<p>Ah actually I got confused about the off-by-one property of <code>reorder</code>. So what happens is that if <code>reorder := ..</code> contains a 1, then it reorders the first two universe variables, which is required for <code>HPow</code> -&gt; <code>HSMul</code>.</p>",
        "id": 514537934,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745673115
    },
    {
        "content": "<p>But I do think this could lead to surprising behaviour, as it is a hack.</p>",
        "id": 514538033,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745673171
    },
    {
        "content": "<p>I tried using <code>==</code>, which works fine. The change made it so that <code>LinearOrder.toDecidableLE</code> can't be self dual, but that is fine, as we can define <code>LinearOrder.toDecidableGE</code>. I also discovered the following weird universe thing in the process:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">run_meta</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"c1\">-- (Œ± : Type u) ‚Üí [inst : LT Œ±] ‚Üí Type (max 0 u)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">info</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">getConstInfo</span><span class=\"w\"> </span><span class=\"ss\">``DecidableLT</span>\n<span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"w\"> </span><span class=\"s2\">\"{info.type}\"</span>\n</code></pre></div>\n<p>Anyways, we do need a way to turn off the verification with syntax like <code>self!</code> or <code>existing!</code> (which I saw you suggested in a comment). The place where verification breaks is the constructor <code>CategoryTheory.Iso.mk</code>, where we need to swap the fields <code>hom_inv_id : hom ‚â´ inv = ùüô X := by aesop_cat</code> and <code>inv_hom_id : inv ‚â´ hom = ùüô Y := by aesop_cat</code>, but the two <code>by aesop_cat</code> <code>autoParam</code>s aren't <code>==</code> to eachother (which is a bit unfortunate)</p>",
        "id": 514550633,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745682212
    },
    {
        "content": "<p>I made a PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/24401\">#24401</a>) that introduces <code>to_dual</code>'s verification step into <code>to_additive</code>, and I had to fix around 20 files where warnings were shown.</p>",
        "id": 514638336,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745754461
    },
    {
        "content": "<p>Also, my PR refactoring order lemmas is now at the new <a href=\"https://github.com/leanprover-community/mathlib4/pull/24396\">#24396</a>, because in the previous PR it was getting unmanageable to fix all of the broken proofs. So instead I've added the old names as aliases, with a TODO to deprecate them.</p>",
        "id": 514638566,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745754624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/514536455\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/514533685\">said</a>:</p>\n<blockquote>\n<p>I noticed there is a special meaning when the number <code>0</code> appears in the <code>reorder := ..</code> syntax, which swaps the order of the first two universe variables. I think this is very confusing, and it isn't used or documented anywhere. Should we remove it?</p>\n</blockquote>\n<p>I didn't realize this was unused. Maybe <span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> has an opinion on this? (It seems the feature was added along with the reorder syntax in <a href=\"https://github.com/leanprover-community/mathlib/pull/7888\">!3#7888</a>)</p>\n</blockquote>\n<p>Oh, I thought I had documented that. <br>\nIt is definitely used in <code>to_additive</code>. The universes have to be reordered correctly as well, and as a hack, I only implemented the following case: if the first two arguments are reordered, <code>to_additive</code> assumes that both of them are types, and then also reorders the first two universe levels. This is a very common scenario, and was necessary for many lemmas <code>to_additive</code> generates with the <code>reorder</code> option. Not reordering them would cause failures when declarations using the faulty one are additivized. <br>\nOf course, this is a hack. Feel free to implement a more robust solution.</p>",
        "id": 514694863,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1745796724
    },
    {
        "content": "<p>Oh, I now read further and see that Jovan also realized this.</p>",
        "id": 514695101,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1745796937
    },
    {
        "content": "<p>(Note that the universes are swapped when doing any permutation involving the first argument, not just a swap with the second argument)</p>",
        "id": 514766350,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745832896
    },
    {
        "content": "<p>Should we use <code>export LinearOrder (le_total min_def max_def)</code> instead of having two identical lemmas in the root and <code>LinearOrder</code> namespaces? The duplication is a bit annoying for tagging.</p>",
        "id": 514857283,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745857863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/514857283\">said</a>:</p>\n<blockquote>\n<p>Should we use <code>export LinearOrder (le_total min_def max_def)</code> instead of having two identical lemmas in the root and <code>LinearOrder</code> namespaces? The duplication is a bit annoying for tagging.</p>\n</blockquote>\n<p>It's useful to not use <code>export</code> because then the lemmas show up under the expected name in the docs (hopefully doc-gen can be fixed to avoid needing this hack)</p>",
        "id": 514877698,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745864477
    }
]