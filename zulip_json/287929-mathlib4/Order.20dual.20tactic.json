[
    {
        "content": "<p>I would imagine this has been discussed before but: is there any progress on a tactic alike <code>to_additive</code> that converts a theorem to its order-dual version?</p>",
        "id": 486753168,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1733650477
    },
    {
        "content": "<p>Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">SuccPred</span><span class=\"bp\">.</span><span class=\"n\">Limit</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Order</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_order_dual</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">-- IsPredLimit a ‚Üî a ‚â† ‚ä§ ‚àß IsPredPrelimit a</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isSuccLimit_iff'</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OrderBot</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsSuccLimit</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"bp\">‚ä•</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">IsSuccPrelimit</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">isSuccLimit_iff</span>\n</code></pre></div>",
        "id": 486753335,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1733650631
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span></p>",
        "id": 486753628,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1733650882
    },
    {
        "content": "<p>No more than last time, at least as much as I'm aware of. <span class=\"user-mention\" data-user-id=\"132603\">@Calle S√∂nne</span> was interested in the category theoretical version but has since been plagued with painful wrists like me</p>",
        "id": 486754980,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1733652033
    },
    {
        "content": "<p>One complication here is that you would expect it to sometimes reorder arguments</p>",
        "id": 486765320,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1733660364
    },
    {
        "content": "<p>And sometimes you want it to generate <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>‚àí</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^n - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7477em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> lemmas for some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n &gt; 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></p>",
        "id": 486776968,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1733670280
    },
    {
        "content": "<p>I would imagine that even this basic version could already get rid of a lot of cruft throughout the library</p>",
        "id": 486807771,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1733695931
    },
    {
        "content": "<p>Other examples of order duals would include <code>Sup</code> and <code>Inf</code>, or <code>IsMin</code> and <code>IsMax</code>, or <code>IsLUB</code> and <code>IsGLB</code>, ...</p>",
        "id": 486807819,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1733695995
    },
    {
        "content": "<p>I've started playing around with using the <code>to_additive</code> infrastructure to make an <code>order_dual</code> tactic in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21719\">#21719</a>. (<a href=\"https://github.com/leanprover-community/mathlib4/pull/21696\">#21696</a> is where I'm putting non-<code>order_dual</code>-specific changes to <code>to_additive</code>.) I'm a relative newcomer to metaprogramming, so I'd be happy to collaborate with anyone who's interested!</p>\n<p>I'm currently stuck on a decidable instance which isn't getting translated:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"n\">ite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"n\">argument</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n</code></pre></div>",
        "id": 499009948,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739280639
    },
    {
        "content": "<p>I look forward to this very much!  In my experiments, the main issue was generating the \"correct\" ordering of the variable names in the statements, plus some twisted difficulty with associativity for statements involving more than 2 elements.</p>",
        "id": 499029104,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739286001
    },
    {
        "content": "<p>Ah, sounds like your experiments may have proceeded farther than mine... if you've got any notes or old code still lying around I'd love to take a look.</p>",
        "id": 499030693,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739286385
    },
    {
        "content": "<p>I think that <a href=\"https://github.com/leanprover-community/mathlib4/pull/12528\">#12528</a> was one of the latest experiments that I had.  It is not at all polished!</p>",
        "id": 499032848,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739286975
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> I had a quick look at <a href=\"https://github.com/leanprover-community/mathlib4/pull/12528\">#12528</a> and it looks like you implemented some useful functions! I'm still working on figuring out the <code>to_additive</code> machinery, but hopefully what you wrote can be plugged in somewhere...</p>",
        "id": 499131470,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739325483
    },
    {
        "content": "<p>As a general progress report, the very simple approach of just replacing the multiplicative-&gt;additive dictionaries with an order-dual dictionary and using <code>to_additive</code>'s <code>reorder</code> to reverse the arguments of every <code>‚â§</code> in sight in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21719\">#21719</a>  is now stuck at <code>LinearOrder.lean</code> and <code>WithBot.lean</code> with different issues. I'll keep digging into what's going on so I can try to ask more focused questions later, but any experts with spare time are welcome to take a look and suggest / push fixes.</p>",
        "id": 499132814,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739326287
    },
    {
        "content": "<p>If I remember correctly, I did not hook into the <code>to_additive</code> machinery, but made a simple syntactic translation, so I think that your approach probably complements nicely the one that I had started.</p>",
        "id": 499177062,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739350163
    },
    {
        "content": "<p>I am definitely interested in this automation and I have had it in the back of my mind for a while: I'll help, but also do remind me, in case I get distracted by other projects!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 499177259,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739350215
    },
    {
        "content": "<p>I made some progress on understanding what is broken in <code>LinearOrder.lean</code>. It turns out the na√Øve approach of just swapping the arguments to <code>‚â§</code> is incompatible with the definition of <code>max</code> that we're using. Compare:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">min</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>If we just swap the arguments of <code>‚â§</code>, then <code>min</code> would get translated to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>(which is actually what mathlib3 used up until <a href=\"https://github.com/leanprover-community/mathlib3/pull/17470\">mathlib3#17470</a>). </p>\n<p>Now if we change the definition of <code>max</code> back to this, then <code>order_dual</code> seems to work quite well translating theorems about min and max... until we try to define a linear order on the natural numbers, where all hell breaks loose because max is defined in core with the first definition -- which is of course the reason that we had to land <a href=\"https://github.com/leanprover-community/mathlib3/pull/17470\">mathlib3#17470</a> in the first place.</p>\n<p>It is possible to manually apply the attribute to any lemmas whose proofs unfold <code>max</code> or <code>min</code> to <code>‚â§</code>, so I'll try doing that next. I'm hoping we eventually get to a point where the max / min API gets sealed off and <code>order_dual</code> can take over.</p>",
        "id": 499372660,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739418027
    },
    {
        "content": "<p>or maybe core just has the wrong definition of max</p>",
        "id": 499834445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739568923
    },
    {
        "content": "<p>and possibly things have changed enough that we can actually have the backport go the other way around</p>",
        "id": 499834524,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739568962
    },
    {
        "content": "<p>I haven't made it that much further yet but so far the <code>min</code> <code>max</code> messiness seems to be contained to a handful of lemmas.</p>",
        "id": 499840001,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739570954
    },
    {
        "content": "<p>I mean sure we can keep working around this but I think the only reason we backported at the time was because core is annoying to PR to and it still kinda is but less so</p>",
        "id": 499840159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739571021
    },
    {
        "content": "<p>I'm almost certain whoever wrote that definition of max did not think about this issue at all and just wrote the first ordering that came to mind</p>",
        "id": 499840263,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739571076
    },
    {
        "content": "<p>My first reaction was certainly the same: wow things would be much cleaner if we just switched the definition back. But as I tag more and more lemmas with <code>order_dual</code>  I'm less and less sure that I'm not just imposing my own arbitrary choices when I tell the tactic to re-order variables.</p>",
        "id": 499840823,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739571335
    },
    {
        "content": "<p>Today's progress update (all work can be found in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21719\">#21719</a>): As always, any feedback / questions here or on the PR is welcome!</p>\n<p>I've now managed to tag most lemmas where the <code>order_dual</code> applies through the start of <code>Order.Basic</code>. Up to now I've been doing it all \"by feel\", so I think now is a good time to try and put the process into words, if just for my own benefit. So far most of the declarations <code>order_dual</code> has been applied to are just simple statements about <code>&lt;</code> and <code>‚â§</code>, with a few that mention <code>min</code> and <code>max</code>; I did do some tests with <code>WithBot</code> and <code>WithTop</code> as well, but maybe I'll talk about those in a later post. </p>\n<p>First, everything starts at the top of <a href=\"https://github.com/leanprover-community/mathlib4/blob/916de1187bc9ebeefd327879a48905a477f6e9ed/Mathlib/Order/Defs/PartialOrder.lean#L28\">Order.Defs.PartialOrder</a>, where I decided that <code>order_dual</code> should transform <code>a ‚â§ b</code> to <code>b ‚â§ a</code> (and similarly <code>a &lt; b</code> should be transformed to <code>b &lt; a</code>, etc.):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">GE</span><span class=\"bp\">.</span><span class=\"n\">ge</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">GE</span><span class=\"bp\">.</span><span class=\"n\">ge</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">GT</span><span class=\"bp\">.</span><span class=\"n\">gt</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">GT</span><span class=\"bp\">.</span><span class=\"n\">gt</span>\n</code></pre></div>\n<p>Here you can see the use of <code>to_additive</code>'s <code>reorder</code> option to swap the arguments of these functions.</p>\n<p>Now that these have been registered, <code>order_dual</code> can transform theorems or defs that mention any of these functions to their dual versions, where \"dual\" just means that the LHS and RHS of every <code>‚â§</code>, <code>&lt;</code>, etc. in sight have been swapped. Note that a theorem like <code>le_rfl : a ‚â§ a</code> is manifestly self-dual so there's no reason to tag it with <code>order_dual</code> as the default behavior is to do nothing.</p>\n<p>So now suppose we have a declaration where <code>order_dual</code> actually transforms it into something different. Consider the resulting dual declaration:</p>\n<p>Case 1: Most of the time, the transformed version is just some slight variation of the original theorem that no one has needed up until now. For the time being, I'm manually naming these theorems as the original name + <code>OD</code> as a suffix:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">le_of_lt_or_eqOD</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">-- {a b : Œ±} (h : b &lt; a ‚à® a = b) : b ‚â§ a</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">le_of_lt_or_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">le_of_eq</span>\n<span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">le_of_eq_or_ltOD</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">-- {a b : Œ±} (h : a = b ‚à® b &lt; a) : b ‚â§ a</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">le_of_eq_or_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">le_of_eq</span><span class=\"w\"> </span><span class=\"n\">le_of_lt</span>\n</code></pre></div>\n<p>It's a bit unfortunate that this leads to a bunch of new trivial theorems, but we need to add these variants so that <code>order_dual</code> will know how to transform the source theorems properly when they show up in proofs later on.</p>\n<p>Case 2: Sometimes we get lucky and the transformed version of a theorem is secretly the same theorem except with some arguments permuted. In that case we just register the theorem as the dual version of itself with <code>reorder</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">lt_iff_le_not_le</span><span class=\"kd\">]</span>\n<span class=\"c1\">-- note that swapping the LHS and RHS of &lt; and ‚â§ below yields:</span>\n<span class=\"c1\">-- b &lt; a ‚Üî b ‚â§ a ‚àß ¬¨a ‚â§ b</span>\n<span class=\"c1\">-- which is also what we get if we swap a and b</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lt_iff_le_not_le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">lt_iff_le_not_le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>Case 3: Sometimes we get even more lucky and the transformed theorem happens to be one that is proved later on in the file. This is the happy case where <code>order_dual</code> will let us delete lines of code (though I'm just commenting things out for now):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trans</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">gt_of_gt_of_ge</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lt_of_lt_of_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_le_not_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">not_le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trans</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">gt_of_ge_of_gt</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lt_of_le_of_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_le_not_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">not_le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- @[trans] lemma gt_of_gt_of_ge (h‚ÇÅ : a &gt; b) (h‚ÇÇ : b ‚â• c) : a &gt; c := lt_of_le_of_lt h‚ÇÇ h‚ÇÅ</span>\n<span class=\"c1\">-- @[trans] lemma gt_of_ge_of_gt (h‚ÇÅ : a ‚â• b) (h‚ÇÇ : b &gt; c) : a &gt; c := lt_of_lt_of_le h‚ÇÇ h‚ÇÅ</span>\n</code></pre></div>\n<p>One thing that I've been treating inconsistently is whether I should identify variations that use <code>ge</code> and <code>gt</code> as the same as the ones with <code>le</code> and <code>lt</code>. Also, case is still relatively rare so far, but I expect that the proportion will be higher for pairs of theorems about <code>min</code> <code>max</code> <code>top</code> <code>bot</code>, etc. rather than these theorems about <code>le</code> and <code>lt</code>.</p>\n<p>I think we eventually want special <code>order_dual self</code> syntax for <code>order_dual</code> to verify case 2, since it's easy to screw up the reordering. Also, it would be nice to have some automation to search for case 3 theorems as well, since searching for defeq theorems later in the file with a different name than expected is a bit annoying. Previously I was also trying to use <code>reorder</code> to try to match up the output of <code>order_dual</code> with later declarations, but I kept making mistakes, so I ended up undoing all of those and using <code>reorder</code> only when we get back the original declaration. Maybe there's some way to use automation here as well?</p>\n<p>I haven't given much thought at all to how <code>order_dual</code> should be changing the names of theorems like these at all - this might help with identifying case 3 declarations. Right now, <code>order_dual</code> only knows to change <code>min</code> to <code>max</code>, <code>bot</code> to <code>top</code>, <code>sup</code> to <code>inf</code>, so theorems about <code>lt</code> and <code>le</code> just end up with the same name.</p>",
        "id": 499882068,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739595581
    },
    {
        "content": "<p>(I don't mean to sidetrack you but my sincere thanks for this! It'll really come in handy in a lot of places)</p>",
        "id": 499884309,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1739597708
    },
    {
        "content": "<p>I think it's fine and even expected that <code>lt</code> and <code>le</code> should be kept the same. The only exception is when this would lead to the entire name being the same for two different theorems, which ime is where a lot of these <code>ge</code>/<code>gt</code> theorems come from.</p>",
        "id": 499884589,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1739597999
    },
    {
        "content": "<p>Are you planning to hit a certain tagging goal before PRing the tactic? I think it's important to have a working proof of concept before we get this into Mathlib, but tagging everything that could be tagged is complete overkill at this point.</p>",
        "id": 499884678,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1739598070
    },
    {
        "content": "<p>Yeah, I‚Äôm not sure how far I should tag before cleaning up the tactic changes. I kind of want to see if I can get to lattices, but maybe it‚Äôs already useful enough?</p>",
        "id": 499887054,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739600461
    },
    {
        "content": "<p>(If anyone feels like pushing some commits tagging more lemmas and defs to my branch while I‚Äôm sleeping I certainly don‚Äôt mind!)</p>",
        "id": 499887225,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739600618
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/499882068\">said</a>:</p>\n<blockquote>\n<p>Case 3: Sometimes we get even more lucky and the transformed theorem happens to be one that is proved later on in the file. This is the happy case where <code>order_dual</code> will let us delete lines of code (though I'm just commenting things out for now):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trans</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">gt_of_gt_of_ge</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lt_of_lt_of_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_le_not_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">not_le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trans</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">gt_of_ge_of_gt</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lt_of_le_of_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_le_not_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">not_le_of_lt</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">hca</span><span class=\"w\"> </span><span class=\"n\">hab</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- @[trans] lemma gt_of_gt_of_ge (h‚ÇÅ : a &gt; b) (h‚ÇÇ : b ‚â• c) : a &gt; c := lt_of_le_of_lt h‚ÇÇ h‚ÇÅ</span>\n<span class=\"c1\">-- @[trans] lemma gt_of_ge_of_gt (h‚ÇÅ : a ‚â• b) (h‚ÇÇ : b &gt; c) : a &gt; c := lt_of_lt_of_le h‚ÇÇ h‚ÇÅ</span>\n</code></pre></div>\n</blockquote>\n<p>By the way, I don't exactly consider this example a win, the <code>order_dual</code> tactic produces a proof from scratch by \"copy paste\" while the original proof was much shorter because it's defeq to an existing lemma</p>",
        "id": 499918318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739629579
    },
    {
        "content": "<p>given the additional issue about <code>gt</code> here I would be enclined to just tag the latter lemma rather than trying to translate it</p>",
        "id": 499918509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739629747
    },
    {
        "content": "<p>Yeah, that makes sense! This is along the lines of something I mentioned at the end of my message, but one thing about tagging lemmas after the fact with <code>existing</code> is that <code>order_dual</code> no longer goes through the proof and checks that things translate properly, so it's easy to accidentally add a tag that's nonsense. What I've been doing is temporarily generating a new lemma and then checking with an <code>example</code> that it is indeed defeq to the other declaration - it'd be nice if there was some kind of automated checking here (though I haven't thought through exactly what I want, I guess).</p>",
        "id": 499919118,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739630219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/499919118\">said</a>:</p>\n<blockquote>\n<p>but one thing about tagging lemmas after the fact with <code>existing</code> is that <code>order_dual</code> no longer goes through the proof and checks that things translate properly, so it's easy to accidentally add a tag that's nonsense</p>\n</blockquote>\n<p>that sounds fixable? <code>order_dual</code> / <code>to_additive</code> should be able to validate these at attribute application time</p>",
        "id": 499925644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739635168
    },
    {
        "content": "<p>Yes, we're open to change the definitions up in Lean, but I'd like to be presented with a \"yes, it all works, including Mathlib, and people have signed off on the fact the change really makes tactic implementations easier\" PR if possible. I don't have time to do this myself right now.</p>",
        "id": 499968190,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739670533
    },
    {
        "content": "<p>I finally found some time this week to come back to this and I've added the <code>order_dual self</code> syntax that I mentioned earlier, so tagging self-dual lemmas is now a lot less verbose. </p>\n<p>I also attempted to add some validation for <code>order_dual self</code> and <code>order_dual existing</code> to check that the type of the declaration generated by <code>order_dual</code> (after variable reordering) is indeed defeq to the type of the original declaration itself (for <code>self</code>) or the type of the provided declaration (for <code>existing</code>), respectively. However, I'm getting mismatches where there just seems to be a difference in a universe variable:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>order_dual failed validation!\ntgt type:\n‚àÄ {Œ± : Type u_2} [self : Preorder Œ±] (a b c : Œ±), a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c,\ntransformed type:\n‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] (a b c : Œ±), a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c\n</code></pre></div>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/ba1dc0721375f4ff78952e683ae23140c81aade0/Mathlib/Tactic/ToAdditive/Frontend.lean#L1675-L1683\">The main validation code consists of these 8 lines or so</a>, and I was already well outside my metaprogramming comfort zone when I wrote them, so there's probably some obvious mistake(s). </p>\n<p>Before PRing, I also need to refactor things to separate out the parts of the code which are specific to <code>to_additive</code>, so I would appreciate it anyone has any suggestions on how to do this cleanly; more generally, any comments about the current state of the meta code are very welcome!</p>",
        "id": 505520343,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741898068
    },
    {
        "content": "<p>I do not know how <code>AttrM</code> works, but couldn't you try to combine the two <code>MetaM.run</code>s into a single one?</p>",
        "id": 505522539,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741898818
    },
    {
        "content": "<p>I think that the universe level information may be stored in the <code>MetaM</code> state somewhere and maybe the two runs do not keep track of the same assignments?</p>",
        "id": 505522661,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741898858
    },
    {
        "content": "<p>Thanks Damiano! However, I tried putting <code>isDefEq</code> into the same function that generates the order dual type in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21719/commits/a4cc18836952566c2a70a5dc51237e68d8a70d24\">the next commit</a> and unfortunately I'm still getting the same errors.</p>",
        "id": 505525356,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741899806
    },
    {
        "content": "<p>Ok, so maybe \"manually\" creating fresh (universe) metavariables before unification might help?</p>",
        "id": 505525551,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741899858
    },
    {
        "content": "<p>How does <code>to_additive</code> do it?</p>",
        "id": 505525641,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741899886
    },
    {
        "content": "<p>I'm not sure that <code>to_additive</code> has this check.</p>",
        "id": 505525716,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741899906
    },
    {
        "content": "<p>In fact, today I was goofing around and you can actually place multiple copies of the <code>to_additive</code> attribute on the same declaration and you get new \"identical\" declarations.</p>",
        "id": 505525857,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741899954
    },
    {
        "content": "<p>(You need to give them manually different names, though, since the environment catches the name clash otherwise.)</p>",
        "id": 505525979,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741899981
    },
    {
        "content": "<p>In that case I would instantiate one with universe variables and the other one with fresh universe metavariables, and do a defeq check on those. Then do it the other way around too to be safe.</p>",
        "id": 505526322,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741900103
    },
    {
        "content": "<p>OK, thanks! I guess the issue is the one that Kyle mentioned in <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/Checking.20defeq.20in.20Command/near/389771514\">#lean4 &gt; Checking defeq in Command @ üí¨</a> . Unfortunately his snippet starts with <code>Name</code>s not <code>Expr</code>s. Is there an easy way to refresh universe metavariables in my use case?</p>\n<p>For reference here's the current checking code (far from an MWE, see <a href=\"https://github.com/leanprover-community/mathlib4/pull/21719\">#21719</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">checkDeclType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BundledExtensions</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">srcDecl</span><span class=\"w\"> </span><span class=\"n\">tgtDecl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ConstantInfo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">srcDecl.updateName</span><span class=\"w\"> </span><span class=\"n\">tgt</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">reorder.flatten</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">decl.updateLevelParams</span><span class=\"w\"> </span><span class=\"n\">decl.levelParams.swapFirstTwo</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">applyReplacementFun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">reorderForall</span><span class=\"w\"> </span><span class=\"n\">reorder</span>\n<span class=\"w\">    </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">expand</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">unfoldAuxLemmas</span><span class=\"w\"> </span><span class=\"n\">decl.type</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">‚ü®</span><span class=\"n\">exp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"n\">tgtDecl.type</span><span class=\"o\">‚ü©</span>\n</code></pre></div>\n<p>and I guess I need to do more setup with <code>exp</code> and <code>tgtDecl.type</code> before passing them to <code>isDefEq</code>.</p>\n<p><strong>edit</strong>: this was resolved in <a class=\"message-link\" href=\"/#narrow/channel/239415-metaprogramming-.2F-tactics/topic/checking.20if.20two.20Exprs.20are.20defeq/near/506000231\">#metaprogramming / tactics &gt; checking if two Exprs are defeq @ üí¨</a></p>",
        "id": 505530995,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741901949
    },
    {
        "content": "<p>You can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.ConstantInfo.instantiateTypeLevelParams#doc\">docs#Lean.ConstantInfo.instantiateTypeLevelParams</a></p>",
        "id": 505533386,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741902948
    },
    {
        "content": "<p>If I understand correctly, Bryan wants to do this for the \"new\" expr, the one that does not have a corresponding declaration.</p>",
        "id": 505533599,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741903037
    },
    {
        "content": "<p><del>You can <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.ConstantInfo.updateType#doc\">docs#Lean.ConstantInfo.updateType</a> an existing declaration.</del></p>",
        "id": 505534910,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741903582
    },
    {
        "content": "<p>You mentioned having trouble with the order on <code>WithBot</code>and <code>WithTop</code>. Note that there is some ongoing work on refactoring these definitions at <a href=\"https://github.com/leanprover-community/mathlib4/pull/19668\">#19668</a>, by <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span>.</p>",
        "id": 505556365,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741914406
    },
    {
        "content": "<p>For the time being I've just turned the validation error into a <code>logInfo</code> so I can continue. Interestingly, I'm now seeing panics in later files coming from the <code>reorderForall</code> function where sometimes the validation function is sending an expression with too few arguments. So there's probably something else wrong in my approach here...</p>",
        "id": 505573545,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741922940
    },
    {
        "content": "<p>In the <code>reorderForall</code> function, you accidentally replaced <code>mkForallFVars</code> by <code>mkLambdaFVars</code>, which gives the mismatch.</p>",
        "id": 505665716,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741956316
    },
    {
        "content": "<p>Ah that was silly of me! Fixing that does get rid of most of the mismatches, but it looks like there are still two remaining coming from: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">reorderForall tried to reorder a list that was too small:</span>\n<span class=\"cm\">forall {Œ± : Type.{u_2}} [self : LinearOrder.{u_2} Œ±],</span>\n<span class=\"cm\">  DecidableRel.{succ u_2, succ u_2} Œ± Œ± (fun (x1._@.Mathlib.Order.Defs.LinearOrder._hyg.636 : Œ±)</span>\n<span class=\"cm\">    (x2._@.Mathlib.Order.Defs.LinearOrder._hyg.636 : Œ±) =&gt;</span>\n<span class=\"cm\">  LE.le.{u_2} Œ± (Preorder.toLE.{u_2} Œ± (PartialOrder.toPreorder.{u_2} Œ± (LinearOrder.toPartialOrder.{u_2} Œ± self))) x1._@.Mathlib.Order.Defs.LinearOrder._hyg.636 x2._@.Mathlib.Order.Defs.LinearOrder._hyg.636)</span>\n<span class=\"cm\">#[_uniq.1658, _uniq.1659]</span>\n<span class=\"cm\">[[2, 3]]</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">decidableLE</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">reorderForall tried to reorder a list that was too small:</span>\n<span class=\"cm\">forall {Œ± : Type.{u_2}} [self : LinearOrder.{u_2} Œ±],</span>\n<span class=\"cm\">  DecidableRel.{succ u_2, succ u_2} Œ± Œ± (fun (x1._@.Mathlib.Order.Defs.LinearOrder._hyg.661 : Œ±)</span>\n<span class=\"cm\">    (x2._@.Mathlib.Order.Defs.LinearOrder._hyg.661 : Œ±) =&gt;</span>\n<span class=\"cm\">  LT.lt.{u_2} Œ± (Preorder.toLT.{u_2} Œ± (PartialOrder.toPreorder.{u_2} Œ± (LinearOrder.toPartialOrder.{u_2} Œ± self))) x1._@.Mathlib.Order.Defs.LinearOrder._hyg.661 x2._@.Mathlib.Order.Defs.LinearOrder._hyg.661)</span>\n<span class=\"cm\">#[_uniq.1691, _uniq.1692]</span>\n<span class=\"cm\">[[2, 3]]</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">decidableLT</span>\n</code></pre></div>\n<p>in <code>Order.Defs.LinearOrder</code>. </p>\n<p>If I had to guess, probably the functions from <code>to_additive</code> don't handle <code>DecidableRel</code> well?</p>",
        "id": 505672895,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741958387
    },
    {
        "content": "<p>A priori <code>DecidableRel</code> is not a forall. Only after unfolding it, does it become a forall (Luckily it is reducible, so in the <code>reducible</code> transparency it is a forall). So the fix is probably to replace some ForallTelescope by ForallTelescopeReducing. (And making sure you are in the <code>reducible</code> tranparency)</p>",
        "id": 505677818,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741959611
    },
    {
        "content": "<p>Although I'm not sure if reducing abbreviations is wanted in general. To avoid unnecessarily unfolding reducibles, you can use ForallBoundedTelescopeReducing (or something like that). This one only unfolds up to how many foralls you want to have.</p>",
        "id": 505680683,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741960348
    },
    {
        "content": "<p>I don't think I fully understand what the role/purpose is of reordering the arguments in <code>LinearOrder.decidableLE</code>. Can you explain why they should be swapped?</p>",
        "id": 505714274,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741968796
    },
    {
        "content": "<p>I can't say I fully understand it either, but without the reordering it seems like the instance doesn't apply when we need it to. <del>Looks like the first failure is <code>lt_trichotomy</code>:</del> (edit: let me look for the actual first failure...)</p>",
        "id": 505718709,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741969980
    },
    {
        "content": "<p>I looked at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Decidable.lt_or_eq_of_le#doc\">docs#Decidable.lt_or_eq_of_le</a>, and I'm confused why this theorem exists, because it is weaker than <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=lt_or_eq_of_le#doc\">docs#lt_or_eq_of_le</a>. I thought mathlib was a classical mathematics library.</p>",
        "id": 505719790,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741970281
    },
    {
        "content": "<p>I think that it is a classical mathematical library <em>outside the <code>Decidable</code> namespace</em>.</p>",
        "id": 505720038,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741970340
    },
    {
        "content": "<p>This theorem dates back to the core lean 3 repository. I'm not sure anyone would mind if it disappeared</p>",
        "id": 505720544,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1741970466
    },
    {
        "content": "<p>OK, if I remove <code>Decidable</code> from the proof of <code>lt_trichotomy</code>, then <code>order_dual</code> (without reordering in <code>LinearOrder.decidableLE</code>) is happy with it, however things blow up just a little bit further below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">application type mismatch</span>\n<span class=\"cm\">  dite (a ‚â§ b)</span>\n<span class=\"cm\">argument has type</span>\n<span class=\"cm\">  Decidable ((fun x1 x2 ‚Ü¶ x1 ‚â§ x2) b a)</span>\n<span class=\"cm\">but function has type</span>\n<span class=\"cm\">  ‚àÄ [h : Decidable (a ‚â§ b)],</span>\n<span class=\"cm\">    (a ‚â§ b ‚Üí b &lt; a ‚à® a ‚â§ b) ‚Üí (¬¨a ‚â§ b ‚Üí b &lt; a ‚à® a ‚â§ b) ‚Üí b &lt; a ‚à® a ‚â§ b</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">@[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">lt_or_leOD</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lt_or_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">hba</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">hba</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">lt_of_not_ge</span><span class=\"w\"> </span><span class=\"n\">hba</span>\n</code></pre></div>",
        "id": 505722441,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741970969
    },
    {
        "content": "<p>Can you show this with <code>pp.explicit</code>? The problem is in the invisible instance.</p>",
        "id": 505723963,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741971318
    },
    {
        "content": "<p>Sure, here you go!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">dite</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLT</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">decidableLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"n\">argument</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Decidable</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"bp\">‚àÄ</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">      </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)],</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span>\n<span class=\"w\">        </span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLT</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span>\n<span class=\"w\">          </span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLT</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span>\n<span class=\"w\">        </span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLT</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 505724343,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741971412
    },
    {
        "content": "<p>It's the classic \"<code>(if a ‚â§ b then a else b) = (if b ‚â§ a then b else a)</code> is not defeq\", no?</p>",
        "id": 505724737,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1741971519
    },
    {
        "content": "<p>I think the easiest way to fix this would just be to reorder the arguments to <code>LinearOrder.decidableLE</code>.</p>",
        "id": 505725915,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741971831
    },
    {
        "content": "<p>Right, the proof was working when <code>attribute [order_dual self (reorder := 3 4)] LinearOrder.decidableLE</code> was not commented out, so (as in the short version of the error) I think it's just that the known decidability of  <code>‚â§</code> doesn't apply to <code>(fun x2 x1 ‚Ü¶ x1 ‚â§ x2)</code>.</p>",
        "id": 505726020,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741971849
    },
    {
        "content": "<p>It looks like you need to change <a href=\"https://github.com/leanprover-community/mathlib4/blob/b6bf9080892e7d60f3397b51efee21fa0988021a/Mathlib/Tactic/ToAdditive/Frontend.lean#L973-L981\">these lines</a> to a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.forallBoundedTelescope#doc\">docs#Lean.Meta.forallBoundedTelescope</a>.</p>",
        "id": 505728700,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741972670
    },
    {
        "content": "<p>Thanks! Looks like that worked. Now it's just the issue with the universe names confusing <code>isDefEq</code>.</p>",
        "id": 505730599,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741973208
    },
    {
        "content": "<p>In your implementation, you didn't pass a bound to <code>forallBoundedTelescope</code>, which kind of defeats the purpose of using <code>forallBoundedTelescope</code> over <code>forallTelescopeReducing</code>. You can instead pass it the bound <code>reorder.flatten.max?</code> (and if the <code>Option</code> value is none, then don't telescope at all, since there is nothing to reorder)</p>",
        "id": 505747372,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741978714
    },
    {
        "content": "<p>Makes sense! I guess I'll do the same thing with <code>lambdaBoundedTelescope</code> in <code>reorderLambda</code>.</p>",
        "id": 505751356,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741980110
    },
    {
        "content": "<p>Oh and I said earlier to use the <code>reducible</code> transparency, but I take that back, because now that we're using a bounded telescope, it will only reduce if explicitly told to do so. (Assuming you didn't modify the transparency yourself, it's set to <code>default</code> by default, so you don't need to change it)</p>",
        "id": 505752532,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741980590
    },
    {
        "content": "<p>Right, I didn't change the transparency at all. </p>\n<p>Here's what I have now (I had to add a <code>+1</code> to the bound but it works):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Reorder pi-binders. See doc of `reorderAttr` for the interpretation of the argument -/</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">reorderForall</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">maxReorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">reorder.flatten.max</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">forallBoundedTelescope</span><span class=\"w\"> </span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">maxReorder</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">xs.size</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">maxReorder</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"n\">mkForallFVars</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs.permute</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">reorder</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">      </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"n\">dbg_trace</span><span class=\"w\"> </span><span class=\"s2\">\"reorderForall tried to reorder a list that was too small:</span><span class=\"se\">\\n</span><span class=\"err\">\\</span>\n<span class=\"s2\">          {src}</span><span class=\"se\">\\n</span><span class=\"s2\">{xs}</span><span class=\"se\">\\n</span><span class=\"s2\">{reorder}\"</span>\n<span class=\"w\">        </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">src</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">src</span>\n\n<span class=\"sd\">/-- Reorder lambda-binders. See doc of `reorderAttr` for the interpretation of the argument -/</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">reorderLambda</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">maxReorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">reorder.flatten.max</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">lambdaBoundedTelescope</span><span class=\"w\"> </span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">maxReorder</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">xs.size</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">maxReorder</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs.permute</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">reorder</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">      </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"n\">dbg_trace</span><span class=\"w\"> </span><span class=\"s2\">\"reorderLambda tried to reorder a list that was too small:</span><span class=\"se\">\\n</span><span class=\"err\">\\</span>\n<span class=\"s2\">          {src}</span><span class=\"se\">\\n</span><span class=\"s2\">{xs}</span><span class=\"se\">\\n</span><span class=\"s2\">{reorder}\"</span>\n<span class=\"w\">        </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">src</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">src</span>\n</code></pre></div>",
        "id": 505753479,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741980937
    },
    {
        "content": "<p>I would write \"if xs.size = maxReorder + 1\" (although this shouldn't change the effect of the code)</p>",
        "id": 505754150,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741981200
    },
    {
        "content": "<p>Is there a reason to prefer that over <code>xs.size &gt; maxReorder</code>?</p>",
        "id": 505757249,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1741982421
    },
    {
        "content": "<p>I think it makes it more readable, and it would throw an error if we accidentally passed the wrong bound to the bounded telescope</p>",
        "id": 505757573,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1741982561
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span>, I've had a look at the <code>decidableLE</code> issue, and one solution I've found is to define <code>decidableGE</code>, which is the dual of <code>decidableLE</code>, as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">DecidableGT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">DecidableGE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"n\">DecidableGT</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">DecidableLT</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">order_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"n\">DecidableGE</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">DecidableLE</span>\n</code></pre></div>\n<p>However, I think a cleaner solution would be to refactor <code>DecidableLE</code> to not be an <code>abbrev</code>, but instead a structure. Then we can tag its projection function with <code>order_dual</code></p>",
        "id": 513404031,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745243575
    },
    {
        "content": "<p>Thanks for taking a look! Right, I thought briefly about having a dual class, but it does indeed seem messy. <code>DecidableLE</code> and friends are defined in core, right? I wonder if they had some specific reasons for making it an abbrev rather than a structure. </p>\n<p>I also wonder if there's a way to use metaprogramming to have <code>order_dual</code> reorder the arguments to instances appropriately when the type contains <code>‚â§</code> or something else tagged with the \"reorder\" attribute.</p>",
        "id": 513405215,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745243999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/513405215\">said</a>:</p>\n<blockquote>\n<p>I also wonder if there's a way to use metaprogramming to have <code>order_dual</code> reorder the arguments to instances appropriately when the type contains <code>‚â§</code> or something else tagged with the \"reorder\" attribute.</p>\n</blockquote>\n<p>I presume you're talking about for example <code>lt_or_eq_of_le</code>, where <code>order_dual</code> gives the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">dite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"n\">inst</span><span class=\"bp\">‚úù</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n</code></pre></div>\n<p>Although it is true that swapping <code>a</code> and <code>b</code> here solves the problem, I think this is hard to acomplish automatically. The same problem would be solved by either making <code>decidableLE</code> a structure, or giving it a dual <code>decidableGE</code>.</p>",
        "id": 513406455,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745244419
    },
    {
        "content": "<p>I think core only defined <code>DecidableLE</code> quite recently. Before that it was just <code>DecidableRel LE.le</code> (which would work better with <code>order_dual</code>). Anyways I think there is no real downside to defining <code>DecidableLE</code> as a structure.</p>",
        "id": 513407279,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745244692
    },
    {
        "content": "<p>Right, I see how making <code>DecidableLE</code> a structure or giving it a dual will solve the issue, but I'd like to better understand why it'd be hard to deal with instances automatically.</p>\n<p>It's certainly out of reach of my current metaprogramming abilities, but doesn't something like the following algorithm work? Whenever the proof that we're dualizing contains an instance term, first dualize its type and note all reordered arguments, then use that to swap the arguments to the instance?</p>",
        "id": 513407711,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745244875
    },
    {
        "content": "<p>In any case, let's ping <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> to see whether making <code>DecidableLE</code> a structure in core would be acceptable.</p>",
        "id": 513407841,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745244936
    },
    {
        "content": "<p>In the part where you say \"first dualize its type\", what exactly would <code>decidableLE Œ±</code> be dualized to? I think in your model it wouldn't be dualized. So then \"note all reordered arguments\" would have to look at something else than the usual <code>reorder</code></p>",
        "id": 513408838,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745245307
    },
    {
        "content": "<p>Ah, OK I see now. I was imagining that we could see through the abbrev, but obviously that doesn't happen for free...</p>",
        "id": 513409444,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745245534
    },
    {
        "content": "<p>Why doesn't <code>reorder</code> just work?</p>",
        "id": 513411146,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745246166
    },
    {
        "content": "<p>What <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> wanted to do is reorder arguments <code>a</code> and <code>b</code> in <code>inst b a</code>. But <code>inst</code> is a local variable, so it cannot be globally tagged with <code>reorder</code>.</p>",
        "id": 513412744,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745246753
    },
    {
        "content": "<p>Just reorder on <code>DecidableLE</code> then, it's a <code>@[reducible, inline] def</code> defined in Prelude</p>",
        "id": 513413850,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247165
    },
    {
        "content": "<p>or does that not work for some reason</p>",
        "id": 513413867,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247176
    },
    {
        "content": "<p>Do it the same way you reorder <code>LE.le</code></p>",
        "id": 513414243,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247323
    },
    {
        "content": "<p>Which arguments of <code>DecidableLE</code> do you want to swap? It only takes 2 arguments: a type and an instance.</p>",
        "id": 513414523,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745247426
    },
    {
        "content": "<p><del>The third and fourth argument :)</del></p>",
        "id": 513414595,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247452
    },
    {
        "content": "<p>wait, that doesn't work</p>",
        "id": 513414634,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247467
    },
    {
        "content": "<p>hmmmmmm</p>",
        "id": 513414712,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247491
    },
    {
        "content": "<p>I guess the best way to do this is to reorder <code>inst</code></p>",
        "id": 513414858,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247551
    },
    {
        "content": "<p>Since it's a local variable, it must have been introduced into the context at some point</p>",
        "id": 513414923,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247580
    },
    {
        "content": "<p>Then you can just mark it as reorder when it's introduced</p>",
        "id": 513415017,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247604
    },
    {
        "content": "<p>and that's based on the type</p>",
        "id": 513415041,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247613
    },
    {
        "content": "<p>I guess this is the price you pay for having dependent types</p>",
        "id": 513415418,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247721
    },
    {
        "content": "<p>Maybe this could be a new attribute? Something like <code>type_reorder</code></p>",
        "id": 513415676,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745247825
    },
    {
        "content": "<p>I think this may cause some problems if you have both <code>decidableLE</code> and <code>decidableRel LE.le</code>. Because one of them gets dualized by swapping the arguments to the local instance, and the other by dualizing the type of the local instance. So we end up with two reducibly defEq expressions that get dualized to two non-defEq expressions. This could give rise to very obscure failures</p>",
        "id": 513420085,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745249339
    },
    {
        "content": "<p>oh, I can see how that could cause problems</p>",
        "id": 513421179,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745249733
    },
    {
        "content": "<p>Is there a library design constraint lurking here? Something more general than \"don't use abbrevs to define classes if you want to be able to use <code>order_dual</code>\".</p>",
        "id": 513448459,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745259954
    },
    {
        "content": "<p>What sort of constraint do you mean? In my experience, using <code>abbrev</code>s to define classes can lead to trouble, but it is convenient because it saves you from writing many instances.</p>\n<p>I had a go at implementing <code>DecidableLE</code> as a structure,  but to be able to use that, I think we'd need to rewrite all type class instances such as e.g. <code>instance (a b : Int16) : Decidable (a ‚â§ b)</code> into the form <code>instance : DecidableLE Int16</code>, which is kind of annoying to do for all of Lean and Mathlib.</p>\n<p>On the other hand, using the <code>abbrev</code> <code>DecidableGE</code> isn't actually that bad, because type class search can automatically infer <code>DecidableLE</code> and <code>DecidableGE</code> from eachother.</p>",
        "id": 513449005,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745260149
    },
    {
        "content": "<p>OK, I was a bit hesitant to add another class, but if <code>DecidableGE</code> doesn't end up being too hard to work with then we can go with that. One minor downside is that theorems that use <code>DecidableLE</code> can't be self-dual anymore, but I don't think there are that many theorems which use <code>DecidableLE</code> anyways.</p>",
        "id": 513462485,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745265915
    },
    {
        "content": "<p>Can typeclass infer <code>DecidableGE</code> from <code>DecidableLE</code>?</p>",
        "id": 513462791,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745266058
    },
    {
        "content": "<p>Yes, because they unfold to <code>‚àÄ a b, Decidable a ‚â§ b</code>, and <code>‚àÄ a b, Decidable b ‚â§ a</code> respectively. And Lean introduces the ‚àÄ variables as metavariables.</p>",
        "id": 513463107,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745266209
    },
    {
        "content": "<p>I made some progress using the approach with <code>DecidableGE</code> and pushed my changes. Some comments:</p>\n<ul>\n<li>When I write <code>@[order_dual self (attr := simp)]</code>, does it apply the <code>simp</code> tag once or twice to the same lemma? I tried instead writing <code>@[simp, order_dual self]</code>, but then the linter complains that it wants 'both' lemmas tagged with <code>simp</code></li>\n<li>I generally prefer to not change statements of lemmas in the process of using <code>order_dual</code>. For example I noticed you set <code>ge_trans</code> to be the dual of <code>le_trans</code>, but this means that it is now defined in terms of <code>‚â§</code> instead of <code>‚â•</code>. Instead, by reordering the arguments in the right way, <code>le_trans</code> and <code>ge_trans</code> can both be self-dual.</li>\n<li>\n<p>I know there was the idea to change the definition of <code>max</code> or <code>min</code> in core to make it a bit more convenient for <code>order_dual</code>. But I think there is actually a good reason for the specific definitions in core, which is written in a comment at <code>maxOfLe</code> and <code>minOfLe</code>:<br>\n<code>-- Marked inline so that `min x y + max x y` can be optimized to a single branch.</code><br>\n  So I think the point is that <code>min</code> and <code>max</code> have the same condition so that using both of them together generates efficient code.</p>\n</li>\n<li>\n<p>To make tagging easier, would it be sensible to have special support for <code>alias</code>es? If A is an alias of B, then the dual of A should just be the dual of B.</p>\n</li>\n<li>To make tagging easier, can there be a syntax (or lack of syntax) to indicate that the dual name should be the name followed by <code>OD</code>, if the name would otherwise be the same?</li>\n</ul>",
        "id": 513480195,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745275155
    },
    {
        "content": "<blockquote>\n<p>When I write <code>@[order_dual self (attr := simp)]</code>, does it apply the <code>simp</code> tag once or twice to the same lemma?</p>\n</blockquote>\n<p>Good question. <a href=\"https://github.com/leanprover-community/mathlib4/blob/49360a0442d6adc904f18913fd8b39fc1176a457/Mathlib/Tactic/ToAdditive/Frontend.lean#L1641\"><code>applyAttributes</code></a> and <a href=\"https://github.com/leanprover-community/mathlib4/blob/49360a0442d6adc904f18913fd8b39fc1176a457/Mathlib/Tactic/ToAdditive/Frontend.lean#L1688\"><code>copyMetadata</code></a> don't check if <code>src</code> and <code>tgt</code> are the same; is applying attributes not idempotent?</p>\n<p>The other bullet points / suggestions sound good to me other than the last one. The <code>OD</code> suffix was basically me being lazy and putting off thinking about names, so I'm hesitant to make it a permanent default; I'm fine if we make it a temporary syntax / convention though (i.e. add a TODO in the comments).</p>",
        "id": 513483631,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745277150
    },
    {
        "content": "<p>I would suggest making better names, but if you're just testing and the names are temporary then I guess it's fine.</p>",
        "id": 513483997,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745277391
    },
    {
        "content": "<p>I think whether attribute application is idempotent depends on the implementation of that attribute, (i.e. does it use a HashSet or an Array)</p>",
        "id": 513528479,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745304051
    },
    {
        "content": "<p>For the names, the main case in which I didn't know how to do the naming is if the theorem contains both ‚â§ and =, like <code>le_of_eq</code>. Because the order dual swaps the arguments in ‚â§ but not in =, so it's almost the same theorem again. Do we pick a keyword to append to the name? Like <code>le_of_eq_swapped</code>?</p>",
        "id": 513529029,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745304276
    },
    {
        "content": "<p>Some more points:</p>\n<ul>\n<li>Attribute syntax: I noticed that the syntax of <code>order_dual</code> takes the arguments self, existing, (reorder := ..) and (attr := ..), in any order (and even multiple times). I think it would be nicer for consistency to pick one order and enforce that. I've been going for <code>order_dual (self/existing)? attr? reorder? name?</code>.</li>\n<li>Syntax hovering: it would be nice if the attribute syntax had better hover information. This should include an example of the attribute syntax and the required order of arguments (from the above point), and also the hover information for the <code>attr :=</code> attributes. And more generally a basic explanation of <code>order_dual</code>.</li>\n<li><code>simp</code> Iff lemmas: for iff lemmas tagged with <code>simp</code>, lean uses some weird auxiliary lemma instead of just applying prop_ext every time. I ran into this issue yesterday and I could solve it by squeezing the <code>simp</code>, but that isn't a nice solution.</li>\n</ul>",
        "id": 513531140,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745305107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Order.20dual.20tactic/near/513529029\">said</a>:</p>\n<blockquote>\n<p>For the names, the main case in which I didn't know how to do the naming is if the theorem contains both ‚â§ and =, like <code>le_of_eq</code>. Because the order dual swaps the arguments in ‚â§ but not in =, so it's almost the same theorem again. Do we pick a keyword to append to the name? Like <code>le_of_eq_swapped</code>?</p>\n</blockquote>\n<p>Naming convention is <code>ge_of_eq</code></p>",
        "id": 513538265,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745307548
    },
    {
        "content": "<p>Do you mean that out of these three</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">le_of_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"n\">le_of_eq'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"n\">ge_of_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â•</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>the middle one should be called <code>ge_of_eq</code>?</p>",
        "id": 513538674,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745307694
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">le_trans'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"n\">ge_trans</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â•</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â•</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â•</span><span class=\"w\"> </span><span class=\"n\">c</span>\n</code></pre></div>\n<p>These two lemmas both exist, but your convention seems to imply <code>le_trans'</code> should be called <code>ge_trans</code>?</p>",
        "id": 513549464,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745310788
    },
    {
        "content": "<p>actually, in my opinion that one should be <code>le_comp</code></p>",
        "id": 513549802,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745310893
    },
    {
        "content": "<p>since it's precisely the difference between <code>comp</code> and <code>trans</code>, applied to <code>le</code></p>",
        "id": 513549934,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745310937
    },
    {
        "content": "<p>So would you suggest removing the current <code>ge_trans</code> in favour of the current <code>le_trans'</code>?</p>",
        "id": 513550065,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745310966
    },
    {
        "content": "<p>i don't see why yet</p>",
        "id": 513550287,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745311045
    },
    {
        "content": "<p>I find it a bit confusing with the <code>‚â§</code> vs <code>‚â•</code> notation and <code>le</code> vs <code>ge</code> naming. For the notation, appart from a few exceptions, we always use <code>‚â§</code>. And I thought that this should be reflected in the name: always use <code>le</code> for <code>‚â§</code>. But <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> is suggesting to use <code>ge</code> in the name for <code>‚â§</code> if the lemma is  generated by the order dual tactic. Don't you think that this would be very confusing?</p>",
        "id": 513551516,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745311419
    },
    {
        "content": "<p>yes. i guess the issue is that in our typical naming scheme, we hardly track where which free variables end up, which is <em>typically</em> precisely the difference between <code>le</code> and <code>ge</code></p>",
        "id": 513552638,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745311734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/513551516\">said</a>:</p>\n<blockquote>\n<p>@Ya√´l Dillies is suggesting to use <code>ge</code> in the name for <code>‚â§</code> if the lemma is generated by the order dual tactic. Don't you think that this would be very confusing?</p>\n</blockquote>\n<p>No, this is not the naming convention. The naming convention is approximately</p>\n<ol>\n<li>Turn <code>foo_le_bar</code> into <code>bar_le_foo</code></li>\n<li>If that fails (because eg <code>foo</code> = <code>bar</code> or there is another ambiguity), instead replace <code>le</code> with <code>ge</code></li>\n</ol>",
        "id": 513552961,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745311826
    },
    {
        "content": "<p>So far I'm mostly looking at lemmas where the two sides of <code>le</code> are free variables, so point 1 doesn't apply.</p>",
        "id": 513553187,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745311894
    },
    {
        "content": "<p>Then <code>le</code> ‚Üí <code>ge</code> it is. But I must warn you that point 1 really is the one that applies most often in practice</p>",
        "id": 513553349,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745311936
    },
    {
        "content": "<p>(I know it makes the naming algorithm much harder, there's a reason why I failed to write <code>to_dual</code> for several years!)</p>",
        "id": 513553427,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745311964
    },
    {
        "content": "<p>i guess it might be best if we can reserve an option to explicitly name the dual lemma?</p>",
        "id": 513553604,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745312026
    },
    {
        "content": "<p>Oh right, should we call it <code>to_dual</code> instead of <code>order_dual</code>? It is really about any kind of dual.</p>",
        "id": 513553757,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745312063
    },
    {
        "content": "<p>Yes, we can choose to override the the automatically generated name for the dual lemma</p>",
        "id": 513553857,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745312097
    },
    {
        "content": "<p>Yes, eg <span class=\"user-mention\" data-user-id=\"132603\">@Calle S√∂nne</span> is hoping to steal all your work on this tactic and apply it to category theory <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 513553863,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745312101
    },
    {
        "content": "<p>Ok, I'll make a PR to clean up some of these lemmas to use the <code>gt</code> and <code>ge</code> naming, but using <code>&lt;</code> and <code>‚â§</code>. But first I have <a href=\"https://github.com/leanprover-community/mathlib4/pull/24277\">#24277</a> to remove some <code>@[trans]</code> annotations.</p>",
        "id": 513589618,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745323088
    },
    {
        "content": "<p>If we want <code>to_dual</code> to dualize both order-theoretically and category-theoretically at the same time, then it might already be possible to start tagging theorems now with the current state of the attribute.</p>",
        "id": 513604914,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745327120
    },
    {
        "content": "<p>Some of the changes to the <code>to_additive</code> infrastructure should probably be PR-ed before <code>to_dual</code> itself. Your check that <code>to_additive existing</code> does the correct thing is very useful, and will probably find some mistakes in mathlib. (In fact I found one by accident here <a href=\"https://github.com/leanprover-community/mathlib4/pull/24283\">#24283</a>).</p>\n<p>Additionally I think <code>reorderForall</code> and <code>reorderLambda</code> should throw an error if the permutation numbers are out of bounds.</p>",
        "id": 513612937,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745329060
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span>, I'm trying to replace lemmas about <code>&gt;</code> with lemmas about <code>&lt;</code>, but still calling them <code>gt</code> when appropriate. Do you think the following lemmas should use <code>ge</code>/<code>gt</code> in the name?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">lt_or_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"n\">lt_or_lt_of_ne</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>the naming conventions seem to suggest the names I wrote, but the names <code>lt_or_ge</code> and <code>lt_or_gt_of_ne</code> also seem natural.</p>",
        "id": 514468034,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745618341
    },
    {
        "content": "<p>Both pairs of names are fine (and possibly we should have both)</p>",
        "id": 514468477,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745618569
    },
    {
        "content": "<p>cf <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=le_or_lt#doc\">docs#le_or_lt</a></p>",
        "id": 514468490,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745618578
    },
    {
        "content": "<p>Do you also think <code>Ne.lt_of_le' : b ‚â† a ‚Üí a ‚â§ b ‚Üí a &lt; b</code> should be renamed to <code>Ne.gt_of_ge</code>?</p>",
        "id": 514487732,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745632617
    },
    {
        "content": "<p>This one is a bit tougher in the sense that I think of it as having the <code>!=</code> reversed, not the <code>&lt;=</code> and <code>&lt;</code></p>",
        "id": 514508145,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745650230
    },
    {
        "content": "<p>I have tagged a bunch of category theory results now with <code>order_dual</code>. I ran into a few issues:</p>\n<ul>\n<li>Applying attributes in the case of <code>order_dual self</code>. I write <code>@[simp, order_dual self (reorder := ..)]</code>, but the linter complains that it wants <code>@[order_dual self (attr := simp) (reorder := ..)]</code>. So if we want the first form, then we should change the linter to complain about the second option instead of the first.</li>\n<li>Higher order functions. A few functions require swapping arguments inside an argument in order to be <code>order_dual</code> to themself, such as <code>Prefunctor.mk {V : Type u‚ÇÅ} [Quiver V] {W : Type u‚ÇÇ} [Quiver W] (obj : V ‚Üí W) (map : {X Y : V} ‚Üí (X ‚ü∂ Y) ‚Üí (obj X ‚ü∂ obj Y)) : V ‚•§q W</code> (need to swap <code>X</code> and <code>Y</code>). I could imagine extending the <code>reorder</code> syntax to support this, but that seems overly complicated, and otherwise we can just have such constants not be self-dual.</li>\n<li><code>IsThin</code> suffers the same problem as <code>decidableLE</code>, so we get the dual <code>IsThin'</code> which is equivalent to <code>IsThin</code>.</li>\n<li>When tagging a structure projection function with <code>order_dual (reorder := ..)</code>, the reordering doesn't apply if the projection is in the form of an <code>Expr.proj</code>. So I think we need to refold all of the <code>Expr.proj</code> expressions into their projection functions before transforming the expression. This comes up because the <code>reassoc</code> attribute creates such proof terms.</li>\n</ul>",
        "id": 514533280,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745669571
    },
    {
        "content": "<p>I noticed there is a special meaning when the number <code>0</code> appears in the <code>reorder := ..</code> syntax, which swaps the order of the first two universe variables. I think this is very confusing, and it isn't used or documented anywhere. Should we remove it?</p>",
        "id": 514533685,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745669886
    },
    {
        "content": "<p>Have you considered using <code>==</code> instead of <code>isDefEq</code> to check that the generated and actual order dual expressions are the same? I would expect that they should satisfy <code>==</code>.</p>",
        "id": 514533777,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745669992
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/514533685\">said</a>:</p>\n<blockquote>\n<p>I noticed there is a special meaning when the number <code>0</code> appears in the <code>reorder := ..</code> syntax, which swaps the order of the first two universe variables. I think this is very confusing, and it isn't used or documented anywhere. Should we remove it?</p>\n</blockquote>\n<p>I didn't realize this was unused. Maybe <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> has an opinion on this? (It seems the feature was added along with the reorder syntax in <a href=\"https://github.com/leanprover-community/mathlib/pull/7888\">!3#7888</a>)</p>",
        "id": 514536455,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745671940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/514533777\">said</a>:</p>\n<blockquote>\n<p>Have you considered using <code>==</code> instead of <code>isDefEq</code> to check that the generated and actual order dual expressions are the same? I would expect that they should satisfy <code>==</code>.</p>\n</blockquote>\n<p>I didn't consider it at all -- do you think it'd be beneficial? I can test it out when I have a chance, but if you're currently hacking on <code>order_dual</code>, maybe you're better poised to do so at the moment. I'd be interested to know the results.</p>",
        "id": 514536533,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1745672031
    },
    {
        "content": "<p>I also renamed it to <code>to_dual</code> just now <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 514536629,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745672113
    },
    {
        "content": "<p>Ah actually I got confused about the off-by-one property of <code>reorder</code>. So what happens is that if <code>reorder := ..</code> contains a 1, then it reorders the first two universe variables, which is required for <code>HPow</code> -&gt; <code>HSMul</code>.</p>",
        "id": 514537934,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745673115
    },
    {
        "content": "<p>But I do think this could lead to surprising behaviour, as it is a hack.</p>",
        "id": 514538033,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745673171
    },
    {
        "content": "<p>I tried using <code>==</code>, which works fine. The change made it so that <code>LinearOrder.toDecidableLE</code> can't be self dual, but that is fine, as we can define <code>LinearOrder.toDecidableGE</code>. I also discovered the following weird universe thing in the process:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">run_meta</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"c1\">-- (Œ± : Type u) ‚Üí [inst : LT Œ±] ‚Üí Type (max 0 u)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">info</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">getConstInfo</span><span class=\"w\"> </span><span class=\"ss\">``DecidableLT</span>\n<span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"w\"> </span><span class=\"s2\">\"{info.type}\"</span>\n</code></pre></div>\n<p>Anyways, we do need a way to turn off the verification with syntax like <code>self!</code> or <code>existing!</code> (which I saw you suggested in a comment). The place where verification breaks is the constructor <code>CategoryTheory.Iso.mk</code>, where we need to swap the fields <code>hom_inv_id : hom ‚â´ inv = ùüô X := by aesop_cat</code> and <code>inv_hom_id : inv ‚â´ hom = ùüô Y := by aesop_cat</code>, but the two <code>by aesop_cat</code> <code>autoParam</code>s aren't <code>==</code> to eachother (which is a bit unfortunate)</p>",
        "id": 514550633,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745682212
    },
    {
        "content": "<p>I made a PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/24401\">#24401</a>) that introduces <code>to_dual</code>'s verification step into <code>to_additive</code>, and I had to fix around 20 files where warnings were shown.</p>",
        "id": 514638336,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745754461
    },
    {
        "content": "<p>Also, my PR refactoring order lemmas is now at the new <a href=\"https://github.com/leanprover-community/mathlib4/pull/24396\">#24396</a>, because in the previous PR it was getting unmanageable to fix all of the broken proofs. So instead I've added the old names as aliases, with a TODO to deprecate them.</p>",
        "id": 514638566,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745754624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/514536455\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/514533685\">said</a>:</p>\n<blockquote>\n<p>I noticed there is a special meaning when the number <code>0</code> appears in the <code>reorder := ..</code> syntax, which swaps the order of the first two universe variables. I think this is very confusing, and it isn't used or documented anywhere. Should we remove it?</p>\n</blockquote>\n<p>I didn't realize this was unused. Maybe <span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> has an opinion on this? (It seems the feature was added along with the reorder syntax in <a href=\"https://github.com/leanprover-community/mathlib/pull/7888\">!3#7888</a>)</p>\n</blockquote>\n<p>Oh, I thought I had documented that. <br>\nIt is definitely used in <code>to_additive</code>. The universes have to be reordered correctly as well, and as a hack, I only implemented the following case: if the first two arguments are reordered, <code>to_additive</code> assumes that both of them are types, and then also reorders the first two universe levels. This is a very common scenario, and was necessary for many lemmas <code>to_additive</code> generates with the <code>reorder</code> option. Not reordering them would cause failures when declarations using the faulty one are additivized. <br>\nOf course, this is a hack. Feel free to implement a more robust solution.</p>",
        "id": 514694863,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1745796724
    },
    {
        "content": "<p>Oh, I now read further and see that Jovan also realized this.</p>",
        "id": 514695101,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1745796937
    },
    {
        "content": "<p>(Note that the universes are swapped when doing any permutation involving the first argument, not just a swap with the second argument)</p>",
        "id": 514766350,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745832896
    },
    {
        "content": "<p>Should we use <code>export LinearOrder (le_total min_def max_def)</code> instead of having two identical lemmas in the root and <code>LinearOrder</code> namespaces? The duplication is a bit annoying for tagging.</p>",
        "id": 514857283,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1745857863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/514857283\">said</a>:</p>\n<blockquote>\n<p>Should we use <code>export LinearOrder (le_total min_def max_def)</code> instead of having two identical lemmas in the root and <code>LinearOrder</code> namespaces? The duplication is a bit annoying for tagging.</p>\n</blockquote>\n<p>It's useful to not use <code>export</code> because then the lemmas show up under the expected name in the docs (hopefully doc-gen can be fixed to avoid needing this hack)</p>",
        "id": 514877698,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1745864477
    },
    {
        "content": "<p>I have fixed the merge conflicts in the <code>to_dual</code> PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/21719\">#21719</a>), and I've made a new PR to <code>to_additive</code> to define the <code>to_additive self</code> syntax (<a href=\"https://github.com/leanprover-community/mathlib4/pull/27387\">#27387</a>).</p>\n<p>Here at the Class Field Theory formalization event, some people would like to have the <code>to_dual</code> attribute for homology and cohomology.</p>",
        "id": 530321259,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1753270099
    },
    {
        "content": "<p>The way I structured the <code>to_dual</code> PR was to have it depend on <a href=\"https://github.com/leanprover-community/mathlib4/pull/21696\">#21696</a> which starts to split up the <code>to_additive</code> code into bits that can be re-used by <code>to_dual</code>. Should we make an effort to revive that one too or should we just try and merge <a href=\"https://github.com/leanprover-community/mathlib4/pull/21719\">#21719</a> all in one go? I'll see if I can make some time to work on <code>to_dual</code> / review related PRs this week; just ping me or DM me if you have some tasks I can help with.</p>",
        "id": 530328766,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1753272519
    },
    {
        "content": "<p>I think we can merge it all in one go, but I don't really mind.</p>",
        "id": 530333825,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1753274124
    },
    {
        "content": "<p>I think in an ideal world, it would be possible to declare a new translation attribute with a one-liner. And then we would do this for <code>to_additive</code> and for <code>to_dual</code>. This would require an extra argument <code>isDual : Bool</code> which determines whether to add a reverse translation for every given translation.</p>",
        "id": 530334048,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1753274196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Order.20dual.20tactic/near/530333825\">said</a>:</p>\n<blockquote>\n<p>I think we can merge it all in one go, but I don't really mind.</p>\n</blockquote>\n<p>Although I am trying to PR independent features one-by-one whenever possible, to reduce the size of the final PR.</p>",
        "id": 530335411,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1753274630
    },
    {
        "content": "<p>Thanks for the quick review! Here is another PR that ports a fix from the <code>to_dual</code> PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/27405\">#27405</a></p>\n<p>Another thought: <code>to_dual</code> and <code>reassoc</code> have a funny interaction. For lemmas currently tagged <code>@[reassoc]</code> that we want to tag with <code>to_dual</code>, we want the lemma and its dual to have a <code>reassoc</code> version. But those are not dual to eachother, so we will need to add their duals as well. So we end up with 6 lemmas. So I guess we should define some <code>@[to_dual_reassoc]</code> for this, which adds both the <code>_assoc</code> and <code>_assocRev</code> lemmas.</p>",
        "id": 530442725,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1753309287
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/21719\">#21719</a>, I have now split out the <code>to_dual</code> code into a separate file, so that <code>ToAdditive.Frontend</code> is changed as little as possible. It is now mostly ready to be PR-ed <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span>. I think the PR will have to contain only a little bit of tagging things with <code>@[to_dual]</code>, and we can leave the rest for future PRs.</p>\n<p>One more TODO is to fix the error messages. It currently will tell you that \"to_additive failed\" even though you actually used <code>to_dual</code>. I'm less worried about trace messages and comments in the code mentioning <code>to_additive</code>.</p>\n<p>Another TODO is to figure out how to deal with associativity of composition in category theory, and the <code>reassoc</code> attribute. But that question doesn't need to block <code>to_dual</code> from being used for order theory.</p>",
        "id": 531485514,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1753748502
    },
    {
        "content": "<p>Thanks so much for your work on this Jovan! I'll try and take a look at this in the next few days and maybe knock off some of the TODOs, unless you're still planning on making more big changes.</p>",
        "id": 531492898,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1753753138
    },
    {
        "content": "<p>I wasn't aware that this was still being worked on! What's the progress status?</p>",
        "id": 531523256,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1753770408
    },
    {
        "content": "<p>The progress status is that essentially all the prerequisites are now in place: <code>to_additive existing</code> now has a check in place to verify that the attribute can be applied. We now have the <code>to_additive self</code> syntax as a special case of <code>existing</code>. The new naming converntion for <code>le</code>/<code>ge</code> has been applied.</p>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/21719\">#21719</a>, I've also been tagging a bunch of lemmas about orders, and category theory. This can be ported in later PRs, but there will still be a lot more tagging to do.</p>",
        "id": 531534909,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1753774488
    },
    {
        "content": "<p>I made a new PR for the <code>to_dual</code> attribute in <a href=\"https://github.com/leanprover-community/mathlib4/pull/27887\">#27887</a>, and it is now ready for review! It only adds <code>@[to_dual]</code> tags in files that directly need to import <code>ToDual</code>, namely <code>Order/Defs/PartialOrder</code>, <code>Order/Notation</code> and <code>Combinatorics/Quiver/Basic</code>.</p>\n<p>When this gets merged, we will have to figure out how to best review PRs that expand the use of <code>to_dual</code>.</p>\n<ul>\n<li>Reviewing tags of the form <code>to_dual self (reorder := ...)</code> or <code>to_dual existing (reorder := ...)</code> is easy, because the attribute checks automatically that the <code>reorder</code> argument is correct.</li>\n<li>But for <code>to_dual (reorder := ...)</code>, it is much trickier to check that the generated lemma matches the original lemma. And I don't know if we even want it to become exactly the same; do we care about the order of implicit arguments?</li>\n</ul>",
        "id": 532599024,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1754254850
    },
    {
        "content": "<p>If when we tag, we always start by trying <code>to_dual existing (reorder := ...) original_lemma</code>, and then only delete <code>original_lemma</code> afterwards, then we can take advantage of the checking, right? I guess this doesn't make it easy for reviewers to check unless we require separate commits.</p>",
        "id": 532610850,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1754262992
    },
    {
        "content": "<p>The <code>to_dual</code> PR has been merged!</p>\n<p>Now, I'd like people's opinion on <a href=\"https://github.com/leanprover-community/mathlib4/pull/31722\">#31722</a>, where I change the <code>(reorder := ...)</code> notation to use 0-indexed counting instead of 1-indexed counting. Personally, I would have expected this to use 0-indexed counting. But if people prefer counting that starts at 1, let me know.</p>",
        "id": 556721409,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763334185
    },
    {
        "content": "<p>/poll How should the <code>(reorder := ...)</code> notation be indexed?</p>",
        "id": 556721496,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1763334259
    },
    {
        "content": "<p>Are there any other tactics that have syntax for refering to arguments by position?</p>\n<p>The only one that comes to my mind isn't a real example: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/NthRewrite.html#Mathlib.Tactic.tacticNth_rewrite_____\"><code>nth_rewrite</code></a> is apparently 1-indexed, but that's for the nth occurrence of some expression in the rewrite target, not for counting arguments.</p>",
        "id": 556722120,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1763334942
    },
    {
        "content": "<p>There is the <code>@[specialize]</code> compiler attribute, which allows you to specify arguments by name or by index, and the number is 1-indexed.</p>",
        "id": 556722708,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763335761
    },
    {
        "content": "<p>There is also the <code>conv</code> mode syntax that uses numbers to specify which argument to zoom into. But in that case, 0 refers to the head function, and then the arguments are counted from 1.</p>",
        "id": 556722838,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763335923
    },
    {
        "content": "<p>If you want more opinions then you might want to give an example or two of current behaviour, I have no idea what this question is about but I could imagine having an opinion if i saw some examples</p>",
        "id": 556753207,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1763360166
    },
    {
        "content": "<p>Here are some examples, using the current 1-indexed counting.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">swapping</span><span class=\"w\"> </span><span class=\"ss\">`a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">into</span><span class=\"w\"> </span><span class=\"ss\">`n</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">`.</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hSMul</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HPow</span><span class=\"bp\">.</span><span class=\"n\">hPow</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">smul_apply</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">-- swapping f and a</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">pow_apply</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Pow</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"c1\">-- turning `a &lt; b` into `b &lt; a` etc.</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">GE</span><span class=\"bp\">.</span><span class=\"n\">ge</span><span class=\"w\"> </span><span class=\"n\">GT</span><span class=\"bp\">.</span><span class=\"n\">gt</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">-- swapping a and b</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lt_or_ge</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">homOfEq_eq_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hY</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">homOfEq</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"n\">hY</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">homOfEq</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">hX</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">hY</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 556766213,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763366648
    },
    {
        "content": "<p>I wonder whether it would be helpful to also allow referring to the arguments by name. This would probably make it easier, but there could also be a cost to having multiple ways of saying the same thing.</p>",
        "id": 556766575,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763366812
    },
    {
        "content": "<p>You are counting things, so shouldn't this start at one? For example in <code>homOfEq_eq_iff</code> I'm sure you would accept that you're talking about the 3rd, 4th, 5th, 6th, 9th and 10th inputs to the function</p>",
        "id": 556768951,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1763367819
    },
    {
        "content": "<p>It would probably be simplest if you could also refer to the names of parameters instead of counting them, similar to how <code>@[specialize]</code> does it, so you would do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hSMul</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HPow</span><span class=\"bp\">.</span><span class=\"n\">hPow</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">smul_apply</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">pow_apply</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Pow</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"c1\">-- turning `a &lt; b` into `b &lt; a` etc.</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">GE</span><span class=\"bp\">.</span><span class=\"n\">ge</span><span class=\"w\"> </span><span class=\"n\">GT</span><span class=\"bp\">.</span><span class=\"n\">gt</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lt_or_ge</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"n\">hY</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">homOfEq_eq_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hY</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">homOfEq</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"n\">hY</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">homOfEq</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">hX</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">hY</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 556806144,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1763379359
    },
    {
        "content": "<p>Note that tactics like <code>nth_rw</code> and <code>pick_goal</code> are also 1-indexed.<br>\nI think when you're doing metaprogramming, things should be 0-indexed, but for \"user-facing\" tactics/commands/attributes it should be 1-indexed.</p>",
        "id": 556808625,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1763380047
    },
    {
        "content": "<p>I'm personally always surprised to see that <code>nth_rw</code> starts counting at 1. It is unintuitive to me.</p>",
        "id": 556838033,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1763388230
    },
    {
        "content": "<p>Whatever the numbering is, would it be possible to add a flag somewhere that, if set, logs a message at the specified location, instead of performing whatever computation the command is supposed to do?</p>",
        "id": 556838328,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1763388315
    },
    {
        "content": "<p>What sort of flag do you mean?</p>",
        "id": 556839329,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763388563
    },
    {
        "content": "<p>Something like <code>to_additive --dry-run ...</code>.</p>",
        "id": 556839505,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1763388605
    },
    {
        "content": "<p>Or maybe the output of <code>to_additive?</code> already does this, or can be extended to make this more explicit?</p>",
        "id": 556839951,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1763388719
    },
    {
        "content": "<p>At this point, I don't really care about this sort of thing, I just don't want it to change! The confusing bit for me with <code>nth_rw</code> wasn't that it starts counting at 1, it's that it <em>used to start counting at 0</em>, and then I had to relearn. So, I don't really care, as long as the behavior (whether 1-indexed or 0-indexed) is documented in the docstring.</p>",
        "id": 556840148,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763388760
    },
    {
        "content": "<p>Ideally, the referring to the parameters by name would be best.</p>",
        "id": 556840258,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763388786
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> If you mean that you want to have a log of what the attribute does, then you can use <code>to_additive?</code>.</p>",
        "id": 556841513,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763389086
    },
    {
        "content": "<p>What I was hoping for would be something where by writing</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">smul_apply</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">-- swapping f and a</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">pow_apply</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Pow</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>what is going to be reordered is underlined, and if I change <code>5</code> or <code>6</code>, then the new positions are underlined.  So, some \"live\" signaling of what is going on.</p>",
        "id": 556841952,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1763389188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/556840258\">said</a>:</p>\n<blockquote>\n<p>Ideally, the referring to the parameters by name would be best.</p>\n</blockquote>\n<p>I agree. I will implement this, and then we can use parameter names, rather than indices, most of the time. And then I don't really mind anymore which indexing style is used.</p>",
        "id": 556842125,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763389231
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> I see, though that sounds quite fancy. What you can do, is see the type of <code>smul_apply</code> when you hover over it, so you can see what was swapped.</p>",
        "id": 556842887,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763389401
    },
    {
        "content": "<p>Ok, I often would like to see a more extensive use of the Expr.diff functionality that is used in the infoview.</p>",
        "id": 556844372,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1763389752
    },
    {
        "content": "<p>Here's my PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/31748\">#31748</a></p>\n<p>As a bonus, I've added hover info to the arguments, so you can see the argument's name and type.</p>\n<p><a href=\"/user_uploads/3121/pOWxTudZ9pvQmF6Ym79Cn6Cb/afbeelding.png\">afbeelding.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/pOWxTudZ9pvQmF6Ym79Cn6Cb/afbeelding.png\" title=\"afbeelding.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"843x108\" src=\"/user_uploads/thumbnail/3121/pOWxTudZ9pvQmF6Ym79Cn6Cb/afbeelding.png/840x560.webp\"></a></div>",
        "id": 556897845,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763402390
    },
    {
        "content": "<p>I have tagged the content of <code>Order.Defs.LinearOrder</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/31709\">#31709</a>. One issue I found is that there is a duplication of lemmas such as <code>LinearOrder.min_def</code> and <code>min_def</code>. I think we should treat <code>LinearOrder.min_def</code> as an implementation detail, and only use <code>min_def</code>, so <code>LinearOrder.min_def</code> should not be tagged with <code>to_dual</code>. I raised this issue in <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Should.20duplicated.20class.20projections.20be.20private.3F/with/558208782\">#mathlib4 &gt; Should duplicated class projections be private?</a> , and I made the PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/31808\">#31808</a> to remove all uses of these internal lemmas.</p>",
        "id": 558269176,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763574572
    },
    {
        "content": "<p>Yes, they were never meant to be used</p>",
        "id": 558269418,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1763574661
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/31902\">#31902</a>, I implement a heuristic for guessing the <code>(reorder := ...)</code> argument when using <code>to_dual self</code> or <code>to_dual existing</code>. This means that in the example above, we can simply write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">homOfEq_eq_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hY</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">homOfEq</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"n\">hY</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">homOfEq</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">hX</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">hY</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 558699399,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763741694
    },
    {
        "content": "<p>Has this tactic been \"released\" yet? i.e. can I and should I start tagging things?</p>",
        "id": 560764558,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764329644
    },
    {
        "content": "<p>Yes, sort of, we are now in the process of tagging things in mathlib. The problem is that this has to be done in a top-down fashion, so we first need to tag all of the most basic files, in order, in order to be able to use it in more complicated files. I currently have a few open PRs doing just that.</p>",
        "id": 560773262,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764332477
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> I'd like to help by adding <code>to_dual</code> to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.IsSuccPrelimit#doc\">docs#Order.IsSuccPrelimit</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.IsSuccLimit#doc\">docs#Order.IsSuccLimit</a>. What do I need to edit in order for theorem names to be translated properly?</p>",
        "id": 560796630,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764339393
    },
    {
        "content": "<p>In the current set-up, <code>Limit</code> gets translated into <code>Colimit</code>. I don't know if we should remove this translation from the dictionary. But even if we don't, we can still get this to work. You'll have to add an entry to the <code>fixAbbreviations</code> dictionary, so that it turns <code>SuccColimit</code> into <code>SuccPrelimit</code>.</p>\n<p>And for the other direction, you can simply add the translation from <code>Prelimit</code> to <code>Limit</code> directly to the main guessName disctionary.</p>",
        "id": 560847697,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764359275
    },
    {
        "content": "<p>Oh, I should have specified. The dual of <code>IsSuccPrelimit</code> is <code>IsPredPrelimit</code>. And the dual of <code>IsSuccLimit</code> is <code>IsPredLimit</code>.</p>",
        "id": 560847863,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764359383
    },
    {
        "content": "<p>So presumably that's what I want to add to <code>fixAbbreviations</code>?</p>",
        "id": 560847878,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764359395
    },
    {
        "content": "<p>Aha, we can add the translations between <code>succ</code> and <code>pred</code> to the main dictionary, and remove <code>limit</code> from it. Or we can keep the <code>limit</code> to <code>colimit</code> translation and work around it with <code>fixAbbreviations</code>.</p>",
        "id": 560848668,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764359922
    },
    {
        "content": "<p>We definitely want succ ‚Üî pred in either case, since <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.succ#doc\">docs#Order.succ</a> should also get dualized to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.pred#doc\">docs#Order.pred</a></p>",
        "id": 560848709,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764359959
    },
    {
        "content": "<p>Perhaps we can remove limit ‚Üî colimit for the moment? And judge whether to add it back if someone makes use of it.</p>",
        "id": 560848805,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764360010
    },
    {
        "content": "<p>When we get a bit further with the tagging, we will get to <code>SemilatticeSup</code>, which is dual to <code>SemilatticeInf</code>, and for example these two lemmas are dual:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sSup_le_sSup</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚äÜ</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sInf_le_sInf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚äÜ</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span>\n</code></pre></div>\n<p>The interesting thing to note here is that even though <code>s ‚äÜ t</code> is an alternative spelling to <code>s ‚â§ t</code>, we don't actually swap the <code>s</code> and <code>t</code>. There is also a long-term plan to have <code>‚äÜ</code> and <code>‚â§</code> be different notations for the same underlying constant (similar to how <code>max a b</code> and <code>a ‚äî b</code> are different notations for the same constant).</p>\n<p>So, we should tag <code>Set</code> with <code>@[to_dual_dont_translate]</code>, so that we never translate order structures on <code>Set</code>.</p>",
        "id": 560952736,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764458403
    },
    {
        "content": "<p>Today, I had an idea for dealing with definitions like <code>DecidableLT</code> for which we want that the dual is not the same as the dual of the value. The idea is to pre-process (proof) terms in such a way thay they do not rely on unfolding <code>DecidableLT</code>. This can be done by inserting some rewrite or some cast in the right places in the expression.</p>\n<p>I made the draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/32438\">#32438</a>, which shows some basic cases working for <code>DecidableLT</code>, <code>WCovBy</code> and <code>Set.Icc</code>.</p>",
        "id": 561958533,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764876144
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/XnxgFrCztBVpNSwiePkwBXPd/image.png\">image.png</a><br>\nAm I doing something wrong? This gives me an error \"expected PredOrder to have a value\"</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/XnxgFrCztBVpNSwiePkwBXPd/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"545x230\" src=\"/user_uploads/thumbnail/3121/XnxgFrCztBVpNSwiePkwBXPd/image.png/840x560.webp\"></a></div>",
        "id": 561986350,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764887707
    },
    {
        "content": "<p>It is not yet supported to generate structures automatically, so you will have to do the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">ConditionallyCompleteLattice</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Cover</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Iterate</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Order equipped with a sensible successor function. -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">SuccOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Successor function -/</span>\n<span class=\"w\">  </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Proof of basic ordering with respect to `succ` -/</span>\n<span class=\"w\">  </span><span class=\"n\">le_succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Proof of interaction between `succ` and maximal element -/</span>\n<span class=\"w\">  </span><span class=\"n\">max_of_succ_le</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">IsMax</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Proof that `succ a` is the least element greater than `a` -/</span>\n<span class=\"w\">  </span><span class=\"n\">succ_le_of_lt</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"sd\">/-- Order equipped with a sensible predecessor function. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">SuccOrder</span><span class=\"kd\">]</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PredOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Predecessor function -/</span>\n<span class=\"w\">  </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Proof of basic ordering with respect to `pred` -/</span>\n<span class=\"w\">  </span><span class=\"n\">pred_le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Proof of interaction between `pred` and minimal element -/</span>\n<span class=\"w\">  </span><span class=\"n\">min_of_le_pred</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">IsMin</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Proof that `pred b` is the greatest element less than `b` -/</span>\n<span class=\"w\">  </span><span class=\"n\">le_pred_of_lt</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>",
        "id": 561986546,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764887833
    },
    {
        "content": "<p>(I am providing it the name <code>SuccOrder</code> manually because the <code>succ</code> ‚Üî <code>pred</code> translation is not yet in the guessName dictionary)</p>",
        "id": 561986653,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764887883
    },
    {
        "content": "<p>I'll add it when I make my PR <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 561986678,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764887894
    },
    {
        "content": "<p>Eventually I'd like better support for tagging structures and generating the reorders there automatically, but for the time being you will also need to add</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">PredOrder</span><span class=\"bp\">.</span><span class=\"n\">le_pred_of_lt</span>\n</code></pre></div>\n<p>To update the <code>reorder</code> argument to be correct for <code>PredOrder.le_pred_of_lt</code>/<code>SuccOrder.succ_le_of_lt</code></p>",
        "id": 561987304,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764888154
    },
    {
        "content": "<p>Hmm... I'm running across a new error<br>\n<a href=\"/user_uploads/3121/JCuGO_5LKlh-UFzXoJCGGNq7/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/JCuGO_5LKlh-UFzXoJCGGNq7/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"816x386\" src=\"/user_uploads/thumbnail/3121/JCuGO_5LKlh-UFzXoJCGGNq7/image.png/840x560.webp\"></a></div>",
        "id": 561987617,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764888325
    },
    {
        "content": "<p>Is <code>to_dual</code> set up to work with <code>OrderDual</code>?</p>",
        "id": 561987642,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764888337
    },
    {
        "content": "<p>Unfortunately, <code>to_dual</code> cannot yet reorder arguments of arguments. This means that it cannot translate <code>PredOrder.mk</code> to <code>SuccOrder.mk</code> correctly. This should not come up too often, but you've encountered one of these cases now. While we don't have this feature, we will need to declare both instances separately, and link them with <code>to_dual existing</code>.</p>",
        "id": 561988098,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764888574
    },
    {
        "content": "<p>More problems <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span><br>\n<a href=\"/user_uploads/3121/ca9rYfGlCaJ0e20IPy56T3my/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/ca9rYfGlCaJ0e20IPy56T3my/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"806x408\" src=\"/user_uploads/thumbnail/3121/ca9rYfGlCaJ0e20IPy56T3my/image.png/840x560.webp\"></a></div>",
        "id": 561989558,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764889380
    },
    {
        "content": "<p>I think the issue is the same, with arguments of arguments, but the validation doesn't even let me add the <code>to_dual existing</code> attribute</p>",
        "id": 561989771,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764889480
    },
    {
        "content": "<p>Exactly. The attribute knows that it cannot reorder arguments of arguments, so it disallows adding the <code>to_dual existing</code> attribute here, because this would lead to wrong translations later on anyways.</p>",
        "id": 561989922,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764889567
    },
    {
        "content": "<p>somehow this doesn't feel like a very smart attribute</p>",
        "id": 561990618,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764889990
    },
    {
        "content": "<p>It's quite a useful attribute as is, and I trust that it'll get better <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 561990738,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764890061
    },
    {
        "content": "<p>How does <code>to_dual</code> interface with alias? If I have something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">alias</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">foo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">baz</span>\n</code></pre></div>\n<p>and I want to override both names, do I just have to split it up into?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">foo'</span><span class=\"kd\">]</span>\n<span class=\"kn\">alias</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">foo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">baz</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">bar'</span><span class=\"kd\">]</span>\n<span class=\"kn\">alias</span><span class=\"w\"> </span><span class=\"bp\">‚ü®_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">baz</span>\n</code></pre></div>",
        "id": 561991738,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764890658
    },
    {
        "content": "<p>Yeah, in general I think</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">attrs</span><span class=\"kd\">]</span>\n<span class=\"kn\">alias</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">foo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">baz</span>\n</code></pre></div>\n<p>is equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">alias</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">foo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">baz</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">attrs</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">bar</span>\n</code></pre></div>\n<p>So you could also make it</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">alias</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">foo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">baz</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">foo'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">bar'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">bar</span>\n</code></pre></div>",
        "id": 561992039,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764890820
    },
    {
        "content": "<p>Sorry I'm troubleshooting so much but I just came across another issue <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span><br>\n<a href=\"/user_uploads/3121/NJYYnAIizr4tHbKHjKhlDhlk/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/NJYYnAIizr4tHbKHjKhlDhlk/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"796x245\" src=\"/user_uploads/thumbnail/3121/NJYYnAIizr4tHbKHjKhlDhlk/image.png/840x560.webp\"></a></div>",
        "id": 561992339,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764891019
    },
    {
        "content": "<p>Is this perhaps fixed by <a href=\"https://github.com/leanprover-community/mathlib4/pull/32438\">#32438</a>?</p>",
        "id": 561992351,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764891026
    },
    {
        "content": "<p>Yes exactly. <code>WCovBy</code> has the property that the unfolded value of <code>a ‚©ø b</code> is not dual to the unfolded value of <code>b ‚©ø a</code>. So currently, <code>to_dual</code> doesn't work here, and <a href=\"https://github.com/leanprover-community/mathlib4/pull/32438\">#32438</a> should fix this.</p>",
        "id": 561992834,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764891309
    },
    {
        "content": "<p>oh damn I just noticed <code>Monotone</code> and co. haven't been tagged</p>",
        "id": 561994423,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764892404
    },
    {
        "content": "<p>I should probably start there</p>",
        "id": 561994430,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764892407
    },
    {
        "content": "<p>Monotone is problematic for the same reason <code>WCovBy</code>is :(</p>",
        "id": 561994475,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764892439
    },
    {
        "content": "<p>oh <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 561994488,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764892446
    },
    {
        "content": "<p>I take it that the order dual tactic can't yet handle pi types?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Iterate</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">iterate_le_id_of_le_id'</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">id_le_iterate_of_id_le'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">iterate_id</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">monotone_id</span><span class=\"bp\">.</span><span class=\"n\">iterate_le_of_le</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>",
        "id": 561996097,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764893227
    },
    {
        "content": "<p>It's not flipping <code>h</code></p>",
        "id": 561996126,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764893235
    },
    {
        "content": "<p>It does work, we are just missing a tag :)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Iterate</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"n\">le_iterate_of_le</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Monotone</span><span class=\"bp\">.</span><span class=\"n\">iterate_le_of_le</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">iterate_le_id_of_le_id'</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">id_le_iterate_of_id_le'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">iterate_id</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">monotone_id</span><span class=\"bp\">.</span><span class=\"n\">iterate_le_of_le</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>",
        "id": 561996706,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764893480
    },
    {
        "content": "<p>Oh, thanks!</p>",
        "id": 561996740,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764893497
    },
    {
        "content": "<p>I notice <code>OrderTop</code> and <code>OrderBot</code> haven't been dualized</p>",
        "id": 562002191,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764896297
    },
    {
        "content": "<p>Any obstacle, or just no one has done it yet?</p>",
        "id": 562002200,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764896304
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/mathlib4/pull/32377\">#32377</a></p>",
        "id": 562002253,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764896350
    },
    {
        "content": "<p>Oh, awesome! I'll review it <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 562002283,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764896372
    },
    {
        "content": "<p>Just opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/32447\">#32447</a> for <code>SuccOrder</code> and <code>PredOrder</code></p>",
        "id": 562006373,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764899032
    },
    {
        "content": "<p>Also opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/32459\">#32459</a> for the <code>Directed</code> file</p>",
        "id": 562036349,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764920160
    },
    {
        "content": "<p>...I'm realizing an issue</p>",
        "id": 562036822,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764920383
    },
    {
        "content": "<p><code>IsDirected Œ± (¬∑ ‚â§ ¬∑)</code> gets dualized to <code>IsDirected Œ± fun x y ‚Ü¶ y ‚â§ x</code> which is def-eq but not syntactically equal to <code>IsDirected Œ± (¬∑ ‚â• ¬∑)</code> and apparently that messes up typeclass lookup</p>",
        "id": 562036931,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764920436
    },
    {
        "content": "<p>Perhaps the solution is to make abbrevs <code>IsDirectedLE Œ±</code> and <code>IsDirectedGE Œ±</code>, use those instead, and mark them as dual?</p>",
        "id": 562036976,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764920463
    },
    {
        "content": "<p>Why not <a href=\"https://github.com/leanprover-community/mathlib4/pull/32462\">#32462</a></p>",
        "id": 562040775,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764922046
    },
    {
        "content": "<p>Are you sure it messes up type class lookup? I don't think it should be a problem because the things are defEq in the reducible transparency.</p>",
        "id": 562044064,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764923228
    },
    {
        "content": "<p>It does seem to mess up some things. Here's an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Bounds</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">OrderDual</span><span class=\"bp\">.</span><span class=\"n\">isDirected_ge</span><span class=\"w\"> </span><span class=\"n\">OrderDual</span><span class=\"bp\">.</span><span class=\"n\">isDirected_le</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">isDirected_le</span><span class=\"kd\">]</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">isDirected_ge</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDirected</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsDirected</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">·µí·µà</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">‚â•</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">assumption</span>\n\n<span class=\"c1\">-- The theorem below fails if you delete this</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">isDirected_le'</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDirected</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">‚â•</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsDirected</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">·µí·µà</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">isDirected_le</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDirected</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬∑</span><span class=\"w\"> </span><span class=\"bp\">‚â•</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">BddBelow</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">BddBelow</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">BddBelow</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚à™</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">BddAbove</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"bp\">·µí·µà</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>",
        "id": 562048024,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764924643
    },
    {
        "content": "<p>I think the abbrevs are probably a good thing anyways? Stops people from trying to write things like <code>IsDirected Œ± fun x y ‚Ü¶ y ‚â§ x</code> or <code>IsDirected Œ± (swap (¬∑ ‚â§ ¬∑))</code></p>",
        "id": 562051637,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764925651
    },
    {
        "content": "<p>Oh wow, thats interesting. The discrimination tree normalization procedure repeatedly does eta-reduction, and unfolding the head constant. So <code>fun x y ‚Ü¶ x ‚â• y</code> get reduced to <code>GE.ge</code> which gets reduced to <code>fun x y ‚Ü¶ y ‚â§ x</code>.</p>\n<p>But, <code>fun x y ‚Ü¶ y ‚â• x</code> does not get reduced to <code>fun x y ‚Ü¶ x ‚â§ y</code>!</p>",
        "id": 562065886,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764930051
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> Ehm, I believe you've somehow introduced a bug in <a href=\"https://github.com/leanprover-community/mathlib4/pull/32377\">#32377</a></p>",
        "id": 562167378,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764961678
    },
    {
        "content": "<p>It's making <a href=\"https://github.com/leanprover-community/mathlib4/pull/32477\">#32477</a> fail all of a sudden. I'll attempt to minimize it. I think it has to do with typeclass search going through some weird path <code>LinearOrder</code> ‚Üí <code>LT</code> which doesn't get properly dualized.</p>",
        "id": 562167923,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764961926
    },
    {
        "content": "<p>Adding the lines</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Lattice</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">id</span>\n</code></pre></div>\n<p>right below <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lattice#doc\">docs#Lattice</a> on latest Mathlib makes the <code>to_dual</code> tactic fail with the error</p>\n<div class=\"codehilite\" data-code-language=\"txt\"><pre><span></span><code>@[to_dual] failed. The translated value is not type correct. For help, see the docstring of `to_additive`, section `Troubleshooting`. Failed to add declaration\nbar:\nApplication type mismatch: The argument\n  inst‚úù.toSemilatticeInf\nhas type\n  SemilatticeInf Œ±\nbut is expected to have type\n  SemilatticeSup Œ±\nin the application\n  @SemilatticeSup.toPartialOrder Œ± inst‚úù.toSemilatticeInf\n</code></pre></div>",
        "id": 562168973,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764962394
    },
    {
        "content": "<p>Oh, this seems to be fixed by adding</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Lattice</span><span class=\"bp\">.</span><span class=\"n\">toSemilatticeInf</span>\n</code></pre></div>",
        "id": 562169448,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764962629
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/562167378\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> Ehm, I believe you've somehow introduced a bug in <a href=\"https://github.com/leanprover-community/mathlib4/pull/32377\">#32377</a></p>\n</blockquote>\n<p>Does that fix this problem?</p>",
        "id": 562170225,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764962940
    },
    {
        "content": "<p>I'm currently recompiling but I think it does</p>",
        "id": 562170290,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764962962
    },
    {
        "content": "<p>I see. Indeed the instance LinearOrder -&gt; LE goes through <code>SemilatticeInf</code> (which seems a bit silly), so now you indeed need to tag <code>Lattice.toSemilatticeInf</code></p>",
        "id": 562171179,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1764963317
    },
    {
        "content": "<p>Just opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/32488\">#32488</a> dualizing <code>WithTop</code> and <code>WithBot</code></p>",
        "id": 562191359,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764972977
    },
    {
        "content": "<p>Might I ask what the status on <a href=\"https://github.com/leanprover-community/mathlib4/pull/32438\">#32438</a> is?</p>",
        "id": 562274856,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765068420
    },
    {
        "content": "<p>Do you think there's a way to get <code>to_dual</code> to work on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lex#doc\">docs#Lex</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Colex#doc\">docs#Colex</a> ?</p>",
        "id": 562376655,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765158989
    },
    {
        "content": "<p>The idea is that on pi types <code>Œ± ‚Üí Œ≤</code> and the like, <code>Colex (Œ± ‚Üí Œ≤)</code> means <code>Lex (Œ±·µí·µà ‚Üí Œ≤)</code>, so it just dualizes one argument</p>",
        "id": 562376738,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765159096
    },
    {
        "content": "<p>so there are two ways to dualize?</p>",
        "id": 562376802,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765159174
    },
    {
        "content": "<p>since I think <code>(Lex (Œ± ‚Üí Œ≤))·µí·µà</code> is the same as <code>Lex (Œ± ‚Üí Œ≤·µí·µà)</code></p>",
        "id": 562376944,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765159256
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/562376944\">said</a>:</p>\n<blockquote>\n<p>since I think <code>(Lex (Œ± ‚Üí Œ≤))·µí·µà</code> is the same as <code>Lex (Œ± ‚Üí Œ≤·µí·µà)</code></p>\n</blockquote>\n<p>That's true but I don't believe that's a def-eq</p>",
        "id": 562377499,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765159837
    },
    {
        "content": "<p>Yep, there's two ways to dualize</p>",
        "id": 562377505,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765159844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/562274856\">said</a>:</p>\n<blockquote>\n<p>Might I ask what the status on <a href=\"https://github.com/leanprover-community/mathlib4/pull/32438\">#32438</a> is?</p>\n</blockquote>\n<p>I'm on holiday now, so won't work on it for this week. I wrote in the PR description what is still TODO, but other than those things, it is ready for review.</p>",
        "id": 562398817,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1765178424
    },
    {
        "content": "<p>Happy holidays! I'll tag whatever else I can in the meanwhile.</p>",
        "id": 562408944,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765182512
    },
    {
        "content": "<p>Sorry, what is the deal with <a href=\"https://github.com/leanprover-community/mathlib4/pull/32488\">#32488</a>? I think it is essential that we drop the defeq between WithTop/WithBot and Option --- it leaks through all over the place and makes working with <code>WithTop</code>/<code>WithBot</code> very unpleasant. I have been working on this at <a href=\"https://github.com/leanprover-community/mathlib4/pull/27918\">#27918</a>, and <a href=\"https://github.com/leanprover-community/mathlib4/pull/32488\">#32488</a> has introduced fundamental merge conflicts.</p>\n<p>Does someone have a plan for proceeding? I would really appreciate if someone (else) could just get this finished.</p>",
        "id": 562583337,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765242397
    },
    {
        "content": "<p>I don't believe <a href=\"https://github.com/leanprover-community/mathlib4/pull/32488\">#32488</a> really changes the situation? All the <code>to_dual</code> tactic does is autogenerate the same definitions and lemmas that already existed.</p>",
        "id": 562583460,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765242486
    },
    {
        "content": "<p>I do agree that we want to get rid of the def-eq. I can draft <a href=\"https://github.com/leanprover-community/mathlib4/pull/32498\">#32498</a> in the meanwhile, since that will also introduce new merge conflicts.</p>",
        "id": 562583498,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765242532
    },
    {
        "content": "<p>Another option might be to first tag everything here with <code>to_dual</code> and then perform the def-eq dropping. That way we only need to do half the work.</p>",
        "id": 562583605,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765242621
    },
    {
        "content": "<p>I'm willing to take this over</p>",
        "id": 562583684,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765242690
    },
    {
        "content": "<p>That's great!</p>\n<p>If you could resolve the merge conflicts on <a href=\"https://github.com/leanprover-community/mathlib4/pull/27918\">#27918</a> that would be a great start. Thanks.</p>",
        "id": 562583805,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765242788
    },
    {
        "content": "<p>Of course! Can I push to your branch?</p>",
        "id": 562583837,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765242815
    },
    {
        "content": "<p>(Context: the FRO interval arithmetic plans are not moving as fast as we'd like, but still hope to eventually get there, and I would really like <code>WithTop</code>/<code>WithBot</code> to be usable by then, as they will be part of the user extension API.)</p>",
        "id": 562583868,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765242840
    },
    {
        "content": "<p>Let me check if I need to give your permissions.</p>",
        "id": 562583881,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765242848
    },
    {
        "content": "<p>You should have an invite now.</p>",
        "id": 562583949,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765242920
    },
    {
        "content": "<p>Hm, I see an issue. <code>to_dual</code> doesn't seem to like the fact that <code>WithBot</code> is an inductive while <code>WithTop</code> is a (definitionally equal) def.</p>",
        "id": 562584912,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765243707
    },
    {
        "content": "<p>Do we want them to be definitionally equal with each other?</p>",
        "id": 562584934,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765243724
    },
    {
        "content": "<p>Perhaps a solution is to make some auxiliary structure, and declare <code>WithBot</code> and <code>WithTop</code> both def-eq to it</p>",
        "id": 562584951,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765243739
    },
    {
        "content": "<p>Though surely the long term solution is to not have them be def-eq and use <code>to_dual</code> for our order dualizing purposes.</p>",
        "id": 562584994,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765243770
    },
    {
        "content": "<p>Just pushed a merge commit to the branch. I've used this \"auxiliary structure\" solution for now, but it's a dirty hack and in the future we surely want to just dualize the definition for <code>WithBot</code> itself.</p>",
        "id": 562585652,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765244232
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/562584934\">said</a>:</p>\n<blockquote>\n<p>Do we want them to be definitionally equal with each other?</p>\n</blockquote>\n<p>I think in the long run, no, we don't. However the decision in previous discussions around <a href=\"https://github.com/leanprover-community/mathlib4/pull/27918\">#27918</a> was that this was too difficult to break on the first pass.</p>",
        "id": 562585966,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765244490
    },
    {
        "content": "<p>This also applies to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithBot.instLE#doc\">docs#WithBot.instLE</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithTop.instLE#doc\">docs#WithTop.instLE</a>, right? I found that design a bit odd when I added the <code>to_dual</code> tags on <a href=\"https://github.com/leanprover-community/mathlib4/pull/32499\">#32499</a>.</p>",
        "id": 562586092,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765244589
    },
    {
        "content": "<p>Did you delete some files? The build fails immediately</p>",
        "id": 562587663,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765245812
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> The <code>grind cases</code> attribute doesn't seem to work on <code>WithBot</code> anymore. Any fix or way to circumvent this?</p>",
        "id": 562590806,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1765248164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/562584912\">said</a>:</p>\n<blockquote>\n<p>Hm, I see an issue. <code>to_dual</code> doesn't seem to like the fact that <code>WithBot</code> is an inductive while <code>WithTop</code> is a (definitionally equal) def.</p>\n</blockquote>\n<p>I think there should be no fundamental obstacle to this. It's just that nobody has tried/tested it before.</p>",
        "id": 562897466,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1765356070
    },
    {
        "content": "<p>But I think the easiest approach is to first tag everything with <code>to_dual</code>, and then changing the definition of <code>WithBot</code> should be easy.</p>",
        "id": 562899586,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1765356623
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/562590806\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> The <code>grind cases</code> attribute doesn't seem to work on <code>WithBot</code> anymore. Any fix or way to circumvent this?</p>\n</blockquote>\n<p>No, this is why I made it an inductive.</p>",
        "id": 563068970,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765404288
    },
    {
        "content": "<p>but I guess this can be a feature request. Any chance you could provide me with a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of what we want from <code>grind cases</code>?</p>",
        "id": 563069160,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1765404351
    },
    {
        "content": "<p>I've made <a href=\"https://github.com/leanprover-community/mathlib4/pull/33036\">#33036</a> for order homs/embeddings/equivs. This one was a bit tricky because the definition for embeddings/equivs unfolds to something that is not self-dual. This is the problem that <a href=\"https://github.com/leanprover-community/mathlib4/pull/32438\">#32438</a> addresses. Unfortuately, <a href=\"https://github.com/leanprover-community/mathlib4/pull/32438\">#32438</a> doesn't fix this instance of the problem.</p>\n<p>Luckily, we don't tend to rely on unfolding this definition in practice, so we can work around this.</p>",
        "id": 564454683,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1766063236
    },
    {
        "content": "<p>Could you help me out with <a href=\"https://github.com/leanprover-community/mathlib4/pull/32459\">#32459</a>? I don't understand why this randomly turned some instance on <code>ENNReal</code> noncomputable.</p>",
        "id": 564516776,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766078022
    },
    {
        "content": "<p>I don't see anything about ENNReal or noncomputable there? I do see a type class synthesis failure for <code>IsDirectedOrder</code> that may or may not go away if you merge master.</p>",
        "id": 564521638,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1766079189
    },
    {
        "content": "<p>Ah! Wrong PR, sorry. One sec</p>",
        "id": 564521724,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766079209
    },
    {
        "content": "<p>I meant <a href=\"https://github.com/leanprover-community/mathlib4/pull/32626\">#32626</a></p>",
        "id": 564521784,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766079224
    },
    {
        "content": "<p>Incidentally, I've merged master on <a href=\"https://github.com/leanprover-community/mathlib4/pull/32459\">#32459</a>. It should hopefully be ready for review. (If it doesn't build, I'll fix it tomorrow, I'm getting really sleepy)</p>",
        "id": 564589826,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766102583
    },
    {
        "content": "<p>The PR for unfold boundaries (<a href=\"https://github.com/leanprover-community/mathlib4/pull/32438\">#32438</a>) should now be ready for review. It introduces two new commands: <code>to_dual_insert_cast</code> and <code>to_dual_insert_cast_fun</code> (I'm still not quite sure what the commands should really be called), and they are used as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">to_dual_insert_cast</span><span class=\"w\"> </span><span class=\"n\">Monotone</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n\n<span class=\"n\">to_dual_insert_cast_fun</span><span class=\"w\"> </span><span class=\"n\">DecidableLE</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p><code>to_dual_insert_cast</code> requires you to prove an equality between the dual and the dual of its value.<br>\n<code>to_dual_insert_cast_fun</code> requires you to give a dual to the unfold and refold functions. This for cases where proving equality doesn't make sense, in particular <code>DecidableLE</code> and <code>DecidableLT</code>, because they are types.</p>",
        "id": 564819968,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1766227797
    },
    {
        "content": "<p>How do I debug to_dual error? The first error message just complains some unreadable type mismatch. It doesn't show me the theorem signature it generated. The doc says checking <code>to_additive</code> troubleshooting (doc indirection is already hard to follow, and to_additive is not searchable in mathlib doc). <code>to_additive</code> then says using <code>set_option trace.to_additive_detail true</code> (note that at nowhere the trace option of to_dual is mentioned), but when I tried it, it says \"Unknown option <code>trace.to_additive_detail</code>\" (or Unknown option <code>trace.to_dual_detail</code>)</p>",
        "id": 565475127,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1766788249
    },
    {
        "content": "<p>(Context: as requested in <a href=\"https://github.com/leanprover-community/mathlib4/pull/30436\">#30436</a>, I'd like to tag <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.prod_add_ordered#doc\">docs#Finset.prod_add_ordered</a> and friends)</p>",
        "id": 565475481,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1766788777
    },
    {
        "content": "<p>Here is one of the problem I encountered that I narrowed down somewhat<br>\nI have already tagged <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.prod_one_add_ordered#doc\">docs#Finset.prod_one_add_ordered</a>, and I am attempting to tag its infinite version <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=tprod_one_add_ordered#doc\">docs#tprod_one_add_ordered</a>. However, I get \"Unknown constant <code>SemilatticeInf.to_isDirected_le</code>\". This only happens when the following line is included in the proof</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tendsto_nhds_unique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">tendsto_finset_Iic_atTop_atTop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>\n<p>which involves ordering about <code>Finset</code>'s subset relation. I suspect <code>to_dual</code> somehow dualized this as well? Is it possible to prevent it from doing that?<br>\n(I saw there are some related discussion above about Set, but it doesn't seem we had a solution at that time. Do we have one now?)</p>",
        "id": 565476361,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1766789992
    },
    {
        "content": "<p>(the linked lemma was just pushed so the doc has not been generated yet)</p>",
        "id": 565476565,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1766790074
    },
    {
        "content": "<p>I think the issue is that <code>SemilatticeSup.to_isDirected_le</code> and <code>SemilatticeInf.to_isDirected_ge</code> have not yet been tagged as duals. This should be fixed in approximately ten minutes <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 565477386,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766791411
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/32459\">#32459</a></p>",
        "id": 565477393,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766791419
    },
    {
        "content": "<p>It's a bit difficult to tag these theorems which are further up in the import chain, since every theorem that's used in a dualized theorem's proof also needs to be dualized (if applicable).</p>",
        "id": 565477412,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766791456
    },
    {
        "content": "<p>In your case, the linked line must somehow be making use of the instance which shows that a supremum semilattice is directed. It's not able to find the dual theorem, and as such, the dualization fails.</p>",
        "id": 565477491,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766791600
    },
    {
        "content": "<p>After merging your change, it changed to a new error <span aria-label=\"melting face\" class=\"emoji emoji-1fae0\" role=\"img\" title=\"melting face\">:melting_face:</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"n\">SemilatticeInf</span><span class=\"bp\">.</span><span class=\"n\">instIsCodirectedOrder</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">IsCodirectedOrder</span><span class=\"w\"> </span><span class=\"n\">Œπ</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">IsDirectedOrder</span><span class=\"w\"> </span><span class=\"n\">Œπ</span>\n<span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">application</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">atTop_neBot</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"n\">instDistribLatticeOfLinearOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"n\">SemilatticeInf</span><span class=\"bp\">.</span><span class=\"n\">instIsCodirectedOrder</span>\n</code></pre></div>",
        "id": 565477595,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1766791798
    },
    {
        "content": "<p>Presumably that is because <code>atTop_neBot</code> and <code>atBot_neBot</code> have not been marked as duals.</p>",
        "id": 565478082,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766792661
    },
    {
        "content": "<p>Is that the real problem? Because if I write the proof manually for the dual version, the <code>atTop</code> will stay as <code>atTop</code>, because it is about the top of Finset, not the type that I flipped the ordering</p>",
        "id": 565478563,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1766793504
    },
    {
        "content": "<p>I was just about to say, we probably don't want to tag <code>atTop</code>/<code>atBot</code> as duals, since both are defined as infima, rather than one being a supremum and the other being an infimum.</p>",
        "id": 565478710,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766793600
    },
    {
        "content": "<p>Actually, what is the order dual of <code>tprod_one_add_ordered</code> even supposed to be?</p>",
        "id": 565478962,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766793773
    },
    {
        "content": "<p>I also tried</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">to_dual_dont_translate</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Finset</span>\n</code></pre></div>\n<p>in the same file but it didn't help</p>",
        "id": 565479021,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1766793816
    },
    {
        "content": "<p>Finset would not be translated regardless, what would the order dual of a finset even be?</p>",
        "id": 565479036,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766793841
    },
    {
        "content": "<p>I was suspecting to_dual was translating Finset, which caused this problem</p>",
        "id": 565479064,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1766793886
    },
    {
        "content": "<p>Let me open the file on my computer and see if I can figure this out.</p>",
        "id": 565479075,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766793905
    },
    {
        "content": "<p>Oh... maybe I need to tag <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.tendsto_finset_Iic_atTop_atTop#doc\">docs#Filter.tendsto_finset_Iic_atTop_atTop</a> ?</p>",
        "id": 565479150,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1766794029
    },
    {
        "content": "<p>Yeah this is a weird example of \"whether we should tag atTop\". Its dual, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.tendsto_finset_Ici_atBot_atTop#doc\">docs#Filter.tendsto_finset_Ici_atBot_atTop</a> has one <code>atTop</code> flipped but not the other</p>",
        "id": 565479201,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1766794120
    },
    {
        "content": "<p>There's the separate issue that we haven't even tagged Iic and Ici yet.</p>",
        "id": 565479318,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766794326
    },
    {
        "content": "<p>We can't tag all of the intervals until <a href=\"https://github.com/leanprover-community/mathlib4/pull/32438\">#32438</a> is merged, but I think Iic and Ici should be fine. I'll get to work.</p>",
        "id": 565479641,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766794899
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> If I'm stepping on your toes, please let me know</p>",
        "id": 565479899,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766795354
    },
    {
        "content": "<p>Found some weird API during my dualization effort so I opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/33328\">#33328</a> to address it.</p>",
        "id": 565480443,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1766796421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/565479899\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> If I'm stepping on your toes, please let me know</p>\n</blockquote>\n<p>The worst that can happen is a merge conflict with <a href=\"https://github.com/leanprover-community/mathlib4/pull/32438\">#32438</a>, so feel free to go ahead. Indeed Ici/Ioi etc. can be dualized now already.</p>\n<p>Also, if you're already cleaning up the set interval API, I think Set.Icc_def etc. are all stated the wrong way around.</p>",
        "id": 565500071,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1766827135
    },
    {
        "content": "<p>I think we should tag atTop/atBot. But from <span class=\"user-mention\" data-user-id=\"873350\">@Weiyi Wang</span> 's example, it looks like we do not want to dualize the order on <code>Prop</code>. I wonder how easy it will be to support that. (If Prop was a constant this would be automatic, but Prop is <code>Sort 0</code>)</p>",
        "id": 565500143,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1766827266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873350\">Weiyi Wang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/565479021\">said</a>:</p>\n<blockquote>\n<p>I also tried</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">to_dual_dont_translate</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Finset</span>\n</code></pre></div>\n<p>in the same file but it didn't help</p>\n</blockquote>\n<p>We will indeed want to add this tag, but so far nothing related to Finset has been tagged with to_dual at all.</p>",
        "id": 565500194,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1766827341
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873350\">Weiyi Wang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/565475127\">said</a>:</p>\n<blockquote>\n<p><code>to_additive</code> then says using <code>set_option trace.to_additive_detail true</code>, but when I tried it, it says \"Unknown option <code>trace.to_additive_detail</code>\"</p>\n</blockquote>\n<p>Thanks for reporting this, the option has been renamed to <code>trace.translate_detail</code> (and works for <code>to_additive</code> and <code>to_dual</code>). I've updated the doc-strings in <a href=\"https://github.com/leanprover-community/mathlib4/pull/33500\">#33500</a></p>",
        "id": 566117877,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1767407292
    },
    {
        "content": "<p>Nice. Thanks!</p>",
        "id": 566117915,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1767407386
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/33497\">#33497</a>, I implement an option in <code>to_dual</code> that makes the generated dual declaration be an auxiliary lemma, without a user facing name.</p>\n<p>This is useful in category theory, where the dual of a right associated lemma is a left associated lemma, and hence the dual is not in a useful form, and should not be part of the public API. But the dual lemma is still needed for <code>to_dual</code> to work.</p>\n<p>It may also be useful more generally when dual lemmas are redundant for the API. E.g. <code>le_succ_iff_pred_le</code> and <code>pred_le_iff_le_succ</code> are dual to eachother, but also are just the same iff swapped. So we might want to not have both lemmas.</p>\n<p>I currently made the syntax for this option be <code>to_dual private</code> (in the same style as <code>to_dual existing</code> and <code>to_dual self</code>). But this use of <code>private</code> may be confusing as the generated lemma isn't made <code>private</code>. <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> suggested we could make it <code>to_dual aux</code>. What are your thoughts?</p>",
        "id": 566208877,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1767517367
    },
    {
        "content": "<p>I prefer <code>private</code>, but at the end of the day I prefer having this feature than bikeshedding over names.</p>",
        "id": 566241252,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1767551798
    },
    {
        "content": "<p>/poll What should the syntax for making generated dual declarations into auxiliary lemmas be?</p>",
        "id": 566241423,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1767551966
    },
    {
        "content": "<p>(Feel free to add more options!)</p>",
        "id": 566241476,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1767552009
    },
    {
        "content": "<p>I'm happy to be outvoted, by the way. I think we can probably merge the PR soon after we get some consensus here.</p>",
        "id": 566241588,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1767552115
    },
    {
        "content": "<p>Another option may be <code>to_dual none</code>. As in, no user-facing declaration is created.</p>",
        "id": 566253561,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1767564414
    },
    {
        "content": "<p>I like that one.</p>",
        "id": 566255051,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1767566473
    },
    {
        "content": "<p>I'm happy with <code>to_dual none</code> as well. If there are no objections I'll merge <a href=\"https://github.com/leanprover-community/mathlib4/pull/33497\">#33497</a> tomorrow.</p>",
        "id": 566646430,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1767749325
    },
    {
        "content": "<p>Should the generated lemma still be shown when hovering on the <code>to_dual</code> part of <code>to_dual none</code>, rather than the to_dual docstring? (The same question can be asked about <code>to_dual</code> self, which shows the lemma itself when hovering)</p>",
        "id": 566742901,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1767795237
    },
    {
        "content": "<p>Sure, I think it's good to have some consistency there. I guess it'd be nice if we could show both the generated lemma and the docstring, but is that not possible?</p>",
        "id": 566744481,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1767795687
    },
    {
        "content": "<p>From what I tried, it is not possible to have both the hover of the lemma (which includes its docstring) and the docstring and go-to-def of <code>to_dual</code> on the same piece of syntax.</p>",
        "id": 566745129,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1767795854
    },
    {
        "content": "<p>The same problem came up in <code>to_fun</code>, and we decided to show the generated lemma. But for example <code>reassoc</code> shows just the reassoc docstring and not the generated lemma.</p>",
        "id": 566745726,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1767796013
    },
    {
        "content": "<p>That's a bit of a shame; maybe we should open an RFC for this since being able to show both the docstring of an attribute as well as information about what it did is an important usability feature.</p>",
        "id": 566746775,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1767796281
    },
    {
        "content": "<p>A little update on <code>to_dual</code>:</p>\n<ul>\n<li>\n<p>Support for inserting casts in terms before translation (<a href=\"https://github.com/leanprover-community/mathlib4/pull/32438\">#32438</a>) has now been merged, which opens up many new possibilities of using <code>to_dual</code> in order theory. The first steps of setting things up with <code>to_dual_insert_cast</code> are done in <a href=\"https://github.com/leanprover-community/mathlib4/pull/34042\">#34042</a>.</p>\n</li>\n<li>\n<p>On the Category theory side, there has also been some progress, including the new <code>to_dual none</code>, and support for combining <code>to_dual</code> with <code>reassoc</code>. One problem is that <code>to_dual self</code> currently doesn't work on the comma category, because we need to swap the universe <code>u‚ÇÅ</code> with <code>u‚ÇÇ</code> and <code>v‚ÇÅ</code>  with<code>v‚ÇÇ</code>. So we will need to support this kind of universe reordering.</p>\n</li>\n<li>\n<p>Relatedly, we still need to support reordering arguments of arguments, for which the now-merged <a href=\"https://github.com/leanprover-community/mathlib4/pull/33236\">#33236</a> was a step in the right direction.</p>\n</li>\n<li>\n<p>I also had a go at adding <code>to_dual self</code> to <code>Quiver.Path</code>, but this was really annoying due to the asymmetric definition of <code>Quiver.Path</code> as an inductive type, and we don't really seem to need this <code>to_dual</code> attribute.</p>\n</li>\n</ul>",
        "id": 571735083,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1770143830
    },
    {
        "content": "<p>I'm trying to use <code>to_dual</code> on <code>Order.Ideal</code> and <code>Order.PFilter</code> and I have to say it's really amazing. Though, there is a problem that I don't want to translate the <code>SetLike</code> induced ordering (which is the same for both <code>Ideal</code> and <code>PFilter</code>); <code>dont_translate</code> works in most of time, but here is a subtle case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">instOrderTop</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDirectedOrder</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OrderTop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><code>@[to_dual (dont_translate := 1)]</code> doesn't translate anything, while <code>@[to_dual]</code> gives</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">PFilter</span><span class=\"bp\">.</span><span class=\"n\">instOrderBot</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsCodirectedOrder</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">OrderBot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PFilter</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>whose proof is not type correct. Is there a way to translate <code>OrderTop (Ideal P)</code> just into <code>OrderTop (PFilter P)</code>?</p>",
        "id": 571804784,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1770171629
    },
    {
        "content": "<p>what's the order on <code>Order.PFilter</code>?</p>",
        "id": 571805207,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770171925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/571805207\">said</a>:</p>\n<blockquote>\n<p>what's the order on <code>Order.PFilter</code>?</p>\n</blockquote>\n<p>It's the same as set inclusion. This is different from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter#doc\">docs#Filter</a> which is reverse inclusion.</p>",
        "id": 571805286,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1770171974
    },
    {
        "content": "<p>Here is another subtle case. I want to translate the RHS of the iff but not the LHS</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">eq_top_iff_top_mem</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">I</span>\n</code></pre></div>\n<p>but <code>dont_translate := 1</code> will just keep the whole iff.</p>",
        "id": 571806068,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1770172507
    },
    {
        "content": "<p>I think you want to tell <code>to_dual</code> to never translate the order on <code>Order.Ideal P</code>, right? In that case you should use the <code>@[to_dual_dont_translate]</code> tag on <code>Order.Ideal</code>. (Maybe this sounds like it tells <code>to_dual</code> to not translate <code>Order.Ideal</code>, but that is not true <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span>)</p>\n<p>So far this has only been used for</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">to_dual_dont_translate</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n</code></pre></div>\n<p>But we'll probably need to add it to all set-like things.</p>",
        "id": 571812606,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1770177750
    },
    {
        "content": "<p>This should remove the need to use <code>(dont_translate := ...)</code>.</p>",
        "id": 571812674,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1770177801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Order.20dual.20tactic/near/571812606\">said</a>:</p>\n<blockquote>\n<p>I think you want to tell <code>to_dual</code> to never translate the order on <code>Order.Ideal P</code>, right? In that case you should use the <code>@[to_dual_dont_translate]</code> tag on <code>Order.Ideal</code>. (Maybe this sounds like it tells <code>to_dual</code> to not translate <code>Order.Ideal</code>, but that is not true <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span>)</p>\n<p>So far this has only been used for</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">to_dual_dont_translate</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n</code></pre></div>\n<p>But we'll probably need to add it to all set-like things.</p>\n</blockquote>\n<p>Thanks very much, this indeed works! Though, I have changed my mind that we should have reverse inclusion order on <code>PFilter P</code> and translate the order on <code>Ideal P</code>.</p>",
        "id": 571966165,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1770224942
    },
    {
        "content": "<p>I have created <a href=\"https://github.com/leanprover-community/mathlib4/pull/34863\">#34863</a> for the recursive reordering of arguments of arguments. As a result, we can now for example write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">to_dual</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reorder</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">lt_iff_le_not_ge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))]</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">mk</span>\n</code></pre></div>\n<p>Which lets us translate general <code>Preorder</code> instances.</p>",
        "id": 572753459,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1770637690
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/35031\">#35031</a> (which depends on <a href=\"https://github.com/leanprover-community/mathlib4/pull/34863\">#34863</a>) I dualize <code>Cone</code> to <code>Cocone</code>. This is the first PR in category theory that deduplicates a large amount of code. One issue I encountered is that most declarations are in the <code>CategoryTheory.Limits.Cones</code> namespace (and in <code>CategoryTheory.Limits.Cocones</code>), even though there is no declaration <code>Cones</code>/<code>Cocones</code>. Is this an oversight, or is there a good reason why  not to use the <code>Cone</code>/<code>Cocone</code> namespace?</p>",
        "id": 574914318,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1771585104
    }
]