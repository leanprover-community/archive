[
    {
        "content": "<p>Currently, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet#doc\">docs#ZFSet</a> is defined as a quotient of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PSet#doc\">docs#PSet</a>, an inductive type which has an incorrect and wholly non-mathematical form of equality. All of the usual set-theoretic functions are first defined on <code>PSet</code>, then transferred to <code>ZFSet</code>. The advantage of doing this, or so I've been told, is that this makes operations on <code>ZFSet</code> computable.</p>\n<p>Over at the game-theory repository, we for the longest time had an analogous situation (games are basically two-sided sets, in a way). We had a type <code>PGame</code> with the wrong equality, and after a bunch of tedious set-up we were able to define the type <code>IGame</code> with the correct equality.</p>\n<p>On paper, this meant that we had computability and thus <code>decide</code> at our disposal. In practice? It basically never worked. Since all of our definitions were done through well-founded recursion, <code>decide</code> refused to unfold anything ever. Eventually, we figured out that a <a href=\"https://github.com/vihdzp/combinatorial-games/blob/master/CombinatorialGames/Tactic/GameCmp.lean\">custom simp set</a> provided most of the same capabilities, and computability fell to the wayside.</p>\n<p>Some time later, <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> realized that thanks to the machinery of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QPF#doc\">docs#QPF</a>, the <code>PGame</code> setup was completely unnecessary. We could instead define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">GameFunctor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Small</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)}</span>\n</code></pre></div>\n<p>and provide a <code>QPF</code> instance on it. The type of games is then the smallest fixpoint <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QPF.Fix#doc\">docs#QPF.Fix</a> of this functor. A really nice corollary of this is that we could then define the type of loopy games (where a state can be returned to) as the largest fixpoint <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QPF.Cofix#doc\">docs#QPF.Cofix</a> of the same functor. And thus, <code>PGame</code> was vanquished for good. (See <a href=\"https://github.com/vihdzp/combinatorial-games/blob/master/CombinatorialGames/Game/Functor.lean\"><code>Functor.lean</code></a> for the full details on this setup).</p>\n<p>All of this could be done for <code>ZFSet</code> all the same. In fact, we could easily define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SmallSetTupleFunctor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Small</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)}</span>\n</code></pre></div>\n<p>which would generalize both the <code>ZFSet</code> and the <code>IGame</code> constructions (setting <code>β</code> to either <code>Unit</code> or <code>Bool</code>). In the case of <code>ZFSet</code>, the co-fixpoint doesn't currently exist in Mathlib, but it's still a mathematically interesting object: it gives us a model for <a href=\"https://en.wikipedia.org/wiki/Aczel%27s_anti-foundation_axiom\">Aczel's anti-foundation axiom</a>.</p>\n<p>The catch? Since <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Shrink#doc\">docs#Shrink</a> is non-computable, the <code>QPF</code> instance is too. Which means we lose out on computable ZFC sets. My question is, do we <em>really</em> want them?</p>\n<ul>\n<li>We currently make no use of <code>ZFSet</code> computability within Mathlib. Though arguably that doesn't mean much, since there's only like 4 files in that folder.</li>\n<li>More importantly, I'd argue that the benefits of computability are quite limited in scope. You have no decidable equality, or membership, or subsets, even in the finite case, since <code>ZFSet</code> bundles no <code>Fintype</code> instances or anything of the sort.</li>\n<li>For finite sets, we already have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lists#doc\">docs#Lists</a>, which models ZFA minus infinity and whose relations and operations are all decidable/computable.</li>\n<li><code>ZFSet</code> isn't really lacking in any automation that could be provided by computability. A lot of its theorems are proved by simply passing to <code>Set</code>.</li>\n</ul>",
        "id": 537988331,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757149655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/ZFSet.20and.20computability/near/537988331\">schrieb</a>:</p>\n<blockquote>\n<p>Since <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Shrink#doc\">docs#Shrink</a> is non-computable</p>\n</blockquote>\n<p>Not anymore</p>",
        "id": 537988774,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757150105
    },
    {
        "content": "<p>Wait, what?</p>",
        "id": 537989399,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757150843
    },
    {
        "content": "<p>...yeah, it's computable alright</p>",
        "id": 537989982,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757151444
    },
    {
        "content": "<p>Does that mean there are no drawbacks to this new design?</p>",
        "id": 537990024,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757151491
    },
    {
        "content": "<p>Yeah, I believe so</p>",
        "id": 537990645,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757152136
    },
    {
        "content": "<p>or well, I don't know whether there's any other reason to use <code>PSet</code> other than computability</p>",
        "id": 537990704,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757152215
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> is the person to ask here</p>",
        "id": 537990810,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757152335
    },
    {
        "content": "<p>I don't think this has anything to do with computability. You can define any inductive using QPFs, that doesn't mean it is a good idea</p>",
        "id": 538001298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1757163760
    },
    {
        "content": "<p>the advantage is you don't need <code>PSet</code></p>",
        "id": 538001361,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757163831
    },
    {
        "content": "<p>Is QPF approach essentially different from existing approach? I feel it's not, <code>QPF.Fix</code> expands to <code>W</code> quotient by equality under the functor, which seems to be the same as <code>PSet</code> quotient by extensional equality.</p>",
        "id": 538006990,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1757168630
    },
    {
        "content": "<p>the advantage is that <code>PSet</code> is never added to the environment and you never have to write lemmas about it</p>",
        "id": 538007087,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757168692
    },
    {
        "content": "<p>Oh I see</p>",
        "id": 538007169,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1757168733
    },
    {
        "content": "<p>But if things in <code>ZFSet</code> can be defined via <code>QPF</code> infrastructure without explicit constructions on W types, I guess we can make the same thing to define <code>ZFSet</code> without explicit constructions on <code>PSet</code>?</p>",
        "id": 538007397,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1757168894
    },
    {
        "content": "<p>I mean we can define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"bp\">.</span><span class=\"n\">ofSet</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Small</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">mk'</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Shrink</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">equivShrink</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>and play with it instead of <code>PSet</code>, which is the same approach if you use QPF</p>",
        "id": 538009583,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1757170528
    },
    {
        "content": "<p>Oh, we already have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet.toSet_equiv#doc\">docs#ZFSet.toSet_equiv</a></p>",
        "id": 538009886,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1757170783
    },
    {
        "content": "<p>We could in current Mathlib deprecate the vast majority of the <code>PSet</code> API and just leave the minimum necessary to define <code>ZFSet</code>, but that would still be around 100 lines of code or so. The QPF approach means we can remove <code>PSet</code> entirely.</p>",
        "id": 538041746,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757206463
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/ZFSet.20and.20computability/near/538001298\">said</a>:</p>\n<blockquote>\n<p>I don't think this has anything to do with computability. You can define any inductive using QPFs, that doesn't mean it is a good idea</p>\n</blockquote>\n<p>I do think computability is relevant to this discussion, because some of the API is built to explicitly take it into account. This is most visible in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet.Definable#doc\">docs#ZFSet.Definable</a>, which defines a definable function on <code>ZFSet</code> as one you can lift from <code>PSet</code> into <code>ZFSet</code>, and uses that to make other operations such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet.image#doc\">docs#ZFSet.image</a> computable.</p>",
        "id": 538041857,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757206639
    },
    {
        "content": "<p>Actually that's worth pointing out, because removing <code>PSet</code> would also imply removing this.</p>",
        "id": 538041884,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757206682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/ZFSet.20and.20computability/near/537989982\">said</a>:</p>\n<blockquote>\n<p>...yeah, it's computable alright</p>\n</blockquote>\n<p>We briefly discussed the ramifications of this over at <a class=\"stream-topic\" data-stream-id=\"518132\" href=\"/#narrow/channel/518132-combinatorial-games/topic/Computability/with/538041282\">#combinatorial-games &gt; Computability</a>, and to quickly summarize things:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/518132-combinatorial-games/topic/Computability/near/537991802\">said</a>:</p>\n<blockquote>\n<p>yeah this does nothing for us</p>\n</blockquote>\n<p>Maybe I was mistaken in the assumption that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet.Definable#doc\">docs#ZFSet.Definable</a> was made for computability purposes. Is there some other reason behind it? And does that reason <em>require</em> <code>PSet</code> to exist?</p>",
        "id": 538066457,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757238190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/ZFSet.20and.20computability/near/538041857\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/ZFSet.20and.20computability/near/538001298\">said</a>:</p>\n<blockquote>\n<p>I don't think this has anything to do with computability. You can define any inductive using QPFs, that doesn't mean it is a good idea</p>\n</blockquote>\n<p>I do think computability is relevant to this discussion, because some of the API is built to explicitly take it into account. This is most visible in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet.Definable#doc\">docs#ZFSet.Definable</a>, which defines a definable function on <code>ZFSet</code> as one you can lift from <code>PSet</code> into <code>ZFSet</code>, and uses that to make other operations such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet.image#doc\">docs#ZFSet.image</a> computable.</p>\n</blockquote>\n<p>As the person who wrote the code, I'm telling you that computability was never a concern; it doesn't even make much sense since ZFC is not a computational theory. Rather, the concern was attempting to avoid the axiom of choice to prove everything except for ZFC choice</p>",
        "id": 538089284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1757261263
    },
    {
        "content": "<p>Oh wow, good luck with that in Lean 4</p>",
        "id": 538089727,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757261667
    },
    {
        "content": "<p>Ah, so I did misunderstand.</p>",
        "id": 538133793,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757308173
    },
    {
        "content": "<p>I'm curious to look at the code as it exists right now and figure out if that goal was actually achieved</p>",
        "id": 538133889,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757308241
    },
    {
        "content": "<p>Otherwise, things would certainly be made much easier by removing <code>PSet</code> and removing <code>Definable</code></p>",
        "id": 538134298,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757308625
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/ZFSet.20and.20computability/near/538133889\">said</a>:</p>\n<blockquote>\n<p>I'm curious to look at the code as it exists right now and figure out if that goal was actually achieved</p>\n</blockquote>\n<p>I think that's a bit off; it was achieved, and it has most likely been subsequently unachieved</p>",
        "id": 538159101,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1757319538
    },
    {
        "content": "<p>and I'm not sure the best response to this is to regress it even further</p>",
        "id": 538159211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1757319571
    }
]