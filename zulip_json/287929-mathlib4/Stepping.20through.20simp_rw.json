[
    {
        "content": "<p>Where do I need to put my cursor to see the intermediate state in this <code>simp_rw</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">mul_two</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 326712986,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675903606
    },
    {
        "content": "<p>Are we missing the equivalent of <a href=\"https://github.com/leanprover-community/mathlib/blob/b6da1a0b3e7cd83b1f744c49ce48ef8c6307d2f6/src/tactic/simp_rw.lean#L52\">this <code>save_info rule.pos</code> line</a> in Lean 3?</p>",
        "id": 326799112,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675944896
    },
    {
        "content": "<p>It's pretty hard to port a broken <code>simp_rw</code> without being able to step through it</p>",
        "id": 326799674,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675945094
    },
    {
        "content": "<p>Especially since it seems <code>simp_rw [foo, bar, baz]</code> now silently continues with <code>baz</code> if <code>bar</code> fails to match anything</p>",
        "id": 326802348,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675945959
    },
    {
        "content": "<p>Do the devs know that simp is not failing when it's a no-op and it's not as nice? Is this expected behaviour because this is another reason that it's annoying. Should someone open an issue?</p>",
        "id": 326953874,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675994585
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> and <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  are listed as the authors of <code>simp_rw</code> in Mathlib4</p>",
        "id": 326954758,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1675994779
    },
    {
        "content": "<p>I think it's maybe ok for <code>simp</code> to behave that way, but it is definitely a bug for <code>simp_rw</code></p>",
        "id": 326954771,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675994782
    },
    {
        "content": "<p>IMHO, if <code>simp</code> didn't use an explicitly listed lemma, then it's at least as bad as an unused argument in a function.</p>",
        "id": 326955024,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1675994841
    },
    {
        "content": "<p>That stance is incompatible with<code>ext; simp [foo, bar]</code> where <code>foo</code> is used by the first goal and <code>bar</code> the second, I think</p>",
        "id": 326955389,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675994920
    },
    {
        "content": "<p>You mean <code>ext &lt;;&gt; simp [foo, bar]</code></p>",
        "id": 326955592,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1675994967
    },
    {
        "content": "<p>Could a linter tell if a lemma wasn’t used by at least one goal? I’m not sure how powerful linters are</p>",
        "id": 326955913,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1675995040
    },
    {
        "content": "<p>Probably, the right question is \"can a linter tell ... without slowing everything down too much?\"</p>",
        "id": 326956312,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1675995155
    },
    {
        "content": "<p>yes it is possible for a linter to do this, although it needs some additional frameworking. We already have the \"unreachable tactic\" linter which warns on e.g. <code>example : 1 = 1 := by first | rfl | simp [foo]</code></p>",
        "id": 326960506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675999053
    },
    {
        "content": "<p>and it would be nice to extend this to unreachable \"parts\" of a tactic. To handle the <code>ext &lt;;&gt; simp [foo, bar]</code> situation you have to mark each part of a tactic that can be considered used, and then mark each such part as used whenever it does something as part of the tactic invocation. Then you go through the info tree in the linter and warn whenever there is a part which is marked as usable but never marked as used</p>",
        "id": 326960716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675999211
    },
    {
        "content": "<p>This is already implemented, but only for entire tactics. For parts of tactics the tactics themselves have to cooperate with the linter and add appropriate annotations into the info tree</p>",
        "id": 326960804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675999268
    },
    {
        "content": "<p>What does <code>%$e</code> do in <code>    | </code>(rwRule| $e:term) =&gt; <code>(tactic| simp%$e only [$e:term] $(loc)?)</code> in <code>simp_rw</code>?</p>",
        "id": 326961217,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1675999679
    },
    {
        "content": "<p>Oh, interesting! Infotrees are on my list of things I (know that I) don’t understand about lean yet, so it’s nice to see an example of what they get used for.</p>\n<p>So is the goal to make it so that unreachable parts of tactics get flagged automatically, even without tactics explicitly cooperating internally? Or is the opt-in cooperation something we want to keep, and we just need better frameworks to handle it?</p>",
        "id": 326961281,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1675999708
    },
    {
        "content": "<p>Did <code>simp</code> loose the <code>fail_if_unchanged</code> config option in Lean 4?</p>",
        "id": 326961862,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1676000239
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Stepping.20through.20simp_rw/near/326961217\">said</a>:</p>\n<blockquote>\n<p>What does <code>%$e</code> do in <code>    | </code>(rwRule| $e:term) =&gt; <code>(tactic| simp%$e only [$e:term] $(loc)?)</code> in <code>simp_rw</code>?</p>\n</blockquote>\n<p>I’m also curious about this. I’ve seen <code>x%$e</code> used to match an explicit <code>x</code> and name it <code>e</code>, but it’s on the other side of a match here and seems to come from other syntax. Does it somehow update the syntax node generated by <code>simp</code> with info from <code>e</code> in…some way?</p>",
        "id": 326965329,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676003764
    },
    {
        "content": "<p>my guess is that when that generated <code>simp</code> produces e.g. error messages tied to its syntax, it’ll use the ref <code>e</code> for that, even though I’m not sure of how the internals play out/what <code>%</code> “really does” here.</p>",
        "id": 326965661,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676004151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Stepping.20through.20simp_rw/near/326961862\">said</a>:</p>\n<blockquote>\n<p>Did <code>simp</code> loose the <code>fail_if_unchanged</code> config option in Lean 4?</p>\n</blockquote>\n<p>Yes, lean 4 tactics for the most part don't know how to detect if the goal changed. I was thinking about making a general <code>fail_if_unchanged</code> combinator which just checks that the goal list is the same as before and all the original goals are still unassigned</p>",
        "id": 326972115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1676009457
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Stepping.20through.20simp_rw/near/326965661\">said</a>:</p>\n<blockquote>\n<p>my guess is that when that generated <code>simp</code> produces e.g. error messages tied to its syntax, it’ll use the ref <code>e</code> for that, even though I’m not sure of how the internals play out/what <code>%</code> “really does” here.</p>\n</blockquote>\n<p>Yes, it annotates the <code>simp</code> token with the info from <code>e</code>, so that for example if simp fails then <code>e</code> will be highlighted</p>",
        "id": 326972187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1676009516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Stepping.20through.20simp_rw/near/326961281\">said</a>:</p>\n<blockquote>\n<p>So is the goal to make it so that unreachable parts of tactics get flagged automatically, even without tactics explicitly cooperating internally?</p>\n</blockquote>\n<p>That's impossible, there is no way to know how an arbitrary tactic interacts with one of its arguments since it could be parsing it or using it in many ways - tactics define their own syntax</p>",
        "id": 326972358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1676009640
    },
    {
        "content": "<p>makes sense, I was thinking there might have been some complicated behind-the-scenes way to trace whether a given input (of any form) winds up influencing the tactic state in some way…now that I write it out that sounds like it would be difficult, costly, and require far more infrastructure than is available to a linter though 😅</p>",
        "id": 326974610,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676011182
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Stepping.20through.20simp_rw/near/326972115\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Stepping.20through.20simp_rw/near/326961862\">said</a>:</p>\n<blockquote>\n<p>Did <code>simp</code> loose the <code>fail_if_unchanged</code> config option in Lean 4?</p>\n</blockquote>\n<p>Yes, lean 4 tactics for the most part don't know how to detect if the goal changed. I was thinking about making a general <code>fail_if_unchanged</code> combinator which just checks that the goal list is the same as before and all the original goals are still unassigned</p>\n</blockquote>\n<p>I implemented <code>fail_if_no_progress</code> for the port of <code>Tactic.Group</code>; I think I’ve learned some things in the short time since I wrote it, though, so I’ll take another look tomorrow…also I don’t do that assignment check, so that’s one thing to change. (also I’m open to making this a separate PR, wasn’t sure.)</p>",
        "id": 326974891,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676011344
    },
    {
        "content": "<p>that’s in <a href=\"https://github.com/leanprover-community/mathlib4/pull/2122\">!4#2122</a></p>",
        "id": 326974985,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676011423
    },
    {
        "content": "<p>that sense of \"no progress\" is quite a bit more expensive to check and I would not use it for most tactics' internal \"has anything changed\" check</p>",
        "id": 326975126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1676011537
    },
    {
        "content": "<p>but it is a reasonable user-facing tactic combinator</p>",
        "id": 326975209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1676011572
    },
    {
        "content": "<p>hmm, since these are related notions conceptually, should we just have one function/tactic with an argument/config to specify which checking behavior (cheap or costly) it performs? or should they be named differently in your opinion</p>",
        "id": 326975531,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676011792
    },
    {
        "content": "<p>What about a <code>set_option lint.unchanged</code>?</p>",
        "id": 326977309,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1676012653
    },
    {
        "content": "<p>So that we can temporarily switch it on while porting.</p>",
        "id": 326977345,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1676012668
    },
    {
        "content": "<p>(I feel like I might want to learn about linters soon...there seem to be a couple of interesting potential projects :) )</p>",
        "id": 326978749,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676013263
    },
    {
        "content": "<p>I don't think an option is appropriate here, because it is a semantic change to the tactic's behavior</p>",
        "id": 326990371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1676017970
    },
    {
        "content": "<p>I thought Yury was suggesting also (separately) having an option to lint tactics which do not change the goals, which could be useful (but I’m not sure)</p>",
        "id": 326991571,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1676018358
    },
    {
        "content": "<p>oh I see, so catching e.g. calls to <code>skip</code> in a proof, sure that is possible</p>",
        "id": 326992885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1676018778
    },
    {
        "content": "<p>An explicit <code>skip</code> can be used, e.g., in <code>&lt;;&gt; [skip, do_something]</code></p>",
        "id": 326994831,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1676019428
    },
    {
        "content": "<p>I meant something like <code>simp</code> that changed nothing.</p>",
        "id": 326994924,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1676019457
    },
    {
        "content": "<p>(or a <code>simp_rw</code> step)</p>",
        "id": 326994946,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1676019465
    },
    {
        "content": "<p>Does it make sense to split this thread? The discussion seems to have gone a different direction from the original \"the goal view isn't updated between rules\" question</p>",
        "id": 326995476,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1676019638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Stepping.20through.20simp_rw/near/326994831\">said</a>:</p>\n<blockquote>\n<p>An explicit <code>skip</code> can be used, e.g., in <code>&lt;;&gt; [skip, do_something]</code></p>\n</blockquote>\n<p>It is easy enough to make special cases for this kind of thing in a linter. You wouldn't usually give a lint warning without a very concrete semantics preserving code modification in mind</p>",
        "id": 327016463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1676025986
    },
    {
        "content": "<p>I made <a href=\"https://github.com/leanprover-community/mathlib4/pull/3738\">!4#3738</a> for the original issue of <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span></p>",
        "id": 354698330,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1682865328
    },
    {
        "content": "<p>One remaining question, inspired by the extended thread above, should we actually use <code>fail_if_no_progress</code> inside <code>simp_rw</code> so that we do see a failure if the user tries to simp_rw with a lemma that doesn't apply?</p>",
        "id": 354699652,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1682865686
    },
    {
        "content": "<p>We definitely should, though it might be better to do that in a follow-up as I expect some proofs to break</p>",
        "id": 354709740,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682868686
    },
    {
        "content": "<p>It might even be a <code>Try this</code>, instead of failing.</p>",
        "id": 354723872,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1682874516
    },
    {
        "content": "<p>I think <code>fail_if_no_progress</code> does the wrong thing; it doesn't check the lemma was actually used, right?</p>",
        "id": 354728124,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682876495
    },
    {
        "content": "<p>If <code>simp_rw [foo, bar]</code> expands to <code>simp only [foo], simp only [bar]</code> then the first <code>simp</code> might just \"make progress\" via basic kernel reduction and not via <code>foo</code></p>",
        "id": 354728347,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682876580
    },
    {
        "content": "<p>You mean like some beta reduction or whatever? I guess thats possible, maybe <code>simp_rw</code> could just run <code>simp only [] &lt;;&gt; simp only [h]</code> (i.e. do an empty simp first before running any lemmas</p>",
        "id": 354734949,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1682879725
    },
    {
        "content": "<p>Every intermediate lemma could have the same problem</p>",
        "id": 354743483,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682883982
    },
    {
        "content": "<p>Doing one before each step would likely be safe</p>",
        "id": 354743505,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682883993
    },
    {
        "content": "<p>Hmm, could you give an example of what you mean? I don't quite understand how un-<code>simp only</code>-reduced terms could show up after a simp only?</p>",
        "id": 354744316,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1682884416
    },
    {
        "content": "<p>I'm thinking of the case where one of the lemmas has a non-beta-reduced RHS</p>",
        "id": 354745255,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682884898
    },
    {
        "content": "<p>But maybe you're right</p>",
        "id": 354745262,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682884903
    },
    {
        "content": "<p><code>fail_if_no_progress</code> checks if the types of everything are unchanged up to defeq, so presumably basic kernel reductions would count as “no change”.</p>\n<p>However, I do have some code I’ve been meaning to PR which gives <code>fail_if_no_progress</code> config options which let you tweak exactly what counts as progress. This includes e.g. the ability to choose to use <code>BEq</code> for expressions instead of defeq, which would reintroduce the kernel reduction distinction but might be less expensive. Lmk if that would be of interest!</p>",
        "id": 354840629,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1682937413
    },
    {
        "content": "<p>Yes, so much of interest that I was already halfway through doing it myself!</p>",
        "id": 354851057,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1682940561
    },
    {
        "content": "<p>So I'll happily use your version, is it on a branch somewhere (I really only got around to tweaking the transparency settings, which I found to be insufficient, beq is much better)</p>",
        "id": 354851172,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1682940604
    },
    {
        "content": "<p>Yes, it’s on the <code>fail_if_no_progress</code> branch! (Sorry, I was asleep by the time this message came in.) I’ve just (rebased to master/force-pushed) and opened a PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/3757\">!4#3757</a>), so it should be at least usable/testable-with.</p>\n<p>Warning: I haven’t <em>really</em> looked at it since a few months ago. I last remember thinking there were <em>too many</em> config options. But the basic ones should remain untouched. I’ll try to finish it up today or tomorrow! :)</p>",
        "id": 354943113,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1682964722
    },
    {
        "content": "<p>update, since I said I’d do this today: found myself pushing through a headache, and couldn’t do all I hoped to. I’m prioritizing <code>mono</code>, but I hope to get the <code>fail_if_no_progress</code> config options done by Friday (or sooner, if possible). :)</p>",
        "id": 355317831,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1683089993
    },
    {
        "content": "<p>Ok great, i don't think there is any rush to get this finished, it's a nice feature but not blocking anything so no worries on it taking longer. Hope you feel better <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> .<br>\nAn update for anyone following along, simp_rw now show goals as you step through and fails if no progress was made (in the beq sense). I've fixed many places in the library where simp_rw wasn't doing anything in the same pr. This could be split up but i don't think the changes are too numerous.</p>",
        "id": 355372509,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1683105978
    },
    {
        "content": "<p>It might be beneficial to split out the \"show goals as you step through\" part, as that's very useful when porting</p>",
        "id": 355376138,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683106748
    },
    {
        "content": "<p>Did you have that working already, or did one feature require the other?</p>",
        "id": 355376276,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683106777
    },
    {
        "content": "<p>Neither feature really requires the other. I don't mind splitting it if it's useful enough.</p>",
        "id": 355388282,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1683109343
    },
    {
        "content": "<p>I've had a lot of files where being able to step through <code>simp_rw</code> would be very useful for debugging</p>",
        "id": 355390056,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683109725
    },
    {
        "content": "<p>Of course, failing when no progress is made is also very useful, but I'd prefer to have one of those features this week rather than both in two weeks</p>",
        "id": 355390284,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683109753
    },
    {
        "content": "<p>Ok <a href=\"https://github.com/leanprover-community/mathlib/pull/3738\">#3738</a> is ready then, unfortunately I force pushed as reverting the merge commit was ugly so I had to squash everything.<br>\nI've left the fixes to the existing proofs in as those were tested on this exact tactic (just without the logic that complained if they weren't changed). Therefore the diff is a bit large but it should be pretty clear that most lines are just removing a lemma or two from simp_rw.</p>",
        "id": 355425338,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1683117815
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/3782\">#3782</a> is the follow up</p>",
        "id": 355425526,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1683117846
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/3738\">!4#3738</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/3782\">!4#3782</a></p>",
        "id": 355428589,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683118421
    }
]