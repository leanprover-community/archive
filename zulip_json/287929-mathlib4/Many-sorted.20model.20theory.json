[
    {
        "content": "<p>With a couple of model theorists, we're working to formalize the basics of the model theory of valued fields. </p>\n<p>Most theorems we want to state require many-sorted logic. <br>\nAs far as we know, this has not been formally implemented in Lean 4.</p>\n<p>We are having some success translating the very basics of the one-sorted material in Mathlib essentially by</p>\n<ul>\n<li>keeping track of a type <code>S</code> of Sorts (in the Model Theory sense),</li>\n<li>encoding signatures of function/relation symbols as objects of type <code>List S</code> (compared to just having to keep track of the arity <code>n  :  ℕ</code> in the one-sorted case),</li>\n<li>encoding structures as dependent types <code>M : S → Type u</code>,</li>\n<li>encoding \"tuples with signature <code>σ :  List S</code> in a structure <code>M : S → Type u</code>\" as dependent lists, represented by e.g. <code>(i : Fin σ.length) → (M σ[i])</code>.</li>\n</ul>\n<p>Ideally, this such basic material on many-sorted logic would eventually end up in the Mathlib, so we wanted to reach to the community about basic design decisions. In particular</p>\n<ul>\n<li>Are there any opinions on using Lists for signatures rather than e.g. <code>Σ n, Fin n → S</code> or a separate datatype?</li>\n<li>It feels to us like the \"dependent lists\" should probably be wrapped in a structure or definition, with definitions and theorems to convert between the many equivalent representations, rather than the explicit Pi type above. </li>\n<li>In any case, these dependent lists seem like a rather general concept. Are there any existing lemmas in Mathlib or other standard repositories that already provide such an interface?</li>\n<li>Any other piece of advice welcome!</li>\n</ul>",
        "id": 543363086,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759768160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"940460\">Mathias Stout</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543363086\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Are there any opinions on using Lists for signatures rather than e.g. <code>Σ n, Fin n → S</code> or a separate datatype?</li>\n</ul>\n</blockquote>\n<p>I would suggest using <code>Multiset S</code> (unless you have a reason to do lists?)</p>",
        "id": 543367535,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759769727
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"940460\">Mathias Stout</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543363086\">said</a>:</p>\n<blockquote>\n<ul>\n<li>In any case, these dependent lists seem like a rather general concept. Are there any existing lemmas in Mathlib or other standard repositories that already provide such an interface?</li>\n</ul>\n</blockquote>\n<p>I am using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.TProd#doc\">docs#List.TProd</a>, which is not very well supported (and other people have told me to not use it)</p>",
        "id": 543367900,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759769862
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543367535\">said</a>:</p>\n<blockquote>\n<p>I would suggest using <code>Multiset S</code> (unless you have a reason to do lists?)</p>\n</blockquote>\n<p>How would you keep track of which sort is attached to which function parameter with a multiset?</p>",
        "id": 543368506,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1759770090
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.ToType#doc\">docs#Multiset.ToType</a></p>",
        "id": 543369554,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759770390
    },
    {
        "content": "<p><del>i'm not sure that works? since <code>Multiset</code> is <code>List</code> quotiented by permutation, you wouldn't be able to track it. (i.e. you wont be able to define things like <code>Nat.sub</code>)</del> Actually, it works, but morally you should be using <code>Finsupp α Nat</code> if you want to go that route</p>",
        "id": 543374080,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759772049
    },
    {
        "content": "<p>where <code>α</code> is your type of sorts</p>",
        "id": 543374701,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759772266
    },
    {
        "content": "<p>that aside, i'm not convinced that forgetting the order in which arguments of different types appear is beneficial</p>",
        "id": 543375308,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759772430
    },
    {
        "content": "<p>i have no doubt it will lead to some difficult to work with dependent types</p>",
        "id": 543375478,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759772478
    },
    {
        "content": "<p>You just have the sort of the argument along with a number telling you which one it is</p>",
        "id": 543387519,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759776630
    },
    {
        "content": "<p>When <code>Finsupp S Nat</code> works, <code>S → Nat</code> should also work, I guess</p>",
        "id": 543388673,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1759777061
    },
    {
        "content": "<p>then you get infinitary functions but not all the infinitary functions so it becomes a bit complicated</p>",
        "id": 543389487,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759777359
    },
    {
        "content": "<p>I think we can expect <code>S</code> be finite for practical first-order languages</p>",
        "id": 543389600,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1759777398
    },
    {
        "content": "<p>It's not infinitary function, any term or formula can only use finite indices from its signature</p>",
        "id": 543389760,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1759777457
    },
    {
        "content": "<p>Oh, I realized. If we define <code>Func : (S → Nat) → Type</code> in <code>Language</code> then it is indeed infinitary</p>",
        "id": 543393288,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1759778849
    },
    {
        "content": "<p>So <code>Finsupp</code> does make sense</p>",
        "id": 543393303,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1759778857
    },
    {
        "content": "<p>Thanks a lot for the input!</p>",
        "id": 543393369,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759778887
    },
    {
        "content": "<p>We did actually start out using <code>Finsupp S Nat</code>, which is super convenient, up to a point. Essentially many of the very basic definitions/lemmas of the Mathlib go through almost immediately.</p>\n<p>For practical applications, it seems better to keep track of the order of the variables. Basically, having all the variables ordered gives you more information to work with.</p>",
        "id": 543393393,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759778901
    },
    {
        "content": "<p>For example, suppose I did not order my variables \"between sorts\" and I want to convert a many-sorted structure to a one-sorted one (where the different sorts now become relation symbols representing disjoint sets). <br>\nSince in the one-sorted setting the variables are totally ordered, such a conversion would depend on a choice of total order on the set of sorts, which seems like it could have undesirable consequences.</p>",
        "id": 543393484,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759778935
    },
    {
        "content": "<p>By the way, if it's not an issue to ask, who's \"we\" in \"we're working to formalize....\"? I currently have all my lean time taken up by PRing another project, but I'd be very happy to collaborate on this in the near future. I actually wanted to formalize some model theoretic algebra last year (I was thinking about QE for RCFs) but then other stuff got in the way : (</p>",
        "id": 543397241,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1759780399
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466290\">Luigi Massacci</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543397241\">said</a>:</p>\n<blockquote>\n<p>By the way, if it's not an issue to ask, who's \"we\" in \"we're working to formalize....\"? I currently have all my lean time taken up by PRing another project, but I'd be very happy to collaborate on this in the near future. I actually wanted to formalize some model theoretic algebra last year (I was thinking about QE for RCFs) but then other stuff got in the way : (</p>\n</blockquote>\n<p>No issue! This is a project initiated by Deirdre Haskell in which Greg Cousins, Aaron Crighton, John Nicholson and I are currently involved with (to varying degrees). In general, we are very happy to see that other people might be interested in this as well. Feel free to direct message me when you have more time :)</p>",
        "id": 543399466,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759781189
    },
    {
        "content": "<p>Cool that someone is working on this! I've played around locally in a pathetic attempt to formalize my master's thesis. (As I'm not a Lean expert I quickly realized that it would be a tough journey and put it aside for some other day when the foundations are laid.)</p>\n<p>Indeed I also went the route of using <code>List S</code>. One of the issues I encountered quickly is that it quickly makes you lose defeqs. I.e. you need to provide (annoying/tedious) proofs that the arguments line up, like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SortedPreterm</span><span class=\"bp\">.</span><span class=\"n\">apps</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortedLanguage</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortedPreterm</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lst'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SortedTerm'</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hlst'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">lst'</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">sort</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">SortedTerm</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>Here the problem lies in needing <code>hlst'</code> <em>in the definition</em>. I tried to trick around it using <code>rfl</code> but I quickly came to think the problem is with <code>List</code>. Since equality of <code>List</code>s requires length comparison (hence proof) and there is no common quantification over two <code>List</code>s.<br>\nMy next attempt would be to refactor to <code>Vector</code> to have a shared length between tuples of sorts, but I haven't gotten round to it.</p>\n<p>Sorry for the wall of text, this just seemed like a logical place to share my experiences before anyone else pours more time into it. With again the caveat that I have limited experience with the \"setting up the right definition\" aspect of Lean. Hope it helps.</p>",
        "id": 543445140,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759813441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543389600\">said</a>:</p>\n<blockquote>\n<p>I think we can expect <code>S</code> be finite for practical first-order languages</p>\n</blockquote>\n<p>2 cents: In categorical logic, it is most definitely not the case that <code>S</code> is always finite, because many techniques involve <code>S = ob &lt;cat&gt;</code>. I would strongly advocate for a setup that does not assume <code>S</code> is finite, even if the focus is not on categorical logic right now.</p>",
        "id": 543445346,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759813605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"940460\">Mathias Stout</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543399466\">said</a>:</p>\n<blockquote>\n<p>No issue! This is a project initiated by Deirdre Haskell in which Greg Cousins, Aaron Crighton, John Nicholson and I are currently involved with (to varying degrees). In general, we are very happy to see that other people might be interested in this as well. Feel free to direct message me when you have more time <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>\n</blockquote>\n<p>I will follow your project with interest, though I am only a 'casual mathematician' and cannot commit reliable time. But would be happy to contribute on select topics and/or provide thoughts/feedback!</p>",
        "id": 543445627,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759813799
    },
    {
        "content": "<p>Final remark, there is also this thread: <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/with/543353117\">#maths &gt; Categorical logic in Lean? (algebraic theories, etc.)</a></p>",
        "id": 543445760,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759813911
    },
    {
        "content": "<p>Thanks for sharing your experience! These are the kind of responses I was hoping for :).</p>\n<p><span class=\"user-mention silent\" data-user-id=\"888530\">Jasper Mulder-Sohn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543445140\">said</a>:</p>\n<blockquote>\n<p>Indeed I also went the route of using <code>List S</code>. One of the issues I encountered quickly is that it quickly makes you lose defeqs. I.e. you need to provide (annoying/tedious) proofs that the arguments line up, like so:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SortedPreterm</span><span class=\"bp\">.</span><span class=\"n\">apps</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortedLanguage</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortedPreterm</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lst'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SortedTerm'</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hlst'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">lst'</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">sort</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">SortedTerm</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I think right here we can get around this problem by using a a dependent list/vector for lst' instead: i.e. let lst' is an object of  some type like <code>DVec l (SortedTerm SL) := (i : Fin l.length) → (SortedTerm SL l[i])</code> instead. <br>\nHowever, this only partially solves this problem and kicks the can down the road. <br>\nEven if you have a proof that l = l', you cannot directly compare <code>DVec l</code> with <code>DVec l'</code>. You have to cast over <code>l=l'</code>, which complicates things. <br>\nThese feel like subtle, but general issues that maybe other people have already given more thought to.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"888530\">Jasper Mulder-Sohn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543445140\">said</a>:</p>\n<blockquote>\n<p>My next attempt would be to refactor to <code>Vector</code> to have a shared length between tuples of sorts, but I haven't gotten round to it.</p>\n</blockquote>\n<p>If I understand correctly, you would suggest rather working with <code>Fin n → Sorts</code> or <code>Vector</code>, rather than lists for signatures?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"888530\">Jasper Mulder-Sohn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543445346\">said</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">cents</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">categorical</span><span class=\"w\"> </span><span class=\"n\">logic</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">most</span><span class=\"w\"> </span><span class=\"n\">definitely</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"ss\">`S</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">always</span><span class=\"w\"> </span><span class=\"n\">finite</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">because</span><span class=\"w\"> </span><span class=\"n\">many</span><span class=\"w\"> </span><span class=\"n\">techniques</span><span class=\"w\"> </span><span class=\"n\">involve</span><span class=\"w\"> </span><span class=\"ss\">`S</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ob</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">cat</span><span class=\"bp\">&gt;`.</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">would</span><span class=\"w\"> </span><span class=\"n\">strongly</span><span class=\"w\"> </span><span class=\"n\">advocate</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">setup</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">does</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"k\">assume</span><span class=\"w\"> </span><span class=\"ss\">`S</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">finite</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">even</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">focus</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">categorical</span><span class=\"w\"> </span><span class=\"n\">logic</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"n\">now</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>Yes, I fully agree with this. In addition, we would eventually want to talk about the T_eq construction and elimination of imaginaries, which would require infinitely many sorts.</p>\n<p>Oh, and thanks for the link to the categorical logic thread!</p>",
        "id": 543538084,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759845161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"940460\">Mathias Stout</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543538084\">said</a>:</p>\n<blockquote>\n<p>I think right here we can get around this problem by using a a dependent list/vector for lst' instead: i.e. let lst' is an object of  some type like <code>DVec l (SortedTerm SL) := (i : Fin l.length) → (SortedTerm SL l[i])</code> instead. <br>\nHowever, this only partially solves this problem and kicks the can down the road. <br>\nEven if you have a proof that l = l', you cannot directly compare <code>DVec l</code> with <code>DVec l'</code>. You have to cast over <code>l=l'</code>, which complicates things. <br>\nThese feel like subtle, but general issues that maybe other people have already given more thought to.</p>\n</blockquote>\n<p>I had this exact problem! Here's what I did</p>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/.60List.2ETProd.2Eget.60/near/536935054\">said</a>:</p>\n<blockquote>\n<p>I'm working with <code>List.TProd</code> and there's barely any API. Is there anything that I can use to index into a <code>List.TProd</code>? Something like this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">TProd</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">TProd</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">TProd</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">hi</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 543539747,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759845561
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"940460\">Mathias Stout</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543538084\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"888530\">Jasper Mulder-Sohn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543445140\">said</a>:</p>\n<blockquote>\n<p>My next attempt would be to refactor to <code>Vector</code> to have a shared length between tuples of sorts, but I haven't gotten round to it.</p>\n</blockquote>\n<p>If I understand correctly, you would suggest rather working with <code>Fin n → Sorts</code> or <code>Vector</code>, rather than lists for signatures?</p>\n</blockquote>\n<p>I actually started out with <code>Fin n</code> but it had problems even earlier, in the declaration of terms/formulas. IIRC you get issues that there is no defeq/pattern-match on the relevant <code>Fin n</code>. That got resolved nicely with <code>List</code> (with a result more similar to the current one-sorted situation). My hope is that <code>Vector</code> would work better still (with the length explicit) but I didn't actually get around to trying it.</p>\n<p>Indeed maybe a hybrid approach mixing low-level types would work better, but it does raise the question how we can a. make clear to others when to do what; and b. successfully abstract away from the concrete implementation asap. With a possible future c. without killing performance.<br>\nI think the key to doing it all successfully is to have as many nice defeqs for as long as possible.</p>",
        "id": 543555501,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759849315
    },
    {
        "content": "<p>I would suggest independently you work with <code>Fin n</code>; it has no pattern matching, but it has custom recursors, and it also has a custom notation <code>![3, 5, 1]</code></p>",
        "id": 543557078,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759849715
    },
    {
        "content": "<p>see e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Fin/Tuple/Basic.html#Fin.snocInduction\">Fin.snocInduction</a></p>",
        "id": 543557380,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759849789
    },
    {
        "content": "<p>One of the powerful things in the current one-sorted formalization is that well-formedness is implicitly baked into the type itself through inductive definition. Is it possible to retain that with this type of construction? If so, how?</p>",
        "id": 543557912,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759849936
    },
    {
        "content": "<p>My current local stuff is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SortedLanguage</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sorts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">functions</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">relations</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">sorts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">SortedPreterm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortedLanguage</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortedPreterm</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"bp\">.</span><span class=\"n\">functions</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortedPreterm</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortedPreterm</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">t'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortedPreterm</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortedPreterm</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">s</span>\n</code></pre></div>\n<p>How could one do that with the <code>Fin n</code> recursors?</p>",
        "id": 543558613,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759850125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"888530\">Jasper Mulder-Sohn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543445140\">said</a>:</p>\n<blockquote>\n<p>As I'm not a Lean expert I quickly realized that it would be a tough journey</p>\n</blockquote>\n<p>It's a tough journey for everyone <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 543558695,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1759850150
    },
    {
        "content": "<p>how is it done currently?</p>",
        "id": 543559018,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759850244
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a></p>",
        "id": 543559115,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759850269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543559018\">said</a>:</p>\n<blockquote>\n<p>how is it done currently?</p>\n</blockquote>\n<p>In one-sorted FOL the power of <code>Nat</code>'s formalization is used and we need a many-sorted equally powerful method.<br>\nMy question was: how can you define the <code>app</code> inductive (which now uses the pattern <code>s' :: l</code>) using the <code>Fin n</code> recursors?</p>",
        "id": 543559512,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759850393
    },
    {
        "content": "<p>I know nothing about multisorted model theory but I feel like sortedness maybe should not be checked on the level of parsing</p>",
        "id": 543559858,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759850479
    },
    {
        "content": "<p>to me just intuitively I feel like <code> functions : List sorts → sorts → Type v</code> is unusable</p>",
        "id": 543559962,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759850503
    },
    {
        "content": "<p>intuitively I want to just have function symbols (basically copy what FirstOrder.Language is doing) and then later assign sorts to each input of each function</p>",
        "id": 543560094,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759850533
    },
    {
        "content": "<p>hmm maybe this is ok</p>",
        "id": 543560282,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759850577
    },
    {
        "content": "<p>sorry i have not thought about this very much</p>",
        "id": 543560451,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759850618
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543559962\">said</a>:</p>\n<blockquote>\n<p>to me just intuitively I feel like <code> functions : List sorts → sorts → Type v</code> is unusable</p>\n</blockquote>\n<p>I had no problem formalizing ZFC language to the point of valid formulas...</p>",
        "id": 543560589,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759850649
    },
    {
        "content": "<p>and your elements and sets are different sorts?</p>",
        "id": 543560793,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759850696
    },
    {
        "content": "<p>(sorry i only know one-sorted zfc)</p>",
        "id": 543560830,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759850702
    },
    {
        "content": "<p>I plainly added a <code>noset</code> sort and checked that stuff broke down if I used a <code>noset</code> sort somewhere. Kind of toy model but at least the many sorts should reduce to the one sort right?</p>",
        "id": 543561351,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759850812
    },
    {
        "content": "<p>what is a noset?</p>",
        "id": 543561912,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759850944
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ZFC_sorts</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">set</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">noset</span>\n</code></pre></div>\n<p>A \"noset\" is, well, not a set, so shouldn't allow set operations. I'll attach the code to avoid this back-and-forth</p>",
        "id": 543562112,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759850992
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/0ltzxkyChrpfM0NeHrMt7FYT/Logic.lean\">Logic.lean</a></p>",
        "id": 543562333,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759851048
    },
    {
        "content": "<p>It also includes some ideas for fragments of logic baked into the formula type.</p>",
        "id": 543562513,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759851086
    },
    {
        "content": "<p>well, it does seem to work for you so far, i'm just worried that it will be hard to convert from list to a function, and you might as well need functions</p>",
        "id": 543563212,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759851271
    },
    {
        "content": "<p>Yeah well as the thread above shows it quickly starts to become difficult to have well-behaving definitions on top of this basis. So I was hoping you would have concrete ideas on how to leverage <code>Fin n</code> in a better way than <code>List</code>.</p>",
        "id": 543564727,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759851631
    },
    {
        "content": "<p>Or maybe someone else will swoop in and save the day <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span><br>\nAnyway, I have to attend to IRL business now, so my responses will be delayed.</p>",
        "id": 543564910,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759851672
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MultiSorted</span><span class=\"bp\">.</span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sorts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- For every arity, a `Type*` of functions of that arity -/</span>\n<span class=\"w\">  </span><span class=\"n\">Functions</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">functionDomain</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Functions</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Sorts</span>\n<span class=\"w\">  </span><span class=\"n\">functionTarget</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Functions</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Sorts</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- For every arity, a `Type*` of relations of that arity -/</span>\n<span class=\"w\">  </span><span class=\"n\">Relations</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span>\n<span class=\"w\">  </span><span class=\"n\">relationDomain</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Relations</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Sorts</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">sorts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- `SortedPreterm SL s` means \"a term of sort `s`\" -/</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">SortedPreterm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MultiSorted</span><span class=\"bp\">.</span><span class=\"n\">Language</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sorts</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortedPreterm</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"bp\">.</span><span class=\"n\">Functions</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SortedPreterm</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SL</span><span class=\"bp\">.</span><span class=\"n\">functionDomain</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">      </span><span class=\"n\">SortedPreterm</span><span class=\"w\"> </span><span class=\"n\">SL</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SL</span><span class=\"bp\">.</span><span class=\"n\">functionTarget</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 543566990,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759852209
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"888530\">@Jasper Mulder-Sohn</span> this is my attempt; idk what the list sort input was doing in your preterm and you had no docstring so i removed it</p>",
        "id": 543567063,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759852229
    },
    {
        "content": "<p>i assume it means \"current context\" but i don't need context</p>",
        "id": 543567081,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759852236
    },
    {
        "content": "<p>i also don't know what func is doing, clearly a function is not a term</p>",
        "id": 543567160,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759852254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"888530\">Jasper Mulder-Sohn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543562112\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ZFC_sorts</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">set</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">noset</span>\n</code></pre></div>\n<p>A \"noset\" is, well, not a set, so shouldn't allow set operations. I'll attach the code to avoid this back-and-forth</p>\n</blockquote>\n<p>Like ZFC with atoms?</p>",
        "id": 543569365,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759852864
    },
    {
        "content": "<p>i think they just wanted to attach a nonfunctional sort to test it out</p>",
        "id": 543569848,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759852993
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>  That seems interesting, I had not considered decoupling the signature of a function from its type. On a purely mathematical level, this feels a bit strange/new to me. Usually I think of multisorted languages as having a set of function or relation symbols,  for each possible signature. <br>\nDo you see any Lean-theoretical advantages to such an approach?</p>",
        "id": 543591454,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759859535
    },
    {
        "content": "<p>Also, for completeness, here is our attempt at Terms, as based on the Mathlib and using Lists</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MSLanguage</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sorts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"n\">Functions</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Sorts</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Sorts</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"n\">Relations</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Sorts</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"c1\">-- The sorts and a collection of variable symbols for each sort</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Sorts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sorts</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- A term is either a variable symbol, or a valid function application to terms-/</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MSLanguage</span><span class=\"w\"> </span><span class=\"n\">Sorts</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sorts</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sorts</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sorts</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Functions</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">s</span>\n</code></pre></div>",
        "id": 543591831,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759859671
    },
    {
        "content": "<p>It seems relatively similar, except for that we call <code>σ .length</code> and that <code>σ </code> already knows the domain of the function.</p>",
        "id": 543592203,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759859807
    },
    {
        "content": "<p>your <code>(α : Sorts → Type u')</code> is trying to interpret the language, i think you should keep language and evaluation separate</p>",
        "id": 543599042,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759862204
    },
    {
        "content": "<p>oh nvm they are variables, sorry</p>",
        "id": 543599117,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759862227
    },
    {
        "content": "<p>what happened to the previous idea of using Nat-indexed variables?</p>",
        "id": 543599180,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759862254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543599117\">said</a>:</p>\n<blockquote>\n<p>oh nvm they are variables, sorry</p>\n</blockquote>\n<p>Still,  I think you have a good point there: with the set-up for languages you suggested, it could make sense to separate it into <code>α  : Type</code> and <code>varDomain : α → Sorts</code>.<br>\nThe reason why we have not gone with this set-up so far is that the former type seems to come up more naturally, e.g. <code>Term α</code> itself is of this type.</p>",
        "id": 543608173,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759865832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543599180\">said</a>:</p>\n<blockquote>\n<p>what happened to the previous idea of using Nat-indexed variables?</p>\n</blockquote>\n<p>Essentially, we are trying to follow the very general one-sorted Mathlib set-up, which has a type <code>α</code> for \"truly free\" variables and indexes the variables that one can quantify over by Nat. <br>\nTerms which have a mix of these variables are then encoded as <code>L.Term (α ⊕ (Fin n))</code> (again, in the one-sorted case).</p>",
        "id": 543609310,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759866253
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543567063\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"888530\">Jasper Mulder-Sohn</span> this is my attempt; idk what the list sort input was doing in your preterm and you had no docstring so i removed it</p>\n</blockquote>\n<p>I was following the \"partial application\" paradigm from Flypitch, which has advantages of naturally having proper types for incomplete terms/formulas (hence <code>Preterm</code> and <code>Preformula</code>). One could also argue that it leads to more \"Lean-ish\" behaviour of the function symbols. That might simplify defining interpretations into other structures using actual functions.</p>\n<p>Both in your and Mathias' approach there is instead a dependent type formulation for immediate full application. I guess the question is if in practice explicitly providing an element of that dependent type will be annoying. Or if it is easy to do so inline.</p>",
        "id": 543677893,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759908983
    },
    {
        "content": "<p>you're dealing with sorts, you can't escape the dependent type</p>",
        "id": 543678051,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759909056
    },
    {
        "content": "<p>My impression from this thread so far (FWIW) is that from the current position it is difficult to estimate which approach will work out best. Maybe we ought to try and determine some hallmark features that the formalization should exhibit and support well, and proceed to try and make those work first?</p>",
        "id": 543678319,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759909153
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543678051\">said</a>:</p>\n<blockquote>\n<p>you're dealing with sorts, you can't escape the dependent type</p>\n</blockquote>\n<p>With partial application paradigm (i.e. <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543558613\">this</a>), you can deal with the 'right' sort one at a time, thus embedding the dependent nature in the inductive definition. Or am I misunderstanding?</p>",
        "id": 543678649,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759909278
    },
    {
        "content": "<p>i think the amount of headache you experience while developing examples will be a good enough indicator</p>",
        "id": 543678716,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759909302
    },
    {
        "content": "<p>if that escapes the dependent type then sure use it</p>",
        "id": 543678882,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759909358
    },
    {
        "content": "<p>again i don't have any expert opinion on this, i have never used multi sorted</p>",
        "id": 543678909,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759909369
    },
    {
        "content": "<p>I guess my suggestion for a way forward would be to set some goals like:</p>\n<ul>\n<li>simple toy examples/statements (e.g. one-sorted reduction, vector space + field)</li>\n<li>key definitions (e.g. interpretation into a structure)</li>\n</ul>\n<p>as well as keep an inventory of possible approaches:</p>\n<ul>\n<li>dependent type formulation <code>Fin n</code> or <code>List</code></li>\n<li>inductive formulation with <code>List</code> or <code>Vector</code></li>\n<li>searching for/introducing some more effective base type that solves the issues</li>\n</ul>\n<p>That is, some sort of framework that helps to assess whether the formalization is going in a good direction, instead of 'just' plowing on.</p>",
        "id": 543681315,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759910174
    },
    {
        "content": "<p>my opinion is that you will encounter a lot of casts so you better be comfortable with them</p>",
        "id": 543708445,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759918353
    },
    {
        "content": "<p>This is a pretty interesting thread to me, since I've been thinking quite a bit of how one would formalize terms in the context of categorical logic (and the terms and formulas are really the same as in model theory). Ideally, one would get an approach to terms that is general enough to provide a unified API for terms that works for sorted first-order logic (or any of its fragments or extensions) and also in contexts where composition of terms is constrained in some way, as it is in (possibly symmetric) linear logic, where we can't use the same variable twice (this happens when we construct terms in monoidal categories such as vector spaces).</p>\n<p>Please excuse the abstract nonsense.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Header</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>The essential insight so far has been that terms naturally carry the structure of a <em>multicategory</em> (the one sort case is called an operad), which means that given terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">t_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> with input sorts <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><msub><mi>j</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>S</mi><msub><mi>j</mi><mrow><mi>i</mi><msub><mi>n</mi><mi>i</mi></msub></mrow></msub></msub></mrow><annotation encoding=\"application/x-tex\">S_{j_{i1}},\\cdots,S_{j_{in_i}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0908em;vertical-align:-0.4075em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3281em;\"><span style=\"top:-2.357em;margin-left:-0.0572em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3281em;\"><span style=\"top:-2.357em;margin-left:-0.0572em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3448em;margin-left:0em;margin-right:0.1em;\"><span class=\"pstrut\" style=\"height:2.6595em;\"></span><span class=\"mord mathnormal mtight\">i</span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3147em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3678em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4075em;\"><span></span></span></span></span></span></span></span></span></span> and output sort <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">T_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and a term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> with input sorts <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">T_1,\\cdots, T_m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and an output sort <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> we can compose this to a new term with output sort <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>. This is a multicategory in the sense that arrows have n input objects and one output objects, instead of the usual single input we have for categories. One can then further notice that we also have actions that relabel the variables on this structure, which gives us what we call a cartesian multicategory.</p>\n<p>Taking terms over a given signature (with no relation symbols) is an operation that <em>freely</em> adds multicategorical compositions, and writing this out formally actually corresponds to soundness and completeness of this term model.</p>\n</div></div>\n<p>Unfortunately, depending of how one formalizes things, a term would be of the type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mi>u</mi><mi>l</mi><mo stretchy=\"false\">(</mo><msub><mi>S</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>⋯</mo><mtext> </mtext><mo separator=\"true\">,</mo><msub><mi>S</mi><mi>n</mi></msub><mo separator=\"true\">;</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Mul(S_1,\\cdots,S_n; T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> are the input sorts and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> is an output sort, which runs us into the topic you're talking about here. Composing these might be tricky in dependent type theory.</p>\n<p>However, mathlib's category API does exactly the same thing, right? Why did mathlib even choose to formalize categories in this dependent way? There certainly are ways to define them as a type of arrows and a type of objects together with maps determining the source and the target of an object, like in a quiver (mathlib also does quivers dependently though). Now all arrows are in the same type and we could provide notation for composing them that simply yields junk values when the target of one arrow does not match the source of the other arrow. Is there any reason we're not doing this? Cause we could certainly do the same thing for terms.</p>",
        "id": 543721451,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1759922537
    },
    {
        "content": "<p>you don't really gain anything by unbundling the sources and targets ime, because to get a non-junk value out of a valid function composition might be the same amount of work</p>",
        "id": 543722096,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759922738
    },
    {
        "content": "<p>but this comparison to category is useful</p>",
        "id": 543722118,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759922745
    },
    {
        "content": "<p>or maybe i'm wrong, i don't really know</p>",
        "id": 543722472,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759922844
    },
    {
        "content": "<p>I mean it certainly wouldn't be clean, since the junk value would be one of the identities on one of the objects (there is no \"0\" we can choose like for reals). Also, it would require decidable equality on objects, which is also not ideal. However, it would certainly keep tricky  unification problems out of definitions and offload them to theorem proofs.</p>",
        "id": 543727120,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1759924306
    },
    {
        "content": "<p>FWIW, I have a different point of view on doing multi-sorted model theory (or really logic more generally) in Lean. Namely, I think the objects should be as close as possible to the corresponding <em>syntax</em> we would write in the surface type theory. In other words, my priorities are in making it easy to apply the internalized logical framework to contexts <em>outside</em> the framework. </p>\n<p>In the case of multi-sorted theories, my inclination would be to do something like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MSLanguage</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"n\">Function</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"n\">Relation</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MSLanguage</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MSLanguage</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"c1\">-- Vars of type `s : S` give terms of type `s : S`.</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"c1\">-- If we have a term of type `s : ProdExpr S` and a function in the language to `t : S`, then</span>\n<span class=\"c1\">-- applying the function results in a term of type `t : S`.</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Function</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"c1\">-- If we have terms of type `s` and `t` then combining them results in a term of type `s.prod t`.</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 543732973,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759925981
    },
    {
        "content": "<p>The way to think about it is that <code>ProdExpr S</code> corresponds to the syntax of writing iterated products of sorts <code>s : S</code>, which is not associative by default, whereas using <code>Multiset S</code> would make it associative from the start. IMO associativity should be taken care of downstream, either by hand or using automation similar to <code>prod_assoc%</code>.</p>\n<p><code>MSLanguage.Term</code> in this case is the type of terms on an iterated product of sorts, not just on a single sort.</p>",
        "id": 543733724,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759926183
    },
    {
        "content": "<p>That sounds similar to what I was doing with typed lambda calculus</p>",
        "id": 543734049,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759926264
    },
    {
        "content": "<p>(NB. Maybe the inductive type for terms needs an additional constructor <code>|unit : L.Term \\alpha .nil</code>)</p>",
        "id": 543734143,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759926291
    },
    {
        "content": "<p>It was much easier to work with when I had the well-formedness separately</p>",
        "id": 543734192,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759926303
    },
    {
        "content": "<p>Sounds probable. Do you have a link?</p>",
        "id": 543734258,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759926323
    },
    {
        "content": "<p>It's on a branch on my mathlib fork</p>",
        "id": 543743359,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759928782
    },
    {
        "content": "<p>To expand a bit given what was written above. Once you have a language L in the sense of the code block above, you can construct inductively the type of functions of type <code>A -&gt; B</code> where A and B are <code>ProdExpr S</code>s. Then composition could be done easily.</p>",
        "id": 543750784,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759930802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543734258\">said</a>:</p>\n<blockquote>\n<p>Sounds probable. Do you have a link?</p>\n</blockquote>\n<p>you can see it at my branch <a href=\"https://github.com/plp127/mathlib4/tree/aliu/ccc\">aliu/ccc</a></p>",
        "id": 543765403,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759934321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"888530\">Jasper Mulder-Sohn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543681315\">said</a>:</p>\n<blockquote>\n<p>I guess my suggestion for a way forward would be to set some goals like:</p>\n<ul>\n<li>simple toy examples/statements (e.g. one-sorted reduction, vector space + field)</li>\n<li>key definitions (e.g. interpretation into a structure)</li>\n</ul>\n</blockquote>\n<p>Yes, I definitely agree. We are testing out approaches specifically on vector spaces + fields to see what works and what additional API and lemmas are required to</p>\n<ol>\n<li>make it as smooth as possible to actually define theories and structures and state theorems about them</li>\n<li>help Lean unfold operations on signatures and variable tuples, as to be able to prove those theorems.</li>\n</ol>\n<p>Additionally, it felt prudent to check with more experienced Lean people if there could be an obviously wrong/right approach. Hence this thread, which has been extremely interesting :)</p>",
        "id": 543776244,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759936883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"402440\">Adrian Marti</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543727120\">said</a>:</p>\n<blockquote>\n<p>I mean it certainly wouldn't be clean, since the junk value would be one of the identities on one of the objects (there is no \"0\" we can choose like for reals). Also, it would require decidable equality on objects, which is also not ideal. However, it would certainly keep tricky  unification problems out of definitions and offload them to theorem proofs.</p>\n</blockquote>\n<p>That is a very interesting perspective. <br>\nFrom our perspective, dependent types seemed quite nice (initially), precisely because they naturally capture the idea of disjointness of sorts at the type level. <br>\nDo you know any examples in the Mathlib or other projects where this less dependent approach reduces the overhead?</p>",
        "id": 543778114,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759937379
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Interesting! </p>\n<p>So if I understand correctly, a <code>Term α s</code> actually represents a (nonassociative) product of terms, with targets in the sorts described by <code>s</code>?</p>",
        "id": 543779318,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759937686
    },
    {
        "content": "<p>In the context that we want to work in, all signatures are associative. Do I understand correctly that you believe one should build a sufficiently general framework where also nonassociative signatures <br>\nare allowed?</p>",
        "id": 543780505,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759938021
    },
    {
        "content": "<p>What would you think of instead defining an Dependent List inductive type e.g. as follows</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">DList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\">     </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DList</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">DList</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">DList</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>\n<p>And then rather passing on a <code>DList S (Term α)</code> to a function symbol to construct terms?</p>",
        "id": 543781747,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759938397
    },
    {
        "content": "<p>this looks like the same as <code>List (Sigma f)</code></p>",
        "id": 543781946,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759938470
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"940460\">Mathias Stout</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543780505\">said</a>:</p>\n<blockquote>\n<p>Do I understand correctly that you believe one should build a sufficiently general framework where also nonassociative signatures<br>\nare allowed?</p>\n</blockquote>\n<p>No, not quite. I'm thinking about the usual model-theoretic context. The point of <code>ProdExpr S</code> is that if you have some function <code>X : S -&gt; Type</code>, then you can associate to <code>P : ProdExpr S</code> a type as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"bp\">.</span><span class=\"n\">Interpret</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">Interpret</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">Interpret</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n</code></pre></div>\n<p>And such \"interpretations\" of <code>ProdExpr S</code> are exactly the kinds of types where you consider elements if you have some concrete interpretation of your language with sorts S (which would involve such a function <code>X</code> that interprets elements of <code>S</code> as types). The <code>ProdExpr S</code> then keeps track of how such a type is constructed out of the sorts in a <em>syntactic</em> way, which means that you could more easily relate the logic which is simulated internally to the type-theoretic logic you get in such an interpretation.</p>",
        "id": 543786059,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759939690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543781946\">said</a>:</p>\n<blockquote>\n<p>this looks like the same as <code>List (Sigma f)</code></p>\n</blockquote>\n<p>Yes, I believe it essentially the same thing, but packed in a nonstandard way (which may make it worse than  <code>List (Sigma f)</code>).</p>",
        "id": 543788293,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759940395
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"940460\">Mathias Stout</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543778114\">said</a>:</p>\n<blockquote>\n<p>That is a very interesting perspective. <br>\nFrom our perspective, dependent types seemed quite nice (initially), precisely because they naturally capture the idea of disjointness of sorts at the type level. <br>\nDo you know any examples in the Mathlib or other projects where this less dependent approach reduces the overhead?</p>\n</blockquote>\n<p>Honestly, I am also naturally more drawn to the dependent version, though I really don't know how well unification of list types, or of the <code>Fin n -&gt; A</code> works out when trying to compose terms. I think the <em>partial application</em> idea might be a compromise between the fully dependent version and the fully untyped version.</p>",
        "id": 543788485,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1759940463
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> </p>\n<p>Oh, I see. Interesting!<br>\nIt seems like I should try to better understand how this contrasts to e.g. <code>List (Sigma X)</code>.<br>\n(Don't have time right now, but will think it over later)</p>",
        "id": 543790241,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759941019
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"402440\">Adrian Marti</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543788485\">said</a>:</p>\n<blockquote>\n<p>Honestly, I am also naturally more drawn to the dependent version, though I really don't know how well unification of list types, or of the <code>Fin n -&gt; A</code> works out when trying to compose terms. I think the <em>partial application</em> idea might be a compromise between the fully dependent version and the fully untyped version.</p>\n</blockquote>\n<p>What is the partial application idea</p>",
        "id": 543794473,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759942322
    },
    {
        "content": "<p><del>I meant something like <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543558613\">this</a>, where you apply one variable at the time. I haven't thought about whether this actually works out or not though.</del></p>",
        "id": 543795439,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1759942678
    },
    {
        "content": "<p>To me a \"compromise\" is anything where we construct terms where we check that they have the right number of inputs through types, but we don't check that the inputs have the right sorts.</p>",
        "id": 543796468,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1759943007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543786059\">said</a>:</p>\n<blockquote>\n<p>The <code>ProdExpr S</code> then keeps track of how such a type is constructed out of the sorts in a <em>syntactic</em> way, which means that you could more easily relate the logic which is simulated internally to the type-theoretic logic you get in such an interpretation.</p>\n</blockquote>\n<p>I think in that sense the <code>ProdExpr</code> approach is comparable to partial application in that it allows to incrementally define the interpretation rather than having to ex-machina interpret the entire domain of a function symbol.</p>\n<p>Conceptually though it seems at least inelegant to have a base type which is nonassociative. After all, a function symbol must a priori specify its \"association\" so it feels kind of moot.<br>\nDo you know if it really behaves any different than choosing an arbitrary yet consistent variant (classical iterated binary product)?</p>\n<p>What your approach did trigger in me is that of course the interpretation and actual model theory will be easier when there is a more natural correspondence between the ways the syntax and the model are formalized. Stuff will carry over in the \"natural/obvious\" way. So maybe the approaches considered here can be compared with how the foundations are formalized on the model side (notably sets and categories).</p>",
        "id": 543816188,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759950259
    },
    {
        "content": "<p>this feels really similar to when I did the lambda calculus</p>",
        "id": 543816607,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759950409
    },
    {
        "content": "<p>My point of view is that no what what you do, you will have to deal with the fact that products in type theory are not definitionally associative. If you base your work on lists <code>L</code>, you will probably end up defining a type associated to a list <code>L</code>, and you wouldn't have <code>(L ++ L').type = L.type x L'.type</code>, so then you end up dealing with dependent type theory hell if you associated <code>(A ++ B) ++ C</code> to <code>A ++ (B ++C)</code>. The approach using <code>ProdExpr</code> takes the point of view that you should deal with this hell <em>as early as possible</em> (which in my experience makes it much easier downstream, at the expense of a bit more work initially).</p>",
        "id": 543816849,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759950509
    },
    {
        "content": "<p>what I did is that I have the terms separate from their typing judgements</p>",
        "id": 543817320,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759950707
    },
    {
        "content": "<p>so you can put a cast on the typing judgement without doing anything to the term</p>",
        "id": 543817352,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759950719
    },
    {
        "content": "<p>this worked great until I encountered a situation where the form of the terms depended on the types and then it was annoying and tedious (but not difficult)</p>",
        "id": 543817528,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759950793
    },
    {
        "content": "<p>I think for such annoyances one should do a bit of metaprogramming</p>",
        "id": 543817834,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759950897
    },
    {
        "content": "<p>what would the metaprogram do</p>",
        "id": 543818219,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759951055
    },
    {
        "content": "<p>do you mean a metaprogram like <a href=\"https://tqft.net/mathlib4files/Tactic/DepRewrite\">file#Tactic/DepRewrite</a></p>",
        "id": 543818322,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759951091
    },
    {
        "content": "<p>Maybe I don't have a concrete enough idea of what sorts of issues you encountered. What I envision is something like <code>prod_assoc%</code>.</p>",
        "id": 543818440,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759951128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543816849\">said</a>:</p>\n<blockquote>\n<p>If you base your work on lists <code>L</code>, you will probably end up defining a type associated to a list <code>L</code>, and you wouldn't have <code>(L ++ L').type = L.type x L'.type</code>, so then you end up dealing with dependent type theory hell if you associated <code>(A ++ B) ++ C</code> to <code>A ++ (B ++C)</code>.</p>\n</blockquote>\n<p>exactly this sort of issues</p>",
        "id": 543818662,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759951206
    },
    {
        "content": "<p>Yeah, take a look at what <code>prod_assoc</code> does.</p>",
        "id": 543818703,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759951220
    },
    {
        "content": "<p>where can I look at it</p>",
        "id": 543818726,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759951230
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/c7bb7934b274be431629a1d00f2b18f616b1eb4f/Mathlib/Tactic/ProdAssoc.lean#L24-L28\">https://github.com/leanprover-community/mathlib4/blob/c7bb7934b274be431629a1d00f2b18f616b1eb4f/Mathlib/Tactic/ProdAssoc.lean#L24-L28</a></p>",
        "id": 543818757,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759951241
    },
    {
        "content": "<p>this technically won't work in my situation because I don't have a definite amount of products</p>",
        "id": 543818885,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759951297
    },
    {
        "content": "<p>since it's a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.TProd#doc\">docs#List.TProd</a></p>",
        "id": 543818921,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759951313
    },
    {
        "content": "<p>but I see the idea</p>",
        "id": 543818926,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759951316
    },
    {
        "content": "<p>Oh, I see if you use <code>TProd</code> then you won't be able to do something similar indeed.</p>",
        "id": 543818985,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759951342
    },
    {
        "content": "<p>One of the benefits of things like <code>ProdExpr</code> is that doing an analogous thing should work.</p>",
        "id": 543819040,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759951361
    },
    {
        "content": "<p>my case is a bit trickier because with products you don't need coherence lemmas since they're all definitional equalities but I need coherences</p>",
        "id": 543819049,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759951363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543816849\">said</a>:</p>\n<blockquote>\n<p>My point of view is that no what what you do, you will have to deal with the fact that products in type theory are not definitionally associative. If you base your work on lists <code>L</code>, you will probably end up defining a type associated to a list <code>L</code>, and you wouldn't have <code>(L ++ L').type = L.type x L'.type</code>, so then you end up dealing with dependent type theory hell if you associated <code>(A ++ B) ++ C</code> to <code>A ++ (B ++C)</code>. The approach using <code>ProdExpr</code> takes the point of view that you should deal with this hell <em>as early as possible</em> (which in my experience makes it much easier downstream, at the expense of a bit more work initially).</p>\n</blockquote>\n<p>I fully agree with this sentiment, that the foundations should cater for this type of issue. Maybe I am just still resistant to the idea that the work must actually be done and must be 'hell' <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span><br>\nI would be happy to defer to people actually having gone through that <em>in Lean</em>. I guess it is all ok as long as there is an end to the 'hell' phase...</p>",
        "id": 543819934,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759951700
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543816849\">said</a>:</p>\n<blockquote>\n<p>My point of view is that no what what you do, you will have to deal with the fact that products in type theory are not definitionally associative. If you base your work on lists <code>L</code>, you will probably end up defining a type associated to a list <code>L</code>, and you wouldn't have <code>(L ++ L').type = L.type x L'.type</code>, so then you end up dealing with dependent type theory hell if you associated <code>(A ++ B) ++ C</code> to <code>A ++ (B ++C)</code>. The approach using <code>ProdExpr</code> takes the point of view that you should deal with this hell <em>as early as possible</em> (which in my experience makes it much easier downstream, at the expense of a bit more work initially).</p>\n</blockquote>\n<p>Yes, this is definitely currently an annoyance. Even if <code>L = L'</code>, then annoying casts are needed between <code>L.type and L'.type</code>. This 'hell' seems like it could be overcome by providing definitions along the lines of <code>Fin.cast</code>and then proving lots of lemmas 'flattening' repeated applications. If something along the lines of <code>ProdExpr</code> would clean this up (possibly at the cost of proving lots lemmas), that would be an improvement.</p>",
        "id": 543853992,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759971289
    },
    {
        "content": "<p>Still, I don't think I fully grasp the idea behind <code>ProdExpr</code>. Given just the definition of <code>ProdExpr</code> and <code>ProdExpr.Interpret</code>, my first attempt at defining terms would be like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">z</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MSLanguage</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"n\">Function</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"n\">Relation</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"bp\">.</span><span class=\"n\">Interpret</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">z</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\">      </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">Interpret</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">Interpret</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\">       </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MSLanguage</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MSLanguage</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"c1\">-- Vars of type `s : S` give terms of type `s : S`.</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"c1\">-- If we have a product of terms of type in the language to `t : S`, then</span>\n<span class=\"c1\">-- applying the function results in a term of type `t : S`.</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Function</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"bp\">.</span><span class=\"n\">Interpret</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">t</span>\n</code></pre></div>\n<p>This inductive definition fails with the error <code>(kernel) arg #7 of 'MSLanguage.Term.func' contains a non valid occurrence of the datatypes being declared</code>. This is new to me. It seems that the mutual induction on <code>ProdExpr.Interpret</code> and <code>Term L α</code> is causing some Type issues?</p>",
        "id": 543854266,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759971527
    },
    {
        "content": "<p>ok I see what you want to do and I see why it doesn't work</p>",
        "id": 543854817,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759971977
    },
    {
        "content": "<p>maybe you can make <code>ProdExpr.Interpret</code> an inductive type instead?</p>",
        "id": 543854866,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759972011
    },
    {
        "content": "<p>That’s not the purpose of <code>ProdExpr.Interpret</code>, rather its purpose would be to define a type-theoretic interpretation of your language. The inductive type in my original code block should correspond to terms with this approach (modulo the missing <code>unit</code> constructor)</p>",
        "id": 543855554,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759972568
    },
    {
        "content": "<p>I guess mathlib calls it <code>Structure</code> in the single sorted case: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure</a></p>",
        "id": 543855718,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759972707
    },
    {
        "content": "<p>Oh ok, thanks for helping me out in understanding this! <br>\nI figured I went wrong somewhere when I tried to use this in the same way that I would use the dependent types that were discussed earlier.</p>",
        "id": 543856135,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759973067
    },
    {
        "content": "<p>Would it be fair to say that if I have a dependent type, say <code>X : S → Type</code>,  and some <code>s : ProdExpr S</code>, then <code>X s</code> represents a product <code>(X s₁) × (X s₂) × ... × (X sₙ)</code> (modulo associativity issues)?</p>",
        "id": 543856137,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759973073
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543855718\">said</a>:</p>\n<blockquote>\n<p>I guess mathlib calls it <code>Structure</code> in the single sorted case: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure</a></p>\n</blockquote>\n<p>Oh, I see that makes a lot of sense now, and is surprisingly elegant.</p>",
        "id": 543856379,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759973267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"940460\">Mathias Stout</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543856137\">said</a>:</p>\n<blockquote>\n<p>Would it be fair to say that if I have a dependent type, say <code>X : S → Type</code>,  and some <code>s : ProdExpr S</code>, then <code>X s</code> represents a product <code>(X s₁) × (X s₂) × ... × (X sₙ)</code> (modulo associativity issues)?</p>\n</blockquote>\n<p>I think this would be</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>Application type mismatch: The argument\n  s\nhas type\n  ProdExpr S\nbut is expected to have type\n  S\nin the application\n  X s\n</code></pre></div>",
        "id": 543856510,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759973387
    },
    {
        "content": "<p>Right it’s not exactly <code>X s</code> rather <code>s.Interpret X</code></p>",
        "id": 543856593,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1759973433
    },
    {
        "content": "<p>yeah then that seems to would be correct</p>",
        "id": 543856759,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759973597
    },
    {
        "content": "<p>Oh yes, indeed.<br>\nI guess then throughout the development  of the basics, one would use e.g.<code>Term α  s </code> for some <code>s : ProdExpr S</code> where the <code>List</code> approach would use dependent objects like <code>(i : Fin l.length) → (Term' α l[i])</code> with <code>l : List S</code> and <code>Term' α : S → Type v</code>.</p>",
        "id": 543858630,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759975336
    },
    {
        "content": "<p>At the very least, I feel like this nice idea should be properly tested. It deviates quite a bit from the \"dependent listlike\" approaches, which essentially all are isomorphic to a <code>List</code> of <code>Sigma</code> types (but might have different advantages in Lean). I currently am quite far from having any sufficient amount of experience to guess to the eventual effects and benefits.</p>",
        "id": 543858684,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759975417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"940460\">Mathias Stout</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543858684\">said</a>:</p>\n<blockquote>\n<p>which essentially all are isomorphic to a <code>List</code> of <code>Sigma</code> types</p>\n</blockquote>\n<p>sometimes you have a list of indices in mind and you want to restrict the list to be \"over\" your indices</p>",
        "id": 543858774,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759975503
    },
    {
        "content": "<p>so like a list of sigmas but separating the fst and snd into separate lists</p>",
        "id": 543858844,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759975547
    },
    {
        "content": "<p>Yeah, exactly. I guess it  would have been more precise to state that you have a List of Sigma types + a proof that the projection onto the first components gives you the list of indices that you have in mind.</p>",
        "id": 543860924,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1759977336
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"940460\">@Mathias Stout</span> I am curious where your developments will take you; is there some place I can keep tabs on the progress, other than this thread? (And possibly chip in for some contributions if I find the opportunity?)</p>",
        "id": 543874213,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1759988409
    },
    {
        "content": "<p>By the way, I heard rumors that some folks are interested in a formalization of the model theory of valued fields. Is this related?</p>",
        "id": 543945600,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1760012752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"940460\">Mathias Stout</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543363086\">said</a>:</p>\n<blockquote>\n<p>With a couple of model theorists, we're working to formalize the basics of the model theory of valued fields.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> it seems like we've gone full circle <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 543945888,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760012828
    },
    {
        "content": "<p>Aha!</p>",
        "id": 543945951,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1760012845
    },
    {
        "content": "<p>Ok I guess I didn’t scroll up high enough</p>",
        "id": 543946017,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1760012861
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"888530\">Jasper Mulder-Sohn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543874213\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"940460\">Mathias Stout</span> I am curious where your developments will take you; is there some place I can keep tabs on the progress, other than this thread? (And possibly chip in for some contributions if I find the opportunity?)</p>\n</blockquote>\n<p>Awesome, really cool to hear that you're interested.<br>\nThere is currently no public-facing Github repo or anything like that. But I'll discuss with the rest of our group and definitely get back to you :)</p>",
        "id": 543979787,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1760021010
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"888530\">Jasper Mulder-Sohn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543874213\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"940460\">Mathias Stout</span> I am curious where your developments will take you; is there some place I can keep tabs on the progress, other than this thread? (And possibly chip in for some contributions if I find the opportunity?)</p>\n</blockquote>\n<p>Took quite some time to get back to this, sorry for that. But there is a now a public GitHub, containing a partial proof of concept, along the lines of the first post in this thread. However, we're interested in finetuning the definition and trying in more detail some of the suggestions that were made in this thread. Feel free to point out any issues and give feedback.</p>\n<p><a href=\"https://github.com/Mathias-Stout/Many-sorted-model-theory\">https://github.com/Mathias-Stout/Many-sorted-model-theory</a></p>",
        "id": 558020454,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1763492522
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"940460\">Mathias Stout</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/558020454\">said</a>:</p>\n<blockquote>\n<p>Took quite some time to get back to this, sorry for that. But there is a now a public GitHub, containing a partial proof of concept, along the lines of the first post in this thread. However, we're interested in finetuning the definition and trying in more detail some of the suggestions that were made in this thread. Feel free to point out any issues and give feedback.</p>\n<p><a href=\"https://github.com/Mathias-Stout/Many-sorted-model-theory\">https://github.com/Mathias-Stout/Many-sorted-model-theory</a></p>\n</blockquote>\n<p>Thanks for the effort and heads up. I'll check it out and report back <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 558213569,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1763561532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543786059\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"940460\">Mathias Stout</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/543780505\">said</a>:</p>\n<blockquote>\n<p>Do I understand correctly that you believe one should build a sufficiently general framework where also nonassociative signatures<br>\nare allowed?</p>\n</blockquote>\n<p>No, not quite. I'm thinking about the usual model-theoretic context. The point of <code>ProdExpr S</code> is that if you have some function <code>X : S -&gt; Type</code>, then you can associate to <code>P : ProdExpr S</code> a type as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"bp\">.</span><span class=\"n\">Interpret</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">Interpret</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">Interpret</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n</code></pre></div>\n<p>And such \"interpretations\" of <code>ProdExpr S</code> are exactly the kinds of types where you consider elements if you have some concrete interpretation of your language with sorts S (which would involve such a function <code>X</code> that interprets elements of <code>S</code> as types). The <code>ProdExpr S</code> then keeps track of how such a type is constructed out of the sorts in a <em>syntactic</em> way, which means that you could more easily relate the logic which is simulated internally to the type-theoretic logic you get in such an interpretation.</p>\n</blockquote>\n<p>I'm not really sure what the consequences of this will be, but I at least have one reason <em>not</em> to want this to be the core definition of first-order logic for mathlib:  In variations on first-order logic, such as continuous logic (which I very much want to formalize at some point), we work with formulas that have infinitely many free variables, and unless I'm missing something, this construction can't account for that.</p>",
        "id": 558723149,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1763748467
    },
    {
        "content": "<p>I should clarify that <code>ProdExpr S</code> here is the syntactic representation of the types where the free (or bound) variables live, not something representing the variables themselves.</p>",
        "id": 558742035,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1763755116
    },
    {
        "content": "<p>Just to add a little bit more: in the end, our interest is in building out the basics of model theory of valued fields (say, at least up to Ax-Kochen/Ersov) principles, on which more advanced (possibly research-level) mathematics can be built, which would be of interest to fellow model theorists.<br>\nSo for the formalization of many-sorted logic, we're looking for the following qualities</p>\n<p>1) The basic definitions should be (able to be) integrated into Mathlib, so that the rest of the project is on stable footing.<br>\n2) (Related to 1) Experienced contributors to Mathlib/Mathlib.ModelTheory should be happy with the choice of formalization.<br>\n3) It should be as accessible as possible to do actual model theory (of say, valued fields) with the end product.</p>\n<p>So to that end, we're very interested in people telling us now that the current approach is fundamentally flawed, or likely to be OK (with maybe some small changes later, informed by the issues we face when doing more advanced stuff).</p>",
        "id": 560012442,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1764017177
    },
    {
        "content": "<p>Also, knowing a little bit more about the inner workings of Lean than last time, I see the appeal of <code>ProdExpr</code> more clearly. <br>\nStill, I find it hard to see the long-term impact on e.g. how it might detach formalized model theory from the way it is informally written (if it impacts this at all).<br>\nIt also seems a bit harder to go back on using/not using <code>ProdExpr</code> than for the other suggestions (such as partial application, or swapping out <code>List</code> for a different structure).<br>\nWhile I don't have big issues with rewriting our foundations now, I'd rather not have to go back while we are doing more advanced mathematics.</p>",
        "id": 560012554,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1764017213
    },
    {
        "content": "<p>My point of view on this is that if you want to do abstract model theory, then it doesn't matter too much whether you use lists, multisets, or whatever other representation you choose. However, if the plan is to do <em>applied</em> model theory (for example, the model theory of valued fields ;)) then you probably want your model-theoretic foundations to be <em>as close as possible</em> to Lean's foundations, so that you have an easier time actually <em>applying</em> model theory to, say, valued fields defined in terms <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ValuativeRel#doc\">docs#ValuativeRel</a> . IMO, this <code>ProdExpr S</code> approach is an approach that would give something closer to the syntactic behavior of the surface type theory. </p>\n<p>At the end of the day, the language, terms, etc. are <em>syntactic objects</em>. By working with List/Multiset/... you're mixing syntax with semantics a little bit.</p>",
        "id": 560013431,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1764017539
    },
    {
        "content": "<p>Yes, I (am starting to) see that now :). Thanks for the suggestions and all the clarifications!<br>\nWe've been experimenting a bit more with <code>ProdExpr S</code> and will be uploading the intermediate results to the GitHub repo soon.  <br>\nIt does raise the question of whether you could push this even further first work e.g. with 'FisrtOrderExpressions' rather than <code>Formula</code>, where the former might be potentially ill-formed, and if such a thing would even be desirable (for an appropriate definition of desirable)</p>",
        "id": 560863752,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1764371418
    },
    {
        "content": "<p>Why does ProdExpr S allow for products of arbitrary ProdExpr and not just appending a singleton like in the definition of Lists:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ProdExpr'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr'</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\">   </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr'</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr'</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr'</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n</code></pre></div>\n<p>This would circumvent the associativity problems while still preserving the same syntactic structure (I think?)</p>",
        "id": 569550076,
        "sender_full_name": "Jonas van der Schaaf",
        "timestamp": 1769102936
    },
    {
        "content": "<p>That's because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>X</mi><mo>×</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mo stretchy=\"false\">(</mo><mi>Z</mi><mo>×</mo><mi>W</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(X \\times Y) \\times (Z \\times W)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">)</span></span></span></span> is not defeq to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>X</mi><mo>×</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mi>Z</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">((X \\times Y) \\times Z) \\times W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">((</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>.</p>",
        "id": 569550283,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1769102998
    },
    {
        "content": "<p>I get that, but how is this closer to the type theory of lean? Usually functions out of products are curried so associativity is not really an issue there?</p>",
        "id": 569561054,
        "sender_full_name": "Jonas van der Schaaf",
        "timestamp": 1769106151
    },
    {
        "content": "<p>I'm not sure what you mean.</p>",
        "id": 569561449,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1769106263
    },
    {
        "content": "<p>In my previous comment, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo separator=\"true\">,</mo><mi>Z</mi><mo separator=\"true\">,</mo><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">X,Y,Z,W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> are meant to be Lean types, for example.</p>",
        "id": 569561513,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1769106279
    },
    {
        "content": "<p>Yes, it's true that functions out of products are usually curried, and I understand that you want to consider functions out of iterated products in model theory (and elsewhere), but that's not the only thing you want to do with iterated products of sorts.</p>",
        "id": 569562039,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1769106435
    },
    {
        "content": "<p>Ah, I think I’m just missing where the iterated products come from</p>",
        "id": 569562167,
        "sender_full_name": "Jonas van der Schaaf",
        "timestamp": 1769106477
    },
    {
        "content": "<p>Sorry for the confusion</p>",
        "id": 569562203,
        "sender_full_name": "Jonas van der Schaaf",
        "timestamp": 1769106485
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631408\">Jonas van der Schaaf</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/569562167\">said</a>:</p>\n<blockquote>\n<p>Ah, I think I’m just missing where the iterated products come from</p>\n</blockquote>\n<p>And therefore didn’t see the need for this construction instead of just lists</p>",
        "id": 569562656,
        "sender_full_name": "Jonas van der Schaaf",
        "timestamp": 1769106617
    },
    {
        "content": "<p>In case it helps, the (simple) key idea for using ProdExpr to construct iterated products is this (from one of the messages above):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"bp\">.</span><span class=\"n\">Interpret</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProdExpr</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">Interpret</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">Interpret</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n</code></pre></div>",
        "id": 569563032,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1769106715
    },
    {
        "content": "<p>So, it took some time but I didn't forget... Finally managed to spend some time to dive into this.</p>\n<p>I was pleasantly surprised to find the <code>ProdExpr</code> approach as part of the repository now. My observations so far:</p>\n<ul>\n<li>The clarity and ease of using <code>ProdExpr</code> have convinced me that it is probably a better approach than using lists. Adam's remark that we are talking about _syntactic_ objects really helped and it makes many things more natural.</li>\n<li>However I have the feeling that the concept hasn't been thoroughly tested yet. The proof of the pudding will be in the handling of substitution which I think hasn't been defined just yet.</li>\n<li>Experimenting with some stuff locally reveals a need to refer to a variable position without committing to a sort (the position needs to be prepended to the <code>indVar</code> of substituted sorts). My first hunch is that this might yield overlap with <code>indVar</code>. Might there be a trick to use <code>ProdExpr Unit</code> together with <code>indVar</code> and some API building on translating between <code>ProdExpr</code> on different types of sorts?</li>\n<li>One step further than setting that API up would be to define <code>ProdExpr</code> differently, using only the structure of the products, and then defining <code>ProdExpr S</code> on top of that. If that even makes sense (my experience defining useful inductive types is still somewhat limited).</li>\n</ul>\n<p>Unfortunately I don't have the luxury to experiment extensively before posting these admittedly rough thoughts. So please regard them with the appropriate scepticism; hopefully something useful remains after further scrutiny. <span class=\"user-mention\" data-user-id=\"940460\">@Mathias Stout</span></p>",
        "id": 571315327,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1769979321
    },
    {
        "content": "<p>Thanks so much for the comments!</p>\n<p>We have been tinkering quite a bit with API for instantiating variables and substituting terms. These should be cleaned up a little and will make it to GitHub really soon (hopefully today). </p>\n<p><span class=\"user-mention silent\" data-user-id=\"888530\">Jasper Mulder-Sohn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Many-sorted.20model.20theory/near/571315327\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Experimenting with some stuff locally reveals a need to refer to a variable position without committing to a sort (the position needs to be prepended to the <code>indVar</code> of substituted sorts). My first hunch is that this might yield overlap with <code>indVar</code>. Might there be a trick to use <code>ProdExpr Unit</code> together with <code>indVar</code> and some API building on translating between <code>ProdExpr</code> on different types of sorts?</li>\n</ul>\n</blockquote>\n<p>I don't think I fully understand the precise issue at work here.</p>\n<p>Certainly, we've been running into a related issue where \"named variables\" <code>α : Sorts → Type*</code> are useful to reason about generally, while the \"indexed\" variables <code>σ : ProdExpr Sorts</code> are useful when quantifying and and interpreting formulas as definable sets. <br>\nWe've mostly been following the existing Mathlib convention of working with <code>BoundedFormula α σ</code>, where <code> σ</code> is mostly used for quantification and <code>α</code> for the named variables, and then defining operations to convert between those when necessary.</p>",
        "id": 571453212,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1770044192
    },
    {
        "content": "<p>I think yesterday I may have implicitly made a step that I didn't realize. I was conflating the definitions of function symbols on the one hand and that of terms which use variables <code>α</code> on the other.</p>\n<p>If I understand it correctly then you are at the level of variables <code>α</code> assuming implicit associativity whereas you don't at the function symbol level.</p>\n<p>By doing so, don't you lose the ability to e.g. easily define a new function symbol out of a certain composition of terms? The structure of the association would always be identical as it would have to emerge from <code>α</code> which doesn't carry it. Does this not lead to issues down the road when we want to talk about concepts like defined symbols? Maybe it is considered sufficient to have <code>PEquiv</code> in such cases instead of strict equality? But then still you have to specify the <code>ProdExpr</code> structure of this new symbol somehow, right?</p>\n<p>In any case I was struggling a bit with a potential need to translate <code>ProdExpr S</code> to <code>ProdExpr T</code> or <code>ProdExpr α</code> and that's where my comments came from.</p>\n<p>It might be that this is not an issue at all, but from a distance at the very least these are some aspects of <code>ProdExpr</code> formalism that I do not fully oversee right now. So I'm very curious (again) to see where you're at!</p>",
        "id": 571530500,
        "sender_full_name": "Jasper Mulder-Sohn",
        "timestamp": 1770068419
    },
    {
        "content": "<p>Yes, there's definitely some tension between the names <code>α : Sorts → Type*</code> and shapes <code>σ : ProdExpr Sorts</code>.</p>\n<p>The former are great for abstract purposes and flexibility, and e.g. allow you to define a type in infinitely many variables.<br>\nThe latter are convenient for actually constructing terms and handling quantification in BoundedFormulas.</p>\n<p>Following Mathlib, we distinguish explicitly between these two types of variables in <code>BoundedFormula</code>, but we a priori only have named variables in <code>Term</code>. We can essentially achieve having both of them inside any <code>Term</code>, by taking a dependent sum over <code>α</code> and <code>σ.indVar</code>.<br>\nThe latter is essentially what dependent maps <code>Fin σ.length → Sorts</code> are to <code>List Sorts</code>, but still keeping in mind the non-associativity. </p>\n<p>Though this approach is flexible, one downside is that at some point or another you have to do some conversions between the two types of variables, which requires some thought and ends up being somewhat technical.</p>",
        "id": 571559990,
        "sender_full_name": "Mathias Stout",
        "timestamp": 1770086010
    }
]