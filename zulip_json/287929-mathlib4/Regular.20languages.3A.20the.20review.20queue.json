[
    {
        "content": "<p>As detailed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/24205\">#24205</a>, there's currently quite a mess of many PRs in the regular languages area of <code>Computability</code>, with some of the PRs overlapping each other. As <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> suggests, it would be good to discuss how to resolve this.</p>\n<p>The main goal these all center around is the equivalence between regular expressions and finite automata, as well as the related area of constructing automata corresponding to various operators on languages.</p>\n<p>Here's a list of PRs that somehow overlap one another:</p>\n<ul>\n<li>a series of PRs by <span class=\"user-mention\" data-user-id=\"712641\">@Tom Kranz</span> , that proves equivalence between REs and NFAs, avoiding the epsilon-NFA step:<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/15649\">#15649</a> (GNFAs, going NFA -&gt; GNFA -&gt; RE)</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/15651\">#15651</a> (NFA union, concatenation, Kleene's star, i.e. majority of the RE -&gt; NFA direction)</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/15654\">#15654</a> (the punchline: RE &lt;-&gt; NFA)</li>\n</ul>\n</li>\n<li>a PR by <span class=\"user-mention\" data-user-id=\"816552\">@Anthony DeRossi</span> which does RE -&gt; epsilon-NFA conversion <a href=\"https://github.com/leanprover-community/mathlib4/pull/20648\">#20648</a></li>\n<li>a PR by <span class=\"user-mention\" data-user-id=\"786070\">@Rudy Peterson</span> which implements NFA union, intersection and reversal <a href=\"https://github.com/leanprover-community/mathlib4/pull/22361\">#22361</a>, which overlaps:<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/15651\">#15651</a> by <span class=\"user-mention\" data-user-id=\"712641\">@Tom Kranz</span>, mentioned above, which also includes NFA union</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/21573\">#21573</a> by <span class=\"user-mention\" data-user-id=\"294142\">@Chris Wong</span>, which does NFA reversal (notably this PR already got approved, but has merge conflicts)</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/20238\">#20238</a> by <span class=\"user-mention\" data-user-id=\"814730\">@Mehmet Emre</span> , which does DFA complement and intersection</li>\n</ul>\n</li>\n</ul>\n<p>One key issue is the question: do we want to have e.g. intersection on both DFAs and NFAs? They show the same underlying facts about the class of regular languages, but they could have utility should one desire to put bounds on the number of states of an automaton...</p>\n<p>I'd be interested to hear your ideas on how to resolve this going forward!</p>",
        "id": 514669532,
        "sender_full_name": "Maja Kądziołka",
        "timestamp": 1745777290
    },
    {
        "content": "<p>I think that it makes sense to have operations on different types of automata, even if they have equal power in terms of languages. It would be nice if the authors of the competing PRs</p>\n<ul>\n<li>review each other's PRs;</li>\n<li>resolve differences in design choices, if any; feel free to tag me here with questions;</li>\n<li>reach the state where PRs are compatible with each other; </li>\n<li>tag me here with the list of relevant PRs in the order they should be reviewed. I'll try to find time to review them quickly.</li>\n</ul>",
        "id": 514673002,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1745779773
    },
    {
        "content": "<p>Okay. Then another issue is whether we want both the direct RE -&gt; NFA and the RE -&gt; eps-NFA constructions.</p>",
        "id": 514907026,
        "sender_full_name": "Maja Kądziołka",
        "timestamp": 1745875655
    },
    {
        "content": "<p>I think there is a reasonable conceptual distinction between the different constructions. Technically what one is proving is “given any RE, applying &lt;insert method name&gt;  transformation, one gets an equivalent automaton”</p>",
        "id": 514911011,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745877572
    },
    {
        "content": "<p>The equivalence claim can be separately expressed as “there exists a transformation such that for any RE …”</p>",
        "id": 514911584,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745877808
    },
    {
        "content": "<p>Having different constructions that lead to the same statement about languages is fine with me, as long as the constructions reference each other in their docs and explain the differences there.</p>",
        "id": 514915049,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1745879673
    },
    {
        "content": "<p>E.g., one can use them to transform specific regular expressions to automata.</p>",
        "id": 514915105,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1745879712
    },
    {
        "content": "<p>Regarding NFA reversal.</p>\n<ul>\n<li>I'm unfortunately really busy lately so don't have time to have a close look – it would be great if someone else could help with the merge conflict.</li>\n<li>From a cursory look at Rudy's approach, I prefer my one. The key differences are (a) the individual parts of the reversed NFA are defined separately, and (b) using Exists + Mem instead of Disjoint, and I don't consider those changes to be an improvement.</li>\n</ul>",
        "id": 515334207,
        "sender_full_name": "Chris Wong",
        "timestamp": 1746026729
    }
]