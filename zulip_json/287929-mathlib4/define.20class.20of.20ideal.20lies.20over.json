[
    {
        "content": "<p>Now we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/Ideal/Over.html#Ideal.Quotient.algebraQuotientOfLEComap\">Quotient.algebraQuotientOfLEComap</a> in mathlib, which states that if <code>S</code> is an <code>R</code>-algebra, <code>p</code> and <code>P</code> are ideals of <code>R</code> and <code>S</code> respectively, and <code>P</code> lies over <code>p</code>, then <code>R / p</code> is an <code>S / P</code>-algebra. However, this is a <code>def</code> rather than an <code>instance</code>, since during instance inference, conditions like <code>(h : p ≤ Ideal.comap f P)</code> are not searched for. This brings some difficulties in practice. For example, writing <code>(B ⧸ P) ≃ₐ[A ⧸ p] (B ⧸ P)</code> and <code>Module.Finite (A ⧸ p) (B ⧸ P)</code> results in errors.</p>\n<p>To solve it, my current idea is to define a <code>class</code> of lying over. Then we can write <code>(B ⧸ P) ≃ₐ[A ⧸ p] (B ⧸ P)</code> and <code>Module.Finite (A ⧸ p) (B ⧸ P)</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.RingTheory.Ideal.Over</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">ideal_lies_over</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">where</span><span class=\"w\"> </span><span class=\"n\">over</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Ideal.comap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">P</span>\n\n<span class=\"kd\">infix</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"s2\">\"lies_over\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ideal_lies_over</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ho</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">lies_over</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ideal.Quotient.algebraQuotientOfLEComap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_of_eq</span><span class=\"w\"> </span><span class=\"n\">ho.over</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower.of_algebraMap_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module.Finite</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module.Finite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Module.Finite.of_restrictScalars_finite</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is there a better way to solve it? Thanks!</p>",
        "id": 473609218,
        "sender_full_name": "Yongle Hu",
        "timestamp": 1727679241
    },
    {
        "content": "<p>In the FLT repo I demonstrate another solution (which I learnt from Amelia) which is basically just to add the assumption that S/P is an R/p algebra and also to add the IsScalarTower instances for R,R/p,S/P and R,S,S/P. Now you can <em>prove</em> that p is a subset of the pullback of P!</p>",
        "id": 474131850,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1727818559
    },
    {
        "content": "<p>That's a very clever idea! But the condition I need is <code>p = Ideal.comap (algebraMap A B) P</code>, so using this method, do I need to state <code>p = Ideal.comap (algebraMap A B) P</code> and <code>[Algebra (R ⧸ p) (S ⧸ P)] [IsScalarTower R (R ⧸ p) (S ⧸ P)]</code> at the same time?</p>",
        "id": 474162718,
        "sender_full_name": "Yongle Hu",
        "timestamp": 1727833579
    },
    {
        "content": "<p>I guess this would be one way out of the problem. Your <code>ideal_lies_over</code> solution looks interesting though. I am not really able to judge the relative merits of these approaches.</p>",
        "id": 474901162,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728076144
    }
]