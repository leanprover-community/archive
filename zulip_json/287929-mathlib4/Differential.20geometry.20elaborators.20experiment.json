[
    {
        "content": "<p>Differential geometry is known to be very heavy to manipulate in Mathlib. The first part is the type class proliferation.  ‚ÄúLet M be a manifold over a non-discrete normed field ùïú‚Äù is spelled</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Bundle</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Bundle</span><span class=\"w\"> </span><span class=\"n\">Manifold</span><span class=\"w\"> </span><span class=\"n\">ContDiff</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithTop</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"bp\">‚àû</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModelWithCorners</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ChartedSpace</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsManifold</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and ‚Äúlet V be a vector bundle over M‚Äù is spelled</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TotalSpace</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">FiberBundle</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">VectorBundle</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ContMDiffVectorBundle</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This has been discussed many times and one day Kyle will save us from this.</p>",
        "id": 527231675,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751663270
    },
    {
        "content": "<p>What I want to discuss today is the next step. Saying ‚Äúlet œÉ be a section of V‚Äù is very easy, this is what dependent type is all about: <code>(œÉ : Œ† x : M, V x)</code>. But then if we want to say <code>œÉ</code> is differentiable at <code>m : M</code> it becomes awful:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">MDifferentiableAt</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">ùìò</span><span class=\"o\">(</span><span class=\"n\">ùïú</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">TotalSpace</span><span class=\"bp\">.</span><span class=\"n\">mk'</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">m</span>\n</code></pre></div>\n<p>There are two issues here. First we need to turn <code>œÉ</code> into a function into the total space of <code>V</code>, and this total space need to be assigned a manifold structure. This is the job of <code>fun x ‚Ü¶ TotalSpace.mk' F x (œÉ x)</code> where <code>F</code> is needed to specify that the target is meant to be <code>TotalSpace F V</code>. It looks crazy because <code>TotalSpace F‚ÄØV</code>does not use <code>F</code> at all, but type class synthesis needs this dependence to endow <code>TotalSpace F V</code> with extra structure (I guess, I don‚Äôt know the details). </p>\n<p>Sometimes this <code>TotalSpace.mk'</code> also requires type annotations. For instance if <code>E</code> and <code>E'</code> are normed spaces we can form the trivial bundle <code>E √ó E'</code> and turn <code>s : E ‚Üí E'</code> into a function to the total space by</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TotalSpace</span><span class=\"bp\">.</span><span class=\"n\">mk'</span><span class=\"w\"> </span><span class=\"n\">E'</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TotalSpace</span><span class=\"w\"> </span><span class=\"n\">E'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Trivial</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">E'</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>before being able to say that <code>s</code> is differentiable in the manifold sense.</p>\n<p>Returning to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">MDifferentiableAt</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">ùìò</span><span class=\"o\">(</span><span class=\"n\">ùïú</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">TotalSpace</span><span class=\"bp\">.</span><span class=\"n\">mk'</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">m</span>\n</code></pre></div>\n<p>the second issue is the specification of the <code>ModelWithCorners</code>, <code>I</code> on the source and and <code>I.prod ùìò(ùïú, F)</code> on the target. Those are obviously what we mean here, but there is no way unification or instance synthesis can infer them from the type <code>M ‚Üí TotalSpace F V</code> of <code>(fun x ‚Ü¶ TotalSpace.mk' F x (œÉ x))</code> (and <code>m</code> has type <code>M</code>).</p>",
        "id": 527231768,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751663344
    },
    {
        "content": "<p>Again, there is no way our general elaboration mechanisms (unification and instance synthesis) can invent those parameters. But this is Lean 4, so if general elaboration is not enough, we can roll our own. The goal of this thread is to discuss experiments in this direction. Those experiments can be improved in many ways, but I‚ÄØfind them encouraging. They allow to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- info: MDifferentiableAt I (I.prod ùìò(ùïú, F)) fun x ‚Ü¶ TotalSpace.mk' F x (œÉ x) : M ‚Üí Prop -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">MDifferentiableAt</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- info: MDifferentiableAt I (I.prod ùìò(ùïú, E)) (fun m ‚Ü¶ TotalSpace.mk' E m (X m)) m : Prop -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">MDifferentiableAt</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">m</span>\n\n<span class=\"sd\">/-- info: MDifferentiableAt I I' f m : Prop -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">MDifferentiableAt</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">m</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">E'</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- info: MDifferentiableAt ùìò(ùïú, E) ùìò(ùïú, E') g : E ‚Üí Prop -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">MDifferentiableAt</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">g</span>\n</code></pre></div>",
        "id": 527231975,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751663550
    },
    {
        "content": "<p>The <code>T%</code> elaborator does the <code>TotalSpace.mk'</code> job, inferring <code>F</code> and implicit arguments without annotations.</p>",
        "id": 527232025,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751663594
    },
    {
        "content": "<p>The <code>MDifferentiableAt%</code> elaborator figures out the <code>ModelWithCorners</code> arguments.</p>",
        "id": 527232051,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751663623
    },
    {
        "content": "<p>The effect on a random file from the covariant derivative wip can be seen at <a href=\"https://github.com/grunweg/mathlib4/commit/52a89f0da0f087d1b0f96927c11af8da23924fd8\">https://github.com/grunweg/mathlib4/commit/52a89f0da0f087d1b0f96927c11af8da23924fd8</a></p>",
        "id": 527232116,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751663669
    },
    {
        "content": "<p>The elaborators and more tests can be seen at <a href=\"https://github.com/grunweg/mathlib4/commit/4ec3b0f6048e877f88b821439d10d8c8da6ef72a\">https://github.com/grunweg/mathlib4/commit/4ec3b0f6048e877f88b821439d10d8c8da6ef72a</a></p>",
        "id": 527232212,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751663775
    },
    {
        "content": "<p>The core function is <code>find_model (e : Expr) (baseInfo : Option (Expr √ó Expr) := none) : TermElabM Expr</code> which tries to find a <code>ModelWithCorners</code> for some given type <code>e</code>. The algorithm (which could easily be made extensible) is currently</p>\n<ul>\n<li>if <code>e</code> matches <code>TotalSpace F V</code> for some <code>F</code> and <code>V</code><br>\n       * if <code>V</code>matches <code>TangentSpace I‚ÄØx</code>for some <code>I</code> and <code>X</code> then return <code>I.prod I.tangent</code><br>\n       * otherwise do something I skip for simplicity</li>\n<li>start looping over the local context<br>\n       * if we <code>ChartedSpace H e</code> then remember who is <code>H</code> (and stop the loop)<br>\n       * if we see <code>NormedSpace K e</code> then remember who is <code>K</code> (and stop the loop)</li>\n<li>if we found some <code>K</code> then return <code>ùìò(K, e)</code></li>\n<li>if we found some <code>H</code>start a new loop on the local context to find some <code>ModelWithCorners _ e H</code> and return it</li>\n<li>if everything else failed, try synthesizing a normed field instance for <code>e</code> and return the corresponding model over itself.</li>\n</ul>",
        "id": 527232729,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751664317
    },
    {
        "content": "<p>Note how almost all those checks are purely syntactical. Only the last thing tried is using instance synthesis. So hopefully this is fast enough. And in the worst case scenario those elaborators could trigger a code action to replace them with explicit terms.</p>",
        "id": 527232977,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751664566
    },
    {
        "content": "<p>Last remarks: </p>\n<ul>\n<li>the <code>%</code> in the notation is only a convention for elaborator, any syntax can do</li>\n<li>those elaborators do not prevent anyone from writing direct calls to <code>MDifferentiableAt</code> and friends.</li>\n</ul>",
        "id": 527233100,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751664670
    },
    {
        "content": "<p>Now the question to <span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span>, <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>, <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>, <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>, <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> and everybody interested in differential geometry in Mathlib is: do we want to push in this direction?</p>",
        "id": 527233189,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751664746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Differential.20geometry.20elaborators.20experiment/near/527231768\">said</a>:</p>\n<blockquote>\n<p>What I want to discuss today is the next step. Saying ‚Äúlet œÉ be a section of V‚Äù is very easy, this is what dependent type is all about: <code>(œÉ : Œ† x : M, V x)</code>. But then if we want to say <code>œÉ</code> is differentiable at <code>m : M</code> it becomes awful:</p>\n</blockquote>\n<p>FYI: there is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContMDiffSection#doc\">docs#ContMDiffSection</a>.</p>",
        "id": 527236061,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1751668202
    },
    {
        "content": "<p>This is only for globally smooth sections.</p>",
        "id": 527236196,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751668340
    },
    {
        "content": "<p>fair</p>",
        "id": 527236227,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1751668375
    },
    {
        "content": "<p>It's an interesting direction to use such elaborators. It definitely looks a lot nicer!</p>\n<p>For the problem of specifying the <code>ModelWithCorners</code>, I'm wondering if there is some approach using classes (+ outParams?) to maybe not specify the model with corners every time, since usually the model with corners is unique. But term elaborators are probably more flexible, since it does allow you to specify the model with corners if you want.</p>\n<p>I think your current approach is a reasonable to pursue.</p>",
        "id": 527236458,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1751668705
    },
    {
        "content": "<p>AFAIR, the main reason we can't rely on typeclasses to find the model with corners is that <code>E \\x F</code> has two candidates: <code>ùìò(ùïú, _)</code> and <code>(ùìò(ùïú, E)).prod (ùìò(ùïú, F)</code>. It would be nice to have some \"do the right thing in most cases, allow overriding as needed\" way to deal with it.</p>",
        "id": 527237652,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1751670278
    },
    {
        "content": "<p>I agree that the elaborators look great, and that they're definitely worth pursuing.</p>\n<p>I had some tried ago another idea: make <code>I</code> an outparam. For that, one should solve the product issue by forgetful inheritance, i.e., embed in every topological space a charted space structure over itself. I consider this as a failed argument, but you can have a look at the branch at <a href=\"https://github.com/leanprover-community/mathlib4/pull/26776\">#26776</a>. This is not obvious to implement because a charted space structure involves partial homeos, which are already defined using a topology. So I used an auxiliary class <code>TopologicalSpaceWithoutAtlas</code>, built just enough topology with it to be able to define an atlas, and then defined <code>TopologicalSpace</code> on top of it. </p>\n<p>Most things work (painfully) once this is done, but I encountered an issue with fiber bundles. Our current definition for a fiber bundle <code>E -&gt; B</code> is that it should have a charted space structure over <code>B x F</code>, where <code>F</code> is a model for the fiber. And once <code>B</code> has a charted space structure over some <code>H</code>, then this is automatically transported to a charted space structure over <code>H x F</code> (well, more precisely <code>ModelProd H F</code> in the current implementation). With the new framework, as <code>B</code> has a charted space structure over itself, then the fiber bundle charted space structure over <code>B x F</code> is automatically transported (among others) to a new charted space structure over <code>B x F</code> which is <em>not</em> defeq to the previous one, and boom, diamond. I solved it in the PR by requiring in the definition of a fiber bundle <code>E -&gt; B</code> that it should have a charted space structure over <code>ModelProd B F</code>, which is then automatically transported (among others) to a charted space structure over <code>B x F</code>, solving the diamond.</p>\n<p>This works, but I'm not sure how much of a gain this is compared to the current situation: we can make <code>I</code> an outparam, but the definition of topological spaces is more complicated (which is a pain in many places) and we still need <code>ModelProd</code> anyway. So I don't think it's worth pursuing, but I thought I should mention it as a failed experiment.</p>",
        "id": 527262536,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1751702294
    },
    {
        "content": "<p>Do I understand correctly that we could use your elaborator as a notation? I feel that <code>MDifferentiableAt%</code> looks a little bit weird, but if instead we use a notation like <code>MDiffAt f x</code> (scoped in <code>Manifold</code>) this would feel completely standard. And we could add all the variants <code>MDiff f</code>, <code>MDiff[s] f</code> (for <code>MDifferentiableOn I J f s</code>), <code>MDiffAt f x</code>, <code>MDiffAt[s] f x</code>, and also <code>CMDiff n f</code>, <code>CMDiff[s] n f</code>, <code>CMDiffAt n f x</code>, <code>CMDiffAt[s] n f x</code> for coherence and completeness. (If you have better notation ideas, it's even better)</p>",
        "id": 527274219,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1751716084
    },
    {
        "content": "<p>Yes, as I wrote earlier, the <code>%</code> sign seems to be a tradition for elaborators, but it has no technical necessity. We can switch to your notation very easily.</p>",
        "id": 527275585,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751717403
    },
    {
        "content": "<p>Do you have a suggestion for the <code>T%</code> elaborator?</p>",
        "id": 527275690,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751717519
    },
    {
        "content": "<p>No good idea for <code>T%</code> on my side. <code>total</code> would work, but it's not really self-explanatory, and it's longer than <code>T%</code>.</p>",
        "id": 527276348,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1751718262
    },
    {
        "content": "<p>Small detail: the new delaborators don't pretty-print as they should, so the commandStart linter complains about them. Is probably not hard to fix.</p>",
        "id": 528035078,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1752138890
    },
    {
        "content": "<p>Can you point me to a commit which oleans, so that I can take a look?</p>",
        "id": 528035216,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1752138929
    },
    {
        "content": "<p>If the doc-string of the notation also contains how you would like it to print, that makes it easier to figure out what should happen!</p>",
        "id": 528035295,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1752138955
    },
    {
        "content": "<p>I made a PR with these elaborators at <a href=\"https://github.com/leanprover-community/mathlib4/pull/27021\">#27021</a>: as this blocks most of the remaining work in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26221\">#26221</a>, I'm arguing it's useful to land this now, with a clear label \"experimental\" and a promise to clean this up in the future.</p>",
        "id": 528442615,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1752309287
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Would one of you like to take a look?</p>",
        "id": 528442636,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1752309305
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Differential.20geometry.20elaborators.20experiment/near/528035216\">said</a>:</p>\n<blockquote>\n<p>Can you point me to a commit which oleans, so that I can take a look?</p>\n</blockquote>\n<p>Thanks! <a href=\"https://github.com/leanprover-community/mathlib4/pull/26221\">#26221</a> builds (CI fails because there are sorries). The doc-strings should contain the expected formatting now. One example of a linter error is in <code>VectorBundle/GramSchmidtOrtho.lean</code>.</p>",
        "id": 528443152,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1752309818
    },
    {
        "content": "<p>One question that came up: how can one scope these elaborators to the <code>Manifold</code> namespace? I tried the obvious things <code>elab[Manifold]:max</code> and <code>elab:max[Manifold</code>, but neither worked.</p>",
        "id": 528443293,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1752309964
    },
    {
        "content": "<p><code>scoped[Manifold] elab ...</code> is the christened syntax, but if it doesn't work then <code>namespace Manifold elab ... end Manifold</code> should definitely work</p>",
        "id": 528443433,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1752310119
    },
    {
        "content": "<p>Thanks for the extremely quick answer <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span> <code>scoped[Manifold] elab</code> didn't work, but putting it inside <code>namespace Manifold</code> did.</p>",
        "id": 528443896,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1752310595
    },
    {
        "content": "<p>It would be great to get <code>scoped[Manifold] elab</code> fixed. I don't remember the full story, but I believe <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> does</p>",
        "id": 528443981,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1752310682
    },
    {
        "content": "<p>See also <a href=\"#narrow/channel/287929-mathlib4/topic/scoped.5BNS.5D.20doesn't.20work.20with.20syntax\">#mathlib4 &gt; scoped&#91;NS&#93; doesn't work with syntax</a></p>",
        "id": 529238331,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1752744624
    },
    {
        "content": "<p>I just added a new pair of very similar elaborators: <code>mfderiv% f</code> expands to <code>mfderiv I J f</code>, and <code>mfderiv[s] f</code> expands to <code>mfderivWithin I J f s</code>. Better naming suggestions, particularly for the first one, are very welcome!</p>",
        "id": 529283908,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1752760187
    },
    {
        "content": "<p>Probably because I am newish to Lean but I found it picking instances (in differential geometry) that I didn't want it to. Eventually I gave up with having to write e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">IsManifold</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ùì°</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"n\">S1</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">S1</span><span class=\"bp\">.</span><span class=\"n\">chartedSpace</span>\n</code></pre></div>\n<p>and defined a new data type wrapping the entity in which I was interested:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MobiusBase</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Metric</span><span class=\"bp\">.</span><span class=\"n\">sphere</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">S1</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">point</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MobiusBase</span>\n</code></pre></div>\n<p>and now I am in full control.</p>\n<p>I have no idea whether this the right approach but it seems to be working in that I have no unpleasant surprises.</p>\n<p>I can't help feeling that although this initiative makes things simpler in some ways, a new user such as myself might not realise what was happening under the covers.</p>",
        "id": 534185619,
        "sender_full_name": "Dominic Steinitz",
        "timestamp": 1755075122
    },
    {
        "content": "<p>I‚Äôm afraid we don‚Äôt have enough context to help you here. Could you write a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 534747717,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1755331739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Differential.20geometry.20elaborators.20experiment/near/534747717\">said</a>:</p>\n<blockquote>\n<p>I‚Äôm afraid we don‚Äôt have enough context to help you here. Could you write a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>\n</blockquote>\n<p>Yes I am working on one which will be a blog post but don't hold your breath.</p>",
        "id": 535345826,
        "sender_full_name": "Dominic Steinitz",
        "timestamp": 1755705360
    },
    {
        "content": "<p>At <span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> 's request, let me bring <a href=\"https://github.com/leanprover-community/mathlib4/pull/27021\">#27021</a> on the agenda again: in the past weeks, that PR has seen some amount of polish, including extended documentation and tests and improvements to robustness and error messages.</p>\n<p>Is there anything blocking the landing of this PR, to start experimentation? (This does block much of the Levi-Civita connection work, for example --- as un-doing the use of the elaborators to re-do them later would be a massive waste of time.)</p>",
        "id": 542317556,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759248906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> has been reviewing much of the meta code (in person). Which of these changes we discussed do you insist on happening before a first merge? (The code has clear warnings about being not polished yet.)</p>",
        "id": 542317652,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759248940
    },
    {
        "content": "<p>I've written on the PR that I will merge it in one week if nobody with meta expertise shows up in between, because I consider the extensive test coverage a proof that it's working well.</p>",
        "id": 542319034,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1759249323
    },
    {
        "content": "<p>I can give this (another) review, if it's desired. :) (Am I interpreting correctly that you would <em>like</em> someone to show up within one week? <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span>)</p>\n<p>My understanding is that the intended design is finalized and agreed-upon, and a review ought to be targeted at the meta code and implementation. Is that right? (Or, what specifically would be helpful for a meta-focused review to consider?)</p>",
        "id": 542568749,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1759347093
    },
    {
        "content": "<p>Yes, that's perfectly right.</p>",
        "id": 542569452,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1759347386
    },
    {
        "content": "<p>I can confirm: the general design works well --- if you see a completely new way to do this, I'm very happy to hear about it <em>after</em> merging a first version.</p>",
        "id": 542576204,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759350226
    },
    {
        "content": "<p>Also: thanks a <em>lot</em> for volunteering to review this PR! The diff is huge, but that's because most of it are tests.</p>",
        "id": 542673223,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759390741
    },
    {
        "content": "<p>I'm checking the implementation of the algorithm, and I'd like to clarify something about this part of it:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Differential.20geometry.20elaborators.20experiment/near/527232729\">said</a>:</p>\n<blockquote>\n<ul>\n<li>if we found some <code>H</code>start a new loop on the local context to find some <code>ModelWithCorners _ e H</code> and return it</li>\n<li>if everything else failed, try synthesizing a normed field instance for <code>e</code> and return the corresponding model over itself.</li>\n</ul>\n</blockquote>\n<p>If we find an <code>H</code>, but then fail to find a <code>ModelWithCorners</code>, should we still try to synthesize a normed field instance, or just fail? (Currently, we just fail; I suspect we might want to try synthesizing a normed field instance instead!)</p>",
        "id": 542775597,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1759419855
    },
    {
        "content": "<p>By the way, just as a progress update here:</p>\n<p>My suggested changes for this PR will be mostly straightforward‚Äîrefactoring for readability/maintainability of meta code, fixing metaprogramming gotchas/implementation details, and fixing typos/style.</p>\n<p>However, there are a decent number of such changes, and many of the straightforward changes span many lines (e.g. because they change some approach in a uniform way, such as changing <code>PrettyPrinter.delab</code> to <code>Term.exprToSyntax</code>).</p>\n<p>There were also a small number of significant fixes/refactors necessary: for example, care needs to be taken with <code>TermElabM</code> in <code>findModel</code> when attempting multiple successive elaborations, and the <code>for</code> loops ought to be replaced with a different (simpler) approach for finding instances and local declarations. (I take the opportunity to improve tracing slightly when refactoring <code>findModel</code>, but otherwise do not add any features.)</p>\n<p>It is a bit unconventional for a review, but given that the GitHub review interface is a bit awkward for making large suggestions, I think the most convenient thing to do here is for me to:</p>\n<ol>\n<li>open a PR to your branch, where each commit is a single suggested change</li>\n<li>add review comments explaining each suggested change and linking to the corresponding commit in that PR which performs it.</li>\n</ol>\n<p>I'll submit the comments all at once when I'm finished. :) (I may open the PR to your branch as a draft before that, but please feel free to ignore it until I've completed the actual review.)</p>\n<p>I'm planning to look over documentation and stress-test the test coverage tomorrow; with the code itself mostly fully reviewed now, I'm hoping to finish the review tomorrow or this weekend. The test file looks great, though, so I don't expect to find any issues! :)</p>",
        "id": 542863468,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1759463573
    },
    {
        "content": "<p>Also, to get into something specific: the reason the <code>MDiffAt2</code> elaborator fails is because we run <code>findModel</code> on the fvar <code>src : M</code> introduced by <code>forallBoundedTelescope</code>, when we should be running it on the type of <code>src</code>!</p>\n<p>However, <code>MDiffAt2</code> actually appears a bit <em>less</em> robust to me: it seems to allow the fvar introduced by <code>forallBoundedTelescope</code> to be picked up by <code>findModel</code> (potentially, though this would be unusual), and we do not check that it is absent from the result (or abstract it). Is there an example where the (rest of the) approach of <code>MDiffAt2</code> would be expected to succeed but <code>MDiffAt</code> wouldn't?</p>",
        "id": 542868216,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1759467602
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Differential.20geometry.20elaborators.20experiment/near/542863468\">said</a>:</p>\n<blockquote>\n<p>By the way, just as a progress update here:</p>\n<p>My suggested changes for this PR will be mostly straightforward‚Äîrefactoring for readability/maintainability of meta code, fixing metaprogramming gotchas/implementation details, and fixing typos/style.</p>\n<p>However, there are a decent number of such changes, and many of the straightforward changes span many lines (e.g. because they change some approach in a uniform way, such as changing <code>PrettyPrinter.delab</code> to <code>Term.exprToSyntax</code>).</p>\n<p>There were also a small number of significant fixes/refactors necessary: for example, care needs to be taken with <code>TermElabM</code> in <code>findModel</code> when attempting multiple successive elaborations, and the <code>for</code> loops ought to be replaced with a different (simpler) approach for finding instances and local declarations. (I take the opportunity to improve tracing slightly when refactoring <code>findModel</code>, but otherwise do not add any features.)</p>\n<p>It is a bit unconventional for a review, but given that the GitHub review interface is a bit awkward for making large suggestions, I think the most convenient thing to do here is for me to:</p>\n<ol>\n<li>open a PR to your branch, where each commit is a single suggested change</li>\n<li>add review comments explaining each suggested change and linking to the corresponding commit in that PR which performs it.</li>\n</ol>\n<p>I'll submit the comments all at once when I'm finished. :) (I may open the PR to your branch as a draft before that, but please feel free to ignore it until I've completed the actual review.)</p>\n<p>I'm planning to look over documentation and stress-test the test coverage tomorrow; with the code itself mostly fully reviewed now, I'm hoping to finish the review tomorrow or this weekend. The test file looks great, though, so I don't expect to find any issues! :)</p>\n</blockquote>\n<p>Thanks a lot, that sounds very promising. A PR into the PR branch works very well!</p>",
        "id": 542913470,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759486688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Differential.20geometry.20elaborators.20experiment/near/542868216\">said</a>:</p>\n<blockquote>\n<p>Also, to get into something specific: the reason the <code>MDiffAt2</code> elaborator fails is because we run <code>findModel</code> on the fvar <code>src : M</code> introduced by <code>forallBoundedTelescope</code>, when we should be running it on the type of <code>src</code>!</p>\n<p>However, <code>MDiffAt2</code> actually appears a bit <em>less</em> robust to me: it seems to allow the fvar introduced by <code>forallBoundedTelescope</code> to be picked up by <code>findModel</code> (potentially, though this would be unusual), and we do not check that it is absent from the result (or abstract it). Is there an example where the (rest of the) approach of <code>MDiffAt2</code> would be expected to succeed but <code>MDiffAt</code> wouldn't?</p>\n</blockquote>\n<p>Good question. I learned that using <code>forallBoundedTelescope</code> is apparently better, but cannot yet detail why - so let me pass this question on:<br>\n<span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> You strongly felt that <code>MDiffAt</code> was not a robust approach. Can you elaborate and perhaps answer this question? Thanks!</p>",
        "id": 542913791,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759486795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Differential.20geometry.20elaborators.20experiment/near/542775597\">said</a>:</p>\n<blockquote>\n<p>I'm checking the implementation of the algorithm, and I'd like to clarify something about this part of it:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Differential.20geometry.20elaborators.20experiment/near/527232729\">said</a>:</p>\n<blockquote>\n<ul>\n<li>if we found some <code>H</code>start a new loop on the local context to find some <code>ModelWithCorners _ e H</code> and return it</li>\n<li>if everything else failed, try synthesizing a normed field instance for <code>e</code> and return the corresponding model over itself.</li>\n</ul>\n</blockquote>\n<p>If we find an <code>H</code>, but then fail to find a <code>ModelWithCorners</code>, should we still try to synthesize a normed field instance, or just fail? (Currently, we just fail; I suspect we might want to try synthesizing a normed field instance instead!)</p>\n</blockquote>\n<p>Good question! Indeed, the current code is not maximally robust, in several aspects:</p>\n<ul>\n<li>if there are several ChartedSpace instances on <code>M</code>, involving different types <code>H</code>, we currently just pick the first one. (There may be situations where we want the second one. Say, about a complex manifold also being regarded as a real manifold, or so. I can construct a test if needed, though that'll be a bit onerous.)</li>\n<li>if there is a ChartedSpace instance on <code>H</code>, but no matching model in sight... I'd need to think if/when this can happen (we should have a test, though perhaps this could be added after the initial version). I can imagine looking for a normed field instance being helpful.</li>\n</ul>",
        "id": 542915801,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759487581
    },
    {
        "content": "<p>Just to check, is <code>T%</code> intended to be scoped to the <code>Manifold</code> namespace? (I'm checking the module docstring, and it seems to only say the differentiability elaborators are scoped.)</p>",
        "id": 543114563,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1759609535
    },
    {
        "content": "<p>Yes, it is. (That module doc-string should be fixed, and the <code>T%</code> elaborator scoped if it isn't already.)</p>",
        "id": 543117007,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759612104
    },
    {
        "content": "<p>Sounds good, I'll fold that into my suggestions. :)</p>",
        "id": 543117073,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1759612212
    },
    {
        "content": "<p>Thanks a lot for your thorough review! I just have two small questions. Otherwise, I merged your PR (and will deal with the last two requests tonight).</p>",
        "id": 543385789,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759776002
    },
    {
        "content": "<p>Let me start a bikeshed about the first one already: are there strong opinions where the elaborators should live? (The current proposal is <code>Mathlib.Geometry.Manifold.Elaborators</code>, but this would be the first module in mathlib called <code>Elaborators</code>.)</p>",
        "id": 543385910,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759776049
    },
    {
        "content": "<p>some other options: <code>Notation</code> or <code>Elab</code></p>",
        "id": 543386229,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759776179
    },
    {
        "content": "<p>we already have <code>Mathlib.Order.Notation</code> which does some delaborating and adds some macros</p>",
        "id": 543386557,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759776286
    },
    {
        "content": "<p>and looking further, there's a bunch more <code>Notation</code> files. I don't think that the difference between notation created implemented as a macro and notation implemented by an elaborator are too different.</p>",
        "id": 543386964,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759776426
    },
    {
        "content": "<p>all to say, I'd be in favor of just naming it <code>Notation</code></p>",
        "id": 543387004,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1759776446
    },
    {
        "content": "<p><code>Notation</code> sounds good to me too, especially since delaborators are intended via <code>TODO</code>. :) Thanks for finding the precedent!</p>",
        "id": 543388817,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1759777124
    },
    {
        "content": "<p>All review comments are now addressed; there is one last issue (which is a question of differential geometry, not metaprogramming).</p>\n<p>Given a function on the total space of a tangent bundle, what's the correct way to talk about its smoothness? (More specifically, if <code>M</code> is a manifold over <code>I</code> and <code>h: Bundle.TotalSpace F (TangentSpace I : M ‚Üí Type _) ‚Üí F</code>; right now <code>MDiff h</code> does not type-check, and indeed probably shouldn't. But what's the correct way to say \"a function from the tangent bundle to another manifold is smooth\"?</p>",
        "id": 543435206,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759804791
    },
    {
        "content": "<p>And there is a follow-up question by Thomas:</p>\n<blockquote>\n<p>Hmm, relatedly, I notice that <code>TangentBundle</code> is an <code>abbrev</code> for <code>Bundle.TotalSpace _ (TangentSpace _)</code>. Should <code>findModel</code> see <code>TangentBundle</code> as a <code>Bundle.TotalSpace</code>, or handle it as a separate case (or not handle it)? If the former, then we should use <code>match_expr ‚Üê whnfR e with</code> in <code>fromTotalSpace</code> to unwrap <code>TangentBundle</code>. But if it has separate instances, it might make sense to handle it as a separate case if at all (presumably in a subsequent PR!).</p>\n</blockquote>\n<blockquote>\n<p>This is a question of the algorithm's spec, so I'll defer to those with greater library knowledge in this area. :)</p>\n</blockquote>",
        "id": 543435254,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759804831
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> This is touching parts of mathlib's differential geometry that you probably know better than me, so your opinion would be most welcome!</p>",
        "id": 543435281,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759804861
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Differential.20geometry.20elaborators.20experiment/near/543435206\">said</a>:</p>\n<blockquote>\n<p>But what's the correct way to say \"a function from the tangent bundle to another manifold is smooth\"?</p>\n</blockquote>\n<p>The tangent bundle is just a manifold in the usual sense, with the model with corners <code>I.tangent</code> (which is just an abbrev for <code>I.prod ùìò(ùïú, E)</code>). So, to say that a function <code>f</code> from the tangent bundle is differentiable, you would just say <code>MDifferentiable I.tangent J f</code>, as usual.</p>",
        "id": 543450586,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1759817389
    },
    {
        "content": "<p>Thanks, that was reassuring.</p>",
        "id": 543570522,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759853191
    },
    {
        "content": "<p>From my side, the PR is now ready for review (and probably, merging).</p>",
        "id": 543570557,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759853205
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> If you like a puzzle, you can join me in <a href=\"https://github.com/leanprover-community/mathlib4/pull/30307\">#30307</a>, debugging why the extension I made to the elaborator does not fire. (There's a coercion <code>PartialEquiv</code> to functions. My very vague guess: that is not applied because the custom elaborator forgot to do this?)</p>",
        "id": 543600935,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759862961
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> Ping: all review comments are fully addressed; I consider the PR ready for merging.</p>",
        "id": 543646982,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759887964
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/30307\">#30307</a> is now ready for review: it allows the elaborators to apply to anything which coerces to functions (including partial homeomorphisms (e.g., charts), partial equivalences (e.g., extended charts) and bundled smooth sections).</p>",
        "id": 543810596,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759948219
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/28032\">#28032</a> builds on top of that one and adds support for inferring the model with corners on a <code>TangentBundle</code>, as well as a few more tests.</p>",
        "id": 543828175,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759955064
    },
    {
        "content": "<p>Great! :D I‚Äôll review these today. :)</p>",
        "id": 543961295,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1760016703
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/30307\">#30307</a> has been approved by Thomas . Would a maintainer like to take a look? <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> <span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> It's a small, well-tested and uncontroversial addition to the linters. (For another data point, I have tested this on almost all of mathlib in <a href=\"https://github.com/leanprover-community/mathlib4/pull/30357\">#30357</a> and not found any issues.)</p>",
        "id": 544073144,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760060831
    },
    {
        "content": "<p>Current status update: the past week has seen some significant activity on the elaborators. There are now in-flight PRs which add new elaborators (e.g. <code>HasMFDeriv(Within)At</code>), support coercions, and adds support for inferring the model with corners in more cases. ##30357 shows that this can be used to golf mathlib's differential geometry library significantly.</p>",
        "id": 544540921,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760358865
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/30503\">#30503</a> tracks the overall progress and missing features</p>",
        "id": 544540967,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760358879
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> has been reviewing these PRs, but cannot merge them. A maintainer's look is appreciated. Right now, these PRs are a linear sequence (also to avoid conflicts).</p>",
        "id": 544541110,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760358919
    },
    {
        "content": "<p>The first PR is <a href=\"https://github.com/leanprover-community/mathlib4/pull/30307\">#30307</a>, supporting coercions: I consider this ready to go.</p>",
        "id": 544541344,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760358965
    },
    {
        "content": "<p>The next PR in the sequence is <a href=\"https://github.com/leanprover-community/mathlib4/pull/28032\">#28032</a>, adding support for inferring the model with corners in a few more cases, and making a few clean-ups to style, tracing messages and tests. +200/-84 lines; Thomas already approved this.</p>",
        "id": 544936693,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760525781
    },
    {
        "content": "<p>Here's a design question for this thread: an in-progress PR of mine also infers the model with corners on a product. Given a product of normed spaces, there are two possible models to infer, either <code>ùìò(ùïú, E √ó F)</code> on <code>E √ó F</code>, or <code>ùìò(ùïú, E).prod ùìò(ùïú, F)</code> on <code>ModelProd E F</code> (which is defined to be <code>E </code>√ó F`). What should the elaborators do in this case?</p>",
        "id": 544942546,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760527585
    },
    {
        "content": "<p>(a) try to respect this decision, and infer the right model depending on whether it's a ModelProd or a product? (Might be tricky, given the elaborator otherwise checks for equivalence of types up to defeq.)</p>",
        "id": 544942693,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760527631
    },
    {
        "content": "<p>(b) in such cases, do not infer a model for now and print a message stating this (This is the most conservative option)</p>",
        "id": 544942792,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760527663
    },
    {
        "content": "<p>(c) Always infer the former model --- and change mathlib to never use statements about the latter. (Indeed, there is only one lemma in mathlib involving the latter, and that lemma is only used 12 times. So this might be feasible.) Put differently, writing the elaborators this way would enforce that most lemmas only use the former model (and single out any other examples as different).</p>",
        "id": 544943479,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760527893
    },
    {
        "content": "<p>(d) Something else, such as having an option to control which model is inferred.</p>",
        "id": 544943512,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760527908
    },
    {
        "content": "<p>What do you think? <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>?</p>",
        "id": 544943586,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760527931
    },
    {
        "content": "<p>You get the latter model, e.g., if you specialize a lemma about <code>ModelProd</code> to normed spaces. We can't totally get rid of it. As a minimum, we need <code>Iff</code>/<code>Eq</code>/<code>Diffeomorphism</code> lemmas/defs saying that the two models are equivalent.</p>",
        "id": 544944720,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1760528306
    },
    {
        "content": "<p>Sure! We do have one lemma like this.</p>",
        "id": 544944863,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760528357
    },
    {
        "content": "<p>My question about option (c) is: do we want any lemmas in mathlib to be stated in terms of the latter model, or should we have a rule \"lemmas are always stated about the former, and if you option the latter (e.g. by specialisation), you must rewrite into the former immediately\"?</p>",
        "id": 544944992,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760528400
    },
    {
        "content": "<p>I think that we shouldn't use the latter model except for lemmas/defs saying that it's equivalent to the former model.</p>",
        "id": 544945924,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1760528701
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"634338\">@Michael Rothgang</span> I'm not sure you summoned the right Sebasti[ae]n here!</p>",
        "id": 544950512,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1760529868
    },
    {
        "content": "<p>I don't think you can really do (a), because the model space can typically not be inferred from the context. I wouldn't do (c), because it doesn't seem to me that one model is really more natural than the other -- even more, I'd say that \"(c'): inferring <code>ùìò(ùïú, E).prod ùìò(ùïú, F)</code>\" is maybe more natural, because this is what should be inferred for all product manifolds, and special casing vector spaces is bound to create a mess. So I'd go either for (c') or for (b).</p>",
        "id": 544952575,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1760530518
    },
    {
        "content": "<p>Indeed, that was an auto-complete failure. I meant S√©bastien.</p>",
        "id": 544963546,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760533619
    },
    {
        "content": "<p>Thanks for all the comments so far. Let me summarize the options:<br>\n(b) conservative (and easy to implement); not the best long-term solution<br>\nDo not infer a model on a product of normed spaces and print a message stating this. This is annoying, but it could (presumably) be made to print the possible options, so users could still write the elaborator first and then get the right suggestion.<br>\n(c') Always infer <code>ùìò(ùïú, E).prod ùìò(ùïú, F)</code>, because this is what you get when specialising a theorem for product manifolds.</p>\n<hr>\n<p>Not good options<br>\n(a) try to guess which product is wanted (e.g., depending on whether it's a ModelProd or a product). Seems not possible in practice.<br>\n(c) Always infer <code>ùìò</code>(ùïú, E √ó F)` and require all mathlib lemmas to be stated this way<br>\nCon: there's no clear reason one model is more natural --- one might even argue the other one is better.</p>",
        "id": 544964836,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760533940
    },
    {
        "content": "<p>I trust <span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> 's judgement more than mine here, so please disregard my comment above.</p>",
        "id": 544965322,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1760534069
    },
    {
        "content": "<p>Barring further comments, I suggest to do first (b) and (c'): implementation-wise, it's good to iron out all the kinks and unexpected bugs around products before attempting this case where failures could truly be informational. Once that part works well, I'll try (c') and see how it goes.</p>",
        "id": 544965388,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760534086
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/30412\">#30412</a> is the next PR in the sequence: its diff is somewhat large (+-350-400 lines), but very simple: it just splits the test file in two.</p>",
        "id": 544970800,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760535370
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/30577\">#30577</a> is now ready for review: it adds a test for something that should clearly work (and already works)</p>",
        "id": 545243738,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760607916
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/30413\">#30413</a> is a more substantial change: it adds elaborators for <code>HasMFDeriv{Within}At</code>, and supports finding a model with corners in a few more cases. Adds about 50 lines of meta code, and 280 lines of tests.</p>",
        "id": 545248370,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1760608693
    }
]