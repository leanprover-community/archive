[
    {
        "content": "<p>Hi all, consider we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"n\">Monoid.End</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">statement_on_product</span> <span class=\"o\">:</span> <span class=\"n\">some_prop</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">*</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Now if I add <code>@[to_additive]</code> to the theorem,  Lean complains that there is not a <code>AddMonoid.End.instMonoidEnd</code> (for good reason as we always want endormporphisms to be in multiplicative notation.)</p>\n<p>I glanced over <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ToAdditive#doc\">docs#ToAdditive</a> but I'm still not sure how to fix this without defining the additive version separately.<br>\nDoes it have something to do with the particularity of my <code>some_prop</code>?<br>\nThanks!</p>",
        "id": 425500719,
        "sender_full_name": "Qi Ge",
        "timestamp": 1709897730
    },
    {
        "content": "<p>Yes that's because <code>Monoid.End</code> is not addivised to <code>AddMonoid.End</code></p>",
        "id": 425501728,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709898164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60to_additive.60.20and.20Product/near/425501728\">said</a>:</p>\n<blockquote>\n<p>Yes that's because <code>Monoid.End</code> is not addivised to <code>AddMonoid.End</code></p>\n</blockquote>\n<p>So can I tell Lean to \"not addivise\" <code>σ * τ</code>?</p>",
        "id": 425502179,
        "sender_full_name": "Qi Ge",
        "timestamp": 1709898356
    },
    {
        "content": "<p>Currently not, sadly. <code>to_additive</code> is a big machinery and it is difficult to extend it</p>",
        "id": 425502370,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709898440
    },
    {
        "content": "<p>Here you are hitting the fact that we want some concrete types to be translated but not their operations.</p>",
        "id": 425502514,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709898487
    },
    {
        "content": "<p>There are also some concrete types that we don't want to be translated, eg <code>ℕ</code></p>",
        "id": 425502550,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709898500
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>, thoughts?</p>",
        "id": 425502620,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709898520
    },
    {
        "content": "<p>Does additivization really make much sense here?</p>",
        "id": 425510420,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709901581
    },
    {
        "content": "<p>This isn't about converting <code>*</code> to <code>+</code>, so I think it's out of scope; you could just as well ask for this on <code>Module.End</code> etc</p>",
        "id": 425510529,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709901615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60to_additive.60.20and.20Product/near/425510529\">said</a>:</p>\n<blockquote>\n<p>This isn't about converting <code>*</code> to <code>+</code>, so I think it's out of scope; you could just as well ask for this on <code>Module.End</code> etc</p>\n</blockquote>\n<p>Well it's about converting <code>Monoid.End G</code> to <code>AddMonoid.End G</code> but I do get it seems arbitrary from Lean's perspective...</p>\n<p>Anyhow once <code>Monoid.End G</code> gets mentioned there seems not to be a point to tag <code>to_additive</code>.</p>\n<p>So separating the statements is only natural, just like <code>AddMonoid.End G</code> is not tagged as the additive version of <code>Monoid.End G</code>.</p>",
        "id": 425513157,
        "sender_full_name": "Qi Ge",
        "timestamp": 1709902527
    },
    {
        "content": "<p>I see, so we want to additivize <code>Monoid.End</code> to <code>AddMonoid.End</code>, but not translate any operations on <code>Monoid.End</code>, right?</p>",
        "id": 425626012,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709942774
    },
    {
        "content": "<p>This idea to allow treating other types as a fixed type like <code>Nat</code> and not additivize their operations has been suggested before, e.g. <a href=\"#narrow/stream/113488-general/topic/to_additive.20and.20fixed.20types\">here</a>.</p>",
        "id": 425626501,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709943183
    },
    {
        "content": "<p>It should be easy to implement: just add another supporting attribute to <code>to_additive</code> to ignore certain types, and add some logic to <code>additiveTestUnsafe</code> to also use the logic of that attribute (i.e. add a check in line 499 to return if the attribute exists).</p>",
        "id": 425626804,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709943411
    },
    {
        "content": "<p>That said, <code>to_additive</code> is a heuristic method, and we add a bunch of exceptions/complications to the heuristic to make it work in almost all cases we care about. Just adding more exceptions and making the logic more complicated will not infinitely scale. <br>\nTherefore, if it's not too bad to manually write the additive versions (you don't expect that many lemmas like this will be written), I would recommend doing it manually.</p>",
        "id": 425626947,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709943525
    },
    {
        "content": "<p>I think the combination of translating a type, but not operations on that type could in principle be supported by such an attribute. However, there might be a bunch of interactions that I don't foresee right now, so this particular combination might be fragile (<code>to_additive</code> was definitely not designed to support something like this).</p>",
        "id": 425627070,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709943610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"668959\">Qi Ge</span> has marked this topic as resolved.</p>",
        "id": 425827398,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710124729
    },
    {
        "content": "<p>Will be fixed by <a href=\"https://github.com/leanprover-community/mathlib4/pull/19297\">#19297</a></p>",
        "id": 483520093,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1732118741
    }
]