[
    {
        "content": "<p>Prompted by comments of <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> in the review of one of my PRs, I would like to suggest adding a notion of <code>Meromorphic</code> to the file <code>Mathlib.Analysis.Meromorphic.Basic.lean</code>, as a shorthand for <code>MeromorphicOn _ Set.univ</code>.</p>\n<p>This would be in analogy to the existing notion of <code>Differentiable</code> in <code>Mathlib.Analysis.Calculus.FDeriv.Defs.lean</code>. If the community here is positive about the suggestion, I would be more than glad to implement it.</p>",
        "id": 558182437,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1763553280
    },
    {
        "content": "<p>I haven't thought about it deeply - but at first glance, this seems very reasonable!</p>",
        "id": 558201477,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1763558710
    },
    {
        "content": "<p>For almost all predicates on functions (<code>Continuous</code>, <code>Differentiable</code>, <code>ContDiff</code>, <code>ContMDiff</code>, <code>MDifferentiable</code> and even things like <code>Injective</code>) we have a predicate for the whole space and a predicate for a subset of the whole space. So this makes sense to add.</p>",
        "id": 558461516,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1763652833
    },
    {
        "content": "<p>Thank you for your feedback. I will implement <code>Meromorphic</code> then and port existing statements to use it. To avoid merge conflicts and the resulting chaos, I will probably wait a few days until my currently open PRs are merged (or rejected).</p>",
        "id": 558610464,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1763716164
    },
    {
        "content": "<p>It is perhaps also interesting to add the corresponding <code>fun_prop</code> API?</p>",
        "id": 558660819,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1763732120
    },
    {
        "content": "<p>Interestingly, we have <code>fun_prop</code> for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeromorphicAt#doc\">docs#MeromorphicAt</a>, but not <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeromorphicOn#doc\">docs#MeromorphicOn</a>.</p>",
        "id": 558661887,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763732423
    },
    {
        "content": "<p>I think we should have it for all three.</p>",
        "id": 558661944,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763732438
    },
    {
        "content": "<p>Relatedly: is there a reason <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AnalyticOn#doc\">docs#AnalyticOn</a> is not fun_prop, while <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AnalyticAt#doc\">docs#AnalyticAt</a> is?</p>",
        "id": 558663073,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1763732698
    },
    {
        "content": "<p>There's some other discrepancies here. For example, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeromorphicOn#doc\">docs#MeromorphicOn</a> doesn't really match <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AnalyticOn#doc\">docs#AnalyticOn</a>, but rather <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AnalyticOnNhd#doc\">docs#AnalyticOnNhd</a>. I'm willing to accept (if someone knowledgable says so), that the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=nhdsWithin#doc\">docs#nhdsWithin</a> variants are just not so useful, as I find that plausible. But if that's the case, I think we should either rename <code>MeromorphicOn</code> to <code>MeromorphicOnNhd</code>, or otherwise call attention to the discrepancy in docstring.</p>",
        "id": 558663581,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1763732832
    },
    {
        "content": "<p>Dear all, following up on the discussion here, I would like to introduce <code>Meromorphic</code> now. I am however unsure about the best way to do it. In principle, I would like to add the definition below to <code>Mathlib/Analysis/Meromorphic/Basic.lean</code> and go through <code>Mathlib</code> and replace all instances of <code>MeromorphicOn f Set.univ</code> by <code>Meromorphic f</code>.</p>\n<ul>\n<li>Is this a sane way to start?</li>\n<li>Should I duplicate theorems that we have for <code>MeromorphicOn</code>? -- There are many!</li>\n<li>Should I add API for conversion between <code>MeromorphicOn f Set.univ</code> and <code>Meromorphic f</code>? If so, what is the best way to do it?</li>\n<li>Do I need to depreciate/rename/whatever theorems where I change the assumption? If so, how should I do that?</li>\n</ul>\n<p>Any help is greatly appreciated. Season's Greeting, Stefan.</p>\n<p>--</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Meromorphy of a function on all of ùïú. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Meromorphic</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">MeromorphicAt</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"sd\">/-- A function is meromorphic iff it is meromorphic on Set.univ. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">meromorphic_iff_meromorphicOn</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Meromorphic</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">MeromorphicOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">tauto</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Meromorphic</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">meromorphicOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Meromorphic</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">MeromorphicOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">tauto</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The singular set of a meromorphic function is countable.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">countable_compl_analyticAt</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SecondCountableTopology</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Meromorphic</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">AnalyticAt</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">}</span><span class=\"bp\">·∂ú.</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">meromorphicOn</span><span class=\"bp\">.</span><span class=\"n\">countable_compl_analyticAt_inter</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Meromorphic functions are measurable.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">measurable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SecondCountableTopology</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BorelSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BorelSpace</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Meromorphic</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Measurable</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">AnalyticAt</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">·∂ú.</span><span class=\"n\">Countable</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">meromorphicOn</span><span class=\"bp\">.</span><span class=\"n\">countable_compl_analyticAt_inter</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"bp\">.</span><span class=\"n\">to_subtype</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsOpen</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">isOpen_analyticAt</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÉ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContinuousOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">hz</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">hz</span><span class=\"bp\">.</span><span class=\"n\">continuousAt</span><span class=\"bp\">.</span><span class=\"n\">continuousWithinAt</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">of_union_range_cover</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">subtype_coe</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÇ</span><span class=\"bp\">.</span><span class=\"n\">measurableSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">subtype_coe</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"bp\">.</span><span class=\"n\">measurableSet</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">mem_compl_iff</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÉ</span><span class=\"bp\">.</span><span class=\"n\">restrict</span><span class=\"bp\">.</span><span class=\"n\">measurable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">measurable_of_countable</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Meromorphic</span>\n</code></pre></div>",
        "id": 564411727,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1766049246
    },
    {
        "content": "<p>Yes, that's a very good plan. Your lemma <code>meromorphic_iff_meromorphicOn</code> should be called <code>meromorphicOn_univ</code>, marked <code>simp</code> and with sides reversed. There's no need to add versions of all lemmas for <code>Meromorphic</code> corresponding to those for <code>MeromorphicOn</code>, this can happen organically -- although it is probably good to add from the start the main ones like <code>Meromorphic.add</code> and friends.</p>\n<p>If you change a lemma statement without changing the name, no need to deprecate. A deprecation is needed when you change the name, though.</p>\n<p>The <code>h‚ÇÅ</code> in your last proof should probably use the lemma <code>Meromorphic.countable_compl_analyticAt</code> that you introduce just before.</p>",
        "id": 564420037,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1766051970
    },
    {
        "content": "<p>Thanks. Will do as Sebastien suggested.</p>",
        "id": 564457274,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1766063981
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"679664\">@Stefan Kebekus</span> I would probably do this in a few PRs instead of one though. That is, I would probably do this:</p>\n<ol>\n<li>Define <code>Meromorphic</code> and establish very basic API lemmas about it.</li>\n<li>Develop some of the more complex theorems for <code>Meromorphic</code>.</li>\n<li>Replace all occurrences of <code>MeromorphicOn univ</code> with <code>Meromorphic</code>.</li>\n</ol>\n<p>If (1) and (2) are small enough they can be a single PR. Alternatively, (2) and (3) could happen simultaneously (dependent on (1)). But I would especially separate out (3) because it will be very easy to review on its own, whereas it would just be noise if it was present in the diff of (1) or (2).</p>",
        "id": 564522177,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1766079324
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> Thanks for your advice. I opened PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/33117\">#33117</a> with your item 1 from your list. Season's Greetings -- Stefan.</p>",
        "id": 564809948,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1766215848
    },
    {
        "content": "<p>Thanks Stefan! With the help of <code>to_fun</code> you can autogenerate all the <code>fun_</code> variants. See my review.</p>",
        "id": 564811089,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1766217118
    },
    {
        "content": "<p>Thanks Johan! Now this is helpful indeed. Merry Christmas! <span aria-label=\"christmas\" class=\"emoji emoji-1f9d1-200d-1f384\" role=\"img\" title=\"christmas\">:christmas:</span></p>",
        "id": 564815500,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1766222835
    }
]