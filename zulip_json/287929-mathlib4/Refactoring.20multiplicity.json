[
    {
        "content": "<p>Would refactoring <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=multiplicity#doc\">docs#multiplicity</a> to be noncomputable and return values in <code>ℕ∞</code> instead of <code>PartENat</code> be good?</p>",
        "id": 470358821,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726418623
    },
    {
        "content": "<p>i seem to recall that removing <code>PartENat</code> in favour of <code>ℕ∞</code> is somewhere on the list of todos, but i could be wrong.</p>",
        "id": 470378010,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726428507
    },
    {
        "content": "<p>Why would <code>ℕ∞</code> make it noncomputable?</p>",
        "id": 470385733,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1726432563
    },
    {
        "content": "<p>because you can't know whether a finite value satisfying the predicate exists, and <code>PartENat</code> nicely avoids that issue by making equality with <code>∞</code> be noncomputable instead</p>",
        "id": 470386004,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1726432708
    },
    {
        "content": "<p>What is the gain in this modification ?</p>",
        "id": 470386491,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1726433159
    },
    {
        "content": "<p>PartENat is really annoying to work with</p>",
        "id": 470413574,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726451575
    },
    {
        "content": "<p>Another option is to have it return values in <code>Nat</code>, with a junk value when it's infinite</p>",
        "id": 470450821,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726462256
    },
    {
        "content": "<p>See also <a href=\"#narrow/stream/287929-mathlib4/topic/Working.20with.20Nat.2Efactorization/near/455657608\">here</a>.</p>",
        "id": 470527854,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1726479581
    },
    {
        "content": "<p>I am not 100% the junk value solution will work well, since (for example) having multiplicity <code>0</code> is a meaningful concept. But it also true that working with multiplicity now is a little pain.</p>",
        "id": 470541024,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1726482305
    },
    {
        "content": "<p>Perhaps we could have both versions, like with dist and edist and degree and natDegree?</p>",
        "id": 470542450,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726482475
    },
    {
        "content": "<p>In the unix style, we could use Int and return -1 as a junk value</p>",
        "id": 470546358,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1726483123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Refactoring.20multiplicity/near/470546358\">said</a>:</p>\n<blockquote>\n<p>In the unix style, we could use Int and return -1 as a junk value</p>\n</blockquote>\n<p>I would really like to be able to write <code>p^(multiplicity p n)</code>...</p>",
        "id": 470547023,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1726483275
    },
    {
        "content": "<p>Perhaps <code>1</code> makes more sense as a junk value? This keeps <code>multiplicity p n = 0 ↔ ¬p ∣ n</code></p>",
        "id": 470552981,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726484415
    },
    {
        "content": "<p>Although it breaks <code>multiplicity a 1 = 0</code></p>",
        "id": 470554005,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726484645
    },
    {
        "content": "<p>I think it's fine to have two versions. We could rename the current version to <code>eMultiplicity</code> to free up <code>multiplicity</code>. Or we could have a new concept called <code>natMultiplicity</code>.</p>",
        "id": 470593933,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1726491445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Refactoring.20multiplicity/near/470547023\">said</a>:</p>\n<blockquote>\n<p>I would really like to be able to write <code>p^(multiplicity p n)</code>...</p>\n</blockquote>\n<p>I agree, and right now you can't do that either, right? Because you can't raise something to the power <code>k : partEnat</code>.</p>",
        "id": 470594435,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1726491514
    },
    {
        "content": "<p>Maybe we should have a <code>Part.get!</code> and a partEnat.get!<code> that return junk (read: default) values. If we do that, we're sorta forced to use </code>0` as junk value.</p>",
        "id": 470595338,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1726491647
    },
    {
        "content": "<p>I'm trying to create a <code>natMultiplicity</code>, but I'm unsure how general stuff should be. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=le_multiplicity_map#doc\">docs#le_multiplicity_map</a>, for instance - should it take <code>Finite (f a) (f b)</code>, or the weaker <code>Finite a b → Finite (f a) (f b)</code>?</p>",
        "id": 470604126,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726493339
    },
    {
        "content": "<p>Surely it should just be exactly as general as the corresponding <code>multiplicity</code> stuff?</p>",
        "id": 470604421,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1726493406
    },
    {
        "content": "<p>Yes, but this creates a problem in theorems like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=multiplicity_eq_multiplicity_iff#doc\">docs#multiplicity_eq_multiplicity_iff</a> - I need to take an assumption like <code>Finite a b ↔ Finite c d</code>.</p>",
        "id": 470604689,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726493474
    },
    {
        "content": "<p>Oh I see -- the corresponding theorem really isn't true. I get your point now.</p>",
        "id": 470604937,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1726493526
    },
    {
        "content": "<p>The problem with the weaker assumption is that probably in practice I'll have <code>h1 : Finite a b</code> and <code>h2 : Finite c d</code> and I don't really want to be faced with a proof obligation that they're logically equivalent. My instinct is just to assume basic finiteness assumptions needed to make the theorems true i.e. <code>Finite a b</code> and <code>Finite c d</code>. If people want more general versions then they can add them later.</p>",
        "id": 470607532,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1726493789
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">tauto</span>\n</code></pre></div>\n<p>besides the point, but proving that they're equivalent is easy?</p>",
        "id": 470609650,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726494171
    },
    {
        "content": "<p>(assuming you do indeed have proofs of both)</p>",
        "id": 470609736,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726494191
    },
    {
        "content": "<p>Yes, but doing it every time it you're doing a bunch of rewrites can be annoying</p>",
        "id": 470609773,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726494201
    },
    {
        "content": "<p>fair</p>",
        "id": 470609871,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726494231
    },
    {
        "content": "<p>What's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=has_dvd.dvd.multiplicity_pos#doc\">docs#has_dvd.dvd.multiplicity_pos</a> ? Is this something that was missed in the port?</p>",
        "id": 470610461,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726494329
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_dvd.dvd.multiplicity_pos\">docs3#has_dvd.dvd.multiplicity_pos</a></p>",
        "id": 470610611,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726494351
    },
    {
        "content": "<p>I see -- it's enabling dot notation for a terms of a type which was since renamed :-/</p>",
        "id": 470611428,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1726494466
    },
    {
        "content": "<p>I remember discussing this with <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span> who agreed that this <code>PartENat</code> is painful. I would be very much in favour of having multiplicity valued in <code>ℕ∞</code> as the default, and if needed to keep both verisons.</p>",
        "id": 470625280,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1726496794
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Refactoring.20multiplicity/near/470594435\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Refactoring.20multiplicity/near/470547023\">said</a>:</p>\n<blockquote>\n<p>I would really like to be able to write <code>p^(multiplicity p n)</code>...</p>\n</blockquote>\n<p>I agree, and right now you can't do that either, right? Because you can't raise something to the power <code>k : partEnat</code>.</p>\n</blockquote>\n<p>Yes, it is already a pain. I think that having two versions is a good idea. Maybe a typeclass saying that the multiplicity of all nonunits (or whatever it is needed) is always finite.</p>",
        "id": 470626859,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1726497086
    },
    {
        "content": "<p>I refactored to an <code>ℕ</code>-valued version at <a href=\"https://github.com/leanprover-community/mathlib4/tree/CM_multiplic\">branch#CM_multiplic</a>, if anybody wants to take a look</p>",
        "id": 470639470,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726498969
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/16881\">#16881</a></p>",
        "id": 470878573,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726553416
    },
    {
        "content": "<p>hmm, this makes <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=padicValNat#doc\">docs#padicValNat</a> noncomputable</p>",
        "id": 470878694,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726553483
    },
    {
        "content": "<p>I'm uncertain what to do with the results in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Nat/Multiplicity.html\">Data.Nat.Multiplicity</a> - should they use <code>emultiplicity</code> or <code>multiplicity</code>?</p>",
        "id": 470889732,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726557015
    },
    {
        "content": "<p>I would say <code>multiplicity</code>, but which one requires less dependencies?</p>",
        "id": 470893280,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1726558132
    },
    {
        "content": "<p>They are in the same file</p>",
        "id": 470894114,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726558390
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Refactoring.20multiplicity/near/470878694\">said</a>:</p>\n<blockquote>\n<p>hmm, this makes <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=padicValNat#doc\">docs#padicValNat</a> noncomputable</p>\n</blockquote>\n<p>The <code>csimp</code> on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=padicValNat.padicValNat_eq_maxPowDiv#doc\">docs#padicValNat.padicValNat_eq_maxPowDiv</a> restores code generation</p>",
        "id": 470921340,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1726564774
    },
    {
        "content": "<p>There was a suggestion elsewhere to just implement padicValNat from scratch to be kernel reducible, which could make it computable at the same time.</p>",
        "id": 471062445,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1726598355
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/16881\">#16881</a> passes CI now! If anybody is able to review it that'd be great</p>",
        "id": 471173462,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726638438
    },
    {
        "content": "<p>That's quite a large diff! However perhaps this is inevitable, and changes like</p>\n<p><a href=\"/user_uploads/3121/TJmoD6ad7qBRyy4kZyc_v8Le/padic.png\">padic.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/TJmoD6ad7qBRyy4kZyc_v8Le/padic.png\" title=\"padic.png\"><img data-original-dimensions=\"1220x662\" src=\"/user_uploads/thumbnail/3121/TJmoD6ad7qBRyy4kZyc_v8Le/padic.png/840x560.webp\"></a></div><p>make me feel like it's making mathlib more readable. Also the removal of random <code>[@DecidableRel R[X] (· ∣ ·)]</code>s makes me happy too, although I'm very much on the noncomputable side of things when it comes to mathlib decisions.</p>",
        "id": 471201975,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1726648669
    },
    {
        "content": "<p>I think that the way to go is the following: do we agree we want both version? I personally do. If this is the case you can split the PR in at least two: first of all just rename <code>multiplicity</code> to <code>emultiplicity</code>, without adding anything else, and in a following PR add the new <code>multiplicity</code>.</p>",
        "id": 471206205,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1726649963
    },
    {
        "content": "<p>I agree that it makes sense to have both <code>emultiplicity</code> (<code>ENat</code>-valued) and a <code>Nat</code>-valued <code>multiplicity</code>. Getting tid of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PartENat#doc\">docs#PartENat</a> is definitely a good thing!</p>",
        "id": 471207902,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1726650447
    },
    {
        "content": "<p>Do we need to split the PR into two? A lot of the diff is just renaming lemma names. I've just ploughed through all of it because like Michael I have always found it hard to work with PartENat.</p>",
        "id": 471210068,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1726650999
    },
    {
        "content": "<p>Maybe not, I was just suggesting a way of making the diff smaller.</p>",
        "id": 471210476,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1726651102
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Refactoring.20multiplicity/near/471206205\">said</a>:</p>\n<blockquote>\n<p>I think that the way to go is the following: do we agree we want both version? I personally do. If this is the case you can split the PR in at least two: first of all just rename <code>multiplicity</code> to <code>emultiplicity</code>, without adding anything else, and in a following PR add the new <code>multiplicity</code>.</p>\n</blockquote>\n<p>You mean while keeping PartENat?</p>",
        "id": 471213098,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726651809
    },
    {
        "content": "<p>I forgot there is also this change. Making several PRs makes the review process easier, but it means more work for you, so a trade-off of probably the way to go. But anyway I think we should decide this (having both versions) is the solution we want.</p>",
        "id": 471213660,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1726651977
    },
    {
        "content": "<p>Another option is to use multiplicity and natMultiplicity instead of emultiplicity and mutliplicity, and then less renames are needed</p>",
        "id": 471216190,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726652760
    },
    {
        "content": "<p>Another thing of note in the PR is moving many results outside of the <code>multiplicity</code> namespace, as they all had to be renamed anyway to have either <code>multiplicity</code> or <code>emultiplicity</code> to disambiguate, so the namespace was redundant</p>",
        "id": 471216654,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726652891
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Refactoring.20multiplicity/near/471216190\">said</a>:</p>\n<blockquote>\n<p>Another option is to use multiplicity and natMultiplicity instead of emultiplicity and mutliplicity, and then less renames are needed</p>\n</blockquote>\n<p>Yes but I think this goes against the principle of making the main things have shorter names</p>",
        "id": 471222882,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1726654751
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Refactoring.20multiplicity/near/471216654\">said</a>:</p>\n<blockquote>\n<p>Another thing of note in the PR is moving many results outside of the <code>multiplicity</code> namespace, as they all had to be renamed anyway to have either <code>multiplicity</code> or <code>natMultiplicity</code> to disambiguate, so the namespace was redundant</p>\n</blockquote>\n<p>I always hated that namespace. It's not a type! Happy to see it go</p>",
        "id": 471222996,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1726654786
    },
    {
        "content": "<p>There are still some remains, mostly <code>multiplicity.Finite</code> and a few other lemmas</p>",
        "id": 471223478,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726654932
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Refactoring.20multiplicity/near/471222996\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Refactoring.20multiplicity/near/471216654\">said</a>:</p>\n<blockquote>\n<p>Another thing of note in the PR is moving many results outside of the <code>multiplicity</code> namespace, as they all had to be renamed anyway to have either <code>multiplicity</code> or <code>natMultiplicity</code> to disambiguate, so the namespace was redundant</p>\n</blockquote>\n<p>I always hated that namespace. It's not a type! Happy to see it go</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/19623\">#19623</a> eliminates that namespace completely (up to deprecated aliases), renaming <code>multiplicity.Finite</code> to <code>FiniteMultiplicity</code></p>",
        "id": 485205211,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1732953593
    },
    {
        "content": "<p>I think this is a good move. But I do find <code>FiniteMultiplicity</code> a rather long name. We also have things like <code>fincard</code>, so how about <code>FinMultiplicity</code>? Or possibly <code>NatMultiplicity</code>?</p>",
        "id": 485247581,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1732988076
    }
]