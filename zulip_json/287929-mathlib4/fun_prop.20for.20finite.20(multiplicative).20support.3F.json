[
    {
        "content": "<h3>Context</h3>\n<p>I'm currently adding material on heights in arithmetic geometry to Mathlib (BTW, a review of <a href=\"https://github.com/leanprover-community/mathlib4/pull/34330\">#34330</a> would be very welcome...). The definition of the height involves a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finprod#doc\">docs#finprod</a>, and so in several places I have to deal with side goals of the form <code>f.mulSupport.Finite</code> (where <code>f</code> is some function). These goals can usually be easily proved by combining lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite.subset#doc\">docs#Set.Finite.subset</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite.union#doc\">docs#Set.Finite.union</a> with results expressing or bounding the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.mulSupport#doc\">docs#Function.mulSupport</a> of some more complicated function in terms of the <code>mulSupport</code>s of its constituents. This looks like something that one should be able to automate fairly easily, and the <code>fun_prop</code> framework seems to be the canonical choice for that.</p>\n<h3>Proposal</h3>\n<p>So I would like to extend <code>fun_prop</code> so that it can deal with these goals.</p>\n<p>I don't think that <code>fun_prop</code> can be made to work with a composed predicate like <code>fun f ↦ f.mulSupport.Finite</code>, so one first has to define a dedicated predicate like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Function</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The function `f` has finite multiplicative support. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HasFiniteMulSupport</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">mulSupport</span><span class=\"bp\">.</span><span class=\"n\">Finite</span>\n</code></pre></div>\n<p>and then prove various lemmas using this predicate, e.g.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">hasFiniteMulSupport_mul</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulOneClass</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasFiniteMulSupport</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasFiniteMulSupport</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">HasFiniteMulSupport</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">mulSupport_mul</span><span class=\"w\"> </span><span class=\"bp\">..</span>\n</code></pre></div>\n<p>This can fairly easily be done; see <a href=\"https://github.com/MichaelStollBayreuth/Heights/blob/master/Heights/FiniteMulSupport.lean\">FiniteMulSupport.lean</a> in the <a href=\"https://github.com/MichaelStollBayreuth/Heights/tree/master\">Heights</a> repo.</p>\n<p>But to reap the benefits, one then needs to replace all assumptions of the form <code>f.mulSupport.Finite</code> in Mathlib by <code>f.HasFiniteMulSupport</code> (loogle finds 37 for <code>mulSupport</code>and 55 for <code>support</code>). (One could perhaps even think of using <code>by fun_prop</code> as the default for these.)</p>\n<h3>Question</h3>\n<p>Would such an addition and change be welcome? If this is the case, I'll prepare a PR.</p>",
        "id": 570411560,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1769544172
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/channel/287929-mathlib4/topic/fun_prop.20for.20finite.20.28multiplicative.29.20support.3F/near/570411560\">said</a>:</p>\n<blockquote>\n<p>Would such an addition and change be welcome?</p>\n</blockquote>\n<p><span aria-label=\"ping pong\" class=\"emoji emoji-1f3d3\" role=\"img\" title=\"ping pong\">:ping_pong:</span> </p>\n<p>I think this would be helpful for my use case, but wouldn't want to spend time and energy to implement it when the maintainers think it's not wanted.</p>",
        "id": 570778543,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1769688953
    },
    {
        "content": "<p>If you don't want to do this refactor you could instead make a custom <code>aesop</code> ruleset.</p>",
        "id": 570783215,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769690390
    },
    {
        "content": "<p>Can <code>aesop</code> \"split\" functions like <code>fun_prop</code> does?</p>",
        "id": 570783327,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769690426
    },
    {
        "content": "<p>what do you mean by \"split\", sorry? If you have something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">add_mulSupport_finite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">mulSupport</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">mulSupport</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mulSupport</span><span class=\"bp\">.</span><span class=\"n\">finite</span>\n</code></pre></div>\n<p>you can tag it <code>aesop 90%</code> (or even <code>aesop safe</code> if you disable it downstream)</p>\n<p>to do the thing I think you want it to do</p>\n<p>see the <code>SetLike</code> <code>aesop</code> ruleset for an example</p>",
        "id": 570784715,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769690804
    },
    {
        "content": "<p>I meant something like that but looks like it works with <code>aesop</code> too:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"n\">safe</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">add_mulSupport_finite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">mulSupport</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">mulSupport</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mulSupport</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"n\">safe</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">id_mulSupport_finite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">mulSupport</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">mulSupport</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mulSupport</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">mulSupport</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mulSupport</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span>\n</code></pre></div>\n<p>Here, when applying <code>add_mulSupport_finite</code> Lean has to come up to use <code>f = fun x =&gt; h x + h x</code> and <code>g = fun x =&gt; x</code>. I thought that it was some special behaviour of <code>fun_prop</code> that it can do that. Though now I see that it is not the case, because even <code>apply add_mulSupport_finite</code> can do that.</p>",
        "id": 570910043,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769726800
    },
    {
        "content": "<p>I think the question is rather whether <code>aesop</code> can do it <em>without</em> adding extra API lemmas for <code>_.mulSupport.Finite</code>. I should experiment a bit to see whether it does, but didn't have time yet.</p>\n<p>My original question is mainly whether the additional API would be welcome (and then it makes sense to have a definition for the combination and add the <code>fun_prop</code> tags).</p>\n<p>(This is beside the point, but the two lemmas <code>add_mulSupport_finite</code> and <code>id_mulSupport_finite</code> are wrong.)</p>",
        "id": 571048410,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1769784457
    },
    {
        "content": "<p>In the Carleson project, we have classes BoundedCompactSupport and BoundedFiniteSupport. (We will probably only upstream one of these.) We're working on using fun_prop with them. In other words, adding fun_prop for such a property seems reasonable to me.</p>",
        "id": 571049762,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1769784761
    },
    {
        "content": "<p>I take this to say that it also seems reasonable to you to add the predicate <code>HasFiniteMulSupport</code> (plus API). Correct?</p>",
        "id": 571050074,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1769784843
    },
    {
        "content": "<p>By now, I have played with this a little bit. In <a href=\"https://github.com/leanprover-community/mathlib4/pull/34658\">#34658</a> I have added <code>HasFiniteMulSupport</code>, provided API and <code>fun_prop</code> tags, and changed most occurrences of <code>Set.Finite (Function.mulSupport _)</code> to <code>HasMulSupport _</code> (and similarly for the additive version).  I then simplified some proofs in NumberTheory.Height.Basic using the new <code>fun_prop</code> capabilities.</p>",
        "id": 571758140,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1770151192
    },
    {
        "content": "<p>For comparison, in <a href=\"https://github.com/leanprover-community/mathlib4/pull/34793\">#34793</a> I just add API for <code>Set.Finite (Function.mulSupport _))</code> and then use it to simplify the same two proofs.</p>",
        "id": 571758263,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1770151238
    },
    {
        "content": "<p>Both PRs are marked \"WIP\" for the time being.</p>\n<ul>\n<li>The <code>HasFiniteMulSupport</code> option leads to nicer proofs (like <code>fun_prop (disch := grind)</code>), but feels a bit heavy when done consequently: there are many places where the new predicate can be used.</li>\n<li>The other option is more \"minimally invasive\", but also leads to less simplification.</li>\n</ul>\n<p>Except for the material on heights (with more to come), it does not look like the existing API for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.mulSupport#doc\">docs#Function.mulSupport</a> and its additive counterpart is used much in Mathlib. But this may well change in the future.</p>\n<p>So the question is, which of the two options is preferable long-term? (If the answer should be \"none\", then a third option would be to add the API lemmas I need as private lemmas to the file where they are used.)</p>\n<p>Your insights are appreciated!</p>",
        "id": 571759028,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1770151514
    }
]