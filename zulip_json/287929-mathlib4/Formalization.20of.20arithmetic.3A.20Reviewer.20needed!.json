[
    {
        "content": "<p>Hey!</p>\n<p>For the past couple of months I have been exploring ways to formalize results from the field of arithmetic (in particular, bounded arithmetic). I am basing my work on the book <a href=\"https://www2.karlin.mff.cuni.cz/~krajicek/cook-nguyen.pdf\">Logical Foundations of Proof Complexity</a> (full text available on anna's) The results are beautiful and are of the form \"if you can prove theorem defining function f(x) in this logic, then the algorithm you implicitly used to prove this theorem is in PTIME (or LOGSPACE, or AC^0 ...)\". There's a bunch of ways to formalize such theorems, most of which not really feasible; but I found a satisfactory approach, which enables us to transfer proofs from paper to computer, for (I think?) most of the field of arithmetic. An example of this is as follows (Draft: Exercise 3.8, page 36 = page 47 of the main.dvi PDF file; in official print, Exercise III.1.8, page 42 = 60 of pdf): these are theorems provable in the theories we study (with proof sketches on the screenshot): <br>\n<a href=\"/user_uploads/3121/It7JA5C261EGlV1Rf1gkNRyj/image.png\">image.png</a> <br>\nand this if my formalization of commutativity of multiplication:<br>\n<a href=\"/user_uploads/3121/JUgu2p93x4KsyGMNQJoqBApJ/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/It7JA5C261EGlV1Rf1gkNRyj/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"556x365\" src=\"/user_uploads/thumbnail/3121/It7JA5C261EGlV1Rf1gkNRyj/image.png/840x560.webp\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/JUgu2p93x4KsyGMNQJoqBApJ/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"928x592\" src=\"/user_uploads/thumbnail/3121/JUgu2p93x4KsyGMNQJoqBApJ/image.png/840x560.webp\"></a></div><p>what my approach does not enable is reasoning about the deduction system itself (because the deduction system is the implementation of Lean). But it does enable us to digitalize most of interesting theorems in this field.</p>\n<p>The weakest theory studied (V^0) does not allow us to define a sorting function, nor prove the Pigeonhole principle. But we can add an axiom (taking us from AC^0 to <a href=\"https://en.wikipedia.org/wiki/TC0\">TC^0</a> complexity class) which allows us to do that (and I have a sketch of <a href=\"https://github.com/ruplet/formalization-of-bounded-arithmetic/blob/14175313430ca36e6d7491283bcccca4572d7a4a/BoundedArithmetic/VTC0.lean\">formalization of Pigeonhole</a> in theory for TC^0). This is quite nice, because we realistically can <a href=\"https://github.com/ruplet/formalization-of-bounded-arithmetic/blob/14175313430ca36e6d7491283bcccca4572d7a4a/BoundedArithmetic/Extraction.lean\">extract programs from these proofs</a> - which gives us a program with a \"certified\" complexity class (conditions: we believe proofs of Cook and Nguyen; we believe our custom code extraction procedure).</p>\n<p>I am still working on the code and results are slightly scattered around, but I want to start looking for someone willing to review my code when it's ready, as I haven't meet too many people knowing both Lean and something about arithmetic :) Please check out <a href=\"https://github.com/ruplet/formalization-of-bounded-arithmetic\">my repo</a>, especially the proofs conducted inside of the weak logic IDelta0 here: <a href=\"https://github.com/ruplet/formalization-of-bounded-arithmetic/blob/14175313430ca36e6d7491283bcccca4572d7a4a/BoundedArithmetic/IDelta0.lean#L1251\">add_cancel_right</a>. I will be very grateful for every piece of early feedback and will be happy to include it now, before the code grows and it becomes more difficult to change design :)</p>\n<p>Perhaps it's worth noting that I have already presented this work at  <a href=\"https://aitp-conference.org/2025/\">aitp 2025</a>! You can check out the slides here: <a href=\"https://github.com/ruplet/formalization-of-bounded-arithmetic/blob/main/aitp-presentation.pdf\">link</a>, and in the repo there is also the abstract I submitted and the reviews it received ;) When I was submitting the abstract, I wasn't sure how to design this formalization, so it was completely speculative if it'd work. But it: a) was interesting enough anyway b) turned out that the formalization is completely doable and very convenient to work with</p>",
        "id": 540831230,
        "sender_full_name": "Paweł Balawender",
        "timestamp": 1758553969
    },
    {
        "content": "<p>This sounds really interesting! I read a bit about the extraction algorithm, and if I understand correctly, the extraction algorithm takes the witness term out from <code>⟨term, proof⟩ : ∃ x, proposition</code>. What would happen if the proposition is proved via contradiction?</p>",
        "id": 540903071,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1758580092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Formalization.20of.20arithmetic.3A.20Reviewer.20needed!/near/540903071\">said</a>:</p>\n<blockquote>\n<p>This sounds really interesting! I read a bit about the extraction algorithm, and if I understand correctly, the extraction algorithm takes the witness term out from <code>⟨term, proof⟩ : ∃ x, proposition</code>. What would happen if the proposition is proved via contradiction?</p>\n</blockquote>\n<p>Thanks for the interest <span class=\"user-mention\" data-user-id=\"734814\">@Dexin Zhang</span> ! There are two things here.</p>\n<p>First is that the way of doing extraction I have in this file is  not general. My code here only handles the special case of this particular binary addition theorem. More generally, this approach will surely not support functions that rely on classical logic to prove that the result exists. However, it shouldn't be a problem to extract code from a function which constructively builds the result, but then proves its correctness classically. E.g. in my extraction example, when I find the <code>(term, proof) : \\exists x, proposition</code>, i ignore the <code>proof</code> anyway - no problem if it uses contradiction. The thing is that the function we create and ultimately run is not guaranteed to be correct (i.e. that the result satisfies some formula) anyway.</p>\n<p>Second thing is much deeper. In this area, \"witnessing theorems\" are considered, which say that if you can prove the existence of the result of a function in one of these theories, then you can actually compute the result in the corresponding complexity class. The proof of such a theorem should ideally correspond to a general code extraction procedure. For example, in the screenshot,  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mn>1</mn></msup></mrow><annotation encoding=\"application/x-tex\">V^1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span> is  the theory for polytime, so if you can prove existence there, you can <em>compute</em> the result in polytime.</p>\n<p><a href=\"/user_uploads/3121/tdYfR8wuuxUnOZOgWAwQS5ve/image.png\">image.png</a> <br>\nThis is a relatively active area of research. The problem is that the proofs they traditionally do are  uncomputable; I looked at  the two proofs  in Logical Foundations for the theory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">V^0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span>, and they don't lead to any practical code extraction mechanism. I also asked <a href=\"https://mathoverflow.net/q/492469\">a question</a> on mathoverflow some time ago,  but didn't get anything useful. And at <a href=\"https://feasible-math.org/events/CCT25/\">STOC this year</a> there was even a talk titled \"Witnessing Theorems — Converting Proofs into Algorithms\" by Sam Buss, but I haven't been able to find any intel on what was in it :&lt; Cook and Nguyen state, while talking about witnessing for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">V^0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span> that the proofs are \"not difficult to find\" (screenshot)  - perhaps they are right? I haven't tried to do it on my own as I don't have the best intuition on the complexity of these logical algorithms such as cut elimination.<br>\n<a href=\"/user_uploads/3121/0O4ZESQJvLoRew3bTmgQGyau/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/tdYfR8wuuxUnOZOgWAwQS5ve/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"966x492\" src=\"/user_uploads/thumbnail/3121/tdYfR8wuuxUnOZOgWAwQS5ve/image.png/840x560.webp\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/0O4ZESQJvLoRew3bTmgQGyau/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"972x173\" src=\"/user_uploads/thumbnail/3121/0O4ZESQJvLoRew3bTmgQGyau/image.png/840x560.webp\"></a></div>",
        "id": 540906455,
        "sender_full_name": "Paweł Balawender",
        "timestamp": 1758582640
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"892220\">@Paweł Balawender</span> Thanks for the explanation. If I understand correctly, witness theorems you mentioned are telling us \"if proofs exist, then algorithms in certain complexities exist\", but that does not give us a translation procedure from proofs to algorithms, right? Would the case be easier when the proofs are intuitionistic (not using excluded middle)?</p>",
        "id": 540910499,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1758586217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Formalization.20of.20arithmetic.3A.20Reviewer.20needed!/near/540910499\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"892220\">Paweł Balawender</span> Thanks for the explanation. If I understand correctly, witness theorems you mentioned are telling us \"if proofs exist, then algorithms in certain complexities exist\", but that does not give us a translation procedure from proofs to algorithms, right? Would the case be easier when the proofs are intuitionistic (not using excluded middle)?</p>\n</blockquote>\n<p>I suspect it should be the case! I think you can go one step further and use classical logic to prove properties about the witness (for x, y, prove that phi(x, y)), but only use constructive reasoning to show the witness (forall x, exists y)</p>",
        "id": 540942870,
        "sender_full_name": "Paweł Balawender",
        "timestamp": 1758611609
    },
    {
        "content": "<p>Btw, <span class=\"user-mention\" data-user-id=\"734814\">@Dexin Zhang</span> I like your recent commits in ModelTheory.Arithmetic.Presburger! I think that we can resolve your TODO in Presburger.Basic <code>Define the theory of Presburger arithmetic and prove its properties (quantifier elimination, completeness, etc).</code> with the approach I used to define IDelta0. In particular, we would just have to remove the 'Delta0' restriction from induction and remove multiplication from IDelta0 to get Presburger?</p>",
        "id": 540968129,
        "sender_full_name": "Paweł Balawender",
        "timestamp": 1758619704
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"892220\">Paweł Balawender</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Formalization.20of.20arithmetic.3A.20Reviewer.20needed!/near/540942870\">said</a>:</p>\n<blockquote>\n<p>I suspect it should be the case! I think you can go one step further and use classical logic to prove properties about the witness (for x, y, prove that phi(x, y)), but only use constructive reasoning to show the witness (forall x, exists y)</p>\n</blockquote>\n<p>Got it. I definitely agree with you, and I'd like to see how far this approach can go <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 540994595,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1758628924
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"892220\">Paweł Balawender</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Formalization.20of.20arithmetic.3A.20Reviewer.20needed!/near/540968129\">said</a>:</p>\n<blockquote>\n<p>Btw, <span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> I like your recent commits in ModelTheory.Arithmetic.Presburger! I think that we can resolve your TODO in Presburger.Basic <code>Define the theory of Presburger arithmetic and prove its properties (quantifier elimination, completeness, etc).</code> with the approach I used to define IDelta0. In particular, we would just have to remove the 'Delta0' restriction from induction and remove multiplication from IDelta0 to get Presburger?</p>\n</blockquote>\n<p>Thanks for your interest! Yes, it's pretty similar, though I plan to define the theory of Presburger arithmetic syntactically (e.g. you can see the existing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FirstOrder.Language.Theory.field#doc\">docs#FirstOrder.Language.Theory.field</a>). The reasoning will be on the models (since Mathlib does not contain any proof system), just like what you did in your repo. Honestly speaking I haven't make too much progress on that <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>",
        "id": 540995712,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1758629194
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Formalization.20of.20arithmetic.3A.20Reviewer.20needed!/near/540995712\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"892220\">Paweł Balawender</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Formalization.20of.20arithmetic.3A.20Reviewer.20needed!/near/540968129\">said</a>:</p>\n<blockquote>\n<p>Btw, <span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> I like your recent commits in ModelTheory.Arithmetic.Presburger! I think that we can resolve your TODO in Presburger.Basic <code>Define the theory of Presburger arithmetic and prove its properties (quantifier elimination, completeness, etc).</code> with the approach I used to define IDelta0. In particular, we would just have to remove the 'Delta0' restriction from induction and remove multiplication from IDelta0 to get Presburger?</p>\n</blockquote>\n<p>Thanks for your interest! Yes, it's pretty similar, though I plan to define the theory of Presburger arithmetic syntactically (e.g. you can see the existing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FirstOrder.Language.Theory.field#doc\">docs#FirstOrder.Language.Theory.field</a>). The reasoning will be on the models (since Mathlib does not contain any proof system), just like what you did in your repo. Honestly speaking I haven't make too much progress on that <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>\n</blockquote>\n<p>Cool! It will be nice when we have a proof system in mathlib indeed, though it's probably still a long way ahead. If you plan to go back to reasoning on models, I'll be glad to help</p>",
        "id": 540997237,
        "sender_full_name": "Paweł Balawender",
        "timestamp": 1758629622
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Formalization.20of.20arithmetic.3A.20Reviewer.20needed!/near/540910499\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"892220\">Paweł Balawender</span> Thanks for the explanation. If I understand correctly, witness theorems you mentioned are telling us \"if proofs exist, then algorithms in certain complexities exist\", but that does not give us a translation procedure from proofs to algorithms, right? Would the case be easier when the proofs are intuitionistic (not using excluded middle)?</p>\n</blockquote>\n<p>These results don't really work the same way as constructive algorithm extraction (although they are related). What these theorems say is really \"If theory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> proves that algorithm <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> computes a total function, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> has time complexity <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>.\"</p>\n<p>The subtlety is going to be in terms of extracting a more specific bound (like a polynomial for polytime) from a given proof. That requires analysis of the totality proof.</p>",
        "id": 541284035,
        "sender_full_name": "James E Hanson",
        "timestamp": 1758733904
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Formalization.20of.20arithmetic.3A.20Reviewer.20needed!/near/541284035\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Formalization.20of.20arithmetic.3A.20Reviewer.20needed!/near/540910499\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"892220\">Paweł Balawender</span> Thanks for the explanation. If I understand correctly, witness theorems you mentioned are telling us \"if proofs exist, then algorithms in certain complexities exist\", but that does not give us a translation procedure from proofs to algorithms, right? Would the case be easier when the proofs are intuitionistic (not using excluded middle)?</p>\n</blockquote>\n<p>These results don't really work the same way as constructive algorithm extraction (although they are related). What these theorems say is really \"If theory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> proves that algorithm <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> computes a total function, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> has time complexity <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>.\"</p>\n<p>The subtlety is going to be in terms of extracting a more specific bound (like a polynomial for polytime) from a given proof. That requires analysis of the totality proof.</p>\n</blockquote>\n<p>Yes, if you want to obtain a bound like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> time, this approach will not provide it yet.</p>\n<p>I would like to learn more about the complexity of finding a witness, given a (nonconstructive) proof as input. I saw some results about it being <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><msup><mi>C</mi><mn>1</mn></msup></mrow><annotation encoding=\"application/x-tex\">NC^1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span>-complete for some proof system, and since this is lower than LOGSPACE, it’s quite feasible</p>",
        "id": 541328118,
        "sender_full_name": "Paweł Balawender",
        "timestamp": 1758746809
    }
]