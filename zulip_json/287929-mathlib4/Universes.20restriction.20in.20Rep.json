[
    {
        "content": "<p>Currently, the category <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Rep#doc\">docs#Rep</a> wants the ring <code>k</code> and the group <code>G</code> to live in the same universe. In particular, in the case <code>k</code> is <code>ℤ</code> we have that <code>G</code> has to live in <code>Type</code>, for example in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Rep.ofAlgebraAut#doc\">docs#Rep.ofAlgebraAut</a>. This has the unpleasant consequence  that all our cohomology computations, for example Hilbert's theorem 90, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=sgroupCohomology.H1ofAutOnUnitsUnique#doc\">docs#sgroupCohomology.H1ofAutOnUnitsUnique</a> is now restricted to <code>K</code> and <code>L</code> in <code>Type</code>.</p>\n<p>Is this an accident or has someone already thought about this? Note that Hilbert's theorem 90 can be reformulated in very concrete terms, and it has nothing to do with cohomology or universes (see <code>exists_div_of_norm_eq_one</code> not yet in the docs).</p>",
        "id": 566392206,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767630085
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Rep</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">uk</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">uG</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uk</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">uG</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Action</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">G</span>\n</code></pre></div>\n<p>at least as a definition seems to work fine</p>",
        "id": 566395265,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767630904
    },
    {
        "content": "<p>Given it's an <code>abbrev</code>, I don't see what benefit the restriction would bring</p>",
        "id": 566395302,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767630914
    },
    {
        "content": "<p>I am not sure where the universe restriction stemmed from, but it was very helpful at the CFT workshop in Oxford this summer to steer our many Lean beginners away from universe headaches</p>",
        "id": 566395817,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767631066
    },
    {
        "content": "<p>Well, I surely don't want to give universes headaches to beginners, but mathlib should be as general as possible, especially since later headaches are surely worse...</p>",
        "id": 566396787,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767631349
    },
    {
        "content": "<p>I am having a look at <a href=\"https://github.com/leanprover-community/mathlib4/pull/33608\">#33608</a>, but it doesn't seem completely trivial.</p>",
        "id": 566400471,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767632413
    },
    {
        "content": "<p>I am not sure how to generalize the <code>Type u</code> in</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The monoidal functor sending a type `H` with a `G`-action to the induced `k`-linear</span>\n<span class=\"sd\">`G`-representation on `k[H].` -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">linearization</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Action</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Rep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"n\">free</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mapAction</span><span class=\"w\"> </span><span class=\"n\">G</span>\n</code></pre></div>",
        "id": 566401038,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767632551
    },
    {
        "content": "<p>I think the main hindrance is that <code>ModuleCat.free</code> isn't maximally universe polymorphic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"c1\">-- declare universes ahead of time for good ordering</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- info: Rep.{u} (k G : Type u) [Ring k] [Monoid G] : Type (u + 1) -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Rep</span>\n\n<span class=\"c1\">-- a copy of the definition, with distinct universe variables</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Rep'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Action</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">G</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: CategoryTheory.Rep'.{u, v, w} (k : Type v) (G : Type w) [Ring k] [Monoid G] : Type (max (max (max (u + 1) v) w) u)</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Rep'</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"n\">free</span><span class=\"w\"> </span><span class=\"n\">k</span>\n\n<span class=\"c1\">-- again a copy of the definition in Mathlib, but more polymorphism</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"n\">free'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→₀</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">lmapDomain</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">map_id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">lmapDomain_id</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"n\">map_comp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">lmapDomain_comp</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"sd\">/-- The monoidal functor sending a type `H` with a `G`-action to the induced `k`-linear</span>\n<span class=\"sd\">`G`-representation on `k[H].` -/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">linearization'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Action</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Rep'</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"n\">free'</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mapAction</span><span class=\"w\"> </span><span class=\"n\">G</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">universes</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">linearization'</span><span class=\"w\"> </span><span class=\"c1\">-- `Action (Type u) G ⥤ Rep'.{max u v, v, w} k G`</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n</code></pre></div>",
        "id": 566409044,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1767635279
    },
    {
        "content": "<p>all of which is to say, either a separate universe level, or the same universe level as <code>k</code> or <code>G</code> (presumably the first) when the prior is too general to be useful (in which case, because it's likely a net slowdown and doesn't have mathematical benefits, we don't want it)</p>",
        "id": 566409608,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1767635494
    },
    {
        "content": "<p>Well the problem is that modifying <code>free</code> breaks essentially everything in the rest of the file, and I am afraid that in fixing it we will just find another problem. But let me see...</p>",
        "id": 566411300,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767636087
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/33608\">#33608</a> now compiles: it is still not enough, but it is a start. The next step is to generalize the monoidal structure on <code>ModuleCat.{v}</code>, but let's see how is the bench.</p>\n<p>Tagging the usual suspects <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span></p>",
        "id": 566431264,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767644089
    },
    {
        "content": "<p>Note that we can just say that all our concrete statements are about number fields or similar objects, so we may just ignore <code>Type 37</code> and be happy with <code>Type</code>.</p>",
        "id": 566433112,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767644888
    },
    {
        "content": "<p>Bench is very bad :(</p>",
        "id": 566440300,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767647982
    },
    {
        "content": "<p>I suspect that many slow files in the algebra side of mathlib are because lean is being slow at solving universe problems. Can you make things better by giving more explicit universes?</p>",
        "id": 566442177,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1767648852
    },
    {
        "content": "<p>I can try tomorrow, but I am wondering if the headache is worth or not. Currently Hilbert's theorem 90 is the statement</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">groupCohomology</span><span class=\"bp\">.</span><span class=\"n\">exists_div_of_norm_eq_one</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">IsGalois</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsCyclic</span><span class=\"w\"> </span><span class=\"n\">Gal</span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">/</span><span class=\"n\">K</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Gal</span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">/</span><span class=\"n\">K</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Gal</span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">/</span><span class=\"n\">K</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"bp\">.</span><span class=\"n\">zpowers</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">norm</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>and I have no idea if having <code>K L : Type*</code> is interesting or not.  The theorem looks really less general, in the sense I am not sure we can deduce the general version by the current one (surely one can assume that <code>L</code> is in the same universe as <code>K</code> since the extension is finite, but <code>K</code> is a real issue).</p>",
        "id": 566442966,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767649251
    },
    {
        "content": "<p>Before I got interested in lean I had no interest in higher universes at all, and all the analysts are proving things about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> and not <code>Ulift.{u} Real</code> so somehow they managed to get away with working in <code>Type</code> whereas whenever I suggest we do this in algebra I'm always told that we should use the full functionality of the system :-/ </p>\n<p>It wouldn't surprise me if you can prove the general theorem from the <code>Type</code> version; this feels like how EGA reduces everything to the Noetherian case. Given L/K a finite extension in some arbitrary universes, and x in L, find L0 and K0 finitely generated over their prime subfields and L0 containing x, with the same Galois group (this is exactly the kind of thing that one can do), find isomorphic fields in Type and etc etc. In fact I suspect that it's quite rare in practice that you can find a reasonable statement in algebra which can't be deduced from a result in Type.</p>",
        "id": 566445477,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1767650512
    },
    {
        "content": "<p>I agree it's possible, it's just not super easy.</p>",
        "id": 566445590,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767650573
    },
    {
        "content": "<p>One could imagine a tactic doing it. One thing that really struck me about FLT was realising that all the groups, rings and fields which show up really are in <code>Type</code>.</p>",
        "id": 566446882,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1767651246
    },
    {
        "content": "<p>I am thinking about sections of a sheaf obtained via sheafification, that I guess lives in a bigger universe, but I don't have a concrete example. Of course all our concrete case are doable in <code>Type</code>, but if you use the general construction the result may be in <code>Type 1</code>: well, you know very well the story about FLT and large cardinals :)</p>",
        "id": 566447270,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767651458
    },
    {
        "content": "<p>I'm glad people care about non-zero universes because that means I can call ordinals a well-order and surreals a linearly ordered field without having to CAPITALIZE EVERYTHING LIKE CONWAY DOES FOR SOME REASON</p>",
        "id": 566488006,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1767681792
    },
    {
        "content": "<p>Waterhouse 1975 has an example of a presheaf on affine schemes that has no flat sheafification in the same universe. If you happen to want general sheafification to be a functor, then you need to raise the universe level.</p>",
        "id": 566489498,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1767682887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Universes.20restriction.20in.20Rep/near/566446882\">說</a>：</p>\n<blockquote>\n<p>One could imagine a tactic doing it. One thing that really struck me about FLT was realising that all the groups, rings and fields which show up really are in <code>Type</code>.</p>\n</blockquote>\n<p>I think it is really hard to have a tactic for this, since I have in mind that some categorical constructions aren't just trivially stable under change universes. Anyway, I remember some universe level of totally unrelated things need to be the same in <code>Rep</code> related stuffs, this indeed need some generalization.</p>",
        "id": 566490038,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1767683261
    },
    {
        "content": "<p>Yes I totally agree that once you go to categories, you need universes.</p>",
        "id": 566495029,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1767686463
    },
    {
        "content": "<p>I suppose I should mention that Waterhouse's paper (Basically bounded functors and flat sheaves) does not really advocate raising the universe level. Instead, his position is more or less that we shouldn't consider \"all presheaves\", because there is a very well-behaved subcategory of presheaves for which sheafification is a functor to the same universe level, and this subcategory contains everything relevant to geometry.</p>",
        "id": 566644005,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1767747421
    },
    {
        "content": "<p>So we want to prove some theorems on nimbers and this universe restriction has come to bite us.</p>",
        "id": 571107223,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1769800854
    },
    {
        "content": "<p>Well one option is to reopen Riccardo's PR, and argue that the bench isnt really bad because we're adding lots of new theorems (namely more polymorphic versions of current theorems). Maybe this is a bullet we have to bite.</p>",
        "id": 571190771,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769860924
    },
    {
        "content": "<p>also, it's possible that the bench will improve now that <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/kernel.20universe.20normalization.20issue/with/570920516\">#lean4 &gt; kernel universe normalization issue</a> is getting traction</p>",
        "id": 571191168,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769861211
    },
    {
        "content": "<p>Nothing has changed there yet (but I agree that it might cause an improvement if something is changed)</p>",
        "id": 571191839,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769861824
    },
    {
        "content": "<p>Note that my PR doesn't compile, I stopped fixing it at some point because of the bench.</p>",
        "id": 571193360,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1769863173
    },
    {
        "content": "<p>There was something not completely trivial about <code>ModuleCat</code> being monoidal.</p>",
        "id": 571193385,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1769863192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Universes.20restriction.20in.20Rep/near/566442966\">said</a>:</p>\n<blockquote>\n<p>I can try tomorrow, but I am wondering if the headache is worth or not. Currently Hilbert's theorem 90 is the statement</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">groupCohomology</span><span class=\"bp\">.</span><span class=\"n\">exists_div_of_norm_eq_one</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">IsGalois</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsCyclic</span><span class=\"w\"> </span><span class=\"n\">Gal</span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">/</span><span class=\"n\">K</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Gal</span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">/</span><span class=\"n\">K</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Gal</span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">/</span><span class=\"n\">K</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"bp\">.</span><span class=\"n\">zpowers</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">norm</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>and I have no idea if having <code>K L : Type*</code> is interesting or not.</p>\n</blockquote>\n<p>For context, we need the additive version of Hilbert 90 in order to prove that the nimbers 2^2^n are fields, and nimbers are a type alias of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ordinal#doc\">docs#Ordinal</a> and thus come with a universe bump. The fields are finite, yes, but using <code>Shrink</code> here just introduces new headaches.</p>",
        "id": 571733615,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770143302
    }
]