[
    {
        "content": "<p>Is there a convenient way to export all the items in one namespace into another? Ideally we would have a syntax like <code>export foo</code>  in the namespace <code>bar</code> which exports all the terms in <code>foo</code> to <code>bar</code>. It seems currently, I need to list all the terms in the bracket, namely <code>export foo (t_1 ... t_n)</code> where in my case <code>n = 10</code> but for higher <code>n</code> it might make sense to have a command to export everything, and another command to exclude some exports. Would it be a good idea to add such a command?</p>",
        "id": 547753402,
        "sender_full_name": "Sina Hazratpour",
        "timestamp": 1761753079
    },
    {
        "content": "<p>You can definitely write such a command using metaprogramming.<br>\nIf we want to add this to Mathlib/Core Lean: probably not, unless there is a really compelling use case for it.</p>",
        "id": 547767222,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1761756633
    },
    {
        "content": "<p>This is in the namespace CWComplex: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">export</span><span class=\"w\"> </span><span class=\"n\">RelCWComplex</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pairwiseDisjoint</span><span class=\"w\"> </span><span class=\"n\">disjoint_openCell_of_ne</span><span class=\"w\"> </span><span class=\"n\">openCell_subset_closedCell</span>\n<span class=\"w\">  </span><span class=\"n\">cellFrontier_subset_closedCell</span><span class=\"w\"> </span><span class=\"n\">cellFrontier_union_openCell_eq_closedCell</span><span class=\"w\"> </span><span class=\"n\">map_zero_mem_openCell</span>\n<span class=\"w\">  </span><span class=\"n\">map_zero_mem_closedCell</span><span class=\"w\"> </span><span class=\"n\">isCompact_closedCell</span><span class=\"w\"> </span><span class=\"n\">isClosed_closedCell</span><span class=\"w\"> </span><span class=\"n\">isCompact_cellFrontier</span>\n<span class=\"w\">  </span><span class=\"n\">isClosed_cellFrontier</span><span class=\"w\"> </span><span class=\"n\">closure_openCell_eq_closedCell</span><span class=\"w\"> </span><span class=\"n\">skeletonLT_top</span><span class=\"w\"> </span><span class=\"n\">skeleton_top</span><span class=\"w\"> </span><span class=\"n\">skeletonLT_mono</span>\n<span class=\"w\">  </span><span class=\"n\">skeleton_mono</span><span class=\"w\"> </span><span class=\"n\">skeletonLT_monotone</span><span class=\"w\"> </span><span class=\"n\">skeleton_monotone</span><span class=\"w\"> </span><span class=\"n\">closedCell_subset_skeletonLT</span>\n<span class=\"w\">  </span><span class=\"n\">closedCell_subset_skeleton</span><span class=\"w\"> </span><span class=\"n\">closedCell_subset_complex</span><span class=\"w\"> </span><span class=\"n\">openCell_subset_skeletonLT</span>\n<span class=\"w\">  </span><span class=\"n\">openCell_subset_skeleton</span>\n<span class=\"w\">  </span><span class=\"n\">openCell_subset_complex</span><span class=\"w\"> </span><span class=\"n\">cellFrontier_subset_skeletonLT</span><span class=\"w\"> </span><span class=\"n\">cellFrontier_subset_skeleton</span>\n<span class=\"w\">  </span><span class=\"n\">cellFrontier_subset_complex</span><span class=\"w\"> </span><span class=\"n\">iUnion_cellFrontier_subset_skeletonLT</span>\n<span class=\"w\">  </span><span class=\"n\">iUnion_cellFrontier_subset_skeleton</span><span class=\"w\"> </span><span class=\"n\">closedCell_zero_eq_singleton</span><span class=\"w\"> </span><span class=\"n\">openCell_zero_eq_singleton</span>\n<span class=\"w\">  </span><span class=\"n\">cellFrontier_zero_eq_empty</span><span class=\"w\"> </span><span class=\"n\">isClosed</span><span class=\"w\"> </span><span class=\"n\">skeletonLT_union_iUnion_closedCell_eq_skeletonLT_succ</span>\n<span class=\"w\">  </span><span class=\"n\">skeleton_union_iUnion_closedCell_eq_skeleton_succ</span><span class=\"w\"> </span><span class=\"n\">iUnion_skeletonLT_eq_complex</span>\n<span class=\"w\">  </span><span class=\"n\">iUnion_skeleton_eq_complex</span><span class=\"w\"> </span><span class=\"n\">eq_of_not_disjoint_openCell</span><span class=\"w\"> </span><span class=\"n\">disjoint_skeletonLT_openCell</span>\n<span class=\"w\">  </span><span class=\"n\">disjoint_skeleton_openCell</span><span class=\"w\"> </span><span class=\"n\">skeletonLT_inter_closedCell_eq_skeletonLT_inter_cellFrontier</span>\n<span class=\"w\">  </span><span class=\"n\">skeleton_inter_closedCell_eq_skeleton_inter_cellFrontier</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Does this count as as a (compelling) use case?</p>\n<p>My would-be use case is less long but can imagine other similar cases even longer than the above.</p>",
        "id": 547781378,
        "sender_full_name": "Sina Hazratpour",
        "timestamp": 1761760895
    },
    {
        "content": "<p>But we don't export all declarations from <code>CWComplex</code> to <code>RelCWComplex</code>. And <a href=\"https://github.com/leanprover-community/mathlib4/pull/30131\">#30131</a> is trying to make that use case nicer.</p>",
        "id": 547795755,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1761765634
    },
    {
        "content": "<p>I was the one suggesting Sina to bring this up on Zulip, because I noticed the analogy with <code>open</code>: <code>export Foo (bar)</code> is functionally the same as a persistent <code>open Foo (bar)</code>, but <code>open</code> supports more syntaxes, like <code>open Foo</code> and <code>open Foo hiding bar</code> and I couldn't explain why the analogous syntax didn't exist for <code>export</code>.</p>",
        "id": 547817309,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1761774115
    },
    {
        "content": "<p>Sina's use case is <a href=\"https://github.com/leanprover-community/mathlib4/pull/31064\">#31064</a>, to add <code>SemiCartesianMonoidalCategory</code> without disturbing the existing users of <code>CartesianMonoidalCategory</code>.</p>",
        "id": 547817443,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1761774176
    },
    {
        "content": "<p>I see. But I still don't see the use case.</p>\n<p>If you literally want to export everything from <code>SemiCartesianMonoidalCategory</code>, then why don't you do that manually for all projections of the structure, and afterwards just don't declare anything in the namespace <code>SemiCartesianMonoidalCategory</code> anymore, directly do it in <code>CartesianMonoidalCategory</code>, even if it's really about <code>SemiCartesianMonoidalCategory</code>.</p>\n<p>This doesn't work if some lemmas would be stated slightly differently in the two cases (we have this when working with CWComplex/RelCWComplex), but it seems to work fine in this case(?)</p>",
        "id": 547909257,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1761823427
    }
]