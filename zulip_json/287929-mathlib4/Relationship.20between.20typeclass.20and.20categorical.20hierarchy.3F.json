[
    {
        "content": "<p>Suppose I have a hierarchy of typeclasses and morphisms </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">AMor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"kn\">class</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">AMorClass</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">CMor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AMor</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"kn\">class</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">CMorClass</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AMorClass</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"c1\">-- Instances and coercions elided</span>\n</code></pre></div>\n<p>and then I bundle them to get a category. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ACatObj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">bundled</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BCatObj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">bundled</span><span class=\"w\"> </span><span class=\"n\">B</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">bundledHom</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">AMor</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">bundledHom</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">CMor</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"c1\">-- 1/4:</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">AAMorCat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ACatObj</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">LargeCategory</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">ACat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">BundledHom</span><span class=\"bp\">.</span><span class=\"n\">category</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">AMor</span>\n</code></pre></div>\n<p>Aach pairing of (A/B)CatObj and (A/C)Mor forms a subcategory of ACat/AMor (I can prove this for the BCatObj+CMor case). How do I lift the results from my typeclass development, to these categories (eg. using the equations I've developed in terms of <code>A</code>, <code>B</code>, <code>AMor</code> and <code>CMor</code>). Is there some canonical way to mechanize this type of thing in mathlib? I could imagine hand-rolling coercions or functors between categories, but I'm not sure how that would scale if my typeclass hierarchy was deeper.</p>",
        "id": 493103575,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1736608179
    },
    {
        "content": "<p>See <code>Mathlib.Algebra.Category.Ring.Basic</code> for the prototypical example. It is all pretty manual / boiler-plate-y.</p>",
        "id": 493132931,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736634969
    },
    {
        "content": "<p>The <code>bundled</code> approach also fails for things like ModuleCat or FinVec, where the typeclass takes more than a single argument</p>",
        "id": 493137780,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736640007
    },
    {
        "content": "<p>That's exactly what I was looking for, thanks for the link! Fortunately my structure has only one argument.</p>",
        "id": 493210629,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1736706307
    }
]