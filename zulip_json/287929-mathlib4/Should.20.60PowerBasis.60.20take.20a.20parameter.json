[
    {
        "content": "<p>In my continued attempts to refactor <code>IsAdjoinRootMonic</code> to be easier to use, I have turned my attention to <code>PowerBasis</code> (which is logically equivalent but parameterised differently).<br>\nI have an idea to make <code>PowerBasis</code> into a <code>Prop</code> parameterised by its generating element. So, rather than \"here is a power basis\" - \"this element generates a basis\". My thought was this would make the definition more flexible.<br>\nDoes anyone have any thoughts on this or any rationale for the original design for <code>PowerBasis</code>?</p>",
        "id": 556722342,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1763335234
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> tagging you as the original author of the file</p>",
        "id": 556722388,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1763335307
    },
    {
        "content": "<p>I think one point of power basis is to contain the basis as data. I would suggest you to first develop the <code>Prop</code> valued analog, replace all the statements on  <code>PowerBasis</code> that does not mention the basis to that predicate, and we will probably have a better idea about if we should remove <code>PowerBasis</code> or not.</p>",
        "id": 556725708,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1763338796
    },
    {
        "content": "<p>I have done / am doing this<br>\nwhat criteria should I be judging by?</p>",
        "id": 556725793,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1763338897
    },
    {
        "content": "<p>The motivation for the original design was for the development of Dedekind domains, to have <code>PowerBasis R S</code> as a way to say <code>S = R[α]</code> without particularly caring about which <code>α</code> we have. But I suppose that just like <code>IsAdjoinRoot</code> we would like to control this <code>α</code> (and especially its defeqs) better, so I can certainly imagine that <code>IsPowerBasis R S α n</code> (or so) would be nicer in practice. Having to rewrite <code>pb.gen = α</code> and <code>pb.dim = n</code> all the time can get annoying :)</p>",
        "id": 556804900,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1763378966
    },
    {
        "content": "<p>For places taking a powerbasis as hypothesis, I'd like to see a reduction in the number of rewrites of the form <code>pb.gen = α</code> and <code>pb.dim = n</code>, and for places returning a powerbasis as conclusion, I'd like to see more <code>IsPowerBasis R S α n</code> for specific <code>α n</code> than <code>∃ α n, IsPowerBasis R S α n</code>.</p>",
        "id": 556805325,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1763379094
    },
    {
        "content": "<p>OK, I've now re-written the entire <code>PowerBasis</code> and <code>IsAdjoinRoot</code> API to depend on only the root/generator <code>x</code> as a parameter. My proposed design is the following:</p>\n<p>Fix <code>CommRing R</code>, <code>Ring S</code>, <code>Algebra R S</code>, <code>x : S</code>. The situation where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>=</mo><mi>R</mi><mo stretchy=\"false\">[</mo><mi>x</mi><mo stretchy=\"false\">]</mo><mo>≅</mo><mi>R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">⟨</mo><mi>f</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">S=R[x]\\cong R[X]/\\langle f\\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">⟩</span></span></span></span> is then described by</p>\n<ol>\n<li><code>hx : IsPrimitiveElement R x : Prop</code>, a predicate on <code>x</code> that then determines all other data: <code>hx.basis</code>, <code>hx.ker_aeval_eq_span_minpoly</code>, and so on.</li>\n<li><code>hS : IsAdjoinRootMonic S (f : R[X]) : Prop</code>, which is equivalent to <code>∃ x : S, IsPrimitiveElement R x ∧ minpoly R x = f</code>. This allows you to talk about properties of the extension <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi mathvariant=\"normal\">/</mi><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">S/R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, e.g. the degree, without having to fix a root. Note that unlike the current <code>IsAdjoinRootMonic</code>, this is a <code>Prop</code>! Of course you can still create the data (using choice) through definitions like <code>hS.root</code>, <code>hS.basis</code>, etc.</li>\n</ol>\n<p>I'd welcome feedback on this design in principle before I try to implement it in some concrete cases to see if it's better than what we have now.</p>",
        "id": 558912575,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1763921940
    },
    {
        "content": "<p>Hooray! Do you have some code for us to check out?</p>\n<p>So for the case where we don't care about the precise value of <code>x</code> nor <code>f</code>, we would write <code>∃ x : S, IsPrimitiveElement R x</code>? Or <code>∃ f : R[X], IsAdjoinRootMonic S f</code>? Or this would depend on the precise generality of the situation? We'd definitely need easy ways to convert back and forth (under the right assumptions).</p>\n<p>And for the case where we want to control both <code>x</code> and <code>f</code>, we'd say something like <code>IsPrimitiveElement R x ∧ minpoly R x = f</code>? I think we can live with writing that out, since it is not very verbose.</p>\n<p>Also, how does the conclusion of the primitive element theorem end up looking?</p>",
        "id": 559005137,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1763980564
    },
    {
        "content": "<p>The only mathematically relevant case I can think of where we don't care about either the root or the polynomial is showing that the resulting algebra is finite and free, which will be theorems of both forms. Generally you care about the root when you're reasoning about the elements of the algebra and about the polynomial when you're reasoning about the algebra as a whole. In any case it's trivial to convert between the two.</p>\n<p>My intention when we care about both was to use <code>IsPrimitiveElement R x ∧ minpoly R x = f</code>, yes. I could absolutely see having <code>f</code> as a parameter in <code>IsPrimitiveElement</code> alongside <code>x</code>, though it <em>is</em> uniquely determined. In that case the <code>IsAdjoinRootMonic</code> API could just use the <code>IsPrimitiveElement</code> API.</p>\n<p>The primitive element theorem just says <code>∃ x : S, adjoin R {x} = S</code>. Then there's a result that says that, when either<br>\n(a) <code>R</code> is a field, or<br>\n(b) <code>R</code> is an integrally closed domain and <code>S</code> is a domain and a torsion-free <code>R</code>-algebra<br>\nwe in fact have <code>IsPrimitiveElement x</code>.</p>\n<p>The name <code>IsPrimitiveElement</code> is therefore not ideal - happy to take suggestions for alternatives.</p>\n<p>Code will be provided shortly.</p>",
        "id": 559053143,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1763993103
    },
    {
        "content": "<p>Also, I'm not sure what to do about <code>IsAdjoinRoot</code>. It would be easiest to just get rid of it but then we do lose some generality. The most general approach would be:</p>\n<ol>\n<li>Define <code>IsAdjoinRoot</code></li>\n<li>Define <code>IsPrimitiveElement</code> and show the algebra satisfies <code>IsAdjoinRoot</code></li>\n<li>Define <code>IsAdjoinRootMonic</code> and show it's equivalent to <code>IsPrimitiveElement</code></li>\n</ol>",
        "id": 559054573,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1763993400
    },
    {
        "content": "<p>OK <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> the design is at <a href=\"https://github.com/artie2000/real_closed_field/blob/master/RealClosedField/PrimitiveElement.lean\">https://github.com/artie2000/real_closed_field/blob/master/RealClosedField/PrimitiveElement.lean</a></p>",
        "id": 559107666,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1764004958
    },
    {
        "content": "<p>Thanks! <span aria-label=\"octopus\" class=\"emoji emoji-1f419\" role=\"img\" title=\"octopus\">:octopus:</span> Right now, I need to go arrange dinner. Will check in as soon as I have some Lean time.</p>",
        "id": 559108216,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1764005106
    },
    {
        "content": "<p>I have been thinking about this for a bit, and wonder if it wouldn't be better if we split <code>IsPrimitiveElement</code> into two parts: <code>IsGeneratingElement R x</code> saying <code>adjoin R {x} = \\top</code>, and <code>IsPrimitiveElement</code> adding the <code>IsIntegralUnique</code> part. A lot of the basic properties you prove for primitive elements also hold for generating elements.</p>\n<p>It looks like you're working over integral domains, which loses us a tiny bit of generality compared to what we have now (<code>PowerBasis</code> basically doesn't use domains, and a lot of commutativity assumptions can be dropped there too). But I don't know from the top of my head if we actually use that generality in full, certainly I've always had the case of domains in the back of my mind and done all the generalizations opportunistically. Do you have something to point to as to why you chose this level of generality?</p>",
        "id": 560112115,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1764065169
    },
    {
        "content": "<p>As for actually implementing this in Mathlib, I think it's best if the first PR(s) only develop the theory of <code>IsPrimitiveElement</code>, without any replacements downstream. Then when we have enough theory, we can replace existing uses of <code>PowerBasis</code> and <code>IsAdjoinRoot</code> incrementally. (Development-wise I'd suggest you try and do a few trial replacements as you develop the theory, so we can be sure the results actually work well. But the list of PRs you open does not need to reflect your actual development history.)</p>",
        "id": 560112669,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1764065324
    },
    {
        "content": "<p>Let's stick with <code>IsPrimitiveElement R x ∧ minpoly R x = f</code> for now, we can always introduce a structure/abbrev if this turns out to be too much of a mouthful.</p>",
        "id": 560112960,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1764065412
    },
    {
        "content": "<p>Naming: as far as I know the term \"primitive element\" really only refers to the generator of a field extension (or sometimes to the generator of the field's multiplicative group). A bit of generalizing of names is very common in Mathlib, so I don't think it's really bad practice to generalize here too. I'm happy to be corrected by others though.</p>\n<p>If you really dislike the current naming, and you agree with my idea to split the <code>adjoin R {x} = \\top</code> hypothesis off, maybe <code>IsGenerating</code> / <code>IsGeneratingUnique</code> to match <code>IsIntegral</code>/<code>IsIntegralUnique</code>?</p>",
        "id": 560113813,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1764065662
    },
    {
        "content": "<p>I think I already did prove everything I can prove for generating elements, for generating elements. It turns out it's not actually very much! But I can make it a structure so we eg get dot notation for  <code>reprAdjoinEqTop</code>.</p>\n<p>I am not working over an integral domain, and nor do I assume commutativity. I am not sure which declarations you are referring to. Indeed, <code>IsPrimitiveElement</code> is equivalent to <code>PowerBasis</code>, as demonstrated by <code>.basis</code> and <code>.ofBasis</code>.</p>",
        "id": 560121102,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1764067753
    },
    {
        "content": "<p>Ah sorry, I didn't notice that <code>R</code> <code>S</code> get redefined in <a href=\"https://github.com/artie2000/real_closed_field/blob/master/RealClosedField/PrimitiveElement.lean#L176\">https://github.com/artie2000/real_closed_field/blob/master/RealClosedField/PrimitiveElement.lean#L176</a></p>",
        "id": 560122279,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1764068084
    },
    {
        "content": "<p>Okay, I am confident now that this will be a useful replacement if we get the details above worked out! <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 560122391,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1764068113
    },
    {
        "content": "<p>Yeah the stuff above that line is all preliminaries</p>",
        "id": 560124547,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1764068715
    },
    {
        "content": "<p>OK I've done some more work. The current design satisfies the following:<br>\n(1) All existing material from <code>PowerBasis</code> and <code>IsAdjoinRoot</code> is maintained.<br>\n(2) All material is as general as possible.<br>\n(3) All <code>def</code>s are directly accessible via dot notation in all structures.<br>\nUnfortunately this means there are now 4 different structures and slightly weird definitions.</p>",
        "id": 560378849,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1764160421
    }
]