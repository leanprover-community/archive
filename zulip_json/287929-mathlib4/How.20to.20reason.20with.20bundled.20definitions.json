[
    {
        "content": "<p>How can I reason with bundled definitions?<br>\nFor example, I want a hypothesis that says a specific function is a group/graph isomorphism-</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Algebra.Group.Equiv.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Maps</span>\n\n<span class=\"w\"> </span><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">comp_group_iso_implies_injective</span>\n<span class=\"w\">   </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">   </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">   </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"w\">   </span><span class=\"o\">:</span>\n<span class=\"w\">   </span><span class=\"c1\">-- what hypothesis says \"(g ∘ f) is an isomorphism from A to C\"?</span>\n<span class=\"w\">   </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃*</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span>\n<span class=\"w\">   </span><span class=\"n\">f.Injective</span>\n<span class=\"w\">   </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"w\"> </span><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">comp_graph_iso_implies_injective</span>\n<span class=\"w\">   </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">   </span><span class=\"o\">(</span><span class=\"n\">gA</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">gC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"w\">   </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"w\">   </span><span class=\"o\">:</span>\n<span class=\"w\">   </span><span class=\"c1\">-- what hypothesis says \"(g ∘ f) is an isomorphism from gA to gC\"?</span>\n<span class=\"w\">   </span><span class=\"n\">gA</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">gC</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span>\n<span class=\"w\">   </span><span class=\"n\">f.Injective</span>\n<span class=\"w\">   </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I'm looking for a way to say \"the expression (...) is an isomorphism between ...\", but a bundled approach for it is also fine- a way to convert the existingisomorphism property to a new bundled property that contains the two functions and the fact that their composition is an isomorphism would also work. But crucially the point is to avoid restating the definition of isomorphism.<br>\nWdyt?<br>\n(I'm new to Lean btw, this is probably a common pitfall)</p>",
        "id": 526313627,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1751253748
    },
    {
        "content": "<p>you could write <code>(f : A -&gt; B) (g : B -&gt; C) (iso : A ≃* C) (iso_eq_comp : iso = g ∘ f)</code></p>\n<p>though it seems like what you're really trying to prove in these specific examples is just <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Injective.of_comp#doc\">docs#Function.Injective.of_comp</a> ... it just so happens that the injectivity of the composition is due to being an equivalence</p>",
        "id": 526315456,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1751255649
    },
    {
        "content": "<p>I guess my point is that these lemmas are trying to do too much... you only need a simpler fact in each case</p>",
        "id": 526315785,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1751255972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/287929-mathlib4/topic/How.20to.20reason.20with.20bundled.20definitions/near/526315456\">said</a>:</p>\n<blockquote>\n<p>you could write <code>(f : A -&gt; B) (g : B -&gt; C) (iso : A ≃* C) (iso_eq_comp : iso = g ∘ f)</code></p>\n<p>though it seems like what you're really trying to prove in these specific examples is just <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Injective.of_comp#doc\">docs#Function.Injective.of_comp</a> ... it just so happens that the injectivity of the composition is due to being an equivalence</p>\n</blockquote>\n<p>Isn't there a better solution without using equality like that?<br>\nAlso, using the <code>Injective.of_comp</code> still requires showing that the composition is injective, which brings us back to requiring that the composition is an isomorphism</p>",
        "id": 526315835,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1751256004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/287929-mathlib4/topic/How.20to.20reason.20with.20bundled.20definitions/near/526315785\">said</a>:</p>\n<blockquote>\n<p>I guess my point is that these lemmas are trying to do too much... you only need a simpler fact in each case</p>\n</blockquote>\n<p>How do you suggest formalizing the theorem: \"if g∘f is an isomorphism between groups A and B, then f is injective\"</p>",
        "id": 526316159,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1751256267
    },
    {
        "content": "<p>I'm saying that I don't know if it's a useful theorem to have</p>\n<p>the critical parts are these lemmas:<br>\n1) an isomorphism is injective<br>\n2) if (g ∘ f) is injective, then f is injective</p>\n<p>then, in whatever larger proof you're working on, you tie these together using the equality <code>iso = (g ∘ f)</code> to get where you need to go</p>",
        "id": 526316574,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1751256655
    },
    {
        "content": "<p>There's no larger proof, and I'm trying to avoid using equality like that</p>",
        "id": 526316709,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1751256768
    },
    {
        "content": "<p>you could use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Bijective#doc\">docs#Function.Bijective</a> which is unbundled, but it sounds like you want to talk about specific kinds of isomorphisms</p>",
        "id": 526316937,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1751256976
    },
    {
        "content": "<p>you could write your own definition, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isMulEquiv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃*</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>",
        "id": 526317188,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1751257156
    },
    {
        "content": "<p>maybe someone else will have a better idea... it's tricky to work with these bundled structures in a way that specifies the content of the structure</p>",
        "id": 526317467,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1751257417
    },
    {
        "content": "<p>The issue is that I want to use defeq instead of semantical equality<br>\nAnd the gist of my question is since bundled definitions are so common in mathlib, whether Lean or mathlib have some mechanism to unbundle definitions when talking about them, like some fancy syntax or macro. Or alternatively, if it's common to define both bundled and unbundled definitions of stuff (like group isomorphism) and prove they're interchangable</p>",
        "id": 526319593,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1751259317
    }
]