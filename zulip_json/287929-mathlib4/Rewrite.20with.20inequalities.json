[
    {
        "content": "<p>I saw Terence Tao complaining on mathstodon about the inability to use inequalities with <code>rw</code>, so I've tried to make a tactic <code>rwi</code> that takes an inequality rather than <code>x = y</code>.</p>\n<p>You can see a draft PR here <a href=\"https://github.com/leanprover-community/mathlib4/pull/8167\">https://github.com/leanprover-community/mathlib4/pull/8167</a></p>\n<p>There's a lot to clean up of course, but it is already functional enough to be useful in my opinion. I'd like some feedback on the general approach:</p>\n<ul>\n<li>Currently most of the work of doing the actual proof is done by gcongr. Is this the right approach? I'm concerned that it's not clear how I handle multiplications where one side can be proven to be negative, so maybe it's not flexible enough?</li>\n<li>I realized half way through the implementation that there isn't really much reason why this should just work for inequalities. It could work for any transitive relations. Should I try to do this or clean up what already works?</li>\n</ul>",
        "id": 400208083,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699047513
    },
    {
        "content": "<p>There is also a version of this tactic at <a href=\"https://github.com/teorth/symmetric_project/blob/master/SymmetricProject/Tactic/RwIneq.lean\">https://github.com/teorth/symmetric_project/blob/master/SymmetricProject/Tactic/RwIneq.lean</a></p>",
        "id": 400211002,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699049133
    },
    {
        "content": "<p>It will be interesting to look at the union of test cases and see whether both versions do the same thing.</p>",
        "id": 400211146,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699049207
    },
    {
        "content": "<p>It looks very similar, I think my tactic can do all of those examples and probably vice versa (except I can handle &gt; inequalities, but that is a trivial change).</p>\n<p>It's interesting that we ended up with such similar solutions. I guess if I go further and try to make it work with arbitrary transitive relations then this won't have been a waste. (Although I learned a lot doing this so not complaining)</p>",
        "id": 400212135,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699049857
    },
    {
        "content": "<p>It feels a bit stupid that we worked independently. It didn't occur to me that someone else could be doing it at the same time.</p>",
        "id": 400212292,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699049966
    },
    {
        "content": "<p>I was discussing this Terence Tao privately and he is already using my version in his repository because going through the Mathlib review process would clearly have been too slow.</p>",
        "id": 400212410,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699050019
    },
    {
        "content": "<p>My version clearly doesn't do <code>rw_ineq [h]</code> when <code>h</code> starts with a forall. I didn't think about handling this.</p>",
        "id": 400212510,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699050091
    },
    {
        "content": "<p>It also doesn't do the</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"mi\">100</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rwi</span> <span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">]</span>\n  <span class=\"n\">guard_target</span> <span class=\"bp\">=ₛ</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"mi\">100</span> <span class=\"bp\">-</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>example which is clearly not the behavior that Tao was expecting. He expected the goal after rewriting to be <code>b * c ≤ 100 - a</code>, but one can argue that you're doing the right thing.</p>",
        "id": 400212673,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699050181
    },
    {
        "content": "<p>I was trying to be as similar to <code>rw</code> as possible</p>",
        "id": 400212811,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699050257
    },
    {
        "content": "<p>My initial implementation didn't use gcongr. I was manually traversing the expression and only changing values if they were in the right 'direction'. </p>\n<p>E.g. rw[ x: a &lt; b] would rewrite <code>a - a &lt;= a - a</code> to <code>b - a &lt;= a - b</code> but this became complicated once I wanted to use mono/congr lemmas and I thought it was kind of confusing</p>",
        "id": 400213264,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699050590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rewrite.20with.20inequalities/near/400212292\">said</a>:</p>\n<blockquote>\n<p>It feels a bit stupid that we worked independently. It didn't occur to me that someone else could be doing it at the same time.</p>\n</blockquote>\n<p>I already mentioned in the past that <span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> has a working ordered rewrite tactic.</p>",
        "id": 400213539,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699050788
    },
    {
        "content": "<p>Feels like we should get something into mathlib before someone else writes one</p>",
        "id": 400213766,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699050924
    },
    {
        "content": "<p>And what is an ordered rewrite tactic? Is it what we are discussing now?</p>",
        "id": 400213795,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699050953
    },
    {
        "content": "<p>It seems your version can essentially do all my test except the one testing for the missing <code>instantiateMVar</code> bug:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bound</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"mi\">10</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">5</span> <span class=\"bp\">≤</span> <span class=\"mi\">10</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)</span>\n  <span class=\"n\">rwi</span> <span class=\"o\">[</span><span class=\"n\">h'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">bound</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 400214329,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699051312
    },
    {
        "content": "<p>Your version complains that <code>Provided hypothesis must be an inequality</code> because you forgot to instantiate the meta-variable that <code>have</code> created because the type of <code>h' </code> was not given upfront.</p>",
        "id": 400214441,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699051371
    },
    {
        "content": "<p>There are also difference because I call <code>linarith only [h]</code> after <code>rwi [h]</code> to cleanup side-goals.</p>",
        "id": 400214486,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699051415
    },
    {
        "content": "<p>Note also that you can use <code>withRWRulesSeq</code> to avoid repeating code from <code>rw</code>.</p>",
        "id": 400214810,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699051521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rewrite.20with.20inequalities/near/400214810\">said</a>:</p>\n<blockquote>\n<p>Note also that you can use <code>withRWRulesSeq</code> to avoid repeating code from <code>rw</code>.</p>\n</blockquote>\n<p>that would have saved a lot of time</p>",
        "id": 400214949,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699051598
    },
    {
        "content": "<p>You can see how it's used in my code.</p>",
        "id": 400214976,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699051616
    },
    {
        "content": "<p>so presumably the reasoning behind using <code>linarith only [h]</code> is that <code>positivity</code> isn't good enough? Or are you ending up with side goals which aren't of the form <code>0 &lt; x</code>?</p>",
        "id": 400215041,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699051682
    },
    {
        "content": "<p>About your \"It could work for any transitive relations.\", note that my version uses <code>Trans.trans</code> for all transitivity proof. But I think the gain is virtual since I think <code>gcongr</code> itself works only for inequalities and congruence modulo an integer.</p>",
        "id": 400215099,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699051696
    },
    {
        "content": "<p>To be honest the example I had was generating a side goal <code>a \\le b</code> when I had assumption <code>h : a &lt; b</code>.</p>",
        "id": 400215133,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699051735
    },
    {
        "content": "<p>I guess you are doing a better analysis in case of mixing <code>&lt;</code> and <code>\\le</code>.</p>",
        "id": 400215155,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699051760
    },
    {
        "content": "<p>Anyway, as a Mathlib maintainer I'm very happy to see a new contributor writing tactics, so I strongly suggest that we try to get <em>your</em> version in Mathlib.</p>",
        "id": 400215339,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699051915
    },
    {
        "content": "<p>So I suggest that you clean up your code, fix your instantiated metavar bug, refactor using <code>withRWRulesSeq</code> and write documentation. Feel free to steal anything you want from my version, including examples or documentation.</p>",
        "id": 400215446,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699051992
    },
    {
        "content": "<p>What's the reasoning behind only wanting to do the rewrite on one side? What I'm doing makes more sense to me, but then I'm not Terence Tao</p>",
        "id": 400215536,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699052054
    },
    {
        "content": "<p>That would be the natural thing to do from a mathematical point of view. But I guess that doing more can' t hurt. I will point him towards this thread.</p>",
        "id": 400215701,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699052193
    },
    {
        "content": "<p>I guess we could have rwi_lhs and rwi_rhs as well</p>",
        "id": 400216932,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699052923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rewrite.20with.20inequalities/near/400213795\">said</a>:</p>\n<blockquote>\n<p>And what is an ordered rewrite tactic? Is it what we are discussing now?</p>\n</blockquote>\n<p>It is a generalised rewrite tactic restricted to <code>≤</code>/ <code>&lt;</code>. So yes.</p>",
        "id": 400217530,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699053228
    },
    {
        "content": "<p>I can imagine this tactic being useful for much more general targets than we have discussed here.</p>\n<p>For example if the target is <code>x ∈ (T ⋃ S)</code> then you should be able to rewrite with <code>R ⊆ S</code> to make the target <code>x ∈ (T ⋃ R)</code>. But as you suggest I'll clean up what I've already got first.</p>",
        "id": 400218421,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699053932
    },
    {
        "content": "<p>Yaël, I clearly missed the moment you announced that, maybe because I didn't recognize the name. Where is that third version?</p>",
        "id": 400222023,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699056813
    },
    {
        "content": "<p>Hi, thanks for doing this.  For my own project (which will likely end in a few days) Patrick's tool is working fine (although it is noticeably slow for complex inequalities, and particularly for failure cases where no match was possible), but it would be great to have a standard tool in the mathlib.</p>\n<p>I was mostly thinking of applying the tool when the inequalities are already in a somewhat normal form in which they are \\leq or &lt; rather than \\geq or &gt;, and all terms are non-negative when this is relevant due to multiplication operators (or all bases are at least one when working with exponentiation).  In such contexts, <code>rw_ineq</code> would naturally only operate on the RHS on hypotheses and on the LHS on goals, but one could indeed extend it to the other side as well after making some guesses as to what is intended to be \"positive\".  I guess by default assuming all terms are positive and/or have base greater than equal to one would be simplest (if one wants to work with negative expressions one can first pull out an explicit minus sign to get <code>rw_ineq</code> to flip the sign of the inequality as needed).   I was also guided a bit by the philosophy of making the behavior as predictable as possible, which I understood was a desirable trait of Lean tactics (particularly non-finishing ones).  </p>\n<p>It's a neat idea to extend to other relations than inequalities, though I don't know how often that use case would actually come up in practice.</p>",
        "id": 400223689,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699057674
    },
    {
        "content": "<p>Sebastian, the mention of speed remind me this is also something that needs to be improved. <code>gcongr</code> is faster when you give it a pattern. Maybe there is an efficient way to build a pattern in our case.</p>",
        "id": 400239720,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699065561
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rewrite.20with.20inequalities/near/400222023\">said</a>:</p>\n<blockquote>\n<p>Yaël, I clearly missed the moment you announced that, maybe because I didn't recognize the name. Where is that third version?</p>\n</blockquote>\n<p>Here it is: <a href=\"#narrow/stream/116395-maths/topic/Mandelbrot.20-.20Lean.204.20version/near/396158326\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Mandelbrot.20-.20Lean.204.20version/near/396158326</a></p>",
        "id": 400266027,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699083521
    },
    {
        "content": "<p>Just FYI, this looks like a much restricted version of Coq's <a href=\"https://coq.inria.fr/doc/V8.18.0/refman/addendum/generalized-rewriting.html\">generalised rewriting</a>. There was a previous attempt to bring this to Lean, but it's a rather big project (that probably won't lead to a paper).</p>",
        "id": 400277848,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1699090632
    },
    {
        "content": "<p>Was about to say the same thing. Rewriting with arbitrary relations is great! Unless I am missing something it has big a big overlap with <code>gconcr</code>, and as a user who likes the principle of least surprise I’d hope that such a <code>grw</code> would work precisely when <code>gcongr</code> work, and that the same congruence lemma setup will work for both tactics.</p>",
        "id": 400278686,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699090888
    },
    {
        "content": "<p>Yaël, is there any <em>visible</em> code?</p>",
        "id": 400303558,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699108252
    },
    {
        "content": "<p>The coq documentation starts with \"This chapter presents the extension of several equality related tactics to work over user-defined structures (called setoids) that are equipped with ad-hoc equivalence relations meant to behave as equalities.\" so either this documentation is very misleading or this isn't related. Inequalities are <em>not</em> \"meant to behave as equalities\".</p>",
        "id": 400303584,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699108298
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rewrite.20with.20inequalities/near/400278686\">said</a>:</p>\n<blockquote>\n<p>Was about to say the same thing. Rewriting with arbitrary relations is great! Unless I am missing something it has big a big overlap with <code>gconcr</code>, and as a user who likes the principle of least surprise I’d hope that such a <code>grw</code> would work precisely when <code>gcongr</code> work, and that the same congruence lemma setup will work for both tactics.</p>\n</blockquote>\n<p>This is precisely the case. Both my version and Sebastian's version are built on top of <code>gcongr</code>.</p>",
        "id": 400303641,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699108345
    },
    {
        "content": "<p>The documentation is misleading (or rather, the introduction does not capture the full generality): Coq's generalised rewriting also works with relations that are merely reflexive or symmetric or transitive or any combination of the three properties. See <a href=\"https://coq.inria.fr/doc/V8.18.0/refman/addendum/generalized-rewriting.html#rewriting-and-nonreflexive-relations\">here</a>.</p>",
        "id": 400305806,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1699110338
    },
    {
        "content": "<p>By the way, I'm already using rw_ineq several times in my project <a href=\"https://github.com/teorth/symmetric_project\">https://github.com/teorth/symmetric_project</a> so one could possibly use those instances as more complicated unit tests for any future version of the tool (they are quite far from being a minimal working example, but could perhaps serve as an example of use cases \"in the wild\").  The tool is primarily used in main.lean and main_lemmas.lean.</p>\n<p>EDIT: In particular, these complex use cases could perhaps be used to benchmark performance.  For complex rewrites, `rw_ineq' can take several seconds on my laptop, and I ended up splitting my main computation somewhat artificially into several smaller lemmas in order to keep under the heartbeat limit.</p>",
        "id": 400305896,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699110418
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rewrite.20with.20inequalities/near/400303558\">said</a>:</p>\n<blockquote>\n<p>Yaël, is there any <em>visible</em> code?</p>\n</blockquote>\n<p>It should be somewhere in <a href=\"https://github.com/Human-Oriented-ATP/lean-tactics\">https://github.com/Human-Oriented-ATP/lean-tactics</a> but I can't find it right now.</p>",
        "id": 400306246,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699110728
    },
    {
        "content": "<p>I just hope that by tagging <span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> enough times he will end up explaining himself what his tactic does and where to find it <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 400306420,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699110892
    },
    {
        "content": "<p>Is this the work of Gowers' team?</p>",
        "id": 400306585,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699111003
    },
    {
        "content": "<p>Yes, exactly.</p>",
        "id": 400307470,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699111645
    },
    {
        "content": "<p>Hi there, I've indeed also made a tactic that allows for rewriting with a preorder. It does not work using gcongr, but it is made independently. It uses an interactive point&amp;click system that allows for the user to click on expression for interacting with the move. Yael told me yesterday, that working with explicit subexpression positions (which are pasted into the editor by the interactive system) is not very robust  because it is hard to maintain, so he said it would be better to encode position using patterns. This is something that still has to be figured out, but I think there is a lot of potential for point&amp;click moves in Lean.</p>\n<p>Anyways, my program works with a type class for monotone functions that I made. It works with any preorder and it doesn't need to be the default instance, so for example one can rewrite with the divisibility relation on natural numbers. Using this type class inference, I find out for every function that it is either monotone increasing or monotone decreasing, and with respect to which order this is. It also works under binders (in particular set builder notation, and quantifiers). In the alternative representation of the proof state that I'm working with, it can unfold foralls, exisist, conditions and conjunctions in the used hypothesis. However if this is going into mathlib, this will probably have to be limited to unfolding foralls and conditions (using forallMetaTelescopeReducing). It doesn't work with multiplication, because thay requires the side condition that the number you multiply by is either positive or negative  and I wasn't sure how to choose which one it would be.</p>\n<p>I've made some more tactics that work with the point and click system. The simplest on is unfold, which unfolds the definition of the selected expression, so this is the first one I'd like to get into Mathlib. There is als an apply and a rewrite tactic. Notably the rewrite tactic allows for rewriting bound variables which rw in Lean does not. For these moves, I've also made library search variants, which searches the Mathlib library forblemmas that can be aplied, or rewritten or order rewritten with in the selected position. I think this would be a very useful addition to Mathlib.</p>",
        "id": 400313765,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1699117209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rewrite.20with.20inequalities/near/400306420\">said</a>:</p>\n<blockquote>\n<p>I just hope that by tagging <span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> enough times he will end up explaining himself what his tactic does and where to find it <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>\n</blockquote>\n<p>It worked</p>",
        "id": 400313976,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1699117345
    },
    {
        "content": "<p>Nice! Are you using the framework I provided for <code>conv?</code>, <code>congrm?</code> and the <code>calc</code> widget or are you also duplicating that? I wanted to to the <code>unfold</code> and <code>rw</code> soon so it would be nice if you could start PRing to Mathlib before everything is duplicated.</p>",
        "id": 400315081,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699118482
    },
    {
        "content": "<p>More generally it looks like a big project so announcing here that you are working on it would have been very welcome. There is a <em>lot</em> to do and duplicating efforts because of secret projects is no the most efficient approach.</p>",
        "id": 400315165,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699118574
    },
    {
        "content": "<p>I haven't done the work on the interactive system, I've made the tactics. But our code doesn't depend on the conv? congrm? calc framework. The idea for the unfolding move was that you type unfold?, then in the editor you click on an expression and then click on the button for pasting the text into the editor.</p>",
        "id": 400317059,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1699120775
    },
    {
        "content": "<p>What do you think about how to represent selected subexpression position? The way it works now is that a list of integers is pasted into the editor, using the Subexpr.Pos encoding of positions.</p>",
        "id": 400317404,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1699121032
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rewrite.20with.20inequalities/near/400313765\">said</a>:</p>\n<blockquote>\n<p>However if this is going into mathlib, this will probably have to be limited to unfolding foralls and conditions (using forallMetaTelescopeReducing). It doesn't work with multiplication, because thay requires the side condition that the number you multiply by is either positive or negative  and I wasn't sure how to choose which one it would be.</p>\n</blockquote>\n<p>I'm not sure whether this is feasible, but one could imagine for every side condition to implement a \"default\" choice (probably the \"positive\" choice) which is pursued unless the opposite choice is explicitly available in the available hypotheses.  So, for instance if one ends up wanting to upper bound <code>a * b</code>, one can assume by default that <code>a</code> is non-negative and look for upper bounds on <code>b</code> (or vice versa, or both), unless the assertion <code>a \\leq 0</code> or <code>a &lt; 0</code> (or something definitionally equivalent to this) is provided, in which case one looks for lower bounds on <code>b</code> instead.  Similarly when seeking upper bounds on an expression like <code>a^b</code> one would assume by default that <code>a \\geq 1</code> and look for upper bounds on <code>b</code> unless it is explicitly provided that <code>a \\leq 1</code> in which case one would seek lower bounds on <code>b</code>.  This could perhaps be overengineering though.  As a workaround, one can use ordinary <code>rw</code> to replace negative quantities by the negation of positive quantities, and to replace bases less than one by their reciprocal, before invoking the <code>rw_ineq</code> tool, so that one can take advantage of the default option in all cases.</p>",
        "id": 400330849,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699136743
    },
    {
        "content": "<p>This exact issue came up in <code>gcongr</code>, and our approach was just to observe that usage of <code>mul_pos</code> compared to <code>mul_pos_of_neg_of_neg</code> was about 100:1, aka this is only a problem in theory, in practice the choice is obvious</p>",
        "id": 400330975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699136850
    },
    {
        "content": "<p>I added the unfold widget in <a href=\"https://github.com/leanprover-community/mathlib4/pull/8218\">#8218</a> since it is a trivial one. It currently support selecting only one location because I think this is by far the most common case, but adding more locations would be easy.</p>",
        "id": 400434325,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699230479
    },
    {
        "content": "<p>Let me clarify since the question was asked on GitHub. PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/8218\">#8218</a> has nothing to do with Jovan's code. It is an illustration of the fact that the <em>current</em> framework already allows easily writing such widgets.</p>",
        "id": 400550343,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699283037
    },
    {
        "content": "<p>I think I found <a href=\"https://github.com/Human-Oriented-ATP/lean-tactics/blob/5b3ddf271cc2abb42627ba7920349671b163fc58/MotivatedMoves/GUI/MotivatedProofList.lean#L310\">Jovan's version</a> and it inserts a cryptic string into the Lean file while my version inserts an ordinary <code>unfold</code> code that is indistinguishable from code written without using the widget.</p>",
        "id": 400551456,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699283320
    },
    {
        "content": "<p>Ah okay, makes sense.</p>",
        "id": 400555638,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699284483
    },
    {
        "content": "<p>I had a look at your unfold, and what I see is that unfolding <code>1+1</code> gives <code>instHAdd.1 1 1</code>. In my version of unfold, it automatically reduces projections, so that this would turn into <code>Add.add 1 1</code>, which I think is a better design.</p>",
        "id": 400603607,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1699301584
    },
    {
        "content": "<p>It is really not meant to be used in that case so I didn't think about that.</p>",
        "id": 400603990,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699301775
    },
    {
        "content": "<p>My version of unfold also allows you to click on a projection, to unfold it, or on a let expression, to zeta-reduce it, or to click on a lambda that is applied to an argument, to beta-reduce it. These sorts of features really require a position to be selected by the user and the position to be pasted into the editor.</p>",
        "id": 400628582,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1699313820
    },
    {
        "content": "<p>At that point it should just emit a <code>change</code> tactic</p>",
        "id": 400628965,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699314096
    },
    {
        "content": "<p>Letting me poke around in the goal (changing it in a defeq way) and then Lean figuring out the corresponding <code>change</code> call would be awesome (although prone to round-tripping errors presumably)</p>",
        "id": 400629549,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1699314490
    },
    {
        "content": "<p>Is there a tracking issue for the promised lands of round-tripping that were never found?</p>",
        "id": 400631780,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699315768
    },
    {
        "content": "<p>What do you mean with round-tripping?</p>",
        "id": 400636424,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1699318234
    },
    {
        "content": "<p>Cut and paste from the infoview reliably working as input to tactics</p>",
        "id": 400636565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1699318313
    },
    {
        "content": "<p>Why wouldn't it be possible to reliably print expressions as input to tactics?</p>",
        "id": 400636879,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1699318453
    },
    {
        "content": "<p>Because the input to tactics aren't <code>Expr</code>essions they're <code>Syntax</code>. The process of going from the former to the latter is called <em>delaboration</em>, and going from the latter to the former is <em>elaboration</em>. Right now our delaboration isn't a perfectly adequate \"inverse\".</p>",
        "id": 400643545,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1699322122
    },
    {
        "content": "<p>Surely it would be possible to check whether the specific result of delaboration is valid, and if not, then run the delaborator again with pp.all set to true (or some other setting that makes the delaboration more specific)? Or is even that not reliable enough?</p>",
        "id": 400787201,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1699378543
    },
    {
        "content": "<p>Are there fundamental problems with the conversion between <code>Syntax</code> and <code>Expr</code>, or is it simply that nobody has fixed <code>delab</code>?</p>",
        "id": 400788498,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1699379143
    },
    {
        "content": "<p>I found some more time to work on this, and I updated my PR with a different approach. <a href=\"https://github.com/leanprover-community/mathlib4/pull/8167\">https://github.com/leanprover-community/mathlib4/pull/8167</a></p>\n<p>1) The tactic is called <code>grw</code> (consistent with how <code>gcongr</code> generalizes <code>congr</code>)<br>\n2) The tactic code does not know anything specific to inequalities. It looks for lemmas tagged <code>@[grw]</code> and some of these happen to describe how to rewrite inequalities. There are also lemmas for handling <code>x ∈ X</code> or <code>X ⊂ Y</code>.<br>\n3) The code is much cleaner than before, in my opinion.</p>\n<p>I think it's ready for review.</p>\n<p>The tactic is already useful, but this is my todo list:</p>\n<ul>\n<li>Test against the examples <span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> mentioned</li>\n<li>Optimize performance. <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> mentioned providing a pattern and I think there are other 'easy wins'. (e.g. maintain an index of <code>@[grw]</code> lemmas indexed by relation, sort of like <code>gcongr</code> does)</li>\n<li>Add <code>grw_lhs</code> and <code>grw_rhs</code>, for only operating on one side of a relation at once. I think I can use all the same infrastructure, just the initial <code>kabstract</code> call will need to change.</li>\n<li>Apply rewrite rules inside binders.</li>\n</ul>\n<p>I think at least some of that could happen in a followup PR.</p>",
        "id": 401610075,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699792287
    },
    {
        "content": "<p>Why can't you reuse the <code>gcongr</code> attribute? What are examples of lemmas that you want to use but <code>gcongr</code> doesn't or the other way around?</p>",
        "id": 401622478,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699803839
    },
    {
        "content": "<p>Most of the actual work is still done by <code>gcongr</code>, so those lemmas are still being used. The <code>grw</code> lemmas are just used for the first step. These lemmas look more like transitivity statements than congruence ones. Maybe I'm missing something obvious, but I don't see how you would use gcongr lemmas to achieve this.</p>",
        "id": 401622820,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699804225
    },
    {
        "content": "<p>Ok, then I misunderstood the above description and I will need to look at the PR to understand.</p>",
        "id": 401622928,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699804364
    },
    {
        "content": "<p>Although I guess the next natural question is: why not using the <code>Trans</code> instance database if you need to tag transitivity lemmas?</p>",
        "id": 401623014,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1699804479
    },
    {
        "content": "<p>I think you would lose some flexibility there. E.g. we could add a <code>grw</code> lemma showing how to convert <code>Finite x</code> to <code>Finite y</code> using <code>x &gt; y</code>. Now I look at it though, there are a lot of trans lemmas out there. Maybe it could do both?</p>\n<p>Right now I'm trying to fix the performance because it is really slow</p>",
        "id": 401626091,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699807619
    },
    {
        "content": "<p>I've got <code>grw</code> working as a replacement to <code>rw_ineq</code> in the project <span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span>  linked.</p>\n<p>I put in a few <code>withReducible</code>s and it's fast now (&gt;100x faster than <code>rw_ineq</code> in many cases) seemingly without breaking it. The biggest difference in use is that <code>rw_ineq</code> allows side goals whereas <code>grw</code> expects any side goal that comes up in <code>grw</code> to be solved with either <code>assumption</code> or <code>positivity</code>, otherwise it fails. In practice that looks like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw_ineq</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span>\n<span class=\"bp\">.</span> <span class=\"n\">prove</span> <span class=\"n\">side</span> <span class=\"n\">goal</span>\n</code></pre></div>\n<p>turns into</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">prove</span> <span class=\"n\">side</span> <span class=\"n\">goal</span>\n<span class=\"n\">grw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This might be a bit annoying, but it makes it much more backwards compatible since adding new side goal dischargers to <code>grw</code> is safe with this api. Since I intend this to be used nonterminally, I think that's quite important.</p>\n<p>Currently the worst thing about using <code>grw</code> is how useless the errors are.</p>",
        "id": 401632617,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699814506
    },
    {
        "content": "<p>Great! About three “side goals” that almost every tactic has to deal with: it doesn't seem to compose and scale well if every tactic does their own little thing. I expect you'll soon run into cases where some lemma have side goals that need something stronger, but where just adding them to the environment is too tedious.</p>\n<p>It would be better if there is a commonly used, commonly accepted extensible tactic for “side goals that must be solved in an otherwise unrelated tactics”. As the developer if <code>grw</code> you shouldn't have to make decisions here - and as user I want to be able to predict what happens without reading tactic code or docs.</p>\n<p>Could <code>aesop</code> be that? I hope it subsumes <code>assumption</code> and <code>positivity</code>, and can easily be extended with more logic?</p>\n<p>Or is there already an accepted tactic for this?</p>\n<p>(This is getting off topic for <code>grw</code> because it is more a matter of consistency across tactics.)</p>",
        "id": 401633986,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699815906
    },
    {
        "content": "<p>I think the closest thing to an accepted tactic for this is <code>gcongr_discharger</code>, which just calls <code>positivity</code>.</p>",
        "id": 401634352,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699816349
    },
    {
        "content": "<p>aesop could probably work, the side goal discharger is much less performance sensitive than the main goal discharger, plus there is an expectation that the statement is actually provable</p>",
        "id": 401634449,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699816452
    },
    {
        "content": "<p>Using the same as <code>gcongr</code> is already a good step towards the principle of least surprise :-)</p>",
        "id": 401634563,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699816578
    },
    {
        "content": "<p>That would mean not having <code>assumption</code>, in which case I would have to add unfilled side goals to the context instead of failing. This is what other tactics do, but I don't like it because if people depend on this then improving the tactic would break proofs (like how adding simp lemmas breaks nonterminal simps)</p>",
        "id": 401634766,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699816816
    },
    {
        "content": "<p>Yeah, that's strange. So gcongr will automatically discharge positivity assumptions, but not assumptions that are already in the context? Isn't that suboptimal? (Or does positivity happen to run assumption?)</p>",
        "id": 401636539,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699819161
    },
    {
        "content": "<p>I tend to expect <code>tactic!</code> to try harder than <code>tactic</code> to do whatever the tactic is expected to do.  Thus, I would expect <code>grw</code> to not try anything, other than the \"<code>rw</code>\".  The one with the discharger would then simply be \"first do <code>grw</code>, then try assumption/positivity/Aesop/norm_num/...\" as appropriate.</p>",
        "id": 401637476,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1699819983
    },
    {
        "content": "<p>We have to do <em>something</em> with side goals otherwise the tactic is useless for anything involving a multiplication.</p>",
        "id": 401638225,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699820787
    },
    {
        "content": "<p>Can you use <code>gcongr_forward</code> (which subsumes <code>assumption</code>)?  That's the discharger <code>gcongr</code> uses for \"main\" goals.</p>",
        "id": 401638245,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1699820820
    },
    {
        "content": "<p>Could do but we'd still want <code>positivity</code></p>",
        "id": 401638355,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1699820960
    },
    {
        "content": "<p>I looked briefly at your code and I agree that since this is explicitly supposed to be a discharger of <em>side</em> goals, <code>gcongr_forward</code> is not appropriate.</p>",
        "id": 401639516,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1699822374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"650732\">Sebastian Zimmer</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rewrite.20with.20inequalities/near/401634766\">said</a>:</p>\n<blockquote>\n<p>That would mean not having <code>assumption</code>, in which case I would have to add unfilled side goals to the context instead of failing. This is what other tactics do, but I don't like it because if people depend on this then improving the tactic would break proofs (like how adding simp lemmas breaks nonterminal simps)</p>\n</blockquote>\n<p>Personally I prefer this approach.  It's true that there is a possibility of it breaking proofs in the future, but it is an easy thing to clean up after (<em>much</em> easier than cleaning up after a broken nonterminal simp would be).  And it's very user-friendly to present unsolved goals to the user -- much more user-friendly than making the user anticipate beforehand what facts might be needed and write them out.</p>",
        "id": 401639816,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1699822756
    },
    {
        "content": "<p>I made the two requested changes</p>\n<ul>\n<li>Use <code>gcongr_discharger</code> to discharge the sidegoals (instead of <code>try positivity; assumption</code></li>\n<li>Add unfilled side goals to the context</li>\n</ul>",
        "id": 402089355,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1700004438
    },
    {
        "content": "<p>I've left some review comments. This is great!</p>",
        "id": 402092136,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700005885
    },
    {
        "content": "<p>I've fixed the review comments, is there any obstacle to merging this?</p>\n<p>There's still stuff I want to do</p>\n<ul>\n<li>Try using transitivity lemmas in addition to the <code>@[grw]</code> lemmas</li>\n<li>Add <code>grw_lhs</code> and <code>grw_rhs</code></li>\n<li>Rewrite inside binders</li>\n</ul>\n<p>But IMO this all can be done in future PRs</p>",
        "id": 402920267,
        "sender_full_name": "Sebastian Zimmer",
        "timestamp": 1700346529
    }
]