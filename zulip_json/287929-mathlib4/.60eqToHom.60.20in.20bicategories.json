[
    {
        "content": "<p>As mentionned in <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/lax.2Foplax.2Fpseudo-trans.20between.20lax.2Foplax.2Fpseudo-functors/with/532589282\">#mathlib4 &gt; lax/oplax/pseudo-trans between lax/oplax/pseudo-functors</a> , I am in the process of defining <a href=\"https://ncatlab.org/nlab/show/icon\">icons</a> between lax functors of bicategories, with end goal being encoding the 2-cell functoriality of the 2-nerve 2-functor (which, in bundled form, is from the strict 2-category of bicategories, strictly unitary pseudofunctors and icons to the bicategory of pseudofunctors <code>LocallyDiscrete (SimplexCategoryᵒᵖ)</code> to <code>Cat</code>).</p>\n<p>One of the difficulty here is that the definition of icons is \"evil\" and bundles an equality of objects in bicategories (icons only make sense between lax/pseudo-functors with <em>equal</em> values on objects), so some <code>eqToHom</code> 1-cells infrastructure is needed. The definition of such 1-cell is easy: one can just replace <code>Category</code> by <code>CategoryStruct</code> in the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.eqToHom#doc\">docs#CategoryTheory.eqToHom</a>, and the most important <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.eqToHom_refl#doc\">docs#CategoryTheory.eqToHom_refl</a> still holds. However, one cannot hope that such 1-cell compose well: the bicategorical analogue of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.eqToHom_trans#doc\">docs#CategoryTheory.eqToHom_trans</a> does not hold AFAICT.</p>\n<p>For the definitions of icons, this is a problem: one cannot blindly require that the <code>app</code> component of the underlying oplax natural transformation of lax functors is equal to an <code>eqToHom</code>, otherwise the vertical composition of two icons is not an icon (because the app component will be <code>eqToHom _ ≫ eqToHom _</code>. Instead, \"being an identity 1-cell\" in a bicategory should mean \"being some composition of <code>eqToHom _</code>\", and given such a composition, we can extract an equality, and an essentially unique isomorphism with a single eqToHom.</p>\n<p>Concretely, my plan to deal with this is to refactor <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.MorphismProperty#doc\">docs#CategoryTheory.MorphismProperty</a> to take as input a type with a <code>CategoryStruct</code> instance rather than a type with a <code>Category</code> instance and similarly for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.MorphismProperty.ContainsIdentities#doc\">docs#CategoryTheory.MorphismProperty.ContainsIdentities</a> , so that we can introduce an <code>identities</code> morphism property (which should be some kind of multiplicative closure of the empty morphism property, except that we might need to adapt for non-strict associativity in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.MorphismProperty.MultiplicativeClosure#doc\">docs#CategoryTheory.MorphismProperty.MultiplicativeClosure</a>), and an icon will then be an oplax natural transformations <code>eta</code> such that <code>identities (η.app a)</code>.</p>\n<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> does that seem like a reasonable plan to you? Would you be okay with me generalizing some <code>MorphismProperty</code> defs to <code>CategoryStruct</code> and introducing <code>identities : MorphismProperty C</code> for <code>[CategoryStruct C]</code>?</p>\n<p>The other possible plan would be to restrict to icons between lax functors between strictly unitary bicategories (for these, I think <code>eqToHom</code> do compose correctly), and use a <a href=\"https://kerodon.net/tag/00FG\">strictification result from a general bicategory to a strictly unitary bicategory</a> (note that Kerodon calls \"2-categories\" what we call bicategories), but I think this would be more of a pain to work with in practice.</p>",
        "id": 532674965,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1754296258
    },
    {
        "content": "<p>Very interesting problem! I don't know about the 2-nerve 2-functor, but I'm wondering if using the non-evil definition (isos of objects) would suffice to define the 2-functor, at least up to equivalence.</p>\n<p>I'm also wondering about <code>identities (η.app a)</code>, I thought <code>η.app a</code> only lived in a bicategory, but <code>identities : MorphismProperty C</code>?</p>",
        "id": 532687301,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1754300070
    },
    {
        "content": "<p>I do not see any problem extending <code>MorphismProperty</code> to <code>CategoryStruct</code>, as long as the API does not change in the case of a category :-)</p>",
        "id": 532691346,
        "sender_full_name": "Joël Riou",
        "timestamp": 1754301315
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"587858\">Fernando Chu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60eqToHom.60.20in.20bicategories/near/532687301\">said</a>:</p>\n<blockquote>\n<p>Very interesting problem! I don't know about the 2-nerve 2-functor, but I'm wondering if using the non-evil definition (isos of objects) would suffice to define the 2-functor, at least up to equivalence.</p>\n<p>I'm also wondering about <code>identities (η.app a)</code>, I thought <code>η.app a</code> only lived in a bicategory, but <code>identities : MorphismProperty C</code>?</p>\n</blockquote>\n<p>By extending <code>MorphismProperty C</code> to <code>[CategoryStruct C]</code>, we can make sense of <code>MorphismProperty</code> for 1-cell in a bicategory (bicategories extend <code>CategoryStruct</code>), this is why I’m proposing this small refactor: this way, we can uniformly use the infrastructure for morphism properties both for 1 and (1-cell) 2-categorical constructions.</p>\n<p>You can read about the 2-nerve in e.g <a href=\"https://arxiv.org/abs/2002.06055\">Johnson-Yau, section 5.5</a>, or <a href=\"https://arxiv.org/abs/math/0607271\">the original reference by Lack &amp; Paoli</a>. </p>\n<p>Regarding the \"non-evil definition\", the problem here is that as soon as you start relaxing stuff in this business, you have no good way around the tricategorical structure of bicategories: oplax transformations won’t compose nicely, and you’ll have to use modifications (3-cells) to correct that. We have modifications, but I guess if we can avoid tricategories for now let’s just do that.</p>\n<p>Also, when thinking of monoidal categories as 1-object bicategories, icons correspond exactly to monoidal natural transformations of lax monoidal functors, so already to state a bi-equivalence between suitable 2-categories of monoidal categories and certain bicategories of 1-object bicategories, these might be nice to have.  I also think the 2-nerve of a monoidal category seen as a 1-object bicategory is an interesting object.</p>\n<p>Also, I guess already the 2-nerve talks about strictly unitary pseudofunctors, which are evil but \"1 level above\" (they talk about equality of 1-cells), so some level of evilness is still \"required\" in this story (just like nerves of 1-categories are \"evil\": they are about manipulation on the algebraic structure of the objects of the 1-category of categories.)</p>",
        "id": 532691545,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1754301380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60eqToHom.60.20in.20bicategories/near/532691346\">said</a>:</p>\n<blockquote>\n<p>as long as the API does not change in the case of a category :-)</p>\n</blockquote>\n<p>That shouldn’t happen. Worse case scenario is a very slight modification of <code>MultiplicativeClosure</code> to adapt for non-associative case (which will then reduce to existing usual constructions in the case of a category or a strict bicategory)</p>",
        "id": 532691979,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1754301535
    },
    {
        "content": "<p>A quick update on this: experiments go in the direction that working with an <code>identities</code> morphism property is a royal pain, and that this does not free from DTT hell that much, so I’m not sure I’ll land the refactor mentioned above.</p>\n<p>While it did make the definition of composition of icons possible, I overlooked that it makes strict associativity of composition false as is (again, <code>eqToHom</code> don’t associate in general...).<br>\n<del>I’m starting to think that there is not much ways around defining the type of icons as some quotient of a (type equivalent to a) subtype of oplax natural transformations, by a relation that identifies the <code>naturality</code> fields through a family of given eqToHoms 1-cells.</del> I may need to think a bit more</p>",
        "id": 533261377,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1754561625
    },
    {
        "content": "<p>Quite interesting that type theory really makes evil-ness hard. What I think would work is bundling the action of objects apart from everything else. And then a lax functor <code>F</code> is such an action of objects <code>F0</code> together with (...). That way we can talk about icons between lax functors extending an specific action of objects <code>F0</code>. Then to talk about other functors with an action of objects <code>G0</code> such that <code>G0 = F0</code> we could use rewrite and develop some lemmas. (this is essentially the displayed category trick)</p>\n<p>This is ofc extremely painful, but I can't think of anything else that gets strictness of associativity.</p>",
        "id": 533462909,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1754659188
    },
    {
        "content": "<p>That a pseudofunctor has a specified action on objects is something that we will need to explore in a certain future as I discussed it with <span class=\"user-mention\" data-user-id=\"648495\">@Christian Merten</span> . For example, when defining the 4 (or 6) operations on derived categories of sheaves, we want to define four pseudofunctors to the bicategory of categories (or two pseudofunctors to the bicategory of adjunctions) on the same \"objects\". Allowing the <code>obj</code> field of <code>Pseudofunctor</code> to be a parameter of a structure <code>PseudofunctorWithObj</code> (and redefining <code>Pseudofunctor</code> accordingly) would be helpful, but there is no hurry!</p>",
        "id": 533571519,
        "sender_full_name": "Joël Riou",
        "timestamp": 1754737146
    },
    {
        "content": "<p>I settled for the solution of giving up defining composition of icons as composition of underlying natural transformations: this way, the <code>app</code> component of the composition is definitionally equal to a single <code>eqToHom</code> and we can work with that. (naturality 2-cells are then the naturality 2-cells of the composition, up to some <code>eqToHoms</code> and \"transitivity isomorphisms\" of <code>eqToHom</code>s: it's really not advisable to unfold this composition in practice!)<br>\nThis makes the proof of strict associativity possible, although quite painful because one must \"pull\" the non-<code>eqToHom</code> morphisms towards the center of (quite big) expressions, and then cancel the outer morphisms (which are all built out of <code>eqToHom</code>s, so reduce to identities as soon as their source and targets are the same). This is easy in principle, but quite long to implement.</p>\n<p>So I won't be the one defining <code>LaxFunctorWithObj</code> nor <code>PseudofunctorWithObj</code>, or at least not this time.</p>",
        "id": 533574828,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1754740955
    },
    {
        "content": "<p>Some basic <code>eqToHom</code> infrastructure in bicategories is at <a href=\"https://github.com/leanprover-community/mathlib4/pull/28242\">#28242</a></p>",
        "id": 533818742,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1754926359
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/28243\">#28243</a> uses the new file as a home for two existing lemmas about bicategories and <code>eqToHom</code>. I’ve used <code>noshake --update</code> rather than <code>noshake --fix</code> so that the breakage from the move remains minimal.</p>",
        "id": 533818879,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1754926409
    }
]