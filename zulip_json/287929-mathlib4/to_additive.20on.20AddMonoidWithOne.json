[
    {
        "content": "<p>I'm having trouble with the following <code>to_additive</code>, which I think should work since I can prove the additive version with the same proof (as seen below):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">pnat_multipliable_iff_multipliable_succ'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommMonoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Multipliable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Multipliable</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">pnatEquivNat</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">multipliable_iff</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">pnat_summable_iff_summable_succ'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">pnatEquivNat</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">summable_iff</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>The <code>to_additive</code> is giving the following error, which I'm not sure how to fix:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Aplication</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">application</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">Zero</span><span class=\"bp\">.</span><span class=\"n\">toOfNat0</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝².</span><span class=\"n\">toOne</span>\n<span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"n\">inst</span><span class=\"bp\">✝².</span><span class=\"n\">toOne</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_11</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_11</span>\n</code></pre></div>",
        "id": 532260268,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1754038588
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/27841\">#27841</a></p>",
        "id": 532347122,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1754068338
    },
    {
        "content": "<p>You don't lose any generality if you take <code>f : ℕ → α</code> instead</p>",
        "id": 532347431,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754068468
    },
    {
        "content": "<p>so drop the <code>AddMonoidWithOne</code></p>",
        "id": 532347494,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754068496
    },
    {
        "content": "<p>hmm</p>",
        "id": 532347617,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754068547
    },
    {
        "content": "<p>I guess you end up with <code>f ↑(x + 1)</code> on the rhs instead of <code>f (↑x + 1)</code></p>",
        "id": 532347768,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754068600
    },
    {
        "content": "<p>now I'm not sure anymore</p>",
        "id": 532347808,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754068615
    },
    {
        "content": "<p>yeah the coercions become annoying which is why I want this version.</p>",
        "id": 532348189,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1754068750
    },
    {
        "content": "<p><del>Just from the error message it looks like <code>to_additive</code> isn't translating <code>One</code> to <code>Zero</code>. I seem to recall there was some issue with those typeclasses, </del>maybe <span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> can explain?</p>",
        "id": 532355105,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1754071419
    },
    {
        "content": "<p>or perhaps it is translating 1 to 0 when it shouldn't in this case?</p>",
        "id": 532355403,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1754071540
    },
    {
        "content": "<p>Yeah I don't think it should be trying to translate it and there is something in the documentation about this for multiplicative instances, but I can't seem to get it to ignore <code>R</code> when doing this.</p>",
        "id": 532355703,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1754071686
    },
    {
        "content": "<p>Yes, this is a known limitation of <code>to_additive</code>. The heuristics are smart enough to see that <code>1 : ℕ</code> should not be translated to <code>0 : ℕ</code>, but it still tries to translate <code>1 : R</code> to <code>0 : R</code>, because it doesn't take into account that the <code>R</code> has an <code>AddMonoidWithOne</code> instance. For example, a consequence of this is that the theory of <code>AddMonoidAlgebra</code> and <code>MonoidAlgebra</code> are duplicated in the same file, instead of using <code>to_additive</code>.</p>\n<p>I think there are two ways in which this problem might be solved (in a hypothetical future fix).</p>\n<ol>\n<li>introduce the syntax <code>@[to_additive (dont_translate := R)</code> to tell <code>to_additive</code> to not translate multiplicative things relating to <code>R</code>.</li>\n<li>in addition to the above, let <code>to_additive</code> infer from <code>AddMonoidWithOne R</code> that <code>R</code> should not be translated. This would involve tagging all instances that are multiplicative and additive, such as <code>Ring</code>, <code>Field</code> and <code>AddMonoidWithOne</code>.</li>\n</ol>",
        "id": 532365144,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1754075829
    },
    {
        "content": "<p><code>@[to_additive (dont_translate := R)]</code> doesnt seem to work, it says:  <code>unexpected identifier; expected 'attr' or 'reorder'</code></p>",
        "id": 532369539,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1754077818
    },
    {
        "content": "<p>also how/where do I tag the instances in your second point?</p>",
        "id": 532369596,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1754077849
    },
    {
        "content": "<p>These are potential solutions, but they have not been implemented.</p>",
        "id": 532369653,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1754077877
    },
    {
        "content": "<p>oh sorry I misread!</p>",
        "id": 532370093,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1754078094
    },
    {
        "content": "<p>I've though about this a bit more, and I think we can add the following heuristic:<br>\nFor any to_additive constant, let the nth argument be the first multiplicative argument (there is already code that looks for this, related to <code>to_additive_relevant_arg</code>). Then when translating this constant, we check if anything in the nth argument has been tranlated. If not, we also don't translate this constant.</p>\n<p>In the original example, One.toOfNat was translated to Zero.toOfNat, but its argument inst.toOne was not translated. Hence this heuristic would fix that, so that neither gets translated. Hopefully this will also make <code>MonoidAlgebra</code> work with to_additive.</p>\n<p>I won't be able to work on this for a week now so if anyone wants to try, feel free to.</p>\n<p>cc <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span></p>",
        "id": 533001715,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1754436141
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/to_additive.20on.20AddMonoidWithOne/near/533001715\">said</a>:</p>\n<blockquote>\n<p>I've though about this a bit more, and I think we can add the following heuristic:<br>\nFor any to_additive constant, let the nth argument be the first multiplicative argument (there is already code that looks for this, related to <code>to_additive_relevant_arg</code>). Then when translating this constant, we check if anything in the nth argument has been tranlated. If not, we also don't translate this constant.</p>\n<p>In the original example, One.toOfNat was translated to Zero.toOfNat, but its argument inst.toOne was not translated. Hence this heuristic would fix that, so that neither gets translated. Hopefully this will also make <code>MonoidAlgebra</code> work with to_additive.</p>\n</blockquote>\n<p>I don't understand what you mean here. Can you expand it more?<br>\nUsually the \"first multiplicative argument\" is a type argument, which is often a variable, and so often nothing gets translated in this argument.</p>\n<p>If you mean \"look at the type-class argument(s), and see whether anything in that gets translated\", that might be an interesting idea. But the basic thing doesn't work. E.g. if we have something which uses the instance <code>CommMonoid.toMonoid (CommRing.toCommMonoid inst)</code> then <code>to_additive</code> will currently translate this to the (type-incorrect) <code>AddCommMonoid.toAddMonoid (CommRing.toCommMonoid inst)</code>, so we also have to block that translation. </p>\n<p>This gets complicated, but it might actually work. When we translate <code>foo a1 a2 ... an</code>, we first translate all arguments. Then we take (all?) the type-class arguments on the first multiplicative argument, and see if their translation changed anything. Then we translate <code>foo</code> to its additive version only if</p>\n<ol>\n<li>the current heuristic says we can change it</li>\n<li>the type-class arguments either changed or is a variable.</li>\n</ol>\n<p>Note: the recursive call of the translation might have to return a boolean stating \"I have changed my subexpression\", or more accurately \"the above test passed\", since for lemmas with <code>to_additive self</code>, the test can pass and we can replace <code>foo</code> with its additive version, without actually changing the term.</p>",
        "id": 533074188,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1754477003
    },
    {
        "content": "<p>Yes, that is what I meant, looking at the multiplicative type class argument. We could look at multiple type class arguments, but I don't think that would gain us more than just looking at the first one. In the algorithm that determines the <code>to_additive_relevant_arg</code>, it first finds the first argument whose type gets translated (i.e. the type class argument), and then if the first argument of that is a variable, then that is the relevant multiplicative argument.</p>\n<p>And indeed a good way to do this is to have the recursive call return a Bool to say whether anything has been tranlated in there. I hadn't thought of the case of the argument being a variable, that case should indeed also be tranlated.</p>",
        "id": 533080634,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1754479440
    },
    {
        "content": "<p>I've made <a href=\"https://github.com/leanprover-community/mathlib4/pull/28591\">#28591</a> that implements the above heuristic, and I've been able to use <code>@[to_additive]</code> on almost everything in <code>Algebra.MonoidAlgebra.Defs</code> <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 534962388,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1755526883
    },
    {
        "content": "<p>Oh great! thanks so much for doing this!</p>",
        "id": 534962478,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1755526911
    },
    {
        "content": "<p>I've encountered some limitations of my current approach, so I'm considering to instead do something closer to my original suggestion in this thread. For example:</p>\n<ul>\n<li>Figuring out whether an instance has changed isn't always as easy  as it seems. There can be an instance of type <code>Mul (MonoidAlgebra _ _)</code> which gets translated into an instance of type <code>Mul (AddMonoidAlgebra)</code>. My heuristic would pick this up as that it was changed, but since it is still a <code>Mul</code> instance, in should count as unchanged.</li>\n<li>Some functions, like <code>MulOpposite</code>, don't have an instance argument, so my heuristic doesn't work here.</li>\n<li>The following instance failed to be translated by my version of <code>to_additive</code>:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">isScalarTower</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SMulZeroClass</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SMulZeroClass</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">isScalarTower</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">k</span>\n</code></pre></div>\n<p>The problem is that although it knows to not translate <code>k</code> because it is a semiring, it still thinks that it should translate <code>SMul R S</code></p>",
        "id": 535089148,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1755595872
    },
    {
        "content": "<p>In your example, <code>R</code> appears along with <code>k</code> in <code>IsScalarTower R S k</code>. Since <code>k</code> isn't additivisable, this means that <code>R</code> isn't either</p>",
        "id": 535089924,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1755596172
    },
    {
        "content": "<p>That's the only constraint I could find</p>",
        "id": 535089974,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1755596192
    },
    {
        "content": "<p>Yes, but the issue is that at that point <code>to_additive</code> has already additivized <code>SMul R S</code></p>",
        "id": 535090186,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1755596268
    },
    {
        "content": "<p>I seriously doubt <code>to_additive</code> can be implemented with a single-pass algorithm</p>",
        "id": 535090421,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1755596355
    },
    {
        "content": "<p>My new idea, which is essentially what I had suggested at the start of this thread, is to have a way to tell <code>to_additive</code> which type arguments should not be translated. Then <code>to_additive</code> should treat these local variables the same way as it does constants marked with <code>to_additive_dont_translate</code>.</p>\n<p>And I would like it to infer these arguments automatically when possible, so that most of the time you can just write <code>@[to_additive]</code>. And in edge cases like my example above you might need to write <code>[to_additive (dont_translate := R S)]</code> (maybe the logic could be beefed up to do this automatically as well)</p>",
        "id": 535091525,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1755596709
    },
    {
        "content": "<p>By only looking at the type arguments, we can still fully support <code>MulOpposite</code>.</p>",
        "id": 535091746,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1755596776
    },
    {
        "content": "<p>btw, from the above PR, I've split out a small (general) fix: <a href=\"https://github.com/leanprover-community/mathlib4/pull/28625\">#28625</a></p>",
        "id": 535092201,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1755596918
    },
    {
        "content": "<p>I have now implemented (half of) my alternative fix at <a href=\"https://github.com/leanprover-community/mathlib4/pull/28637\">#28637</a>. It  implements the <code>(dont_translate := ...)</code> syntax, but doesn't implement any heuristics for figuring out the values automatically. Although I haven't yet tested this for <code>MonoidAlgebra</code>.</p>",
        "id": 535134199,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1755611481
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>, another option is that you do both at the same time: refactor <code>MonoidAlgebra</code> while also switching it to use <code>to_additive</code>. You don't need the <code>(dont_translate := ...)</code> heuristic to get started with this. It would just be nice to have. And this would be a good test case for <a href=\"https://github.com/leanprover-community/mathlib4/pull/28637\">#28637</a></p>",
        "id": 535135799,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1755611899
    },
    {
        "content": "<p>Oh god, that's probably a bad idea review-wise</p>",
        "id": 535136149,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1755611991
    },
    {
        "content": "<p>Why do it simultaneously? Is the reason that I'm redefining <code>MonoidAlgebra R M</code> as <code>AddMonoidAlgebra R (Multiplicative M)</code>?</p>",
        "id": 535136687,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1755612134
    },
    {
        "content": "<p>No, I just though it could be more efficient</p>",
        "id": 535137057,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1755612230
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/28637\">#28637</a>, I have now <code>to_additive</code>-ized <code>MonoidAlgebra</code>, to show that it works, inserting <code>(dont_translate := k)</code> whenever necessary. So, it is ready for review (and I'd be happy to split off the <code>MonoidAlgebra</code> part into a separate PR).</p>\n<p>Some issues with additivizing showed up when the <code>MonoidAlgebra</code> and <code>AddMonoidAlgebra</code> theorems don't have the same shape. In particular <code>MonoidAlgebra.of : G →* MonoidAlgebra k G</code> is annoying, as its additive version is <code>Multiplicative G →* AddMonoidAlgebra k G</code>. We may want to consider making it into just a function <code>G → MonoidAlgebra k G</code>.</p>\n<p>Additionally <code>AddMonoidAlgebra.opRingEquiv</code> isn't actually the additivization of <code>MonoidAlgebra.opRingEquiv</code>, which is a bit annoying. But it seems that both versions are genuinely being used.</p>",
        "id": 536402828,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756295613
    }
]