[
    {
        "content": "<p>The current <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Paths#doc\">docs#CategoryTheory.Paths</a> is a \"direct type alias\", i.e</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A type synonym for the category of paths in a quiver.-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Paths</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₁</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">V</span>\n</code></pre></div>\n<p>This particular type alias is very prone to defeq abuse, and I’m getting more and more disatisfied with it when working with it in practice (<code>Paths</code> is a necessary ingredient for any kind of category presented by generators and relations.). One of the few pain points are:</p>\n<ul>\n<li>The absence of a good coercion functions to and from the original type. We do have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Paths.of#doc\">docs#CategoryTheory.Paths.of</a>, which allows in theory to use its <code>obj</code> and <code>map</code> fields as \"coercions\", but for instance <code>docs#CategoryTheory.Paths.of_obj</code> is marked <code>simp</code>, which is very bad (it clearly abuses the defeq <code>V = Paths V</code>). </li>\n<li>Similary <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Paths.of_map#doc\">docs#CategoryTheory.Paths.of_map</a> is also <code>simp</code> which abuses the defeq <code>x ⟶ y = Quiver.Hom.Path x y</code> for <code>x y : Paths V</code> (in the latter form, lean sometimes has trouble unifying with morphisms in a category). This leads to inconsistent writing in the API, where some declarations coerce from morphisms in the quiver to Paths via <code>Paths.of</code>, while some other do it using <code>Quiver.Hom.toPath</code>. </li>\n</ul>\n<p>As a result, working with <code>Paths</code> often result in either <code>erw</code> hell or with a <code>change</code>-fest (see e.g <a href=\"https://github.com/leanprover-community/mathlib4/blob/4f582f1db87fe206405f470c5640a54b6a0ef77f/Mathlib/CategoryTheory/Groupoid/FreeGroupoid.lean#L143-L150\">here</a> or <a href=\"https://github.com/leanprover-community/mathlib4/blob/4f582f1db87fe206405f470c5640a54b6a0ef77f/Mathlib/CategoryTheory/Groupoid/FreeGroupoid.lean#L83-L108\">here</a>).</p>\n<p>I think the situation would be much better if we could enforce a stronger barrier between <code>Paths</code> and the original type. Concretely, I propose we refactor things in the following way:</p>\n<ul>\n<li>Paths become a one-field structure, i.e</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Paths</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u₁</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span>\n</code></pre></div>\n<ul>\n<li>The <code>Hom</code>s for the category struct remain defeq to <code>Quiver.Path</code> but we stop using <code>Quiver.Hom.toPath</code> to coerce morphisms in <code>V</code> to morphisms in <code>Paths V</code>, and we generally ban <code>Quiver.Hom.toPath</code> in the \"categorical\" API (it remains a valid coercion in the Quiver API). The way to translate from the quiver to the path category becomes exclusively <code>Paths.of</code>, which gets un-simped.</li>\n</ul>\n<p>Are there objections?</p>",
        "id": 548130360,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1761908908
    },
    {
        "content": "<p>This looks good to me.</p>",
        "id": 548144111,
        "sender_full_name": "Joël Riou",
        "timestamp": 1761913596
    },
    {
        "content": "<p>I’m currently experimenting with this and it breaks an unexpected amount of things around <code>Cat.FreeRefl</code> and <code>SSet.HomotopyCategory</code>... Things might not be as easy as I initially made it and may need to wait for a refactor making this part of the library more robust first.</p>",
        "id": 548144999,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1761913875
    },
    {
        "content": "<p>It may also break the construction of the localized category (but there the fix should be relatively easy).</p>",
        "id": 548146158,
        "sender_full_name": "Joël Riou",
        "timestamp": 1761914185
    },
    {
        "content": "<p>Yes, the breakages around <code>Localization/Construction</code> were easy to fix ;)</p>",
        "id": 548146341,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1761914235
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> might be able to diagnose the issues here as he and I are responsible for that code ... <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 548210873,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1761931280
    },
    {
        "content": "<p>But I'm a big fan of anything that will ultimately make <code>SSet.HomotopyCategory</code> easier to work with. It now features in the construction of the strict bicategory of quasicategories.</p>",
        "id": 548210992,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1761931338
    },
    {
        "content": "<p>Independently of the refactor of <code>CategoryTheory.Paths</code>, I believe I have found how to make things more practical for doing computations in <code>SSet.HomotopyCategory</code>, in a way that will be consistent with the construction of the fundamental groupoid of a Kan complex, and also get a computable isomorphism for the commutation of <code>hoFunctor</code> to binary products.<br>\n<a href=\"https://github.com/joelriou/mathlib4/blob/hofunctor-monoidal/Mathlib/AlgebraicTopology/SimplicialSet/HoFunctorMonoidal.lean\">https://github.com/joelriou/mathlib4/blob/hofunctor-monoidal/Mathlib/AlgebraicTopology/SimplicialSet/HoFunctorMonoidal.lean</a> (most of the sorries there should be easy)<br>\nMay I proceed to the appropriate refactor of <code>SSet.HomotopyCategory</code>?</p>",
        "id": 548292324,
        "sender_full_name": "Joël Riou",
        "timestamp": 1761990184
    },
    {
        "content": "<p>I'm not in a huge hurry for refactoring <code>Paths</code> (I have experimented, but will probably finish the thing in ~2 weeks), so I think there won't be \"work clashing\" here if you proceed.</p>",
        "id": 548311111,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1762006244
    },
    {
        "content": "<p>I have refactored most of the material about the homotopy category of a simplicial set and the nerve adjunction in <a href=\"https://github.com/leanprover-community/mathlib4/pull/31174\">#31174</a> (very draft).</p>",
        "id": 553581276,
        "sender_full_name": "Joël Riou",
        "timestamp": 1762253623
    },
    {
        "content": "<p>In order to make the refactor PR a little bit smaller, the first basic PR is <a href=\"https://github.com/leanprover-community/mathlib4/pull/31248\">#31248</a>.</p>",
        "id": 553581400,
        "sender_full_name": "Joël Riou",
        "timestamp": 1762253657
    },
    {
        "content": "<p>The next two are:</p>\n<ul>\n<li>feat(AlgebraicTopology): Edge and CompStruct for 2-truncated simplicial sets <a href=\"https://github.com/leanprover-community/mathlib4/pull/31254\">#31254</a></li>\n</ul>",
        "id": 553598907,
        "sender_full_name": "Joël Riou",
        "timestamp": 1762258773
    },
    {
        "content": "<ul>\n<li>feat(AlgebraicTopology): inductive construction of StrictSegal structures <a href=\"https://github.com/leanprover-community/mathlib4/pull/31250\">#31250</a></li>\n</ul>",
        "id": 553599001,
        "sender_full_name": "Joël Riou",
        "timestamp": 1762258803
    },
    {
        "content": "<p>Currently having a look at <a href=\"https://github.com/leanprover-community/mathlib4/pull/31250\">#31250</a></p>",
        "id": 553599050,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1762258816
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> for the reviews!</p>",
        "id": 553629771,
        "sender_full_name": "Joël Riou",
        "timestamp": 1762266722
    },
    {
        "content": "<p>The computable version of the commutation of the homotopy category functor (from simplicial sets or <code>2</code>-truncated simplicial sets) is now sorry-free <a href=\"https://github.com/leanprover-community/mathlib4/pull/31325\">#31325</a></p>",
        "id": 554248709,
        "sender_full_name": "Joël Riou",
        "timestamp": 1762498297
    }
]