[
    {
        "content": "<p>I have two very similar examples that have very different type-class inference timings. The example depends on Mathlib (revision <code>ebbd72bd24186186016706e3716518fbc7aba085</code> from earlier this month, but I expect that doesn't matter much), but I think there might be general type-class inference lessons, so I'm posting it here.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">profiler</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">profiler</span><span class=\"bp\">.</span><span class=\"n\">threshold</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n<span class=\"c1\">-- set_option trace.Meta.synthInstance true</span>\n<span class=\"c1\">-- set_option trace.profiler true</span>\n\n<span class=\"c1\">-- 40-80ms (high variance)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MulPosReflectLE</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"c1\">-- typeclass inference of MulPosReflectLE took 15.7ms</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mul_le_mul_right</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">zpow_pos</span><span class=\"w\"> </span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"c1\">-- 376ms</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mul_le_mul_right</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">zpow_pos</span><span class=\"w\"> </span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"c1\">-- typeclass inference of MulPosReflectLE took 266ms</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>I did some investigation: The slow instances seem to be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearOrderedCommGroupWithZero.toMulPosReflectLE#doc\">docs#LinearOrderedCommGroupWithZero.toMulPosReflectLE</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearOrderedCommGroupWithZero.toPosMulReflectLE#doc\">docs#LinearOrderedCommGroupWithZero.toPosMulReflectLE</a>. The difference between the two examples <em>seems</em> to be that in the first example, the arguments of these instances are tried to be synthesized first, which immediately results in a (cached) failure. In the second example, unification is attempted first, which takes significant time to fail.</p>\n<p>Is there a lesson here about improving the type-class inference algorithm? (probably not, because it's so complicated) (but cc <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> anyway)</p>\n<p>I think there are a few Mathlib lessons here:</p>\n<ul>\n<li>The fact that classes like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PosMulReflectLE#doc\">docs#PosMulReflectLE</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MulPosReflectLE#doc\">docs#MulPosReflectLE</a> are abbreviations is insane, and they should be separate classes. It takes Lean &gt;100ms to figure out (after unfolding them) that the lemma <code>LinearOrderedCommGroupWithZero.toPosMulReflectLE</code> doesn't apply to the goal, which is about a different class!</li>\n<li>We should probably make these two instances (that only apply for types like <code>NNReal</code>) have low priority compared to lemmas that apply to linearly ordered rings.</li>\n</ul>",
        "id": 500674647,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1739978118
    },
    {
        "content": "<p>I guess <a href=\"https://github.com/leanprover-community/mathlib4/pull/13124\">#13124</a> is related</p>",
        "id": 500675130,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1739978248
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"455791\">@Yuyang Zhao</span> what is the status of that PR?</p>",
        "id": 500675296,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1739978285
    },
    {
        "content": "<p>I think there are some Lean lessons as well, but I understand that any change to elaboration/type-class inference is very hard to do.</p>\n<p>In the second example, type-class inference tries the two mentioned instances, and first tries to unify the conclusion of the instance with the class to be synthesized. The problem is that the instance contains an instance argument (of type <code>LinearOrderedCommGroupWithZero ℝ</code>), and this argument is still a metavariable. This makes unification really hard, and causes <em>many</em> nested type-class inference searches (according to the diagnostics <code>LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero</code> is unfolded 10286 times, so I guess roughly that many times). <br>\nIdeally, during type-class inference of class <code>A</code>, while trying instance an instance <code>I</code> that has other type-class argument occurring in its conclusion <code>B</code>, we try to synthesize the arguments of <code>I</code> before an expensive unification of <code>A</code> with <code>B</code> (although I guess you have to do some unification to figure out the implicit arguments of <code>I</code>, so this sounds pretty hard).</p>",
        "id": 500681123,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1739979690
    },
    {
        "content": "<p>Another thing I noticed in the trace is that certain unification problems seem to be tried twice:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">                              </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">0.168624</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">                                </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">0.084345</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n<span class=\"w\">                                </span><span class=\"o\">[</span><span class=\"n\">synthInstance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">0.000002</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n<span class=\"w\">                                </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">0.084215</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">                                  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">0.084064</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">❌️</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">▶</span>\n</code></pre></div>\n<p>where, as far as I can tell, lines 1&amp;4 and lines 2&amp;5 have the same implicit arguments and metavariable numbers. But this might have a genuine reason.</p>",
        "id": 500681528,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1739979799
    },
    {
        "content": "<p>Attempting a small change in <a href=\"https://github.com/leanprover-community/mathlib4/pull/22086\">#22086</a></p>",
        "id": 500685881,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1739980884
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/22090\">#22090</a> gives (small) performance improvements (not sure if the decrease in total build time is statistically significant).</p>",
        "id": 500713196,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1739988885
    },
    {
        "content": "<p>The <code>-0.851 %</code> in type class inference time is probably significant. It's a very good speedup, considering I'm only touching a tiny fraction of the classes.</p>",
        "id": 500713419,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1739988961
    },
    {
        "content": "<p>Yes; this is definitely a meaningful gain (and nothing got slower).</p>",
        "id": 500714037,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1739989130
    },
    {
        "content": "<p>The seemingly duplicate unification problem can be seen to not be duplicate if you hover over the typeclass argument. The first one uses <code>Real.instPreorder.toLT</code>, and this is unfolded into the same unification problem, but directly using <code>Real.instLT</code>.</p>",
        "id": 500755294,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740004144
    },
    {
        "content": "<p>But the <code>0 =?= 0</code> unification problems are genuinely the same, and this isn't caught by the caching in <code>isDefEq</code> :(</p>",
        "id": 500756544,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1740004640
    }
]