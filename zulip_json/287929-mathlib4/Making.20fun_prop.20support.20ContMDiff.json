[
    {
        "content": "<p>Let me start a new thread about this: see e.g. <a href=\"#narrow/channel/287929-mathlib4/topic/Painful.20.60ContMDiff.60.20proof\">https://leanprover.zulipchat.com/#narrow/channel/287929-mathlib4/topic/Painful.20.60ContMDiff.60.20proof</a> and <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Differential.20geometry.20elaborators.20experiment/with/545248370\">#mathlib4 &gt; Differential geometry elaborators experiment</a> for previous discussion.</p>\n<p>Right now, fun_prop does not support <code>ContMDiff</code>, <code>MDifferentiable</code> and friends: this is because these definitions take a model with corners on the domain and codomain as arguments,<br>\nand fun_prop would have to find a model with corners for intermediate domains.</p>\n<p>One complication is that there is not always a canonical model: there are two different models with corners on a product of normed spaces spaces (which are propeq, but not defeq).<br>\nS√©bastien Gouezel tried to make the model with corners an outparam, solving this issue with forgetful inheritance: as he writes<br>\n<a href=\"#narrow/channel/287929-mathlib4/topic/Differential.20geometry.20elaborators.20experiment/near/527262536\">https://leanprover.zulipchat.com/#narrow/channel/287929-mathlib4/topic/Differential.20geometry.20elaborators.20experiment/near/527262536</a>,<br>\nthe result is arguably worse (and certainly not better) than the current design.</p>\n<p>However, we have a third approach now: using a custom elaborator to infer the model with corners from the domain in the \"almost all\" cases which are not a product of normed spaces. The basic infrastructure (and support for inferring many models) has already been merged into master, <a href=\"https://github.com/leanprover-community/mathlib4/pull/30463\">#30463</a> and its dependencies complete the loop by adding support for every instance known to mathlib. In other words, with that in place, we have a way to ask \"what's the model with corners on this space\". It cannot be 100% reliable, but get pretty close.</p>\n<p>Given this gadget, what would it take to make fun_prop support <code>ContMDiff</code> and friends?</p>",
        "id": 555097183,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1762947942
    },
    {
        "content": "<p>I think it is almost supported :) </p>\n<p>You need to modify <a href=\"https://github.com/lecopivo/mathlib4/blob/3bde4584937f8989525cddbd1d644602a19e8390/Mathlib/Tactic/FunProp/Core.lean#L44\"><code>synthesizeArgs</code></a> . In particular this part</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">        </span><span class=\"c1\">-- try user provided discharger</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">read</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">isProp</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">          </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"bp\">.</span><span class=\"n\">disch</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">              </span><span class=\"n\">continue</span>\n<span class=\"w\">            </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">              </span><span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">fun_prop</span><span class=\"o\">]</span>\n<span class=\"w\">                </span><span class=\"s2\">\"{‚Üê ppOrigin thmId}, failed to assign proof{indentExpr type}\"</span>\n<span class=\"w\">              </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">          </span><span class=\"k\">else</span>\n<span class=\"w\">            </span><span class=\"n\">logError</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"Failed to prove necessary assumption `{‚Üê ppExpr type}` </span><span class=\"se\">\\</span>\n<span class=\"s2\">                        when applying theorem `{‚Üê ppOrigin' thmId}`.\"</span>\n</code></pre></div>\n<p>For some reason I thought that custom discharger should be run only on <code>Prop</code> but you want to run it on <code>?I' : ModelWithCorners ùïú E' H' </code> when applying <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Geometry/Manifold/ContMDiff/Basic.html#ContMDiff.comp\">ContMDiff.comp</a> </p>\n<p>I think it should really be just removing the <code> if (‚Üê isProp type) then</code> line and running <code>fun_prop (disch:=find_model)</code> where <code>find_model</code> is a tactic capable of discharging <code>ModelWithCorners ùïú E' H' </code>.</p>",
        "id": 555123075,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1762955344
    },
    {
        "content": "<blockquote>\n<p>not a product of normed spaces</p>\n</blockquote>\n<p>This is a bit worrisome, <code>fun_prop</code> rewrite function into compositions of functions over product spaces. For example, <code>fun x =&gt; sin x + exp x</code> is decomposed as <code>(fun xy =&gt; xy.1 + xy.2) ‚àò (fun x =&gt; (sin x, exp x))</code>.  Thus <code>fun_prop</code> creates lots of intermediate product spaces so I'm a bit worried if it will work in practice for <code>ContMDiff</code>.</p>\n<p>However, the above decomposition is not done if there is a theorem for addition in compositional form like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Algebra/Monoid/Defs.html#Continuous.add\">Continuous.add</a> instead of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Algebra/Monoid/Defs.html#continuous_add\">continuous_add</a></p>",
        "id": 555125576,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1762956001
    },
    {
        "content": "<p>These are great news, I'm very excited to hear this! I've started work on this in <a href=\"https://github.com/leanprover-community/mathlib4/tree/funpropM\">branch#funpropM</a>.</p>",
        "id": 555290019,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1763021840
    },
    {
        "content": "<blockquote>\n<p>This is a bit worrisome, <code>fun_prop</code> rewrite function into compositions of functions over product spaces.</p>\n</blockquote>\n<p>Thanks for the warning, that is very good to know. I hope this won't be a big issue here --- taking products of two manifolds is fine, as are products of a manifold and a normed space. Only products of two normed spaces are an issue --- and if I understand correctly, a workaround for now could be to have find_model look in the local context first, and then provide the model I want by hand, as in</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModelWithCorners</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">  </span><span class=\"n\">ùìò</span><span class=\"o\">(</span><span class=\"n\">ùïú</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"n\">fun_prop</span>\n</code></pre></div>\n<p>right?</p>",
        "id": 555290590,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1763022001
    },
    {
        "content": "<p>Yeah, that way you can force it to use a particular model you want.</p>\n<p>Btw the link to the branch is broken. Unfortunately, I don't really have the time to help out with it but I'm happy to answer any questions.</p>",
        "id": 555464019,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1763070195
    },
    {
        "content": "<p>Thanks! In fact, I already have a first question: when my <code>find_model</code> tactic is run on goals of the form <code>I? : ModelWithCorners k E H</code>, can I assume the <code>ModelWithCorners k E H</code> is type-correct? (For example, that it's not <code>ModelWithCorners Bool Bool Bool</code>, or that E is a k-normed space and H a topological space?) This would avoid the need for some checks in the tactic.</p>",
        "id": 555468705,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1763072167
    },
    {
        "content": "<p>The branch is now a WIP PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/31580\">#31580</a></p>",
        "id": 555468802,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1763072208
    },
    {
        "content": "<p>When trying to apply theorem <code>fun_prop</code> does </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"n\">statement</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">forallMetaTelescope</span><span class=\"w\"> </span><span class=\"n\">theoremType</span>\n</code></pre></div>\n<p>unifies <code>statemetn</code> with the current goal and then runs <code>synthesizeArgs</code> on each <code>xs[i]</code> in order.</p>\n<p>It does not error out if it fails to synthesize an argument, for example when having <code>{n : Nat} (hf : ContDiff ùïú n f)</code> the <code>n</code> often fails to be synthesized but then it is inferred from <code>hf</code>. Therefore, I think you can safely assume that <code>ModelWithCorners k E H</code> is type correct but I think you might be able to get <code>ModelWithCorners Bool Bool Bool</code> however in that case all the type class instances will be metavariables. </p>\n<p>I think you can do the check like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">syntesizeModelWithCorners</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">goal</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">isAppOfArity</span><span class=\"w\"> </span><span class=\"ss\">``ModelWithCorners</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">    </span><span class=\"c1\">-- check if all the instances [NontriviallyNormedField ùïú] [NormedAddCommGroup E]</span>\n<span class=\"w\">    </span><span class=\"c1\">--                            [NormedSpace ùïú E] [TopologicalSpace H]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- has been syntasized</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">hasMVar</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">model</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">      </span><span class=\"n\">goal</span><span class=\"bp\">.</span><span class=\"n\">mvarId!</span><span class=\"bp\">.</span><span class=\"n\">assign</span><span class=\"w\"> </span><span class=\"n\">model</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 555522399,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1763106414
    },
    {
        "content": "<p>Thanks; this is very helpful!</p>",
        "id": 567304041,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1768034819
    },
    {
        "content": "<p>Quick status update: my branch above has a quick prototype; I have a plan for implementing this and will be supervising <span class=\"user-mention\" data-user-id=\"697518\">@Hannah Scholz</span> to execute this. This should get added to mathlib in spring.</p>",
        "id": 567304095,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1768034909
    },
    {
        "content": "<p>For reference, <a href=\"https://github.com/leanprover-community/mathlib4/pull/33808\">#33808</a> tags <code>MDifferentiable</code> with fun_prop. It turns out that the current state already works to some degree (as long as no composition is involved). I prefer improving fun_prop before adding the tagging to mathlib; having an interim impression \"fun_prop is unreliable\" is undesirable to me.</p>",
        "id": 567304139,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1768034963
    }
]