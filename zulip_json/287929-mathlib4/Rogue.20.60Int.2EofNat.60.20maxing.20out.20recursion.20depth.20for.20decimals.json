[
    {
        "content": "<p><code>Int.ofNat</code> is notoriously badly behaved and discouraged in favor of coercions. One of the reasons might be the following: <code>simp</code> expands natural numbers into  <code>1 + 1 + 1 + ... + 1</code> when they appear as arguments to the argument of <code>Int.ofNat</code> (sometimes). For example, </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">Int.ofNat</span> <span class=\"o\">(</span><span class=\"mi\">12</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>leaves us with the goal</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But this thread isn't actually about <code>Int.ofNat</code> being badly behaved—it's about how it appears without warning in <code>Rat.ofScientific</code>.</p>\n<p>The written definition of <code>Rat.ofScientific</code> in <code>std</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Implements \"scientific notation\" `123.4e-5` for rational numbers. -/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">ofScientific</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Rat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">s</span> <span class=\"k\">then</span>\n    <span class=\"n\">Rat.normalize</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.ne_of_gt</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.pos_pow_of_pos</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span>\n    <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>When we <code>#print Rat.ofScientific</code>, we see an <code>Int.ofNat</code> has slipped in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">Rat.ofScientific</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Rat</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"n\">s</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"k\">then</span> <span class=\"n\">normalize</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">Int.ofNat</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"mi\">10</span> <span class=\"bp\">^</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>This causes problems when writing something like <code>3.1</code>—even though the <code>false</code> branch isn't explored, <code>simp</code> still expands it.</p>\n<p>It might be worth looking at the trace of the <code>simp</code> call above. We see it constantly trying to discharge and failing each time it peels off another <code>+ 1</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">Nat.cast_ofNat</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">assign</span> <span class=\"kd\">instance</span>\n      <span class=\"n\">NatCast</span> <span class=\"n\">ℤ</span>\n    <span class=\"n\">sythesized</span> <span class=\"n\">value</span>\n      <span class=\"n\">Int.instNatCastInt</span>\n    <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span>\n      <span class=\"n\">NonAssocSemiring.toNatCast</span>\n</code></pre></div>\n<p>I'm not sure what the best way to fix this is, but here are some possible approaches.</p>\n<ol>\n<li><strong>Change the cast that gets used in <code>ofScientific</code>.</strong> There are a few ways to do this, too:</li>\n</ol>\n<ul>\n<li>Simply use something like <code>Int.mul</code> or <code>(m * (Nat.pow 10 e)) : Int</code>. A band-aid; not sure if it would actually work.</li>\n<li>Add an instance of <code>NatCast Rat</code>. We only have <code>IntCast Rat</code> defined directly; <code>NatCast Rat</code> relies on algebraic structure inclusions (namely <code>#synth NatCast Rat</code> yields <code>NonAssocRing.toNatCast</code>).</li>\n<li>Remove the instance of <code>IntCast Rat</code> and rely on algebraic inclusions for the cast in general. (For <code>ofScientific</code>, we'd define the rational number directly via e.g. <code>mkRat</code> instead of relying on a cast to the rationals.)</li>\n</ul>\n<ol start=\"2\">\n<li><strong>Fix the behavior that causes <code>Int.ofNat</code> to expand into <code>1 + 1 + 1 + ... + 1</code>.</strong> I don't know why this happens, but it's not just with <code>*</code>; it also happens with the first argument of <code>^</code>, and possibly other operations. I'm guessing this would resolve other problems as well, but I don't know if it's feasible to fix it. I think <code>zify</code> ran into a similar problem, and I wonder if the reason is the same.</li>\n<li><strong>Stop <code>Int.ofNat</code> from being inserted automatically like this.</strong> Where did this <code>Int.ofNat</code> even come from? Why doesn't it appear as an up-arrow? It just seems a bit fishy, so I wonder if there's something to address in this direction—but if there is, I don't have the background necessary to do so.</li>\n</ol>\n<p>If we could resolve this quickly somehow it would be great! <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> is looking to use decimals for teaching in less than a week, and I found out that even trying to use <code>norm_num</code> with e.g. <code>3.141</code> hangs, and <code>3.14159</code> causes a stack overflow. I suspect this behavior is the culprit; when we try to simplify <code>3.141</code> with <code>simp</code> we hit the max recursion depth:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">141</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">OfScientific.ofScientific</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Rat.ofScientific</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n<span class=\"c1\">-- maximum recursion depth has been reached (use `set_option maxRecDepth &lt;num&gt;` to increase limit)</span>\n</code></pre></div>\n<p>(I could technically be wrong about this being the source of the issues for the new <code>norm_num</code> extension, as I'm still looking into it—but still, this seems like it should be fixed one way or another!)</p>",
        "id": 323990836,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1674808783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rogue.20.60Int.2EofNat.60.20maxing.20out.20recursion.20depth.20for.20decimals/near/323990836\">said</a>:</p>\n<blockquote>\n<p><code>Int.ofNat</code> is notoriously badly behaved and discouraged in favor of coercions.</p>\n</blockquote>\n<p>This seems like a strange mischaracterization. <code>Int.ofNat</code> is <em>the constructor</em>, it's not badly behaved performance-wise but it is not the coercion and hence not the simp-normal form.</p>",
        "id": 324086165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674834842
    },
    {
        "content": "<p>You will certainly find calls to <code>Int.ofNat</code> and other non-simp-normal functions if you unfold enough definitions. This is not a problem that needs to be solved</p>",
        "id": 324086426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674834903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rogue.20.60Int.2EofNat.60.20maxing.20out.20recursion.20depth.20for.20decimals/near/323990836\">said</a>:</p>\n<blockquote>\n<p>One of the reasons might be the following: <code>simp</code> expands natural numbers into  <code>1 + 1 + 1 + ... + 1</code> when they appear as arguments to the argument of <code>Int.ofNat</code> (sometimes). For example, </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">Int.ofNat</span> <span class=\"o\">(</span><span class=\"mi\">12</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>leaves us with the goal</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is certainly a problem (which has been mentioned elsewhere although I don't think it has a dedicated issue for it), although I don't think it is specific to <code>Int.ofNat</code>. I think you can cause the same behavior using <code>Nat.cast</code>, it's a problem in <code>simp</code> and/or our simp set.</p>",
        "id": 324087061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674835041
    },
    {
        "content": "<blockquote>\n<p>This causes problems when writing something like 3.1—even though the false branch isn't explored, simp still expands it.</p>\n</blockquote>\n<p><code>simp</code> should not do anything to <code>3.1</code> as written. If you give it to <code>norm_num</code> it should hopefully rewrite it to <code>31 / 10</code> and leave it at that. <code>simp [Rat.ofScientific]</code> is not something you should be doing unless you are proving theorems about <code>Rat.ofScientific</code>, and in those cases the workaround would most likely be to disable simp lemmas like <code>\\u (n+1) = \\u n + 1</code> that are causing this bad unfolding.</p>",
        "id": 324090681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674835211
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span></p>",
        "id": 324091311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674835328
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rogue.20.60Int.2EofNat.60.20maxing.20out.20recursion.20depth.20for.20decimals/near/324086165\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Rogue.20.60Int.2EofNat.60.20maxing.20out.20recursion.20depth.20for.20decimals/near/323990836\">said</a>:</p>\n<blockquote>\n<p><code>Int.ofNat</code> is notoriously badly behaved and discouraged in favor of coercions.</p>\n</blockquote>\n<p>This seems like a strange mischaracterization. <code>Int.ofNat</code> is <em>the constructor</em>, it's not badly behaved performance-wise but it is not the coercion and hence not the simp-normal form.</p>\n</blockquote>\n<p>Ok, makes sense! That last bit clarifies the motivation behind the <a href=\"#narrow/stream/287929-mathlib4/topic/Rat.20in.20norm_num/near/320356859\">sentiment</a> I’ve seen about it, I’m guessing.</p>",
        "id": 324112101,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1674840443
    },
    {
        "content": "<p>Cool, I’ll see if disabling those lemmas in the proofs about <code>Rat.ofScientific</code> fixes the problems next time that I have some downtime! :)</p>",
        "id": 324112559,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1674840553
    }
]