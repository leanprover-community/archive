[
    {
        "content": "<p>Given two functions <code>(f : α → γ) (g : β → γ)</code> with the same codomain, one can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sum.elim#doc\">docs#Sum.elim</a> to glue them together into a single function <code>Sum.elim f g: α ⊕ β → γ</code>.  For functions <code>(f : α → α') (g : β → β')</code> with different codomains, we can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sum.map#doc\">docs#Sum.map</a> instead to create a slightly different glued function <code>Sum.map f g: α ⊕ β → α' ⊕ β'</code>.  For both operations one has a very convenient API (in particular, <code>simp</code> tends to work wonders).</p>\n<p>But suppose now that one has two functions <code>f: (i:α) → (α' i)</code> <code>g : (j:β) → (β' j)</code> with codomains depending on the domain variable.  Is there any sensible way to glue them together?  I am struggling to even formulate a type to hold such a glued function.  And even if one did hack together some sort of type, building an API to relate it back to the original functions looks very challenging (there are annoying <code>cast</code> issues as most of the solutions I came up with involved types that were only propositionally equal to the types one actually wants, rather than definitionally equal).  Is there a good solution to this, or is this an inherent issue with dependent type theory?</p>",
        "id": 531399902,
        "sender_full_name": "Terence Tao",
        "timestamp": 1753716774
    },
    {
        "content": "<p>Do you have any requirements for what the gluing should look like?</p>",
        "id": 531400774,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753717049
    },
    {
        "content": "<p>I guess I should discuss the motivation.  On a probability space <code>Ω</code>, I have one family <code>X : (i:I) → Ω → (G i)</code> of random variables <code>X i</code>, each taking values in some measurable space <code>G i</code>; and I have another family <code>Y : (j:J) → Ω → (H j)</code>of random variables <code>Y j</code>, taking values in some other measurable spaces <code>H j</code>.  I would like to glue these collections into a single collection <code>glue X Y : (k : I ⊕ J) → Ω → ???</code> of random variables which can be related to the original random variables; in particular, I would like <code>iIndepFun (glue X Y)</code> to hold if and only if <code>iIndepFun X</code> and <code>iIndepFun Y</code> both hold, and furthermore <code>IndepFun (fun ω i ↦ X i ω) (fun ω j ↦ Y j ω)</code> also hold.  (Informally: independent samples of sets of independent variables remain jointly independent.) I could do all this when the types <code>G i</code>, <code>H j</code> were all a single type <code>G</code>, but am struggling to even assign a sensible type to <code>???</code> in the case when these are different.</p>",
        "id": 531401908,
        "sender_full_name": "Terence Tao",
        "timestamp": 1753717387
    },
    {
        "content": "<p>since I can definitely glue them together into a function<br>\n<code>Unit → (((i : α) → α' i) × ((j : β) → β' j))</code></p>",
        "id": 531401964,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753717400
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">iorj</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Sum</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">iorj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Sum</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span>\n</code></pre></div>",
        "id": 531401986,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1753717407
    },
    {
        "content": "<p>You can of course insert <code>Option.rec</code> or any other (non-recursive) recursor, or a <code>match</code> instead of <code>Sum.rec</code></p>",
        "id": 531402198,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1753717465
    },
    {
        "content": "<p>Ah OK.  That may be the best option.  There are still some issues in my application with transferring various data (e.g., <code>[MeasureSpace]</code>) from say <code>α i</code> to <code>Sum.elim α β (Sum.inl i)</code> (which is defeq to <code>Sum.inl (α i)</code>) but this is \"just\" a matter of applying a whole bunch of <code>cast</code> operators and is at least doable, albeit annoying.</p>",
        "id": 531403138,
        "sender_full_name": "Terence Tao",
        "timestamp": 1753717751
    },
    {
        "content": "<p><code>Sum.elim α β (Sum.inl i)</code> is defeq to <code>α i</code></p>",
        "id": 531403375,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753717815
    },
    {
        "content": "<p>it doesn't even have the same type as <code>Sum.inl (α i)</code></p>",
        "id": 531403427,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753717833
    },
    {
        "content": "<p>Yes, but syntactically different, therefore typeclass search won't see through</p>",
        "id": 531403458,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1753717839
    },
    {
        "content": "<p>Here's an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α'</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β'</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ij</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">Σ'</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sum</span><span class=\"bp\">.</span><span class=\"n\">isLeft</span><span class=\"w\"> </span><span class=\"n\">ij</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">α'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ij</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"bp\">Σ'</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sum</span><span class=\"bp\">.</span><span class=\"n\">isRight</span><span class=\"w\"> </span><span class=\"n\">ij</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">β'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ij</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">⟩</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sum_inl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sum_inr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 531403473,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1753717843
    },
    {
        "content": "<p>My point is that you won't need <code>cast</code></p>",
        "id": 531403538,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753717861
    },
    {
        "content": "<p>But, yes, a naked <code>Sum.rec</code> works</p>",
        "id": 531403546,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1753717864
    },
    {
        "content": "<p>Oh you are using <code>Sum.elim</code> instead of <code>Sum.map</code> because <code>α, β</code> lie in the same universe.  OK, that is a clean solution (and it would be unrealistic to expect to glue across universes anyway).</p>",
        "id": 531403669,
        "sender_full_name": "Terence Tao",
        "timestamp": 1753717897
    },
    {
        "content": "<p>You can do this without messing around with types by gluing into<br>\n<code>(α ⊕ β) → (Sigma α' ⊕ Sigma β')</code></p>",
        "id": 531404069,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753718003
    },
    {
        "content": "<p>OK I see now where I went wrong.  I was somehow sure that the target type needed to be <code>Sum.map α β iorj</code> which takes values in the ridiculous and useless space <code>Type ⊕ Type</code>, but this was a purely self-inflicted difficulty.</p>",
        "id": 531405365,
        "sender_full_name": "Terence Tao",
        "timestamp": 1753718333
    }
]