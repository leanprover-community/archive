[
    {
        "content": "<p>Are there effective algorithms to prove statements in FOL if only one-variable predicates are involved? I tried to golf <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isPreconnected_closed_iff#doc\">docs4#isPreconnected_closed_iff</a> and after</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">IsPreconnected</span><span class=\"o\">,</span> <span class=\"n\">compl_surjective.forall</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">forall_congr'</span> <span class=\"k\">fun</span> <span class=\"n\">u</span> <span class=\"bp\">↦</span> <span class=\"n\">compl_surjective.forall.trans</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">forall_congr'</span> <span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">isOpen_compl_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">forall_congr'</span> <span class=\"k\">fun</span> <span class=\"n\">hu</span> <span class=\"bp\">↦</span> <span class=\"n\">forall_congr'</span> <span class=\"k\">fun</span> <span class=\"n\">hv</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n</code></pre></div>\n<p>I've got the goal</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">u</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∪</span> <span class=\"n\">v</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">v</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∩</span> <span class=\"n\">v</span><span class=\"bp\">ᶜ</span><span class=\"o\">))</span> <span class=\"bp\">↔</span>\n    <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">u</span> <span class=\"bp\">∪</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">∩</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>This is a statement that is true for any three sets <code>s</code>, <code>u</code>, <code>v</code>.  It would be nice to have a tactic that closes this goal automatically.</p>",
        "id": 360935401,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684988549
    },
    {
        "content": "<p>I guess, in this case one can reformulate each atom like <code>s ⊆ u ∪  v</code> as a statement about parts of the corresponding Venn diagram being (non)empty, then get a statement in propositional logic.</p>",
        "id": 360935615,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684988716
    },
    {
        "content": "<p>there was a tactic along those lines</p>",
        "id": 360935631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684988736
    },
    {
        "content": "<p>There was or there is?</p>",
        "id": 360935654,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684988760
    },
    {
        "content": "<p>it was a zulip discussion</p>",
        "id": 360935707,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684988770
    },
    {
        "content": "<p>I forget how far along it actually got, it did not land in mathlib</p>",
        "id": 360935734,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684988787
    },
    {
        "content": "<p>the simple version is to introduce x, simp everything to propositional logic and call <code>tauto</code></p>",
        "id": 360935763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684988807
    },
    {
        "content": "<p>What do you mean by \"introduce x\"?</p>",
        "id": 360935812,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684988844
    },
    {
        "content": "<p>well I guess your goal is more complicated because you have multiple existential quantifiers</p>",
        "id": 360935907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684988894
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">subset_def</span><span class=\"o\">,</span> <span class=\"n\">Set.Nonempty</span><span class=\"o\">]</span>\n  <span class=\"n\">tauto</span>\n</code></pre></div>",
        "id": 360935918,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684988904
    },
    {
        "content": "<p>the version that was in the discussion only handled universal quantifiers IIRC</p>",
        "id": 360935936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684988919
    },
    {
        "content": "<p>for stuff like subset masquerading as implication</p>",
        "id": 360935950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684988930
    },
    {
        "content": "<p>Leaves many goals like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">mp.inl.h.right.right</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n<span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">u.23250</span>\n<span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">u.23255</span>\n<span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span>\n<span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span>\n<span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">u</span>\n<span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">v</span>\n<span class=\"n\">em</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"n\">a</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">u</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">v</span>\n<span class=\"n\">a⁴</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">u</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">v</span>\n<span class=\"n\">x</span><span class=\"bp\">¹</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"n\">a</span><span class=\"bp\">³</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">¹</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n<span class=\"n\">a</span><span class=\"bp\">²</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">¹</span> <span class=\"bp\">∈</span> <span class=\"n\">u</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"n\">a</span><span class=\"bp\">¹</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n<span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">v</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">x</span><span class=\"bp\">¹</span> <span class=\"bp\">∈</span> <span class=\"n\">v</span>\n</code></pre></div>",
        "id": 360935985,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684988956
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 360935986,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684988958
    },
    {
        "content": "<p>yeah I think we need a FOL tactic to prove this</p>",
        "id": 360936212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989064
    },
    {
        "content": "<p>if you instantiate the quantifiers manually it can probably be done with the existing tools</p>",
        "id": 360936233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989085
    },
    {
        "content": "<p>What means instantiate the quantifiers manually?</p>",
        "id": 360936515,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684989277
    },
    {
        "content": "<p><code>have := a⁴ _ a¹; have := a⁴ _ a³; tauto</code></p>",
        "id": 360936555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989308
    },
    {
        "content": "<p>something like that</p>",
        "id": 360936570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989315
    },
    {
        "content": "<p>(a) my goal is to avoid intervention; (b) those a^k only appear after the call to <code>tauto</code>.</p>",
        "id": 360936617,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684989349
    },
    {
        "content": "<p>(a) yes I'm aware</p>",
        "id": 360936658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989363
    },
    {
        "content": "<p>the tactic doesn't exist</p>",
        "id": 360936693,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989370
    },
    {
        "content": "<p>at least not until the likes of <code>duper</code> make it to mathlib</p>",
        "id": 360936714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989382
    },
    {
        "content": "<p>What is <code>duper</code>?</p>",
        "id": 360936750,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684989405
    },
    {
        "content": "<p>Should I open a github issue?</p>",
        "id": 360936794,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684989437
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/duper\">https://github.com/leanprover-community/duper</a>, WIP superposition prover in lean 4</p>",
        "id": 360936802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989440
    },
    {
        "content": "<p>For FOL proving? This is a long standing issue, we've known about it since the beginning of lean 3</p>",
        "id": 360936853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989482
    },
    {
        "content": "<p>No README... Probably, a clear sign of \"WIP\"</p>",
        "id": 360936889,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684989484
    },
    {
        "content": "<p>making a good FOL prover is really challenging, especially when you mix it with all the higher order stuff in lean</p>",
        "id": 360937006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989597
    },
    {
        "content": "<p>Do I understand correctly that FOL with unary predicates is doable, FOL with binary predicates is undecidable? Is it undecidable in practice or there is an algorithm that works for reasonably sized formulas provided that they're true?</p>",
        "id": 360937014,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684989601
    },
    {
        "content": "<p>It's not undecidable in practice, but it is heuristic</p>",
        "id": 360937160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989663
    },
    {
        "content": "<p>The success rate depends quite strongly on the complexity of the goal</p>",
        "id": 360937209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989693
    },
    {
        "content": "<p>BTW, are there any prover-independent solutions to this? Like an external tool or a C/C++ library that can take an input formula and give you a proof in some machine-readable format?</p>",
        "id": 360937303,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684989734
    },
    {
        "content": "<p>Z3 (leo's project before lean) is an SMT solver (aka FOL plus theories like linear arithmetic)</p>",
        "id": 360937350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989771
    },
    {
        "content": "<p>Can we somehow call it (or another similar tool) from Lean 4?</p>",
        "id": 360937414,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684989801
    },
    {
        "content": "<p>there are other SMT solvers as well like vampire (which had an open PR to mathlib for a long time)</p>",
        "id": 360937420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989806
    },
    {
        "content": "<p>the other problem with calling such tools is that you often don't get a proof back, just an assertion \"it's true\"</p>",
        "id": 360937527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989855
    },
    {
        "content": "<p>or at least not something which can be externally checked, much less reconstructed into a lean proof</p>",
        "id": 360937559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989876
    },
    {
        "content": "<p>many of these properties disqualify them from being used in mathlib proofs</p>",
        "id": 360937621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989911
    },
    {
        "content": "<p>Of course, \"it's true\" is not enough.</p>",
        "id": 360937740,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684989981
    },
    {
        "content": "<p>As for unary predicates... it's plausible to me that this fragment is decidable (at least, assuming the term language isn't too fancy), but I assume you want to include equality, and that's a binary predicate</p>",
        "id": 360937745,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684989985
    },
    {
        "content": "<p>I'm not sure how useful that fragment is in practice</p>",
        "id": 360937756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684990009
    },
    {
        "content": "<p>In this example I don't need equality.</p>",
        "id": 360937762,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684990017
    },
    {
        "content": "<p>you are using a binary predicate though (actually, probably a 4-ary predicate since lean has implicits everywhere) so writing a tactic that knows what to ignore is quite a tricky part of this goal</p>",
        "id": 360937842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684990078
    },
    {
        "content": "<p>I think it would be more useful to just have a general FOL instantiation tactic rather than a decision procedure for unary predicate FOL</p>",
        "id": 360937952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684990130
    },
    {
        "content": "<p>OK, I'll just leave the proof we had.</p>",
        "id": 360937999,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684990164
    },
    {
        "content": "<p>I mean, in this case you can just instantiate all quantifiers at all ground terms and get a proof by propositional logic</p>",
        "id": 360938024,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684990179
    },
    {
        "content": "<p>There are many statements in <code>Topology/Connected</code> that are repeated for open and closed sets</p>",
        "id": 360938102,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684990213
    },
    {
        "content": "<p>And in most cases one can go from one statement to another by something I wrote in the first few lines: replace all open sets by their complements which are closed.</p>",
        "id": 360938213,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684990272
    },
    {
        "content": "<p>the fact that your theorem is not quantified over u and v makes it a lot less obvious to me</p>",
        "id": 360938237,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684990292
    },
    {
        "content": "<p>It is quantified. The first 2 lines get rid of that.</p>",
        "id": 360938352,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684990337
    },
    {
        "content": "<p>I mean that while</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">\\</span><span class=\"k\">forall</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">u</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∪</span> <span class=\"n\">v</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">v</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∩</span> <span class=\"n\">v</span><span class=\"bp\">ᶜ</span><span class=\"o\">)))</span> <span class=\"bp\">↔</span>\n<span class=\"o\">(</span><span class=\"bp\">\\</span><span class=\"k\">forall</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">u</span> <span class=\"bp\">∪</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">∩</span> <span class=\"n\">v</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>looks obviously true to me,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">u</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∪</span> <span class=\"n\">v</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">v</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∩</span> <span class=\"n\">v</span><span class=\"bp\">ᶜ</span><span class=\"o\">)))</span> <span class=\"bp\">↔</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">u</span> <span class=\"bp\">∪</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Set.Nonempty</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">∩</span> <span class=\"n\">v</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>looks a lot harder and possibly false</p>",
        "id": 360938436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684990407
    },
    {
        "content": "<p>If you were to keep the quantifiers and substitute <code>u |-&gt; uᶜ</code> and <code>v |-&gt; vᶜ</code> then simp could probably do this proof</p>",
        "id": 360938571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684990482
    },
    {
        "content": "<p>Let me try</p>",
        "id": 360938626,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684990516
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">IsPreconnected</span><span class=\"o\">,</span> <span class=\"n\">compl_surjective.forall</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">forall_congr'</span> <span class=\"k\">fun</span> <span class=\"n\">u</span> <span class=\"bp\">↦</span> <span class=\"n\">compl_surjective.forall.trans</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">revert</span> <span class=\"n\">u</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">subset_def</span><span class=\"o\">,</span> <span class=\"n\">Set.Nonempty</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>fails</p>",
        "id": 360938729,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684990572
    },
    {
        "content": "<p>what's the goal?</p>",
        "id": 360938759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684990587
    },
    {
        "content": "<p>you don't need to unfold <code>subset_def</code> or <code>Set.Nonempty</code> for this proof</p>",
        "id": 360938783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684990602
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n        <span class=\"n\">IsClosed</span> <span class=\"n\">u</span> <span class=\"bp\">→</span>\n          <span class=\"n\">IsClosed</span> <span class=\"n\">x</span> <span class=\"bp\">→</span>\n            <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x_1</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">x_1</span> <span class=\"bp\">∈</span> <span class=\"n\">u</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">x_1</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n              <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x_1</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">x_1</span> <span class=\"bp\">∈</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x_2</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x_2</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">x_2</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">x_3</span><span class=\"o\">,</span> <span class=\"n\">x_3</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"n\">x_3</span> <span class=\"bp\">∈</span> <span class=\"n\">u</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"n\">x_3</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>\n      <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n        <span class=\"n\">IsClosed</span> <span class=\"n\">u</span> <span class=\"bp\">→</span>\n          <span class=\"n\">IsClosed</span> <span class=\"n\">t'</span> <span class=\"bp\">→</span>\n            <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">u</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t'</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n              <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t'</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">u</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t'</span>\n</code></pre></div>",
        "id": 360938785,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684990604
    },
    {
        "content": "<p>I guess I don't understand what the original goal was and how you want to prove it</p>",
        "id": 360938882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684990666
    },
    {
        "content": "<p>Here is the original proof from mathlib4:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"o\">⟨</span><span class=\"kd\">by</span>\n      <span class=\"n\">rintro</span> <span class=\"n\">h</span> <span class=\"n\">t</span> <span class=\"n\">t'</span> <span class=\"n\">ht</span> <span class=\"n\">ht'</span> <span class=\"n\">htt'</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">xt</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">yt'</span><span class=\"o\">⟩</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">not_disjoint_iff_nonempty_inter</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">subset_compl_iff_disjoint_right</span><span class=\"o\">,</span> <span class=\"n\">compl_inter</span><span class=\"o\">]</span>\n      <span class=\"n\">intro</span> <span class=\"n\">h'</span>\n      <span class=\"k\">have</span> <span class=\"n\">xt'</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">t'</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">resolve_left</span> <span class=\"o\">(</span><span class=\"n\">absurd</span> <span class=\"n\">xt</span><span class=\"o\">)</span>\n      <span class=\"k\">have</span> <span class=\"n\">yt</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∉</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">resolve_right</span> <span class=\"o\">(</span><span class=\"n\">absurd</span> <span class=\"n\">yt'</span><span class=\"o\">)</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">ht.isOpen_compl</span> <span class=\"n\">ht'.isOpen_compl</span> <span class=\"n\">h'</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">yt</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">xt'</span><span class=\"o\">⟩</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">compl_union</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n      <span class=\"n\">exact</span> <span class=\"n\">this.ne_empty</span> <span class=\"n\">htt'.disjoint_compl_right.inter_eq</span><span class=\"o\">,</span>\n    <span class=\"kd\">by</span>\n      <span class=\"n\">rintro</span> <span class=\"n\">h</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">hu</span> <span class=\"n\">hv</span> <span class=\"n\">huv</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">xu</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">yv</span><span class=\"o\">⟩</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">not_disjoint_iff_nonempty_inter</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">subset_compl_iff_disjoint_right</span><span class=\"o\">,</span> <span class=\"n\">compl_inter</span><span class=\"o\">]</span>\n      <span class=\"n\">intro</span> <span class=\"n\">h'</span>\n      <span class=\"k\">have</span> <span class=\"n\">xv</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"n\">absurd</span> <span class=\"n\">xu</span><span class=\"o\">)</span> <span class=\"n\">id</span>\n      <span class=\"k\">have</span> <span class=\"n\">yu</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∉</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">absurd</span> <span class=\"n\">yv</span><span class=\"o\">)</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hu.isClosed_compl</span> <span class=\"n\">hv.isClosed_compl</span> <span class=\"n\">h'</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">yu</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">xv</span><span class=\"o\">⟩</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">compl_union</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n      <span class=\"n\">exact</span> <span class=\"n\">this.ne_empty</span> <span class=\"n\">huv.disjoint_compl_right.inter_eq</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 360938989,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684990709
    },
    {
        "content": "<p>ah yeah that can be golfed</p>",
        "id": 360939059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684990758
    },
    {
        "content": "<p>and your replacement?</p>",
        "id": 360939108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684990780
    },
    {
        "content": "<p>The problem is that while the formulas are equivalent (in FOL, after the cleanup I made), it is not \"obvious\": the terms in the implications do not correspond to each other.</p>",
        "id": 360939120,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684990789
    },
    {
        "content": "<p>The replacement I tried to write starts with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">IsPreconnected</span><span class=\"o\">,</span> <span class=\"n\">compl_surjective.forall</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">forall_congr'</span> <span class=\"k\">fun</span> <span class=\"n\">u</span> <span class=\"bp\">↦</span> <span class=\"n\">compl_surjective.forall.trans</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">isOpen_compl_iff</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and leaves a goal that is true in FOL.</p>",
        "id": 360939350,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684990869
    },
    {
        "content": "<p>(at least if you unfold definitions of subset and nonempty)</p>",
        "id": 360939377,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684990888
    },
    {
        "content": "<p>what happened to <code>t</code> and <code>t'</code>?</p>",
        "id": 360939388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684990895
    },
    {
        "content": "<p>from the original theorem</p>",
        "id": 360939396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684990900
    },
    {
        "content": "<p>I used <code>compl_surjective.forall.trans _</code> to unify sets in LHS and RHS.</p>",
        "id": 360939518,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684990949
    },
    {
        "content": "<p>As you can see, the original proof calls <code>h</code> with the complements of the available sets.</p>",
        "id": 360939577,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684990982
    },
    {
        "content": "<p>Anyway, this is a low priority question (at least, for me and now). Sorry for taking so much of your time.</p>",
        "id": 360941915,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684991903
    },
    {
        "content": "<p>I mean, there is no theorem I can't prove without it, it's only about hiding technical details of some proofs.</p>",
        "id": 360941962,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684991938
    },
    {
        "content": "<p>Here's my golf of the proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">IsPreconnected</span><span class=\"o\">,</span> <span class=\"n\">compl_surjective.forall</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">P</span> <span class=\"n\">u</span> <span class=\"n\">u'</span> <span class=\"o\">:=</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">u</span> <span class=\"bp\">∪</span> <span class=\"n\">u'</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">∩</span> <span class=\"n\">u'</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span>\n  <span class=\"k\">suffices</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">u'</span><span class=\"o\">},</span> <span class=\"n\">P</span> <span class=\"n\">u</span> <span class=\"n\">u'</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u'</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"kd\">by</span>\n    <span class=\"n\">refine</span> <span class=\"n\">forall_congr'</span> <span class=\"k\">fun</span> <span class=\"n\">u</span> <span class=\"bp\">↦</span> <span class=\"n\">compl_surjective.forall.trans</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">isOpen_compl_iff</span><span class=\"o\">]</span>\n    <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">H</span> <span class=\"n\">v</span> <span class=\"n\">hu</span> <span class=\"n\">hv</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"n\">v</span> <span class=\"n\">hu</span> <span class=\"n\">hv</span><span class=\"o\">)</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">not_disjoint_iff_nonempty_inter</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">subset_compl_iff_disjoint_right</span><span class=\"o\">,</span> <span class=\"n\">compl_inter</span><span class=\"o\">,</span>\n    <span class=\"n\">compl_compl</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">refine</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"n\">huv</span> <span class=\"n\">hu</span> <span class=\"n\">hv</span> <span class=\"n\">huv'</span> <span class=\"bp\">↦</span> <span class=\"n\">h</span> <span class=\"n\">huv'</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">huv</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">h'</span> <span class=\"bp\">↦</span> <span class=\"n\">hv</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">huv'</span> <span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">resolve_left</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"n\">hx</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">h'</span> <span class=\"bp\">↦</span> <span class=\"n\">hu</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">huv'</span> <span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">resolve_right</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"n\">hx</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 360946486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684993401
    },
    {
        "content": "<p>it could be golfed a bit more with the lemma <code>a ⊆ b ∪ c → a ⊆ bᶜ → a ⊆ c</code> (i.e. <code>resolve_left</code> for subsets)</p>",
        "id": 360947091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684993571
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 360953940,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684995749
    }
]