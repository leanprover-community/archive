[
    {
        "content": "<p>Does anybody know why</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Algebra equivalences are reflexive. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">refl</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A₁</span><span class=\"w\"> </span><span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">A₁</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A₁</span><span class=\"w\"> </span><span class=\"bp\">≃+*</span><span class=\"w\"> </span><span class=\"n\">A₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">commutes'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>works in <a href=\"https://github.com/leanprover-community/mathlib4/blob/53e51368435af3437578f54eb3dc7b930e095358/Mathlib/Algebra/Algebra/Equiv.lean#L218\">Algebra/Algebra/Equiv.lean#L218</a></p>\n<p>but</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Identity map as an `AffineEquiv`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">refl</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Porting note: removed attribute</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P₁</span><span class=\"w\"> </span><span class=\"bp\">≃ᵃ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">P₁</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toEquiv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">P₁</span>\n<span class=\"w\">  </span><span class=\"n\">linear</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LinearEquiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V₁</span>\n<span class=\"w\">  </span><span class=\"n\">map_vadd'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>errors with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">refl</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"n\">applies</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">lemmas</span><span class=\"w\"> </span><span class=\"n\">proving</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∼</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">got</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">P₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">V₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_6</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst_2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst_3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AffineSpace</span><span class=\"w\"> </span><span class=\"n\">V₁</span><span class=\"w\"> </span><span class=\"n\">P₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P₁</span><span class=\"w\"> </span><span class=\"bp\">≃ᵃ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">P₁</span>\n</code></pre></div>\n<p>in <a href=\"https://github.com/leanprover-community/mathlib4/blob/5e033aa736bd1620df982693b3bb17f19ffd6c21/Mathlib/LinearAlgebra/AffineSpace/AffineEquiv.lean#L229\">LinearAlgebra/AffineSpace/AffineEquiv.lean#L229</a></p>",
        "id": 512312363,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744721633
    },
    {
        "content": "<p>Isn't it something about the order of the arguments to <code>AffineEquiv</code> vs <code>AlgEquiv</code>?</p>",
        "id": 512313250,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744721855
    },
    {
        "content": "<p>Try reordering <code>P</code> and <code>V</code></p>",
        "id": 512313708,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744721964
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/refl.20attribute/near/512313250\">said</a>:</p>\n<blockquote>\n<p>Isn't it something about the order of the arguments to <code>AffineEquiv</code> vs <code>AlgEquiv</code>?</p>\n</blockquote>\n<p>I don't quite get the point. In fact I also met this problem at <a href=\"https://github.com/acmepjz/lean-iwasawa/blob/5e49802bc024d9227b40958045bee3a6604a68ac/Iwasawalib/RingTheory/PseudoNull/Basic.lean#L186\">https://github.com/acmepjz/lean-iwasawa/blob/5e49802bc024d9227b40958045bee3a6604a68ac/Iwasawalib/RingTheory/PseudoNull/Basic.lean#L186</a>. I tried to reorder variables, but it didn't work.</p>",
        "id": 512356286,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744732013
    },
    {
        "content": "<p>That's funny that this works. <code>@[refl]</code> isn't supposed to work there, and I think it accidentally does work for some dependent type reasons.</p>\n<p>All the attribute looks for is that there are at least two arguments and that the last two are defeq. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgEquiv#doc\">docs#AlgEquiv</a> has at least two arguments, and the last two are the <code>[Algebra R A]</code> and  <code>[Algebra R B]</code> instances. If you try to unify two instances, I think that will require that <code>A</code> and <code>B</code> be defeq, which is exactly what's needed for the relation.</p>\n<p>It would be better I think if the explicit arguments were the ones that were being considered, but it's not the worst thing for the underlying algebra structures to be what's related in <code>AlgEquiv</code>.</p>",
        "id": 512372541,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744736635
    },
    {
        "content": "<p>Should <code>rfl</code> skip implicit arguments?</p>",
        "id": 512373176,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744736825
    },
    {
        "content": "<p>That's what I'm suggesting in the last paragraph, yes.</p>\n<p>It's a little complicated though, since the current logic tries to do a just single defeq. The attribute needs to keep track of which arguments are explicit (or else the tactic needs to recompute this every time).</p>",
        "id": 512376456,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744737881
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/24156\">#24156</a> fixes <code>AffineEquiv</code> using the insight that we should reorder the typeclass variables. But admittedly, this is a bit of a hack...</p>",
        "id": 512968101,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744950550
    }
]