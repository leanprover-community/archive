[
    {
        "content": "<p>In the example </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">B</span> <span class=\"kd\">extends</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n  <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"o\">:=</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Lean builds <code>b</code> as <code>B.mk (A.mk 0 a.y) 0</code> which is less efficient than <code>B.mk a 0</code> and forces unification to open up <code>A.mk</code> for defeq checks in cases where it could have figured out <code>a</code> is defeq to the RHS and not unfolded.</p>",
        "id": 389254830,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1693937998
    },
    {
        "content": "<p>I built a list of all files where such collisions occur <a href=\"https://github.com/leanprover-community/mathlib4/pull/6965\">#6965</a>. Not all are as useless at <code>x := 0</code> above.</p>",
        "id": 389255349,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1693938175
    },
    {
        "content": "<p>The end goal here is to try to stamp out the useless ones. </p>\n<p>But right now the branch is only useful for the list itself unless you are on Apple Silicon since that is the only architecture the toolchain is built for.</p>",
        "id": 389255667,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1693938296
    },
    {
        "content": "<p>The toolchain just writes to stdout the list of fields specified and the module we are in at that moment.</p>",
        "id": 389256024,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1693938422
    },
    {
        "content": "<p>Unsurprisingly Lean CI does not like this so I only built the minimal amount I needed to. I can try to build some more if anyone wants to directly use the toolchain.</p>",
        "id": 389256250,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1693938503
    },
    {
        "content": "<p>Please feel encouraged to tell me I am doing it wrong (it only took ~10 lines this way) and to suggest things.</p>",
        "id": 389256396,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1693938563
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/5b7c9d4b8da83d3c1cca7aaa4e2190c30bf09475/collisions.txt\">Here</a> is the generated list if you just want to look at that. Each line is a single instance with collisions.</p>",
        "id": 389257640,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1693939047
    },
    {
        "content": "<p>One disadvantage of my hacky method was that I didn’t know how to find the declaration name to which the term syntax I was elaborating belonged to</p>",
        "id": 389257835,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1693939108
    },
    {
        "content": "<p>Interesting! Am I right in thinking that the list linked above shows <em>all</em> potential field collisions, not just collisions where the overwriting field is actually defeq to the overwritten one (e.g. it would also flag <code>{ a with x := 1, z := 0 }</code>)? (I looked for an <code>isDefEq</code> check in the lean4 commits but couldn’t find one; did I miss it?)</p>",
        "id": 389265576,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1693942087
    },
    {
        "content": "<p>Checking <code>isDefEq</code> would probably cut it down more. But I would guess not much. Some times they are defeq but syntactically distinct. Feel free to prove me wrong!</p>",
        "id": 389274055,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1693945491
    },
    {
        "content": "<p>Gotcha! and just to be clear, you’re not saying that anything’s inefficient in how the case</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>is handled, right? This is only about the case where <code>b.toA</code> is actually the same as <code>a</code> up to unfolding?</p>",
        "id": 389274743,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1693945760
    },
    {
        "content": "<p>I just took a very coarse criteria because it was simplest to implement.</p>",
        "id": 389274892,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1693945811
    }
]