[
    {
        "content": "<p>I found this error surprising:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">error: Type mismatch</span>\n<span class=\"sd\">  e.toAddEquiv.toContinuousAddEquiv</span>\n<span class=\"sd\">has type</span>\n<span class=\"sd\">  (∀ (s : Set B), IsOpen (⇑e.toAddEquiv ⁻¹' s) ↔ IsOpen s) → A ≃ₜ+ B</span>\n<span class=\"sd\">but is expected to have type</span>\n<span class=\"sd\">  A ≃ₜ+ B</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃ₜ+</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">toContinuousAddEquiv</span><span class=\"w\"> </span><span class=\"c1\">-- surprising error</span>\n<span class=\"c1\">-- because it goes through `AddEquiv` which forgets the continuity!</span>\n\n<span class=\"c1\">-- Do we want this?</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ContinuousAlgEquiv</span><span class=\"bp\">.</span><span class=\"n\">toContinuousAddEquiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃ₜ+</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"bp\">__</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃ₜ+</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">toContinuousAddEquiv</span><span class=\"w\"> </span><span class=\"c1\">-- now works</span>\n</code></pre></div>\n<p>Should mathlib have <code>ContinuousAlgEquiv.toContinuousAddEquiv</code> or is the correct fix something more subtle?</p>",
        "id": 564229914,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765971514
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousAlgEquiv#doc\">docs#ContinuousAlgEquiv</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousAddEquiv#doc\">docs#ContinuousAddEquiv</a> )</p>",
        "id": 564235114,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1765973219
    },
    {
        "content": "<p>i think this would be fixed if it extended <code>ContinuousAddEquiv</code> instead of <code>Homeomorph</code>?</p>",
        "id": 564235535,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1765973343
    },
    {
        "content": "<p>it's possible the reason that's not currently the case is because it could bring with it some bad import chains</p>",
        "id": 564235747,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1765973400
    },
    {
        "content": "<p>Rather than changing the definition should I just add the declaration? It fits perfectly in <code>Mathlib.Topology.Algebra.Algebra.Equiv</code>. I think that changing the definition will cause far more disruption and we don't have any particular need to change the definition?</p>",
        "id": 564237701,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765974069
    },
    {
        "content": "<p>i think adding the declaration should be fine too.</p>\n<p>note that we also should get API explaining how the coercions interact (so things like <code>e.toContinuousAddEquiv.toAddEquiv = e.toAddEquiv</code>, <code>e.toContinuousAddEquiv.toHomeomorph = e.toHomeomorph, FunLike.coe e.toContinousAddEquiv = FunLike.coe e</code> etc.), as well as how it interacts with operations like <code>symm</code> and <code>trans</code></p>",
        "id": 564239498,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1765974669
    },
    {
        "content": "<p>Should <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddEquiv.toContinuousAddEquiv#doc\">docs#AddEquiv.toContinuousAddEquiv</a> be called instead something like <code>ContinuousAddEquiv.ofAddEquiv</code> to avoid such a collision</p>",
        "id": 564356869,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766012510
    }
]