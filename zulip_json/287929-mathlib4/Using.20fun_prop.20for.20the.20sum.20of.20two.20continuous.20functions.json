[
    {
        "content": "<p>Why does the first one work but the second one does not?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">add'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span>\n</code></pre></div>",
        "id": 573888237,
        "sender_full_name": "Yongxi Lin (Aaron)",
        "timestamp": 1771067972
    },
    {
        "content": "<p>We have a convention that certain lemmas about properties of functions are supposed to be formulated twice, once in \"eta-expanded\" form and once not; see e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Differentiable.add#doc\">docs#Differentiable.add</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Differentiable.fun_add#doc\">docs#Differentiable.fun_add</a>. (The latter is autogenerated from the former using the <code>@[to_fun]</code> decorator.)</p>\n<p>It looks like this wasn't carried out for <code>Continuous.add</code>.</p>",
        "id": 573890357,
        "sender_full_name": "David Loeffler",
        "timestamp": 1771069353
    },
    {
        "content": "<p>I can make a PR to address this</p>",
        "id": 573891390,
        "sender_full_name": "Yongxi Lin (Aaron)",
        "timestamp": 1771070312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Using.20fun_prop.20for.20the.20sum.20of.20two.20continuous.20functions/near/573890357\">said</a>:</p>\n<blockquote>\n<p>We have a convention that certain lemmas about properties of functions are supposed to be formulated twice, once in \"eta-expanded\" form and once not; see e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Differentiable.add#doc\">docs#Differentiable.add</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Differentiable.fun_add#doc\">docs#Differentiable.fun_add</a>. (The latter is autogenerated from the former using the <code>@[to_fun]</code> decorator.)</p>\n<p>It looks like this wasn't carried out for <code>Continuous.add</code>.</p>\n</blockquote>\n<p>I don't think we have that convention at all. We allow this in situations where it's really necessary, but there is no consensus that we want to duplicate all such lemmas.</p>\n<p>I am actually surprised that <code>fun_prop</code> fails for the second one, I thought that it had logic to deal with this.</p>",
        "id": 574083510,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1771239597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Using.20fun_prop.20for.20the.20sum.20of.20two.20continuous.20functions/near/574083510\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Using.20fun_prop.20for.20the.20sum.20of.20two.20continuous.20functions/near/573890357\">said</a>:<br>\nI don't think we have that convention at all. We allow this in situations where it's really necessary, but there is no consensus that we want to duplicate all such lemmas.</p>\n</blockquote>\n<p><a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/502460714\">#mathlib4 &gt; Convention for &#96;f &#42; g&#96; and / or &#96;fun x ‚Ü¶ f x &#42; g x&#96; @ üí¨</a> caused <a href=\"https://leanprover-community.github.io/contribute/naming.html#unexpanded-and-expanded-forms-of-functions\">this</a> to be added to the naming convention, and the <code>@[to_fun]</code> attribute.<br>\nIn the same thread at <a href=\"#narrow/channel/287929-mathlib4/topic/Convention.20for.20.60f.20*.20g.60.20and.20.2F.20or.20.60fun.20x.20.E2.86.A6.20f.20x.20*.20g.20x.60/near/502728182\">#mathlib4 &gt; Convention for &#96;f &#42; g&#96; and / or &#96;fun x ‚Ü¶ f x &#42; g x&#96; @ üí¨</a> it was said that <code>fun_</code> shouldn't be added to names if the unexpanded form will never exist.<br>\nIt was never said explicitly, but the conclusion of that thread does seem to imply we should use <code>@[to_fun]</code> wherever possible.</p>",
        "id": 574099769,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1771245421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"669043\">Yongxi Lin (Aaron)</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Using.20fun_prop.20for.20the.20sum.20of.20two.20continuous.20functions/near/573891390\">said</a>:</p>\n<blockquote>\n<p>I can make a PR to address this</p>\n</blockquote>\n<p>To cross-link, this happened in <a href=\"https://github.com/leanprover-community/mathlib4/pull/35306\">#35306</a></p>",
        "id": 574099959,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1771245479
    },
    {
        "content": "<p>You have a fair point: the naming conventions do say</p>\n<blockquote>\n<p>If there is no need to disambiguate because a lemma is given using only the expanded form, the prefix <code>fun_</code> is not required.</p>\n</blockquote>\n<p>That does not imply \"we need to duplicate each lemma every time\". (And I would disagree with that.)</p>",
        "id": 574191623,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1771281290
    },
    {
        "content": "<p>My favourite outcome would be that</p>\n<ul>\n<li>we find out why fun_prop fails in the second example</li>\n<li>we fix this underlying cause, and</li>\n<li>we revert <a href=\"https://github.com/leanprover-community/mathlib4/pull/35306\">#35306</a> as it is no longer necessary.</li>\n</ul>",
        "id": 574191872,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1771281452
    },
    {
        "content": "<p>For the root cause: my understanding was the fun_prop uses the refined discrimination tree by <span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span>, and that treats <code>f * g</code> and its eta-expanded version the same --- so fun_prop should treat them the same. Perhaps you can comment on that, Jovan and <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>?</p>",
        "id": 574191873,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1771281454
    },
    {
        "content": "<p>It was originally my idea to have the discrimination tree treat <code>f * g</code> the same as <code>fun x =&gt; f x * g x</code>. But typically for performance, we want to run unification in the <code>reducible</code> transparency, and unfortunately we need the <code>reducible_and_instances</code> transparency to unify these two forms. So this idea is not actually used now.</p>",
        "id": 574192272,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1771281760
    },
    {
        "content": "<p>I could imagine a world where <code>pull fun _ =&gt; _</code> is part of the preprocessing that <code>fun_prop</code> does whenever the function in question is not a lambda function. This way, we only need the <code>fun</code> version of any lemma to be tagged with <code>fun_prop</code>.</p>",
        "id": 574192617,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1771282010
    },
    {
        "content": "<p>But you would also have to do that preprocessing to local hypotheses, no?</p>",
        "id": 574192872,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1771282199
    },
    {
        "content": "<p>If we do that, then <code>fun_prop</code> will also be able to solve this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">fun_prop</span>\n</code></pre></div>",
        "id": 574193124,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1771282380
    },
    {
        "content": "<p>Hmm, in that case what should be the syntax for creating a <code>fun_</code> lemma and tagging only that version with <code>fun_prop</code>. Should it be the <code>to_fun_prop</code> attribute? <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 574196267,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1771284498
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Using.20fun_prop.20for.20the.20sum.20of.20two.20continuous.20functions/near/574191873\">said</a>:</p>\n<blockquote>\n<p>For the root cause: my understanding was the fun_prop uses the refined discrimination tree by <span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span>, and that treats <code>f * g</code> and its eta-expanded version the same --- so fun_prop should treat them the same. Perhaps you can comment on that, Jovan and <span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span>?</p>\n</blockquote>\n<p>The issue is not with eta expansion but the the reduction <code>(f + g) x ==&gt; f x + g x</code>. <code>fun_prop</code> internally changes the functions to <code>fun x =&gt; (f + g) x</code> but it won't do the reduction to <code>fun x =&gt; f x + g x</code>.</p>\n<p><code>fun_prop</code> keeps track of the indices of the  function arguments it knows something about. The theorem <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Continuous.fun_add#doc\">docs#Continuous.fun_add</a> is compositional form for the first and second argument of <code>+</code>/<code>HAdd.hAdd</code>, the theorem <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Continuous.add#doc\">docs#Continuous.add</a> is simple form for the third argument.</p>\n<p>Compositional form for all three arguments would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">add''</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"bp\">‚Üø</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"bp\">‚Üø</span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span>\n</code></pre></div>\n<p>which is still not solvable purely by <code>fun_prop</code>  and needs <code>dsimp</code> or something before.</p>",
        "id": 574231365,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1771314139
    },
    {
        "content": "<p>In this example too, using <code>pull fun _ =&gt; _</code> does the trick:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">module</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">add''</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"bp\">‚Üø</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"bp\">‚Üø</span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Continuous</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">pull</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"c1\">-- changes the goal to `Continuous fun x =&gt; f x (h x) + g x (h x)`</span>\n<span class=\"w\">  </span><span class=\"n\">fun_prop</span>\n</code></pre></div>",
        "id": 574237096,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1771316763
    },
    {
        "content": "<p>Yes, whatever is capable of doing the reduction <code>(f + g) x = f x + g x</code></p>",
        "id": 574237640,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1771316970
    },
    {
        "content": "<p>We could experiment with adding and option to preprocess the function with a custom <code>conv</code> tactic like <code>pull</code> or <code>simp</code>.</p>",
        "id": 574261878,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1771325175
    }
]