[
    {
        "content": "<p>Having finished one project I am returning to my previous PRs, in particular <a href=\"https://github.com/leanprover-community/mathlib4/pull/24540\">#24540</a> where I define the empty, vertex, point, and interval quivers. I did this in part because I personally find dealing with <code>ULift</code> and <code>ULiftHom</code> quite annoying when embedded into bundled objects I have to use frequently, <code>ULiftHom</code> especially as it tends to lead to 'defeq abuse' problems on objects; all the quivers in that file are defined so that they can be given a specific pair of universe levels for objects and morphisms.</p>\n<p>This does mean that there is some overlap with existing objects, and some uncertainty as to where exactly that file belongs. The <code>Empty</code> quiver could just as easily be defined as a category, for example, and its only difference with the existing category instance on <code>PEmpty</code> is that, again, it can be given an explicit universe level for its morphisms. The only objects that <em>have</em> to be quivers are <code>Vertex</code> (the quiver with one vertex and no edges at all) and <code>Interval</code> (the quiver with two vertices and the edge between them), as they lack identities; everything else could, I suppose, be put into <code>Cat</code> instead. Not coincidentally, those are the ones I consider most important from that PR, as I use them later in the project and they can't easily be replaced by existing objects.</p>\n<p>Where should these objects go? <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> , you had some opinions on the matter when I first made the PR?</p>",
        "id": 546571595,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1761179455
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Place.20for.20'shapes'.20of.20simple.20quivers.20and.20categories.2E/near/546571595\">said</a>:</p>\n<blockquote>\n<p>The <code>Empty</code> quiver could just as easily be defined as a category, for example, and its only difference with the existing category instance on <code>PEmpty</code> is that, again, it can be given an explicit universe level for its morphisms.</p>\n</blockquote>\n<p>Why isn't that possible for the category?</p>",
        "id": 546573107,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761180732
    },
    {
        "content": "<p>Same reason my PR for doing it for <code>Discrete</code> got mostly-rejected: it's not <em>impossible</em>, but it results in universe level unification issues down the line in a bunch of uses that don't actually need the capability and would rather not be concerned with it. Personally I would rather live with it but <em>shrug</em>.</p>",
        "id": 546573179,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1761180786
    },
    {
        "content": "<p>We used to have versions of basic shapes of categories with extraneous universe parameters (e.g. there was one <code>WalkingParallelPair</code> in each universe). It was terrible. Since <a href=\"https://github.com/leanprover-community/mathlib3/pull/15067\">https://github.com/leanprover-community/mathlib3/pull/15067</a> we have only one of these, in <code>Type 0</code>, and the category theory works much better now. I would not like we revert this design choice by introducing irrelevant universe parameters again when dealing with <em>unbundled</em> objects like categories or quivers.<br>\nWhat I would suggest is defining types with <code>Quiver/Category</code> instances with the lowest possible universe only.<br>\nIf you need to work in <code>Quiv</code> or <code>Cat</code>, then you may define terms by ulifting these constructions to the expected universes.</p>",
        "id": 546590903,
        "sender_full_name": "Joël Riou",
        "timestamp": 1761195928
    },
    {
        "content": "<p>In that case, why not just make bundled <code>Cat</code> and <code>Quiv</code> objects with the right universe levels? Again, I don't like the <code>ULift</code> option; not only does it add a nontrivial amount of mental noise (especially since <code>rcases</code> doesn't respect <code>cases_eliminator</code>), but <code>ULiftHom</code> actually introduces defeq problems that e.g. make <code>simp</code> lemmas not fire</p>",
        "id": 546591163,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1761196123
    },
    {
        "content": "<p>There have been a few instances where not defining the unbundled objects first made things more ackward afterwards. There may be issues with ulift, but I think it is better to improve the API.<br>\nFor example, in the context of simplicial sets, ulift appears in the definition of the standard simplex in <code>SSet.{u}</code>, but the API makes it so that most of the times we do not even have to think that there is a ulift.</p>",
        "id": 546593093,
        "sender_full_name": "Joël Riou",
        "timestamp": 1761197711
    },
    {
        "content": "<p>Mm. The issue is that to my knowledge, you <em>can't</em>  actually make API that <code>rcases</code> and <code>casesm</code>, and their derived tactics, will recognize. For some purposes, that <em>might</em> not be a total dealbreaker, as I can probably make do with 'opaque' lift/desc defs and associated lemmas, but esp. with the walking quiver there are proofs that are currently best done via <code>rintro</code> that will break if I have to use a 'non-canonical' matcher -- in particular, <code>ULiftHom</code>.</p>",
        "id": 546806774,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1761279345
    },
    {
        "content": "<p>Let us say you define a certain quiver <code>C : Type 0</code> using inductive types, and you want to compute the type of prefunctors from <code>C</code> to a quiver <code>D</code> in any universe. You may first do that with the universe polymorphic API of quivers. Then, in order to translate this into a computation of morphisms in <code>Quiv</code>, you just need to know that prefunctors from <code>C</code> or from the ulifted version of <code>C</code> can be identified: as this works for any <code>C</code>, there is no need to do induction on <code>C</code> or the type of morphisms in <code>C</code>.</p>",
        "id": 546823376,
        "sender_full_name": "Joël Riou",
        "timestamp": 1761289228
    }
]