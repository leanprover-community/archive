[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"673690\">Raphael Douglas Giles</span> has marked this topic as unresolved.</p>",
        "id": 524916861,
        "sender_full_name": "Notification Bot",
        "timestamp": 1750349904
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/product.20of.20morphisms.20in.20product.20category/near/465084232\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.prod#doc\">docs#CategoryTheory.prod</a> says you are right. Try doing <code>#check F.map (Prod.mk f1 f2 : (X1, X2) ⟶ (Y1, Y2))</code></p>\n</blockquote>\n<p>Why do we need to provide the type annotations here? We can't tell from reading the docs why that should be necessary</p>",
        "id": 524917375,
        "sender_full_name": "Raphael Douglas Giles",
        "timestamp": 1750350133
    },
    {
        "content": "<p>because <code>X ⟶ Y</code> isn't <em>reducibly</em> defeq to <code>(X.1 ⟶ Y.1) × (X.2 ⟶ Y.2)</code></p>",
        "id": 524917770,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750350301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/product.20of.20morphisms.20in.20product.20category/near/524917770\">said</a>:</p>\n<blockquote>\n<p>because <code>X ⟶ Y</code> isn't <em>reducibly</em> defeq to <code>(X.1 ⟶ Y.1) × (X.2 ⟶ Y.2)</code></p>\n</blockquote>\n<p>It seems to me that we need something weaker, i.e. that <code>(X1, X2) ⟶ (Y1, Y2) = (X1 ⟶ Y1) × (X2 ⟶ Y2)</code>, and this is is the case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y2</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X1</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X2</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y2</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">    </span><span class=\"n\">dsimp</span>\n</code></pre></div>\n<p>So we're unsure of what's going on here.</p>",
        "id": 525014046,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1750414252
    },
    {
        "content": "<p>Can you provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>",
        "id": 525014204,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750414310
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Products</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">hom_product</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X1</span><span class=\"w\"> </span><span class=\"n\">X2</span><span class=\"w\"> </span><span class=\"n\">Y1</span><span class=\"w\"> </span><span class=\"n\">Y2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X1</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X2</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y2</span><span class=\"o\">}:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">X1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y2</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X1</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X2</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y2</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">    </span><span class=\"n\">dsimp</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>",
        "id": 525014259,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1750414334
    },
    {
        "content": "<p>Here is the solution:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Products</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">hom_product</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X1</span><span class=\"w\"> </span><span class=\"n\">X2</span><span class=\"w\"> </span><span class=\"n\">Y1</span><span class=\"w\"> </span><span class=\"n\">Y2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X1</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X2</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y2</span><span class=\"o\">}:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">X1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">f1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 525014467,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750414428
    },
    {
        "content": "<p>Now what is your question, exactly? <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 525014532,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750414453
    },
    {
        "content": "<p>We want to understand why we can't apply <code>F.map</code> to the morphism <code>⟨f1, f2⟩</code>; the original question mentioned that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- error</span>\n</code></pre></div>\n<p>gives an error.</p>\n<p>As you suggested then, giving type annotations work. But we don't understand why this is needed, since <code>(X1, X2) ⟶ (Y1, Y2) = (X1 ⟶ Y1) × (X2 ⟶ Y2)</code> definitionally. Lean knows the type of <code>⟨f1, f2⟩</code> is the rhs of the equation, so it should be able to infer that what we mean by <code>F.map (Prod.mk f1 f2)</code>, but it doesn't.</p>\n<p>Always giving type annotations is quite cumbersome when dealing with a lot of profunctors, this is furthermore a context where currying is not always possible.</p>",
        "id": 525015494,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1750414868
    },
    {
        "content": "<p>In the mean time, I reverse-engineered your MWE to the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Products</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X₁</span><span class=\"w\"> </span><span class=\"n\">X₂</span><span class=\"w\"> </span><span class=\"n\">Y₁</span><span class=\"w\"> </span><span class=\"n\">Y₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X₁</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y₁</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X₂</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y₂</span><span class=\"o\">}</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">f₁</span><span class=\"w\"> </span><span class=\"n\">f₂</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Application type mismatch: In the application</span>\n<span class=\"cm\">  (?m.297, f₂)</span>\n<span class=\"cm\">the argument</span>\n<span class=\"cm\">  f₂</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  X₂ ⟶ Y₂ : Type ?u.117</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  ?m.264.2 ⟶ ?m.265.2 : Type ?u.117</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 525015793,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750414994
    },
    {
        "content": "<p>(In the future, please provide a MWE that actually displays the error you want people to see!)</p>",
        "id": 525015886,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750415037
    },
    {
        "content": "<p>Sorry for being unclear, my questions were meant to be a continuation of the original question, so I was talking about that specific MWE.</p>",
        "id": 525016073,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1750415128
    },
    {
        "content": "<p>Since <code>X ⟶ Y</code> for <code>X Y : C × C</code> is defined as <code>(X.1 ⟶ Y.1) × (X.2 ⟶ Y.2)</code>, when trying to solve for <code>Prod.mk f₁ f₂ : ?X ⟶ ?Y</code>, Lean unfolds this to <code>Prod.mk f₁ f₂ : (?X.1 ⟶ ?Y.1) × (?X.2 ⟶ ?Y.2)</code></p>",
        "id": 525016417,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750415278
    },
    {
        "content": "<p>It then tries to match <code>X₁</code> with <code>?X.1</code>, <code>Y₁</code> with <code>?Y.1</code>, <code>X₂</code> with <code>?X.2</code>, <code>Y₂</code> with <code>?Y.2</code></p>",
        "id": 525016428,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750415283
    },
    {
        "content": "<p>My experience with morphisms in product categories is also that they’re a pain, and that you have to provide annotations at random places.</p>\n<p>Should they be refactored to be a two-field struct that would let us write <code>⟨f₁, f₂⟩</code>? I don’t think we gain much by wanting the homs to be defeq to a product, just that it \"behaves like a product\".</p>",
        "id": 525016501,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1750415314
    },
    {
        "content": "<p>This is where the algorithm gets stuck, since it doesn't know it can set <code>?X := (X₁, X₂)</code>, <code>?Y := (Y₁, Y₂)</code></p>",
        "id": 525016514,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750415320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/287929-mathlib4/topic/product.20of.20morphisms.20in.20product.20category/near/525016501\">said</a>:</p>\n<blockquote>\n<p>Should they be refactored to be a two-field struct that would let us write <code>⟨f₁, f₂⟩</code>? I don’t think we gain much by wanting the homs to be defeq to a product, just that it \"behaves like a product\".</p>\n</blockquote>\n<p>That wouldn't fix anything here, cf my explanation before and after your message</p>",
        "id": 525016591,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750415355
    },
    {
        "content": "<p>What you need is a constructor of the form <code>(X₁ ⟶ Y₁) → (X₂ ⟶ Y₂) → ((X₁, X₂) ⟶ (Y₁, Y₂))</code>, as opposed to the current <code>Prod.mk : (X.1 ⟶ Y.1) → (X.2 ⟶ Y.2) → (X ⟶ Y)</code></p>",
        "id": 525016836,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750415460
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Over.homMk#doc\">docs#CategoryTheory.Over.homMk</a> is painful to use for the same reason</p>",
        "id": 525016961,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750415508
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MulEquiv.toCommGrpIso#doc\">docs#MulEquiv.toCommGrpIso</a> also follows the bad pattern</p>",
        "id": 525017036,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750415537
    },
    {
        "content": "<p>In contrast, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CommRingCat.ofHom#doc\">docs#CommRingCat.ofHom</a> is well-designed</p>",
        "id": 525017125,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750415573
    },
    {
        "content": "<p>Welp, if the solution is that easy, <a href=\"https://github.com/leanprover-community/mathlib4/pull/26206\">#26206</a>, and I guess there’ll be a second PR to use it instead of type annotations everywhere, but this will be more of a pain to write.</p>",
        "id": 525018734,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1750416275
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/product.20of.20morphisms.20in.20product.20category/near/525016514\">said</a>:</p>\n<blockquote>\n<p>This is where the algorithm gets stuck, since it doesn't know it can set <code>?X := (X₁, X₂)</code>, <code>?Y := (Y₁, Y₂)</code></p>\n</blockquote>\n<p>Thanks for the clear explanation! I don't understand why it gets stucked here but the proposed solution works, so all is great now :)</p>",
        "id": 525039145,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1750424615
    }
]