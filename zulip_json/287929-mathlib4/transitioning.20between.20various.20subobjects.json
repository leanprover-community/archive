[
    {
        "content": "<p>Currently, transitioning between various subobjects can be quite painful at times. I would like to lessen this burden. To give just a small flavor of what I mean, consider the following goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">AddSubmonoid</span><span class=\"bp\">.</span><span class=\"n\">closure_subset_span</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">AddSubmonoid</span><span class=\"bp\">.</span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>While this is relatively easy to prove, it's not absolutely immediate, as one would hope. Moreover, there would be a similar lemma for subalgebras, etc., which leads you to want to prove the following lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SubmonoidClass</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Submonoid</span><span class=\"bp\">.</span><span class=\"n\">closure_subset</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Submonoid</span><span class=\"bp\">.</span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This is totally natural, but it's actually surprisingly annoying to prove with the current state of Mathlib (unless someone proves me wrong aside from what follows below). One \"natural\" way to prove it is to construct a <code>Submonoid</code> with carrier <code>(↑s : Set M)</code>, and then apply <code>Submonoid.closure_le</code>, but it's annoying to need to do this. We could, as we do with morphisms, create coercions from subobject classes to the relevant subobjects, but I can already hear <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>'s cries of anguish (not to mention the cries of Lean's elaborator) at the idea.</p>",
        "id": 455449019,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1722448496
    },
    {
        "content": "<p>Instead, I propose to do something different. I want to add the following <code>CanLift</code> instances for subobjects across Mathlib. In this way, we can always lift the coercion to <code>Set</code> of an element in a subobject class to whichever subobject kind we want. Moreover, the <code>using</code> portion should always be provable <code>by aesop</code>. In this way, it should be relatively painless to pass between various \"copies\" of a subobject of different kinds within a single proof, all of them united by the fact that they have the same coercion to set. As this example shows, the ability to use <code>lift</code> makes the proof trivial.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SubmonoidClass</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CanLift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Submonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">prf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">one_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Submonoid</span><span class=\"bp\">.</span><span class=\"n\">closure_subset</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Submonoid</span><span class=\"bp\">.</span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">Submonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Submonoid</span><span class=\"bp\">.</span><span class=\"n\">mem_of_mem_closure</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Submonoid</span><span class=\"bp\">.</span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Submonoid</span><span class=\"bp\">.</span><span class=\"n\">closure_subset</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n</code></pre></div>\n<p>Thoughts?</p>",
        "id": 455449030,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1722448501
    },
    {
        "content": "<p>Not against the idea in general, but I don't think that this is that annoying to prove?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SubmonoidClass</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Submonoid</span><span class=\"bp\">.</span><span class=\"n\">closure_subset</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Submonoid</span><span class=\"bp\">.</span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Submonoid</span><span class=\"bp\">.</span><span class=\"n\">closure_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_mem</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">one_mem</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 455458140,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1722451227
    },
    {
        "content": "<p>Also for <code>HomClass</code>s, we have things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHomClass.toRingHom#doc\">docs#RingHomClass.toRingHom</a>. Maybe we can copy it here?</p>",
        "id": 455458268,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1722451286
    },
    {
        "content": "<p>either that or generalize the api to using <code>SubMonoidClass</code> rather than <code>Submonoid</code>?</p>",
        "id": 455458477,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1722451379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/287929-mathlib4/topic/transitioning.20between.20various.20subobjects/near/455458140\">said</a>:</p>\n<blockquote>\n<p>but I don't think that this is that annoying to prove?</p>\n</blockquote>\n<p>For submonoids, you can just fill all the stuff manually, sure, but it gets annoying when you're working with say, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subalgebra#doc\">docs#Subalgebra</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=StarSubalgebra#doc\">docs#StarSubalgebra</a>. And it would be nice to not to be forced to fill the arguments.</p>",
        "id": 455459521,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1722451828
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/287929-mathlib4/topic/transitioning.20between.20various.20subobjects/near/455458268\">said</a>:</p>\n<blockquote>\n<p>Also for <code>HomClass</code>s, we have things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHomClass.toRingHom#doc\">docs#RingHomClass.toRingHom</a>. Maybe we can copy it here?</p>\n</blockquote>\n<p>I mentioned this in my post. These are the coercions which, while we <em>could</em> have them, I think we may want to avoid.</p>",
        "id": 455459631,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1722451874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/287929-mathlib4/topic/transitioning.20between.20various.20subobjects/near/455458477\">said</a>:</p>\n<blockquote>\n<p>either that or generalize the api to using <code>SubMonoidClass</code> rather than <code>Submonoid</code>?</p>\n</blockquote>\n<p>You can't do that without (a) writing the coercions that have been discussed, or (b) significantly decreasing the utility of the API. This is because if <code>s : S</code> with <code>SubmonoidClass S M</code> and <code>t : Set M</code>, you can't make sense of <code>Submonoid.closure t ≤ s</code>, because you can't coerce (without adding a new coercion) <code>↑s : Submonoid M</code>, so the <code>≤</code> can't make sense. That is, unless you go to sets, but that decreases the utility of the API for honest-to-god <code>Submonoid</code>s.</p>",
        "id": 455460009,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1722452049
    },
    {
        "content": "<p>If you want a more real-world example of where the lack of this API can really bite you, please witness the contortions necessary in <a href=\"https://github.com/leanprover-community/mathlib4/pull/12889\">#12889</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/13326\">#13326</a>. There I ended up proving something related to <code>Submonoid.closure_subset</code> above which is in the library as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.coe_span_eq_self#doc\">docs#Submodule.coe_span_eq_self</a>. That particular declaration is not the main pain point of the PR, only an example that this has come up before for me.</p>",
        "id": 455460775,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1722452406
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/transitioning.20between.20various.20subobjects/near/455459631\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/287929-mathlib4/topic/transitioning.20between.20various.20subobjects/near/455458268\">said</a>:</p>\n<blockquote>\n<p>Also for <code>HomClass</code>s, we have things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHomClass.toRingHom#doc\">docs#RingHomClass.toRingHom</a>. Maybe we can copy it here?</p>\n</blockquote>\n<p>I mentioned this in my post. These are the coercions which, while we <em>could</em> have them, I think we may want to avoid.</p>\n</blockquote>\n<p>I don't like the coercions of homomorphisms at all but I could see them useful as standalone defs. (That is, writing <code>.ofClass S</code> manually if you have a <code>Submonoid.ofClass</code>)</p>",
        "id": 455461009,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1722452464
    },
    {
        "content": "<p>I could see that, although I think the <code>CanLift</code> instances could be useful in their own right.</p>",
        "id": 455461340,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1722452569
    },
    {
        "content": "<p>Sorry that I have something that don't unduerstand, why we don't like the coercion from <code>AddSubgroupClass</code> to <code>AddSubgroup</code>? Is there a general reason or some examples? Thanks</p>",
        "id": 503170244,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1741058224
    },
    {
        "content": "<p>I think the biggest reason is this: you want to insert these manually. Otherwise you might end up with statements where your <code>S : Subalgebra R A</code> was coerced to a <code>Submonoid A</code> unintentionally. In general, I don't want to encourage using these in statements (so that we don't have a million and one ways to spell something), but only want them easily available in proofs, which is why I proposed <code>CanLift</code> instances.</p>",
        "id": 503170729,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1741058529
    },
    {
        "content": "<p>Thanks, I know why now.<br>\nAnother question: how should we use <code>CanLift</code>? I doesn't know how to trigger it, my original proof is failing everywhere <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 503171196,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1741058837
    },
    {
        "content": "<p><code>CanLift</code> instances are used when you call the <code>lift</code> tactic.</p>",
        "id": 503171290,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1741058883
    },
    {
        "content": "<p>Thanks, I'll try to give a fix.</p>",
        "id": 503171434,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1741058997
    },
    {
        "content": "<p>One more thing, can you have a look for <a href=\"https://github.com/leanprover-community/mathlib4/pull/22230\">#22230</a>? Is the defs and instances added correctly? Thanks</p>",
        "id": 503173071,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1741060063
    },
    {
        "content": "<p>Looks good. Can you do it for all the subobject classes you can find? (<code>Subsemigroup</code>, <code>Submodule</code>, <code>Subsemiring</code>, <code>Subring</code>, <code>NonUnitalSubsemiring</code>, <code>NonUnitalSubring</code>, <code>Subalgebra</code>, <code>NonUnitalSubalgebra</code>, <code>StarSubalgebra</code>, <code>NonUnitalStarSubalgebra</code>)</p>",
        "id": 503174263,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1741060854
    },
    {
        "content": "<p>Sorry I have another question first, is it safe to add <code>coe S (ofClass S)</code> for S of <code>SubgroupClass S G</code>, I met some problem with this so I want to add it.</p>",
        "id": 503184178,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1741066144
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/transitioning.20between.20various.20subobjects/near/503174263\">said</a>:</p>\n<blockquote>\n<p>Looks good. Can you do it for all the subobject classes you can find? (<code>Subsemigroup</code>, <code>Submodule</code>, <code>Subsemiring</code>, <code>Subring</code>, <code>NonUnitalSubsemiring</code>, <code>NonUnitalSubring</code>, <code>Subalgebra</code>, <code>NonUnitalSubalgebra</code>, <code>StarSubalgebra</code>, <code>NonUnitalStarSubalgebra</code>)</p>\n</blockquote>\n<p>This is a bit crazy, I need the coe for <code>Subgroup</code> in an existing PR, I think I can open another one.</p>",
        "id": 503184862,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1741066575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"749361\">Nailin Guan</span> <a href=\"#narrow/channel/287929-mathlib4/topic/transitioning.20between.20various.20subobjects/near/503184178\">said</a>:</p>\n<blockquote>\n<p>Sorry I have another question first, is it safe to add <code>coe S (ofClass S)</code> for S of <code>SubgroupClass S G</code>, I met some problem with this so I want to add it.</p>\n</blockquote>\n<p>It's a bit unclear what you mean. Do you mean you want a <code>Coe</code> instance from terms of an element <code>S</code> of a subgroup class to terms of <code>SubgroupClass S G</code> (e.g., you want to be able to coerce, for <code>S : Subring R</code>, some <code>x : S</code> to <code>↑x : ofClass S</code>)? if so, then no, definitely don't do that.</p>",
        "id": 503294120,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1741101576
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"749361\">Nailin Guan</span> <a href=\"#narrow/channel/287929-mathlib4/topic/transitioning.20between.20various.20subobjects/near/503184862\">said</a>:</p>\n<blockquote>\n<p>This is a bit crazy</p>\n</blockquote>\n<p>It should only be around ~100 lines of mostly copy paste?</p>",
        "id": 503295899,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1741101837
    },
    {
        "content": "<p>I've done the rest of this in <a href=\"https://github.com/leanprover-community/mathlib4/pull/23708\">#23708</a></p>",
        "id": 510406208,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743883024
    }
]