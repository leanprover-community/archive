[
    {
        "content": "<p>I am trying to use <code>swap_induction_on</code> from <code>Equiv.Perm</code>in the process of proving the following theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">swap_theorem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Func</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">swap_func_comp</span><span class=\"w\"> </span><span class=\"n\">l</span>\n</code></pre></div>\n<p>Here's a quick explaination of the intended meaning:</p>\n<ul>\n<li>for every function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>V</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>B</mi><mi>o</mi><mi>o</mi><mi>l</mi><mi>n</mi><mo>→</mo><mi>V</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>B</mi><mi>o</mi><mi>o</mi><mi>l</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">f : Vector Bool n → Vector Bool n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">ec</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\">oo</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">ec</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\">oo</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">n</span></span></span></span> that is an isomorphism, there exists a list of swaps whose product is equivalent to f.</li>\n<li>This is translated as a function <code>swap_func_comp</code> that takes a list of vectors and swaps every two elemts from the list.</li>\n</ul>\n<p>The proof I have so far is the following </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">swap_theorem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Func</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">swap_func_comp</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- provide the corresponding permutation</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">iso_equiv_perm</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"bp\">⟩</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- manipulate the goal to be able to apply swap_induction_on</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">getSwapList</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">revert</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- apply induction on the permutation p</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">swap_induction_on</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">swap_func_comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">getSwapList</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>My issue is that I do not fully understand how <code>swap_induction_on</code> works. The <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/GroupTheory/Perm/Sign.html#Equiv.Perm.swap_induction_on\">documentation</a> says:</p>\n<blockquote>\n<p>An induction principle for permutations. If <code>P</code> holds for the identity permutation, and is preserved under composition with a non-trivial swap, then <code>P</code> holds for all permutations.</p>\n</blockquote>\n<p>Firstly, I had to provide the implied parameters to it, as a simple <code>apply swap_induction_on p</code> kept giving the error <code>failed to elaborate eliminator, expected type is not available</code>.<br>\nThen, in the base case, which my understanding tells me is when <code>p</code> is <code>1</code>, the goal state doesn't provide me with such a premise, as it is simply the following for <code>case h.h.a</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Func</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">swap_func_comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">getSwapList</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>Can I get an explanation on this, and is this tactic useful at all?</p>",
        "id": 507904337,
        "sender_full_name": "Abdullah Al Kayal",
        "timestamp": 1742864455
    },
    {
        "content": "<p>Can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 507904790,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742864755
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  For sure! <br>\nHere's my best attempt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">GroupTheory</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"bp\">.</span><span class=\"n\">Cycle</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Perm</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">true_P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mwe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">true_P</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">by</span>\n\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">swap_induction_on</span>\n<span class=\"w\">    </span><span class=\"n\">Bool</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"n\">true_P</span>\n<span class=\"w\">    </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The goal state before <code>sorry</code> is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">true_P</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>In this case, the goal is trivially true and the theorem doesn't require induction. However I hope it illustrates my confusion about the following question:<br>\nWhy don't I get <code>p = 1</code> in the premices for the base case of the <code>swap_induction_on</code>?</p>",
        "id": 507905860,
        "sender_full_name": "Abdullah Al Kayal",
        "timestamp": 1742865383
    },
    {
        "content": "<p>Does <a href=\"https://github.com/leanprover-community/mathlib4/pull/23290\">#23290</a> make it a little easier?</p>",
        "id": 507909720,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742867816
    },
    {
        "content": "<p>I think you're making things hard for yourself by using <code>apply</code>, which disables the automatic behavior</p>",
        "id": 507909771,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742867860
    },
    {
        "content": "<p>Using <code>refine</code> or better <code>induction ... using</code> should do the hard work for you</p>",
        "id": 507909787,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742867873
    },
    {
        "content": "<p>on a side note, instead of using <code>@</code> with a bunch of underscores, I think it's cleaner to provide the parameters explicitly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">swap_induction_on</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true_P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>but Eric's suggestion to use <code>induction ... using</code> is a great idea and it should allow you to avoid all the parameter issues in the first place</p>",
        "id": 507910861,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1742868411
    },
    {
        "content": "<p>(you don't need the PR I linked above to do that, only to use <code>with</code>)</p>",
        "id": 507910973,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742868478
    },
    {
        "content": "<p><code>induction ... using</code> works perfectly. Thank you!</p>",
        "id": 507913042,
        "sender_full_name": "Abdullah Al Kayal",
        "timestamp": 1742869692
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"784523\">Abdullah Al Kayal</span> has marked this topic as resolved.</p>",
        "id": 507913053,
        "sender_full_name": "Notification Bot",
        "timestamp": 1742869704
    }
]