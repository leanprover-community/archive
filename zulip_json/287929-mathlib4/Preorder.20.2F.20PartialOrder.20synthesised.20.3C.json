[
    {
        "content": "<p>I was experimenting with partial orders in Lean and was very surprised to find that using PartialOrder automatically synthesises a LT operator &lt; from LE ‚â§. Even more so because for the application I am thinking about, the synthesised &lt;, which is defined as a &lt; b := a ‚â§ b ‚àß ¬¨b ‚â§ a, is definitely not what one wants! There also doesn't seem to be any way around this (there are no subclasses of PartialOrder with just ‚â§ and its properties).</p>\n<p>I looked for Zulip threads or Github issues mentioning this but couldn't find anything, am I missing something?</p>\n<p>I also looked in the source file and docs, and there's no real rationale given, only the following comment in  mathlib4/Mathlib/Order/Defs/PartialOrder.lean :</p>\n<p>/-- A preorder is a reflexive, transitive relation <code>‚â§</code> with <code>a &lt; b</code> defined in the obvious way. -/</p>\n<p>I notice the files  mathlib4/Mathlib/Order/Defs/PartialOrder.lean (de Moura, 2016) and mathlib4/Mathlib/Order/Basic.lean (Avigad, Carneiro 2014) pretty old. Maybe this was just added for convenience for certain uses, and the design wasn't deeply thought through or discussed at the time. But it seems like an unnecessarily non-orthogonal design, and makes life awkward if the particular choice of &lt; is not what one wants.</p>\n<p>Alternative definitions of &lt; which are natural in certain contexts are:</p>\n<ul>\n<li>For f,g:X‚ÜíY with a partial order on Y, define f &lt; g ‚Üî ‚àÄ x, f x &lt; g x</li>\n<li>On a topological space X, we often have { (x1, x2) | x1 ‚â§ x2 } a closed set, and want { (x1, x2) | x1 &lt; x2 } to be open, so taking the interior makes sense. In general, { (x1, x2) | (x1 ‚â§ x2) ‚àß ( ¬¨ (x2 ‚â§ x1) ) } is neither closed nor open.</li>\n<li>Computably, ‚â§ is often falsifiable, and we want &lt; to be verifiable; again the synthesised &lt; is neither falsifiable nor verifiable.<br>\nAnd in some cases, maybe you don't want to allow &lt; at all.</li>\n</ul>\n<p>Would it be possible to refactor the hierarchy to separate ‚â§ (WeakPartialOrder) and &lt; (StrictPartialOrder) with the natural properties? One could combine these into a WeakStrictPartialOrder under the less restrictive assumption a&lt;b ‚Üí a‚â§b (probably also mixed transitivity a&lt;b‚àßb‚â§c‚Üía&lt;c and a‚â§b‚àßb&lt;‚â§&gt;c‚Üía&lt;c), with the current PartialOrder on top of these. Presumably, the refactoring would not affect code only using PartialOrder.</p>",
        "id": 570301876,
        "sender_full_name": "Pieter Collins",
        "timestamp": 1769515378
    },
    {
        "content": "<p>Hi Pieter! Welcome!</p>\n<p>I think we should indeed consider this. A long time ago <code>a - b</code> was defined to be <code>a + -b</code>. We've also decoupled that. We should probably do the same here. (And using default arguments, we can still keep the current behaviour for almost all purposes.)</p>",
        "id": 570307556,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1769517035
    },
    {
        "content": "<p>Hard disagree here. A preorder comes bundled with both a ‚â§ and a &lt; relation, and they're always related via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=lt_iff_le_not_ge#doc\">docs#lt_iff_le_not_ge</a>. If that's not what you have, then you don't have a preorder.</p>",
        "id": 570415924,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1769545638
    },
    {
        "content": "<p>What exactly is the application you have in mind?</p>",
        "id": 570417378,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1769546124
    },
    {
        "content": "<p>see also <a href=\"#narrow/channel/287929-mathlib4/topic/Conflicting.20.60.E2.89.A4.60.20and.20.60.3C.60/near/512123692\">#mathlib4 &gt; Conflicting &#96;‚â§&#96; and &#96;&lt;&#96; @ üí¨</a></p>",
        "id": 570417936,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769546340
    },
    {
        "content": "<p>If you need a custom relation that's stronger than &lt; then you should just define it and give it the appropriate API.</p>",
        "id": 570419044,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1769546780
    },
    {
        "content": "<p>Maybe that's what Pieter is proposing? And one of the question is whether &lt; can be used as notation. I don't think that's unreasonable. I'm a bit surprised that you're dismissing this so strongly.</p>",
        "id": 570420199,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1769547221
    },
    {
        "content": "<p>If I saw a type with a <code>Group</code> instance, I'd be very surprised to then find <code>a - b</code> defined as anything other than <code>a + (-b)</code>(or something equivalent). And if I saw a type with a <code>Preorder</code> instance, I'd feel the same seeing <code>a &lt; b</code> defined as anything other than <code>a ‚â§ b</code> and not <code>b ‚â§ a</code>.</p>",
        "id": 570421311,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1769547566
    },
    {
        "content": "<p>If you want a preorder without any restrictions on <code>&lt;</code>, then you may use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.IsPreorder#doc\">docs#Std.IsPreorder</a></p>",
        "id": 570422047,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769547769
    },
    {
        "content": "<p>Johan, I think Pieter's proposal is not quite comparable to the subtraction example. We already have a default argument for Preorder's <code>&lt;</code> argument, ie it already is like subtraction, and (just like subtraction), one can decouple the definition of <code>&lt;</code> from what it must be, provided we prove it's propositionally equal. Instead, this proposal would _remove_ the property of <code>&lt;</code> from PartialOrder, and thus many of the theorems about it that we currently have would become false.</p>",
        "id": 570446621,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1769559452
    },
    {
        "content": "<p>I don't think this is the proposal, from what I can tell the proposal is rather something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">GeneralPreorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le_refl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">not_ge_of_lt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_le_of_lt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_lt_of_le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">GeneralPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">lt_iff_le_not_le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">lt_iff_le_not_le</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"m\">1</span>\n<span class=\"w\">  </span><span class=\"n\">not_ge_of_lt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">lt_iff_le_not_le</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"m\">2</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_le_of_lt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÇ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">lt_iff_le_not_le</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"m\">2</span>\n<span class=\"w\">      </span><span class=\"bp\">‚ü®</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÇ</span><span class=\"o\">),</span>\n<span class=\"w\">        </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">absurd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">not_ge_of_lt</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÇ</span><span class=\"o\">)</span><span class=\"bp\">‚ü©</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_lt_of_le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÇ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">lt_iff_le_not_le</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"m\">2</span>\n<span class=\"w\">      </span><span class=\"bp\">‚ü®</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÇ</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">absurd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÇ</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">not_ge_of_lt</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h‚ÇÅ</span><span class=\"o\">)</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">GeneralPartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">GeneralPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le_antisymm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">GeneralPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>So pretty much nothing would change for someone just using <code>Preorder</code> or <code>PartialOrder</code> but there would be an earlier class, however it may be called, that makes less assumptions about <code>&lt;</code> (if we don't like <code>Preorder</code> extending it we could always also make it a separate class with the right instances).</p>",
        "id": 570448394,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1769560610
    },
    {
        "content": "<p><code>GeneralPreorder</code> feels way to permissive</p>",
        "id": 570448716,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769560844
    },
    {
        "content": "<p>you can set <code>lt a b := False</code> and it works with any <code>le</code> (that forms a preorder)</p>",
        "id": 570448736,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769560860
    },
    {
        "content": "<p>Yeah, I'm not sure what kind of properties would be reasonable to put in there; I suppose at least though</p>\n<ol>\n<li><code>lt a b := a ‚â§ b ‚àß ¬¨ b ‚â§ a</code> should satisfy those properties</li>\n<li>If <code>&lt;</code> on <code>Œ≤</code> has those properties, then <code>lt f g := ‚àÄ x : Œ±, f x &lt; g x</code> should also have those properties on <code>Œ± ‚Üí Œ≤</code></li>\n<li>If <code>‚â§</code> forms a linear order, then <code>&lt;</code> should be uniquely determined</li>\n</ol>",
        "id": 570449356,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1769561337
    },
    {
        "content": "<p>unfortunately those conditions are incompatible</p>",
        "id": 570449571,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769561494
    },
    {
        "content": "<p>ah no, the thing I was thinking of doesn't work</p>",
        "id": 570449729,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769561611
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/570449356\">said</a>:</p>\n<blockquote>\n<p>should also have those properties on <code>Œ± ‚Üí Œ≤</code></p>\n</blockquote>\n<p>I was tricked by the non-dependent arrow</p>",
        "id": 570449754,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769561630
    },
    {
        "content": "<p>There are 2 separate discussions here:</p>\n<ul>\n<li>should we change the canonical instance of <code>LT</code> on a product/pi type?</li>\n<li>if yes, then what could be the axioms describing this new instance?</li>\n</ul>",
        "id": 570450051,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769561815
    },
    {
        "content": "<p>I think that we should keep these 2 discussions separate. If we decide \"no\" for the first one, then the second one can turn into \"should we turn <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=StrongLT#doc\">docs#StrongLT</a> into a typeclass with some axioms?\"</p>",
        "id": 570450395,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769562068
    },
    {
        "content": "<p>Oh I get what you mean about these being incompatible; if we looked at <code>Unit √ó ‚Ñù</code> then pointwise <code>&lt;</code> would end up with <code>(a, b) &lt; (c, d) := False</code> but <code>Unit √ó ‚Ñù</code> has a linearly ordered <code>‚â§</code> and should thus induce a unique <code>&lt;</code>. So either</p>\n<ol>\n<li>we introduce a new typeclass for <code>&lt;</code>, which will have to be more permissive (i.e. allow an empty relation) to apply to products and pi types</li>\n<li>we introduce a new typeclass for <code>&lt;</code>, which will not be permissive but therefore also not apply to products and pi types in general</li>\n<li>we introduce a new typeclass and new notation that will represent a generalized strict <code>&lt;</code></li>\n<li>we don't introduce a new typeclass but something else</li>\n<li>we don't change anything</li>\n</ol>",
        "id": 570452203,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1769563361
    },
    {
        "content": "<p>My view is that we shouldn't change anything here, and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.IsPreorder#doc\">docs#Std.IsPreorder</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsStrictOrder#doc\">docs#IsStrictOrder</a> or the related could be used if necessary. But we do already have another ordering defined on Prod and Pi, via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lex#doc\">docs#Lex</a>, so in particular situations (and downstream applications) a new instance can be put on these types anyway.</p>",
        "id": 570456252,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1769566754
    },
    {
        "content": "<p>In the past there have been discussions about making a new class which would allow for a \"<code>StrongLT</code>\" in different contexts in such a way that it is compatible with, but does not induce, the existing order structure. This would be a strict order, let's denote it <code>‚â™</code>, that has some properties like: <code>a ‚â™ b ‚Üí a &lt; b</code>, <code>a ‚â™ b ‚Üí b ‚â§ c ‚Üí a ‚â™ c</code> and <code>a ‚â§ b ‚Üí b ‚â™ c ‚Üí a ‚â™ c</code>. Potentially there could be further mixins analogous to <code>IsOrderedMonoid</code> which specify the interaction with <code>‚â§</code>, <code>‚â™</code>, <code>&lt;</code> and <code>+</code>.</p>\n<p>Besides pi types, another place this comes up is with strictly positive operators on a Hilbert space and strictly positive elements in a C‚ãÜ-algebra.</p>\n<p>But no, I don't think we should redefine <code>&lt;</code> or decouple it from <code>PartialOrder</code>, although I have considered it in the past.</p>",
        "id": 570459241,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1769568418
    },
    {
        "content": "<p>I think that the \"obvious\" docstring should at least be changed. It is not very useful to see something described as obvious in the docstring of an unfamiliar typeclass that forgets many of the hypotheses of a stronger more common typeclass like partial order or linear order. I would have thought the obvious definition of lt would have been \"le but not equal\".</p>",
        "id": 570461102,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1769569975
    },
    {
        "content": "<p>It is not helpful to my confusion level that the usual reading of <code>‚â§</code> in English is <a href=\"https://unicodelookup.com/#%E2%89%A4/1\">\"less-than or equal to\"</a> but <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Defs/PartialOrder.html#le_iff_lt_or_eq\">le_iff_lt_or_eq</a> is a theorem of PartialOrder that does not hold in general for Preorder</p>",
        "id": 570461334,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1769570181
    },
    {
        "content": "<p>If we are going to keep things as they are, what is the standard advice for someone who wants the <code>lt</code> on their type to be something different than what it is, like in the function type example? Define a new LT instance to use locally? Use some other notation?</p>",
        "id": 570464469,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1769572815
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/570461102\">said</a>:</p>\n<blockquote>\n<p>I think that the \"obvious\" docstring should at least be changed. </p>\n</blockquote>\n<p>I agree. The definition is standard, but certainly not obvious. Preorders are very jarring if you're used to thinking of less-or-equal as either less or equal. (This is really the fault of the naming, to be fair)</p>",
        "id": 570466143,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1769574195
    },
    {
        "content": "<p>I have put a PR here <a href=\"https://github.com/leanprover-community/mathlib4/pull/34512\">#34512</a></p>",
        "id": 570474980,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1769580077
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span>  Thanks for spotting this discussion! I issue they have with the (strict) Loewer is a good example of an existing natural usage where &lt; is not that of Lean's PartialOrder.</p>",
        "id": 570520076,
        "sender_full_name": "Pieter Collins",
        "timestamp": 1769596189
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> :</p>\n<blockquote>\n<p>Hard disagree here. A preorder comes bundled with both a ‚â§ and a &lt; relation, and they're always related via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=lt_iff_le_not_ge#doc\">docs#lt_iff_le_not_ge</a>. If that's not what you have, then you don't have a preorder.</p>\n</blockquote>\n<p>That's the current <em>Lean Mathlib</em> definition of a preorder. But this is particular to Lean; other sources (e.g. Wikipedia, Wolfram Mathworld) don't bundle ‚â§ with &lt;. Even Std.IsPreorder  doesn't require LT.</p>",
        "id": 570521512,
        "sender_full_name": "Pieter Collins",
        "timestamp": 1769596602
    },
    {
        "content": "<p>Here's the basic idea for refactoring I had in mind. This means one can use ‚â§ and &lt; separately, combine them with weaker restrictions (essentially a &lt; b ‚Üí a ‚â§ b and mixed-transitivity) or use the synthesised version of &lt;. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">WeakPreorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le_refl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">StrictPreorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">lt_irrefl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">lt_trans</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">WeakStrictPreorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">WeakPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">StrictPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_le_of_lt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_lt_of_le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">WeakStrictPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">lt_iff_le_not_ge</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">lt_irrefl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">lt_trans</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_le_of_lt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_lt_of_le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">WeakPartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">WeakPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le_antisymm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">StrictPartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">StrictPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">lt_asymm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"bp\">¬¨</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">WeakStrictPartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">WeakPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">StrictPreorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">WeakStrictPartialOrder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>",
        "id": 570523102,
        "sender_full_name": "Pieter Collins",
        "timestamp": 1769597072
    },
    {
        "content": "<p>Note that <code>lt_asymm</code> is a theorem following from irreflexivity and transitivity...</p>",
        "id": 570523847,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769597283
    },
    {
        "content": "<p>So it should already hold for <code>StrictPreorder</code></p>",
        "id": 570524055,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769597336
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> <br>\nI didn't put <code>lt_asymm</code> in <code>StrictPreorder</code> for consistency with <code>WeakPreorder</code>. Of course, it could go in <code>StrictPreorder</code>. One could even omit one of the <code>StrictPreorder</code> or <code>StrictPartialOrder</code> typeclasses.</p>",
        "id": 570524711,
        "sender_full_name": "Pieter Collins",
        "timestamp": 1769597497
    },
    {
        "content": "<p>Having two definitions for the same thing sounds like unnecessary code duplication.</p>",
        "id": 570526663,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769598062
    },
    {
        "content": "<p>Not to mention the fact that this very well may invite instance diamonds. Indeed, i am more in favor of Jireh's proposal.</p>",
        "id": 570527217,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769598224
    },
    {
        "content": "<p>We could try and use scoped notation more. We could have both proposals and the user can choose by opening some one or other namespace.</p>",
        "id": 570527957,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769598447
    },
    {
        "content": "<p>Now <em>that</em> sounds like unnecessary code duplication</p>",
        "id": 570528120,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769598500
    },
    {
        "content": "<p>How would scoped notation lead to code duplication?</p>",
        "id": 570528275,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769598552
    },
    {
        "content": "<p>The \"having both proposals\" part</p>",
        "id": 570528575,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769598650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/570456252\">said</a>:</p>\n<blockquote>\n<p>My view is that we shouldn't change anything here, and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.IsPreorder#doc\">docs#Std.IsPreorder</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsStrictOrder#doc\">docs#IsStrictOrder</a> or the related could be used if necessary.</p>\n</blockquote>\n<p>Ah, I didn't spot <code>Std.IsPreorder</code> and <code>Mathlib.Order.Defs.Unbundled.IsStrictOrder</code> earlier. </p>\n<p>But why then does Mathlib's <code>Preorder</code>have &lt; when <code>Std.IsPreorder</code>does not? And why aren't these typeclasses extended by Mathlib's <code>Preorder</code>? </p>\n<p>This gives me the impression that (i) the conceptualisation has not been clearly thought through, and (ii) typeclasses have been added piecemeal without being properly integrated (maybe to avoid refactorisation). </p>\n<p>For a new user, which should one use for just ‚â§, <code>Std.IsPartialOrder</code> or Mathlib's <code>PartialOrder</code>?  Are there results available for one but not the other? Why is (to give an example I am working with) is <code>Dyadic</code> an instance of both <code>Std.IsPartialOrder</code> and <code>PartialOrder</code>but <code>Rat</code> only of <code>PartialOrder</code>?</p>",
        "id": 570528676,
        "sender_full_name": "Pieter Collins",
        "timestamp": 1769598690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/570528575\">said</a>:</p>\n<blockquote>\n<p>The \"having both proposals\" part</p>\n</blockquote>\n<p>But from the implementation perspective both proposals are the same I think? They only differ in what is the notation.</p>",
        "id": 570528757,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769598721
    },
    {
        "content": "<p>I dont believe we want both of <code>StrictPreorder</code> and <code>LawfulStrongLT</code></p>",
        "id": 570529173,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769598849
    },
    {
        "content": "<p>Hm, maybe not the same. But I meant to implement one implementation, and then have namespace A in which <code>a &lt; b</code> is notation for <code>a ‚â§ b ‚àß ¬¨ b ‚â§ a</code>, and <code>a ‚â™ b</code> is notation for <code>LT</code> or <code>StrongLT</code> (that depends on the implemntation). And in another namespace B <code>a &lt; b</code> would be the notation for <code>LT</code>/<code>StrongLT</code>. And either we don't have notation for <code>a ‚â§ b ‚àß ¬¨ b ‚â§ a</code> in namespace B, or we could come up with some yet another notation.</p>",
        "id": 570529626,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769598994
    },
    {
        "content": "<p>this sounds like it will be really unnecessarily confusing</p>",
        "id": 570529783,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769599043
    },
    {
        "content": "<p>In mathlib we would always stick to one.</p>",
        "id": 570529851,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769599062
    },
    {
        "content": "<p>But it lets the user choose a different notation.</p>",
        "id": 570529936,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769599088
    },
    {
        "content": "<p>The user can always choose a different notation, just not <code>&lt;</code></p>",
        "id": 570530341,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769599177
    },
    {
        "content": "<p>It's already present in math papers that notation can mean something different, depending on the field. So it's the question of whether we want a consistent notation across all math, or whether scoped notation is necessary evil.</p>",
        "id": 570530516,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769599222
    },
    {
        "content": "<p>I can see the appeal of having consistent notation across all math. The problem that could lead to is that you would have to remember 30 different symbols and how to read and type them. It might be easier after all to just have the same notation mean something different depending on the namespace. I'm not sure if that would be confusing. The mathlib would still standardize the notation, so you just would just have to learn what notation is used for the field you're plan to work in. Even if you work in multiple fields, you should at every time be aware of what are you're working on at the given moment and which notation is in place in the file you're working in.</p>",
        "id": 570533714,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769600307
    },
    {
        "content": "<p>I can share a story from my lectures. The professor wrote a theorem on a board, and I spotted, that the theorem is wrong. So I raised a question, and it turned out, that the notation <code>v &lt; u</code> (<code>v</code>, <code>u</code> were vectors) that the professor wrote, didn't mean <code>v ‚â§ u ‚àßv ‚â† u</code> as I wrongly assumed, but pointwise <code>&lt;</code>.<br>\nIf the professor used some other symbol, that I still would have to ask the question, because I wouldn't know what the symbol meant. I guess it might be less confusing that way, though not really by much. I quickly spotted that something was wrong, asked a question, and my confusion was resolved. We used this notation a lot and it wasn't confusing anymore after I learned what it meant. And in the end, <code>&lt;</code> was easier to write than some other symbol like <code>‚â™</code>.<br>\nI also had another lectures, about partial orders, and on these lectures <code>a &lt; b</code> meant just <code>a ‚â§ b ‚àß ¬¨ b ‚â§ a</code> . Even though we used the same notation on these two different lectures I was never confused by it. I was always aware of the context and knew what the notation meant.</p>",
        "id": 570535842,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769600984
    },
    {
        "content": "<p>sorry, I lost track of what you're proposing should be done</p>",
        "id": 570536760,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769601268
    },
    {
        "content": "<p>are you still proposing to override the core notation for <code>LT.lt</code>?</p>",
        "id": 570536826,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769601288
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1015002\">Pieter Collins</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/570528676\">said</a>:</p>\n<blockquote>\n<p>But why then does Mathlib's <code>Preorder</code>have &lt; when <code>Std.IsPreorder</code>does not? And why aren't these typeclasses extended by Mathlib's <code>Preorder</code>?</p>\n</blockquote>\n<p>Order typeclasses in Std are still relatively new and some of the justification for their design can be found in <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/Request.20for.20feedback.3A.20new.20order.20typeclasses.20in.20std.20library/near/537826289\">#general &gt; Request for feedback: new order typeclasses in std library @ üí¨</a> I'm not sure about why Preorder has an Std.IsPreorder instance versus being extended. Some of the other classes that map onto mathlib better have been/are being adopted in mathlib already e.g. see <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Relation.20properties.20duplication/with/569830180\">#mathlib4 &gt; Relation properties duplication</a></p>",
        "id": 570537278,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1769601421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1015002\">Pieter Collins</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/570528676\">said</a>:</p>\n<blockquote>\n<p>For a new user, which should one use for just ‚â§, <code>Std.IsPartialOrder</code> or Mathlib's <code>PartialOrder</code>?  Are there results available for one but not the other? Why is (to give an example I am working with) is <code>Dyadic</code> an instance of both <code>Std.IsPartialOrder</code> and <code>PartialOrder</code>but <code>Rat</code> only of <code>PartialOrder</code>?</p>\n</blockquote>\n<p>Well <code>PartialOrder</code> is not supported for just <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>‚â§</mo></mrow><annotation encoding=\"application/x-tex\">\\le</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">‚â§</span></span></span></span> so that seems to be out of the question. The Std classes will surely have less API than the mathlib ones given that the mathlib ones provide instances for Std and are older and have more API, but maybe you can comment more about what specifically you'd like to do to get more relevant feedback. I can <code>#synth Std.IsPartialOrder Rat</code> so I assume you mean the question the other way around: Why is there no <code>PartialOrder</code> for Dyadic: probably it just hasn't been done yet but would be welcome as mentioned in the other thread where you asked about Dyadic.</p>",
        "id": 570539088,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1769601924
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/570536826\">said</a>:</p>\n<blockquote>\n<p>are you still proposing to override the core notation for <code>LT.lt</code>?</p>\n</blockquote>\n<p>I wasn't proposing any particular implementation though, but argumenting that scoped notation might not be confusing. Implementation wise we don't necessarily have to change anything in core, but we would need a feature that let's you overwrite a notation from core inside a namespace, which I think is not currently possible.</p>",
        "id": 570539144,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769601943
    },
    {
        "content": "<p>i think in a lecture series, it's definitely possible to have notation conflict with lectures on other topics. However, not in mathlib. I think this will cause a headache when learning/teaching mathlib. In particular, the docs will not show you what instance of <code>LT</code> is meant by <code>&lt;</code>, so this can lead to confusing situations similar to when one writes <code>[Ring Real]</code> to then try to apply <code>sq_nonneg</code>, except that in the <code>&lt;</code> situation, the fact that it won't work is <em>intended</em></p>",
        "id": 570547261,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769604492
    },
    {
        "content": "<p>which feels maniacal/evil to me. (i understand it isn't and comes from a logical train of thought, but it still feels that way)</p>",
        "id": 570547570,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769604574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1015002\">Pieter Collins</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/570521512\">said</a>:</p>\n<blockquote>\n<p>That's the current <em>Lean Mathlib</em> definition of a preorder. But this is particular to Lean; other sources (e.g. Wikipedia, Wolfram Mathworld) don't bundle ‚â§ with &lt;. Even Std.IsPreorder  doesn't require LT.</p>\n</blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Preorder#Strict_partial_order_induced_by_a_preorder\">Wikipedia</a>: Any preorder <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>‚â≤</mo></mrow><annotation encoding=\"application/x-tex\">\\lesssim</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9592em;vertical-align:-0.2296em;\"></span><span class=\"mrel amsrm\">‚â≤</span></span></span></span> gives rise to a strict partial order defined by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a &lt; b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> if and only if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>‚â≤</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a \\lesssim b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9592em;vertical-align:-0.2296em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">‚â≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> and not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo>‚â≤</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">b \\lesssim a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9592em;vertical-align:-0.2296em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">‚â≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span>.</p>",
        "id": 570673743,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1769640144
    },
    {
        "content": "<p>It's also worth noting that it's exactly this definition of <code>&lt;</code> which guarantees the relation can be lifted to the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Antisymmetrization#doc\">docs#Antisymmetrization</a> of the preorder.</p>",
        "id": 570674081,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1769640294
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/570417378\">said</a>:</p>\n<blockquote>\n<p>What exactly is the application you have in mind?</p>\n</blockquote>\n<p>Might I ask this again? This entire thread feels like a huge <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>. We're trying to come up for a design for a \"stronger &lt; relation\" without even knowing what we want it for.</p>",
        "id": 570674548,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1769640544
    },
    {
        "content": "<p>Do you want the pointwise &lt; relation on functions? We have that already. Do you want some kind of matrix ordering? There's existing API for that. Is this just a hypothetical? Then no action is needed.</p>",
        "id": 570674674,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1769640606
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/570673743\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Preorder#Strict_partial_order_induced_by_a_preorder\">Wikipedia</a>: Any preorder <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>‚â≤</mo></mrow><annotation encoding=\"application/x-tex\">\\lesssim</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9592em;vertical-align:-0.2296em;\"></span><span class=\"mrel amsrm\">‚â≤</span></span></span></span> gives rise to a strict partial order defined by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a &lt; b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> if and only if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>‚â≤</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a \\lesssim b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9592em;vertical-align:-0.2296em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">‚â≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> and not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo>‚â≤</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">b \\lesssim a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9592em;vertical-align:-0.2296em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">‚â≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span>.</p>\n</blockquote>\n<p>Indeed it's a general definition of <em>a</em> particular preorder. But there are others, and this is not always the one that's wanted.</p>",
        "id": 570986816,
        "sender_full_name": "Pieter Collins",
        "timestamp": 1769767666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/570417378\">said</a>:</p>\n<blockquote>\n<p>What exactly is the application you have in mind?</p>\n</blockquote>\n<p>The main application I have in mind is developing constructive analysis and rigorous numerical methods. Here, the natural relation between &lt; and ‚â§ is that &lt; should be verifiable (topologically: true on an open set of pairs), and ‚â§ falsifiable (true on a closed set). The synthesised &lt; doesn't satisfy this in general (though it does for a total order). I would like the (topo)logically-natural orders on R^n and C(X-&gt;R), but also on spaces of subsets ordered by inclusion.</p>\n<p>But I think the issue is bigger than my particular application. (Otherwise I probably wouldn't have posted on this channel.) The examples we've seen above are all related to topology; &lt; should be robustly true, so hold on an open set. For discrete mathematics it may well be a non-issue, but for continuous mathematics the current definition is unnatural.</p>",
        "id": 570986869,
        "sender_full_name": "Pieter Collins",
        "timestamp": 1769767682
    },
    {
        "content": "<p>Things get problematic once we combine Lean partial orders with the order topology.<br>\n Given the (total) partial order on R, we can define the product order on R^2 given by (x1,y1) ‚â§ (x2,y2) ‚Üî x1 ‚â§ x2 ‚àß y1 ‚â§ y2. (I can't find this definition in Lean/Mathlib, but it's standard and hopefully uncontroversial). We then define the order topology on R^2 <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Order/Basic.html#OrderTopology\">docs#OrderTopology</a> which uses the synthesised &lt; to generate basic opens { (x,y) | (a,b) &lt; (x,y) &lt; (c,d) }. By taking intersections, we see that sets { (x,y) : a&lt;x&lt;c ‚àß y=b } and { (x,y) : x=a  ‚àß b&lt;y&lt;d } are open. Intersecting sets of this form shows that all singletons { (a,b) } are open, so we have the discrete topology! This is <em>not</em> what we want!!<br>\nDefining  (x1,y1) &lt; (x2,y2) ‚Üî x1 &lt; x2 ‚àß y1 &lt; y2, which is the natural product strict partial order, gives the Euclidean topology as the order topology.</p>",
        "id": 570991564,
        "sender_full_name": "Pieter Collins",
        "timestamp": 1769769011
    },
    {
        "content": "<p>I think synthesising &lt; is a genuinely <em>bad</em> design (and I don't say that lightly), and unnecessarily so.</p>\n<ul>\n<li>\n<p>I think orthogonality is a good design principle. It seems to be present in the arithmetic classes (e.g. <code>Neg</code>, <code>Add</code> and <code>Sub</code> are separate, and only in <code>SubNegMonoid</code> do we have <code>sub_eq_add_neg : ‚àÄ a b, a - b = a + -b</code>.) So why not here? Moreover, I think <code>a - b = a + -b</code> is probably closer to being universal than <code>lt_iff_le_not_ge (a b : Œ±) : a &lt; b ‚Üî a ‚â§ b ‚àß ¬¨b ‚â§ a</code>. </p>\n</li>\n<li>\n<p>The definition of PartialOrder doesn't correspond to (what I believe is by far) the most common definition which only mentions ‚â§.</p>\n</li>\n<li>The choice is general, but is not canonical there are other reasonable choices (notably in continuous mathematics).</li>\n<li>\n<p>Providing a convenience to some users shouldn't also be an inconvenience to others.</p>\n</li>\n<li>\n<p>It's unnecessary, since one can easily refactor to keep a typeclass (even called PartialOrder) with this particular relationship between ‚â§ and &lt;, and also have typeclasses with weaker reasonable definitions of compatibilty, and with only one of the two.</p>\n</li>\n<li>\n<p>I think an important goal in formalising mathematics is to keep assumptions to a minimum. This means that abstractions should be graded so that one can use precisely the conditions needed for the result. This increases generality, and clearly shows what assumptions are needed. The algebra classes in Lean seem to follow this design.</p>\n<ul>\n<li>For a result which only needs ‚â§, we shouldn't have to have a &lt;. For a result which needs weaker conditions on &lt;, we shouldn't restrict to cases assuming the stronger condition.</li>\n<li>Suppose we have an alternative &lt; (let's call it ‚ãñ) which is a strict partial order satisfying some compatibilty conditions with ‚â§. Maybe these are already sufficient to apply the particular Big Theorem we am interested in using. But if the Big Theorem assumes PartialOrder because there's nothing weaker in the library, then presumably we have to redo the proof of Big Theorem to use it. </li>\n</ul>\n</li>\n</ul>\n<p>Now I'm sure that one can work around many issues, like using different operator symbols. But then the user/reader still has to realise that '&lt;' is wrong, and doesn't mean what it does in the domain literature, which could lead to errors. I also don't see a workaround for the Big Theorem issue.</p>\n<p>Since this is a fundamental concept, it is probably widely used and one of the first things many new users will work with. So it's important to get things right! I realise it's also harder to change, and changes should definitely be well-considered. Here, I think the library could be majorly improved by refactoring PartialOrder, which hopefully is a non-breaking change for the rest of Mathlib.</p>",
        "id": 570996679,
        "sender_full_name": "Pieter Collins",
        "timestamp": 1769770520
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"1015002\">@Pieter Collins</span> Interesting thoughts! Can I ask: what do you think &lt; and &lt;= should mean?</p>",
        "id": 571008363,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769774191
    },
    {
        "content": "<p>The order topology is not meant for partial orders or preorders. In fact I believe there is a pending refactor to use <code>LinearOrder</code> as an assumption throughout.</p>",
        "id": 571009088,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1769774416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1015002\">Pieter Collins</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/570521512\">said</a>:</p>\n<blockquote>\n<p>That's the current <em>Lean Mathlib</em> definition of a preorder. But this is particular to Lean; other sources (e.g. Wikipedia, Wolfram Mathworld) don't bundle ‚â§ with &lt;.</p>\n</blockquote>\n<p>I don't believe this is fair, Violeta has given one wikipedia link which contradicts your claim, and <a href=\"https://en.wikipedia.org/wiki/Order_theory#Constructing_new_orders\">here is another</a>. Page 2 of Davey &amp; Priestley Introduction to Lattices and¬†Order also has this definition, as does Page 4 of Roman's Lattices and Ordered Sets. Birkhoff's Lattice theory also does this bundling (though in partial orders, using the equivalent version which is valid there). Do you have references which don't do this?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"1015002\">Pieter Collins</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/570996679\">said</a>:</p>\n<blockquote>\n<ul>\n<li>It seems to be present in the arithmetic classes (e.g. <code>Neg</code>, <code>Add</code> and <code>Sub</code> are separate, and only in <code>SubNegMonoid</code> do we have <code>sub_eq_add_neg : ‚àÄ a b, a - b = a + -b</code>.) So why not here?</li>\n</ul>\n</blockquote>\n<p>This is exactly the pattern taken in mathlib for Preorder and PartialOrder, we have the classes <code>LE</code> and <code>LT</code> corresponding to <code>Neg</code>, <code>Add</code> and <code>Sub</code>, and they are only combined in <code>Preorder</code>. The pattern is exactly the same: we have notational typeclasses with no axioms, and structural typeclasses combining them with axioms. As such, I think it's unfair to call this bad design.</p>\n<p>On the product order, I think this discussion <a href=\"https://mathoverflow.net/a/296355/117945\">https://mathoverflow.net/a/296355/117945</a> is particularly relevant.</p>",
        "id": 571009355,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1769774486
    },
    {
        "content": "<p>Let me address some of your other points.</p>\n<p>Orthogonality: we already have that! If you want ‚â§ and &lt; as bare notation, the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LE#doc\">docs#LE</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LT#doc\">docs#LT</a> typeclasses exist. And then <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Preorder#doc\">docs#Preorder</a> is the weakest typeclass combining both in a reasonable way. It's not any different from the algebraic examples you give.</p>\n<p>Textbook definition: Orders are usually defined from just a ‚â§ relation, yes, but you'd be hard-pressed to find anyone who doesn't also implicitly define a &lt; relation as well. In the partial order case, the obvious way to do this is via a ‚â§ b and a ‚â† b. In the preorder case, the most reasonable generalization is precisely a ‚â§ b and not b ‚â§ a, for the reason that it will not distinguish between order-indistinguishable elements the way that the partial order definition would. </p>\n<p>Other possible choices: the symbol &lt; can mean any number of things, yes. What I'm arguing is that the path of least resistance is to just define a new symbol for what you want to do, and prove whatever API is appropriate to it.</p>\n<p>Easy refactoring: I'd like to emphasize that typeclasses aren't cheap. With every new typeclass comes a large amount of boilerplate, plus API and theorems that now have to be generalized to use it. Mathlib has more than a million lines of code. Any large change in something as basic as the order library would take dozens of hours of refactoring effort. It's not easy as you seem to be suggesting.</p>\n<p>Minimum assumptions: carrying around &lt; does not decrease generality anymore than carrying subtraction and negation separately in a group. If you only want to talk about ‚â§ in a preorder, you can let &lt; be defined automatically and just never mention it.</p>",
        "id": 571012190,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1769775374
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Partially_ordered_set\">https://en.wikipedia.org/wiki/Partially_ordered_set</a></p>\n<p>There is a discussion on this page about the fact that every strict partial order gives rise to a weak partial order and vice versa - I think this precisely corresponds to the fact that &lt; and &lt;= correspond.</p>\n<p>Is the same true with preorders? I know Mathlib defines some of this stuff but I am not sure if all of its definitions are the same as other sources etc.</p>",
        "id": 571015792,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769776363
    },
    {
        "content": "<p>To me, at the very least for PartialOrder, you need &lt;= and &lt; to be compatible because the typeclass represents both orders at once.</p>",
        "id": 571015936,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769776403
    },
    {
        "content": "<p>I do think it would be good to use the Std classes where possible.</p>",
        "id": 571016020,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769776432
    },
    {
        "content": "<p>Hmm: this paragraph from <a href=\"https://en.wikipedia.org/wiki/Weak_ordering\">https://en.wikipedia.org/wiki/Weak_ordering</a> suggests that in fact they are not equivalent.<br>\n<a href=\"/user_uploads/3121/ceYD2oAXt48MhzOxHmek_pGn/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/ceYD2oAXt48MhzOxHmek_pGn/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"975x536\" src=\"/user_uploads/thumbnail/3121/ceYD2oAXt48MhzOxHmek_pGn/image.png/840x560.webp\"></a></div>",
        "id": 571016377,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769776558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/571015792\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Partially_ordered_set\">https://en.wikipedia.org/wiki/Partially_ordered_set</a></p>\n<p>There is a discussion on this page about the fact that every strict partial order gives rise to a weak partial order and vice versa - I think this precisely corresponds to the fact that &lt; and &lt;= correspond.</p>\n<p>Is the same true with preorders? I know Mathlib defines some of this stuff but I am not sure if all of its definitions are the same as other sources etc.</p>\n</blockquote>\n<p>For preorders, &lt; doesn't uniquely determine &lt;= (see eg <a href=\"https://mathoverflow.net/a/286674/117945\">https://mathoverflow.net/a/286674/117945</a>), but &lt;= is used to define &lt; in the order theory textbooks I could think of to check</p>",
        "id": 571016398,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1769776564
    },
    {
        "content": "<p>That page somewhat implies that you <em>could</em> define x &lt; y as \"y is not &lt;= x\".</p>",
        "id": 571016512,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769776600
    },
    {
        "content": "<p>Which is equivalent to the above I think only on linear orders?</p>",
        "id": 571016542,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769776611
    },
    {
        "content": "<p>I think on reflection I am of the view, therefore, that Preorder defining the equivalence between &lt; and &lt;= that it does might be a mistake, but that <em>certainly</em> I would want <code>le_iff_lt_or_eq</code> for Partial Orders.</p>",
        "id": 571016918,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769776725
    },
    {
        "content": "<p>(Preorder should therefore perhaps only be an extension of LE, or possibly dependent on [LE _],  the approach <code>Std.IsPreorder</code> takes.)</p>",
        "id": 571017095,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769776780
    },
    {
        "content": "<p>Essentially currrently we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instLawfulOrderLT_mathlib#doc\">docs#instLawfulOrderLT_mathlib</a> dependent on Preorder. Would it be so bad if it was dependent on Partial Order? I am not sure.</p>",
        "id": 571017289,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769776839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/571016512\">said</a>:</p>\n<blockquote>\n<p>That page somewhat implies that you <em>could</em> define x &lt; y as \"y is not &lt;= x\".</p>\n</blockquote>\n<p>You can do this, but it doesn't work very well, for example \"y is not &lt;= x\" is not in general a transitive relation</p>",
        "id": 571017582,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769776930
    },
    {
        "content": "<p>Well that's fine. I mean it doesn't seem very useful but that I would expect.</p>",
        "id": 571017734,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769776967
    },
    {
        "content": "<p>If I am reading <a href=\"https://en.wikipedia.org/wiki/Preorder#Strict_partial_order_induced_by_a_preorder\">https://en.wikipedia.org/wiki/Preorder#Strict_partial_order_induced_by_a_preorder</a> and your posts correctly, which Violeta linked above, every preorder &lt;= gives rise to a &lt; which is \"lawful\", but that you could have some non-lawful &lt; which would still give rise to &lt;= if it was defined from it.</p>",
        "id": 571018078,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777063
    },
    {
        "content": "<p><del>correct</del> no that doesn't seem right</p>",
        "id": 571018154,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769777082
    },
    {
        "content": "<p>&lt; only gives rise to &lt;= if you additionally specify an equivalence relation compatible with &lt; (the \"inseparable wrt &lt;=\" relation)</p>",
        "id": 571018409,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769777147
    },
    {
        "content": "<p>Right, sorry, I see.</p>",
        "id": 571018475,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777162
    },
    {
        "content": "<p>yes because a &lt;= b iff a &lt; b or a ~ b, which I see is actually equivalent to:<br>\na &lt;=b iff a &lt; b or (a &lt;=b and b &lt;= a).</p>",
        "id": 571018632,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777201
    },
    {
        "content": "<p>Something something LEM</p>",
        "id": 571018816,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769777247
    },
    {
        "content": "<p>(which is clearly simpler when &lt;= is a partial order.)</p>",
        "id": 571018828,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777251
    },
    {
        "content": "<p>if you specify = as the equivalence relation you always get a partial order, this is what <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=partialOrderOfSO#doc\">docs#partialOrderOfSO</a> does</p>",
        "id": 571018847,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769777254
    },
    {
        "content": "<p>Right because then you are essentially saying no loops in your order graph.</p>",
        "id": 571018942,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777278
    },
    {
        "content": "<p>something something univalence ;)</p>",
        "id": 571019004,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777292
    },
    {
        "content": "<p>I don't think the full refactor proposed above is at all the right one, but I do see the argument that mayvbe </p>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/571018632\">said</a>:</p>\n<blockquote>\n<p>yes because a &lt;= b iff a &lt; b or a ~ b, which I see is actually equivalent to:<br>\na &lt;=b iff a &lt; b or (a &lt;=b and b &lt;= a).</p>\n</blockquote>\n<p>Is <code>a &lt;=b iff a &lt; b or (a &lt;=b and b &lt;= a)</code> equivalent to <code>a &lt; b iff a &lt;= b and ¬¨b &lt;= a</code>?</p>",
        "id": 571019557,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777439
    },
    {
        "content": "<p>what conditions are you assuming on &lt;</p>",
        "id": 571019766,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769777504
    },
    {
        "content": "<p>&lt; could be equal to &lt;=</p>",
        "id": 571019815,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769777519
    },
    {
        "content": "<p>none other than what is there I guess? Or maybe that it's a strict preorder I suppose.</p>",
        "id": 571019877,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777531
    },
    {
        "content": "<p>Yes one would want that.</p>",
        "id": 571019921,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777542
    },
    {
        "content": "<p>if it's just a strict preorder then &lt; could have some fine structure inside the equivalence classes of &lt;=</p>",
        "id": 571020030,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769777568
    },
    {
        "content": "<p>Hm. Which is ruled out by <code>a &lt; b iff a &lt;= b and ¬¨b &lt;= a</code>?</p>",
        "id": 571020158,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777598
    },
    {
        "content": "<p>yeah</p>",
        "id": 571020199,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769777608
    },
    {
        "content": "<p>Hmm.</p>",
        "id": 571020214,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777612
    },
    {
        "content": "<p>Then yeah it does somewhat feel like the current definition of Preorder precludes such structure?</p>",
        "id": 571020272,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777628
    },
    {
        "content": "<p>I really don't see why you would want it</p>",
        "id": 571020410,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769777663
    },
    {
        "content": "<p>It feels very delicate and quite niche though.</p>",
        "id": 571020425,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/571020410\">said</a>:</p>\n<blockquote>\n<p>I really don't see why you would want it</p>\n</blockquote>\n<p>Neither do I - I think I am just obsessive about never eliminating possible structures unnecessarily.</p>",
        "id": 571020504,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777691
    },
    {
        "content": "<p>Std has <code>LawfulOrderLT.of_lt</code> which basically says that the &lt;= induced by \"not &lt;\" is a lawful one.</p>",
        "id": 571021106,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777847
    },
    {
        "content": "<p>I think my general opinion is more that I would support using the Std classes if at all possible, but that it is also good to make sure that the setup we use doesn't rule them out.</p>",
        "id": 571021370,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769777911
    },
    {
        "content": "<p>Don't forget we also have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Defs/Unbundled.html#IsStrictOrder\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Defs/Unbundled.html#IsStrictOrder</a> and related, to express these concepts</p>",
        "id": 571023560,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1769778500
    },
    {
        "content": "<p>Yes - I think there is an effort to remove them and replace them with the Std ones maybe? At least a subset.</p>",
        "id": 571039678,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769782417
    },
    {
        "content": "<p>I don't know that these ones in particular have Std analogues?</p>",
        "id": 571045607,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1769783817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/571012190\">said</a>:</p>\n<blockquote>\n<p>Easy refactoring: I'd like to emphasize that typeclasses aren't cheap. With every new typeclass comes a large amount of boilerplate, plus API and theorems that now have to be generalized to use it. Mathlib has more than a million lines of code. Any large change in something as basic as the order library would take dozens of hours of refactoring effort. It's not easy as you seem to be suggesting.</p>\n</blockquote>\n<p>Without saying anything about this particular change, I do want to push back against reflexively saying \"this refactor is too hard, Mathlib is too big\". I think over the years we have actively embraced refactors that go right to  the roots of Mathlib/Lean, and this has been good, and we should always remain open to doing these refactors when they are motivated!</p>",
        "id": 571063972,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1769788164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/571063972\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/571012190\">said</a>:</p>\n<blockquote>\n<p>Easy refactoring: I'd like to emphasize that typeclasses aren't cheap. With every new typeclass comes a large amount of boilerplate, plus API and theorems that now have to be generalized to use it. Mathlib has more than a million lines of code. Any large change in something as basic as the order library would take dozens of hours of refactoring effort. It's not easy as you seem to be suggesting.</p>\n</blockquote>\n<p>Without saying anything about this particular change, I do want to push back against reflexively saying \"this refactor is too hard, Mathlib is too big\". I think over the years we have actively embraced refactors that go right to  the roots of Mathlib/Lean, and this has been good, and we should always remain open to doing these refactors when they are motivated!</p>\n</blockquote>\n<p>Strongly agree with this. I think it's vital for Mathlib that over time it does not ossify and become conservative in what it is willing to change.</p>",
        "id": 571066429,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1769788790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/571039678\">said</a>:</p>\n<blockquote>\n<p>Yes - I think there is an effort to remove them and replace them with the Std ones maybe? At least a subset.</p>\n</blockquote>\n<p>Yes but Kim <a href=\"#narrow/channel/287929-mathlib4/topic/Relation.20properties.20duplication/near/544659241\">suggested</a> to leave the order classes alone for now</p>",
        "id": 571117877,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1769804785
    },
    {
        "content": "<p>Violeta Hern√°ndez said:</p>\n<blockquote>\n<p>And then <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Preorder#doc\">docs#Preorder</a> is the weakest typeclass combining both in a reasonable way.</p>\n</blockquote>\n<p>No! Precisely my main point is that there are weaker and reasonable relationships between &lt; and ‚â§. In particular,  the combination  </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>requiring that &lt; is not too big, and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">lt_of_le_of_lt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"n\">lt_of_lt_of_le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span>\n</code></pre></div>\n<p>requiring that &lt; is not too small, is reasonable. We've seen concrete examples of product orders and the Loewner order where these are used.</p>",
        "id": 571642734,
        "sender_full_name": "Pieter Collins",
        "timestamp": 1770120316
    },
    {
        "content": "<p>Note that earlier in the thread we already have a counterexample explaining why this is not reasonable: <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/570448736\">#mathlib4 &gt; Preorder / PartialOrder synthesised &lt; @ üí¨</a></p>",
        "id": 571643049,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1770120419
    },
    {
        "content": "<p>Note that in a topological space, taking <code>a&lt;b ‚Üî (a,b) ‚àà interior { (x,y) | x ‚â§ y }</code> satisfies <code>lt_of_le_of_lt</code> and <code>lt_of_lt_of_le</code>.</p>",
        "id": 571646931,
        "sender_full_name": "Pieter Collins",
        "timestamp": 1770121597
    },
    {
        "content": "<p>I'm not sure which topology you're using here, since:<br>\n<span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hern√°ndez</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/571009088\">said</a>:</p>\n<blockquote>\n<p>The order topology is not meant for partial orders or preorders. In fact I believe there is a pending refactor to use <code>LinearOrder</code> as an assumption throughout.</p>\n</blockquote>",
        "id": 571649664,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1770122406
    },
    {
        "content": "<p>Regarding the example <code>lt a b := False</code> being compatible with any <code>le</code> preorder: <br>\nI don't mean to imply that the relations <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Preorder.20.2F.20PartialOrder.20synthesised.20.3C/near/571642734\">#mathlib4 &gt; Preorder / PartialOrder synthesised &lt; @ üí¨</a>  define what is meant for <code>le</code> and <code>lt</code> to be compatible. However, they do form weaker conditions which are satisfied by some pairs of relations which do not satisfy <code>lt_iff_le_not_ge</code> but are still natural to consider together. The transitivity conditions are precisely what is needed to chain &lt; and ‚â§, which seems like a useful yet fairly minimal requirement which is definable purely and easily in terms of the order relations.</p>",
        "id": 571651306,
        "sender_full_name": "Pieter Collins",
        "timestamp": 1770122868
    }
]