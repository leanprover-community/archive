[
    {
        "content": "<p>I was expecting <code>positivity</code> to be able to directly establish</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">):</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">j</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">sum_nonneg</span>\n  <span class=\"n\">intro</span> <span class=\"n\">j</span> <span class=\"n\">_</span>\n  <span class=\"n\">positivity</span>\n</code></pre></div>\n<p>without needing to explicitly invoke <code>sum_nonneg</code>.  Would it be feasible to extend <code>positivity</code> to be able to handle this sort of expression?  It's not a huge pain to add these extra two lines of code, but it would be a minor convenience not to have to do so.  (Recently I had a whole stack of positivity conditions to verify and wanted to finish them all off with <code>all_goals { positivity }</code>, but this issue presented a speed bump in doing so.)</p>",
        "id": 397966701,
        "sender_full_name": "Terence Tao",
        "timestamp": 1698002688
    },
    {
        "content": "<p>I've tried exactly this in Lean 3 and failed! I am still hoping to crank up my metaprogramming fu and get <code>positivity</code> to work, but that hasn't happened yet.</p>",
        "id": 397968259,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698004327
    },
    {
        "content": "<p>If you look through <a href=\"https://github.com/YaelDillies/LeanAPAP\">LeanAPAP</a>, you will see that I make heavy use of <code>positivity</code> and that a bunch of calls could be shortened with a few extra <code>positivity</code> extensions.</p>",
        "id": 397968331,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698004402
    },
    {
        "content": "<p>The reason this is harder to write than other extensions is because you need to introduce extra variables to the context, call <code>positivity</code> there, then zoom back.</p>",
        "id": 397968510,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698004590
    },
    {
        "content": "<p>This was also <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291755417\">proposed</a> by <span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> soon after the tactic first appeared -- Moritz, did you ever try it?  I still think it's a good idea ...</p>",
        "id": 397979367,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1698017434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Could.20positivity.20handle.20sums.20of.20squares.3F/near/397979367\">said</a>:</p>\n<blockquote>\n<p>This was also <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/291755417\">proposed</a> by <span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> soon after the tactic first appeared -- Moritz, did you ever try it?  I still think it's a good idea ...</p>\n</blockquote>\n<p>No, I did not. I don't have much time to spend on mathlib at the moment. I agree that it should be possible (and probably not too hard, the telescoping function should take care of introducing the variables just fine) - if nobody does it this week I might be motivated next weekend to look into this</p>",
        "id": 397990558,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1698025548
    },
    {
        "content": "<p>Here is a basic version of this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Positivity.Core</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Order</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Qq</span>\n<span class=\"kn\">open</span> <span class=\"n\">Mathlib.Meta.Positivity</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">positivity</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">evalSum</span> <span class=\"o\">:</span> <span class=\"n\">PositivityExt</span> <span class=\"n\">where</span> <span class=\"n\">eval</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">β2</span><span class=\"o\">}</span> <span class=\"n\">zβ</span> <span class=\"n\">pβ</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">⟩</span> <span class=\"bp\">←</span> <span class=\"n\">inferTypeQ'</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">Expr.getAppArgs</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">withReducible</span> <span class=\"o\">(</span><span class=\"n\">whnf</span> <span class=\"n\">e</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"bp\">!</span> <span class=\"mi\">1</span>\n  <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">AddCommMonoid</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"bp\">←</span> <span class=\"n\">withReducible</span> <span class=\"o\">(</span><span class=\"n\">whnf</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"not sum\"</span>\n  <span class=\"n\">haveI'</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">β</span> <span class=\"bp\">=</span><span class=\"n\">Q</span> <span class=\"bp\">$</span><span class=\"n\">β2</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n  <span class=\"n\">haveI'</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"bp\">=</span><span class=\"n\">Q</span> <span class=\"n\">Finset.sum</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">rhs</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)))</span> <span class=\"bp\">←</span> <span class=\"n\">lambdaMetaTelescope</span> <span class=\"n\">b</span>\n  <span class=\"k\">let</span> <span class=\"n\">rb</span> <span class=\"bp\">←</span> <span class=\"n\">core</span> <span class=\"n\">zβ</span> <span class=\"n\">pβ</span> <span class=\"n\">rhs</span>\n  <span class=\"k\">match</span> <span class=\"n\">rb</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nonnegative</span> <span class=\"n\">pb</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">pα'</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">OrderedAddCommMonoid</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n    <span class=\"n\">assertInstancesCommute</span>\n    <span class=\"k\">let</span> <span class=\"n\">pr</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"n\">lhs</span> <span class=\"n\">pb</span>\n    <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nonnegative</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">sum_nonneg.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">$</span><span class=\"n\">β</span> <span class=\"bp\">$</span><span class=\"n\">pα'</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">pr</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"bp\">.</span><span class=\"n\">none</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Tactic.positivity</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">oops</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">):</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">j</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">positivity</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">oops</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">oops'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">):</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">j</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">i</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">positivity</span>\n</code></pre></div>\n<p>it has some limitations (I couldn't get universes to play nice so I just assume u = v and hope for the best, it currently doesn't use the fact that the element lies in the finset being summed over (maybe that would help in some situations), and it only does nonnegativity, as for positivity we need to know the sum is nonempty etc</p>",
        "id": 397991302,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1698026011
    },
    {
        "content": "<p>A really important case to get right for strict positivity is when the sum is over a nonempty fintype. Can you hardcode that?</p>",
        "id": 398021741,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698043882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Could.20positivity.20handle.20sums.20of.20squares.3F/near/398021741\">said</a>:</p>\n<blockquote>\n<p>A really important case to get right for strict positivity is when the sum is over a nonempty fintype. Can you hardcode that?</p>\n</blockquote>\n<p>Sure!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Positivity.Core</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Order</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Qq</span>\n<span class=\"kn\">open</span> <span class=\"n\">Mathlib.Meta.Positivity</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">positivity</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">evalSum</span> <span class=\"o\">:</span> <span class=\"n\">PositivityExt</span> <span class=\"n\">where</span> <span class=\"n\">eval</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">β2</span><span class=\"o\">}</span> <span class=\"n\">zβ</span> <span class=\"n\">pβ</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">⟩</span> <span class=\"bp\">←</span> <span class=\"n\">inferTypeQ'</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">Expr.getAppArgs</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">withReducible</span> <span class=\"o\">(</span><span class=\"n\">whnf</span> <span class=\"n\">e</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"bp\">!</span> <span class=\"mi\">1</span>\n  <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">AddCommMonoid</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"bp\">←</span> <span class=\"n\">withReducible</span> <span class=\"o\">(</span><span class=\"n\">whnf</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"not sum\"</span>\n  <span class=\"n\">haveI'</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">β</span> <span class=\"bp\">=</span><span class=\"n\">Q</span> <span class=\"bp\">$</span><span class=\"n\">β2</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n  <span class=\"n\">haveI'</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"bp\">=</span><span class=\"n\">Q</span> <span class=\"n\">Finset.sum</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">rhs</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)))</span> <span class=\"bp\">←</span> <span class=\"n\">lambdaMetaTelescope</span> <span class=\"n\">b</span>\n  <span class=\"k\">let</span> <span class=\"n\">rb</span> <span class=\"bp\">←</span> <span class=\"n\">core</span> <span class=\"n\">zβ</span> <span class=\"n\">pβ</span> <span class=\"n\">rhs</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">so</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Finset.Nonempty</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"k\">do</span> <span class=\"c1\">-- TODO if i make a typo it doesn't complain.?</span>\n    <span class=\"n\">try</span> <span class=\"o\">{</span>\n      <span class=\"k\">let</span> <span class=\"n\">fi</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fintype</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n      <span class=\"k\">let</span> <span class=\"n\">no</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nonempty</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Prop</span><span class=\"o\">))</span>\n      <span class=\"k\">match</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">univ</span> <span class=\"n\">_</span> <span class=\"bp\">$</span><span class=\"n\">fi</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Finset.univ_nonempty</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)))</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">none</span> <span class=\"o\">}</span>\n    <span class=\"n\">catch</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">pure</span> <span class=\"n\">none</span>\n  <span class=\"k\">match</span> <span class=\"n\">rb</span><span class=\"o\">,</span> <span class=\"n\">so</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nonnegative</span> <span class=\"n\">pb</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">pα'</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">OrderedAddCommMonoid</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n    <span class=\"n\">assertInstancesCommute</span>\n    <span class=\"k\">let</span> <span class=\"n\">pr</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"n\">lhs</span> <span class=\"n\">pb</span>\n    <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nonnegative</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">sum_nonneg.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">$</span><span class=\"n\">β</span> <span class=\"bp\">$</span><span class=\"n\">pα'</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">pr</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">positive</span> <span class=\"n\">pb</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">fi</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Finset.Nonempty</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">pα'</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">OrderedCancelAddCommMonoid</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n    <span class=\"n\">assertInstancesCommute</span>\n    <span class=\"k\">let</span> <span class=\"n\">pr</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"n\">lhs</span> <span class=\"n\">pb</span>\n    <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">positive</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">sum_pos.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">$</span><span class=\"n\">β</span> <span class=\"bp\">$</span><span class=\"n\">pα'</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">pr</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">fi</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"bp\">.</span><span class=\"n\">none</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Tactic.positivity</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">oops</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">):</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">j</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">positivity</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">oops</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">sum_pos</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">oops'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">):</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">8</span><span class=\"o\">,</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">j</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">i</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">positivity</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">oops''</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">):</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">j</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">positivity</span>\n</code></pre></div>",
        "id": 398073588,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1698063822
    },
    {
        "content": "<p>Finally, we really should let <code>positivity</code> look for local <code>Finset.Nonempty</code> assumptions. Heather and Mario previously complained that this was scope-creep, and I replied we could let <code>positivity</code> take extra assumptions (as in eg <code>positivity [hs, ha.trans hab]</code> where <code>hs : s.Nonempty</code>, <code>ha : 0 &lt; a</code>, <code>hab : a &lt; b</code>) that it is then allowed to search through, both as positivity assumptions and as assumptions that do not fit the <code>positivity</code> framework.</p>",
        "id": 398074551,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698064194
    },
    {
        "content": "<p>Do you think you could hack something like that?</p>",
        "id": 398074632,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698064208
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Could.20positivity.20handle.20sums.20of.20squares.3F/near/398074551\">said</a>:</p>\n<blockquote>\n<p>Finally, we really should let <code>positivity</code> look for local <code>Finset.Nonempty</code> assumptions. Heather and Mario previously complained that this was scope-creep</p>\n</blockquote>\n<p>This would  be local to the <code>Finset.sum</code> <code>positivity</code> handler, right? Not sure I agree that this is scope creep, it seems reasonable enough</p>",
        "id": 398075387,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1698064484
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Positivity.Core</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Order</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Qq</span>\n<span class=\"kn\">open</span> <span class=\"n\">Mathlib.Meta.Positivity</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">positivity</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">evalSum</span> <span class=\"o\">:</span> <span class=\"n\">PositivityExt</span> <span class=\"n\">where</span> <span class=\"n\">eval</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">β2</span><span class=\"o\">}</span> <span class=\"n\">zβ</span> <span class=\"n\">pβ</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">⟩</span> <span class=\"bp\">←</span> <span class=\"n\">inferTypeQ'</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">Expr.getAppArgs</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">withReducible</span> <span class=\"o\">(</span><span class=\"n\">whnf</span> <span class=\"n\">e</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"bp\">!</span> <span class=\"mi\">1</span>\n  <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">AddCommMonoid</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"bp\">←</span> <span class=\"n\">withReducible</span> <span class=\"o\">(</span><span class=\"n\">whnf</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"not sum\"</span>\n  <span class=\"n\">haveI'</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">β</span> <span class=\"bp\">=</span><span class=\"n\">Q</span> <span class=\"bp\">$</span><span class=\"n\">β2</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n  <span class=\"n\">haveI'</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"bp\">=</span><span class=\"n\">Q</span> <span class=\"n\">Finset.sum</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">rhs</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)))</span> <span class=\"bp\">←</span> <span class=\"n\">lambdaMetaTelescope</span> <span class=\"n\">b</span>\n  <span class=\"k\">let</span> <span class=\"n\">rb</span> <span class=\"bp\">←</span> <span class=\"n\">core</span> <span class=\"n\">zβ</span> <span class=\"n\">pβ</span> <span class=\"n\">rhs</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">so</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Finset.Nonempty</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"k\">do</span> <span class=\"c1\">-- TODO if i make a typo it doesn't complain.?</span>\n    <span class=\"n\">try</span> <span class=\"o\">{</span>\n      <span class=\"k\">let</span> <span class=\"n\">fi</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fintype</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n      <span class=\"k\">let</span> <span class=\"n\">no</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nonempty</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Prop</span><span class=\"o\">))</span>\n      <span class=\"k\">match</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">univ</span> <span class=\"n\">_</span> <span class=\"bp\">$</span><span class=\"n\">fi</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Finset.univ_nonempty</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)))</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">none</span> <span class=\"o\">}</span>\n    <span class=\"n\">catch</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">fv</span> <span class=\"bp\">←</span> <span class=\"n\">findLocalDeclWithType</span><span class=\"bp\">?</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Finset.Nonempty</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">pure</span> <span class=\"n\">none</span>\n      <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">fvar</span> <span class=\"n\">fv</span><span class=\"o\">))</span>\n  <span class=\"k\">match</span> <span class=\"n\">rb</span><span class=\"o\">,</span> <span class=\"n\">so</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nonnegative</span> <span class=\"n\">pb</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">pα'</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">OrderedAddCommMonoid</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n    <span class=\"n\">assertInstancesCommute</span>\n    <span class=\"k\">let</span> <span class=\"n\">pr</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"n\">lhs</span> <span class=\"n\">pb</span>\n    <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nonnegative</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">sum_nonneg.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">$</span><span class=\"n\">β</span> <span class=\"bp\">$</span><span class=\"n\">pα'</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">pr</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">positive</span> <span class=\"n\">pb</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">fi</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Finset.Nonempty</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">pα'</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">OrderedCancelAddCommMonoid</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n    <span class=\"n\">assertInstancesCommute</span>\n    <span class=\"k\">let</span> <span class=\"n\">pr</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"n\">lhs</span> <span class=\"n\">pb</span>\n    <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">positive</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">sum_pos.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">$</span><span class=\"n\">β</span> <span class=\"bp\">$</span><span class=\"n\">pα'</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">pr</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">fi</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"bp\">.</span><span class=\"n\">none</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Tactic.positivity</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">oops</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">):</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">j</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">positivity</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">oops</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">sum_pos</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">oops'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">):</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">8</span><span class=\"o\">,</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">j</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">i</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">positivity</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">oops''</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">):</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">j</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">positivity</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">oops'''</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">):</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">j</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Finset.Nonempty</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">singleton_nonempty</span> <span class=\"mi\">1</span>\n  <span class=\"n\">positivity</span>\n</code></pre></div>",
        "id": 398076223,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1698064782
    },
    {
        "content": "<p>Yes. It would be local to the <code>Finset.sum</code> extension. In fact, mathlib already has a local <code>positivity</code> tactic which looks for local assumptions (note the three distinct uses of \"local\" in the past two sentences): <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.positivity_szemeredi_regularity\">docs3#tactic.positivity_szemeredi_regularity</a>. I see that <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> translated it to a plain custom tactic: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SzemerediRegularity.Positivity.tacticSz_positivity#doc\">docs#SzemerediRegularity.Positivity.tacticSz_positivity</a></p>",
        "id": 398076919,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698065030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Could.20positivity.20handle.20sums.20of.20squares.3F/near/398074551\">said</a>:</p>\n<blockquote>\n<p>Finally, we really should let <code>positivity</code> look for local <code>Finset.Nonempty</code> assumptions. Heather and Mario previously complained that this was scope-creep, </p>\n</blockquote>\n<p>To be more precise: Mario previously complained. (You're talking about <a href=\"https://github.com/leanprover-community/mathlib/pull/16632\">!3#16632</a>, right?). But if Mario had concerns I think we should take them seriously ...</p>",
        "id": 398115233,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1698076554
    },
    {
        "content": "<p>Just a note that I am trying out Alex's <code>positivity</code> extension on my project <a href=\"https://github.com/teorth/symmetric_project\">https://github.com/teorth/symmetric_project</a> and so far it is working fine.  (Thanks to Alex for the pull request.)  Will let people know here if there are issues.</p>\n<p>I wonder if the same code that now lets <code>positivity</code> handle sums and products could also handle universal quantifiers?  For instance, in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">_</span>\n  <span class=\"n\">positivity</span>\n</code></pre></div>\n<p>whether <code>positivity</code> could perform the <code>intro</code> automatically.</p>",
        "id": 398115516,
        "sender_full_name": "Terence Tao",
        "timestamp": 1698076644
    },
    {
        "content": "<p>Ooh is that scope creep? :-)</p>",
        "id": 398115736,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698076708
    },
    {
        "content": "<p>How should I have interpreted your first comment on that same PR then, Heather?</p>",
        "id": 398115739,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698076710
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I still don't think <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">0&lt;a-b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> is in scope for positivity, but personally I don't object to having <code>Finset.nonempty</code> hypotheses being used for card-positivity, it seems in the same spirit as other positivity.  (But if Mario does, I think we should discuss it seriously.)</p>",
        "id": 398115897,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1698076777
    },
    {
        "content": "<p>Ah! Then what difference are you drawing between those two scenarios?</p>",
        "id": 398116039,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698076826
    },
    {
        "content": "<p>To me, positivity of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">0&lt;a-b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> given an ambient <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo>&lt;</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">b&lt;a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> hypothesis does not follow the positivity spec of \"clear from the syntax of the epxression\".</p>",
        "id": 398116255,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1698076891
    },
    {
        "content": "<p>Does it not? Would you then rather expect an extension for <code>0 &lt; a → b ≤ 0 → 0 &lt; a - b</code>?</p>",
        "id": 398116586,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698076989
    },
    {
        "content": "<p>Incidentally, Bhavik and I were talking about making <code>positivity</code> support <code>≤ 0</code> and <code>&lt; 0</code> assumptions. This actually shows up in our calculations and adding the logic to <code>positivity</code> is pretty easy without slowdown.</p>",
        "id": 398116908,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698077071
    },
    {
        "content": "<p>I must also add that in most cases we have a goal of the form <code>0 &lt; a - 1</code> and an assumption <code>1 &lt; a</code>. Namely, <code>b</code> is usually fixed.</p>",
        "id": 398117531,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698077269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Could.20positivity.20handle.20sums.20of.20squares.3F/near/398115736\">said</a>:</p>\n<blockquote>\n<p>Ooh is that scope creep? :-)</p>\n</blockquote>\n<p>Well, yes, but if we are already automatically clearing <code>Finset.sum_nonneg; intros</code> and <code>Finset.prod_nonneg; intros</code>, why not also just automatically clear <code>intros</code>?  There are plenty of other tools besides <code>Finset.sum_nonneg</code> and <code>Finset.prod_nonneg</code> that produce universally quantified positivity hypotheses; in my own project I have encountered <code>ConvexOn.map_sum_le</code>, <code>Real.finset_prod_rpow</code>, and <code>geom_mean_le_arith_mean_weighted</code>for instance, and I am sure there are many others.  I have taken to using a whole bunch of these tools in a row to manipulate various complex inequalities or equalities, accumulating a stack of a dozen positivity hypotheses outstanding, and it would be convenient to clear them all at once with <code>all_goals {positivity}</code>.</p>",
        "id": 398136568,
        "sender_full_name": "Terence Tao",
        "timestamp": 1698085563
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> It's possible to write a tactic of the form \"do the obvious logical stuff, then run tactic X\" using the tactic <code>aesop</code>. <br>\n Here's my quick attempt, which I am sure others can improve:</p>\n<p>first file contains</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Aesop</span>\n\n<span class=\"n\">declare_aesop_rule_sets</span> <span class=\"o\">[</span><span class=\"n\">Positivity</span><span class=\"o\">]</span>\n\n<span class=\"n\">macro</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">lpositivity</span><span class=\"o\">)</span> <span class=\"s2\">\"lpositivity\"</span> <span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">Aesop.tactic_clause</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n<span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span>\n  <span class=\"n\">aesop</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">options</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">introsTransparency</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"bp\">.</span><span class=\"n\">default</span><span class=\"o\">,</span> <span class=\"n\">terminal</span> <span class=\"o\">:=</span> <span class=\"n\">true</span> <span class=\"o\">})</span>\n  <span class=\"o\">(</span><span class=\"n\">rule_sets</span> <span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Lean.mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">Positivity</span><span class=\"o\">):</span><span class=\"n\">ident</span><span class=\"o\">]))</span>\n</code></pre></div>\n<p>second file contains</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Positivity</span>\n<span class=\"kn\">import</span> <span class=\"o\">[</span><span class=\"n\">first</span> <span class=\"n\">file</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span>\n<span class=\"kd\">@[</span><span class=\"n\">aesop</span> <span class=\"n\">safe</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">rule_sets</span> <span class=\"o\">[</span><span class=\"n\">Positivity</span><span class=\"kd\">]</span><span class=\"o\">)]</span>\n<span class=\"kd\">def</span> <span class=\"n\">PositivityForAesop</span> <span class=\"o\">:</span> <span class=\"n\">TacticM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">liftMetaTactic</span> <span class=\"k\">fun</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">Mathlib.Meta.Positivity.positivity</span> <span class=\"n\">g</span><span class=\"bp\">;</span> <span class=\"n\">pure</span> <span class=\"o\">[]</span>\n</code></pre></div>\n<p>Then this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">lpositivity</span>\n<span class=\"c1\">-- `lpositivity` for \"logic + positivity\"</span>\n</code></pre></div>",
        "id": 398139093,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1698086796
    },
    {
        "content": "<p>It will also solve e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">∧</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span> <span class=\"bp\">^</span> <span class=\"mi\">4</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">lpositivity</span>\n</code></pre></div>",
        "id": 398139464,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1698086966
    },
    {
        "content": "<p>You could also just do this if you only care about <code>intro</code>ducing new variables: <code>all_goals {intros; positivity}</code>, but Heather's <code>aesop</code> configuration would be a more sophisticated approach that can do more.</p>",
        "id": 398139998,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698087205
    },
    {
        "content": "<p>And if you want to abbreviate Jireh's version, you can name it with a macro:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Positivity</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"lpositivity\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">positivity</span><span class=\"o\">))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">lpositivity</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">lpositivity</span>\n</code></pre></div>",
        "id": 398140439,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1698087419
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Could.20positivity.20handle.20sums.20of.20squares.3F/near/398139998\">said</a>:</p>\n<blockquote>\n<p>You could also just do this if you only care about <code>intro</code>ducing new variables: <code>all_goals {intros; positivity}</code>, but Heather's <code>aesop</code> configuration would be a more sophisticated approach that can do more.</p>\n</blockquote>\n<p>Ah, I didn't realize that <code>intros</code> doesn't fail if there is nothing to introduce.  That solves my immediate use case nicely - thanks!</p>\n<p>There could still be some value I think though in a more aggressive cousin <code>positivity!</code> of <code>positivity</code> that applies a few more \"obvious\" reductions in a search for establishing positivity.</p>",
        "id": 398142099,
        "sender_full_name": "Terence Tao",
        "timestamp": 1698088113
    },
    {
        "content": "<p>If you want to use a tactic that could fail (e.g., <code>intro</code>) then you could do it this way: <code>(try intro); positivity</code>.</p>",
        "id": 398142388,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698088256
    },
    {
        "content": "<p>I think the solution to that is ultimately <code>aesop</code> as Heather suggests, but I think <span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> is working on a method to allow tactic calls within <code>aesop</code>, am I correct?</p>",
        "id": 398142690,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698088397
    },
    {
        "content": "<p>To clarify what I meant about scope creep, I think it is fine if <code>positivity</code> uses typeclass inference for nonempty assumptions, but having the nonempty subgoals be mutually recursive with other kinds of goals is going to make it a kitchen sink tactic because there is no clear bound on what subgoals should be considered, and at that point you have just reinvented <code>apply_rules</code>.</p>",
        "id": 398147942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698091295
    },
    {
        "content": "<p>Okay but surely depth 1 is not scope-creep?</p>",
        "id": 398149288,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698092061
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Could.20positivity.20handle.20sums.20of.20squares.3F/near/398142690\">said</a>:</p>\n<blockquote>\n<p>I think the solution to that is ultimately <code>aesop</code> as Heather suggests, but I think <span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> is working on a method to allow tactic calls within <code>aesop</code>, am I correct?</p>\n</blockquote>\n<p>It's already possible to call arbitrary tactics in Aesop (all rules are ultimately tactics). It's just that the syntax is currently very ugly.</p>",
        "id": 398265738,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1698146438
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>, I just tried <a href=\"#narrow/stream/287929-mathlib4/topic/Could.20positivity.20handle.20sums.20of.20squares.3F/near/398076223\">your positivity extension</a> but it seems to mishandle universes. In my use cases, I get errors of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"bp\">@</span><span class=\"n\">sum_nonneg</span> <span class=\"n\">ι</span>\n<span class=\"n\">argument</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">but</span> <span class=\"n\">function</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">OrderedAddCommMonoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span>\n</code></pre></div>",
        "id": 407860100,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702524108
    },
    {
        "content": "<p>Here's a MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Normed.Field.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Qq</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">positivity</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Mathlib.Meta.Positivity.evalSum</span> <span class=\"o\">:</span> <span class=\"n\">PositivityExt</span> <span class=\"n\">where</span> <span class=\"n\">eval</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">β2</span><span class=\"o\">}</span> <span class=\"n\">zβ</span> <span class=\"n\">pβ</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">_v</span><span class=\"o\">,</span> <span class=\"n\">_l</span><span class=\"o\">,</span> <span class=\"n\">_r</span><span class=\"o\">⟩</span> <span class=\"bp\">←</span> <span class=\"n\">inferTypeQ'</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">Expr.getAppArgs</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">withReducible</span> <span class=\"o\">(</span><span class=\"n\">whnf</span> <span class=\"n\">e</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"bp\">!</span> <span class=\"mi\">1</span>\n  <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">_f</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">_a</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">AddCommMonoid</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"bp\">←</span> <span class=\"n\">withReducible</span> <span class=\"o\">(</span><span class=\"n\">whnf</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"not `Finset.sum`\"</span>\n  <span class=\"n\">haveI'</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">β</span> <span class=\"bp\">=</span><span class=\"n\">Q</span> <span class=\"bp\">$</span><span class=\"n\">β2</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n  <span class=\"n\">haveI'</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"bp\">=</span><span class=\"n\">Q</span> <span class=\"n\">Finset.sum</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">rhs</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)))</span> <span class=\"bp\">←</span> <span class=\"n\">lambdaMetaTelescope</span> <span class=\"n\">b</span>\n  <span class=\"k\">let</span> <span class=\"n\">rb</span> <span class=\"bp\">←</span> <span class=\"n\">core</span> <span class=\"n\">zβ</span> <span class=\"n\">pβ</span> <span class=\"n\">rhs</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">so</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Finset.Nonempty</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"k\">do</span> <span class=\"c1\">-- TODO: if I make a typo it doesn't complain?</span>\n    <span class=\"n\">try</span> <span class=\"o\">{</span>\n      <span class=\"k\">let</span> <span class=\"n\">_fi</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fintype</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n      <span class=\"k\">let</span> <span class=\"n\">_no</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nonempty</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Prop</span><span class=\"o\">))</span>\n      <span class=\"k\">match</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">univ</span> <span class=\"n\">_</span> <span class=\"bp\">$</span><span class=\"n\">fi</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Finset.univ_nonempty</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)))</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">none</span> <span class=\"o\">}</span>\n    <span class=\"n\">catch</span> <span class=\"n\">_e</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">fv</span> <span class=\"bp\">←</span> <span class=\"n\">findLocalDeclWithType</span><span class=\"bp\">?</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Finset.Nonempty</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">pure</span> <span class=\"n\">none</span>\n      <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">fvar</span> <span class=\"n\">fv</span><span class=\"o\">))</span>\n  <span class=\"k\">match</span> <span class=\"n\">rb</span><span class=\"o\">,</span> <span class=\"n\">so</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nonnegative</span> <span class=\"n\">pb</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">pα'</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">OrderedAddCommMonoid</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n    <span class=\"n\">assertInstancesCommute</span>\n    <span class=\"k\">let</span> <span class=\"n\">pr</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"n\">lhs</span> <span class=\"n\">pb</span>\n    <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nonnegative</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">sum_nonneg.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">$</span><span class=\"n\">β</span> <span class=\"bp\">$</span><span class=\"n\">pα'</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">_h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">pr</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">positive</span> <span class=\"n\">pb</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">fi</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Finset.Nonempty</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">pα'</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">OrderedCancelAddCommMonoid</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n    <span class=\"n\">assertInstancesCommute</span>\n    <span class=\"k\">let</span> <span class=\"n\">pr</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"n\">lhs</span> <span class=\"n\">pb</span>\n    <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">positive</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">sum_pos.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">$</span><span class=\"n\">β</span> <span class=\"bp\">$</span><span class=\"n\">pα'</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">_h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">pr</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">fi</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"bp\">.</span><span class=\"n\">none</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">‖</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"bp\">‖</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">positivity</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 407860166,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702524124
    },
    {
        "content": "<p>This is very easily explained by the <code>(β : Q(Type u))) (α : Q(Type u)))</code> in the second line of your extension, but I don't know how one can pattern-match on universe levels to fix it.</p>",
        "id": 407860662,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702524298
    },
    {
        "content": "<p>My recollection is that I also couldn't get things to work more universe polymorphically which is why I hardcoded it. I can make another attempt sometime but I'm not sure I will fare any better than the first time around</p>",
        "id": 407861478,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1702524598
    },
    {
        "content": "<p>It would be quite annoying for me to force everything in <code>Type</code>, especially because I'm writing code that I hope will end up in mathlib, so I'd greatly appreciate any effort to save universe polymorphism!</p>",
        "id": 407861790,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702524707
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> can impart us some wisdom too.</p>",
        "id": 407861846,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702524724
    },
    {
        "content": "<p>Update: I managed to make it polymorphic thanks to Mario's advice! I just replaced the first two <code>let</code> with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"n\">_</span> <span class=\"o\">[</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"n\">_a</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">AddCommMonoid</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"bp\">←</span> <span class=\"n\">withReducible</span> <span class=\"o\">(</span><span class=\"n\">whnf</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and now everything works.</p>",
        "id": 407879018,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702531435
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>, I PRed the extension in <a href=\"https://github.com/leanprover-community/mathlib4/pull/9365\">#9365</a> but it fails in <code>Computability.AkraBazzi</code> because it seems to wrongly infer what function is inside the sum. See my comment on the PR.</p>",
        "id": 410628975,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704024119
    }
]