[
    {
        "content": "<p>Quiz: if <code>F</code> is a field without <code>DecidableEq</code>, can you define a function on it which maps non-zero <code>x</code> to <code>x</code>, and maps <code>0</code> to <code>1</code>? You can't use <code>if x = 0 then 1 else x</code> since there is no <code>DecidableEq</code>.</p>\n<p>Answer: it is <code>(x - 1) * x / x + 1</code>, since in Lean anything divide by <code>0</code> is <code>0</code>.</p>\n<p>But seems that in order to prove that this function satisfies the property, <code>classical</code> must be used, since you need <code>by_cases h : x = 0</code>.</p>\n<p>Any thoughts?</p>",
        "id": 472897207,
        "sender_full_name": "Jz Pan",
        "timestamp": 1727357269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/stream/287929-mathlib4/topic/field.20division.20and.20DecidableEq/near/472897207\">said</a>:</p>\n<blockquote>\n<p>But seems that in order to prove that this function satisfies the property, <code>classical</code> must be used, since you need <code>by_cases h : x = 0</code>.</p>\n</blockquote>\n<p>To prove what property? Not to show that <code>f(0)=1</code> or <code>x \\ne 0 \\to f(x)=x</code>.</p>",
        "id": 472897615,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1727357387
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/287929-mathlib4/topic/field.20division.20and.20DecidableEq/near/472897615\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/stream/287929-mathlib4/topic/field.20division.20and.20DecidableEq/near/472897207\">said</a>:</p>\n<blockquote>\n<p>But seems that in order to prove that this function satisfies the property, <code>classical</code> must be used, since you need <code>by_cases h : x = 0</code>.</p>\n</blockquote>\n<p>To prove what property?</p>\n</blockquote>\n<p>Prove that (1) it maps non-zero <code>x</code> to <code>x</code>, and maps <code>0</code> to <code>1</code>.</p>\n<p>... or prove that (2) it maps any elements to nonzero elements.</p>",
        "id": 472898528,
        "sender_full_name": "Jz Pan",
        "timestamp": 1727357615
    },
    {
        "content": "<p>Real world scenario: in PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/16864\">#16864</a> I defined something depends on some number equal to zero or not: <a href=\"https://github.com/leanprover-community/mathlib4/blob/9e08b117fbd856d22db894716a4df6d39e93d780/Mathlib/AlgebraicGeometry/EllipticCurve/NormalForms.lean#L645\">https://github.com/leanprover-community/mathlib4/blob/9e08b117fbd856d22db894716a4df6d39e93d780/Mathlib/AlgebraicGeometry/EllipticCurve/NormalForms.lean#L645</a> but in order to make it work without <code>classical</code> I have to add a <code>DecidableEq</code> instance. I'm thinking if it worth to use such cheating way to define it bypassing <code>DecidableEq</code>.</p>",
        "id": 472900048,
        "sender_full_name": "Jz Pan",
        "timestamp": 1727358037
    },
    {
        "content": "<p>in <a href=\"https://github.com/leanprover-community/mathlib4/blob/9e08b117fbd856d22db894716a4df6d39e93d780/Mathlib/AlgebraicGeometry/EllipticCurve/NormalForms.lean#L375\">https://github.com/leanprover-community/mathlib4/blob/9e08b117fbd856d22db894716a4df6d39e93d780/Mathlib/AlgebraicGeometry/EllipticCurve/NormalForms.lean#L375</a> the cheat is successful since in that case I just want 1,0,0,0 if some number is zero, so I don't need to invent some artificial formulas.</p>",
        "id": 472900289,
        "sender_full_name": "Jz Pan",
        "timestamp": 1727358110
    },
    {
        "content": "<p>Is there a reason why you want to avoid <code>classical</code> there?</p>",
        "id": 472900722,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1727358227
    },
    {
        "content": "<p>There are no particular reason, just out of curiosity. I just want the <code>def</code> itself does not depend on <code>classical</code>, since it is an explicit formula written in textbook, so it should be computable. For the proof of the property it satisfies, I'm OK if it requires <code>classical</code>.</p>",
        "id": 472901428,
        "sender_full_name": "Jz Pan",
        "timestamp": 1727358430
    },
    {
        "content": "<p>If there is no particular reason, my advice would be to use <code>classical</code>from the start. The only downside I can think of is if you want to run this on explicit examples using kernel calculations, but it's probably a bad idea anyway.</p>",
        "id": 472901977,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1727358601
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/stream/287929-mathlib4/topic/field.20division.20and.20DecidableEq/near/472901977\">said</a>:</p>\n<blockquote>\n<p>my advice would be to use <code>classical</code>from the start</p>\n</blockquote>\n<p>Thank you for your suggestion!</p>\n<p>But I got the contrary comments from reviewers on my previous PRs, they don't like <code>noncomputable section</code> and <code>open scoped Classical</code> in the beginning...</p>",
        "id": 472904769,
        "sender_full_name": "Jz Pan",
        "timestamp": 1727359370
    },
    {
        "content": "<p><code>open scoped Classical</code> is definitely bad, as you don't know what it can contaminate. For definitions that need it, just do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foobar</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>And in proofs about <code>foobar</code>, use <code>classical</code> at the beginning of the proofs if needed.</p>",
        "id": 472906123,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1727359753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/stream/287929-mathlib4/topic/field.20division.20and.20DecidableEq/near/472906123\">said</a>:</p>\n<blockquote>\n<p><code>open scoped Classical</code> is definitely bad, as you don't know what it can contaminate. For definitions that need it, just do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foobar</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>And in proofs about <code>foobar</code>, use <code>classical</code> at the beginning of the proofs if needed.</p>\n</blockquote>\n<p><code>open scoped Classical in</code> is probably better practice, but the gain over what you have is small compared to the <code>in</code>-free version</p>",
        "id": 473247129,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727477185
    }
]