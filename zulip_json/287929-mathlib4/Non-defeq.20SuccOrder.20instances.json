[
    {
        "content": "<p>I'm getting a weird error in some code I'm writing which uses the notion of a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SuccOrder#doc\">docs#SuccOrder</a> (an ordered set with a \"successor\" function);  it doesn't work as expected if I apply it to the natural numbers.</p>\n<p>I think the problem is that Mathlib has two distinct ways of synthesizing an instance of <code>SuccOrder</code> on <code>ℕ</code>:</p>\n<ul>\n<li>via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SuccAddOrder.toSuccOrder#doc\">docs#SuccAddOrder.toSuccOrder</a>, which provides an instance for which <code>Order.succ n</code> is definitionally <code>Nat.succ n</code>, i.e. <code>n + 1</code>; </li>\n<li>or alternatively via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearLocallyFiniteOrder.instSuccOrderOfLocallyFiniteOrder#doc\">docs#LinearLocallyFiniteOrder.instSuccOrderOfLocallyFiniteOrder</a>, which provides a different instance, for which <code>Order.succ n</code> is defined as a choice of GLB of <code>Ioi n</code>. </li>\n</ul>\n<p>The two are propositionally equal but not definitionally equal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">SuccPred</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">SuccPred</span><span class=\"bp\">.</span><span class=\"n\">LinearLocallyFinite</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Interval</span><span class=\"bp\">.</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">o1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SuccOrder</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LinearLocallyFiniteOrder</span><span class=\"bp\">.</span><span class=\"n\">instSuccOrderOfLocallyFiniteOrder</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">o2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SuccOrder</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SuccAddOrder</span><span class=\"bp\">.</span><span class=\"n\">toSuccOrder</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">o1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">o2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">--fails</span>\n</code></pre></div>\n<p>What's the best solution to this? Maybe <code>LinearLocallyFiniteOrder.instSuccOrderOfLocallyFiniteOrder</code> shouldn't be an instance?</p>\n<p>(Tagging <span class=\"user-mention\" data-user-id=\"350992\">@Rémy Degenne</span>, who seems to have been the author of <code>LinearLocallyFiniteOrder.instSuccOrderOfLocallyFiniteOrder</code>)</p>",
        "id": 490692736,
        "sender_full_name": "David Loeffler",
        "timestamp": 1735057646
    },
    {
        "content": "<p>I don't remember why I added that instance. Presumably it got me another instance on some type. If I worked on succ orders, it has to be as a tool for something else, not for themselves. If the instance is problematic and removing it does not break too much things, feel free to do it (or fix it in another way).</p>",
        "id": 490699824,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1735062617
    },
    {
        "content": "<p>This should not be an instance.</p>",
        "id": 490712317,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1735072400
    },
    {
        "content": "<p>Because it creates data <code>Order.succ</code> from classical choice.</p>",
        "id": 490712337,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1735072431
    },
    {
        "content": "<p>The alternative is to make a <code>LocallyFiniteLinearOrder</code> class that extends <code>LinearOrder, LocallyFiniteOrder, SuccOrder,  PredOrder</code>, right?</p>",
        "id": 490712519,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735072574
    },
    {
        "content": "<p>Why not <code>[LinearOrder α] [LocallyFiniteOrder α] [SuccOrder α] [PredOrder α]</code>?</p>",
        "id": 490713215,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1735073324
    },
    {
        "content": "<p>Are they all mixins? Or does that give you multiple LEs?</p>",
        "id": 490724403,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735084660
    },
    {
        "content": "<p>Only <code>LinearOrder</code> is not a mixin</p>",
        "id": 490724500,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1735084761
    },
    {
        "content": "<p>Fixed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/20235\">#20235</a></p>",
        "id": 490744584,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1735104560
    },
    {
        "content": "<p>I'm trying to drop <code>SuccOrder</code>/<code>PredOrder</code> assumptions you've introduced.</p>",
        "id": 490752934,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1735111848
    },
    {
        "content": "<p>Great! Feel free to push directly to that PR</p>",
        "id": 490755021,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1735113540
    },
    {
        "content": "<p>Pushed</p>",
        "id": 490756844,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1735114988
    },
    {
        "content": "<p>Also opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/20237\">#20237</a></p>",
        "id": 490757111,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1735115182
    }
]