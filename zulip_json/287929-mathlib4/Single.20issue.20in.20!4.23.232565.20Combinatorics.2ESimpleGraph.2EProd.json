[
    {
        "content": "<p>I again have a file down to a single issue, this time what appears to be a missing type inference at <code>Finset.univ</code> in <code>boxProd_neighborFinset</code>. There are a limited set of types it could be but I haven't managed to type annotate correctly yet. Would appreciate extra eyes on...</p>",
        "id": 339006719,
        "sender_full_name": "Arien Malec",
        "timestamp": 1677735095
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">xa</span><span class=\"o\">,</span><span class=\"n\">xb</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n  <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">⟩</span>\n  <span class=\"n\">aesop</span>\n</code></pre></div>\n<p>seems to close the goal, but I don't know if that's allowed? Oh, but I think it poisons some instance?</p>\n<p><strong>Edit</strong> with that proof above, the next theorem fails, but you can dumbly make it work again with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">boxProd_degree</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">G.neighborSet</span> <span class=\"n\">x.1</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">H.neighborSet</span> <span class=\"n\">x.2</span><span class=\"o\">)]</span>\n    <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"o\">((</span><span class=\"n\">G</span> <span class=\"bp\">□</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">neighborSet</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">□</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">degree</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">G.degree</span> <span class=\"n\">x.1</span> <span class=\"bp\">+</span> <span class=\"n\">H.degree</span> <span class=\"n\">x.2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">degree</span><span class=\"o\">,</span> <span class=\"n\">degree</span><span class=\"o\">,</span> <span class=\"n\">degree</span><span class=\"o\">,</span> <span class=\"n\">boxProd_neighborFinset</span><span class=\"o\">,</span> <span class=\"n\">Finset.card_disjUnion</span><span class=\"o\">]</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.card_product</span><span class=\"o\">,</span> <span class=\"n\">Finset.card_singleton</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">x</span>\n  <span class=\"n\">exact</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>I don't understand why it needs those two new <code>exact</code>s.</p>",
        "id": 339021376,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1677742170
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">boxProd_neighborFinset</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">G.neighborSet</span> <span class=\"n\">x.1</span><span class=\"o\">)]</span>\n    <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">H.neighborSet</span> <span class=\"n\">x.2</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"o\">((</span><span class=\"n\">G</span> <span class=\"bp\">□</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">neighborSet</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">□</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">neighborFinset</span> <span class=\"n\">x</span> <span class=\"bp\">=</span>\n      <span class=\"c1\">-- porting note: was `×ˢ`</span>\n      <span class=\"o\">(</span><span class=\"n\">G.neighborFinset</span> <span class=\"n\">x.1</span> <span class=\"bp\">×ᶠ</span> <span class=\"o\">{</span><span class=\"n\">x.2</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">disjUnion</span> <span class=\"o\">({</span><span class=\"n\">x.1</span><span class=\"o\">}</span> <span class=\"bp\">×ᶠ</span> <span class=\"n\">H.neighborFinset</span> <span class=\"n\">x.2</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">Finset.disjoint_product.mpr</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Or.inl</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">neighborFinset_disjoint_singleton</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n  <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">aesop</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">simple_graph.box_prod_neighbor_finset</span> <span class=\"n\">SimpleGraph.boxProd_neighborFinset</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">boxProd_degree</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">G.neighborSet</span> <span class=\"n\">x.1</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">H.neighborSet</span> <span class=\"n\">x.2</span><span class=\"o\">)]</span>\n    <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"o\">((</span><span class=\"n\">G</span> <span class=\"bp\">□</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">neighborSet</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">□</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">degree</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">G.degree</span> <span class=\"n\">x.1</span> <span class=\"bp\">+</span> <span class=\"n\">H.degree</span> <span class=\"n\">x.2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">degree</span><span class=\"o\">,</span> <span class=\"n\">degree</span><span class=\"o\">,</span> <span class=\"n\">degree</span><span class=\"o\">,</span> <span class=\"n\">boxProd_neighborFinset</span><span class=\"o\">,</span> <span class=\"n\">Finset.card_disjUnion</span><span class=\"o\">]</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.card_product</span><span class=\"o\">,</span> <span class=\"n\">Finset.card_singleton</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">x</span>\n  <span class=\"n\">exact</span> <span class=\"n\">y</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">simple_graph.box_prod_degree</span> <span class=\"n\">SimpleGraph.boxProd_degree</span>\n</code></pre></div>\n<p>So, if I use <code>aesop</code> in the first theorem, it decides to catch two implicit variables, not sure why.<br>\nSeems to me this is a case where <code>omit</code> would have been useful.</p>",
        "id": 339040184,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1677748243
    },
    {
        "content": "<p>The <code>aesop</code> thing is a gotcha when you're coming from Lean 3. Now <em>every variable is available in theorems</em> and there's no way for a smart tactic to know that it shouldn't do cases on something in the local context.</p>\n<p>A solution to this is to be more careful with what you put in your <code>variable</code>s. I went ahead and did that</p>",
        "id": 339055833,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677752445
    },
    {
        "content": "<p>But I also fixed the proof of <code>boxProd_neighborFinset</code>, which is now slightly more careful about how it replaces the <code>Fintype</code> instance.</p>",
        "id": 339056251,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677752546
    },
    {
        "content": "<blockquote>\n<p>The aesop thing is a gotcha when you're coming from Lean 3. Now every variable is available in theorems and there's no way for a smart tactic to know that it shouldn't do cases on something in the local context.</p>\n</blockquote>\n<p>That seems like a footgun. Is there a way/plan to remedy this?<br>\nI mean, the \"no need for omit/include anymore\" pitch doesn't mean much if you can actually get got by unwanted use of variables…</p>",
        "id": 339057490,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1677752852
    },
    {
        "content": "<p>Another place to be careful is <a href=\"#narrow/stream/270676-lean4/topic/.60induction.60.20tactic.20changes.20type.20signature.3F/near/338448701\">with induction</a> since it generalizes all variables that depend on variables involved in the induction.</p>",
        "id": 339060081,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677753406
    },
    {
        "content": "<p>I'm not sure there's a good solution beyond relying more on autoimplicits and mimicking omit/include by carefully crafting your <code>variable</code>s.</p>",
        "id": 339060558,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1677753513
    },
    {
        "content": "<p>ah, autoimplicits mean we don't have as much of an incentive to keep variables around, good point!</p>",
        "id": 339060735,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1677753570
    }
]