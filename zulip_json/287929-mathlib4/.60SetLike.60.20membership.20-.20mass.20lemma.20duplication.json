[
    {
        "content": "<p>Types with a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SetLike#doc\">docs#SetLike</a> instance are given a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Membership#doc\">docs#Membership</a> instance (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SetLike.instMembership#doc\">docs#SetLike.instMembership</a>), defining the operation <code>x ∈ p</code> as <code>x ∈ (p : Set B)</code>. The <code>simp</code> lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SetLike.mem_coe#doc\">docs#SetLike.mem_coe</a> then rewrites <code>x ∈ (p : Set B)</code> to <code>x ∈ p</code>. This means that, whenever we have a <code>simp</code> lemma <code>coe_foo : (p : Set B) = q</code>, we need also a <code>simp</code> lemma <code>mem_foo {x} : x ∈ p ↔ x ∈ q</code>.</p>\n<p>Across the library, this must add up to the duplication of thousands of lemmas, with thousands more <code>mem_foo</code> lemmas simply missing, leading to surprising <code>simp</code> failures (as I found out recently).</p>\n<p>I'm not (currently) proposing to change such a fundamental design choice, but I do want to understand it better. Is anyone aware of the history of <code>SetLike</code>? In particular, what gets worse if the above <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Membership#doc\">docs#Membership</a> instance is removed, so that <code>x ∈ p</code> simply elaborates to <code>x ∈ (p : Set B)</code>?</p>",
        "id": 569960907,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769354513
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60SetLike.60.20membership.20-.20mass.20lemma.20duplication/near/569960907\">said</a>:</p>\n<blockquote>\n<p>In particular, what gets worse if the above <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Membership#doc\">docs#Membership</a> instance is removed, so that <code>x ∈ p</code> simply elaborates to <code>x ∈ (p : Set B)</code>?</p>\n</blockquote>\n<p>I don't think this works? You will just get a \"failed to synthesize instance\" error</p>",
        "id": 569961501,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769355100
    },
    {
        "content": "<p>I will try it out. I figured it would see <code>x : B</code> and infer <code>p : Set B</code> and find a coercion. Maybe a custom elaborator would be required for this?</p>",
        "id": 569961553,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769355162
    },
    {
        "content": "<p>I think a custom elaborator may make sense here</p>",
        "id": 569961649,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1769355260
    },
    {
        "content": "<p>the type of <code>x</code> is never used when synthesizing a membership instance, typeclass always only looks at the type of <code>p</code></p>",
        "id": 569961703,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769355320
    },
    {
        "content": "<p>Ah OK. It's the <code>outParam</code> thing right? Presumably this explains the design choice?</p>",
        "id": 569961736,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769355358
    },
    {
        "content": "<p>I guess if we tried to force it to elaborate this way, it would have to run a typeclass search for <code>SetLike A B</code> every time it saw something of the form <code>(x : B) ∈ (p : A)</code>. Currently it only has to search for <code>Membership ? A</code>.</p>",
        "id": 569961865,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769355499
    },
    {
        "content": "<p>Shouldn't <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SetLike#doc\">docs#SetLike</a> extend <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Membership#doc\">docs#Membership</a> and have a some <code>mem_coe_iff_mem</code> field?<br>\nEDIT: that wouldn't solve the problem though</p>",
        "id": 569961963,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769355620
    },
    {
        "content": "<p>What we could try is to remove the instance <code>SetLike.instMembership</code>, and add a custom elaborator for <code>Membership.mem</code>, which first tries to elaborate the application as normal, and if that fails, then it falls back to syntesizing a <code>SetLike</code> instance, and constructing the term that contains a coercion.</p>\n<p>However such a \"try this, else that\" elaborator can have some rough edges when there are metavariables, because then instance search gets delayed, and it's nkt clear if this should count as a success or a failure.</p>",
        "id": 569962273,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1769355952
    },
    {
        "content": "<p>my main concern is this would tank the performance</p>",
        "id": 569962308,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769355980
    },
    {
        "content": "<p>Could you give a concrete example for <code>coe_foo</code> and <code>mem_foo</code> (or missing <code>mem_foo</code>)?</p>",
        "id": 569963069,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769356663
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"870257\">@Jakub Nowak</span> see <a href=\"https://github.com/leanprover-community/mathlib4/pull/33801\">#33801</a></p>",
        "id": 569963115,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769356720
    },
    {
        "content": "<p>If we do not manage to sort something out with the elaborator, we can always create an attribute that makes the mem form of the coe form (similar to how <code>@[reassoc]</code> works)</p>",
        "id": 569963291,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1769356917
    },
    {
        "content": "<p>Something like this for <code>simps</code> would be amazing</p>",
        "id": 569963326,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769356946
    },
    {
        "content": "<p>In what sense do you mean for <code>simps</code>? Does <code>simps</code> create the problematic coe theorems?</p>",
        "id": 569964121,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1769357679
    },
    {
        "content": "<p><code>simps</code> creates the <code>coe</code> but not the <code>mem</code> so it's the most common way for the missing <code>mem</code> to get past review.</p>",
        "id": 569964174,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769357732
    },
    {
        "content": "<p><del>Btw, this is mentioned in documentation of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SetLike#doc\">docs#SetLike</a></del><br>\n<del>&gt; Note: if <code>SetLike.coe</code> is a projection, implementers should create a simp lemma such as [...]</del></p>\n<p>nvm, that's something different</p>",
        "id": 569967870,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769361054
    },
    {
        "content": "<p>I don't exactly understand your elabolator idea. Wouldn't reversing the direction of simp lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/SetLike/Basic.html#SetLike.mem_coe\">SetLike.mem_coe</a> have the same effect?</p>",
        "id": 569968172,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769361337
    },
    {
        "content": "<p>Well, not the same, because it would require using <code>simp</code> to convert <code>x ∈ p</code> to <code>x ∈ (p : Set B)</code>, but the whole problem is about <code>simp</code> anyway.</p>",
        "id": 569968244,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769361400
    },
    {
        "content": "<p>Technically yes, but that would require manually inserting explicit coercions into theorem statements. It's less about <code>simp</code> specifically and more about what the standard spelling is.</p>",
        "id": 569968283,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769361439
    },
    {
        "content": "<p>The elaborator idea is basically, how do you insert those coercions automatically?</p>",
        "id": 569968331,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769361478
    },
    {
        "content": "<p>Hm, maybe <code>simp</code> could have some kind of normalization pass, so that it normalizes <code>x ∈ p</code> to <code>x ∈ (p : Set B)</code> before inserting and searching in discrimination tree?</p>",
        "id": 569969640,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769362674
    },
    {
        "content": "<p>I think it would be a pretty bizarre solution, but yes indeed you could basically have <code>simp</code> have a hidden reverse <code>SetLike.mem_coe</code> rewrite. However, that wouldn't solve the problem that every tactic that isn't <code>simp</code> (most notably <code>rw</code>) also needs to use that rewrite! <code>simp</code> non-confluence is just the most obvious manifestation of the problem of missing <code>mem_foo</code> lemmas.</p>",
        "id": 569969828,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769362857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60SetLike.60.20membership.20-.20mass.20lemma.20duplication/near/569962273\">said</a>:</p>\n<blockquote>\n<p>What we could try is to remove the instance <code>SetLike.instMembership</code>, and add a custom elaborator for <code>Membership.mem</code>, which first tries to elaborate the application as normal, and if that fails, then it falls back to syntesizing a <code>SetLike</code> instance, and constructing the term that contains a coercion.</p>\n<p>However such a \"try this, else that\" elaborator can have some rough edges when there are metavariables, because then instance search gets delayed, and it's nkt clear if this should count as a success or a failure.</p>\n</blockquote>\n<p>Maybe we could  try not removing <code>SetLike.instMembership</code> and do instance search as normal. After finding the instance, we check if the found instance is <code>SetLike.instMembership</code> and if it is, we replace it with <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Defs.html#Set.instMembership\">Set.instMembership</a> and coercion. This shouldn't change the behaviour regarding metavariable instantation, and the only visible effect would be automatically inserting coercions.</p>",
        "id": 569970575,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769363760
    },
    {
        "content": "<p>Something like that</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Sets</span><span class=\"bp\">.</span><span class=\"n\">Opens</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">mem_coe</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Opens</span><span class=\"bp\">.</span><span class=\"n\">mem_sup</span>\n\n<span class=\"kn\">syntax</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"s2\">\" ∈' \"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n\n<span class=\"kn\">macro_rules</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈'</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"n\">elab_rules</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈'</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">typ?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‹</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"bp\">›</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Membership</span><span class=\"bp\">.</span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">typ?</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">instT</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">getArg!</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">synthInstance?</span><span class=\"w\"> </span><span class=\"n\">instT</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">.</span><span class=\"n\">isAppOf</span><span class=\"w\"> </span><span class=\"ss\">`SetLike.instMembership</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Membership</span><span class=\"bp\">.</span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">typ?</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">e</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Opens</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Opens</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">guard_target</span><span class=\"w\"> </span><span class=\"bp\">=ₛ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Opens</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">guard_target</span><span class=\"w\"> </span><span class=\"bp\">=ₛ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 569975843,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1769368509
    },
    {
        "content": "<p>Here's a solution making use of Lean's ability to deal with ambiguous parsing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Sets</span><span class=\"bp\">.</span><span class=\"n\">Opens</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">instMembership</span>\n\n<span class=\"kn\">notation</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"s2\">\" ∈ \"</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Membership</span><span class=\"bp\">.</span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Opens</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- These two `#check` give the same output.</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Opens</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊔</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Though I don't know if it is a good idea to rely on this feature in such a way.</p>",
        "id": 569998300,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1769392305
    },
    {
        "content": "<p>I have created <a href=\"https://github.com/leanprover-community/mathlib4/pull/34473\">#34473</a>, where I implement the elaborator that we need, and I remove the instance <code>SetLike.instMembership</code>.</p>\n<p>The advantage is that now lots of rewrites become syntactic equalities, and so they can be removed. The problem is that now <code>simp</code> is seeing all of these coercions that it didn't see before, so <code>simp</code> is firing a lot more often. As a result lot's of proofs need to be fixed, possibly be removing <code>@[simp]</code> from lemmas about set coercions.</p>",
        "id": 570212519,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1769473163
    },
    {
        "content": "<p>It's not clear to me whether this is a net benefit; having two ways to spell this makes it very clear when we want to work in set land, and when we want to work in suboject land</p>",
        "id": 570216144,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769475571
    },
    {
        "content": "<p>I don't think what you describe is a benefit. I think that membership should coerce, just like function application does.</p>\n<p>However, I can imagine technical and performance issues getting in the way of this PR anyway.</p>",
        "id": 570216239,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769475638
    },
    {
        "content": "<p>So for function, we tend to do two things:</p>\n<ul>\n<li>Write a non-simp <code>coe</code> lemma (if this is <code>simp</code> then lemmas like <code>map_add</code> don't get a chance to apply)</li>\n<li>Write a <code>simp</code> <code>_apply</code> lemma</li>\n</ul>\n<p>If we copy this design (swapping <code>apply</code> for <code>mem</code>), we still have pretty much exactly the same lemma duplication as the one you wanted to avoid</p>",
        "id": 570216376,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769475737
    },
    {
        "content": "<p>I don't fully understand what you mean. Surely if we tag the <code>_apply</code> lemma with <code>@[simp]</code>, then <code>map_add</code> still doesn't get a chance to apply?</p>",
        "id": 570216739,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1769475989
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60SetLike.60.20membership.20-.20mass.20lemma.20duplication/near/570216376\">said</a>:</p>\n<blockquote>\n<p>So for function, we tend to do two things:</p>\n<ul>\n<li>Write a non-simp <code>coe</code> lemma (if this is <code>simp</code> then lemmas like <code>map_add</code> don't get a chance to apply)</li>\n<li>Write a <code>simp</code> <code>_apply</code> lemma</li>\n</ul>\n<p>If we copy this design (swapping <code>apply</code> for <code>mem</code>), we still have pretty much exactly the same lemma duplication as the one you wanted to avoid</p>\n</blockquote>\n<p>We frequently make the <code>coe</code> lemma <code>simp</code>, and then we don't duplicate! And importantly, we always have the option to! In the <code>SetLike</code> case, we don't have this option, leading to the duplication of thousands of lemmas.</p>",
        "id": 570218408,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1769477193
    },
    {
        "content": "<p>Jovan, my point was that we can't make the <code>coe</code> lemma simp if we want <code>map_add</code> to apply (and so instead make the <code>_apply</code> lemma simp, as you remark); but this is not what Artie is suggesting.</p>",
        "id": 570220542,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769478735
    },
    {
        "content": "<p>Can you give an explicit example where <code>simp</code> on <code>coe</code> would be bad but on <code>_apply</code> would be good w.r.t. <code>map_add</code>?</p>",
        "id": 570224386,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1769481326
    },
    {
        "content": "<p>I'm interested in an example too. IMHO, <code>-fullyApplied</code> should be the default for <code>simps</code>, but changing this default leads to lots of incompatibilities.</p>",
        "id": 570241328,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769494431
    }
]