[
    {
        "content": "<p>Is there any reason why Mathlib uses <code>I ⊔ J = ⊤</code> to say that ideals <code>I</code> and <code>J</code> are coprime instead of <code>I + K = 1</code>?</p>",
        "id": 393799669,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695932583
    },
    {
        "content": "<p>Are they defeq? :-)</p>",
        "id": 393799742,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695932618
    },
    {
        "content": "<p>No.</p>",
        "id": 393799750,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695932623
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">one_eq_top</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">Submodule.one_eq_range</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.range_id</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 393799839,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695932653
    },
    {
        "content": "<p>The sup equal add is rfl.</p>",
        "id": 393799867,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695932673
    },
    {
        "content": "<p>Oh didn't we have some <em>huuge</em> debate about the meaning of coprime in some arbitrary (abstract thing) at some point? Maybe that was the conclusion?</p>",
        "id": 393799886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695932682
    },
    {
        "content": "<p>The trouble comes from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.range_id#doc\">docs#LinearMap.range_id</a> which is not rfl.</p>",
        "id": 393800097,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695932796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/coprime.20ideal/near/393799886\">said</a>:</p>\n<blockquote>\n<p>Oh didn't we have some <em>huuge</em> debate about the meaning of coprime in some arbitrary (abstract thing) at some point? Maybe that was the conclusion?</p>\n</blockquote>\n<p>One such (naming) debate was around <a href=\"#narrow/stream/116395-maths/topic/IsCoprime.20is.20.40.5Bsimp.5D.3F/near/359101248\">this message</a>, but it seems nothing executive came out of that.</p>",
        "id": 393800216,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1695932864
    },
    {
        "content": "<p>I don't think that discussion is really relevant. I'm not talking about having a <code>coprime</code> definition, I'm talking about statements such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.quotientInfRingEquivPiQuotient#doc\">docs#Ideal.quotientInfRingEquivPiQuotient</a></p>",
        "id": 393800813,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695933117
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Codisjoint#doc\">docs#Codisjoint</a> would also work here I think (c.f <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=codisjoint_iff#doc\">docs#codisjoint_iff</a>)</p>",
        "id": 393817045,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695942096
    },
    {
        "content": "<p>Eric, this is precisely my point. The current writing is natural from an abstract lattice theory point of view, but not from an arithmetic point of view.</p>",
        "id": 393817407,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1695942358
    },
    {
        "content": "<p>Patrick, why do you say this? <br>\nThere are many places where such pairs of ideals are called “comaximal”. If that doesn't mean <code>sup(I,J)=top</code>, what else could it mean?<br>\nIn practice, it is often as easy to use comaximality this way than using the <code>+</code> definition and decompositions of 1 as a sum.</p>",
        "id": 394009792,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1696024618
    },
    {
        "content": "<p>If you want to use the semi-ring structure on ideals this is clearly the wrong formulation, but I can use it if you prefer it. It is only one rewrite away from the arithmetic formulation.</p>",
        "id": 394033871,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696040128
    },
    {
        "content": "<p>I'm confused, aren't the semiring and arithmetic structure one and the same? Or did you intend one of them to mean lattice?</p>",
        "id": 394060804,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696059504
    },
    {
        "content": "<p>Yes, but I don't see where I wrote something else.</p>",
        "id": 394087181,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696081927
    },
    {
        "content": "<p>I read your message as saying \"the semiring structure is clearly the wrong formulation\" and \"the semiring structure is only one rewrite away from the arithmetic one\".</p>",
        "id": 394091041,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696085175
    },
    {
        "content": "<p>I assume I must have read both parts incorrectly</p>",
        "id": 394091058,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696085211
    },
    {
        "content": "<p>I believe Patrick was saying \"If you want to use the semi-ring structure, <code>I ⊔ J = ⊤</code> is clearly the wrong formulation\" and \"<code>I ⊔ J = ⊤</code> is only one rewrite away from the arithmetic formulation\"</p>",
        "id": 394099764,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1696092880
    },
    {
        "content": "<p>Without entering the discussion about the correct definition, in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7466\">#7466</a>, we add <code>Ideal.isCoprime_iff_add</code>.</p>",
        "id": 394778907,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1696405526
    },
    {
        "content": "<p>Let me tag people that I know have worked on algebraic number theory  in mathlib <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span>, <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>, <span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span>, <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>. Do you mind if we settle this discussion by using <code>IsCoprime I J</code> everywhere and have lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">isCoprime_iff_codisjoint</span> <span class=\"o\">:</span> <span class=\"n\">IsCoprime</span> <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"bp\">↔</span> <span class=\"n\">Codisjoint</span> <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">IsCoprime</span><span class=\"o\">,</span> <span class=\"n\">codisjoint_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hxy</span><span class=\"o\">⟩</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_top_iff_one</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">J</span> <span class=\"bp\">≤</span> <span class=\"n\">I</span> <span class=\"bp\">⊔</span> <span class=\"n\">J</span> <span class=\"k\">from</span>\n      <span class=\"n\">sup_le</span> <span class=\"o\">(</span><span class=\"n\">mul_le_left.trans</span> <span class=\"n\">le_sup_left</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul_le_left.trans</span> <span class=\"n\">le_sup_right</span><span class=\"o\">))</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hxy</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">one_eq_top</span><span class=\"o\">,</span> <span class=\"n\">Submodule.mem_top</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">one_eq_top</span><span class=\"o\">,</span> <span class=\"n\">top_mul</span><span class=\"o\">,</span> <span class=\"n\">Submodule.add_eq_sup</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">isCoprime_iff_add</span> <span class=\"o\">:</span> <span class=\"n\">IsCoprime</span> <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"bp\">↔</span> <span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">J</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isCoprime_iff_codisjoint</span><span class=\"o\">,</span> <span class=\"n\">codisjoint_iff</span><span class=\"o\">,</span> <span class=\"n\">add_eq_sup</span><span class=\"o\">,</span> <span class=\"n\">one_eq_top</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">isCoprime_iff_exists</span> <span class=\"o\">:</span> <span class=\"n\">IsCoprime</span> <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">J</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">add_eq_one_iff</span><span class=\"o\">,</span> <span class=\"n\">isCoprime_iff_add</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">isCoprime_iff_sup_eq</span> <span class=\"o\">:</span> <span class=\"n\">IsCoprime</span> <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"bp\">↔</span> <span class=\"n\">I</span> <span class=\"bp\">⊔</span> <span class=\"n\">J</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isCoprime_iff_codisjoint</span><span class=\"o\">,</span> <span class=\"n\">codisjoint_iff</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>maybe even with aliases in the <code>IsCoprime</code> namespace for all the forward direction? This means changing quite a few statements in <code>RingTheorey.DedekindDomain.Ideal</code> for instance but of course these are tiny changes.</p>",
        "id": 395055642,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696515899
    },
    {
        "content": "<p>LGTM.</p>",
        "id": 395056019,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1696516027
    },
    {
        "content": "<p>I agree. Consistently using <code>IsCoprime</code> everywhere should end the discussion which formulation is best.</p>",
        "id": 395056832,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1696516293
    },
    {
        "content": "<p>Exactly, I think this is mathlib general philosophy: we don't worry about the actual definition, we just want a good API</p>",
        "id": 395057305,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1696516428
    },
    {
        "content": "<p>Certainly LGTM.</p>",
        "id": 395057790,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1696516567
    },
    {
        "content": "<p>That sounds like you want a TFAE statement</p>",
        "id": 395058225,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1696516706
    },
    {
        "content": "<p>TFAE look nice but they are a bit harder to use.</p>",
        "id": 395059551,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696517093
    },
    {
        "content": "<p>I opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/7523\">#7523</a>. It needs to wait for CI since I didn't build locally</p>",
        "id": 395059834,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696517169
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/287929-mathlib4/topic/coprime.20ideal/near/395059551\">said</a>:</p>\n<blockquote>\n<p>TFAE look nice but they are a bit harder to use.</p>\n</blockquote>\n<p>Oh I mean on top of your statements, not instead.</p>",
        "id": 395060963,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1696517523
    },
    {
        "content": "<p>Given <code>P : Prop</code>, how do you prove <code>TFAE [P, P, P, P, P]</code>? I was hoping <code>simp</code> would do it...</p>",
        "id": 395063698,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696518371
    },
    {
        "content": "<p>Do we not have the fact that <code>TFAE L</code> is equivalent to <code>TFAE L.dedup</code>? We probably should.</p>",
        "id": 395064128,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1696518503
    },
    {
        "content": "<p>although maybe that's not useful because <code>Prop</code> doesn't have decidable equality.</p>",
        "id": 395064302,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1696518558
    },
    {
        "content": "<p><del>wait, maybe it does?</del></p>",
        "id": 395064437,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1696518599
    },
    {
        "content": "<p>Well, at least <code>simp</code> does reduce <code>[P, P, P].dedup</code> to <code>[P]</code>.</p>",
        "id": 395064770,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1696518694
    },
    {
        "content": "<p>I mean <code>P</code> literally appear five times, syntactically.</p>",
        "id": 395065304,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696518852
    },
    {
        "content": "<p>How do you manage to call <code>dedup</code> on a list of Prop?</p>",
        "id": 395065749,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696518983
    },
    {
        "content": "<p>yeah I understand, that's why I think adding a lemma <code>foo : L.TFAE \\iff L.dedup.TFAE</code> would let you prove your statement with <code>simp [foo]</code>.</p>",
        "id": 395065768,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1696518988
    },
    {
        "content": "<p>Should <code>tfae_finish</code> maybe  just handle syntactic equivalent statements?</p>",
        "id": 395066217,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696519126
    },
    {
        "content": "<p>oh yeah, that's probably a better approach!</p>",
        "id": 395066268,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1696519144
    },
    {
        "content": "<p><code>simp [List.tfae_cons_cons, List.tfae_singleton]</code> works around it for now if you just want something fast</p>",
        "id": 395066306,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1696519154
    },
    {
        "content": "<p>although that would be a significant refactor of <code>tfae_finish</code>, I think!</p>",
        "id": 395066327,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1696519159
    },
    {
        "content": "<p>I ended up with tagging <code>List.tfae_singleton</code> with simp and adding</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">tfae_cons_self</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">TFAE</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">TFAE</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">tfae_cons_cons</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 395066538,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696519219
    },
    {
        "content": "<p>Really? Wouldn’t just</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">dfs</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">P'</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Prop</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">P</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">StateT</span> <span class=\"o\">(</span><span class=\"n\">HashSet</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">MetaM</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">P'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">==</span> <span class=\"n\">j</span> <span class=\"k\">then</span>\n    <span class=\"n\">return</span> <span class=\"n\">hP</span>\n</code></pre></div>\n<p>have to add a case for <code>i</code> not equal to <code>j</code>, but the <code>atoms</code> being defEq?</p>",
        "id": 395066686,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696519271
    },
    {
        "content": "<p>I don't want to mix meta-code with an otherwise trivial algebra PR, put feel free to fix this in a later PR.</p>",
        "id": 395067090,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696519401
    },
    {
        "content": "<p>Actually, reading through the code, it’s using <code>AtomM</code> to collect and number the propositions, shouldn’t that deduplicate the atoms in the list? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>      <span class=\"k\">let</span> <span class=\"n\">is</span> <span class=\"bp\">←</span> <span class=\"n\">tfaeList.mapM</span> <span class=\"n\">AtomM.addAtom</span>\n</code></pre></div>",
        "id": 395068769,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696519865
    },
    {
        "content": "<p>Indeed, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.TFAE</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">false</span>\n<span class=\"kn\">open</span> <span class=\"n\">List</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TFAE</span> <span class=\"o\">[</span><span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">tfae_finish</span>\n</code></pre></div>",
        "id": 395068784,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696519871
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> , did you try <code>tfae_finish</code>? :-)</p>",
        "id": 395069046,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696519949
    },
    {
        "content": "<p>It looks like I didn't...</p>",
        "id": 395069097,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696519967
    },
    {
        "content": "<p>(Completely unrelated, how can anyone write any code with <code>autoImplicit true</code>? So many typos or unopened namespaces not leading to errors, but weird <code>sorryAx</code> in the goal state… Not expecting a response, just ranting :-))</p>",
        "id": 395069519,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696520095
    },
    {
        "content": "<p>I have a much more serious mystery to solve. The indentation style linter says:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Error</span><span class=\"o\">:</span> <span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">RingTheory</span><span class=\"bp\">/</span><span class=\"n\">Ideal</span><span class=\"bp\">/</span><span class=\"n\">Operations.lean</span><span class=\"bp\">#</span><span class=\"n\">L855</span><span class=\"o\">:</span> <span class=\"n\">ERR_IND</span><span class=\"o\">:</span> <span class=\"n\">If</span> <span class=\"n\">the</span> <span class=\"kd\">theorem</span><span class=\"bp\">/</span><span class=\"kd\">def</span> <span class=\"n\">statement</span> <span class=\"n\">requires</span> <span class=\"n\">multiple</span> <span class=\"n\">lines</span><span class=\"o\">,</span> <span class=\"n\">indent</span> <span class=\"n\">it</span> <span class=\"n\">correctly</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"n\">spaces</span> <span class=\"n\">or</span> <span class=\"mi\">2</span> <span class=\"n\">for</span> <span class=\"bp\">`|`</span><span class=\"o\">)</span>\n<span class=\"n\">Error</span><span class=\"o\">:</span> <span class=\"n\">Process</span> <span class=\"n\">completed</span> <span class=\"k\">with</span> <span class=\"n\">exit</span> <span class=\"n\">code</span> <span class=\"mi\">123</span><span class=\"bp\">.</span>\n</code></pre></div>",
        "id": 395071873,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696520820
    },
    {
        "content": "<p>about <a href=\"https://github.com/leanprover-community/mathlib4/pull/7523/files#diff-cd0998115e627d03a50bc6846968ec95f9f85d137e3e89c92eb09a7a95aed7b9R853-R857\">https://github.com/leanprover-community/mathlib4/pull/7523/files#diff-cd0998115e627d03a50bc6846968ec95f9f85d137e3e89c92eb09a7a95aed7b9R853-R857</a></p>",
        "id": 395071990,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696520864
    },
    {
        "content": "<p>The reviewbot comment suggests the linter was complaining about a previous version (<code>0f38c80</code>)</p>",
        "id": 395072552,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1696521049
    },
    {
        "content": "<p>Oh, GitHub has been very confusing then.</p>",
        "id": 395072960,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696521208
    },
    {
        "content": "<p>Sorry about the noise.</p>",
        "id": 395072973,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696521213
    },
    {
        "content": "<p>CI is indeed happy now. This is ready for an easy review.</p>",
        "id": 395085933,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696525588
    },
    {
        "content": "<p>Thanks Johan. I can now proceed with the actual motivation for this discussion which was to refactor our Chinese remainder theorem proof. Recall I was looking for nice challenges for GlimpseOfLean during the spring and thought proving the Chinese remainder theorem would make a nice exercice about rings, but I was a bit shocked to discover our proof in Mathlib. In particular surjectivity used the following single-use ad-hoc lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">exists_sub_one_mem_and_mem</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">⊔</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">his</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"bp\">≠</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"bp\">≠</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">j</span> <span class=\"n\">hjs</span> <span class=\"n\">hji</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">hf</span> <span class=\"n\">i</span> <span class=\"n\">his</span> <span class=\"n\">j</span> <span class=\"n\">hjs</span> <span class=\"n\">hji.symm</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_top_iff_one</span><span class=\"o\">,</span> <span class=\"n\">Submodule.mem_sup</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hf</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">hri</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hsj</span><span class=\"o\">,</span> <span class=\"n\">hrs</span><span class=\"o\">⟩</span>\n    <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sub_right_comm</span><span class=\"o\">,</span> <span class=\"n\">sub_self</span><span class=\"o\">,</span> <span class=\"n\">zero_sub</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">neg_mem</span> <span class=\"n\">hri</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hrs</span><span class=\"o\">,</span> <span class=\"n\">add_sub_cancel'</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hsj</span>\n  <span class=\"n\">classical</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">j</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"bp\">≠</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">choose</span> <span class=\"n\">g</span> <span class=\"n\">hg1</span> <span class=\"n\">hg2</span> <span class=\"n\">using</span> <span class=\"n\">this</span>\n      <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">j</span> <span class=\"bp\">≠</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"n\">g</span> <span class=\"n\">j</span> <span class=\"n\">H.1</span> <span class=\"n\">H.2</span> <span class=\"k\">else</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n      <span class=\"bp\">·</span> <span class=\"n\">dsimp</span> <span class=\"n\">only</span>\n        <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">h</span>\n        <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">hg1</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sub_self</span><span class=\"o\">]</span>\n        <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">zero_mem</span>\n      <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hjs</span> <span class=\"n\">hji</span>\n        <span class=\"n\">dsimp</span> <span class=\"n\">only</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">dif_pos</span><span class=\"o\">]</span>\n        <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">hg2</span>\n        <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">hjs</span><span class=\"o\">,</span> <span class=\"n\">hji</span><span class=\"o\">⟩</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hgi</span><span class=\"o\">,</span> <span class=\"n\">hgj</span><span class=\"o\">⟩</span>\n    <span class=\"n\">use</span> <span class=\"bp\">∏</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">s.erase</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">x</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Ideal.Quotient.mk_eq_mk_iff_sub_mem</span><span class=\"o\">,</span> <span class=\"n\">map_one</span><span class=\"o\">,</span> <span class=\"n\">map_prod</span><span class=\"o\">]</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Finset.prod_eq_one</span>\n      <span class=\"n\">intros</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">RingHom.map_one</span><span class=\"o\">,</span> <span class=\"n\">Ideal.Quotient.mk_eq_mk_iff_sub_mem</span><span class=\"o\">]</span>\n      <span class=\"n\">apply</span> <span class=\"n\">hgi</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">j</span> <span class=\"n\">hjs</span> <span class=\"n\">hji</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Quotient.eq_zero_iff_mem</span><span class=\"o\">,</span> <span class=\"n\">map_prod</span><span class=\"o\">]</span>\n      <span class=\"n\">refine'</span> <span class=\"n\">Finset.prod_eq_zero</span> <span class=\"o\">(</span><span class=\"n\">Finset.mem_erase_of_ne_of_mem</span> <span class=\"n\">hji</span> <span class=\"n\">hjs</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Quotient.eq_zero_iff_mem</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hgj</span> <span class=\"n\">j</span> <span class=\"n\">hjs</span> <span class=\"n\">hji</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">ideal.exists_sub_one_mem_and_mem</span> <span class=\"n\">Ideal.exists_sub_one_mem_and_mem</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_sub_mem</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">⊔</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">-</span> <span class=\"n\">g</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">nonempty_fintype</span> <span class=\"n\">ι</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">exists_sub_one_mem_and_mem</span> <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">_</span> <span class=\"n\">j</span> <span class=\"n\">_</span> <span class=\"n\">hij</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">hf</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">hij</span>\n    <span class=\"n\">choose</span> <span class=\"n\">φ</span> <span class=\"n\">hφ</span> <span class=\"n\">using</span> <span class=\"n\">this</span>\n    <span class=\"n\">exists</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">Finset.mem_univ</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"n\">i</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">hij</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"n\">i</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">j</span> <span class=\"o\">(</span><span class=\"n\">Finset.mem_univ</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">hij.symm</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">hφ1</span><span class=\"o\">,</span> <span class=\"n\">hφ2</span><span class=\"o\">⟩</span>\n  <span class=\"n\">use</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">φ</span> <span class=\"n\">i</span>\n  <span class=\"n\">intro</span> <span class=\"n\">i</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Quotient.mk_eq_mk_iff_sub_mem</span><span class=\"o\">,</span> <span class=\"n\">map_sum</span><span class=\"o\">]</span>\n  <span class=\"n\">refine'</span> <span class=\"n\">Eq.trans</span> <span class=\"o\">(</span><span class=\"n\">Finset.sum_eq_single</span> <span class=\"n\">i</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">j</span> <span class=\"n\">_</span> <span class=\"n\">hji</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Quotient.eq_zero_iff_mem</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mul_mem_left</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">hφ2</span> <span class=\"n\">j</span> <span class=\"n\">i</span> <span class=\"n\">hji</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hi</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Finset.mem_univ</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hφ1</span> <span class=\"n\">i</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Quotient.mk_eq_mk_iff_sub_mem</span><span class=\"o\">,</span> <span class=\"n\">RingHom.map_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hφ1</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">RingHom.map_mul</span><span class=\"o\">,</span> <span class=\"n\">hφ1</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">ideal.exists_sub_mem</span> <span class=\"n\">Ideal.exists_sub_mem</span>\n</code></pre></div>\n<p>that I propose to replace with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">coprime_iInf_of_coprime</span> <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">IsCoprime</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">IsCoprime</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"bp\">⨅</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">J</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">isCoprime_iff_add</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">revert</span> <span class=\"n\">hf</span>\n  <span class=\"n\">induction</span> <span class=\"n\">s</span> <span class=\"n\">using</span> <span class=\"n\">Finset.induction</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">empty</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">insert</span> <span class=\"n\">i</span> <span class=\"n\">s</span> <span class=\"n\">_</span> <span class=\"n\">hs</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">intro</span> <span class=\"n\">h</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.iInf_insert</span><span class=\"o\">,</span> <span class=\"n\">inf_comm</span><span class=\"o\">,</span> <span class=\"n\">one_eq_top</span><span class=\"o\">,</span> <span class=\"n\">eq_top_iff</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">one_eq_top</span><span class=\"o\">]</span>\n      <span class=\"n\">set</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"bp\">⨅</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">J</span> <span class=\"n\">j</span>\n      <span class=\"k\">calc</span>\n        <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">K</span>            <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"n\">hj</span> <span class=\"bp\">↦</span> <span class=\"n\">h</span> <span class=\"n\">j</span> <span class=\"o\">(</span><span class=\"n\">Finset.mem_insert_of_mem</span> <span class=\"n\">hj</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n        <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">K</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">J</span> <span class=\"n\">i</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">Finset.mem_insert_self</span> <span class=\"n\">i</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span>\n        <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">K</span><span class=\"bp\">*</span><span class=\"n\">J</span> <span class=\"n\">i</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ring</span>\n        <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">K</span> <span class=\"bp\">⊓</span> <span class=\"n\">J</span> <span class=\"n\">i</span>      <span class=\"o\">:=</span> <span class=\"n\">add_le_add</span> <span class=\"n\">mul_le_left</span> <span class=\"n\">mul_le_inf</span>\n</code></pre></div>",
        "id": 395113288,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696537242
    },
    {
        "content": "<p>The only \"downside\" is that it requires moving this theorem one file later, in the file importing both quotients and ideal operations.</p>",
        "id": 395113502,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696537348
    },
    {
        "content": "<p>This is <a href=\"https://github.com/leanprover-community/mathlib4/pull/7532\">#7532</a>.</p>",
        "id": 395113639,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696537430
    },
    {
        "content": "<p>The injectivity proof is also modified, following the paper proof saying the kernel is obviously what it is.</p>",
        "id": 395113743,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696537465
    },
    {
        "content": "<p>using the previously missing lemma</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">_root_.Pi.ker_ringHom</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Semiring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n    <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">S</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ker</span> <span class=\"o\">(</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">ringHom</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⨅</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">ker</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mem_ker</span><span class=\"o\">,</span> <span class=\"n\">Ideal.mem_iInf</span><span class=\"o\">,</span> <span class=\"n\">Function.funext_iff</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 395113801,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696537501
    },
    {
        "content": "<p>I believe that <code>IsCoprime</code> should be named <code>IsComaximal</code>.</p>",
        "id": 395118761,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1696539872
    },
    {
        "content": "<p>Even for integers?</p>",
        "id": 395118825,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1696539908
    },
    {
        "content": "<p>That's a general definition for ideals in a ring.</p>",
        "id": 395121089,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1696541122
    },
    {
        "content": "<p>What is?</p>",
        "id": 395123697,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1696542529
    },
    {
        "content": "<p>I think <code>IsComaximal</code> (in the lattice interpretation) is precisely what <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Codisjoint#doc\">docs#Codisjoint</a> is intended to mean?</p>",
        "id": 395125611,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696543579
    },
    {
        "content": "<p>Maybe <code>Codisjoint</code> should be renamed to <code>Comaximal</code>? I think the <code>Is</code> prefix is fine, but we shouldn't add it unless we also add it to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Disjoint#doc\">docs#Disjoint</a>.</p>",
        "id": 395125656,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696543628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/287929-mathlib4/topic/coprime.20ideal/near/395123697\">said</a>:</p>\n<blockquote>\n<p>What is?</p>\n</blockquote>\n<p>That their sum (or their sup, it's the same) is the unit ideal.</p>",
        "id": 395173432,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1696569032
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/287929-mathlib4/topic/coprime.20ideal/near/395118761\">said</a>:</p>\n<blockquote>\n<p>I believe that <code>IsCoprime</code> should be named <code>IsComaximal</code>.</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCoprime#doc\">docs#IsCoprime</a> is a statement about two elements in a <code>CommSemiring</code>, so it is the one we use two say that <code>(2 : ℤ)</code> and <code>(3 : ℤ)</code> are coprime. It would be quite weird to say that they are comaximal... but we can add an alias for ideals.</p>",
        "id": 395197549,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1696577693
    },
    {
        "content": "<p>There's another interpretation of coprime in a UFD which is weaker (and makes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> coprime in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\R[X,Y]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">]</span></span></span></span>), but IIRC we have already had a lengthy discussion on this.</p>",
        "id": 395201152,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696579116
    }
]