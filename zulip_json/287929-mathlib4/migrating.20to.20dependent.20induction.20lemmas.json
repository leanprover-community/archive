[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Linear.20algebra.20in.20MIL/near/473134428\">said</a>:</p>\n<blockquote>\n<p>Sure. But there is no point saying <code>apply</code> is bad and <code>induction</code> should be used if <code>induction</code> fails just as much. That’s why I stuck to <code>apply</code> which is simpler.</p>\n</blockquote>\n<p>The above is from another thread. I've decided to finally fix this problem by migrating the existing <code>foo_induction</code> lemmas to their dependent counterparts so that they work correctly with the <code>induction</code> tactic.</p>\n<p>I've started on this in <a href=\"https://github.com/leanprover-community/mathlib4/pull/17543\">#17543</a>. However, before I continue by fixing the fallout and migrating similar lemmas, I would like some feedback. In particular are you happy with the way I've changed the <code>Subsemigroup</code> and <code>Submonoid</code> lemmas (note some changes to: argument order / implicitness / argument names)? I've checked that these all work correctly with the induction tactic.</p>\n<p>When proving, e.g., <code>closure_induction₂</code>, do we prefer the compact <code>refine</code> style, or the structured <code>induction</code> version (the latter is included as a comment in the code)? Please let me know your thoughts at least <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> , <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> and <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> .</p>",
        "id": 475601928,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1728402655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/migrating.20to.20dependent.20induction.20lemmas/near/475601928\">said</a>:</p>\n<blockquote>\n<p>When proving, e.g., <code>closure_induction₂</code>, do we prefer the compact <code>refine</code> style, or the structured <code>induction</code> version (the latter is included as a comment in the code)?</p>\n</blockquote>\n<p>I think standard golfing rules apply  (\"author's choice\") for lemmas like this one. I'd maybe argue that <code>closure_induction₂</code> shouldn't exist at all, since it really is just two inductions in the obvious way.</p>",
        "id": 475603351,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728403046
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/migrating.20to.20dependent.20induction.20lemmas/near/475603351\">said</a>:</p>\n<blockquote>\n<p>I'd maybe argue that <code>closure_induction₂</code> shouldn't exist at all, since it really is just two inductions in the obvious way.</p>\n</blockquote>\n<p>if you're in a situation where you need to do it enough times, you might change your mind <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 475603696,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1728403127
    },
    {
        "content": "<p>Thanks Jireh! I like the structured versions.</p>",
        "id": 475611140,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1728404800
    },
    {
        "content": "<p>Ready for review at <a href=\"https://github.com/leanprover-community/mathlib4/pull/17543\">#17543</a>. I tried to keep the diff small (still 800 lines!) unless the structured versions provided more clarity.</p>",
        "id": 475931038,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1728498588
    },
    {
        "content": "<p>On the PR <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> suggests that we should keep the non-dependent versions around for two reasons:</p>\n<ol>\n<li>to avoid need to give Lean the motive explicitly when proving a non-dependent version.</li>\n<li>to avoid superfluous underscores which are just noise.</li>\n</ol>\n<p>It seems that (1) is not really an issue (that is, there was essentially only one place this needed to occur, and it was actually reasonable). For (2), I considered making the dependent hypotheses implicit. That is, in the statement of, for example <code>Submonoid.closure_induction</code>, the <code>mul</code> hypothesis would look like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">closure_induction</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">subset_closure</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">one_mem</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">hx</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">hy</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mul_mem</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This would work reasonably well to avoid underscores when these arguments are superfluous, and it would greatly reduce the diff on this PR.</p>\n<p><strong>However</strong>, it seems there is one major drawback, and it has to do with the <code>induction</code> tactic itself. When you call the above lemma with induction, for example, to prove:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">dense_induction</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">mem_top</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">closure_induction</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">one</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">ihx</span><span class=\"w\"> </span><span class=\"n\">ihy</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">ihx</span><span class=\"w\"> </span><span class=\"n\">ihy</span>\n</code></pre></div>\n<p>if you <em>did</em> (in the <code>mul</code> arm) for some reason want to access the hypotheses <code>hx✝ : x ∈ Submonoid.closure s</code> and <code>hy✝ : y ∈ Submonoid.closure s</code>, you would have to use <code>rename_i</code> (gross), as the syntax</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">ihx</span><span class=\"w\"> </span><span class=\"n\">ihy</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>doesn't work. <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I'm interested in your thoughts here too.</p>",
        "id": 476169422,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1728576376
    },
    {
        "content": "<p>Hmm I'm not sure it's worth it - in the cases that you do want access to those parts, this is super unpleasant...</p>",
        "id": 476170140,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1728576546
    },
    {
        "content": "<p>I know, but I'm more wondering if we should ask core to change the <code>induction</code> tactic to allow for this. It would be nice if it didn't introduce all the variables as shadowed if you don't provide them anyway. I think there are a few rough edges around the <code>induction</code> tactic still.</p>",
        "id": 476171164,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1728576793
    },
    {
        "content": "<p>(probably the same also applies to <code>cases</code>, but I haven't checked yet.)</p>",
        "id": 476171340,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1728576821
    },
    {
        "content": "<p><span aria-label=\"idea\" class=\"emoji emoji-1f4a1\" role=\"img\" title=\"idea\">:idea:</span> I just found out about this syntax which allows access to naming implicit variables.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"n\">ihxy</span><span class=\"w\"> </span><span class=\"n\">ihy</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 476204522,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1728587129
    },
    {
        "content": "<p>Unfortunately, it doesn't work to prevent the introduction of the induction hypotheses via <code>@mul =&gt; sorry</code>, which is too bad.</p>",
        "id": 476204778,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1728587197
    }
]