[
    {
        "content": "<p>Right now there are:</p>\n<ul>\n<li><code>Finite</code> which says, without data, that a type is finite</li>\n<li><code>Fintype</code> which includes the data enumerating the type</li>\n<li><code>Infinite</code> which says, without data, that a type is not finite</li>\n<li><code>Countable</code> which says, without data, that a type is countable (but could be finite)</li>\n<li><code>Uncountable</code> which says it's not</li>\n<li><code>Encodable</code> which gives the data for <code>Countable</code></li>\n<li><code>Denumerable</code> which means that the <code>Encodable</code> listing is surjective and it's countable</li>\n</ul>\n<p>but what feels obviously missing to me is the equivalent of <code>Fintype</code> for an infinite type: just the fact that you have some injective function <code>ℕ → α</code>, so a way to produce infinitely many objects of the type. Basically: this is the data witnessing the infiniteness of the type.</p>\n<p>There's some analogy that this <code>Infintype</code> is to <code>Infinite</code> what <code>Fintype</code> is to <code>Finite</code>. An <code>Infintype</code> instance can provide an <code>Infinite</code> instance, and in the flipped direction you can always get an <code>Infintype</code> instance nonconstructively from an <code>Infinite</code> proof.</p>\n<p>I claim nearly all <code>Infinite</code> instances in Mathlib actually can be lifted to <code>Infintype</code> instances, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Fintype/EquivFin.html#Sum.infinite_of_left\">Sum.infinite_of_left</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Fintype/EquivFin.html#Infinite.sigma_of_right\">Infinite.sigma_of_right</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Finite/Basic.html#Set.infinite_univ\">Set.infinite_univ</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Finite/Basic.html#Set.Finite.infinite_compl\">Set.Finite.infinite_compl</a> (that one would need a <code>DecidablePred s</code> to be computable) etc. etc.</p>\n<p>It would fit in with the other ones: <del>right now there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Denumerable.html#nonempty_denumerable\">nonempty_denumerable</a> which lets you nonconstructively get <code>Denumerable</code> from <code>Countable</code> and <code>Infinite</code>. <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Denumerable.html#Denumerable.ofEncodableOfInfinite\">Denumerable.ofEncodableOfInfinite</a> says that if the first one has data (replace <code>Countable</code> with <code>Encodable</code>) then you can do it constructively. But we could also have <code>Denumerable</code> from <code>Countable</code> and <code>Infintype</code>, so, using the data of the second one.</del> Scratch that, that doesn't work. What I meant is that you can get <code>Infintype</code> from <code>Encodable</code> and <code>Infinite</code>, </p>\n<p>Would this, generally, be welcome?</p>",
        "id": 519469902,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1747773342
    },
    {
        "content": "<p>It's not clear to me that having a constructive version of infiniteness would be useful for mathlib: all the other constructive ones you mention have some value (eg <code>Fintype</code> makes <code>decide</code> work better for proving easy properties by enumeration and makes tactics like <code>fin_cases</code> work). But I'm not currently seeing any real use-cases for <code>Infintype</code></p>",
        "id": 519470425,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1747773579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Infintype.60.3F/near/519469902\">said</a>:</p>\n<blockquote>\n<p>just the fact that you have some injective function <code>ℕ → α</code>, so a way to produce infinitely many objects of the type</p>\n</blockquote>\n<p>Isn't this exactly <code>Encodable</code>?</p>",
        "id": 519471615,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1747774035
    },
    {
        "content": "<p>No, the Reals could also be <code>Infintype</code>, the function isn't necessarily surjective. You just get some infinite stream of fresh examples</p>",
        "id": 519471993,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1747774184
    },
    {
        "content": "<p>So you're looking for a typeclass version of <code>ℕ ↪ α</code>?</p>",
        "id": 519472192,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1747774268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Infintype.60.3F/near/519470425\">said</a>:</p>\n<blockquote>\n<p>It's not clear to me that having a constructive version of infiniteness would be useful for mathlib: all the other constructive ones you mention have some value (eg <code>Fintype</code> makes <code>decide</code> work better for proving easy properties by enumeration and makes tactics like <code>fin_cases</code> work). But I'm not currently seeing any real use-cases for <code>Infintype</code></p>\n</blockquote>\n<p>The main I think of would be (admittedly epsilon-external to Mathlib) a <code>Plausible</code>-style generator of instances of a thing: give me a stream of instances of this thing, and then I will verify my claim on each thing I get, hopefully up to some large limit and I can start to check if it seems true.</p>\n<p><code>Encodable</code> works fine for this purpose for countably-sized things, but if you want to generate some stream of examples from what is possibly an uncountable type, it would be good to have</p>",
        "id": 519472492,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1747774389
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Infintype.60.3F/near/519472192\">said</a>:</p>\n<blockquote>\n<p>So you're looking for a typeclass version of <code>ℕ ↪ α</code>?</p>\n</blockquote>\n<p>Yes, I suppose so, in the same way that <code>Encodable</code> is a surjection from ℕ and <code>Denumerable</code> is a bijection.</p>",
        "id": 519473035,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1747774625
    },
    {
        "content": "<p>This isn't really related, but in my first message I listed most of the \"cardinality\" typeclasses, so just to scratch my own itch, here are (I think) the rest of them:</p>\n<ul>\n<li><code>IsEmpty</code>: cardinality less than one</li>\n<li><code>Nonempty</code>: cardinality at least one</li>\n<li><code>Inhabited</code> - same as<code>Nonempty</code> but with data</li>\n<li><code>Subsingleton</code> - cardinality at most one</li>\n<li><code>Unique</code> - cardinality exactly one, with data (no version of this without data)</li>\n<li><code>Nontrivial</code> - cardinality greater than one (no version of this with data)</li>\n<li><code>FinEnum</code> - logically and computationally equivalent(?) to <code>Fintype</code>, but different</li>\n</ul>\n<p>... although, there is a version of <code>Nontrivial</code> definitely used in practice plenty, which is <code>[Zero] + [One] + [NeZero 1]</code> :)</p>",
        "id": 519477078,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1747776393
    },
    {
        "content": "<p>I think <code>Nonempty + Subsingleton</code> is the version of <code>Unique</code> without data</p>",
        "id": 519477555,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1747776612
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Infintype.60.3F/near/519471993\">said</a>:</p>\n<blockquote>\n<p>You just get some infinite stream of fresh examples</p>\n</blockquote>\n<p>Which one? Arguably typeclasses are supposed to be canonical, but what's <strong>the</strong> canonical stream of examples of real numbers?</p>",
        "id": 519487151,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1747781873
    },
    {
        "content": "<p>Hold on... The only requirement is that you're only supposed to have defined one instance for any given set of arguments.</p>\n<p>This \"typeclasses are supposed to be canonical\" argument would say that Inhabited, FinEnum, Encodable, etc. \"shouldn't\" be typeclasses, unless I'm misunderstanding what you're getting at <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>.</p>",
        "id": 519487938,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747782308
    },
    {
        "content": "<p>My claim is that those types are used when people would generally agree on the canonical default / enumeration order</p>",
        "id": 519488007,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1747782355
    },
    {
        "content": "<p>Or at least, if you polled a room full of people about what the instance is, hopefully it should be the choice of a plurality or agreement by consensus</p>",
        "id": 519488082,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1747782379
    },
    {
        "content": "<p>What would the enumeration order for</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>be? Should that not be <code>Encodable</code>?</p>",
        "id": 519488125,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747782410
    },
    {
        "content": "<p>There's \"canonical to mathematicians\" and \"actually singleton\" or whatever</p>\n<p>I guess the biggest non-example in Mathlib would be normed spaces, there's enough competing operator norms (and operator topologies) that there's no public instance, just many scoped instances</p>",
        "id": 519488193,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1747782461
    },
    {
        "content": "<p>I think in the case of inductive types you can probably globally document what <code>deriving</code> does or should do, and declare that canonical</p>",
        "id": 519488283,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1747782497
    },
    {
        "content": "<p>The thing I worry most about with <code>Infintype</code> is that it's hard to make sure you write an instance that gives \"representative\" data. I'd guess I'd want something with an image that's dense in R for example, but even then it might not be representative enough.</p>",
        "id": 519488304,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747782508
    },
    {
        "content": "<p>The reals are, I guess, a bit pathological since there's no actually <em>no</em> predicate you can compute on them, ever. (Besides the trivial true/false ones)</p>",
        "id": 519488394,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1747782579
    },
    {
        "content": "<blockquote>\n<p>The main I think of would be (admittedly epsilon-external to Mathlib) a <code>Plausible</code>-style generator of instances of a thing: give me a stream of instances of this thing, and then I will verify my claim on each thing I get, hopefully up to some large limit and I can start to check if it seems true.</p>\n</blockquote>\n<p>Just to check: in this strategy do you need things to be decidable / kernel-reducible like plausible does?</p>",
        "id": 519488502,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1747782631
    },
    {
        "content": "<p>Otherwise I'm not sure what you're going to do with <code>theorem foo : P (sample 37 : Real)</code>, unless you have some closed form expression to expand <code>sample</code> into.</p>",
        "id": 519488564,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1747782688
    },
    {
        "content": "<p>I don't know! Probably. I don't know the details of plausible that much. This idea kind of came to me as spotting a \"lexical gap\" in the current instances and this was the most obvious application</p>",
        "id": 519488597,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1747782712
    },
    {
        "content": "<p>Plausible current works by computing the samples in the interpreter then converting them to <code>Expr</code>, which  makes a bunch of types unsampleable. It should either sample exprs directly, or somehow unfold a sampling function like <code>fin_cases</code> does</p>",
        "id": 519488736,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1747782805
    },
    {
        "content": "<p>Yeah, so reals are kind of silly in that sense. So maybe a more interesting case: functions <code>Nat -&gt; Nat</code>. You could imagine a <em>boring</em> generator that just gives each constant function, but I'd hope for \"more interesting\" ones</p>",
        "id": 519488737,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1747782805
    }
]