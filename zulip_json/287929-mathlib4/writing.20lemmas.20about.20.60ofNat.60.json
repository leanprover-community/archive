[
    {
        "content": "<p>This is probably an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>, but I would like to know how to do this anyway: Given a ring <code>R</code>, both <code>(37 : R)</code> and <code>((37 : ℕ) : R)</code> make sense, where the former is elaborated as <code>@OfNat.ofNat R 37 _</code> and the latter is elaborated as <code>Nat.cast (@OFNat.ofNat ℕ 37 _)</code> with the <code>37</code>s here being nat literals (I think, my understanding is weak here). My question is, how do I write the following lemma correctly? I'm just wondering about the statement, not the proof. Also, I know it holds in more generality for <code>SubsemiringClass</code>, but let's ignore that for now.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ofNat_mem</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Subring</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">n.AtLeastTwo</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I want this to be able to prove that <code>5 ∈ S</code> where the <code>5</code> is the <code>OfNat</code> for <code>R</code> coming from the <code>AddMonoidWithOne</code> instance.</p>",
        "id": 389953047,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694208848
    },
    {
        "content": "<p>Did you try that? It seems like it would work</p>",
        "id": 389953302,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694209017
    },
    {
        "content": "<p>Oh it elaborates just fine, but I thought I was getting a double-wrapping of <code>OfNat.ofNat</code>, maybe not though. Perhaps my problems lie elsewhere.</p>",
        "id": 389953363,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694209067
    },
    {
        "content": "<p>no I mean try applying it to <code>5 \\in S</code></p>",
        "id": 389953435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694209086
    },
    {
        "content": "<p>in the lemma itself there is nothing to double wrap as there is a variable instead of a numeral</p>",
        "id": 389953468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694209118
    },
    {
        "content": "<p>oh, I see. Yes, it does work to prove that, but <code>aesop</code> doesn't like to apply it for some reason (like I said, probably an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>). <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> I'll write the example in a minute, but I have to leave in about 5, so I won't see the reply.</p>",
        "id": 389953551,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694209185
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">@[aesop safe apply]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ofNat_mem</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Subring</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">n.AtLeastTwo</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">OfNat.ofNat</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">Nat.cast_eq_ofNat</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">natCast_mem</span> <span class=\"n\">S</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Subring</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">5</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">ofNat_mem</span> <span class=\"n\">S</span> <span class=\"mi\">5</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Subring</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">5</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 389953797,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694209335
    },
    {
        "content": "<p>Looks like a bug somewhere. Aesop's indexing doesn't realise that <code>ofNat_mem</code> could be applicable to the target <code>5 ∈ S</code>. I suspect that the numeric literal is to blame somehow.</p>",
        "id": 389954935,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1694210059
    },
    {
        "content": "<p>I can confirm that this works, so it indeed seems to be numeric literals that are the problem.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Subring</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">n.AtLeastTwo</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span> <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 389970480,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694220897
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> any idea how to fix this issue?</p>",
        "id": 390380893,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694463139
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[aesop safe apply]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ofNat_mem</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Subring</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">n.AtLeastTwo</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">no_index</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">Nat.cast_eq_ofNat</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">natCast_mem</span> <span class=\"n\">S</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>works</p>",
        "id": 390381285,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1694463311
    },
    {
        "content": "<p>What does <code>no_index</code> do?</p>",
        "id": 390383567,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1694464237
    },
    {
        "content": "<p>I think it allows matching up to defeq, rather than syntactically</p>",
        "id": 390384698,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694464757
    },
    {
        "content": "<p>Though I don't know what the defeq would be</p>",
        "id": 390384720,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694464769
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Polynomial.2Ecoeff.20example/near/395337657\">said</a>:</p>\n<blockquote>\n<p>Same here. I searched through mathlib to figure out how exactly theorems about ofNat need to be written, and they all had that</p>\n</blockquote>\n<p>Is there anyone who can explain that <code>noindex</code> thing? Eric W asked about is in review too. I am talking about</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">coeff_ofNat_zero</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">a.AtLeastTwo</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">coeff</span> <span class=\"o\">(</span><span class=\"n\">no_index</span> <span class=\"o\">(</span><span class=\"n\">ofNat</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]))</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n  <span class=\"n\">coeff_monomial</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>?</p>",
        "id": 395432610,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696694356
    },
    {
        "content": "<p>That makes <code>simp</code> ignore any structure under <code>coeff</code>, meaning it will try to apply the lemma on any subterm of the form <code>coeff _ 0</code> instead of <code>coeff (ofNat a) 0</code></p>",
        "id": 395436604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1696697595
    },
    {
        "content": "<p>this is useful if you want it to match when you have <code>coeff X 0</code> where <code>X</code> is defeq to <code>ofNat a</code> but not reducibly</p>",
        "id": 395436688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1696697653
    },
    {
        "content": "<p>Thanks. Why is it needed in that particular case? Remember the goal was to get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">X</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">coeff</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>\n<p>working. In this case it looks like the target is exactly <code>ofNat</code>.</p>",
        "id": 395437709,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696698625
    },
    {
        "content": "<p>if I had to guess, it's inferring an extra <code>ofNat</code> to avoid raw numerals and this messes up theorems that want to work on all <code>ofNat</code> expressions</p>",
        "id": 395438147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1696699069
    },
    {
        "content": "<p>What is  \"it\"? Lean? Where is it inferring that extra ofNat?</p>",
        "id": 395438240,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696699146
    },
    {
        "content": "<p>inside <code>simp</code></p>",
        "id": 395438280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1696699198
    },
    {
        "content": "<p>IIRC</p>",
        "id": 395438301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1696699204
    },
    {
        "content": "<p>Is that a bug in <code>simp</code>?</p>",
        "id": 395438700,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696699581
    },
    {
        "content": "<p>Last I looked at these ofNat things the only difference I would see between my lemmas and the goals was that in the goal they had some weird <code>[AtLeastTwo (7 + 2)]</code> stuff  inwhich meant that <code>[AtLeastTwo n]</code> didn't match syntactically (as n is already fixed to be <code>9</code> by that point) and hence some noindex was needed</p>",
        "id": 395460480,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1696719104
    },
    {
        "content": "<p>Could the <code>no_index</code> go in the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.AtLeastTwo#doc\">docs#Nat.AtLeastTwo</a> instances instead?</p>",
        "id": 395511751,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696755236
    },
    {
        "content": "<p>Pinging this; are we any closed to understanding why <code>no_index</code> is a good idea here? We have a library note <a href=\"https://github.com/leanprover-community/mathlib4/blob/332340d8760e750d04114ee5920c382b8fe75d8e//Mathlib/Data/Nat/Cast/Defs.lean#L64-L70\">here</a> (pointing back to this thread), but it feels like we're cargo-culting it with no understanding; should <code>no_index</code> go on both the LHS and RHS? Is it only needed for <code>simp</code> lemmas?</p>",
        "id": 401399369,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699630000
    },
    {
        "content": "<p>(deleted: I move the discussion instead)</p>",
        "id": 401399524,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699630048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> has marked this topic as unresolved.</p>",
        "id": 401399680,
        "sender_full_name": "Notification Bot",
        "timestamp": 1699630093
    },
    {
        "content": "<p>14 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/.E2.9C.94.20Polynomial.2Ecoeff.20example\">#mathlib4 &gt; ✔ Polynomial.coeff example</a> by <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>.</p>",
        "id": 401399682,
        "sender_full_name": "Notification Bot",
        "timestamp": 1699630093
    },
    {
        "content": "<p>I don't understand why we need <code>no_index</code> with <code>ofNat</code>, but experimentally, it seems it's necessary on the LHS for <code>simp</code> to apply the lemma at all, and it's necessary on both sides of the equation in order to be found by <code>exact?</code>. It's also necessary on the RHS of any equation if we want <code>simp [← not_a_simp_lemma]</code> to work.</p>",
        "id": 401635632,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699817954
    },
    {
        "content": "<p>It seems to me like we want <code>no_index</code> around every occurence of <code>OfNat.ofNat</code> in the library, except in the cases where that leaves no constants to index on so will cause a significant performance regression</p>",
        "id": 401635699,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699818040
    },
    {
        "content": "<p>Perhaps we should write an <code>of_nat% n</code> elaborator that inserts the <code>no_index</code> so that we don't have to remember to do this?</p>",
        "id": 401636070,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699818543
    },
    {
        "content": "<p>The <code>exact?</code> behavior is interesting, thanks for finding that!</p>",
        "id": 401636085,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699818591
    },
    {
        "content": "<p>Here's a pretty simple repro using <code>exact?</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.LibrarySearch</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyProp</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">False</span>\n\n<span class=\"c1\">-- Note: Using `instOfNatNat`, not `instOfNat` (the `NatCast` instance from Mathlib)</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">myProp_ofNat</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span><span class=\"bp\">?</span> <span class=\"c1\">-- fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span><span class=\"bp\">?</span> <span class=\"c1\">-- fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">myProp_ofNat</span> <span class=\"mi\">2</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">myProp_ofNat'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"o\">(</span><span class=\"n\">no_index</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span><span class=\"bp\">?</span> <span class=\"c1\">-- succeeds</span>\n</code></pre></div>",
        "id": 401637079,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699819502
    },
    {
        "content": "<p>This rules out the hypothesis that the problem has to do with the <code>Nat.AtLeastTwo</code> instance argument</p>",
        "id": 401637219,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699819672
    },
    {
        "content": "<p>For comparison, <code>id</code> behaves a bit differently from <code>OfNat.ofNat</code> here</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.LibrarySearch</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyProp</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">False</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">myProp_id</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span><span class=\"bp\">?</span> <span class=\"c1\">-- fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span><span class=\"bp\">?</span> <span class=\"c1\">-- succeeds, unlike with `OfNat.ofNat`</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">myProp_id</span> <span class=\"mi\">2</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">myProp_id'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"o\">(</span><span class=\"n\">no_index</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span><span class=\"bp\">?</span> <span class=\"c1\">-- succeeds</span>\n</code></pre></div>",
        "id": 401637375,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699819836
    },
    {
        "content": "<p>It looks like <code>myProp_ofNat</code> ends up in the discrimination tree under <code>[MyProp, OfNat.ofNat, Nat, *, *]</code>, which is later not matched when looking for <code>[MyProp, 2]</code></p>",
        "id": 401641481,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699824393
    },
    {
        "content": "<p>I think this is a bug in core <code>DiscrTree</code>. Should I open an issue? (Using <code>simp</code> for the <code>mwe</code>)</p>",
        "id": 401641505,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699824429
    },
    {
        "content": "<p>What's the <code>2</code> there in <code>[MyProp, 2]</code>?</p>",
        "id": 401641513,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699824440
    },
    {
        "content": "<p><code>Lean.Meta.DiscrTree.Key.lit (Lean.Literal.natVal 2)</code></p>",
        "id": 401641584,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699824487
    },
    {
        "content": "<p>That would explain why your PR is such a performance hit too, because the no_index means that we try the lemma on all <code>foo _</code> goals, not just <code>foo (OfNat _)</code></p>",
        "id": 401641621,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699824572
    },
    {
        "content": "<p>Presumably the lemma is going to the right place in the tree, but the lookup is incorrect?</p>",
        "id": 401641701,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699824650
    },
    {
        "content": "<p>In comparison, a lemma <code>theorem myProp_nat (n : Nat) : MyProp n</code> looks like <code>[MyProp, *]</code> in the discrimination tree, which does get found when looking up <code>MyProp 2</code>. I think there needs to be a special case in the lookup code for when the expression being searched for is a nat literal of type <code>α</code> so it matches both <code>[*]</code> and <code>[OfNat.ofNat, α, *, *]</code></p>",
        "id": 401641994,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699825027
    },
    {
        "content": "<p>Interestingly, lemmas using natural number \"offsets\" such as <code>n.succ</code> are special-cased as <code>no_index</code> in the <code>DiscrTree</code> code.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- DiscrTree key: [MyProp, *] due to `isOffset` special case</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">myProp_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span><span class=\"bp\">?</span> <span class=\"c1\">-- succeeds</span>\n</code></pre></div>",
        "id": 401642178,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699825246
    },
    {
        "content": "<p>and there used to be one for literals like <code>OfNat.ofNat 2</code> well, but it was removed in <a href=\"https://github.com/leanprover/lean4/commit/425f42cd839fab576e9be4ba18e76f2bf837615a\">https://github.com/leanprover/lean4/commit/425f42cd839fab576e9be4ba18e76f2bf837615a</a></p>",
        "id": 401642282,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699825408
    },
    {
        "content": "<p>Ah.. And the reason that explicitly adding <code>OfNat.ofNat 2</code> to the goal doesn't help is because there's code that normalizes that needle if it's a numeral to just the literal key <code>2</code></p>",
        "id": 401642548,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699825764
    },
    {
        "content": "<p>Issue posted <a href=\"https://github.com/leanprover/lean4/pull/2867\">lean4#2867</a></p>",
        "id": 401646494,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699830045
    },
    {
        "content": "<p>How exactly are you finding out the DiscrTree key?</p>",
        "id": 401856356,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699914798
    },
    {
        "content": "<p>Hackily..</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.LibrarySearch</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyProp</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">False</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">myProp_ofNat</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">myProp_two</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span><span class=\"bp\">?</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">myProp_ofNat'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"o\">(</span><span class=\"n\">no_index</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">myProp_nat</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyProp</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">defnName</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"s2\">\"myProp_ofNat\"</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"dbg_discr_key\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">cinfo</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"bp\">←</span><span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"bp\">?</span> <span class=\"n\">defnName</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"bp\">!</span>\n  <span class=\"k\">let</span> <span class=\"n\">processed</span> <span class=\"bp\">←</span> <span class=\"n\">Mathlib.Tactic.LibrarySearch.processLemma</span> <span class=\"n\">defnName</span> <span class=\"n\">cinfo</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{processed}\"</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span><span class=\"kd\">by</span>\n  <span class=\"n\">dbg_discr_key</span>\n  <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 401857275,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1699915211
    },
    {
        "content": "<p>Once <a href=\"https://github.com/leanprover/lean4/pull/2867\">lean4#2867</a> is fixed and we can write lemmas about <code>OfNat.ofNat</code> without needing <code>no_index</code>, it would be really nice to avoid having to duplicate lemmas for both the <code>Nat.cast</code> case and <code>OfNat.ofNat</code> case. Could we avoid this by making some small tweaks to Mathlib's nat casting instances to make <code>Nat.cast</code> and <code>OfNat.ofNat</code> reducibly defeq? Here is one proposal that I think might work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Cast.Defs</span>\n\n<span class=\"c1\">-- Redefine `NatCast` so that `Nat.cast n` will be defeq to `OfNat.ofNat n`</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">NatCast'</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">OfNat</span> <span class=\"n\">R</span> <span class=\"n\">n</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">Nat.cast'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NatCast'</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- We can no longer extend `NatCast R`, so we need to add an explicit `natCast` field.</span>\n<span class=\"kd\">class</span> <span class=\"n\">AddMonoidWithOne'</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">AddMonoid</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">One</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">natCast</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.unaryCast</span>\n  <span class=\"n\">natCast_zero</span> <span class=\"o\">:</span> <span class=\"n\">natCast</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">natCast_succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">natCast</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">natCast</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- Define the `OfNat` instance for all n, removing the `AtLeastTwo` assumption.</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instOfNat'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne'</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">R</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">AddMonoidWithOne'.natCast</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne'</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Nat.cast'</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">with_reducible</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- Note: Although there are now two instances of `OfNat R 0`, they are reducibly defeq.</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne'</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">R</span> <span class=\"mi\">0</span> <span class=\"n\">Zero.toOfNat0</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">R</span> <span class=\"mi\">0</span> <span class=\"n\">instOfNat'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">with_reducible</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 402791699,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1700261211
    },
    {
        "content": "<p>I kicked</p>\n<blockquote>\n<p>fix: add missing no_index around OfNat.ofNat <a href=\"https://github.com/leanprover-community/mathlib4/pull/8317\">#8317</a> </p>\n</blockquote>\n<p>on the queue. But clearly this approach isn't sustainable. So I hope some elaborator trickery, or some patch to <code>simp</code>, will allow us to revert this PR in the future.</p>",
        "id": 405799726,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701687710
    },
    {
        "content": "<p>Is there an issue capturing for this anywhere? This <code>no_index</code> stuff is pretty undesirable.</p>",
        "id": 405808480,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1701691042
    },
    {
        "content": "<p>Yes,  <a href=\"https://github.com/leanprover/lean4/pull/2867\">lean4#2867</a> referenced two messages above</p>",
        "id": 405813432,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701692846
    }
]