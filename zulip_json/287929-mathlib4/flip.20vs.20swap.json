[
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=flip#doc\">docs#flip</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.swap#doc\">docs#Function.swap</a> and these seem to be entirely identical (save for the latter being dependently typed). Should one be deprecated for the other?</p>",
        "id": 500262552,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1739820867
    },
    {
        "content": "<p>The latter also works with dot notation</p>",
        "id": 500269138,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739823968
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> It \"works\" with dot notation, but not in the way you would expect.</p>",
        "id": 500277368,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739828017
    },
    {
        "content": "<p>In that the effect is surprising, or the mechanism is?</p>",
        "id": 500277402,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739828041
    },
    {
        "content": "<p>The effect</p>",
        "id": 500277461,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739828053
    },
    {
        "content": "<p>Oh no, it fills in the type argument!</p>",
        "id": 500277563,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739828124
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">swap</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>",
        "id": 500277792,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1739828237
    },
    {
        "content": "<p>Is this a quirk of <code>Function.</code> or does this happen with all dot notation?</p>",
        "id": 500278018,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1739828374
    },
    {
        "content": "<p>I think all dot notation fills in the first argument with the right type, rather than the first <em>explicit</em> argument</p>",
        "id": 500278066,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739828402
    },
    {
        "content": "<p>I believe Kyle had an RFC for marking which argument should participate</p>",
        "id": 500278124,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739828413
    },
    {
        "content": "<p>My very first Lean RFC is about this too: <a href=\"https://github.com/leanprover/lean4/pull/1629\">lean4#1629</a></p>",
        "id": 500278720,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739828723
    },
    {
        "content": "<p>(The motivation for this \"first argument, even if it's implicit\" behavior is that it makes dot notation consistent when you are using it on a typeclass instance, where the typeclass appears as an instance implicit argument.)</p>",
        "id": 500278969,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739828834
    },
    {
        "content": "<p>\"first explicit argument if there is one, followed by first implicit otherwise\" would seemingly work for that case too</p>",
        "id": 500279101,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739828888
    },
    {
        "content": "<p>It's quite uncommon for a typeclass to appear in both positions</p>",
        "id": 500279125,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739828900
    },
    {
        "content": "<p>Here's my current RFC about it: <a href=\"https://github.com/leanprover/lean4/pull/6489\">lean4#6489</a></p>\n<p>The first RFC suggests looking for a <code>self</code> parameter, and the new one suggests looking for a <code>dotParam</code>-annotated parameter.</p>",
        "id": 500279233,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739828952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/flip.20vs.20swap/near/500279101\">said</a>:</p>\n<blockquote>\n<p>\"first explicit argument if there is one, followed by first implicit otherwise\" would seemingly work for that case too</p>\n</blockquote>\n<p>An annoying complication is that somehow we have to interleave finding CoeFun instances. I suppose for Function it would be fairly rare for there to be a CoeFun instance, and there's no confusion between trying for a CoeFun instance and making use of an implicit function-type argument.</p>",
        "id": 500279553,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739829104
    },
    {
        "content": "<p>For \"there's only one way to do it\" purposes, <code>dotParam</code> seems like the right choice to me.</p>\n<p>However, I'm feeling tempted to let <code>self</code> be used for this too. The main argument against <code>self</code> is that it tempts people to use it rather than a more descriptive parameter name.</p>",
        "id": 500279832,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739829239
    },
    {
        "content": "<p>Anyway, regarding the original question, I believe there are a number of examples where there's the dependently-typed version and the simply-typed version, and you sort of need both since the former is more complicated to elaborate and might fail so you want the second, but also you do want the more complicated one since not everything is simply typed.</p>",
        "id": 500280311,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739829458
    },
    {
        "content": "<p>I guess we could try making the one in core dependently-typed and see what breaks?</p>",
        "id": 500280426,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739829492
    },
    {
        "content": "<p>I'm wondering if it's a good use of time though. Usually we don't use these functions for plain functions, and at least in core we don't tend to write in point-free style.</p>",
        "id": 500280701,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739829617
    },
    {
        "content": "<p>Haskell programmers learning Lean might gravite toward <code>flip</code>, and I'd hate to see dependent type issues making their programming style not work for them.</p>",
        "id": 500280850,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739829677
    },
    {
        "content": "<blockquote>\n<p>I'm wondering if it's a good use of time though.</p>\n</blockquote>\n<p>Well, if it works everywhere then that's perhaps an argument for dropping it; and if it doesn't, it gives us something to put in the docstring of <code>Function.swap</code> explaining why it can't replace <code>flip</code></p>",
        "id": 500281073,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739829777
    },
    {
        "content": "<p>I'm not proposing trying to fix all downstream breakages, only check if there are any!</p>",
        "id": 500281102,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739829790
    }
]