[
    {
        "content": "<p>I met a problem on design of interraction of <code>Ext</code> and arbitrary semi-linear equiv as I want to prove the invariant of projective/injective dimension under arbitrary semi-linear equiv to show Gorenstein local ring is stable under ring equivlence. Here I not only met universe issue but also instance of module. (In contrast I think proving <code>Localization</code> is Gorenstein is relatively easier? I don't know why, maybe just an illusion.) <br>\nOur current setup: we know that <code>Ext</code> commute with flat base change when the ring is noetherian and the module on the left is finitely generated. See PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/30532\">#30532</a>.<br>\nThe universe level needed is as follow:<br>\nFor <code>R</code> in universe <code>u</code> and <code>S</code> in universe <code>u'</code> a flat <code>R</code>-algebra, assume <code>R</code> is <code>v</code>-small and <code>S</code> is <code>v'</code>-small with <code>v</code> not greater than <code>v'</code>, for <code>v \\le w</code> and <code>v' \\le w'</code><br>\n<code>Ext.{w'} MS NS n</code> is the base change of <code>Ext.{w} M N n</code> with <code>S</code> if <code>MS</code> and <code>NS</code> (in <code>ModuleCat.{v'}</code>) are base change of <code>M</code> and <code>N</code> (in <code>ModuleCat.{v}</code>) respectively.</p>",
        "id": 555577736,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1763124077
    },
    {
        "content": "<p>Currently I have the following in mind:<br>\nI first construct the linear equiv of <code>Ext</code> under linear equiv of modules respectively. This can also be separated into two steps as I need <code>UnivLE.{v, v'}</code> at first.<br>\nThen consider change of ring only in the same universe. I have in mind that the two category at this  time is equivalent? So we might be able to directly construct the map from two sides? If this is not ideal enough we are still able to consider using base change.<br>\nAt last we connect the above two steps together to obtain a full universe invariant semi-linear equiv between <code>Ext</code>.</p>",
        "id": 555580496,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1763124975
    },
    {
        "content": "<p>My guess is that if <code>F : C₁ ⥤ C₂</code> is an exact fully faithful functor between abelian categories such that</p>\n<ol>\n<li><code>C₁</code> has enough projectives and <code>F</code> preserves projectives, or</li>\n<li><code>C₁</code> has enough injectives and <code>F</code> preserves injectives,<br>\nthen, the maps on <code>Ext</code> induced by <code>F</code> are bijections.</li>\n</ol>",
        "id": 555601436,
        "sender_full_name": "Joël Riou",
        "timestamp": 1763130519
    },
    {
        "content": "<p>This can be applied for the <code>ulift</code>-functor on modules, or for the equivalence of categories given by extension or restriction of scalars by a ring isomorphism.</p>",
        "id": 555601452,
        "sender_full_name": "Joël Riou",
        "timestamp": 1763130524
    },
    {
        "content": "<p>The right way to do all of this should probably be to define <code>Ext</code>-types attached to modules with generic universe parameters:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Module.Ext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M₁</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M₂</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M₂</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c1\">-- use the categorical `Ext` in the category `ModuleCat.{max u v₁ v₂} R`</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 555601497,
        "sender_full_name": "Joël Riou",
        "timestamp": 1763130531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Ext.60.20functor.20under.20semi-linear.20equiv/near/555601436\">說</a>：</p>\n<blockquote>\n<p>My guess is that if <code>F : C₁ ⥤ C₂</code> is an exact fully faithful functor between abelian categories such that</p>\n<ol>\n<li><code>C₁</code> has enough projectives and <code>F</code> preserves projectives, or</li>\n<li><code>C₁</code> has enough injectives and <code>F</code> preserves injectives,<br>\nthen, the maps on <code>Ext</code> induced by <code>F</code> are bijections.</li>\n</ol>\n</blockquote>\n<p>The inverse can't be canonically constructed right? If so and I didn't get it wrong, this can be done by dimension shifting?</p>",
        "id": 555718808,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1763187645
    },
    {
        "content": "<p>However sorry that I don't think I am fully ready for this general <code>Module.Ext</code>? As there may involve many redesigns? Also I think I don't need it for now (?) But if this is definitely needed then I am willing to do it as soon as possible before to much things are already built on <code>Ext</code>.</p>",
        "id": 555718849,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1763187677
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"749361\">Nailin Guan</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Ext.60.20functor.20under.20semi-linear.20equiv/near/555718808\">said</a>:</p>\n<blockquote>\n<p>The inverse can't be canonically constructed right? If so and I didn't get it wrong, this can be done by dimension shifting?</p>\n</blockquote>\n<p>The statement would be that the induced maps satisfy <code>Function.Bijective</code>, and this would hold by induction on the dimension.</p>",
        "id": 555721961,
        "sender_full_name": "Joël Riou",
        "timestamp": 1763190498
    },
    {
        "content": "<p>I've opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/31697\">#31697</a> for the bijection.</p>",
        "id": 556675529,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1763289082
    },
    {
        "content": "<p>However I have some more question: I believe using restrict scalars with ring isomorphism is able to construct a category equivalence thus two sides of the isomorphism between <code>Ext</code> can be explicitly constructed?<br>\nBut as I tried to prove the map between <code>Ext</code> is compatible with composition of exact functors, I found it a bit hard to prove by either using <code>SmallShiftedHom.map</code> or <code>ShiftedHom.map</code>. I am not very sure about what is missing?</p>",
        "id": 556675845,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1763289370
    },
    {
        "content": "<p>If I didn't get it wrong, <code>ModuleCat.uliftFunctor</code> is missing? I try to add it in <a href=\"https://github.com/leanprover-community/mathlib4/pull/31706\">#31706</a></p>",
        "id": 556683589,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1763297507
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 556751423,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1763359117
    },
    {
        "content": "<p>I've opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/31768\">#31768</a> for compatibility with (semi-)linear equiv with general universe.</p>",
        "id": 557898876,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1763463647
    }
]