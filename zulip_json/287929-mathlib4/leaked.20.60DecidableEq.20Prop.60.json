[
    {
        "content": "<p>I have two related issues and I would like some advice on if/how it should be fixed:</p>\n<p>(1) A <code>LinearOrder Prop</code> instance <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prop.linearOrder#doc\">docs#Prop.linearOrder</a> is defined in mathlib without scoping under <code>Classical</code>. As a result, because of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearOrder.toDecidableEq#doc\">docs#LinearOrder.toDecidableEq</a>, we have <code>DecidableEq Prop</code> synthesizable without opening Classical. Informally, this is tantamount to saying that every <code>Prop</code> is decidable (because we have <code>âˆ€ p, Decidable (p = True)</code>). </p>\n<p>We can define the following function without opening Classical. Although it is not idiomatic (it should be <code>if p then 1 else 0</code>), it can occur as an instantiation of a larger definition (e.g., counting <code>True</code> in a <code>Multiset Prop</code>).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>(2) Regardless of whether it is scoped under Classical, this creates an instance diamond:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- I have a definition `a`</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"c1\">-- suppose in a `classical` proof, or in a separate definition, I have</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\">  </span><span class=\"c1\">--fails</span>\n</code></pre></div>\n<p><code>a</code> and <code>b</code> are not definitionally equal because the first uses <code>LinearOrder.toDecidableEq</code> and the <code>DecidableEq Prop</code> instance is just <code>Classical.propDecidable</code>, while the second uses <code>instDecidableEqOfIff</code> on <code>instDecidableIff</code> with a non-Classical <code>instDecidableTrue</code>. (See <a href=\"https://github.com/leanprover-community/mathlib4/blob/af239326a46dea977a6d5444466c14aa423f4b10/Mathlib/RingTheory/Norm/Transitivity.lean#L97-L99\">Mathlib/RingTheory/Norm/Transitivity.lean</a> for a real-world example).</p>\n<p>My questions are:</p>\n<ul>\n<li>Is this an issue to be fixed?</li>\n<li>Should we make the instance scoped under Classical? Note that doing this works with <code>open scoped Classical in ...</code> but might not work with the <code>classical</code> tactic, in that writing <code>classical</code> might not make <code>LinearOrder Prop</code> available, because <code>classical</code> only adds <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.propDecidable#doc\">docs#Classical.propDecidable</a> which alone does not infer <code>LinearOrder Prop</code> because <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lattice.toLinearOrder#doc\">docs#Lattice.toLinearOrder</a> is a non-instance.</li>\n</ul>",
        "id": 564769361,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1766175003
    }
]