[
    {
        "content": "<p>It would be nice to have a tactic that autogenerates lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sigma.forall#doc\">docs#Sigma.forall</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sigma.exists#doc\">docs#Sigma.exists</a></p>",
        "id": 372439087,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688518535
    },
    {
        "content": "<p>If someone is ready to teach me how to write meta code, I can try to write this.</p>",
        "id": 372449986,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688524514
    },
    {
        "content": "<p>E.g., what should I read first?</p>",
        "id": 372450006,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688524534
    },
    {
        "content": "<p>If you want to learn in a systematic way then you need to read Functional programming in Lean and then the meta-programming book. The indirect way is to try to read meta-code and try to imitate it.</p>",
        "id": 372483686,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1688540388
    },
    {
        "content": "<p>Here's a general plan for a way to generate these lemmas sketched out inside a tactic proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.ProxyType</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.ULift</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Foo</span>\n  <span class=\"bp\">|</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mk_Foo_forall_exists</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- The `proxy_equiv%` machinery also has a direct metaprogramming interface.</span>\n  <span class=\"c1\">-- In the simps I'm making use of the name of the global definition it generates.</span>\n  <span class=\"k\">let</span> <span class=\"n\">eqv</span> <span class=\"o\">:=</span> <span class=\"n\">proxy_equiv</span><span class=\"bp\">%</span> <span class=\"n\">Foo</span>\n  <span class=\"k\">have</span> <span class=\"n\">forall_lemma</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.forall_congr_left'</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">eqv.symm</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Foo.proxyTypeEquiv</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">forall_lemma</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">forall_lemma</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  forall_lemma :</span>\n<span class=\"cm\">    (∀ (x : Foo), p x) ↔</span>\n<span class=\"cm\">      (∀ (a : ℕ) (x : a &lt; 5), p (Foo.A a x)) ∧ p (Foo.B false) ∧ p (Foo.B true)</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"k\">have</span> <span class=\"n\">exists_lemma</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.exists_congr_left</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">eqv.symm</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Foo.proxyTypeEquiv</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">exists_lemma</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">exists_lemma</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  exists_lemma :</span>\n<span class=\"cm\">    (∃ a, p a) ↔</span>\n<span class=\"cm\">      (∃ a x, p (Foo.A a x)) ∨ p (Foo.B false) ∨ p (Foo.B true)</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>(Though it's probably better and more general to generate the lemmas more directly from the recursor.)</p>",
        "id": 372502291,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688545330
    },
    {
        "content": "<p>You could check out how reassoc and elementwise work as a partial model, though it's going to be different since these don't start with a theorem to transform</p>",
        "id": 372502521,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688545396
    },
    {
        "content": "<p>Here's a rough implementation to generate forall lemmas by analyzing the recursor. It works at least for the examples I've thrown at it.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.SolveByElim</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span>\n\n<span class=\"sd\">/-- Make a conjunction of `And`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">mkConj</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p</span>\n  <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"o\">::</span> <span class=\"n\">ps</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkApp2</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">And</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">mkConj</span> <span class=\"n\">ps</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- For a given inductive type, create a \"forall lemma.\" -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">mkForallIffType</span> <span class=\"o\">(</span><span class=\"n\">decl</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">recOn</span> <span class=\"o\">:=</span> <span class=\"n\">mkRecOnName</span> <span class=\"n\">decl</span>\n  <span class=\"k\">let</span> <span class=\"n\">recInfo</span> <span class=\"bp\">←</span> <span class=\"n\">mkRecursorInfo</span> <span class=\"n\">recOn</span>\n  <span class=\"c1\">-- Specialize the motive to Prop:</span>\n  <span class=\"k\">let</span> <span class=\"n\">us</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Level</span> <span class=\"bp\">←</span> <span class=\"n\">recInfo.univLevelPos.mapM</span> <span class=\"k\">fun</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">motive</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"bp\">.</span><span class=\"n\">zero</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">majorType</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkFreshLevelMVar</span>\n  <span class=\"k\">let</span> <span class=\"n\">recFn</span> <span class=\"o\">:=</span> <span class=\"n\">mkConst</span> <span class=\"n\">recOn</span> <span class=\"n\">us</span>\n  <span class=\"c1\">--logInfo m!\"recOn = {recOn}\\nrecInfo = {recInfo}\\nrecOn : {← inferType recFn}\"</span>\n  <span class=\"n\">forallTelescopeReducing</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">recFn</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">args</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"n\">args</span><span class=\"o\">[</span><span class=\"n\">recInfo.motivePos</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n    <span class=\"c1\">--let major := args[recInfo.majorPos]!</span>\n    <span class=\"n\">unless</span> <span class=\"n\">recInfo.paramsPos.all</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">isSome</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"(internal error) kernel recursors should have all paramsPos\"</span>\n    <span class=\"k\">let</span> <span class=\"n\">params</span> <span class=\"o\">:=</span> <span class=\"n\">recInfo.paramsPos.toArray.map</span> <span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">[</span><span class=\"bp\">·.</span><span class=\"n\">get</span><span class=\"bp\">!</span><span class=\"o\">]</span><span class=\"bp\">!</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">minors</span> <span class=\"o\">:=</span> <span class=\"n\">Array.range</span> <span class=\"n\">args.size</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">filter</span> <span class=\"n\">recInfo.isMinor</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">[</span><span class=\"bp\">·</span><span class=\"o\">]</span><span class=\"bp\">!</span><span class=\"o\">)</span>\n    <span class=\"n\">unless</span> <span class=\"n\">args.size</span> <span class=\"bp\">==</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">minors.size</span> <span class=\"bp\">+</span> <span class=\"n\">params.size</span> <span class=\"bp\">+</span> <span class=\"n\">recInfo.indicesPos.length</span> <span class=\"k\">do</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"(internal error) recursor has unexpected number of arguments\"</span>\n    <span class=\"c1\">-- Rename the motive to P:</span>\n    <span class=\"k\">let</span> <span class=\"n\">lctx'</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getLCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">setUserName</span> <span class=\"n\">motive.fvarId</span><span class=\"bp\">!</span> <span class=\"bp\">`</span><span class=\"n\">P</span>\n    <span class=\"n\">withLCtx</span> <span class=\"n\">lctx'</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getLocalInstances</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n      <span class=\"c1\">--logInfo m!\"params = {params}\\nmotive = {motive}\\nminors = {minors}\"</span>\n      <span class=\"k\">let</span> <span class=\"n\">lhs</span> <span class=\"bp\">←</span> <span class=\"n\">forallTelescopeReducing</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">motive</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">idxs</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"n\">mkForallFVars</span> <span class=\"n\">idxs</span> <span class=\"o\">(</span><span class=\"n\">mkAppN</span> <span class=\"n\">motive</span> <span class=\"n\">idxs</span><span class=\"o\">)</span>\n      <span class=\"c1\">--logInfo m!\"lhs = {lhs}\"</span>\n      <span class=\"k\">let</span> <span class=\"n\">rhs</span> <span class=\"o\">:=</span> <span class=\"n\">mkConj</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">minors.mapM</span> <span class=\"n\">inferType</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n      <span class=\"c1\">--logInfo m!\"rhs = {rhs}\"</span>\n      <span class=\"k\">let</span> <span class=\"n\">iff</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp2</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Iff</span><span class=\"o\">)</span> <span class=\"n\">lhs</span> <span class=\"n\">rhs</span>\n      <span class=\"n\">mkForallFVars</span> <span class=\"o\">(</span><span class=\"n\">params.push</span> <span class=\"n\">motive</span><span class=\"o\">)</span> <span class=\"n\">iff</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mkForallIffPf</span> <span class=\"o\">(</span><span class=\"n\">decl</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">←</span> <span class=\"n\">mkForallIffType</span> <span class=\"n\">decl</span>\n  <span class=\"c1\">--logInfo m!\"ty = {ty}\"</span>\n  <span class=\"n\">check</span> <span class=\"n\">ty</span>\n  <span class=\"k\">let</span> <span class=\"n\">pf</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"n\">ty</span>\n  <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">pf.mvarId</span><span class=\"bp\">!</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">g.intros</span>\n  <span class=\"k\">let</span> <span class=\"o\">[</span><span class=\"n\">gmp</span><span class=\"o\">,</span> <span class=\"n\">gmpr</span><span class=\"o\">]</span> <span class=\"bp\">←</span> <span class=\"n\">g.apply</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Iff.intro</span>\n    <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"apply did not generate exactly two goals\"</span>\n  <span class=\"k\">let</span> <span class=\"o\">[]</span> <span class=\"bp\">←</span> <span class=\"n\">Term.withoutErrToSorry</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Tactic.run</span> <span class=\"n\">gmp</span> <span class=\"k\">do</span> <span class=\"n\">Tactic.evalTactic</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span>\n      <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">}))</span>\n    <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"could not solve forward direction\"</span>\n  <span class=\"k\">let</span> <span class=\"o\">[]</span> <span class=\"bp\">←</span> <span class=\"n\">Term.withoutErrToSorry</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Tactic.run</span> <span class=\"n\">gmpr</span> <span class=\"k\">do</span> <span class=\"n\">Tactic.evalTactic</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"o\">(</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">and_imp</span><span class=\"o\">]</span>\n      <span class=\"n\">intros</span>\n      <span class=\"n\">rename_i</span> <span class=\"n\">m</span>\n      <span class=\"n\">induction</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">solve_by_elim</span><span class=\"o\">))</span>\n    <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"could not solve backward direction\"</span>\n  <span class=\"n\">instantiateMVars</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">←</span> <span class=\"n\">mkExpectedTypeHint</span> <span class=\"n\">pf</span> <span class=\"n\">ty</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">mkQuantifierLemma</span><span class=\"o\">)</span> <span class=\"s2\">\"mk_quantifier_iffs\"</span> <span class=\"o\">:</span> <span class=\"n\">attr</span>\n\n<span class=\"n\">initialize</span> <span class=\"n\">registerBuiltinAttribute</span> <span class=\"o\">{</span>\n  <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">mkQuantifierLemma</span>\n  <span class=\"n\">descr</span> <span class=\"o\">:=</span> <span class=\"s2\">\"\"</span>\n  <span class=\"n\">applicationTime</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">afterCompilation</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">src</span> <span class=\"n\">ref</span> <span class=\"n\">kind</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">ref</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"bp\">|</span> <span class=\"n\">mk_quantifier_iffs</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MetaM.run'</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"bp\">!=</span> <span class=\"n\">AttributeKind.global</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"`mk_quantifier_iffs` can only be used as a global attribute\"</span>\n    <span class=\"k\">let</span> <span class=\"n\">tgt</span> <span class=\"o\">:=</span> <span class=\"n\">Name.str</span> <span class=\"n\">src</span> <span class=\"s2\">\"forall_iff\"</span>\n    <span class=\"k\">let</span> <span class=\"n\">tgt'</span> <span class=\"o\">:=</span> <span class=\"n\">Name.str</span> <span class=\"n\">src</span> <span class=\"s2\">\"exists_iff\"</span> <span class=\"c1\">-- TODO</span>\n    <span class=\"n\">addDeclarationRanges</span> <span class=\"n\">tgt</span>\n      <span class=\"o\">{</span> <span class=\"n\">range</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">getDeclarationRange</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getRef</span><span class=\"o\">)</span>\n        <span class=\"n\">selectionRange</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">getDeclarationRange</span> <span class=\"n\">ref</span> <span class=\"o\">}</span>\n    <span class=\"n\">addDeclarationRanges</span> <span class=\"n\">tgt'</span>\n      <span class=\"o\">{</span> <span class=\"n\">range</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">getDeclarationRange</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getRef</span><span class=\"o\">)</span>\n        <span class=\"n\">selectionRange</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">getDeclarationRange</span> <span class=\"n\">ref</span> <span class=\"o\">}</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">levels</span><span class=\"o\">,</span> <span class=\"n\">pf</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">Term.TermElabM.run'</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">pf</span> <span class=\"bp\">←</span> <span class=\"n\">mkForallIffPf</span> <span class=\"n\">src</span>\n      <span class=\"k\">let</span> <span class=\"n\">pf</span> <span class=\"bp\">←</span> <span class=\"n\">Elab.Term.levelMVarToParam</span> <span class=\"n\">pf</span>\n      <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Term.getLevelNames</span><span class=\"o\">,</span> <span class=\"n\">pf</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">pf</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">pf</span>\n    <span class=\"n\">addAndCompile</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">.</span><span class=\"n\">thmDecl</span>\n      <span class=\"o\">{</span> <span class=\"n\">levelParams</span> <span class=\"o\">:=</span> <span class=\"n\">levels</span><span class=\"o\">,</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">pf</span><span class=\"o\">),</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">tgt</span><span class=\"o\">,</span> <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"n\">pf</span> <span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span> <span class=\"o\">}</span>\n</code></pre></div>\n</div></div>\n<p>Here are some examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[mk_quantifier_iffs]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Foo.forall_iff</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Foo.forall_iff.{u_1} {α : Type u_1} {P : Foo α → Prop} :</span>\n<span class=\"cm\">  (∀ (t : Foo α), P t) ↔ (∀ (n : ℕ) (h : n &lt; 5), P (Foo.A n h))</span>\n<span class=\"cm\">                            ∧ (∀ (b : Bool), P (Foo.B b)) ∧ ∀ (x : α), P (Foo.C x)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">@[mk_quantifier_iffs]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Primaries</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Red</span> <span class=\"bp\">|</span> <span class=\"n\">Green</span> <span class=\"bp\">|</span> <span class=\"n\">Blue</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Primaries.forall_iff</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Primaries.forall_iff {P : Primaries → Prop} :</span>\n<span class=\"cm\">  (∀ (t : Primaries), P t) ↔ P Primaries.Red ∧ P Primaries.Green ∧ P Primaries.Blue</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">mk_quantifier_iffs</span><span class=\"o\">]</span> <span class=\"n\">Fin</span>\n<span class=\"k\">#check</span> <span class=\"n\">Fin.forall_iff</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Fin.forall_iff {n : ℕ} {P : Fin n → Prop} :</span>\n<span class=\"cm\">  (∀ (t : Fin n), P t) ↔ ∀ (val : ℕ) (isLt : val &lt; n), P { val := val, isLt := isLt }</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">mk_quantifier_iffs</span><span class=\"o\">]</span> <span class=\"n\">Eq</span>\n<span class=\"k\">#check</span> <span class=\"n\">Eq.forall_iff</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Eq.forall_iff.{u_1} {α : Sort u_1} {a✝ : α} {P : (a : α) → a✝ = a → Prop} :</span>\n<span class=\"cm\">  (∀ (a : α) (t : a✝ = a), P a t) ↔ P a✝ (_ : a✝ = a✝)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">mk_quantifier_iffs</span><span class=\"o\">]</span> <span class=\"n\">List</span>\n<span class=\"k\">#check</span> <span class=\"n\">List.forall_iff</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">List.forall_iff.{u_1} {α : Type u_1} {P : List α → Prop} :</span>\n<span class=\"cm\">  (∀ (t : List α), P t) ↔ P [] ∧ ∀ (head : α) (tail : List α), P tail → P (head :: tail)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 372739919,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688604551
    },
    {
        "content": "<p>Thanks! Will you PR it? BTW, should we use <code>.forall</code>/<code>.exists</code> or <code>.forall_iff</code>/<code>.exists_iff</code>?</p>",
        "id": 372741461,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688605306
    },
    {
        "content": "<p>It doesn't have exists lemmas yet, and it would be nice to more accurately generate the proof of the forall lemma rather than hope <code>solve_by_elim</code> works (I found that it doesn't work for <code>Acc</code>). But, yeah, I can PR it once it's ready</p>",
        "id": 372741743,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688605427
    },
    {
        "content": "<p>For names of the generated lemmas, both options seem fine, except <code>forall</code> is still a reserved keyword, which is a little awkward</p>",
        "id": 372741981,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688605539
    },
    {
        "content": "<p>We have lots of <code>*.forall</code> lemmas. All of them need to be protected anyway.</p>",
        "id": 372743331,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688606233
    },
    {
        "content": "<p>(you don't want many <code>forall_iff</code> lemmas available after <code>open</code> either)</p>",
        "id": 372743379,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688606264
    }
]