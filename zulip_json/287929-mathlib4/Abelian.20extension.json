[
    {
        "content": "<p>Is this the correct way to define an abelian extension of fields?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.FieldTheory.Galois.Basic</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsGalois</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Subgroup.IsCommutative</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">))]</span>\n</code></pre></div>",
        "id": 510209302,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1743774939
    },
    {
        "content": "<p>On the poster for <a href=\"https://www.claymath.org/events/formalizing-class-field-theory/\">https://www.claymath.org/events/formalizing-class-field-theory/</a> I went for <code>\\forall a b : G, a * b = b * a</code> which feels a bit less contrived than what you've written but I'm certainly not convinced that my way is optimal either</p>",
        "id": 510211227,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743775395
    },
    {
        "content": "<p>I had something like in a branch of mine.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsAbelianGalois</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n<span class=\"w\">   </span><span class=\"n\">IsGalois</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Commutative</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n\n<span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsAbelianGalois</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">     </span><span class=\"n\">CommGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"n\">mul_comm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Commutative</span><span class=\"bp\">.</span><span class=\"n\">comm</span>\n</code></pre></div>",
        "id": 510212641,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1743775700
    },
    {
        "content": "<p>I like the idea of having a class for abelian extensions rather than some ad-hoc hypothesis.</p>",
        "id": 510213232,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1743775848
    },
    {
        "content": "<p>Another option would be to add an assumption like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Subgroup.center</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span>\n</code></pre></div>\n<p>and to benefit from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Group.commGroupOfCenterEqTop#doc\">docs#Group.commGroupOfCenterEqTop</a>; this might make it easier to speak about \"abelian subextensions of a given extension\"  or the like; but <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> 's solution is also very nice.</p>",
        "id": 510215418,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1743776353
    },
    {
        "content": "<p>Yes, because this is how the library is designed, e.g. we have <code>Group</code> and <code>CommGroup</code> so it feels like if we have <code>IsGalois</code> then we should have <code>IsAbelianGalois</code></p>",
        "id": 510217151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743776821
    },
    {
        "content": "<p>I am starting to play a bit with abelian extensions and it would be helpful to have some solid base to build on.  <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> , could you PR this definition?</p>",
        "id": 510218310,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1743777125
    },
    {
        "content": "<p>I don't have much but here's a PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/23669\">#23669</a></p>",
        "id": 510229921,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1743780205
    },
    {
        "content": "<p>It would nice to <em>fix</em> the way that some properties of a group (and other algebraic objects) are stated. <code>Subgroup.IsCommutative ⊤</code> is not really legible. Why not having a class <code>IsCommutative</code>for groups (or monoids)?</p>",
        "id": 510231162,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1743780516
    },
    {
        "content": "<p>Because then do you have the instance <code>[Group G] [IsCommutative G] -&gt; [CommGroup G]</code> or <code>[CommGroup G] -&gt; [IsCommutative G]</code>? Probably you can't have both because of loops. If we have <code>IsCommutative</code> then probably we should literally remove <code>CommGroup</code> which sounds like a massive nightmare.</p>",
        "id": 510232126,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743780781
    },
    {
        "content": "<p>The current design is throughout the library, for example we have <code>NonAssocRing</code> and <code>Ring</code>, and <code>NonUnitalRing</code> and <code>Ring</code>. For commutativity and associativity we have chosen a different design to <code>IsCommutative</code> and <code>IsAssociative</code>.</p>",
        "id": 510232442,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743780868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abelian.20extension/near/510232126\">said</a>:</p>\n<blockquote>\n<p>Because then do you have the instance <code>[Group G] [IsCommutative G] -&gt; [CommGroup G]</code></p>\n</blockquote>\n<p>This should not be an instance, but only a <code>def</code>, just like <code>[Ring R] [IsField R] -&gt; [Field R]</code> is only a <code>def</code>: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsField.toField#doc\">docs#IsField.toField</a></p>",
        "id": 510375401,
        "sender_full_name": "Jz Pan",
        "timestamp": 1743861297
    },
    {
        "content": "<p>Or define <code>CommGroup</code> as <code>class abbrev</code></p>",
        "id": 510375584,
        "sender_full_name": "Jz Pan",
        "timestamp": 1743861468
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abelian.20extension/near/510375401\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abelian.20extension/near/510232126\">said</a>:</p>\n<blockquote>\n<p>Because then do you have the instance <code>[Group G] [IsCommutative G] -&gt; [CommGroup G]</code></p>\n</blockquote>\n<p>This should not be an instance, but only a <code>def</code>, just like <code>[Ring R] [IsField R] -&gt; [Field R]</code> is only a <code>def</code>: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsField.toField#doc\">docs#IsField.toField</a></p>\n</blockquote>\n<p>these are not the same at all. <code>IsField.toField</code> creates data (it creates the inverse function), while <code>CommGroup</code> compared to <code>Group</code> only adds a proof of commutativity</p>",
        "id": 510376056,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743861795
    },
    {
        "content": "<p>because it creates data, if it were an instance it would create diamonds, hence why it's a <code>def</code></p>",
        "id": 510376098,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743861840
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abelian.20extension/near/510232126\">said</a>:</p>\n<blockquote>\n<p>Because then do you have the instance <code>[Group G] [IsCommutative G] -&gt; [CommGroup G]</code> or <code>[CommGroup G] -&gt; [IsCommutative G]</code>? Probably you can't have both because of loops. If we have <code>IsCommutative</code> then probably we should literally remove <code>CommGroup</code> which sounds like a massive nightmare.</p>\n</blockquote>\n<p>i think this is actually a loop that lean is able to detect, so this may actually be fine?</p>",
        "id": 510376197,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743861900
    },
    {
        "content": "<p>What's an example of a loop Lean is not able to detect?</p>",
        "id": 510382968,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743866617
    },
    {
        "content": "<p>one that changes the type, i think. i.e. things like <code>[Group (MulOpposite G)] -&gt; Group G</code></p>",
        "id": 510383523,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743866961
    },
    {
        "content": "<p>which causes lean to look for <code>Group</code> on increasingly many <code>MulOpposite</code> applied to <code>G</code>, when trying to synthesise <code>Group G</code></p>",
        "id": 510383677,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743867047
    },
    {
        "content": "<p>That's what I thought, but then people were worrying about loops on stuff that was not changing the type and I got confused.</p>",
        "id": 510383963,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743867225
    },
    {
        "content": "<p>another example of what can go wrong is that (when a specific option set to a high value, i forget which one) there can be an increase of local variables. An example would be <code>[forall (n:Nat), Group G] -&gt; Group G</code>. In this example, the context keeps getting more and more free variables of type <code>Nat</code></p>",
        "id": 510384094,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743867297
    },
    {
        "content": "<p>(the option was <code>SynthPendingDepth</code>)</p>",
        "id": 510384328,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743867475
    },
    {
        "content": "<p>I think we should add the looping instance, and see what the effect is on <code>!bench</code>. If the effect is tiny, then I would really prefer an <code>IsCommutative</code> typeclass, instead of a specialized <code>IsAbelianGalois</code>.</p>",
        "id": 510602121,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744016163
    },
    {
        "content": "<p>Why do we need the loopy instance?</p>",
        "id": 510661963,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744030574
    },
    {
        "content": "<p>test PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/23773\">#23773</a></p>",
        "id": 510665575,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1744031373
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abelian.20extension/near/510661963\">said</a>:</p>\n<blockquote>\n<p>Why do we need the loopy instance?</p>\n</blockquote>\n<p>So that you can apply all lemmas about commutative monoids/groups to your Galois group.</p>",
        "id": 510668607,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744032067
    },
    {
        "content": "<p>What's the precise example we need to succeed?</p>",
        "id": 510668815,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744032116
    },
    {
        "content": "<p>Results are in and they're not really good: <a href=\"https://github.com/leanprover-community/mathlib4/pull/23773#issuecomment-2783321596\">https://github.com/leanprover-community/mathlib4/pull/23773#issuecomment-2783321596</a></p>",
        "id": 510668888,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1744032126
    },
    {
        "content": "<p><code>rw [mul_comm]</code> for starters.</p>",
        "id": 510668918,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744032132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abelian.20extension/near/510665575\">said</a>:</p>\n<blockquote>\n<p>test PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/23773\">#23773</a></p>\n</blockquote>\n<p>This doesn't even add the other part of the loop, right? <code>CommGroup -&gt; IsMulCommutative</code>...</p>",
        "id": 510669111,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744032174
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abelian.20extension/near/510668815\">said</a>:</p>\n<blockquote>\n<p>What's the precise example we need to succeed?</p>\n</blockquote>\n<p>But besides the trivial <code>rw [mul_comm]</code>, facts like \"every subgroup is normal\", etc...</p>",
        "id": 510669355,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744032227
    },
    {
        "content": "<p>I guess it's hard to make a list here.</p>",
        "id": 510669393,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744032237
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abelian.20extension/near/510669111\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abelian.20extension/near/510665575\">said</a>:</p>\n<blockquote>\n<p>test PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/23773\">#23773</a></p>\n</blockquote>\n<p>This doesn't even add the other part of the loop, right? <code>CommGroup -&gt; IsMulCommutative</code>...</p>\n</blockquote>\n<p>Yes, the loop is there: <code>Group + IsMulCommutative -&gt; CommGroup</code> and <code>CommGroup -&gt; IsMulCommutative</code></p>",
        "id": 510670344,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1744032461
    },
    {
        "content": "<p>I was looking for a mwe with <code>variable</code>s and a failing <code>#synth</code></p>",
        "id": 510670350,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744032463
    },
    {
        "content": "<p>I guess it's</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsGalois</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- add a hypothesis to make this work</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">CommGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 510670871,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744032553
    },
    {
        "content": "<p>A solution is proposed there: <a href=\"https://github.com/leanprover-community/mathlib4/pull/23669\">#23669</a></p>",
        "id": 510671232,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1744032617
    },
    {
        "content": "<p>BTW I'm trying <code>IsZpExtension</code> here <a href=\"https://github.com/acmepjz/lean-iwasawa/blob/master/Iwasawalib/FieldTheory/ZpExtension/Basic.lean\">https://github.com/acmepjz/lean-iwasawa/blob/master/Iwasawalib/FieldTheory/ZpExtension/Basic.lean</a> and I also defined a <code>CommGroup</code> instance. Clearly abelian extension is very useful in my application.</p>",
        "id": 510676824,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744033785
    },
    {
        "content": "<p>Removing the loop in <a href=\"https://github.com/leanprover-community/mathlib4/pull/23773\">#23773</a> make everything runs smoothly (If I understand the results properly). Now, I think that we actually do not need the instance <code>CommGroup -&gt; IsCommutative</code> for abelian extensions. It is enough to have <code>Group + IsCommutative -&gt; CommGroup</code> so that we can promote <code>E ≃ₐ[F] E</code> to a <code>CommGroup</code>.</p>",
        "id": 510716587,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1744043248
    },
    {
        "content": "<p>OK, so when I sent the previous message, I actually had forgotten to rerun <code>!bench</code> first <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span> but now I did run it and the results of the bench of <a href=\"https://github.com/leanprover-community/mathlib4/pull/23773\">#23773</a> are a lot better.</p>",
        "id": 510754315,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1744055381
    },
    {
        "content": "<p>Pretriangulated gets slower but Triangulated gets faster by more :-)</p>",
        "id": 510754617,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744055512
    },
    {
        "content": "<p>It would probably not be difficult to avoid needing <code>CommGroup -&gt; IsCommutative</code> -- presumably the only point of <code>IsCommutative</code> is to get you to <code>CommGroup</code> anyway.</p>",
        "id": 510754803,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744055578
    },
    {
        "content": "<p>That's what I think. In any case,  I checked that <code>Group + IsCommutative -&gt; CommGroup</code> is enough for my needs.</p>",
        "id": 510754998,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1744055652
    },
    {
        "content": "<p>Is this PR WIP or ready for review? If ready for review you should delete the dead code and probably also not call the section <code>test</code>.</p>",
        "id": 510755029,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744055666
    },
    {
        "content": "<p>No. It is not for review (I'll mark it WIP), it was just for testing. If there is an agreement that this is the way to go, I'll clean it up and probably add also the <code>CommMonoid</code> instance and maybe some more.</p>",
        "id": 510755291,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1744055761
    },
    {
        "content": "<p>Well, I'll probably do that anyway so we get something more concrete to discuss about but that will have to wait for tomorrow...</p>",
        "id": 510755636,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1744055867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Abelian.20extension/near/510676824\">said</a>:</p>\n<blockquote>\n<p>BTW I'm trying <code>IsZpExtension</code> here <a href=\"https://github.com/acmepjz/lean-iwasawa/blob/master/Iwasawalib/FieldTheory/ZpExtension/Basic.lean\">https://github.com/acmepjz/lean-iwasawa/blob/master/Iwasawalib/FieldTheory/ZpExtension/Basic.lean</a> and I also defined a <code>CommGroup</code> instance. Clearly abelian extension is very useful in my application.</p>\n</blockquote>\n<p>BTW, although a bit unrelated to this, I think we really need to set up the theory of multiple Zp extensions from the start indexed by a Fintype <code>I</code> and have an <code>abbrev</code> for the special case <code>I=Unit</code> as we do for polynomials.</p>",
        "id": 510830739,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1744084042
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> Maybe we should continue discussing Zp-extension things here <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/channel/116395-maths/topic/Discussion.20on.20formalization.20of.20Iwasawa.20Theory.20in.20Lean/with/510849171\">#maths &gt; Discussion on formalization of Iwasawa Theory in Lean</a>  :)</p>",
        "id": 510850884,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744094764
    },
    {
        "content": "<p>I added more instances to <a href=\"https://github.com/leanprover-community/mathlib4/pull/23773\">#23773</a> and benchmarked the new version. It is not as bad as with the loop but still 3 files got notably slower and the overall slowdown is +0.48%</p>",
        "id": 510950402,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1744122609
    },
    {
        "content": "<p>I looked in details at <code>Mathlib.LinearAlgebra.Semisimple</code> and there is no place where it got significantly slower. It just that everything takes a little more time.</p>",
        "id": 510950639,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1744122679
    },
    {
        "content": "<p>After lowering the priority of the new instances in <a href=\"https://github.com/leanprover-community/mathlib4/pull/23773\">#23773</a>, the slowdown is only +0.15% with only one file <code>Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup</code> significantly slower (+6%).</p>",
        "id": 511135948,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1744195030
    },
    {
        "content": "<p>(but still a bunch of files getting somewhat slower)</p>",
        "id": 511136112,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1744195095
    },
    {
        "content": "<p>The latest version of <a href=\"https://github.com/leanprover-community/mathlib4/pull/23773\">#23773</a> is ready for review. The slowdown is now \"only\" +0.09%.</p>",
        "id": 511204806,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1744212740
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/23773\">#23773</a> has been merged. The proper way to define an abelian extension  is now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.FieldTheory.Galois.Basic</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsGalois</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsMulCommutative</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">CommGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- CommGroup.ofIsMulCommutative</span>\n</code></pre></div>",
        "id": 511347691,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1744274376
    },
    {
        "content": "<p>What is the plan on <a href=\"https://github.com/leanprover-community/mathlib4/pull/23669\">#23669</a> ?<br>\nSpecifically, now that we have <code>IsMulCommutative</code>, do we still add </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsAbelianGalois</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n<span class=\"w\">  </span><span class=\"n\">IsGalois</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsMulCommutative</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>or do we just use <code>[IsGalois F E] [IsMulCommutative (E ≃ₐ[F] E)]</code>?<br>\nI am inclined to still add the class. They are prop valued so they should't cause big trouble. The alternative just feels too clunky for me.</p>",
        "id": 531942676,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1753914442
    },
    {
        "content": "<p>This doesn't quite answer the question, but eventually we might want to write <code>[CommGroup G] [IsGaloisGroup G F E]</code> (using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsGaloisGroup#doc\">docs#IsGaloisGroup</a> to generalize beyond just <code>E ≃ₐ[F] E</code>) .</p>",
        "id": 531947920,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1753916825
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Abelian.20extension/near/531942676\">said</a>:</p>\n<blockquote>\n<p>What is the plan on <a href=\"https://github.com/leanprover-community/mathlib4/pull/23669\">#23669</a> ?<br>\nSpecifically, now that we have <code>IsMulCommutative</code>, do we still add </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsAbelianGalois</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n<span class=\"w\">  </span><span class=\"n\">IsGalois</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsMulCommutative</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>or do we just use <code>[IsGalois F E] [IsMulCommutative (E ≃ₐ[F] E)]</code>?<br>\nI am inclined to still add the class. They are prop valued so they should't cause big trouble. The alternative just feels too clunky for me.</p>\n</blockquote>\n<p>I think adding the class is a good idea.</p>",
        "id": 533608613,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1754783276
    },
    {
        "content": "<p>More classes seems like a bad idea to me</p>",
        "id": 533608725,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754783446
    }
]