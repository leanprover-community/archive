[
    {
        "content": "<p>Can someone who understands <code>simps</code> better than I do help me in linting <a href=\"https://github.com/leanprover-community/mathlib4/pull/2424\">!4#2424</a> ? It seems that <code>simps!</code> on the following line<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/5492db0c40ee02d592f04adb0219fb88800b4916/Mathlib/CategoryTheory/Adjunction/Opposites.lean#L37\">https://github.com/leanprover-community/mathlib4/blob/5492db0c40ee02d592f04adb0219fb88800b4916/Mathlib/CategoryTheory/Adjunction/Opposites.lean#L37</a><br>\nis generating some lemmas which are not passing the simpNF linter. <br>\nIs this a bug in simps or is something else going on here? I'm not sure.</p>",
        "id": 338712461,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677626525
    },
    {
        "content": "<p>The lemmas generated by simps also look quite different from the analogous ones in mathlib3. I think the issue might be that some simp lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Adjunction.homEquiv_unit#doc\">docs4#CategoryTheory.Adjunction.homEquiv_unit</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Adjunction.homEquiv_counit#doc\">docs4#CategoryTheory.Adjunction.homEquiv_counit</a> are not firing.</p>",
        "id": 338713049,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677626831
    },
    {
        "content": "<p>That's despite the fact that they're tagged with <code>simp</code> here:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/b21620a738bdb033f8e5b97ca769d89ae650bfbc/Mathlib/CategoryTheory/Adjunction/Basic.lean#L133\">https://github.com/leanprover-community/mathlib4/blob/b21620a738bdb033f8e5b97ca769d89ae650bfbc/Mathlib/CategoryTheory/Adjunction/Basic.lean#L133</a></p>",
        "id": 338713207,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677626927
    },
    {
        "content": "<p><code>@[simps]</code> never calls <code>simp</code> on the LHS of a lemma, so it has nothing to do with simp not firing.<br>\nThe (LHS of) lemma <code>CategoryTheory.Adjunction.adjointOfOpAdjointOp_homEquiv_apply</code> looks entirely analogue to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.adjunction.adjoint_of_op_adjoint_op_hom_equiv_apply\">docs#category_theory.adjunction.adjoint_of_op_adjoint_op_hom_equiv_apply</a>.</p>\n<p>I'm not sure why this didn't trigger the <code>simp_nf</code> linter in Lean 3. <br>\nIt seems a bit dangerous to generate <code>simp</code> lemmas where the LHS can be simplified further by <code>CategoryTheory.Adjunction.homEquiv_unit</code>. <br>\nIt might have to do that the fact that in Lean 3 this <code>simp</code> lemma had <a href=\"https://github.com/leanprover-community/mathlib/blob/4c586d291f189eecb9d00581aeb3dd998ac34442/src/category_theory/adjunction/basic.lean#L99\">low priority</a>, which is not there in Lean 4. You could try making the priority of those simp attributes low in Lean 4, too. Alternatively, consider using something like <code>initialize_simps_projections Adjunction (-homEquiv)</code> to not generate lemmas for the <code>homEquiv</code> field. Or if you want the <code>homEquiv</code> lemma, but not the <code>homEquiv_apply</code> lemma, you can do this by using <code>@[simps homEquiv unit counit]</code> (this would have to be done for each <code>simps</code>-attribute on an adjunction). Though the last 2 options diverge from the behavior in Lean 3.</p>",
        "id": 338720192,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1677630692
    },
    {
        "content": "<p>The mathlib4 lemma in question has this form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">CategoryTheory.Adjunction.adjointOfOpAdjointOp_homEquiv_apply</span><span class=\"o\">:</span>\n      <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">CategoryTheory.Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">CategoryTheory.Category</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">CategoryTheory.Functor.op</span> <span class=\"n\">G</span> <span class=\"bp\">⊣</span> <span class=\"n\">CategoryTheory.Functor.op</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span>\n          <span class=\"n\">Opposite.unop</span> <span class=\"o\">(</span><span class=\"n\">Prefunctor.obj</span> <span class=\"o\">(</span><span class=\"n\">CategoryTheory.Functor.op</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toPrefunctor</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"bp\">⟶</span>\n            <span class=\"n\">Opposite.unop</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"n\">Y</span><span class=\"o\">)),</span>\n        <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">CategoryTheory.Adjunction.homEquiv</span> <span class=\"o\">(</span><span class=\"n\">CategoryTheory.Adjunction.adjointOfOpAdjointOp</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">=</span>\n          <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">CategoryTheory.opEquiv</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"o\">(</span><span class=\"n\">Prefunctor.obj</span> <span class=\"n\">G.toPrefunctor</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n            <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">Equiv.symm</span> <span class=\"o\">(</span><span class=\"n\">CategoryTheory.Adjunction.homEquiv</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"n\">X</span><span class=\"o\">)))</span>\n              <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">Equiv.symm</span> <span class=\"o\">(</span><span class=\"n\">CategoryTheory.opEquiv</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Opposite.op</span> <span class=\"o\">(</span><span class=\"n\">Prefunctor.obj</span> <span class=\"n\">F.toPrefunctor</span> <span class=\"n\">X</span><span class=\"o\">))))</span>\n                <span class=\"n\">a</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and the mathlib3 version is  <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.adjunction.adjoint_of_op_adjoint_op_hom_equiv_apply\">docs#category_theory.adjunction.adjoint_of_op_adjoint_op_hom_equiv_apply</a></p>",
        "id": 338721210,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677631220
    },
    {
        "content": "<p>The <code>opEquiv/homEquiv</code> in the RHS of the mathlib4 version is never simplified to something involving <code>counit</code></p>",
        "id": 338721256,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677631253
    },
    {
        "content": "<p>I think I do want a lemma involving <code>homEquiv_apply</code> in this case.</p>",
        "id": 338721458,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677631355
    },
    {
        "content": "<p>in any case, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.opEquiv#doc\">docs4#CategoryTheory.opEquiv</a> is tagged with <code>simps</code> as well, so it should <code>dsimp</code>lify away from the RHS, right?</p>",
        "id": 338721570,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677631423
    },
    {
        "content": "<p>oh wait, I had things backwards.</p>",
        "id": 338722189,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677631701
    },
    {
        "content": "<p>sorry, I'm just thinking out loud here...</p>",
        "id": 338722333,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677631774
    },
    {
        "content": "<p>okay, I still think there might be an issue. the linter says </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">adjointOfOpAdjointOp_homEquiv_apply</span> <span class=\"c\">/-</span><span class=\"cm\"> Left-hand side simplifies from</span>\n<span class=\"cm\">  ↑(homEquiv (adjointOfOpAdjointOp F G h) X Y) a✝</span>\n<span class=\"cm\">to</span>\n<span class=\"cm\">  ↑(opEquiv (Opposite.op (Prefunctor.obj G.toPrefunctor (Prefunctor.obj F.toPrefunctor X))) (Opposite.op X))</span>\n<span class=\"cm\">    (↑(Equiv.symm (homEquiv h (Opposite.op (Prefunctor.obj F.toPrefunctor X)) (Opposite.op X)))</span>\n<span class=\"cm\">      (↑(Equiv.symm</span>\n<span class=\"cm\">            (opEquiv (Opposite.op (Prefunctor.obj F.toPrefunctor X)) (Opposite.op (Prefunctor.obj F.toPrefunctor X))))</span>\n<span class=\"cm\">        (𝟙 (Prefunctor.obj F.toPrefunctor X)))) ≫</span>\n<span class=\"cm\">  Prefunctor.map G.toPrefunctor a✝</span>\n</code></pre></div>\n<p>but why isn't the <code>opEquiv</code> simplified away?</p>",
        "id": 338722483,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677631835
    },
    {
        "content": "<p>The <code>simpNF</code> linter only cares about the LHS of lemmas. The RHS of the lemma might be different than in Lean 3, and that will likely have to do with simp lemmas firing or not, but it won't solve the simpNF linter.</p>\n<blockquote>\n<p>but why isn't the opEquiv simplified away?</p>\n</blockquote>\n<p>That is not really a relevant question. To appease the <code>simpNF</code> linter, the LHS should not simplify at all. Which in Lean 3 apparently didn't happen because of low priorities</p>",
        "id": 338722789,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1677631974
    },
    {
        "content": "<p>Ah I see. Thanks for the explanation! I'm not sure what is the best way to proceed. Any ideas?</p>",
        "id": 338722930,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677632043
    },
    {
        "content": "<p>I think <code>attribute [simp low] </code> is a thing in Lean 4, use that for every <code>[priority 10, simp]</code> that was in Lean 3.</p>",
        "id": 338722972,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1677632059
    },
    {
        "content": "<p>so my suggestion is to modify <code>simp</code> priorities in the already ported Adjunction file, to match Lean 3</p>",
        "id": 338723068,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1677632134
    },
    {
        "content": "<p>I see. Perhaps it wouldn't hurt to only generate a <code>homEquiv</code> lemma without the <code>homEquiv_apply</code> variant.</p>",
        "id": 338723146,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677632167
    },
    {
        "content": "<p>I think that would be an improvement (albeit not what we did in Lean 3).</p>",
        "id": 338723192,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1677632204
    },
    {
        "content": "<p>Though it might have downsides, since the right-hand sides of such lemmas could be really large.</p>",
        "id": 338723289,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1677632264
    },
    {
        "content": "<p>yeah, but it's large even with the apply variant because nothing gets simplified away <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 338723375,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677632294
    },
    {
        "content": "<p>That is something else worth investigating, yeah. I wonder why <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.opEquiv_apply#doc\">docs4#CategoryTheory.opEquiv_apply</a> doesn't apply. Maybe the coercion is different? I'm going to stop investigating for now.</p>",
        "id": 338723872,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1677632598
    },
    {
        "content": "<p>Yeah same here... I need to cook dinner. BTW, for my own understanding, what's the rationale for why simps doesnt simplify the LHS?</p>",
        "id": 338724215,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677632770
    },
    {
        "content": "<p>Because there shouldn't be another simp lemma that applies to the LHS.</p>",
        "id": 338781592,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1677662869
    }
]