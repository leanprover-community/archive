[
    {
        "content": "<p>(deleted)</p>",
        "id": 379298461,
        "sender_full_name": "Calvin Lee",
        "timestamp": 1690490725
    },
    {
        "content": "<p>Here's my <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem:<br>\nI'm working on the definition of krull dimension for prime ideals in a ring.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Ideal.height</span>  <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">IsPrime</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">WithBot</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">|&gt;</span> <span class=\"n\">height</span> <span class=\"o\">(</span><span class=\"n\">PrimeSpectrum</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>in particular, this definition needs typeclass search to find a proof that the ideal is prime, which works well for elements of the prime and maximal spectrums of R.</p>\n<p>However, consider the following theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">minimal_primes_height_1_of_principal</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">minimalPrimes</span><span class=\"o\">,</span> <span class=\"n\">p.height</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In this case, we <code>p.height</code> fails to synthesize the instance <code>IsPrime p</code>, as all we know is <code>p : Ideal R</code>, and we cannot determine that p is prime even though this is evident from <code>p</code>'s membership in the set of minimal primes.</p>\n<p>I have tried to remedy this with typeclass instances, such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">minimalPrimes_isPrime</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">I.minimalPrimes</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">p.IsPrime</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but this does not work (in fact, I see <code>h : p ∈ I.minimalPrimes</code> nowhere in the environment when using <code>∀ p ∈ I.minimalPrimes</code> notation).</p>\n<p>Is there any way to make typeclass search work well with <code>mem</code> notation? and use facts about membership to synthesize instances? Or should I rethink the definition of <code>minimalPrimes</code> in Mathlib to instead return an entirely different type that encodes primality more explicitly (such as <code>Set PrimeSpectrum</code>).</p>",
        "id": 379300720,
        "sender_full_name": "Calvin Lee",
        "timestamp": 1690491393
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Ideal.height</span>  <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">IsPrime</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">WithBot</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">|&gt;</span> <span class=\"n\">height</span> <span class=\"o\">(</span><span class=\"n\">PrimeSpectrum</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Ideal</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">minimal_primes_height_1_of_principal</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">minimalPrimes</span><span class=\"o\">,</span>\n    <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">IsPrime</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">p.height</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 379308238,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690494149
    },
    {
        "content": "<p>right, so i can technically make it work with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">minimal_primes_height_1_of_principal</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">minimalPrimes</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Ideal.height</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">minimalPrimes_isPrime</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>using my instance from before, but this is horrible</p>",
        "id": 379315199,
        "sender_full_name": "Calvin Lee",
        "timestamp": 1690496956
    },
    {
        "content": "<p>Right, and I'm suggesting that my version is less horrible</p>",
        "id": 379319984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690499360
    },
    {
        "content": "<p>Your instance will never fire unless explicitly invoked because typeclass inference can't find <code>h</code>.</p>",
        "id": 379320202,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690499476
    },
    {
        "content": "<p>I agree that yours is better, but it's still a bit of work whenever you need to show that an element of the set of minimalPrimes is prime (which seems rather common to me)<br>\nMaybe it would be better to change <code>Ideal.minimalPrimes</code> to have type <code>Set (PrimeSpectrum R)</code> with better <code>coe</code> from <code>PrimeSpectrum</code> to <code>Ideal</code>, since that type contains a witness of primality in a much more straightforward way</p>",
        "id": 379346080,
        "sender_full_name": "Calvin Lee",
        "timestamp": 1690512041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Typeclass.20search.20for.20mem.20notation/near/379308238\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Ideal.height</span>  <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">IsPrime</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">WithBot</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">|&gt;</span> <span class=\"n\">height</span> <span class=\"o\">(</span><span class=\"n\">PrimeSpectrum</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Ideal</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">minimal_primes_height_1_of_principal</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">minimalPrimes</span><span class=\"o\">,</span>\n    <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">IsPrime</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">p.height</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>why are we using <code>haveI</code> here?</p>",
        "id": 379443492,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1690539595
    },
    {
        "content": "<p><code>haveI</code> prevents a let appearing in the theorem statement</p>",
        "id": 379450977,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690540781
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"382349\">@Calvin Lee</span> if you want to take on that refactor of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.minimalPrimes#doc\">docs#Ideal.minimalPrimes</a> (which would probably then need renaming to <code>PrimeSpectrum.minimalPrimes</code>) then my <em>guess</em> is that there won't be too many objections. I am not too upset about the version I proposed with the <code>haveI</code> but perhaps I'm just used to this sort of thing occasionally occuring in theorem statements.</p>",
        "id": 379489064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690547742
    }
]