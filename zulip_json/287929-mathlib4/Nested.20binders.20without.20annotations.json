[
    {
        "content": "<p>I just hit a (Lean 4? Std?) regression in the way nested binders are handled. All examples work in Lean3.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">myPred</span>  <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">myPred</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- expected ',' or binderPred</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">myPred</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- expected ',' or binderPred</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">myPred</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- works</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">myPred</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 388847287,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1693763717
    },
    {
        "content": "<p>(I'm happy for this thread to be moved to <a class=\"stream\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4\">#lean4</a> if this is a Lean 4 issue. I must say it's hard to know which library does what precisely these days)</p>",
        "id": 388847375,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1693763775
    },
    {
        "content": "<p>Here's a tip for how to figure out who might be responsible for what notation: right click a salient part of the notation and do \"Go to Declaration\" in VS Code. For the working multiple-binders exists notation, that leads to <a href=\"https://github.com/leanprover/lean4/blob/66e1472c7ed27e4690340fb4b5bb3093a7265cf3/src/Init/NotationExtra.lean#L83\">this line of Init.NotationExtra</a>, so it turns out to be Lean 4.</p>\n<p>That syntax definition says that what comes after <code>∃</code> is an <code>explicitBinders</code>, and going to definition we can see this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"n\">unbracketedExplicitBinders</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ppSpace</span> <span class=\"n\">binderIdent</span><span class=\"o\">)</span><span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"s2\">\" : \"</span> <span class=\"n\">term</span><span class=\"o\">)</span><span class=\"bp\">?</span>\n<span class=\"n\">syntax</span> <span class=\"n\">bracketedExplicitBinders</span>   <span class=\"o\">:=</span> <span class=\"s2\">\"(\"</span> <span class=\"n\">withoutPosition</span><span class=\"o\">((</span><span class=\"n\">binderIdent</span> <span class=\"n\">ppSpace</span><span class=\"o\">)</span><span class=\"bp\">+</span> <span class=\"s2\">\": \"</span> <span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"s2\">\")\"</span>\n<span class=\"n\">syntax</span> <span class=\"n\">explicitBinders</span>            <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ppSpace</span> <span class=\"n\">bracketedExplicitBinders</span><span class=\"o\">)</span><span class=\"bp\">+</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">unbracketedExplicitBinders</span>\n</code></pre></div>\n<p>Simplified,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"n\">unbracketedExplicitBinders</span> <span class=\"o\">:=</span> <span class=\"n\">binderIdent</span><span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"s2\">\" : \"</span> <span class=\"n\">term</span><span class=\"o\">)</span><span class=\"bp\">?</span>\n<span class=\"n\">syntax</span> <span class=\"n\">bracketedExplicitBinders</span>   <span class=\"o\">:=</span> <span class=\"s2\">\"(\"</span> <span class=\"n\">binderIdent</span><span class=\"bp\">+</span> <span class=\"s2\">\": \"</span> <span class=\"n\">term</span> <span class=\"s2\">\")\"</span>\n<span class=\"n\">syntax</span> <span class=\"n\">explicitBinders</span>            <span class=\"o\">:=</span> <span class=\"n\">bracketedExplicitBinders</span><span class=\"bp\">+</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">unbracketedExplicitBinders</span>\n</code></pre></div>\n<p>So, it doesn't allow mixing bracketed binders and unbracketed binders. And furthermore, it doesn't allow <code>∃ (a) (h : myPred a), True</code>, which might have been a convenient shorthand for <code>∃ (a : _) (h : myPred a), True</code>.</p>\n<p>Mixing bracketed and unbracketed binders is probably not allowed because there is a parsing issue: when you're parsing <code>∃ a b c : X, True</code> you don't know if you should only have unbracketed binders until you get to the <code>:</code>. However, <code>fun</code> notation allows mixed binders, so it's not impossible.</p>",
        "id": 388856100,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693770383
    },
    {
        "content": "<p>Good point. I actually tried <code>∃ (a) (h : myPred a), True</code> but decided it wasn't relevant.</p>",
        "id": 388856139,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1693770440
    },
    {
        "content": "<p>We can Go To Declaration on <code>fun</code> too to see how it's syntax works. Here are the relevant definitions, simplified and using <code>syntax</code> notation.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"n\">funBinder</span> <span class=\"o\">:=</span> <span class=\"n\">funStrictImplicitBinder</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">funImplicitBinder</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">instBinder</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"n\">max</span>\n<span class=\"n\">syntax</span> <span class=\"n\">basicFun</span> <span class=\"o\">:=</span> <span class=\"n\">funBinder</span><span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"s2\">\":\"</span> <span class=\"n\">term</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"s2\">\" =&gt;\"</span> <span class=\"n\">term</span>\n<span class=\"n\">syntax</span> <span class=\"bp\">«</span><span class=\"k\">fun</span><span class=\"bp\">»</span> <span class=\"o\">:=</span> <span class=\"s2\">\"fun\"</span> <span class=\"o\">(</span><span class=\"n\">basicFun</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">matchAlts</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>So, the way it works is that it parses a sequence of binders (or <code>term</code>s!) and then optionally a <code>: type</code>. It's then up to the <code>fun</code> elaborator to mak sure that if <code>: type</code> is present then the only things preceding it are identifiers.</p>",
        "id": 388856377,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693770642
    },
    {
        "content": "<p>(I've been thinking of these things anyway because I've been wanting to make the binders that appear in notations defined by mathlib's <code>notation3</code> command to be more flexible. It'd be nice to use this <code>fun</code> setup there I think, along with our extended binders.)</p>",
        "id": 388856507,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693770730
    },
    {
        "content": "<p>It's annoying that this syntax is defined in core Lean. It seems that the bar for PRs there got much higher recently <span aria-label=\"half frown\" class=\"emoji emoji-1f615\" role=\"img\" title=\"half frown\">:half_frown:</span></p>",
        "id": 388856664,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1693770837
    },
    {
        "content": "<p>Exists could be more flexible with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"n\">bracketedExplicitBinders</span>   <span class=\"o\">:=</span> <span class=\"s2\">\"(\"</span> <span class=\"n\">binderIdent</span><span class=\"bp\">+</span> <span class=\"s2\">\": \"</span> <span class=\"n\">term</span> <span class=\"s2\">\")\"</span>\n<span class=\"n\">syntax</span> <span class=\"n\">explicitBinders</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">bracketedExplicitBinders</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">binderIdent</span><span class=\"o\">)</span><span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"s2\">\":\"</span> <span class=\"n\">term</span><span class=\"o\">)</span><span class=\"bp\">?</span>\n</code></pre></div>",
        "id": 388856847,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693770956
    },
    {
        "content": "<p>I just thought to compare it with forall, and this turns out to be essentially its binder syntax:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"bp\">«</span><span class=\"k\">forall</span><span class=\"bp\">»</span> <span class=\"o\">:=</span> <span class=\"s2\">\"∀\"</span> <span class=\"o\">(</span><span class=\"n\">binderIdent</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">bracketedBinder</span><span class=\"o\">)</span><span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"s2\">\":\"</span> <span class=\"n\">term</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"s2\">\", \"</span> <span class=\"n\">term</span>\n</code></pre></div>\n<p>though <code>bracketedBinder</code> supports other types of binders too.</p>",
        "id": 388856936,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693771019
    },
    {
        "content": "<p>For a Lean PR, we'd need an RFC, and there are a number of points we need to cover <a href=\"https://github.com/leanprover/lean4/blob/master/doc/contributions.md\">link</a></p>\n<p>For impact to code, <code>explicitBinders</code> only used for a few notations in Lean 4, it's never mentioned by name in Std4 (though it likely needs patching), and Mathlib uses it once for <code>∃!</code>. Std4 mentions that it'd be nice to upstream letting <code>bracketedExplicitBinders</code> have an optional type, though that would impact <code>(x : X) × Y x</code> sigma notation (you don't want <code>(X) × Y</code> to mean <code>(X : _) × Y</code>!).</p>",
        "id": 388857553,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693771444
    },
    {
        "content": "<p>(I'll just mention that we can let mathlib have our own exists notation entirely since we can set a high-priority parse. I'd rather not go down this route for mathlib, but at least it's something you could have in your own projects.)</p>",
        "id": 388857691,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693771537
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Nested.20binders.20without.20annotations/near/388856664\">said</a>:</p>\n<blockquote>\n<p>It's annoying that this syntax is defined in core Lean. It seems that the bar for PRs there got much higher recently <span aria-label=\"half frown\" class=\"emoji emoji-1f615\" role=\"img\" title=\"half frown\">:half_frown:</span></p>\n</blockquote>\n<p>My understanding from Leo was that Lean 4 was designed with so much flexibility in mind that if you don't like something then you can change it without having to make PRs to core Lean. Would that principle apply here? (oh maybe that's what Kyle is saying above?)</p>",
        "id": 388857776,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1693771575
    },
    {
        "content": "<p>He did say that, but he also said that he wished for fragmentation not to happen (at least between Core and Std, don't know how much that applies to mathlib).</p>",
        "id": 388858026,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1693771747
    },
    {
        "content": "<p>Yeah, I'm saying it's flexible enough that we can override it in mathlib, but I think for <code>Exists</code> it would be much better if it were just made to be more consistent with other notations (like forall and fun).</p>\n<p>If we're careful about making our new notations be extensions of pre-existing notations, then it's not so bad, but if you're not careful you can end up with libraries with mutually unintelligible dialects of Lean.</p>\n<p>Syntax extension is fun but it's dangerous for large projects. Luckily mathlib is for mathematicians, who are used to needing to learn new notations (and maybe enjoy it?). Software engineers tend to be much more wary of these sorts of features.</p>",
        "id": 388858412,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693772039
    },
    {
        "content": "<p>I'm very thankful for \"Go to Declaration\" for custom (and core!) syntax, which makes dealing with this feature (and learning Lean 4) so much more manageable.</p>",
        "id": 388858595,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693772179
    },
    {
        "content": "<p>Kyle, I assume you already know <code>⨆ i j, f i j</code> currently doesn't parse?</p>",
        "id": 388861622,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1693774428
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Turns out this is all that's needed to get Exists work with your test cases and also with destructuring.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MyExists</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">myExists</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span>\n  <span class=\"s2\">\"∃\"</span> <span class=\"o\">(</span><span class=\"n\">ppSpace</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"o\">)</span><span class=\"bp\">+</span> <span class=\"n\">Term.optType</span> <span class=\"s2\">\", \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">bs</span><span class=\"o\">]</span><span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"o\">[:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"bp\">?</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">show</span> <span class=\"n\">MacroM</span> <span class=\"n\">Term</span> <span class=\"k\">from</span>\n    <span class=\"n\">bs.foldrM</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Exists</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">$</span><span class=\"o\">[:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"bp\">?</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">))</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MyExists</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myPred</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">myPred</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">myPred</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">myPred</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">myPred</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- unexpected type ascription</span>\n</code></pre></div>",
        "id": 388863821,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693776079
    },
    {
        "content": "<p>(Yeah, I think I knew about <code>⨆ i j, f i j</code>. You should be able to write <code>⨆ (i) (j), f i j</code> as a workaround.)</p>",
        "id": 388864137,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693776258
    },
    {
        "content": "<p>I can confirm that it is incredibly annoying that the syntax of <code>fun</code>, <code>forall</code> and <code>exists</code> is not consistent. This made mathport have some very annoying code to convert between them</p>",
        "id": 388900849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693799322
    },
    {
        "content": "<p>So this is a core lean issue?</p>",
        "id": 388919343,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1693809695
    },
    {
        "content": "<p>yes, this is inconsistency of the lean grammar</p>",
        "id": 389065328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693869783
    }
]