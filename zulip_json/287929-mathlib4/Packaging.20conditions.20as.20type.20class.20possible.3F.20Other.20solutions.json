[
    {
        "content": "<p>Hi, I find that lists of variables can get rather long. Imagine trying PL-topology without going straight into R^n. Is there a way to simplify such variable lists? Here is an easy and limited example from purely algebraic \"PL-topology\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- These are the typs that are needed -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">AlgebraicPLSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">is_StrictOrderedCommRing</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">StrictOrderedCommRing</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span>\n<span class=\"w\">  </span><span class=\"n\">is_AddCommGroup</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">is_Module</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">is_NoZeroSMulDivisors</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NoZeroSMulDivisors</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">is_AddTorsor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddTorsor</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">P</span>\n\n<span class=\"sd\">/-- OK, this here does noit compile. Trying tu use Coe's of various kinds does not help: -/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AlgebraicPLSpace</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">affineSegment</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"sd\">/-- This would be the way out. But I need to repeat this too often! -/</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OrderedCommRing</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NoZeroSMulDivisors</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddTorsor</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Or would I write a mcro that expands as follows: -/</span>\n<span class=\"c1\">-- variables [AlgebraicPLSpace ğ•œ V P] ---- expandes to ----&gt; the variable list above?</span>\n</code></pre></div>\n<p>Any thoughts. And sorry, if this has been asked before.<br>\nCheers, Stephan</p>",
        "id": 440303336,
        "sender_full_name": "Stephan Maier",
        "timestamp": 1716464042
    },
    {
        "content": "<p>I have not been able to test this, since I don't know exactly what to import to make this compile. But have you tried adding:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AlgebraicPLSpace</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">StrictOrderedCommRing</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h.is_StrictOrderedCommRing</span>\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AlgebraicPLSpace</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h.is_AddCommGroup</span>\n<span class=\"o\">(</span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">so</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>before <code>example [AlgebraicPLSpace ğ•œ V P] (x y : P) := affineSegment ğ•œ x y</code>? This should make it so that lean can deduce <code>StrictOrderedCommRing</code> from a given instance of <code>AlgebraicPLSpace</code>.</p>",
        "id": 440306255,
        "sender_full_name": "Calle SÃ¶nne",
        "timestamp": 1716465156
    },
    {
        "content": "<p>I'm afraid it is not technically possible to follow Calle's approach or Stephan's first approach: the problem here is that to find an instance of e.g. <code>StrictOrderedCommRing ğ•œ</code> from an instance of <code>AlgebraicPLSpace ğ•œ _ _</code>, the problem is in figuring out what the V and P are supposed to be that fill in the <code>_</code>s. In principle that could be any type. So the algorithm doesn't like these instances.</p>",
        "id": 440310181,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1716466676
    },
    {
        "content": "<p>There have been various proposals for a macro that would expand <code>[AlgebraicPLSpace ğ•œ V P]</code> into a full list of instances, but they have been less popular for various reasons. Mostly to do with how to deal with variables that have already been declared. That is, questions like: assume we have a line above <code>variable [Field ğ•œ]</code>, should <code>[AlgebraicPLSpace ğ•œ V P]</code> be smart enough to expand into <code>[OrderedField ğ•œ]</code> instead of <code>[OrderedCommRing ğ•œ]</code>?</p>",
        "id": 440310546,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1716466813
    },
    {
        "content": "<p>For now, the closest we have is <code>variable? [AlgebraicPLSpace ğ•œ V P]</code> which return the full <code>variable</code> declaration as a suggestion. At least that should save you some typing, even if reading the full declaration is still extremely long.</p>",
        "id": 440310781,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1716466909
    },
    {
        "content": "<p>Oh I see, sorry about that!</p>",
        "id": 440314275,
        "sender_full_name": "Calle SÃ¶nne",
        "timestamp": 1716468152
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Packaging.20conditions.20as.20type.20class.20possible.3F.20Other.20solutions/near/440310181\">said</a>:</p>\n<blockquote>\n<p>I'm afraid it is not technically possible to follow Calle's approach or Stephan's first approach: the problem here is that to find an instance of e.g. <code>StrictOrderedCommRing ğ•œ</code> from an instance of <code>AlgebraicPLSpace ğ•œ _ _</code>, the problem is in figuring out what the V and P are supposed to be that fill in the <code>_</code>s. In principle that could be any type. So the algorithm doesn't like these instances.</p>\n</blockquote>\n<p>Thanks a lot. I suspected as much. I did try what Calle proposed. Never mind. I appreciate that interferences are a chelenge when generating code. So I rest my case. Thanks for the hint with variable?.</p>",
        "id": 440367713,
        "sender_full_name": "Stephan Maier",
        "timestamp": 1716485144
    }
]