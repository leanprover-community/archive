[
    {
        "content": "<p>Is it a known issue that <code>Finset.sum</code> does not pretty-print?  Consider</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Linarith</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"bp\">‚àë</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"n\">IH</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sum_range_succ</span><span class=\"o\">]</span> <span class=\"bp\">;</span> <span class=\"n\">linarith</span>\n</code></pre></div>\n<p>The goal at the start of the proof displays as</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>(2 * Finset.sum (range (n + 1)) fun i ‚Ü¶ i) = n * (n + 1)\n</code></pre></div>",
        "id": 355262783,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683060672
    },
    {
        "content": "<p>I noticed <a href=\"https://github.com/leanprover-community/mathlib4/pull/2724\">!4#2724</a>, \"Pretty printing for functors and other nested structures\" -- not sure if this is the same issue.</p>",
        "id": 355262862,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683060703
    },
    {
        "content": "<p>Is this caused by the <code>‚Ü¶</code> delaborator?</p>",
        "id": 355263550,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683060912
    },
    {
        "content": "<p>As far as I know there's no delaborator for <code>Finset.sum</code>, which is what's needed for pretty printing.</p>",
        "id": 355264531,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683061248
    },
    {
        "content": "<p>Perhaps this can be my opportunity to learn what a delaborator is.</p>",
        "id": 355264801,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683061335
    },
    {
        "content": "<p>What's a delaborator and why didn't we need them in Lean 3?</p>",
        "id": 355264826,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683061346
    },
    {
        "content": "<p>Should we be requiring that every new notation in mathlib come with a delaborator?</p>",
        "id": 355265178,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683061475
    },
    {
        "content": "<p><a href=\"https://github.com/arthurpaulino/lean4-metaprogramming-book/blob/master/md/extra/pretty-printing.md\">This section</a> of the metaprogramming book might be particularly relevant! Basically, as you might have guessed from the name, a delaborator does the opposite of elaboration; that means it turns <code>Expr</code>s back into <code>Syntax</code> for display.</p>",
        "id": 355266269,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1683061823
    },
    {
        "content": "<p>OK, but</p>\n<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Pretty-printing.20of.20sums/near/355264826\">said</a>:</p>\n<blockquote>\n<p>why didn't we need them in Lean 3?</p>\n</blockquote>\n<p>?</p>",
        "id": 355266505,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683061906
    },
    {
        "content": "<p>This is the price to pay for Lean 4's much greater notation flexibility I think.</p>",
        "id": 355266596,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1683061928
    },
    {
        "content": "<p>As a non-lean 3 user, my best guess is the handwavey ‚Äúnew metaprogramming framework!‚Äù answer üòÖ</p>",
        "id": 355266670,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1683061960
    },
    {
        "content": "<p>So:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Pretty-printing.20of.20sums/near/355265178\">said</a>:</p>\n<blockquote>\n<p>Should we be requiring that every new notation in mathlib come with a delaborator?</p>\n</blockquote>",
        "id": 355266763,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683062010
    },
    {
        "content": "<p>I‚Äôm under the impression that the <code>notation</code> command introduces delaborators, but I could be wrong. Let me check‚Ä¶</p>",
        "id": 355266768,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1683062012
    },
    {
        "content": "<p>It does, but only in simple cases.</p>",
        "id": 355266909,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1683062062
    },
    {
        "content": "<p>Is there a way to get the <code>notation</code> command to throw an error if it can't autogenerate the appropriate delaborator and there is no accompanying delaborator?</p>",
        "id": 355267328,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683062254
    },
    {
        "content": "<p>I'm far from an expert in this, but maybe detecting failure isn't so easy. The command probably generates something, but it may not be good enough.</p>",
        "id": 355267546,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1683062339
    },
    {
        "content": "<p>It looks like <code>mkUnexpander</code> is the thing that generates the delaborator, and is allowed to succeed or fail when the notation is made. Not sure if successes in <code>mkUnexpander</code> might still nonetheless be ‚Äúnot good enough‚Äù/the ‚Äúwrong‚Äù delaborator, though.</p>",
        "id": 355267771,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1683062435
    },
    {
        "content": "<p>I second the notion of at least reporting that failure though! :)</p>",
        "id": 355267799,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1683062453
    },
    {
        "content": "<p>Though, that‚Äôs in core; maybe in the meantime it would make sense to have a mathlib-based command <code>notation?</code> like <code>simps?</code> which displayed any delaborators made?</p>",
        "id": 355268000,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1683062538
    },
    {
        "content": "<p>Let's also think about a way to track this.  It seems like it will come up all the time.  Should we have a missing-delaborator tracking issue, like we had a tactic porting issue?</p>",
        "id": 355268042,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683062557
    },
    {
        "content": "<p>I would support that. :)</p>",
        "id": 355268332,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1683062680
    },
    {
        "content": "<p>Oh, another idea: what about a linter to check when notation failed to generate an unexpander? We could probably do this just by re-running <code>mkUnexpander</code> on the right arguments.</p>",
        "id": 355268438,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1683062724
    },
    {
        "content": "<p>(Or, if we have access to it, we could just check how many children the syntax node generated by <code>notation</code> produces‚Äîit‚Äôs 2 if there‚Äôs no delaborator and 3 if there is. I‚Äôm still not sure how linters work, tbh. üòÅ)</p>",
        "id": 355269157,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1683063071
    },
    {
        "content": "<p>A message or linter is possible, but a bit besides the original point: the <code>Finset.sum</code> notation is not a <code>notation</code>, but a non-trivial macro with custom binding syntax, whereas all of this was built-in in Lean 3. So this is already a somewhat advanced example and one really shouldn't expect Lean to automatically construct an unexpander here. Though I wonder whether someone has explored autogenerating unexpanders from <code>macro_rules</code> yet.</p>",
        "id": 355269329,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1683063138
    },
    {
        "content": "<p>Sebastian, from a user's perspective it is still hard to understand why Lean 3 had a way for users to define such a notation and get an unexpander for free and Lean 4 doesn't.</p>",
        "id": 355269490,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1683063225
    },
    {
        "content": "<p>It's great that we can have more complicated notations now, but it would be even greater if simple things could remain simple.</p>",
        "id": 355269605,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1683063265
    },
    {
        "content": "<p>Indeed ... is it not possible or is the answer is just \"we haven't got round to it yet\"?</p>",
        "id": 355269652,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683063295
    },
    {
        "content": "<p>(Of course I appreciate that it is nontrivial work to offer features like this.)</p>",
        "id": 355269783,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683063358
    },
    {
        "content": "<p>While we're at it, I noticed that <code>Set.union·µ¢</code> is apparently also missing its delaborator.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Lattice</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">‚ãÉ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- goal is `(union·µ¢ fun i ‚Ü¶ {i, i + 1}) = univ`</span>\n  <span class=\"n\">ext</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 355271941,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683064402
    },
    {
        "content": "<p>Well this has all been moved to std/mathlib4 so needs to be addressed there, but there is no intrinsic reason this should make creating notations with binders harder than in Lean 3. In fact I would hope it should become easier than in Lean 3 because who can ever remember what's going on in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"bp\">`‚àë`</span> <span class=\"n\">binders</span> <span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span> <span class=\"n\">r</span><span class=\"o\">:(</span><span class=\"n\">scoped</span><span class=\"o\">:</span><span class=\"mi\">67</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">finset.sum</span> <span class=\"n\">finset.univ</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">r</span>\n</code></pre></div>\n<p>So once we know what we actually want to end up with, this could be addressed in mathlib4.</p>",
        "id": 355272152,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1683064516
    },
    {
        "content": "<p>I think</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">scoped</span> <span class=\"n\">macro</span> <span class=\"s2\">\"‚àè \"</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">extBinder</span> <span class=\"s2\">\", \"</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">:</span><span class=\"mi\">67</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"n\">Finset.prod</span> <span class=\"n\">Finset.univ</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">‚Ü¶</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>would be a reasonable representation and only needs a missing <code>TSyntax</code> coercion to work in the forward direction. Then mathlib4 could either override the <code>macro</code> command (I think people avoid doing that, which is probably a good idea) or introduce a new attribute to autogenerate the unexpander from that by specifically looking for that coercion.</p>",
        "id": 355273723,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1683065192
    },
    {
        "content": "<p>And of course the more limited you want to make the abstraction, the simpler it can be. It could be as short as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">bigop_notation</span> <span class=\"s2\">\"‚àè \"</span><span class=\"o\">:</span><span class=\"mi\">67</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Finset.prod</span> <span class=\"n\">Finset.univ</span>\n</code></pre></div>\n<p>to cover examples without extra <code>in</code> etc.</p>",
        "id": 355274005,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1683065331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Pretty-printing.20of.20sums/near/355264826\">said</a>:</p>\n<blockquote>\n<p>What's a delaborator</p>\n</blockquote>\n<p>Here are all the words in one place:</p>\n<p>String ---(parser)---&gt; Syntax ---(elaborator)---&gt; Expr ---(delaborator)---&gt; Syntax ---(formatter)---&gt; String</p>\n<p>The elaborator is flexible, and you can make your own plugins (themselves called elaborators) to extend it. One type of elaborator, a \"macro\", is a Syntax -&gt; Syntax transformation.</p>\n<p>The delaborator is also flexible. There's something like an antimacro, an \"unexpander,\" also for Syntax -&gt; Syntax transformations.</p>\n<p>In Lean 3, there was much less flexibility. The above diagram looked like this:</p>\n<p>String ---(parser)---&gt; Expr ---(elaborator)---&gt; Expr --(pretty printer)--&gt; String</p>\n<p>(There was no difference between unelaborated and elaborated Expr types.)</p>\n<p>Notation in Lean 3 is completely handled by the parser and pretty printer. All the notations are stored in a single table, with high-level descriptions of how to parse each notation and how they expand into Exprs, and the parser and pretty printer have special code for how to interpret these descriptions. As Sebastian has been saying, the Lean 4 version is that we just need to get around to writing commands that add elaborators and delaborators automatically. This would replace the less flexible notation table in Lean 3.</p>",
        "id": 355279588,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683067952
    },
    {
        "content": "<p>At a high level, the point is that Lean 3's <code>notation</code> table was intrinsically invertible (at least in theory). Being able to define elaborators and delaborators separately is much more powerful, but you do lose that automatic invertibility.</p>",
        "id": 355279876,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683068082
    },
    {
        "content": "<p>Would it be worth writing a special command for invertible notation, which works in a smaller set of cases but is more user-friendly (replicating the lean 3 experience) in those cases?</p>",
        "id": 355280007,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683068147
    },
    {
        "content": "<p>If you have time, Kyle -- can you augment your explanation above with where notation fits into the story in Lean 4?  Is notation a macro?</p>",
        "id": 355280268,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683068248
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Pretty-printing.20of.20sums/near/355280007\">said</a>:</p>\n<blockquote>\n<p>Would it be worth writing a special command for invertible notation, which works in a smaller set of cases but is more user-friendly (replicating the lean 3 experience) in those cases?</p>\n</blockquote>\n<p>Yeah, I think this is exactly what Sebastian is suggesting: figure out what would be a good notation command that would make things at least as user-friendly as the Lean 3 one (including invertibility).</p>",
        "id": 355280519,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683068345
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Pretty-printing.20of.20sums/near/355280268\">said</a>:</p>\n<blockquote>\n<p>can you augment your explanation above with where notation fits into the story in Lean 4?  Is notation a macro?</p>\n</blockquote>\n<p>Indeed, the <code>notation</code> command <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Notation.lean#L163\">is a macro</a> that creates a macro and (hopefully) an unexpander. It looks like <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> already brought up <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Notation.lean#L86\"><code>mkUnexpander</code></a>, which is a supporting function in that file to try to derive the unexpander to reverse the notation.</p>",
        "id": 355281821,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683068974
    },
    {
        "content": "<p>I have also seen <code>notation3</code> in use, and its docstring says</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>`notation3` declares notation using Lean 3-style syntax.\n</code></pre></div>\n<p>So should we maybe just make more extensive use of <code>notation3</code>?  For example, we could switch the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set#doc\">docs4#Set</a>.union·µ¢ and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sum#doc\">docs4#Finset.sum</a> macros to use <code>notation3</code>?</p>",
        "id": 355282415,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683069313
    },
    {
        "content": "<p>Here's an implementation of some <code>Finset.prod</code> and <code>Finset.sum</code> delaborators:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">BigOperators</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Parser.Term</span> <span class=\"n\">PrettyPrinter.Delaborator</span> <span class=\"n\">SubExpr</span>\n<span class=\"kn\">open</span> <span class=\"n\">Std.ExtendedBinder</span>\n\n<span class=\"kd\">@[scoped delab app.Finset.prod]</span> <span class=\"kd\">def</span> <span class=\"n\">delabFinsetProd</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">‚Üê</span> <span class=\"n\">getExpr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getAppArgs</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n  <span class=\"n\">guard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">f.isLambda</span>\n  <span class=\"k\">let</span> <span class=\"n\">ppDomain</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">getPPOption</span> <span class=\"n\">getPPPiBinderTypes</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">body</span><span class=\"o\">)</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">withAppArg</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">withBindingBodyUnusedName</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">body</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">delab</span>\n    <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">body</span><span class=\"o\">)</span>\n  <span class=\"k\">if</span> <span class=\"n\">s.isAppOfArity</span> <span class=\"bp\">``</span><span class=\"n\">Finset.univ</span> <span class=\"mi\">2</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"n\">binder</span> <span class=\"bp\">‚Üê</span> <span class=\"k\">if</span> <span class=\"n\">ppDomain</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">withAppArg</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">withBindingDomain</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">delab</span>\n      <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">extBinder</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">i</span><span class=\"o\">):</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span>\n      <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">extBinder</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">i</span><span class=\"o\">):</span><span class=\"n\">ident</span><span class=\"o\">)</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">‚àè</span> <span class=\"bp\">$</span><span class=\"n\">binder</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">body</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">let</span> <span class=\"n\">ss</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">withAppFn</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">withAppArg</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">delab</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">‚àè</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">i</span><span class=\"o\">):</span><span class=\"n\">ident</span> <span class=\"k\">in</span> <span class=\"bp\">$</span><span class=\"n\">ss</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">body</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[scoped delab app.Finset.sum]</span> <span class=\"kd\">def</span> <span class=\"n\">delabFinsetSum</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">‚Üê</span> <span class=\"n\">getExpr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getAppArgs</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n  <span class=\"n\">guard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">f.isLambda</span>\n  <span class=\"k\">let</span> <span class=\"n\">ppDomain</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">getPPOption</span> <span class=\"n\">getPPPiBinderTypes</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">body</span><span class=\"o\">)</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">withAppArg</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">withBindingBodyUnusedName</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">body</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">delab</span>\n    <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">body</span><span class=\"o\">)</span>\n  <span class=\"k\">if</span> <span class=\"n\">s.isAppOfArity</span> <span class=\"bp\">``</span><span class=\"n\">Finset.univ</span> <span class=\"mi\">2</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"n\">binder</span> <span class=\"bp\">‚Üê</span> <span class=\"k\">if</span> <span class=\"n\">ppDomain</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">withAppArg</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">withBindingDomain</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">delab</span>\n      <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">extBinder</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">i</span><span class=\"o\">):</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span>\n      <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">extBinder</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">i</span><span class=\"o\">):</span><span class=\"n\">ident</span><span class=\"o\">)</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">‚àë</span> <span class=\"bp\">$</span><span class=\"n\">binder</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">body</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">let</span> <span class=\"n\">ss</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">withAppFn</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">withAppArg</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">delab</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">‚àë</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">i</span><span class=\"o\">):</span><span class=\"n\">ident</span> <span class=\"k\">in</span> <span class=\"bp\">$</span><span class=\"n\">ss</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">body</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">BigOperators</span>\n</code></pre></div>",
        "id": 355287947,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683072952
    },
    {
        "content": "<p>You can put this right after the <code>end BigOperators</code> in <code>Mathlib/Algebra/BigOperators/Basic.lean</code>, and it becomes active when you do <code>open BigOperators</code>, just like the syntax.</p>",
        "id": 355288068,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683073020
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Pretty-printing.20of.20sums/near/355273723\">said</a>:</p>\n<blockquote>\n<p>I think</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">scoped</span> <span class=\"n\">macro</span> <span class=\"s2\">\"‚àè \"</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">extBinder</span> <span class=\"s2\">\", \"</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">:</span><span class=\"mi\">67</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"n\">Finset.prod</span> <span class=\"n\">Finset.univ</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">‚Ü¶</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>would be a reasonable representation and only needs a missing <code>TSyntax</code> coercion to work in the forward direction.</p>\n</blockquote>\n<p>I don't think this works; don't you need to fold over <code>extBinder</code>? <code>‚àè i j, f i j</code> is <code>Finset.prod Finset.univ (fun i, Finset.prod Finset.univ (fun j, f i j))</code></p>",
        "id": 355288199,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683073090
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Pretty-printing.20of.20sums/near/355288068\">said</a>:</p>\n<blockquote>\n<p>You can put this right after the <code>end BigOperators</code> in <code>Mathlib/Algebra/BigOperators/Basic.lean</code>, and it becomes active when you do <code>open BigOperators</code>, just like the syntax.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Are you saying that you're looking for a volunteer to PR this for you?</p>",
        "id": 355288707,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683073376
    },
    {
        "content": "<p>I'm saying you can test it out if you want Right Now. (There are some fixable spacing issues due to the <code>syntax</code>, just so you know.)</p>",
        "id": 355288761,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683073411
    },
    {
        "content": "<p>I'll create a PR</p>",
        "id": 355288851,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683073451
    },
    {
        "content": "<p>OK, thanks, even better :-)</p>",
        "id": 355289359,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683073731
    },
    {
        "content": "<p>For later: will copy-pasta do <code>Set.union·µ¢</code>, integrals, etc?</p>",
        "id": 355289512,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683073810
    },
    {
        "content": "<p>On a related note, is mathlib3's <code>‚àë i j : Fin 3, (i + j)</code> something we can have back in mathlib4?</p>",
        "id": 355289723,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683073930
    },
    {
        "content": "<p>Ah ... is this not supported by Kyle's version?</p>",
        "id": 355290106,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683074138
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Pretty-printing.20of.20sums/near/355288199\">said</a>:</p>\n<blockquote>\n<p>I don't think this works; don't you need to fold over <code>extBinder</code>?</p>\n</blockquote>\n<p><code>extBinder</code> is only for a single binder, and it's what the sum syntax is using right now. I don't see why sum/prod syntax couldn't eventually support multiple binders.</p>",
        "id": 355290890,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683074524
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/3772\">mathlib4#3772</a></p>",
        "id": 355292957,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683075765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Pretty-printing.20of.20sums/near/355282415\">said</a>:</p>\n<blockquote>\n<p>I have also seen <code>notation3</code> in use, and its docstring says</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>`notation3` declares notation using Lean 3-style syntax.\n</code></pre></div>\n<p>So should we maybe just make more extensive use of <code>notation3</code>?  For example, we could switch the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set#doc\">docs4#Set</a>.union·µ¢ and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sum#doc\">docs4#Finset.sum</a> macros to use <code>notation3</code>?</p>\n</blockquote>\n<p>In one sense, yes <code>notation3</code> is exactly what you need to get an unexpander automatically since the allowed syntax there is rigid enough that we know what to generate. On the other hand, this won't work because <code>notation3</code> does not implement any unexpander, only the elaborator.</p>",
        "id": 355293664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683076177
    },
    {
        "content": "<p>I think it would not be too difficult to adapt Kyle's unexpander to work on arbitrary <code>notation3</code>s</p>",
        "id": 355293808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683076244
    },
    {
        "content": "<p>It'd be great if we could get <code>notation3</code> to (finally) let us use <code>‚àë x ‚àà s, f x</code> notation in a robust way. Maybe that could be done with some custom elaborator after <code>notation3</code>'s expansion?</p>",
        "id": 355294040,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683076384
    },
    {
        "content": "<p>I did actually spend some time thinking about what would be the best syntax for concisely declaring binder notations, and <code>notation3</code> is the best I could come up with. It is a slightly simplified form of the lean 3 notation command</p>",
        "id": 355294047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683076387
    },
    {
        "content": "<p>I'm not sure exactly what you are after there. Is it about using binder predicates?</p>",
        "id": 355294164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683076450
    },
    {
        "content": "<p>Yeah</p>",
        "id": 355294195,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683076477
    },
    {
        "content": "<p>In Lean 3, that would generate two levels of <code>Finset.sum</code>, which is not good if the domain is not a fintype</p>",
        "id": 355294228,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683076507
    },
    {
        "content": "<p>I guess the <code>(...)</code> in notation3 syntax could just support binder_pred out of the box</p>",
        "id": 355294232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683076508
    },
    {
        "content": "<p>ah well that's a different issue</p>",
        "id": 355294254,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683076524
    },
    {
        "content": "<p>I was assuming you want to generate the same thing as what lean 3 would do</p>",
        "id": 355294287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683076546
    },
    {
        "content": "<p>if you want to do something else, then you will have to specify what that is</p>",
        "id": 355294350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683076571
    },
    {
        "content": "<p>the current support for binder predicates certainly allows you to do something else, e.g. the <code>\\exists x, x \\in s /\\ p x</code> thing that people have noticed</p>",
        "id": 355294458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683076662
    },
    {
        "content": "<p>but it's less obvious what syntax you want to use to specify that transformation, especially if it is a one-liner like <code>notation3</code></p>",
        "id": 355294598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683076735
    },
    {
        "content": "<p>I've posted some experiments occasionally over the last two years to convert Lean 3 expansions of the binder predicates into well-formed <code>finset.sum</code> expressions using some complicated typeclasses.</p>",
        "id": 355294661,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683076777
    },
    {
        "content": "<p>They were never really robust though</p>",
        "id": 355294771,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683076830
    },
    {
        "content": "<p>I think what could work is having a <code>Finset.sum'</code> that gives the sum if the function has finite support, <code>0</code> otherwise, and then have some elaborator for it that turns expressions involving <code>Finset.sum'</code> into <code>Finset.sum</code> wherever it's possible.</p>",
        "id": 355294928,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683076906
    },
    {
        "content": "<p>Then <code>‚àë x ‚àà s, f x</code> for <code>s : Finset X</code> would be <code>Finset.sum' (fun x =&gt; Finset.sum' (fun (h : x ‚àà s) =&gt; f x))</code>, and the elaborator could turn this into <code>Finset.sum s (fun x =&gt; f x)</code></p>",
        "id": 355295114,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683077017
    },
    {
        "content": "<p>I don't really have a full design here -- the main goal is just to remove the irregularity of the <code>in</code> in sum/prod notation, while also allowing this to generalize to other sorts of decidable predicates with finite support.</p>",
        "id": 355295276,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683077118
    },
    {
        "content": "<p>Just noting that <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> has been adding delaborators to his PR at <a href=\"https://github.com/leanprover-community/mathlib4/pull/3592\">https://github.com/leanprover-community/mathlib4/pull/3592</a>.</p>\n<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, might you be able to look at this and decide what to do with them? Obviously we want this functionality, I'm just not certain whether the right action is:</p>\n<ul>\n<li>merge as is</li>\n<li>merge, but in some way keep track of wanting to replace these with a more general solution</li>\n<li>don't merge, and implement a general solution now</li>\n</ul>",
        "id": 355295417,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1683077214
    },
    {
        "content": "<p>I opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/3773\">!4#3773</a> for this issue (in the general case, not just for sums).  I think it's extremely high-priority.  (I know Sebastian, Kyle, Mario and Scott are well aware of this ... thank you for thinking about it and also for explaining it carefully!)</p>",
        "id": 355301033,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683080846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> does your pretty-printing magic trick also fix <code>infi</code> for <code>Finset</code>, as in <code>‚®Ö i ‚àà s, f i</code> not displaying <code>‚®Ö i, ‚®Ö h, f i</code>?</p>",
        "id": 355834744,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1683219263
    },
    {
        "content": "<p>I think this is a problem in general for <code>‚®Ö h : P, _</code> where <code>P : Prop</code>, and isn't restricted to finsets</p>",
        "id": 355838597,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683220289
    },
    {
        "content": "<p>No problem, I'd tolerate a fully general solution.</p>",
        "id": 355843828,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1683221659
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Here's a potential general-ish solution for simple dot notation delaborators <a href=\"https://github.com/leanprover-community/mathlib4/pull/3811\">mathlib4#3811</a></p>",
        "id": 356189552,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683334786
    },
    {
        "content": "<p>A big thing it does is define a delaborator that pretty prints projections in general with collapsed parent projections, so <code>x.toC.toB.toA.val</code> is <code>x.val</code>. It still has the limitation of the original version, where it can't handle projections that take any additional arguments.</p>\n<p>The other thing it does is define a command so that you can get dot notation to work for specific functions, either projections that take additional arguments or functions that are used as generalized fields. For example, <code>pp_extended_field_notation Prefunctor.obj</code> for the first and <code>pp_extended_field_notation Iso.app</code> for the second. These interact with the projection delaborator, so, if <code>F</code> is a functor, then <code>F.obj</code> pretty prints as <code>F.obj</code>.</p>\n<p>There's a little hack to get this last part to work, where it adds an extra rule that <code>x.toPrefunctor.obj</code> should be <code>x.obj</code>, no matter what <code>x</code> is. This is because the projection delaborator only collapses parent projections up to the last one. That is, <code>x.toC.toB.toA</code> is still <code>x.toA</code>, so you need to get rid of that last <code>toA</code> somehow. Since <code>pp_extended_field_notation</code> is defining an app unexpander, which is a syntax-&gt;syntax transformation, this extra rule is not guaranteed to be correct, though in practice it shouldn't be a problem.</p>",
        "id": 356190527,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1683335356
    }
]