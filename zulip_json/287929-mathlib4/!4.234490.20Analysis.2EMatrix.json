[
    {
        "content": "<p>I have fixed most of the errors in this file, but the remaining ones are super evil. This file adds a few normed structures as local instances on matrices using <code>inferInstanceAs</code> and then looking through some type equalities. This seems to cause major headaches because at times Lean chooses to see the wrong type, and then picks the wrong norm. As an example of what I mean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.NormedSpace.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.NormedSpace.PiLp</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.InnerProductSpace.PiL2</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">BigOperators</span> <span class=\"n\">NNReal</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n\n<span class=\"kn\">local</span> <span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>   <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">HPow.hPow</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"c1\">-- Porting note: See issue #2220</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">linfty</span>\n\n<span class=\"sd\">/-- Seminormed group instance (using sup norm of L1 norm) for matrices over a seminormed group. Not</span>\n<span class=\"sd\">declared as an instance because there are several natural choices for defining the norm of a</span>\n<span class=\"sd\">matrix. -/</span>\n<span class=\"kd\">@[local instance]</span>\n<span class=\"kd\">def</span> <span class=\"n\">linftyOpSeminormedAddCommGroup</span> <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">SeminormedAddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">Matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">inferInstanceAs</span> <span class=\"o\">(</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">PiLp</span> <span class=\"mi\">1</span> <span class=\"k\">fun</span> <span class=\"n\">_j</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">‖</span><span class=\"n\">A</span><span class=\"bp\">‖</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> with `set_option pp.explicit true`</span>\n<span class=\"cm\">  ⊢ @Eq ℝ</span>\n<span class=\"cm\">    (@norm (Matrix m n α)</span>\n<span class=\"cm\">      (@SeminormedAddCommGroup.toNorm (Matrix m n α) (@linftyOpSeminormedAddCommGroup m n α inst✝² inst✝¹ inst✝)) A)</span>\n<span class=\"cm\">    0</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">norm_def</span> <span class=\"n\">A</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> with `set_option pp.explicit true`</span>\n<span class=\"cm\">  this: @Eq ℝ</span>\n<span class=\"cm\">    (@norm (m → n → α)</span>\n<span class=\"cm\">      (@SeminormedAddGroup.toNorm (m → n → α)</span>\n<span class=\"cm\">        (@Pi.seminormedAddGroup m (fun i ↦ n → α) inst✝² fun i ↦</span>\n<span class=\"cm\">          @Pi.seminormedAddGroup n (fun a ↦ α) inst✝¹ fun i ↦ @SeminormedAddCommGroup.toSeminormedAddGroup α inst✝))</span>\n<span class=\"cm\">      A)</span>\n<span class=\"cm\">    ↑(@Finset.sup ℝ≥0 m instNNRealSemilatticeSup</span>\n<span class=\"cm\">        NNReal.instOrderBotNNRealToLEToPreorderToPartialOrderInstNNRealStrictOrderedSemiring (@Finset.univ m inst✝²)</span>\n<span class=\"cm\">        fun b ↦</span>\n<span class=\"cm\">        @nnnorm (n → α)</span>\n<span class=\"cm\">          (@SeminormedAddGroup.toNNNorm (n → α)</span>\n<span class=\"cm\">            (@Pi.seminormedAddGroup n (fun a ↦ α) inst✝¹ fun i ↦ @SeminormedAddCommGroup.toSeminormedAddGroup α inst✝))</span>\n<span class=\"cm\">          (A b))</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">linfty_op_norm_def</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">‖</span><span class=\"n\">A</span><span class=\"bp\">‖</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sup</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">‖</span><span class=\"n\">A</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- in mathlib3, this worked: `simp [Pi.norm_def, PiLp.nnnorm_eq_sum ENNReal.one_ne_top]`</span>\n  <span class=\"gr\">sorry</span>\n  <span class=\"c1\">-- `rw [Pi.norm_def]` fails with: \"synthesized type class instance is not definitionally equal</span>\n  <span class=\"c1\">-- to expression inferred by typing rules ...\"</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">linfty</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I think this is just defeq abuse in Lean 3, but I'm not sure the best way to resolve it in Lean 4, especially because it was super convenient.</p>",
        "id": 366563064,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1686847345
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> because I expect you will care a lot about this and have ideas about its resolution.</p>",
        "id": 366563388,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1686847423
    },
    {
        "content": "<p>I think this lemma is awkward because:</p>\n<ul>\n<li>We are using defeq abuse rather than using <code>NormedAddCommGroup.induced</code> with a map equal to the identity</li>\n<li>This lemma is doing two things at once; undoing the defeq abuse, and then applying a useful lemma</li>\n</ul>\n<p>The first point seems pretty minor, since this is an implementation detail anyway. The solution to the second was to start the proof with a <code>change</code> line to express the norm without any defeq abuse.</p>",
        "id": 367597523,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1687173127
    },
    {
        "content": "<p>(I pushed some fixes, but haven't reviewed the overall diff)</p>",
        "id": 367597605,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1687173153
    },
    {
        "content": "<p>Thanks. I'll have a look in a bit.</p>",
        "id": 367612663,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1687176311
    }
]