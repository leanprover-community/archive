[
    {
        "content": "<p>Is there a way in Lean to avoid type annotation or express it before the <code>:</code> like explicitly choosing an instance for <code>Mul</code> in the following <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ? ( 3 examples are shown to demonstrate the spiritually same use case)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.CliffordAlgebra.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">QuadraticForm</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">instance</span> <span class=\"n\">hasCoeCliffordAlgebraRing</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)⟩</span>\n<span class=\"kn\">local</span> <span class=\"kd\">instance</span> <span class=\"n\">hasCoeCliffordAlgebraModule</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">CliffordAlgebra.ι</span> <span class=\"n\">Q</span><span class=\"o\">⟩</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">  https://arxiv.org/abs/1205.5935</span>\n\n<span class=\"cm\">  Axiom 3. G contains a subset G1 closed under addition, and λ ∈ G0, v ∈ G1 implies λv = vλ ∈ G1.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_add</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">u</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">Algebra.commutes</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_smul</span><span class=\"o\">,</span> <span class=\"n\">Algebra.smul_def</span><span class=\"o\">,</span> <span class=\"n\">Algebra.commutes</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>P.S. I also don't know if using coe is the idiomatic way to try to write it in Lean as close as in math, but it works for other cases with the help from local notations and definitions.</p>",
        "id": 402362351,
        "sender_full_name": "Utensil Song",
        "timestamp": 1700099434
    },
    {
        "content": "<p>If you want more symmetry, you could write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"n\">A</span> <span class=\"s2\">\" =[\"</span> <span class=\"n\">T</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\"] \"</span> <span class=\"n\">B</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">@</span><span class=\"n\">Eq</span> <span class=\"n\">T</span> <span class=\"n\">A</span> <span class=\"n\">B</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">w</span> <span class=\"bp\">=</span><span class=\"o\">[</span><span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">]</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_add</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 402363154,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700099903
    },
    {
        "content": "<p>Another option is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">HMul.hMul</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>though this is likely to become annoying quickly</p>",
        "id": 402363389,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700100037
    },
    {
        "content": "<p>Annotating the eq seems clear and noiseless. The macro rules version is something I would wish to avoid too.</p>",
        "id": 402366570,
        "sender_full_name": "Utensil Song",
        "timestamp": 1700101675
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"s2\">\"Cl\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span>\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"n\">A</span> <span class=\"s2\">\"=\"</span> <span class=\"n\">B</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\":\"</span> <span class=\"n\">T</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">@</span><span class=\"n\">Eq</span> <span class=\"n\">T</span> <span class=\"n\">A</span> <span class=\"n\">B</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Cl</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_add</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>seems more natural to me. Any idea why <code>abbrev Cl := CliffordAlgebra Q</code> doesn't work in place of local notation?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"n\">v</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">Cl</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"bp\">?</span><span class=\"n\">u.218013</span> <span class=\"bp\">?</span><span class=\"n\">u.218012</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>where</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">Cl.{u_2, u_1} {R : Type u_1} {M : Type u_2} [inst✝ : CommRing R] [inst✝¹ : AddCommGroup M] [inst✝² : Module R M]</span>\n<span class=\"cm\">  {Q : QuadraticForm R M} : Type (max u_2 u_1)</span>\n<span class=\"cm\">-/</span>\n<span class=\"k\">#check</span> <span class=\"n\">Cl</span>\n</code></pre></div>",
        "id": 402398342,
        "sender_full_name": "Utensil Song",
        "timestamp": 1700117748
    },
    {
        "content": "<p>Another caveat is that annotating only eq doesn't remove the need of local notation in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"n\">x</span> <span class=\"s2\">\"²\"</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Cl</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ι_sq_scalar</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span><span class=\"bp\">²</span> <span class=\"bp\">=</span> <span class=\"n\">Q</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Cl</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_two</span><span class=\"o\">,</span> <span class=\"n\">CliffordAlgebra.ι_sq_scalar</span><span class=\"o\">]</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>without the type annotation in local notation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"n\">x</span> <span class=\"s2\">\"²\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">failed to synthesize instance</span>\n<span class=\"cm\">  HPow M ?m.302609 Cl</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ι_sq_scalar</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span><span class=\"bp\">²</span> <span class=\"bp\">=</span> <span class=\"n\">Q</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Cl</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_two</span><span class=\"o\">,</span> <span class=\"n\">CliffordAlgebra.ι_sq_scalar</span><span class=\"o\">]</span>\n  <span class=\"n\">done</span>\n</code></pre></div>",
        "id": 402400469,
        "sender_full_name": "Utensil Song",
        "timestamp": 1700118602
    },
    {
        "content": "<p>It's not yet clear to me whether <a href=\"https://github.com/leanprover/lean4/pull/2854\">lean4#2854</a> (context: <a href=\"#narrow/stream/270676-lean4/topic/RFC.20for.20fixing.20lean4.232220/near/401254024\"> :thread: </a> ) helps.</p>",
        "id": 402401011,
        "sender_full_name": "Utensil Song",
        "timestamp": 1700118898
    },
    {
        "content": "<p>A new case, <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.CliffordAlgebra.Star</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">QuadraticForm</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CliffordAlgebra</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">failed to synthesize instance</span>\n<span class=\"cm\">  HMul (CliffordAlgebra Q) (CliffordAlgebra Q)ˣ (CliffordAlgebra Q)</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">units_involute_act_eq_conjAct</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CliffordAlgebra.involute</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">ι</span> <span class=\"n\">Q</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">ConjAct.toConjAct</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">ι</span> <span class=\"n\">Q</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">  Instead, I have to write it with ↑ and type annotation</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">units_involute_act_eq_conjAct'</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CliffordAlgebra.involute</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">ι</span> <span class=\"n\">Q</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ConjAct.toConjAct</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">ι</span> <span class=\"n\">Q</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 406754752,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702040582
    },
    {
        "content": "<p>When type class search fails to synth a <code>HMul a b a</code>, it seems reasonable for it to try coercion to synth an <code>Mul a a a</code>. Don't know if it's possible to be encoded in Lean.</p>",
        "id": 406755463,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702040864
    },
    {
        "content": "<p>I think something weirder is going on here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.CliffordAlgebra.Star</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">QuadraticForm</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CliffordAlgebra</span>\n\n<span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">involute</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">ι</span> <span class=\"n\">Q</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">ConjAct.toConjAct</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">ι</span> <span class=\"n\">Q</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">involute</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">ι</span> <span class=\"n\">Q</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">ConjAct.toConjAct</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">ι</span> <span class=\"n\">Q</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 406756915,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702041480
    },
    {
        "content": "<p>It seems that the actual problem is that Lean can't work out the type of <code>involute x</code> until it's looked at the <code>*</code></p>",
        "id": 406757168,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702041568
    },
    {
        "content": "<p>I think this is due to a conflict between the default elaboration rules, which work from the outside in, and the special rules for <code>*</code> (<code>binop%</code>), which work from the inside out. If you disable those special rules then this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- restore the lean3 behavior</span>\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">HMul.hMul</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">instHMul</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">involute</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">ι</span> <span class=\"n\">Q</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">ConjAct.toConjAct</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">ι</span> <span class=\"n\">Q</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 406757778,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702041773
    },
    {
        "content": "<p>Interesting that it can be fixed by annotating the other <code>Mul</code></p>",
        "id": 406757800,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702041781
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Avoiding.20type.20annotation/near/406757778\">said</a>:</p>\n<blockquote>\n<p>I think this is due to a conflict between the default elaboration rules, which work from the outside in, and the special rules for <code>*</code> (<code>binop%</code>), which work from the inside out. If you disable those special rules then this works:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- restore the lean3 behavior</span>\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">HMul.hMul</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">instHMul</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">involute</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">ι</span> <span class=\"n\">Q</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">ConjAct.toConjAct</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">ι</span> <span class=\"n\">Q</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>More context seems to be in <a href=\"https://github.com/leanprover/lean4/issues/1915#issuecomment-1369663605\">lean4#1915</a>.</p>",
        "id": 406758513,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702042042
    },
    {
        "content": "<p>Or a few other PRs on <code>binop</code>, are they fixing something same underneath case by case?</p>",
        "id": 406758839,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702042169
    },
    {
        "content": "<p>I don't think there are any planned core changes incoming here</p>",
        "id": 406760266,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702042705
    },
    {
        "content": "<p>Here's a couple places where there's documentation about how the expression tree elaborator works:</p>\n<ul>\n<li><a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Extra.lean#L82\">https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Extra.lean#L82</a> is the file with the elaborator</li>\n<li>the \"manual-level explanation\" in RFC <a href=\"https://github.com/leanprover/lean4/pull/2854\">lean4#2854</a></li>\n</ul>",
        "id": 406808443,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702057021
    },
    {
        "content": "<p>Outside-in vs inside-out isn't completely accurate. It elaborates each leaf in a full arithmetic expression without an expected type, then it computes a type that everything can be coerced to, and then it inserts coercions where needed.</p>\n<p>A difference one can observe is that coercions don't get sunk into the leaves in expression trees -- they're stuck right at a leaf -- where if there were no such elaborator then coercions can get sunk arbitrarily deep based on expected types.</p>",
        "id": 406809225,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702057331
    },
    {
        "content": "<p>Indeed, I just looked at the first example and I see <code>involute ↑x * (ι Q) y * ↑x⁻¹ = ConjAct.toConjAct x • (ι Q) y</code>. It needs to sink a coercion into the argument to <code>involute</code>.</p>\n<p>I obliquely mentioned this in the \"future possibilities\" section of the RFC. If there were a way for <code>involute</code> to participate in this elaboration algorithm and say that the input and output should have the same type, then the expression tree elaborator could help get this to elaborate successfully</p>",
        "id": 406810146,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702057699
    },
    {
        "content": "<p>Doesn't this mean that in practice almost every function ends up having to participate in the new elaboration?</p>",
        "id": 406810219,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702057733
    },
    {
        "content": "<blockquote>\n<p>It needs to sink a coercion into the argument to involute.</p>\n</blockquote>\n<p>I guess the problem is that even</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"n\">involute</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>doesn't elaborate</p>",
        "id": 406810845,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702057955
    },
    {
        "content": "<p>I don't think so, just expressions that are algebraic operators of some sort, in the sense that you want all the \"primary\" arguments to all of them to have the same type.</p>",
        "id": 406810849,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702057957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Avoiding.20type.20annotation/near/406810845\">said</a>:</p>\n<blockquote>\n<p>I guess the problem is that even ...doesn't elaborate</p>\n</blockquote>\n<p>Maybe <code>involute</code> needs its own elaborator to try to compute its <code>Q</code> and insert a coercion if needed?</p>",
        "id": 406811007,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702058017
    },
    {
        "content": "<p>I think this is a more general problem with coercion from <code>Units</code></p>",
        "id": 406811148,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702058065
    },
    {
        "content": "<p>We have this problem for matrices elsewhere too</p>",
        "id": 406811163,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702058072
    },
    {
        "content": "<p>(the fact that <code>involute</code> is a morphism seems to be a distraction; it seems to fail as a plain function too)</p>",
        "id": 406811310,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702058139
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Avoiding.20type.20annotation/near/406811148\">said</a>:</p>\n<blockquote>\n<p>I think this is a more general problem with coercion from <code>Units</code></p>\n</blockquote>\n<p>Can a general elab be defined for Units, regardless of what the function is?</p>",
        "id": 406812837,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702058677
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Avoiding.20type.20annotation/near/406809225\">said</a>:</p>\n<blockquote>\n<p>Outside-in vs inside-out isn't completely accurate. It elaborates each leaf in a full arithmetic expression without an expected type, then it computes a type that everything can be coerced to, and then it inserts coercions where needed.</p>\n<p>A difference one can observe is that coercions don't get sunk into the leaves in expression trees -- they're stuck right at a leaf -- where if there were no such elaborator then coercions can get sunk arbitrarily deep based on expected types.</p>\n</blockquote>\n<p>The arbitrary deep issue seems to be manageable by a max depth analogous to max hearbeat. And it's quite small in practice, less than 5.</p>",
        "id": 406815007,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702059569
    },
    {
        "content": "<p>The issue here isn't about arbitrary depth, it's that the expression tree elaborator is only aware of terms that appear (recursively) as operands to <code>binop%</code> notations, etc. The algorithm would not work at all if it were extended to visit all operands to all functions to a certain depth.</p>",
        "id": 406815813,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702059898
    },
    {
        "content": "<p>I see...</p>",
        "id": 406815946,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702059952
    },
    {
        "content": "<p>There's no single process that is responsible for sinking coercions arbitrarily deep into expressions in the main elaborator. It's a combination of the fact that when elaborating there's an expected type, and when function applications are elaborated Lean can insert coercions to the functions arguments when there's a type mismatch.</p>",
        "id": 406816096,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702060010
    },
    {
        "content": "<p>For example, in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span><span class=\"cm\"> id ↑5 : ℤ -/</span>\n</code></pre></div>",
        "id": 406816393,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702060121
    },
    {
        "content": "<p>The expression tree evaluator does try to play nicely with this, at least in one direction (when it's inside another expression, rather than when other expressions are within it):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">((</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">id (↑5 + ↑6) : ℤ</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>This by the way is an example of why it's not accurate to say that it's \"inside-out\". It's using the expected type \"outside-in\" and pushes coercions to the leaves.</p>",
        "id": 406816748,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702060287
    },
    {
        "content": "<p>Just read the elab code, now it makes much more sense. It seems that operator side has done what it can, the cause might be how involute is defined.</p>",
        "id": 406817572,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702060560
    },
    {
        "content": "<p>I think involute is a distraction here: here's a much more minimal <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.ZMod.Basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">zu</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">foo</span> <span class=\"n\">zu</span>  <span class=\"c1\">-- fails</span>\n<span class=\"k\">#check</span> <span class=\"n\">foo</span> <span class=\"bp\">↑</span><span class=\"n\">zu</span>  <span class=\"c1\">-- fails</span>\n<span class=\"k\">#check</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">zu</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span>  <span class=\"c1\">-- ok</span>\n</code></pre></div>",
        "id": 406819481,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702061452
    },
    {
        "content": "<p>The ingredients seem to just be using <code>Units</code> on a parameterized type</p>",
        "id": 406819806,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702061595
    },
    {
        "content": "<p>What does the coercion for units? I wonder if this is one of these things where we have to exeriment with <code>CoeHead</code>, etc.</p>",
        "id": 406846910,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702073838
    },
    {
        "content": "<p><del>I believe it's a <code>CoeOut</code></del> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Units.instCoeHeadUnits#doc\">docs#Units.instCoeHeadUnits</a></p>",
        "id": 406847426,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702074074
    },
    {
        "content": "<p>I don't understand what I'm doing, but defining any of these instances doesn't help <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> 's MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span>  <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CoeHead</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">Units.val</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CoeTail</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">Units.val</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">Units.val</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CoeDep</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span> <span class=\"n\">z</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">Units.val</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p><a href=\"#narrow/stream/270676-lean4/topic/Typeclass.20changes.20between.20April.20and.204.2E1.2E0.3F/near/397958110\">Related</a>.</p>",
        "id": 406889971,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702098613
    },
    {
        "content": "<p>Checking with <code>set_option trace.Meta.synthInstance true</code>, <code>CoeDep</code> did help, making the <span aria-label=\"explosion\" class=\"emoji emoji-1f4a5\" role=\"img\" title=\"explosion\">:explosion:</span>  happen in fewer steps.</p>",
        "id": 406890471,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702098943
    },
    {
        "content": "<p>Oh yes, I noticed this recently in my work with units. Honestly in some ways the fact it's a coercion at all is a bit of a trap because it is hard to make it work. I don't know what defines the coercion.</p>",
        "id": 408061713,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1702594887
    },
    {
        "content": "<p>I wonder if it's related somehow to the fact that a unit contains two pieces of data? I mean it shouldn't be, it's hardly unique in that. But it's the only aspect that seems weirder than anything else.</p>",
        "id": 408061917,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1702594947
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/9111\">#9111</a>, the directly ported <code>lipschitz</code> looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">lipschitz</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">QuadraticForm</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Subgroup.closure</span> <span class=\"o\">(</span><span class=\"n\">Coe.coe</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">Set.range</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">lipschitz</span> <span class=\"n\">lipschitz</span>\n</code></pre></div>\n<p>which fails with </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span> <span class=\"o\">(</span><span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Of course, it works if <code>Coe.coe</code> is changed to <code>CoeHead.coe</code> but I was ignorant about it and used <code>Units.val</code> in its place. I think it makes it even more clear about what the preimage is. And even knowing that <code>CoeHead.coe</code> works, I'm still reluctant to change it back. I hope that's OK.</p>\n<p>Posting this here as this topic has more context, and I still wonder why the synthesization failed.</p>",
        "id": 408436017,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702813608
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Avoiding.20type.20annotation/near/406757778\">said</a>:</p>\n<blockquote>\n<p>I think this is due to a conflict between the default elaboration rules, which work from the outside in, and the special rules for <code>*</code> (<code>binop%</code>), which work from the inside out. If you disable those special rules then this works:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- restore the lean3 behavior</span>\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">HMul.hMul</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">instHMul</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">CliffordAlgebra</span> <span class=\"n\">Q</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">involute</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">ι</span> <span class=\"n\">Q</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">ConjAct.toConjAct</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">ι</span> <span class=\"n\">Q</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Also in <a href=\"https://github.com/leanprover-community/mathlib4/pull/9111\">#9111</a>, I've used this solution, but for a serious PR, I think I need to remove this <code>macro_rules</code> but as this errors for all occurrences and alike (&gt;5) of <code>involute ↑x * ι Q y * ↑x⁻¹</code> in the file, should I use <code>involute (Q := Q)</code> instead? It seems less poluting and better than type annotating <code>↑x⁻¹</code>.  (UPDATE: this <a href=\"https://github.com/leanprover-community/mathlib4/pull/9111/commits/8cc8431ab4daa0f2711ad49ee8bd952f25c5f628\">commit</a> has done this.)</p>",
        "id": 408437436,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702814966
    },
    {
        "content": "<p>In Lean4 you should pretty much never write <code>Coe.coe</code>, but <code>(↑)</code></p>",
        "id": 408440990,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702818575
    },
    {
        "content": "<p><code>(↑) ⁻¹'</code> definitely works in this case!</p>",
        "id": 408441756,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702819372
    },
    {
        "content": "<p>with the extra benefit that hover/cm+click on it gives <code>Units.val : (CliffordAlgebra Q)ˣ → CliffordAlgebra Q</code> <span aria-label=\"astonished\" class=\"emoji emoji-1f632\" role=\"img\" title=\"astonished\">:astonished:</span></p>",
        "id": 408442526,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702820279
    }
]