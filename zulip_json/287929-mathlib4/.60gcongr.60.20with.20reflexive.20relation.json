[
    {
        "content": "<p>I am learning to use <code>gcongr</code> and was surprised to find that it does not attempt to apply a <code>gcongr</code> lemma when the generated goal would be reflexivity. Is this intended or a missing feature?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">GCongr</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">refl</span><span class=\"kd\">]</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Rrefl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">gcongr</span><span class=\"kd\">]</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Rf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">y'</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">z'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">y'</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">z'</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"n\">y'</span><span class=\"w\"> </span><span class=\"n\">z'</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">z'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">z'</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">z'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">h'</span>\n<span class=\"w\">  </span><span class=\"n\">gcongr</span><span class=\"w\"> </span><span class=\"c1\">-- gcongr did not make progress</span>\n</code></pre></div>",
        "id": 525624997,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1750818317
    },
    {
        "content": "<p>I believe it's currently expected behaviour that you need to make a separate gcongr lemma for, eg, <code>R (f x y z) (f x y z')</code>, and there are a few of these in mathlib. But I agree that it'd be convenient if we didn't have to! Maybe <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> can say more about the choices made here</p>",
        "id": 525652870,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1750837678
    },
    {
        "content": "<p><code>gcongr</code> (currently) requires that you write a separate <code>gcongr</code> lemma for every possible choice of arguments changing or being fixed. So if <code>f</code> is <code>n</code>-ary this requires <code>2^n</code> congr-lemmas (or <code>2^n-1</code>, since it's trivial if all arguments are fixed). <code>gcongr</code> could probably be extended to also try more general lemmas (though there is not always a canonical choice...)</p>",
        "id": 525670329,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1750843470
    },
    {
        "content": "<p>The reason for this decision is that e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_le_mul_of_nonneg_left#doc\">docs#mul_le_mul_of_nonneg_left</a> has fewer side conditions than <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_le_mul#doc\">docs#mul_le_mul</a>.</p>",
        "id": 525671201,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1750843779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60gcongr.60.20with.20reflexive.20relation/near/525671201\">said</a>:</p>\n<blockquote>\n<p>The reason for this decision is that e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_le_mul_of_nonneg_left#doc\">docs#mul_le_mul_of_nonneg_left</a> has fewer side conditions than <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_le_mul#doc\">docs#mul_le_mul</a>.</p>\n</blockquote>\n<p>I should have said more here, sorry. I am aware of this design. In my development I have a 4-ary function and 4 <code>gcongr</code> lemmas where a single argument varies. These indeed have fewer assumptions/side conditions. But I don't necessarily want to have 15 lemmas (especially since there are several 4-ary functions). It makes sense that <code>gcongr</code> would prefer these special-cased lemmas, but I think it could be useful for it to fall back to the general lemma <code>R x x' -&gt; R y y' -&gt; R z z' -&gt; R (f x y z) (f x' y' z')</code> when no special-case matches. Perhaps the worry is that this generates unprovable goals for non-reflexive relations? I am personally okay with that, but it could be prevented by looking for an <code>@[refl]</code> lemma or an instance of <code>IsRefl</code>.</p>",
        "id": 525760453,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1750872697
    },
    {
        "content": "<p>(For context, I am trying to work with what is essentially a quotient by <code>R</code> without actually using <code>Quotient</code>.)</p>",
        "id": 525760862,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1750872880
    },
    {
        "content": "<p>I would be very happy if <code>gcongr</code> looked a little harder, when the goal is of the form <code>R ... (f ...) (f ...)</code>, but there is no lemma found with the right varying arguments.</p>\n<p>There are some design decision here:</p>\n<ul>\n<li>As you pointed out: does this only work for reflexive relations? One example where it might be useful to allow this behavior for non-reflexive relations is if you have a partial equivalence relation (or more generally, a relation that is neither reflexive nor irreflexive): then you might want to create the a goals <code>R 0 0 </code>. But if <code>R</code> is reflexive, that goal is hopefully discharged automatically.</li>\n<li>Which more general lemma(s) do you try to find (EDIT: if the lemma with the expected varying arguments doesn't exist)? Do you jump directly to the <code>gcongr</code> lemma where all arguments vary, or do you update the varying-ness of arguments one by one (e.g. from left-to-right) and see for each of the possibilities you walk along whether a <code>gcongr</code> lemma exists?</li>\n</ul>\n<p>I would be happy if <code>gcongr</code> does this, independent of the precise chosen implementation. It is indeed silly that we have to specialize some lemmas to make them work for <code>gcongr</code>.</p>",
        "id": 525886115,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1750938688
    },
    {
        "content": "<p>Sorry if I am stating the obvious, but the reason why <code>gcongr</code> works the way it does is to avoid having to prove <code>0 â‰¤ c</code> when run on <code>a * b â‰¤ a * c</code></p>",
        "id": 525886886,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1750938981
    },
    {
        "content": "<p>I do believe <code>gcongr</code> could be improved, but we have to be careful of this (very very important) use case</p>",
        "id": 525887046,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1750939037
    },
    {
        "content": "<p>You could probably sort the candidates by the amount of fixed parameters so that the one with the most fixed parameters (that work with the goal) are tried first.</p>",
        "id": 525887425,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750939181
    },
    {
        "content": "<p>Yael, I completely agree we need to preserve that use case. Both of my suggestions do (I clarified my suggestion slightly).</p>",
        "id": 525892993,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1750940925
    },
    {
        "content": "<p>Yes, I just wanted to make sure everyone in this thread knew what was going on</p>",
        "id": 525893293,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1750941022
    },
    {
        "content": "<p>I agree with <span class=\"user-mention\" data-user-id=\"873547\">@Robin Arnez</span>'s suggestion. The candidate lemmas should be sorted by which parameters are fixed, so that we always start trying the lemmas with the most fixed parameters. So only if those fail to apply, we try more general lemmas. And for the new reflexive subgoals, we should try the <code>rfl</code> tactic (and if <code>rfl</code> fails, leave this as a new goal).</p>\n<p>I might try to implement this next week when I have time again.</p>",
        "id": 526360797,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1751276740
    },
    {
        "content": "<p>Here's my PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/26907\">#26907</a></p>",
        "id": 527792567,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1752023176
    },
    {
        "content": "<p>I've split off a small change into a separate PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/26938\">#26938</a></p>",
        "id": 527924582,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1752078240
    }
]