[
    {
        "content": "<p>Excuse me, I want to construct an <code>Equiv.Perm</code> that rotates the elements in the  <code>range(i, j)</code> while keeping the other positions unchanged. For example : <code>(0, ..., i - 1, i, i + 1, ...., j , j + 1, ...., n )</code> â†’ <code>(0, ..., i - 1, i + 1, ...., j ,i,  j + 1, ...., n )</code></p>\n<p>How should I design this? I found <code>finRotate n</code> and <code>Fin.cycleRange</code> in mathlib for now. The former rotates everything, while the latter rotates the range <code>Range(i)</code>. I tried to copy the proof of <code>Fin.cycleRange</code>, but it involves a lot of cumbersome steps like <code>Fin (n) â‰ƒ Fin (i + (n - i))</code>.</p>",
        "id": 510684414,
        "sender_full_name": "Yi.Yuan",
        "timestamp": 1744035318
    },
    {
        "content": "<p>You can construct it this way, or provide a definition of the permutation you want (using <code>if ... then ... else</code>) and its inverse.</p>",
        "id": 510694795,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1744037698
    },
    {
        "content": "<p>Do you mean that I can use many <code>by_cases</code>? It is currently the most efficient approach, but they will probably not merge this into mathlib.</p>",
        "id": 510697134,
        "sender_full_name": "Yi.Yuan",
        "timestamp": 1744038224
    },
    {
        "content": "<p><code>by_cases</code> is in tactic mode. In term mode you should use <code>if ... then ... else if ... then ... else ...</code> just like ordinary programming languages.</p>",
        "id": 510707347,
        "sender_full_name": "Jz Pan",
        "timestamp": 1744040737
    },
    {
        "content": "<p>Another, more general, option would be, given an embedding <code>e</code> of a type <code>X</code> into a type <code>Y</code>, to define (maybe it exists) the corresponding group morphism <code>Equiv.Perm X -&gt;* Equiv.Perm Y</code>.</p>",
        "id": 511206982,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1744213311
    },
    {
        "content": "<p>Yes, this exists, although I can't remember where it is</p>",
        "id": 511207677,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1744213485
    },
    {
        "content": "<p><a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Equiv.2EPerm.20from.20a.20list.20of.20mappings/near/496677072\">#mathlib4 &gt; Equiv.Perm from a list of mappings @ ðŸ’¬</a></p>",
        "id": 511208318,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744213665
    },
    {
        "content": "<p>Oh, I found <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.Perm.viaEmbeddingHom#doc\">docs#Equiv.Perm.viaEmbeddingHom</a></p>",
        "id": 511208674,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744213760
    },
    {
        "content": "<p>There's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.Perm.extendDomainHom#doc\">docs#Equiv.Perm.extendDomainHom</a></p>",
        "id": 511208902,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744213809
    }
]