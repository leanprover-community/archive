[
    {
        "content": "<p>Hi all, I independently formalized that the power series ring over a noetherian ring is noetherian locally, and only afterwards I noticed that it already exists in the latest mathlib. My formalization uses a different approach that follows <a href=\"https://stacks.math.columbia.edu/tag/0306\">https://stacks.math.columbia.edu/tag/0306</a><br>\nI wanted to share it here in case anyone finds the approach useful<br>\n<a href=\"https://github.com/BryceT233/power-series-ring-is-noetherian-\">https://github.com/BryceT233/power-series-ring-is-noetherian-</a></p>\n<p>If this is redundant and not worth upstreaming, that's fine — I mainly thought it might be helpful as an alternative explanation.</p>",
        "id": 563726295,
        "sender_full_name": "Bingyu Xia",
        "timestamp": 1765765008
    },
    {
        "content": "<p>Congratulation! Nice work!</p>\n<p>If you think there are some reusable components, then upstreaming those is welcome. I scrolled through your file, and it seems that most of it is private lemmas building up to the main result... So I couldn't identify reusable intermediate results quickly.</p>",
        "id": 563749793,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1765784251
    },
    {
        "content": "<p>Hi! If you are interested in learning a little bit of Lean you can try to add that power series over finitely many variable is a noetherian ring. Beware that this is mostly a \"formalization proof\", in the sense that the math is trivial, but the formalization is probably a little annoying.</p>",
        "id": 563765934,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1765789547
    },
    {
        "content": "<p>This would be literally immediate if we had the right induction. Do we?</p>",
        "id": 563776528,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765792367
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/an.20alternative.20formalization/near/563765934\">发言道</a>：</p>\n<blockquote>\n<p>Hi! If you are interested in learning a little bit of Lean you can try to add that power series over finitely many variable is a noetherian ring. Beware that this is mostly a \"formalization proof\", in the sense that the math is trivial, but the formalization is probably a little annoying.</p>\n</blockquote>\n<p>Thanks for the suggestion, yes, this is something I’ve been thinking about as well. I’m aware that the mathematical content is fairly straightforward and that most of the work would be on the formalization side, but it still seems like a good exercise to understand the existing APIs better. I may give it a try when I have some time.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/an.20alternative.20formalization/near/563776528\">发言道</a>：</p>\n<blockquote>\n<p>This would be literally immediate if we had the right induction. Do we?</p>\n</blockquote>\n<p>Good question — I’m actually not sure whether there is a cleaner induction / recursion principle available here. In my own formalizations I usually end up first proving an existence lemma and then defining things via recursion based on that, which works but is admittedly a bit cumbersome. If there is a more direct inductive setup that I’m missing, I’d be very interested to learn about it.</p>",
        "id": 563779917,
        "sender_full_name": "Bingyu Xia",
        "timestamp": 1765793226
    },
    {
        "content": "<blockquote>\n<p>add that power series over finitely many variable is a noetherian ring.</p>\n</blockquote>\n<p>Seems we're missing the analogue of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/MvPolynomial/Equiv.html#MvPolynomial.optionEquivLeft\">MvPolynomial.optionEquivLeft</a> for MvPowerSeries. Once we have that the proof should be similar to (half of) <a href=\"https://github.com/leanprover-community/mathlib3/commit/eabc6192c84ccce3936a8577a987b80b95ba75f6\">this mathlib3 PR</a> (the other half deducing the infinite case from the finite case doesn't work here).</p>",
        "id": 563797917,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1765798254
    },
    {
        "content": "<p>Yes, it's not trivial but it should be doable.</p>",
        "id": 563798879,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1765798548
    },
    {
        "content": "<p>I'm saying that it <em>should</em> be trivial i.e. one line, because we should have some general lemma which can just be <br>\napplied. Unfortunately I ran into two issues when trying to make one (independent of the missing def Junyan has highlighted):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MvPowerSeries</span><span class=\"bp\">.</span><span class=\"n\">semiring_finite_induction</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">},</span>\n<span class=\"w\">      </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PowerSeries</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">],</span>\n<span class=\"w\">      </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MvPowerSeries</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MvPowerSeries</span><span class=\"bp\">.</span><span class=\"n\">ring_finite_induction</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">},</span>\n<span class=\"w\">      </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PowerSeries</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">],</span>\n<span class=\"w\">      </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MvPowerSeries</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MvPowerSeries</span><span class=\"bp\">.</span><span class=\"n\">commRing_finite_induction</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">},</span>\n<span class=\"w\">      </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PowerSeries</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">],</span>\n<span class=\"w\">      </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MvPowerSeries</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The first is that we seem to need one principle per typeclass. The second is that the index type is forced to be in <code>Type u</code>, the same type as the ring, unless we make a second one with an index type in <code>Type</code> which should also work, which would mean 6 theorems in all :-/</p>",
        "id": 563803780,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765800057
    },
    {
        "content": "<p>it's finite so it shouldn't matter</p>",
        "id": 563807381,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765801066
    },
    {
        "content": "<p>why does it have to be the same universe as the ring</p>",
        "id": 563807586,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765801122
    },
    {
        "content": "<p>oh I see now</p>",
        "id": 563807827,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765801200
    },
    {
        "content": "<p>then you should just state it for when the ring is <code>Type (max u v)</code> and the index is <code>Type v</code></p>",
        "id": 563808197,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765801304
    },
    {
        "content": "<p>that should work right</p>",
        "id": 563808240,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765801314
    },
    {
        "content": "<p>and it specializes to both of the cases</p>",
        "id": 563808288,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765801324
    },
    {
        "content": "<p>so that takes care of the universe issue</p>",
        "id": 563808466,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765801371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/an.20alternative.20formalization/near/563808240\">said</a>:</p>\n<blockquote>\n<p>that should work right</p>\n</blockquote>\n<p>I love your optimism :-) I fear that this is a recipe for big weird slowdowns and obscure universe unification errors. Also I'm not convinced that it solves the problem: I want to be able to prove that if <code>(R : Type u)</code> and <code>P R -&gt; P (PowerSeries R)</code> then <code>P R -&gt; P (MvPowerSeries \\sigma R)</code> for <code>(\\sigma : Type v)</code> and I don't think your suggestion will do this but this is the natural statement.</p>",
        "id": 563811302,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765802201
    },
    {
        "content": "<p>I mean that we are missing the isomorphism, after that it is of course a one liner.<br>\nIn my opinion we should not rush to the result about <code>option</code>, we should make sure we have all the results in <code>Mathlib.Algebra.MvPolynomial.Equiv</code>, including the case of infinitely many variables (when it holds of course).</p>",
        "id": 563812331,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1765802508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/an.20alternative.20formalization/near/563811302\">said</a>:</p>\n<blockquote>\n<p>I want to be able to prove that if <code>(R : Type u)</code> and <code>P R -&gt; P (PowerSeries R)</code> then <code>P R -&gt; P (MvPowerSeries \\sigma R)</code> for <code>(\\sigma : Type v)</code> and I don't think your suggestion will do this but this is the natural statement.</p>\n</blockquote>\n<p>That doesn't typecheck so I'm not worried about it</p>",
        "id": 563813235,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765802777
    },
    {
        "content": "<p>But <code>IsNoetherianRing R -&gt; IsNoetherianRing (MvPowerSeries \\sigma R)</code> typechecks!</p>",
        "id": 563813801,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765802954
    },
    {
        "content": "<p>That's because you have two different <code>P</code>s</p>",
        "id": 563813856,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765802974
    },
    {
        "content": "<p><code>IsNoetherianRing.{u}</code> and <code>IsNoetherianRing.{max u v}</code></p>",
        "id": 563814052,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765803030
    },
    {
        "content": "<p>if you want to make an induction principle with them then you have to add in the hypothesis that said they're related</p>",
        "id": 563814264,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765803092
    },
    {
        "content": "<p>Youch. So here's the concrete question:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- assume this</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">PowerSeries</span><span class=\"bp\">.</span><span class=\"n\">isNoetherianRing'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hR</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsNoetherianRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsNoetherianRing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PowerSeries</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- Is there now a general induction principle which can be applied to prove this:</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MvPowerSeries</span><span class=\"bp\">.</span><span class=\"n\">isNoetherianRing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hR</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsNoetherianRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsNoetherianRing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MvPowerSeries</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 563814771,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765803223
    },
    {
        "content": "<p>And the relation is probably just this, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- assume this too</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">IsNoetherianRing</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">≃+*</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsNoetherianRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsNoetherianRing</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 563815082,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765803310
    },
    {
        "content": "<p>yeah that would suffice</p>",
        "id": 563815122,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765803321
    },
    {
        "content": "<p>You say that and I believe you mathematically but what's the general induction principle which can be made to apply?</p>",
        "id": 563815245,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765803355
    },
    {
        "content": "<p>I'll think about it</p>",
        "id": 563815305,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765803366
    },
    {
        "content": "<p>right now it still feels like you're gonna have one per typeclass :(</p>",
        "id": 563815496,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765803418
    },
    {
        "content": "<p>Can we not sidestep the universe issue by using <code>IsNoetherianRing R ↔ IsNoetherianRing (ULift R)</code>?</p>",
        "id": 563815590,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1765803440
    },
    {
        "content": "<p>Then your induction principle only works for <code>IsNoetherianRing</code></p>",
        "id": 563815716,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765803471
    },
    {
        "content": "<p>and we still need a way of going from <code>PowerSeries (PowerSeries (...))</code> to <code>MvPowerSeries</code></p>",
        "id": 563816071,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765803574
    },
    {
        "content": "<p>so you'll need some sort of transfer across equiv anyway</p>",
        "id": 563816293,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765803633
    },
    {
        "content": "<p>Yeah that's the missing <code>MvPowerSeries.optionEquivLeft</code> which Junyan highlighted</p>",
        "id": 563816314,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765803637
    },
    {
        "content": "<p>and then you use the appropriate induction hypothesis for finite types which IIRC we do have.</p>",
        "id": 563816450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765803667
    },
    {
        "content": "<p>I mean we need the hypothesis that the <code>P</code> respects equivalence</p>",
        "id": 563816494,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765803679
    },
    {
        "content": "<p>even without the universe issue</p>",
        "id": 563816526,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765803687
    },
    {
        "content": "<p>You can look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.pi_induction#doc\">docs#Module.pi_induction</a> for a similar case. The trick is having two <code>motive</code>s and relating them by an <code>equiv</code> relation.</p>",
        "id": 563817922,
        "sender_full_name": "Christian Merten",
        "timestamp": 1765804035
    },
    {
        "content": "<p>I just finished a first draft of formalization of the finitely many variable case, which is <code>noetherian_mv.lean</code> in<br>\n<a href=\"https://github.com/BryceT233/power-series-ring-is-noetherian-\">https://github.com/BryceT233/power-series-ring-is-noetherian-</a><br>\nI will add more documentation, keep revising everything and finish the empty case soon.</p>\n<p>I also noticed the corresponding, more general setup in <code>MvPolynomial/Equiv.lean</code>; compared to that, the argument here is limited and does not reach the same level of generality.</p>",
        "id": 564374951,
        "sender_full_name": "Bingyu Xia",
        "timestamp": 1766028434
    },
    {
        "content": "<p>Nice work! On the other hand I think that for mathlib we should really follow what we did for <code>MvPolynomial</code>. Did you try that? It is of course a longer route, but it should be doable.</p>",
        "id": 564415834,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1766050518
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/an.20alternative.20formalization/near/564415834\">发言道</a>：</p>\n<blockquote>\n<p>Nice work! On the other hand I think that for mathlib we should really follow what we did for <code>MvPolynomial</code>. Did you try that? It is of course a longer route, but it should be doable.</p>\n</blockquote>\n<p>There might be some chance to generalize my <code>Fin n</code> case argument to <code>option</code> case, I will try!</p>",
        "id": 564588611,
        "sender_full_name": "Bingyu Xia",
        "timestamp": 1766101927
    },
    {
        "content": "<p>Indeed, the arguments in <code>Fin n</code> case generalizes to <code>option</code> case with no difficulty. I updated the first draft of the generalized arguments in a new file <code>optionEquivLeft.lean</code>. A minor issue is that I used subtraction, which will not work for semirings.</p>",
        "id": 564601852,
        "sender_full_name": "Bingyu Xia",
        "timestamp": 1766108882
    },
    {
        "content": "<p>I improved the argument and it no longer uses subtraction! maybe I should open a PR for this?</p>",
        "id": 564789562,
        "sender_full_name": "Bingyu Xia",
        "timestamp": 1766188328
    }
]