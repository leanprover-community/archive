[
    {
        "content": "<p>I am currently working on formalizing some model theory in Lean (specifically o-minimality).</p>\n<p><strong>Context:</strong> Assume we are working in a structure <code>M</code> that expands a dense linear order. By \"definable,\" I mean definable with parameters from the universe.</p>\n<p><strong>The Problem:</strong> I frequently need to introduce definitions that are intuitively first-order definable. For instance, given a definable function on an interval <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>I</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">f : I \\to M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>, I define an \"ascending point\"  essentially as:</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>I</mi><mo>∧</mo><mi mathvariant=\"normal\">∃</mi><mi>y</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo>∈</mo><mi>I</mi><mo>∧</mo><mi mathvariant=\"normal\">∀</mi><mi>u</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo>&lt;</mo><mi>u</mi><mo>&lt;</mo><mi>x</mi><mo>→</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo><mo>&lt;</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>∧</mo><mi mathvariant=\"normal\">∃</mi><mi>z</mi><mo stretchy=\"false\">(</mo><mi>z</mi><mo>∈</mo><mi>I</mi><mo>∧</mo><mi mathvariant=\"normal\">∀</mi><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>&lt;</mo><mi>v</mi><mo>&lt;</mo><mi>z</mi><mo>→</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>&lt;</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">x \\in I \\land \\exists y (y \\in I \\land \\forall u (y&lt;u&lt;x \\to f(u) &lt; f(x))) \\land \\exists z (z \\in I \\land \\forall v (x&lt;v&lt;z \\to f(x)&lt;f(v)))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)))</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)))</span></span></span></span></span></p>\n<p>(Note that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> are also definable.)</p>\n<p>And its formal definition is as following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsAscendingAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\">  </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Currently, for every such definition (even for simple ones like open intervals <code>Ioo a b</code>), I have to manually prove <code>Set.Definable</code> for them. This involves manually constructing the <code>FirstOrder.Language.Formula</code> term and unfolding definitions, which feels very repetitive and tedious.</p>\n<p><strong>My Question:</strong> Is there existing  a best practice to handle this? Or should we develop a tactic similar to <code>measurability</code> or <code>continuity</code> that can inspect the logical structure of the <code>Prop</code> and infer its definability. We could potentially go even further: similar to how <code>@[to_additive]</code> automatically creates additive versions, could we envision an attribute like <code>@[definable]</code> that automatically generates the proof of definability for a given definition for some <code>Set M</code>? Perhaps some advanced metaprogramming techniques would be useful here?</p>",
        "id": 558661508,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1763732323
    },
    {
        "content": "<p>I think there are some possible tactics and refactors that would help with this process, but there's already a better way to prove this sort of thing than writing the whole first-order formula from scratch.</p>",
        "id": 558721269,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1763747851
    },
    {
        "content": "<p>Definable sets satisfy certain closure properties, such as definable sets of a particular \"dimension\" forming a Boolean algebra.</p>",
        "id": 558721520,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1763747930
    },
    {
        "content": "<p>You may have to start with a few basic applications of the definition of definability, but you can bootstrap up with these lemmas.</p>",
        "id": 558721662,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1763747972
    },
    {
        "content": "<p>For a concrete instance of what I mean, if I was trying to prove definability of your <code>IsAscendingAt</code>, I'd apply <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Definable.inter#doc\">docs#Set.Definable.inter</a> to break it down into 3 simpler definability statements (one of which should be the assumption, missing here, that <code>I</code> itself is definable.)</p>",
        "id": 558721812,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1763748020
    },
    {
        "content": "<p>To deal with quantifiers, you can use lemmas such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Definable.image_comp#doc\">docs#Set.Definable.image_comp</a></p>",
        "id": 558722222,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1763748162
    },
    {
        "content": "<p>This API probably isn't ideal yet, but I think improving this is the first step, and then wrapping it in a tactic is the second step.</p>",
        "id": 558722328,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1763748191
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"984271\">@Zikang Yu</span> you can use a custom Aesop ruleset as a quick way to get a tactic that works for what you want<br>\nSpecifically, you register the lemmas that recursively break down the formula as <span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> describes as Aesop <code>apply</code> rules.<br>\nThis approach is already used to automate substructure membership goals - see the <code>SetLike</code> ruleset.</p>",
        "id": 558769403,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1763770190
    },
    {
        "content": "<p>It would be nice to have a custom <code>definability</code> tactic like <code>measurability</code>. FFL does the same thing</p>",
        "id": 558777876,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1763778812
    },
    {
        "content": "<p>And it's interesting how to automate definability of <code>f x &lt; f v</code>. I guess we need a predicate saying \"the graph of this function is definable\" and tag lemmas with <code>fun_prop</code></p>",
        "id": 558777926,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1763778880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400289\">Artie Khovanov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.28ModelTheory.29Automation.20for.20proving.20first-order.20definability/near/558769403\">說</a>：</p>\n<blockquote>\n<p>recursively break down the formula</p>\n</blockquote>\n<p>So basically I write down a definition with only  <code>Exists</code>, <code>And</code>, <code>Or</code> and <code>Neg</code> manually (or automatically maybe, by some simplifier), and use <code>aesop</code> with extra <code>apply</code> rules to deconstruct it into some \"atomic\" parts, then show these atomic parts are definable, which should be easily and directly. Is that an ideal process?</p>",
        "id": 558787935,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1763790668
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.28ModelTheory.29Automation.20for.20proving.20first-order.20definability/near/558777926\">說</a>：</p>\n<blockquote>\n<p>automate definability of <code>f x &lt; f v</code></p>\n</blockquote>\n<p>Yeah that's quite tedious, too. Even considering definable sets in the set algebra, we still need to use <code>preimage_comp</code> and <code>image_comp</code> to handle quantifiers.</p>",
        "id": 558791487,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1763794297
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"984271\">@Zikang Yu</span> yes, and hopefully you can discharge the atoms by some simp rules or something</p>",
        "id": 558799104,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1763801864
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400289\">@Artie Khovanov</span> Then how do we deal with parameters? </p>\n<p>Consider <code>{ x : M | x &lt; a} : Set M</code> where <code>a : M</code> is a parameter. Then we have <code>{x : M | x &lt; a} = {x : M | ∃ y, x &lt; y ∧ y = a}</code>. Now we can use <code>Definable.inter</code>, <code>Definable.preimage_comp</code> and <code>Definable.image_comp</code> to prove that the latter set is definable,  where we prove <code>{ (x,y) | x &lt; y }</code> and <code>{ x | x = a }</code> are definable by constructing the specific formulas.</p>\n<p>But the problem arises since we are actually dealing with <code>Fin 1 -&gt; M</code>. Now we have to prove <code>{v | v 0 &lt; a} = (fun g ↦ g ∘ fun (x : Fin 1) ↦ 0) '' S</code> where <code>S  = { v : Fin 2 → M | v 0 &lt; v 1 ∧ v 1 = a }</code>. Although the proof is straightforward, one of two directions still can't be completed by <code>simp</code>, <code>aesop</code> or <code>grind</code> since it needs a witness and a manual application of <code>List.ofFn_inj.mp</code> .</p>\n<p>Do we or should we have a lemma to automate this? If not, it would be easier to manually construct the constant term and the formula in this particular case.</p>",
        "id": 558805779,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1763808514
    },
    {
        "content": "<p>Yeah I don't know, sorry<br>\nAesop is good when your goal is soluble by some sort of structural recursion scheme but you don't want to have to specify the scheme<br>\nIf you have to supply witnesses, then yeah probably you should do some metaprogramming</p>",
        "id": 558815197,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1763818245
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"984271\">Zikang Yu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.28ModelTheory.29Automation.20for.20proving.20first-order.20definability/near/558805779\">said</a>:</p>\n<blockquote>\n<p>But the problem arises since we are actually dealing with <code>Fin 1 -&gt; M</code>. Now we have to prove <code>{v | v 0 &lt; a} = (fun g ↦ g ∘ fun (x : Fin 1) ↦ 0) '' S</code> where <code>S  = { v : Fin 2 → M | v 0 &lt; v 1 ∧ v 1 = a }</code>. Although the proof is straightforward, one of two directions still can't be completed by <code>simp</code>, <code>aesop</code> or <code>grind</code> since it needs a witness and a manual application of <code>List.ofFn_inj.mp</code> .</p>\n<p>Do we or should we have a lemma to automate this? If not, it would be easier to manually construct the constant term and the formula in this particular case.</p>\n</blockquote>\n<p>We definitely should have lemmas! For proving <code>Definable {v : Fin 1 -&gt; M | v 0 &lt; a}</code>, I could imagine the following steps:</p>\n<ol>\n<li>Apply lemma <code>Definable.lt</code> so that goal becomes <code>DefinableFun fun v : (Fin 1 -&gt; M) =&gt; v 0</code> and <code>DefinableFun fun v : (Fin 1 -&gt; M) =&gt; a</code> where <code>DefinableFun : ((a -&gt; M) -&gt; M) -&gt; Prop</code> says the function has a definable graph</li>\n<li>Apply lemma <code>DefinableFun.proj</code> and <code>DefinableFun.const</code> to resolve the two goals</li>\n</ol>\n<p><code>Definable.lt</code> should do the tedious things manually, like combine \"<code>&lt;</code> is definable\" and <code>Definable.image_comp</code></p>",
        "id": 558819987,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1763823067
    },
    {
        "content": "<p>Now I've managed to create an auxiliary lemma as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">definable_exists</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p_def</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">Definable</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">Definable</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">snoc</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Surprisingly, <code>aesop</code> can prove equalities about such set quite well, like <code>{v | v 0 &lt; a} = {v | ∃ x, p (Fin.snoc v x)}</code> where <code>p : (Fin 2 → M) → Prop := fun v ↦ v 0 &lt; v 1 ∧ v 1 = a</code>.</p>\n<p>My idea is that we can substitute variables with parameters (or more generally, functions that are definable but not in the language since you can regard parameters as constant functions). The strategy is to first permute the variable (or function) we want to replace to the last position using <code>Definable.image_comp</code>, and then apply <code>definable_exists</code> to introduce the existential quantifiers recursively. It still could be handy to prove the equality of the permuted sets, but maybe <code>aesop</code> performs well in these cases too, or we need an another auxiliary lemma.</p>\n<p>The only thing left is to manually construct the innermost <code>BoundedFormula</code> (under the nested existential quantifiers)—or, in this context, the predicate <code>p</code> on <code>n+m</code> variables. I suspect we might need some metaprogramming to automatically expand expressions into this form.</p>",
        "id": 558964449,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1763968577
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"984271\">@Zikang Yu</span> I got a proof of your lemma without constructing a formula explicitly. I guess this can still be golfed</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">definable_exists</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p_def</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">Definable</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">Definable</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">snoc</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">p_def</span><span class=\"bp\">.</span><span class=\"n\">image_comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">castSucc</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_setOf_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mem_image</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">lastCases</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 560264630,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1764110324
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"734814\">@Dexin Zhang</span> Yeah I used <code>image_comp (Fin.castSucc)</code> to prove this lemma as well. Now I wonder if we can directly use <code>Fin.insertNth</code> instead of <code>Fin.snoc</code> to insert the variable of an arbitrary index and then use  <code>image_comp (i.succAbove)</code> to eliminate it. Then we don't need to permute variables at all.</p>",
        "id": 560293458,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1764127429
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"984271\">@Zikang Yu</span> Do you mean things like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">definable_exists</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p_def</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">Definable</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">Definable</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">insertNth</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">p_def</span><span class=\"bp\">.</span><span class=\"n\">image_comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">succAbove</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_setOf_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mem_image</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">    </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">succAboveCases</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 560395951,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1764165262
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"734814\">@Dexin Zhang</span> Right. It would be more general.</p>",
        "id": 560436315,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1764175571
    },
    {
        "content": "<p>It seems like the only thing left is to get the first-order definition of some predicate <code>p : (Fin n → M) → Prop</code> or function <code>f : (Fin n → M) → M)</code> and prove the definablity recursively. Clearly one can always manunally write down the formula. And I believe there's little chance for someone to directly give a hugely complex definition.</p>\n<p>However, it still seems unlikely to automatically unfold some simple definition into a first-order formula. Consider the following \"indicator\" function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">indicator</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>(Suppose that <code>0</code> and <code>1</code> are aliases of some given elements of <code>M</code>, and <code>p</code> is definable.)<br>\nIts graph is essentially defined by the following formula:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">i_formula</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Of conrse we can easily prove the equivalence:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">indicator_is_defined_by_formula</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">indicator</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">i_formula</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But we can't directly prove that <code>A.Definable L { v | v 1 = indicator p (v 0) } ↔ A.Definable L { v | i_formula p (v 0) (v 1) }</code> without this lemma.</p>\n<p>Since working with functions is much more natural than raw formulas in contexts other than proving definability, we can't simply bypass this by only providing first-order definitions.</p>\n<p>Such definitions could be common, and the difficulty of proving their equivalence to formulas can vary, so I think this is the best we can do for now.</p>",
        "id": 560436677,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1764175678
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"984271\">@Zikang Yu</span> Yeah, these if-then-else are pretty common as definable functions.</p>",
        "id": 560880090,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1764389783
    },
    {
        "content": "<p>In fact, I would suggest not to operate on raw formulas at all. If we define <code>DefinableFun</code> as above, we can prove things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">DefinableFun</span><span class=\"bp\">.</span><span class=\"n\">ite</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">Definable</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">setOf</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">DefinableFun</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">DefinableFun</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">DefinableFun</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and make them aesop rules (or rules for the <code>definability</code> tactic, following FFL).</p>\n<p>If we operate on raw formulas, we have to unfold these if-then-else and write the formulas, which is doable but quite tedious.</p>",
        "id": 560880193,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1764389925
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"734814\">@Dexin Zhang</span> Then how do we deal with <code>match</code> expressions? Should they be treated as nested if-then-else statements and unfolded layer by layer? I'm not sure if the equivalence between them could be automatically verified.</p>",
        "id": 560882889,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1764392788
    },
    {
        "content": "<p>By the way, I tried to use the following definition to bypass the difficulties in proving definability of functions with only finitely many values:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">DefinableFunOfFiniteRange</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">Definable</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">})</span>\n</code></pre></div>\n<p>It even eliminates the problem that the values are actually not in the structure, given we use integers frequently.</p>\n<p>However, such a definition seems quite unrelated to the original definition <code>DefinableFun</code> since it actually is not a function to <code>M</code> at all. So that could be a convenient way, but not a proper way.</p>",
        "id": 560882903,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1764392808
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"984271\">Zikang Yu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.28ModelTheory.29Automation.20for.20proving.20first-order.20definability/near/560882889\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> Then how do we deal with <code>match</code> expressions? Should they be treated as nested if-then-else statements and unfolded layer by layer? I'm not sure if the equivalence between them could be automatically verified.</p>\n</blockquote>\n<p>That sounds quite tricky! Do you have a case where <code>match</code> has to be used instead of <code>if</code>?</p>",
        "id": 560883210,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1764393129
    },
    {
        "content": "<p><code>match</code> are auto-generated functions, so they can't be easily unfolded to <code>if</code>...</p>",
        "id": 560883316,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1764393280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"984271\">Zikang Yu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.28ModelTheory.29Automation.20for.20proving.20first-order.20definability/near/560882903\">said</a>:</p>\n<blockquote>\n<p>By the way, I tried to use the following definition to bypass the difficulties in proving definability of functions with only finitely many values:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">DefinableFunOfFiniteRange</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">Definable</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">})</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Is there any other assumption for <code>DefinableFunOfFiniteRange</code>? If I understand correctly, we can define <code>f x := if p x then true else false</code> then any set <code>{x | p x} = f ⁻¹' {true}</code> would be definable...</p>",
        "id": 560883718,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1764393715
    },
    {
        "content": "<p><code>DefinableFunOfFiniteRange</code> is actually a defintion but not a lemma. We may prove the equivalence of <code>DefinableFunOfFiniteRange</code> with <code>DefinableFun</code> if the codomain of <code>f</code> is <code>M</code>.</p>",
        "id": 560883943,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1764393954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.28ModelTheory.29Automation.20for.20proving.20first-order.20definability/near/560883210\">說</a>：</p>\n<blockquote>\n<p>Do you have a case where <code>match</code> has to be used instead of <code>if</code>?</p>\n</blockquote>\n<p>It seems not. I tried to use <code>match compare</code> to define a \"comparator\" function and dealing with <code>match</code> expression is actually an issue.</p>",
        "id": 560884128,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1764394108
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"984271\">Zikang Yu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.28ModelTheory.29Automation.20for.20proving.20first-order.20definability/near/560883943\">said</a>:</p>\n<blockquote>\n<p><code>DefinableFunOfFiniteRange</code> is actually a defintion but not a lemma. We may prove the equivalence of <code>DefinableFunOfFiniteRange</code> with <code>DefinableFun</code> if the codomain of <code>f</code> is <code>M</code>.</p>\n</blockquote>\n<p>Oh, that makes sense! Out of curiosity, what kinds of <code>f</code> do you find satisfying <code>DefinableFunOfFiniteRange</code>?</p>",
        "id": 560884240,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1764394252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.28ModelTheory.29Automation.20for.20proving.20first-order.20definability/near/560884240\">說</a>：</p>\n<blockquote>\n<p>What kinds of <code>f</code> do you find satisfying <code>DefinableFunOfFiniteRange</code>?</p>\n</blockquote>\n<p>For any definable predicate <code>p</code>, the indicator <code>fun x =&gt; if p x then 1 else 0 : (α → M) → Fin 2</code> would be a <code>DefinableFunOfFiniteRange</code>.</p>\n<p>And the following <code>comparator</code> should be as well, I guess.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">comparator</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">gt</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n</code></pre></div>",
        "id": 560884741,
        "sender_full_name": "Zikang 'Axi' Yu",
        "timestamp": 1764394767
    }
]