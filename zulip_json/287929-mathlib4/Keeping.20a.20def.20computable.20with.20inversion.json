[
    {
        "content": "<p>I have defined a probability mass function and want to normalise it. Normalisation is possible but it forces me to mark the result as ‚Äúnon computable‚Äù.</p>\n<p>I have a suspicion that this makes theorems about the normalised measure harder or impossible to check. </p>\n<p>The reason that it is like that is probably that I cannot invert a natural number safely because it can be zero. How do invert a nonzero natural number without introducing the ‚Äúnoncomputable‚Äù keyword?</p>",
        "id": 525321326,
        "sender_full_name": "Willem vanhulle",
        "timestamp": 1750682046
    },
    {
        "content": "<p>could you give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ? if you're talking about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PMF#doc\">docs#PMF</a>, i don't think your function is returning natural numbers...</p>",
        "id": 525322276,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750682371
    },
    {
        "content": "<p>No, noncomputable has nothing to do with making theorems harder or impossible. The vast majority of the definitions in the parts of mathlib I work in are noncomputable, this is a computer science thing to do with use of <code>#eval</code> and <code>#reduce</code>, not theorem proving.</p>",
        "id": 525322277,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750682372
    },
    {
        "content": "<p>fwiw, division by zero is computable on the natural numbers:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- no `noncomputable` needed</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>",
        "id": 525322527,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750682435
    },
    {
        "content": "<p>Ah yes, I was probably having reals but they were integers by coincidence. <span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span>. Okay so I should not worry about the nomcomputable. I was wondering if this problem was related to my inability to proof switching is the most optimal strategy in the Monty Hall brain teaser. I tried to use Bayes theorem from Mathlib. I can send a MWE example with sorries.</p>",
        "id": 525324124,
        "sender_full_name": "Willem vanhulle",
        "timestamp": 1750682928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Keeping.20a.20def.20computable.20with.20inversion/near/525322277\">said</a>:</p>\n<blockquote>\n<p>No, noncomputable has nothing to do with making theorems harder or impossible. The vast majority of the definitions in the parts of mathlib I work in are noncomputable, this is a computer science thing to do with use of <code>#eval</code> and <code>#reduce</code>, not theorem proving.</p>\n</blockquote>\n<p>So the noncomputable keyword is unrelated to usage of the ‚Äúdecide‚Äù macro?</p>",
        "id": 525325125,
        "sender_full_name": "Willem vanhulle",
        "timestamp": 1750683239
    },
    {
        "content": "<p>sort of</p>",
        "id": 525325213,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750683264
    },
    {
        "content": "<p>if the <code>Decidable</code> instance reduces to <code>.ofTrue</code> or <code>.ofFalse</code>, you're fine. this is more likely when all your functions are <code>computable</code>, but it can happen that that it isn't the case but still reduces</p>",
        "id": 525325527,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750683355
    },
    {
        "content": "<p>You won't be able to use the <code>decide</code> tactic for noncomputable things, but if you're working with the real numbers (for which equality is undecidable) you'll almost certainly not be using this tactic at all.</p>",
        "id": 525330632,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750684896
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Keeping.20a.20def.20computable.20with.20inversion/near/525330632\">said</a>:</p>\n<blockquote>\n<p>You won't be able to use the <code>decide</code> tactic for noncomputable things</p>\n</blockquote>\n<p>it's subtle though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- this is noncomputable</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"c1\">-- succeeds</span>\n</code></pre></div>\n<p>here <code>noncomputableInst</code> is noncomputable, but the decide tactic is able to use it anyway.</p>",
        "id": 525333114,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750685485
    },
    {
        "content": "<p>otoh, free variables can stop something which is decidable (and computable) from reducing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- this is computable</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- decide -- has a hard-coded error for free variables</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">of_decide_eq_true</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- fails too</span>\n</code></pre></div>",
        "id": 525335098,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750686014
    },
    {
        "content": "<p>The details are indeed subtle but I maintain that \"if you're doing probability theory then you don't need to worry at all about noncomputability\" is an accurate overview.</p>",
        "id": 525356025,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750691888
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928352\">Willem vanhulle</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Keeping.20a.20def.20computable.20with.20inversion/near/525324124\">said</a>:</p>\n<blockquote>\n<p>Ah yes, I was probably having reals but they were integers by coincidence.</p>\n</blockquote>\n<p>There are other tactics better suited for doing arithmetic (e.g. <code>norm_num</code> and <code>linarith</code>). The <code>decide</code> tactic can be useful, but to me it often feels like the wrong tool unless there really is a general algorithm.</p>\n<p>Real numbers are sort of computable in some senses, but also not really (there's no algorithm to decide whether or not two general real numbers are equal).</p>\n<p>Side question: what in the world is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.decidableEq#doc\">docs#Real.decidableEq</a> doing as a global instance? That's just <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.decEq#doc\">docs#Classical.decEq</a>, so not an algorithm in any sense. This is the reason <span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span>'s example seems to work, along with the fact that the <code>Option</code> decidable equality instance won't ask <code>Real.decidableEq</code> to do anything in the <code>none</code>/<code>some</code> case.</p>",
        "id": 525369189,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750696226
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928352\">Willem vanhulle</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Keeping.20a.20def.20computable.20with.20inversion/near/525324124\">said</a>:</p>\n<blockquote>\n<p>I can send a MWE example with sorries.</p>\n</blockquote>\n<p>Is this the MWE? <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Bayes.20theorem.20in.20Monty.20Hall.20problem/near/525352964\">#mathlib4 &gt; Bayes theorem in Monty Hall problem @ üí¨</a></p>",
        "id": 525369293,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750696260
    },
    {
        "content": "<p>Yes, I started on proving that the H and E are measurable sets. But no progress so far.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Keeping.20a.20def.20computable.20with.20inversion/near/525369293\">zei</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"928352\">Willem vanhulle</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Keeping.20a.20def.20computable.20with.20inversion/near/525324124\">said</a>:</p>\n<blockquote>\n<p>I can send a MWE example with sorries.</p>\n</blockquote>\n<p>Is this the MWE? <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Bayes.20theorem.20in.20Monty.20Hall.20problem/near/525352964\">#mathlib4 &gt; Bayes theorem in Monty Hall problem @ üí¨</a></p>\n</blockquote>",
        "id": 525369480,
        "sender_full_name": "Willem vanhulle",
        "timestamp": 1750696328
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Keeping.20a.20def.20computable.20with.20inversion/near/525369189\">said</a>:</p>\n<blockquote>\n<p>Side question: what in the world is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.decidableEq#doc\">docs#Real.decidableEq</a> doing as a global instance? </p>\n</blockquote>\n<p>We know that there won't ever be a true computing DecidableEq instance on the reals. So there is no cost in having the classical one around, and there is the benefit that you can apply all the lemmas needing DecidableEq without any more fuss.</p>",
        "id": 525370126,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1750696587
    },
    {
        "content": "<p>One cost is that tactics that use <code>decide</code> (like <code>simp +decide</code>) might think it can apply, then fruitlessly reduce the synthesized instance.</p>",
        "id": 525370352,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750696676
    },
    {
        "content": "<p>actually, if you try that, you'll see that the error message is suitably helpful to not be too much of a headache</p>",
        "id": 525370446,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1750696710
    },
    {
        "content": "<p><code>simp +decide</code> doesn't show error message. I'm talking about automation that repeatedly tries reducing something that's not going to reduce. I think all <code>Decidable</code> instances <em>should</em> be able to reduce.</p>",
        "id": 525370624,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750696793
    },
    {
        "content": "<p>I suspect <code>Real</code> having these \"bad\" global Decidable instances isn't a big deal, but poisoning the reducibility of the global instances isn't something that should be done lightly.</p>",
        "id": 525370866,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750696874
    },
    {
        "content": "<p>Conceivably there's some proposition <code>p</code> and a diamond of instances where when the <code>Real</code> ones are present the resulting <code>Decidable p</code> instance is not reducible, but when they are removed it becomes reducible. That's the sort of risk here (independent of the small performance issue I just mentioned). It's a small risk, but the risk is there.</p>\n<p>Maybe they should at least be marked as having low priority...</p>",
        "id": 525371069,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750696948
    },
    {
        "content": "<p>Any <code>LinearOrder</code> in Mathlib has DecidableEq. I remember the old Lean 3 times when we had <code>LinearOrder</code> and <code>DecidableLinearOrder</code> (maybe called <code>DiscreteLinearOrder</code> just to add to the confusion). It was causing a lot of pain for essentially no gain, so we decided to merge them. I don't remember any issue it would have created since then (but I'm not saying it won't ever create one!)</p>",
        "id": 525372440,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1750697490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Keeping.20a.20def.20computable.20with.20inversion/near/525371069\">said</a>:</p>\n<blockquote>\n<p>Conceivably there's some proposition <code>p</code> and a diamond of instances where when the <code>Real</code> ones are present the resulting <code>Decidable p</code> instance is not reducible, but when they are removed it becomes reducible.</p>\n</blockquote>\n<p>I guess this can happen for something like <code>Decidable ((1 : Real) = 1)</code></p>",
        "id": 525372780,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750697624
    },
    {
        "content": "<p>But I think in general we try to avoid <code>Decidable (x = y)</code> instances, and only have the fully quantified <code>DecidableEq Real</code> ones</p>",
        "id": 525372856,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750697653
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Keeping.20a.20def.20computable.20with.20inversion/near/525371069\">said</a>:</p>\n<blockquote>\n<p>Conceivably there's some proposition <code>p</code> and a diamond of instances where when the <code>Real</code> ones are present the resulting <code>Decidable p</code> instance is not reducible, but when they are removed it becomes reducible. That's the sort of risk here (independent of the small performance issue I just mentioned). It's a small risk, but the risk is there.</p>\n</blockquote>\n<p>Then that's just a bad instance, since it would lead to diamonds.</p>",
        "id": 525372874,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750697661
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> I don't see any problem with having them be merged ‚Äî it's fine having a classical DecidableEq instances safely inside the <code>LinearOrder</code> instance. It's the global instances that are suspect.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110050\">S√©bastien Gou√´zel</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Keeping.20a.20def.20computable.20with.20inversion/near/525370126\">said</a>:</p>\n<blockquote>\n<p>there is the benefit that you can apply all the lemmas needing DecidableEq without any more fuss.</p>\n</blockquote>\n<p>This makes me wonder why we have definitions needing <code>DecidableEq</code> in the first place, if in practice we're going to thwart the decidability system?</p>\n<p>Over in the Fintype world, we added Finite, which let us remove global noncomputable instances that were poisoning computability.</p>",
        "id": 525373208,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750697802
    },
    {
        "content": "<p>There is a global instance from <code>LinearOrder</code> to <code>DecidableEq</code> (I mean, registered as an instance, not just a field in the definition). So if we want the reals to be a linear order, they have to have a <code>DecidableEq</code> instance also.</p>",
        "id": 525374041,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1750698104
    },
    {
        "content": "<p>(I've said this before, but I think that having mathematical definitions use Decidable is a compromise, one that (1) increases the awkwardness of doing mathematical reasoning and (2) is lowest common denominator for computation, so it's in practice not living up to being a practical way to have mathematical definitions that are also executable. I know Eric says that at least for small examples it's useful being able to compute, and also sometimes it's nice when defeqs work out and make things more convenient (at the cost of heavy rfls!), but long term I don't see how we can keep this up. It seems much less costly for learning and for development to have a decidability-free theory and good automation to do computations. That includes synthesizing efficient programs to run to do the computation (reflection).)</p>",
        "id": 525374087,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750698123
    },
    {
        "content": "<p>Ah, I missed that, thanks <span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span>. That's a strong constraint.</p>",
        "id": 525374266,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750698191
    },
    {
        "content": "<p>Some people (inclusing I think <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span>, or myself) would definitely prefer a completely classical mathlib, without any decidability in it, but I don't think we'll get there, unfortunately.</p>",
        "id": 525374387,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1750698246
    },
    {
        "content": "<p>I would also prefer this (I say this after having to add random <code>DecidableEq</code> stuff recently to a bunch of declarations for no obvious reason other than \"it's how we do this in mathlib\"); I wonder whether we could make classicality happen with carefully-chosen <code>csimp</code>? I know that Bhavik will have a very different opinion because they actually use <code>decide</code> to prove things, whereas I don't think I have ever done this.</p>",
        "id": 525376423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750699070
    },
    {
        "content": "<p>One step would be a <code>FiniteSet</code> type (a <code>Set</code> bundled with a <code>Set.Finite</code> proof). <code>Finset</code> is a large source of unnecessary decidability. This wouldn't be to replace <code>Finset</code>, but it would be parallel to it, like <code>Finite</code> and <code>Fintype</code>. (Theory about <code>Finset</code> might drift to <code>FiniteSet</code>, especially if we have some good simp sets that can turn expressions about <code>Finset</code>s into <code>FiniteSet</code>s.) We'd also want to be able to evaluate <code>FiniteSet</code>s, but I don't think the story is really that different from <code>Finset</code> in the end, as far as tactics go.</p>\n<p>Another would be a noncomputable version of <code>if</code> that's purely classical (maybe <code>if!</code>?), just to save needing to write <code>open Classical in</code>, which makes it feel like you're doing something wrong.</p>",
        "id": 525376474,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750699089
    },
    {
        "content": "<p>I'm basically just reiterating myself though.</p>\n<p><a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/521124839\">#mathlib4 &gt; Why is &#96;Polynomial&#96; noncomputable? @ üí¨</a> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>: Rather than csimp per se, I think there's a future where a tactic like <code>decide</code> could synthesize an algorithm based on the specifics of what needs to be decided. (The <code>grind</code> tactic does a lot of this sort of thing as well ‚Äî it's great at deciding things about polynomials, even if the underlying ring isn't \"computable\"!)</p>",
        "id": 525376907,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750699278
    },
    {
        "content": "<p>More about <code>grind</code>: when it sees some arithmetic it needs to prove, it can use a custom polynomial type that has been design for very fast kernel computations. It \"reflects\" the goal into this custom type, does the computation there, and uses it to justify a calculation about the goal ‚Äî meanwhile it avoids actually computing anything using the goal's types (e.g. it might be a polynomial with <code>Real</code> coefficients).</p>",
        "id": 525377612,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750699507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Keeping.20a.20def.20computable.20with.20inversion/near/525376474\">said</a>:</p>\n<blockquote>\n<p>Another would be a noncomputable version of <code>if</code> that's purely classical (maybe <code>if!</code>?), just to save needing to write <code>open Classical in</code>, which makes it feel like you're doing something wrong.</p>\n</blockquote>\n<p>Or maybe just <code>classical% if</code>, since often there is something else in the if that also also needs classical logic anyway</p>",
        "id": 525382358,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750700978
    },
    {
        "content": "<p>Certainly <code>open scoped Classical in</code> is non-ideal, as its long, and it also encourages doing things at the command-level when actually we usually want it at the term-level</p>",
        "id": 525382495,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750701036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Keeping.20a.20def.20computable.20with.20inversion/near/525376423\">said</a>:</p>\n<blockquote>\n<p>I would also prefer this (I say this after having to add random <code>DecidableEq</code> stuff recently to a bunch of declarations for no obvious reason other than \"it's how we do this in mathlib\"); I wonder whether we could make classicality happen with carefully-chosen <code>csimp</code>? I know that Bhavik will have a very different opinion because they actually use <code>decide</code> to prove things, whereas I don't think I have ever done this.</p>\n</blockquote>\n<p>Oh this is happening to me again so I may as well make my comment more precise: group homology and cohomology seems to be demanding <code>[DecidableEq G]</code> everywhere and it's making my files look uglier and weirder-looking to mathematicians. Why has this happened I wonder?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">groupCohomology</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"n\">k</span>\n</code></pre></div>",
        "id": 525489371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750761948
    },
    {
        "content": "<p>Ultimately it comes from <a href=\"https://github.com/leanprover-community/mathlib4/blob/edf2cbec036cbc703268107faad1b6b16f216c3f/Mathlib/Algebra/Homology/HomologicalComplex.lean#L831\">here</a>, which looks ok</p>",
        "id": 525490251,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750762295
    },
    {
        "content": "<p>Actually, I think it's just unused</p>",
        "id": 525490636,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750762429
    },
    {
        "content": "<p>I have no idea why it's there</p>",
        "id": 525490647,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750762433
    },
    {
        "content": "<p>I guess we never got the <code>DecidableEq</code> linter from lean 3 that complained if decidability was only used in the proof?</p>",
        "id": 525490791,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750762480
    },
    {
        "content": "<p>That <code>if</code> is all about decidable equality on the index set (which is the naturals or integers), not on G, so I am skeptical about this claim (but I'm in a group cohomology meeting so can't think about this right now, sorry)</p>",
        "id": 525491961,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750762960
    },
    {
        "content": "<p>PR incoming</p>",
        "id": 525492042,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750762991
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/26352\">#26352</a></p>",
        "id": 525493448,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750763547
    },
    {
        "content": "<p>I prefer to think of this kind of noise in the same vein as \"Why did you use <code>Ring</code> when <code>Semiring</code> would suffice\", rather than that <code>Decidable</code> is somehow evil; while there are plenty of mathematicians who don't care about <code>Decidable</code> at all, the same is surely also true of semirings, or of free modules vs vector spaces, or char zero vs char-not-two, ....</p>",
        "id": 525504826,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750767527
    },
    {
        "content": "<p>Hmm, this did not completely solve the problem, to my surprise. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=groupHomology#doc\">docs#groupHomology</a> is still demanding <code>[DecidableEq G]</code> (which sounds like nonsense to me). One can chase this back in <code>RepresentationTheory/Homological/GroupHomology/Basic.lean</code> to  <code>groupHomology.inhomogeneousChains.d_eq</code> which needs <code>Rep.coinvariantsTensorFreeLEquiv</code> which involves <code>Finsupp</code> which it seems pollutes everything.</p>",
        "id": 525572779,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750789440
    },
    {
        "content": "<p>Right, I think that ultimately falls back on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.curry#doc\">docs#Finsupp.curry</a></p>",
        "id": 525595553,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750799267
    },
    {
        "content": "<p>This is probably a case where it's reasonable to add an <code>ooen scoped Classical</code> inside <code>groupHomology</code></p>",
        "id": 525596373,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750799665
    },
    {
        "content": "<p>I deliberately skipped it in that PR because it would be a bigger change, so made sense to do separately</p>",
        "id": 525596446,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750799693
    },
    {
        "content": "<p>Somewhat interestingly, it would be possible to implemented a potential <code>DFinsupp.curry</code> computably without decidable equality, but it is not possible to implement <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFinsupp.sigmaCurry#doc\">docs#DFinsupp.sigmaCurry</a> without it</p>",
        "id": 525597969,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1750800439
    },
    {
        "content": "<p>Since finsupps aren't really being used for computation, could we maybe make <code>Finsupp.curry</code> noncomputable using the classical instance and just put <code>[DecidableEq Œ±]</code> in all the API lemmas that need it?</p>",
        "id": 529937593,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753119578
    },
    {
        "content": "<p>I don't think that's worth it; anything mathematical using finsupp dowstream should be using it as an implementation detail, and is free to supply a classical instance as part of that implementation.</p>",
        "id": 529938084,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753119721
    },
    {
        "content": "<p><em>what about polynomials</em></p>",
        "id": 529938308,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753119795
    },
    {
        "content": "<p>Yes, the implementation of polynomials is free to provide a classical instance of <code>DecidableEq Nat</code> to the underlying finsupp if it so chooses (which is essentially what currently happens).</p>",
        "id": 529938392,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753119837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Keeping.20a.20def.20computable.20with.20inversion/near/529938392\">said</a>:</p>\n<blockquote>\n<p>Yes, the implementation of polynomials is free to provide a classical instance of <code>DecidableEq Nat</code> to the underlying finsupp if it so chooses (which is essentially what currently happens).</p>\n</blockquote>\n<p>No but the classical instance isn't the fault of polynomials, it comes from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.zipWith#doc\">docs#Finsupp.zipWith</a> which is part of the finsupp api and so should remain computable I think?</p>",
        "id": 532474438,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754156733
    },
    {
        "content": "<p>My \"essentially\" was doing some heavy lifting I'm afraid</p>",
        "id": 532482317,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1754163616
    }
]