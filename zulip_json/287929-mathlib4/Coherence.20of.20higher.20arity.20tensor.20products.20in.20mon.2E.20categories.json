[
    {
        "content": "<p>I have just pushed <a href=\"https://github.com/robin-carlier/mathlib4/blob/coherent-tensor-families-demo/Mathlib/CategoryTheory/Monoidal/CoherentTensorFamily.lean\">a branch</a> on my fork which formalizes a result/construction that I’ve been wanting in Mathlib for quite some time now: the construction of \"higher arity\" tensor product functors in monoidal categories, i.e the existence of functors <code>(Fin (n + 1) → C) ⥤ C</code> which send a family <code>(x₀, x₁, x₂, …, xₙ)</code> to <code>x₀ ⊗ x₁ ⊗ ⋯ ⊗ xₙ</code>, and (much more importantly!) the fact that this construction behaves nicely with respect to functors <code>Fin (n + 1) ⥤ Fin (m + 1)</code> (or equivalently, monotone maps <code>Fin (n + 1) →o Fin (m + 1)</code>. (See the discussion below where I clear up what I mean by \"behaves nicely\", as there might be more than one way to interpret what this means. )</p>\n<p>The construction of the functors is not impressive at all: these can be defined by induction in a very naive way, but working with that is actually not that easy, and the coherence of the construction with respect to monotone maps is tricky: one needs to re-associate the expressions in order to write down the correct maps; the inductive definition is simply <em>not</em> suited for this. </p>\n<p>I thus followed an indirect approach: given a monoidal category <code>C</code>, one can view <code>C</code> as a one-object bicategory in which the tensor product is composition. One can coherently encode composition in bicategories using Lack-Paoli's 2-nerve construction, whose simplicial structure gives the expected coherences.<br>\nMy original plan was to derive all of this from the existence (and some properties) of the 2-nerve of <code>MonoidalSingleObj C</code>. Unfortunately, the 2-nerve is a nest of DTT hell, and this resulted in constant defeq abuse (though I could construct the simplicial object).<br>\nInstead, I ended up defining an <em>ad hoc</em> structure <code>CoherentTensorFamily C n</code>, for every <code>n</code>, which is really a \"cleaned up\" description of the data of a pseudofunctor(*) from <code>LocallyDiscrete (Fin (n + 1))</code> to <code>MonoidalSingleObj C</code> (it doesn’t even mention <code>MonoidalSingleObj</code> or bicategories at the end of the day). One can directly directly construct a category structure on these objects (in terms of pseudofunctors, this would involve \"icons\", which are a source of DTT hell), and these objects have very easy to define functoriality with respect to monotone maps of <code>Fin</code>'s.<br>\nWith enough work on \"inductive\" constructors for objects and morphisms of <code>CoherentTensorFamily</code>, I could construct an equivalence of categories <code>CoherentTensorFamily C n ≌ Fin n ⟶ C</code>, and I showed that through this equivalence, one recovers the expected \"tensor product\" functors as the operation on <code>CoherentTensorFamily C n</code> that corresponds to a certain edge inclusion in simplicial terms. I am indebted to <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> here for the design he came up with for <code>ComposableArrows</code>, which was partly a guideline for how to do things here and in earlier versions of this work.</p>\n<p>I consider that this result is a small milestone for higher category theory in mathlib: this \"simplicial\" and coherent encoding of the tensor products of a monoidal category is absolutely key to prove the fact that a monoidal ordinary category is a monoidal infinity-category (one can define the latter as certain kind of fibrations over the opposite of the simplex category: in this case, the Grothendieck construction of the pseudofunctor I almost defined in this work will be the expected fibration), a statement that looks innocent but which is all about these \"coherence\" issues.</p>\n<p>I believe that this construction (and this point of view on monoidal categories it opens) will be essential for proving that the augmented simplex category is the \"walking monoid\", a fact that in turn will be needed to produce simplicial \"bar resolutions\" of monoid objects in general monoidal categories (and thus also for monads in categories).</p>\n<p>An other future direction will be to extend to the case of symmetric monoidal categories: in this case, the functoriality extends to maps of finite pointed sets; I am not yet sure on how to tackle this (it is again not that easy to obtain all the coherences).</p>\n<p>I still need to do some clean-up in the code linked above, but I intend to upstream this shortly. I wanted to make this post to share the small achievement, as well as some motivation and context around the result. </p>\n<hr>\n<p>(*) Technically, the 2-nerve is about strictly unitary pseudofunctors and not just pseudofunctors. I dropped this requirement, because it’s in fact nothing but a source of DTT hell. It seems this requirement is taken it order to make things \"easier\" in pen-and paper maths, but for formalization in dependent type theory, this has the opposite effect...</p>",
        "id": 535327053,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1755700086
    },
    {
        "content": "<p>Should I be surprised that you didn't do this for any finite ordered index set, rather than restricting to Fin n?</p>",
        "id": 535400583,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1755729966
    },
    {
        "content": "<p><del>I'd also like to see the corresponding construction in a symmetric monoidal category for any finite index set (presumably defined by taking a \"flat section\" of the bundle of tensor products over the space of orderings).</del> I think you said this above.</p>",
        "id": 535400665,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1755730034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Coherence.20of.20higher.20arity.20tensor.20products.20in.20mon.2E.20categories/near/535400665\">said</a>:</p>\n<blockquote>\n<p>I'd also like to see the corresponding construction in a symmetric monoidal category for any finite index set (presumably defined by taking a \"flat section\" of the bundle of tensor products over the space of orderings).</p>\n</blockquote>\n<p>I mention this is in the \"Another future direction\" paragraph.</p>",
        "id": 535400746,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1755730085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Coherence.20of.20higher.20arity.20tensor.20products.20in.20mon.2E.20categories/near/535400583\">said</a>:</p>\n<blockquote>\n<p>Should I be surprised that you didn't do this for any finite ordered index set, rather than restricting to Fin n?</p>\n</blockquote>\n<p>As I said, my end goal here was mainly to get the \"planar infinity-operad\" description of monoidal categories: this is why I focused on <code>Fin n</code>: this ease the link with the simplex category. Once this will be bundled as a pseudofunctor out of the simplex category, the extension to arbitrary finite linearly oredered set will \"just\" be the equivalence between the simplex category and the category of finite linearly ordered sets.</p>",
        "id": 535400969,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1755730239
    },
    {
        "content": "<p>Also, there’s quite a few constructions that would be a bit more painful with arbitrary finite types, but perhaps this is just skill issue on my end, and I might as well try and see how it goes if I define <code>CoherentTensorFamily C I</code> for a finite linearly ordered index type <code>I</code>. I expect \"inductive definitions\" to be a bit more of a pain.</p>",
        "id": 535401263,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1755730436
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Coherence.20of.20higher.20arity.20tensor.20products.20in.20mon.2E.20categories/near/535400746\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Coherence.20of.20higher.20arity.20tensor.20products.20in.20mon.2E.20categories/near/535400665\">said</a>:</p>\n<blockquote>\n<p>I'd also like to see the corresponding construction in a symmetric monoidal category for any finite index set (presumably defined by taking a \"flat section\" of the bundle of tensor products over the space of orderings).</p>\n</blockquote>\n<p>I mention this is in the \"Another future direction\" paragraph.</p>\n</blockquote>\n<p>(Though as said above: getting all the coherence right is a not so trivial problem, and I am still not sure how to tackle this right. ideas welcome!)</p>",
        "id": 535401417,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1755730559
    },
    {
        "content": "<p>I suspect jumping straight to arbitrary sets rather than working with Fin makes it much easier to state the coherences. :-)</p>",
        "id": 535401658,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1755730729
    },
    {
        "content": "<p>After some trying, there is no issue defining <code>CoherentTensorFamily C I</code> for <code>I : NonemptyFinLinOrd</code>, it’s very much functorial in <code>I</code>and of course there is a functor <code>CoherentTensorFamily C I ⥤ C</code> that essentially corresponds to the tensor product (no surprises here).<br>\nHowevew, the procedure that extends an <code>n</code>-simplex (+ some 2-simplices data) to a <code>n+1</code> simplex, which is the core of the construction of the equivalence <code>CoherentTensorFamily C (Fin n) ⥤ (Fin n → C)</code> is a different beast to adapt for a general fintype. I don’t see right now how replacing <code>Fin n</code> by any Fintype makes it any easier for this part. I guess I could replace it by an extension procedure for <code>CoherentTensorFamily C I</code> to <code>CoherentTensorFamily C (WithBot I)</code>, but I fail to see the added benefit here, given that once the <code>Fin n</code> version is defined (which it is now!) the <code>NonemptyFinLinOrd</code> version comes for free from the equivalence with the simplex category.</p>",
        "id": 535411523,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1755738530
    },
    {
        "content": "<p>What's the coherence we want at the end of the day relating the various tensorProdFunctor : (I \\to C) \\func C, and monotone maps (without mentioning <code>CoherentTensorFamily</code>)?</p>",
        "id": 535419290,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1755744716
    },
    {
        "content": "<p><del> Calling <code>Φ C I : I → C ⥤ C</code> these \"product functors\", given <code>f : J →o I</code>, you want isomorphism an <code>e f</code> between <code>Φ C I</code> and <code>precomp f ⋙ Φ C J</code>, where <code>precomp f : I → C ⥤ J → C </code>. You want these isomorphisms to be coherent wrt compositions and identities (I guess that last part is in the fact that <code>precomp</code> is coherent in that aspect, this isn’t too hard). </del> That is definitely not right.</p>",
        "id": 535433984,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1755755501
    },
    {
        "content": "<p>Morning coffee helped clearing up some brain fog.</p>\n<p>Given <code>f : J →o I</code> and <code>x : J → C</code>, there is a \"pushforward\" family <code>f_* x : I → C</code>, where <code>f_* x i</code> is the tensor product of the <code>x j</code>'s for <code>j</code>s such that <code>f j = i</code>. Part of the desired coherences here is that <code>f ↦ f_*</code> is suitably pseudofunctorial, and an identification between <code>g_*</code> and the \"J-shaped tensor product\" for <code>g : J →o Fin 1</code> through <code>Fin 1 → C ≌ C</code>. This construction seems indeed doable if you already have <code>I</code>-shaped tensor product functors for fintypes <code>I</code> (which already I might fail to see how to construct other than inductively when <code>I</code> is not <code>Fin</code>, but I admitedly lack experience with non-<code>Fin</code> fintypes). I don’t know about how easy its pseudofunctoriality is. In that description, the tensor product bifunctor corresponds (through some equivalences) to the unique map <code>Fin 2 →o Fin 1</code> (the degeneracy <code>σ 0 : ⦋1⦌ ⟶ ⦋0⦌</code> simplicially).</p>\n<p>Note that this is <em>covariant</em> w.r.t monotone maps, while the construction I did is <em>contravariant</em> instead: that’s because again what I was after was also the description of <code>C</code> as a planar infinity-operad (i.e a cocartesian fibration over the <em>opposite</em> of the simplex category, such that a \"Segal condition\" holds, or equivalently a pseudofunctor from the <em>opposite</em> of the simplex category to Cat): this is the simplicial object I defined. In that description, the tensor product bifunctor is encoded by the inclusion <code>Fin 2 →o Fin 3</code>, which is the face map <code>δ 1 : ⦋1⦌ ⟶ ⦋2⦌</code> in the simplicial world.</p>\n<p>Hopefully, this describes more clearly what I did. Given that the goal is the planar infinity-operad description, I don’t think I will refactor this using fintypes for now.</p>\n<p>Perhaps I should have titled this thread \"planar infinity-operad attached to a monoidal category\" instead.</p>",
        "id": 535446077,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1755761673
    },
    {
        "content": "<p>The relation between the two points of views (at least, when restricted to <code>Fin</code>) may be that there is a functor <code>SimplexCategory ⥤ SimplexCategoryᵒᵖ</code> that <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> formalized in <a href=\"https://github.com/leanprover-community/mathlib4/pull/27166\">#27166</a>, which sends <code>σ 0 : ⦋1⦌ ⟶ ⦋0⦌</code> to <code>δ 1 : ⦋1⦌ ⟶ ⦋2⦌</code>. Precomposing the simplicial object I defined (or an extension of it to <code>NonemptyFinLinOrd</code>) might give the \"covariant\" point of view.</p>",
        "id": 535448712,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1755762769
    },
    {
        "content": "<p>(Also, the description \"f_* x i = tensor product of the <code>x j</code>s for <code>j</code>'s such that f j = i\" in the \"covariant\" description seems like a red flag: this will <em>a priori</em> pack non-def equality of objects <code>x f j = x i</code> when trying to make this into an actual functor (<code>I → C ⥤ J → C</code>), and action of this at the level of maps might in fact be a headache).</p>",
        "id": 535451761,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1755764015
    }
]