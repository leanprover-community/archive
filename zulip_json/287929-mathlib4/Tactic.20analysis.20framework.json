[
    {
        "content": "<p>This weekend we got a <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/TacticAnalysis.html#Mathlib.TacticAnalysis.Config\">framework for analyzing tactics</a> merged int Mathlib. This was intended for large-scale tests like \"is <code>grind</code> a strict improvement over <code>omega</code>?\". But we can also do linting with it, such as warning when two adjacent calls to <code>rw</code> can be merged.</p>\n<p>The framework scans for sequences of tactics and calls user-configured passes on the corresponding infotree. Declare a pass by defining a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.TacticAnalysis.Config#doc\">docs#Mathlib.TacticAnalysis.Config</a> that has a <code>@[tacticAnalysis]</code> attribute. (There is also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.TacticAnalysis.ComplexConfig#doc\">docs#Mathlib.TacticAnalysis.ComplexConfig</a> that tries to do some steps for you, but it is still awkward to use; design suggestions welcome.) Some example passes are already available (currently disabled) in Mathlib: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/TacticAnalysis/Declarations.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/TacticAnalysis/Declarations.html</a></p>\n<ul>\n<li><code>linarithToGrind</code>, <code>omegaToGrind</code> and <code>ringToGrind</code> are used for developing <code>grind</code>: they report an error when one of those tactics can solve a goal, but <code>grind</code> cannot.</li>\n<li><code>rwMerge</code> warns when there are two <code>rw</code> calls that can become a single call.</li>\n<li><code>mergeWithGrind</code> warns when a proof contains <code>tac; grind</code> that could be a single <code>grind</code> call.</li>\n<li><code>terminalToGrind</code> warns when a sequence of tactic calls (currently of length at least 3) can be replaced with <code>grind</code>.</li>\n</ul>\n<p>What other passes can we think of? Maybe <code>continuity</code> to <code>fun_prop</code>?</p>",
        "id": 534970556,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1755529401
    },
    {
        "content": "<p>Great! <code>continuity</code> to <code>fun_prop</code> and <code>measurability</code> to <code>fun_prop</code> would be nice. <code>measurability</code> applies in some cases where <code>fun_prop</code> does not, but whenever the replacement is possible it results in a significant speed-up.</p>",
        "id": 534976710,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1755531349
    },
    {
        "content": "<p>simp_all to simp is also nice</p>",
        "id": 534977223,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1755531507
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> how are macros and autoParams handled? Does your framework track those too, or are they invisible?</p>",
        "id": 534977286,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1755531529
    },
    {
        "content": "<p>erw to rw would also be nice</p>",
        "id": 534977450,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1755531586
    },
    {
        "content": "<p>Possibly norm_num to simp</p>",
        "id": 534978333,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1755531870
    },
    {
        "content": "<p>Two successive <code>simp</code> calls that could be combined?</p>",
        "id": 534978901,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1755532056
    },
    {
        "content": "<p><code>nlinarith</code> to <code>linarith</code></p>",
        "id": 534978923,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1755532061
    },
    {
        "content": "<p>I don't know how desirable this is, but definitely plenty of times<code>linarith</code> can go to <code>order</code>, <code>ring</code>, or even just <code>abel</code>.</p>",
        "id": 534979352,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755532193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Tactic.20analysis.20framework/near/534978901\">said</a>:</p>\n<blockquote>\n<p>Two successive <code>simp</code> calls that could be combined?</p>\n</blockquote>\n<p>The problem is sometimes they can't be combined</p>",
        "id": 534979435,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755532220
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> Doesn't this framework precisely check whether they can be combined?</p>",
        "id": 534979602,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1755532270
    },
    {
        "content": "<p>Aaron, my understanding is that the purpose of this framework is that it allows you to specify, \"try the combined simp call and see if that works\" (ninja'd)</p>",
        "id": 534979630,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755532282
    },
    {
        "content": "<p>I can't tell</p>",
        "id": 534979635,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755532284
    },
    {
        "content": "<p>oh it does?</p>",
        "id": 534979658,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755532292
    },
    {
        "content": "<p>what happens when you time out?</p>",
        "id": 534979689,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755532300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Tactic.20analysis.20framework/near/534979352\">said</a>:</p>\n<blockquote>\n<p>I don't know how desirable this is, but definitely plenty of times<code>linarith</code> can go to <code>order</code>, <code>ring</code>, or even just <code>abel</code>.</p>\n</blockquote>\n<p><code>linarith</code> to <code>order</code> is particularly worth catching, since <code>order</code> conveys a lot more information.</p>",
        "id": 534979827,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1755532343
    },
    {
        "content": "<p>aesop to simp_all is also nice</p>",
        "id": 534979844,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1755532350
    },
    {
        "content": "<p>I don't know if these are problems likely to currently be in Mathlib, but nice \"tactic linters\" to have would be:</p>\n<ul>\n<li>Using <code>obtain</code> where <code>have</code> would suffice (this one at <a href=\"https://github.com/leanprover-community/mathlib4/blob/feb717448bb3d1672d20710f6e1704f9b171e917/Mathlib/GroupTheory/GroupAction/Iwasawa.lean#L66\">least</a> a <a href=\"https://github.com/leanprover-community/mathlib4/blob/feb717448bb3d1672d20710f6e1704f9b171e917/Mathlib/Algebra/Order/Archimedean/Class.lean#L283\">few</a> times)</li>\n<li>Using <code>apply</code> or <code>refine</code> where <code>exact</code> would suffice</li>\n<li>Using <code>tauto</code> where <code>rfl</code> would suffice (potentially risky, if the <code>rfl</code> only works by defeq abuse, but there's a \"clean\" proof in context?)</li>\n<li>I think many lines matching <code>have[.*]ontrivial</code> could be replaced with a <code>nontriviality</code> tactic.</li>\n<li>Cancelling out <code>by exact</code>s.<br>\n     * But not when they're part of <code>suffices ... by exact ...</code>, which would really be <code>suffices ... from ...</code>, but does not feel like such an obvious upgrade.<br>\n        * Except that very many <code>suffices ... by exact ... </code> are actually <code>suffices foo by exact bar this</code>, which can often just be <code>apply bar</code> instead.</li>\n</ul>",
        "id": 534983949,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755533759
    },
    {
        "content": "<p>This one is also up to taste, but there a ton of instances in mathlib of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">hik</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">i</span>\n</code></pre></div>\n<p>which could with some minimal effort be turned into</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">em</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hik</span>\n<span class=\"bp\">·</span>\n</code></pre></div>\n<p>which I think is nicer, personally</p>",
        "id": 534984136,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755533846
    },
    {
        "content": "<p>What about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=eq_or_ne#doc\">docs#eq_or_ne</a></p>",
        "id": 534984194,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755533868
    },
    {
        "content": "<p>yes, <code>em (i = k)</code> or <code>eq_or_ne i k</code>, either way. Maybe the latter's more readablee</p>",
        "id": 534984274,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755533904
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Tactic.20analysis.20framework/near/534983949\">said</a>:</p>\n<blockquote>\n<p>Using <code>obtain</code> where <code>have</code> would suffice</p>\n</blockquote>\n<p>I dislike these replacements of the form \"fast and capable tactic\" -&gt; \"fast and incapable tactic\", because you're effectively making the codebase harder to maintain for no good reason. In this world where <code>obtain</code> is strictly better than <code>have</code> at destructing, I see no reason to use <code>have</code>to destruct. When <code>have</code> is changed to be as capable as <code>obtain</code>, then we should delete <code>obtain</code></p>",
        "id": 535002570,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1755542193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Tactic.20analysis.20framework/near/534977286\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> how are macros and autoParams handled? Does your framework track those too, or are they invisible?</p>\n</blockquote>\n<p>It hooks into the linter, so if there are no infotrees about <code>autoParams</code> then they are invisible to tactic analysis. For macros at least, they are visible but consciously filtered out (since many tactic implementations are actually macros over other tactics, and I didn't want to make everyone look for <code>ring1</code> when they want to do <code>ring</code>). The filtering could be a configurable option if that would be desired. Then you'd need to do your own tactic sequence parsing probably.</p>",
        "id": 535003457,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1755542642
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Tactic.20analysis.20framework/near/535002570\">schrieb</a>:</p>\n<blockquote>\n<p>I see no reason to use <code>have</code> to destruct</p>\n</blockquote>\n<p>The point is to suggest using <code>have</code> when <code>obtain</code> is used to not destruct I think, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 535010833,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1755545857
    },
    {
        "content": "<p>Yes, that's what I meant. (I actually didn't know that <code>have</code> destructed products, oops... I've always just used obtain for destructuring products. <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> )</p>",
        "id": 535030715,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1755557414
    },
    {
        "content": "<p>Another \"tactic linter\": by_contra followed by push_neg could become by_contra!</p>",
        "id": 535033614,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1755559416
    },
    {
        "content": "<p>these are some options which are inspired by common golfs... I dont think they have been suggested yet:</p>\n<ul>\n<li>merging lines of <code>intro</code>/<code>intros</code></li>\n<li>inlining <code>have</code> if it's used at most once and is short enough</li>\n<li>merging <code>intro</code>(<code>s</code>) and <code>refine</code></li>\n<li>merging <code>refine</code>s</li>\n</ul>",
        "id": 535680325,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1755868636
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Tactic.20analysis.20framework/near/535680325\">said</a>:</p>\n<blockquote>\n<ul>\n<li>inlining <code>have</code> if it's used at most once and is short enough</li>\n<li>merging <code>refine</code>s</li>\n</ul>\n</blockquote>\n<p>I worry this may lead to decreased readability.</p>",
        "id": 535684284,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1755869909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Tactic.20analysis.20framework/near/535684284\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Tactic.20analysis.20framework/near/535680325\">said</a>:</p>\n<blockquote>\n<ul>\n<li>inlining <code>have</code> if it's used at most once and is short enough</li>\n<li>merging <code>refine</code>s</li>\n</ul>\n</blockquote>\n<p>I worry this may lead to decreased readability.</p>\n</blockquote>\n<p>Offen, I think it doesn't - but sometimes it surely will. In other words, if this is added, it should be disabled by default and come with a comment explaining the trade-off.</p>",
        "id": 535712871,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1755878348
    },
    {
        "content": "<p>Should all of this analysis come with profiling? \"<code>grind</code> works in place of <code> tac; grind</code>, but is 50% slower\" etc?</p>",
        "id": 535737272,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755888327
    },
    {
        "content": "<p>It would be wonderful to have the tool generate \"every <code>linarith</code>/<code>gcongr</code>/<code>field_simp</code>/... use in Mathlib\" as a test suite, so that we could review things we <em>think</em> are performance improvements to linarith with actual data.  Currently our only options are (1) profile individual examples where we see performance problems, (2) read the tea leaves to correlate benchmark performance on Mathlib files with the mix of tactics that appear in those files.</p>",
        "id": 535740832,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1755889739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Tactic.20analysis.20framework/near/535737272\">said</a>:</p>\n<blockquote>\n<p>Should all of this analysis come with profiling? \"<code>grind</code> works in place of <code> tac; grind</code>, but is 50% slower\" etc?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, it already does. (I mean, you can write tools in this framework that choose not to display this information, but the framework provides it.)</p>",
        "id": 535766514,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1755904132
    },
    {
        "content": "<p>I think it's best if these tools report only significant slow downs. It's just noise to say \"you can replace X with Y, but it is 3% slower\".</p>",
        "id": 535766569,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1755904201
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>, is ir possible to write a \"<code>simp only</code> squeezer\" in this framework? e.g. suppose we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">]</span>\n<span class=\"n\">some_tactic</span>\n<span class=\"n\">simp</span>\n</code></pre></div>\n<p>very often the <code>X, Y, Z</code> are only there because they are what <code>simp?</code> greedily produces at that step, but in fact some subset don't need to be used before <code>some_tactic</code> succeeds, and can then be absorbed into the terminal <code>simp</code>.</p>\n<p>I'm not certain this is technically possible with your current setup, could you let me know?</p>",
        "id": 535766713,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1755904340
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/28802\">#28802</a> adds an analysis for continuity/measurability -&gt; fun_prop</p>",
        "id": 535801039,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1755949161
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/28804\">#28804</a> adds a few more (still WIP)</p>",
        "id": 535802788,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1755951126
    },
    {
        "content": "<p>I would like to advocate: <code>simp only</code> -&gt; <code>simp_rw</code> where possible.</p>\n<p>There has been some prior discussion <a href=\"#narrow/stream/113488-general/topic/tactic.20caching/near/304586252\">here</a>, note that this might not be a performance benefit.</p>\n<p>However, I think the ability to click through individual lemmas in the infoview can be a huge readability / understanding boost, especially when you are not clear on why a theorem is true and you are trying to read Lean to understand.</p>",
        "id": 535864075,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1755983657
    },
    {
        "content": "<p>Also <code>simp_rw</code> -&gt; <code>rw</code>, but I would expect this to trigger less often.</p>",
        "id": 535864107,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1755983708
    },
    {
        "content": "<p>Also, <code>haveI</code> -&gt; <code>have</code> when the goal is a proposition.</p>",
        "id": 535888141,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756022460
    },
    {
        "content": "<p>And maybe <code>have</code> → <code>haveI</code> when it isn't?</p>",
        "id": 535900300,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1756039591
    },
    {
        "content": "<p>i just remembered, i don't think combinations like <code>simp; assumption</code> or <code>simp;exact</code> -&gt; <code>simpa</code> have been mentioned yet?</p>",
        "id": 535903711,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1756043458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Tactic.20analysis.20framework/near/535900300\">said</a>:</p>\n<blockquote>\n<p>And maybe <code>have</code> → <code>haveI</code> when it isn't?</p>\n</blockquote>\n<p>Although in principle this could lead to exponentially large terms.</p>",
        "id": 535905670,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756045668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span>, I presume you are talking about <code>simpa</code> without a <code>using</code> clause? would prefer <code>simp; exact ...</code> over <code>simpa using ...</code>, because it signifies that the term doesn't need to be simplified.</p>",
        "id": 535905984,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1756045994
    },
    {
        "content": "<p>firstly, i didn't mean to specify whether or not there is a <code>using</code> clause, i was merely referring to the general pattern which applies when golfing. Secondly, i don't care about showing if the term needs to be simplified, i care about line count.</p>",
        "id": 535906184,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1756046192
    },
    {
        "content": "<p>(<a href=\"https://github.com/leanprover-community/mathlib4/pull/28862\">#28862</a> is the linter for merging <code>intro</code> lines)</p>",
        "id": 535911487,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1756052253
    },
    {
        "content": "<p>something which could be useful/nice for the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.TacticAnalysis.ComplexConfig#doc\">docs#Mathlib.TacticAnalysis.ComplexConfig</a> is the ability to separate generating a suggestion from the check making sure that the suggestion is sane (and a proper replacement)... right now, <code>ComplexConfig.test</code> does both at the same time, which can result in an inflation of the registered heartbeatcount for the new suggestion.</p>",
        "id": 535912344,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1756053255
    },
    {
        "content": "<p>also, the ability to have code-actions and/or clickable <code>Try This</code> suggestions in the infoview might be useful?</p>",
        "id": 535912370,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1756053289
    },
    {
        "content": "<p>We can't use <code>addSuggestion</code> in linters (<a href=\"https://github.com/leanprover/lean4/pull/4363\">lean4#4363</a>), but we can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MessageData.hint#doc\">docs#Lean.MessageData.hint</a> ! Maybe that would work here?</p>",
        "id": 535912768,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756053770
    },
    {
        "content": "<p>Hmm, actually, that requires <code>CoreM</code> or some refactoring.</p>",
        "id": 535914554,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756055957
    },
    {
        "content": "<p>Is there a reason <code>tell</code> does not have a monadic return type? It would be awfully convenient for this to be in the highest monad possible, I think! (<code>CommandElabM</code>, as far as I can tell.) (Or at least be on top of <code>IO</code> so that we can save the <code>MetaM</code> state we want from <code>test</code> in <code>out</code> and run e.g. <code>CoreM</code>.)</p>",
        "id": 535914572,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756055987
    },
    {
        "content": "<p><del>Or, I suppose we can construct the <code>MessageData</code> in <code>test</code> if we must? Is that the intention?</del> (ah, but then we don't have easy access to the <code>ref</code> at which we're logging the message, so I can't imagine this is the intention.)</p>",
        "id": 535914702,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756056160
    },
    {
        "content": "<p>Also, ideally, the argument <code>currentTactic</code> in <code>trigger</code> should be of type <code>TSyntax `tactic</code>! :) Is that possible, or is it prevented by something?</p>",
        "id": 535915757,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756057471
    },
    {
        "content": "<p>i think that's possible, <a href=\"https://github.com/leanprover-community/mathlib4/blob/0041bc0332e4f62ac667060ad4d3a63a8ebb6f7b/Mathlib/Tactic/TacticAnalysis.lean#L304\">when it gets called</a> i think it already has that type</p>",
        "id": 535915820,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1756057561
    },
    {
        "content": "<p>I see that we \"dangerously\" cast the syntax in <code>TacticInfo</code> to <code>TSyntax `tactic</code> anyway in <code>runPass</code> before passing it to <code>trigger</code>, so hopefully we can stand by this promise. :)</p>",
        "id": 535915865,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756057622
    },
    {
        "content": "<p>So, this is the first I've taken some time to look at this, and: this is amazing, and I'm really excited about it! :D If it's okay, I have two initial thoughts, esp. on the request for design suggestions for the complex config.</p>",
        "id": 535950932,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756095909
    },
    {
        "content": "<ol>\n<li>I'm not sure we should handle the end of a sequence by inserting a <code>done</code>, as it breaks the expectation of all tactics having actually been written in source, and may be erroneously counted as a \"real\" <code>done</code> by linters which care about <code>done</code>! Rather, I think we should either:</li>\n</ol>\n<ul>\n<li>pass in <code>Syntax.missing</code>, which is unambiguous</li>\n<li>change the signature of <code>trigger</code> to take in an <code>Option Syntax</code></li>\n<li>change the signature of <code>trigger</code> to take in a flag e.g. <code>atEndAfterContinue : Bool</code> and pass in the last syntax again, which allows the behavior to depend on the last syntax in the chain without adjusting the context (which could be useful)</li>\n<li>or, add another field to the complex config called e.g. <code>atEndAfterContinue : ctx -&gt; Syntax -&gt; Option ctx</code>, where we pass back in the last syntax encountered in the chain, and a return value of <code>some c</code> is interpreted as an <code>.accept</code>ance.</li>\n</ul>\n<p>To me, the last option feels the most right. It could also have a default value of <code>fun _ _ =&gt; none</code> to keep config declarations uncluttered. But these are just the ideas I could come up with. :)</p>",
        "id": 535950944,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756095920
    },
    {
        "content": "<p>(2) I believe it might be nice if <code>test</code> and <code>tell</code> were consolidated somehow. Both take in arguments which are useful to the other: the information on the old tactic behavior is useful for testing and is available before testing, but is only passed to <code>tell</code>. We also might want to log several messages, or log them at specific tactics, so <code>tell</code> might like to have access to the <code>Array Syntax</code> that is available earlier, rather than the synthetic tactic. (Thought: to make logging at the correct position easy, the current ref ought to be set appropriately, so that a simple <code>logWarning</code> is probably correct.)</p>\n<p>I think logging is fairly easy, and that we do not necessarily need to funnel the author into producing an <code>Option MessageData</code>. Likewise, we might naturally want to construct our message in a higher monad (as in the case of <code>MessageData.hint</code>); and without <code>MetaM</code>, we cannot really use the <code>MVarId</code>s. The choice of <code>out</code> seems unnecessary, since it is effectively just an interface between <code>test</code> and <code>tell</code>—is there a reason we need an interface at all? Yes, kind of:</p>\n<p>As far as I can see, the biggest necessary difference to me seems to be that <code>test</code> must run down in <code>MetaM</code>, whereas <code>tell</code> could conceivably run up in <code>CommandElabM</code> and, crucially, in a different metavarcontext. (Indeed, the <code>TacticInfo</code> nodes only provide enough info for running <code>MetaM</code>, so we do seem to be locked into <code>MetaM</code> there...)</p>\n<p>A problem, therefore, seeems to be \"which state should I log my message in\". This seems to depend on the details of <code>runTactic</code>—I think it's good to keep much of that machinery conveniently hidden from the author! (While generally I'm in favor of flexibility here, I also want to avoid boilerplate and heavy lifting of that sort.)</p>\n<p>I have just started thinking about this, so I do not have a (good) idea to offer yet. But I wonder if there is a way to just run one thing in <code>MetaM Unit</code> or <code>CommandElabM Unit</code> (the latter of which would demand an appropriate API to make the sorts of things we typically want to do smoother), while providing the opportunity to easily switch to logging from within the original \"final\" state if necessary.</p>",
        "id": 535951045,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756095996
    },
    {
        "content": "<p>Small issues:</p>\n<ul>\n<li>I PR'd a fix to log messages on the tactic sequence range, instead of the whole command (the synthetic syntax was picking up position info from the ambient ref): <a href=\"https://github.com/leanprover-community/mathlib4/pull/28919\">#28919</a></li>\n<li>There's a tricky issue preventing <code>withSetOptionIn</code> from working as expected: <code>findTacticSeqs</code> only visits trees with syntax whose range is enclosed by the range of the syntax which is passed in. However, due to <code>withSetOptionIn</code>, the syntax passed in is only the syntax nested within <code>set_option ... in &lt;stx&gt;</code>, whereas the ranges recorded in the infotrees are the whole command. Hence, the top-level infotrees are not enclosed in the syntax we're looking at, and we skip them. <a href=\"https://github.com/leanprover-community/mathlib4/pull/28926\">#28926</a> fixes this simply by passing in the enclosing syntax.</li>\n</ul>",
        "id": 536113060,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756157758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Tactic.20analysis.20framework/near/535766713\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span>, is ir possible to write a \"<code>simp only</code> squeezer\" in this framework? e.g. suppose we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">]</span>\n<span class=\"n\">some_tactic</span>\n<span class=\"n\">simp</span>\n</code></pre></div>\n<p>very often the <code>X, Y, Z</code> are only there because they are what <code>simp?</code> greedily produces at that step, but in fact some subset don't need to be used before <code>some_tactic</code> succeeds, and can then be absorbed into the terminal <code>simp</code>.</p>\n<p>I'm not certain this is technically possible with your current setup, could you let me know?</p>\n</blockquote>\n<p>I don't see any technical objections: in the low-level interface, we are given a list of tactic calls. For each subsequence of the form <code>simpOnly :: tail</code>, where <code>simpOnly</code> has the form <code> `(tactic| simp only $simpArgs)</code> and <code>tail.getLast == `(tactic| simp)</code>:</p>\n<ul>\n<li>build a new call to <code>simp only</code> for each subset of the <code>simpArgs</code></li>\n<li>rebuild a new tactic sequence using a call like <code>let seq ← `(tactic| $(newSimpOnly :: tail).toArray;*)</code></li>\n<li>call <code>runTactic</code> on the new <code>seq</code>, check if that also closes the goal.</li>\n</ul>\n<p>Practical objections exist though: we'd have to check a lot of subsets, running a potentially very long sequence of tactics each time. Maybe we'd delete only the arguments from the <code>simp only</code> that are in fact in the <code>simp</code> set?</p>",
        "id": 536188009,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1756198112
    },
    {
        "content": "<p>When <a href=\"https://github.com/leanprover-community/mathlib4/pull/29089\">#29089</a> lands, adding a linter for calls to <code>field</code> which could become <code>ring</code> would be nice!</p>",
        "id": 542278762,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1759239483
    }
]