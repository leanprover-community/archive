[
    {
        "content": "<p>Hello mathlib community,</p>\n<p>I’m preparing a contribution formalizing the Sylvester–Schur theorem (often called Sylvester’s theorem). In the formulation I have fully formalized in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">exists_prime_gt_and_dvd_ascFactorial</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hkn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p.Prime</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n.ascFactorial</span><span class=\"w\"> </span><span class=\"n\">k</span>\n</code></pre></div>\n<p>Informally: for <code>0 &lt; k &lt; n</code>, the rising factorial <code>n.ascFactorial k = n * (n+1) * ... * (n+k-1)</code> has a prime divisor strictly larger than <code>k</code>.</p>\n<p>Before opening a PR, I’d like to ask some questions:</p>\n<p>Is this theorem a good fit for mathlib?</p>\n<p>The proof follows the classical Erdős-style argument (bounding a related binomial coefficient via prime-factor envelopes / primorial-style products / central binomial coefficient chains, then deriving a contradiction under a “no prime &gt; k divides” hypothesis).</p>\n<ul>\n<li>I’m trying to keep dependencies reasonable and reuse existing lemmas where possible, but the development does introduce some supporting infrastructure (product decompositions and inequalities tailored to the argument).</li>\n</ul>\n<p>Any red flags you anticipate (e.g. proof too long/fragile, too much bespoke inequality machinery, or missing connections to existing results like <code>Mathlib/NumberTheory/Bertrand.lean</code>)?</p>\n<p>For reference, Wikipedia’s discussion of “Sylvester’s theorem” in the Bertrand page is here:<br>\n<a href=\"https://en.wikipedia.org/wiki/Bertrand%27s_postulate#Sylvester%27s_theorem\">https://en.wikipedia.org/wiki/Bertrand%27s_postulate#Sylvester%27s_theorem</a></p>\n<p>Also: the formalization was drafted with AI assistance and then reviewed/edited by me</p>\n<p>Thanks a lot for any guidance on whether this is “in scope” for mathlib and what acceptance criteria I should keep in mind.</p>",
        "id": 575936833,
        "sender_full_name": "Coder-Osman",
        "timestamp": 1772084673
    },
    {
        "content": "<p>If you've already done the work, you may as well upload a draft PR and link back to this discussion in the description; probably the most relevant factor is the size of the contribution, since usually for first contributions we recommend contributors start small.</p>",
        "id": 575937281,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772084904
    },
    {
        "content": "<p>The statement is something I believe mathlib should have. The size and quality of code are the potential red flags, especially with AI-assisted proofs.</p>",
        "id": 575937409,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1772084973
    },
    {
        "content": "<p>Thanks Eric and Bhavik — this is very helpful.<br>\nI agree that the main question is really the size/maintainability. I’ve already completed a full formalization of the core statement and I’m currently doing some cleanup work, in particular removing remaining native_decide usage.<br>\nI’ll post the draft PR link shortly after the native_decide removal and cleanup are complete.</p>",
        "id": 575940489,
        "sender_full_name": "Coder-Osman",
        "timestamp": 1772086635
    },
    {
        "content": "<p>Oooh, do I have a lot to say about this.</p>\n<p>The short version is that the Erdos proof leaves lots of small cases to the reader, and does not prove the general version involving irreducible arithmetic progressions.  Nor does his work extend easily to modern improvements of the Sylvester-Schur Theorem.</p>\n<p>The long version is that I am also formalizing that theorem, but in parallel with some generalizations of it.  (I omit details which are mathematically interesting but may not be appropriate for this thread.) If you (or anyone else) is interested in what I have learned so far, I encourage you to DM (direct message) me.  I have a spotty connection, but I will respond eventually.</p>\n<p>I will be very interested in hearing about the challenges you encounter in the formalization of the proof, especially in how you restate the Erdos bound of lcm(1..n) which he uses.  I am also willing to compare notes and receive assistance on my path toward formalization.</p>",
        "id": 575950465,
        "sender_full_name": "J. J. Issai (project started by GRP)",
        "timestamp": 1772091451
    },
    {
        "content": "<p>I’ve uploaded a draft PR here: <a href=\"https://github.com/Coder-Osman/mathlib4/blob/master/Mathlib/NumberTheory/SylvesterSchur.lean\">https://github.com/Coder-Osman/mathlib4/blob/master/Mathlib/NumberTheory/SylvesterSchur.lean</a></p>\n<p>One remaining blocker is removing the native_decide-based finite check. I’ve been working on replacing it with a decide-only approach, but in practice it’s still extremely slow—even with an algorithmic improvement (roughly linear-time in the range being checked), the kernel checking time can be on the order of tens of minutes. I’ll need a few more days to engineer a Lean-friendly certificate/verification strategy and then I’ll update the PR.</p>",
        "id": 576008948,
        "sender_full_name": "Coder-Osman",
        "timestamp": 1772108678
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1024069\">Coder-Osman</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Would.20mathlib.20accept.20Sylvester.E2.80.93Schur.20.28Sylvester.E2.80.99s.20theorem.29.3F/near/576008948\">said</a>:</p>\n<blockquote>\n<p>I’ve uploaded a draft PR here: <a href=\"https://github.com/Coder-Osman/mathlib4/blob/master/Mathlib/NumberTheory/SylvesterSchur.lean\">https://github.com/Coder-Osman/mathlib4/blob/master/Mathlib/NumberTheory/SylvesterSchur.lean</a></p>\n</blockquote>\n<p>This is not a draft PR, you currently <a href=\"https://github.com/leanprover-community/mathlib4/pulls/Coder-Osman\">have no PRs</a> to Mathlib.<br>\nSee <a href=\"https://leanprover-community.github.io/contribute/git.html\">Git Guide for Mathlib4 Contributors</a> for help.</p>",
        "id": 576015889,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1772110725
    },
    {
        "content": "<p>(though it does let others see your code, so maybe a draft PR is redundant)</p>",
        "id": 576016139,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1772110784
    },
    {
        "content": "<p>Besides the finite check, do you see any other aspect that would discourage the draft from being accepted into Mathlib?</p>",
        "id": 576063387,
        "sender_full_name": "J. J. Issai (project started by GRP)",
        "timestamp": 1772122034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"930113\">J. J. Issai (project started by GRP)</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Would.20mathlib.20accept.20Sylvester.E2.80.93Schur.20.28Sylvester.E2.80.99s.20theorem.29.3F/near/576063387\">said</a>:</p>\n<blockquote>\n<p>Besides the finite check, do you see any other aspect that would discourage the draft from being accepted into Mathlib?</p>\n</blockquote>\n<p>Besides the native_decide, I don’t see any other aspect that would discourage acceptance into mathlib.</p>",
        "id": 576181093,
        "sender_full_name": "Coder-Osman",
        "timestamp": 1772168964
    },
    {
        "content": "<p>Quick update: I’ve removed native_decide from the finite check. It now uses only decide, and compiles in about ~2 minutes on my machine. Is that within the usual acceptable range for mathlib?</p>",
        "id": 576206453,
        "sender_full_name": "Coder-Osman",
        "timestamp": 1772182067
    },
    {
        "content": "<p>Now I optimized it to ~1.5 minutes on my machine</p>",
        "id": 576210805,
        "sender_full_name": "Coder-Osman",
        "timestamp": 1772183462
    },
    {
        "content": "<p>2 minutes is way too much for an individual file. Mathlib consists of 8,000 different files and takes only about an hour to build in full.</p>",
        "id": 576238664,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1772192187
    },
    {
        "content": "<p>...though your file is also 3k lines long, whereas Mathlib has a 1.5k line restriction per file, and most files are well under 1k.</p>",
        "id": 576239129,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1772192352
    },
    {
        "content": "<p>How are you verifying the cases below 2304? I know that for Bertrand's postulate you also get a similarly large lower bound, but then it turns out you only have to check that about 20 numbers are prime. Does something similar happen here?</p>",
        "id": 576239799,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1772192559
    },
    {
        "content": "<p>Assuming there isn't some <code>decide</code> call that's taking most of the compile time, and assuming you can clean up your code to Mathlib standards, then I think it should belong in there.</p>",
        "id": 576241754,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1772193221
    },
    {
        "content": "<p>I’ve now removed native_decide, and I managed to get the FiniteCheck part to compile in ~10s on my machine (it’s decide-only). </p>\n<p>The remaining issue is size: after the refactor the development is ~6000 lines. Would you prefer that I move the finite-check machinery into a separate file (e.g. SylvesterSchur/FiniteCheck.lean) so the main theorem file stays within the usual line/maintenance expectations?</p>",
        "id": 576247462,
        "sender_full_name": "Coder-Osman",
        "timestamp": 1772195007
    },
    {
        "content": "<p>As a rule of thumb, no file in mathlib should be larger than 1500 files (and usually, we prefer shorter than 1000 lines). The code should definitely be split sensibly.</p>",
        "id": 576247671,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1772195068
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Would.20mathlib.20accept.20Sylvester.E2.80.93Schur.20.28Sylvester.E2.80.99s.20theorem.29.3F/near/576239799\">said</a>:</p>\n<blockquote>\n<p>How are you verifying the cases below 2304? I know that for Bertrand's postulate you also get a similarly large lower bound, but then it turns out you only have to check that about 20 numbers are prime. Does something similar happen here?</p>\n</blockquote>\n<p>For Sylvester–Schur I don’t think there’s a Bertrand-style reduction to “check a tiny fixed list of primes”: the obstruction is that we need a witness prime depending on both n and k.</p>\n<p>Instead, I verify the finite range n ≤ 2304 via an explicit algorithmic certificate:</p>\n<ul>\n<li>For each n I construct a small list of primes (in practice ≤ 3 primes suffice) such that their associated validity intervals cover all k ∈ {1,…,⌊n/2⌋}.</li>\n<li>Given a prime p, its interval is computed from r = n % p as k ∈ [r+1, min(p-1, ⌊n/2⌋)] .</li>\n<li>Then the checker just verifies coverage of 1..⌊n/2⌋ by these intervals, plus primality of the chosen p’s.</li>\n</ul>\n<p>This makes the verification essentially linear in n overall, rather than enumerating all (n,k) pairs.</p>",
        "id": 576248198,
        "sender_full_name": "Coder-Osman",
        "timestamp": 1772195226
    },
    {
        "content": "<p>That said, the big open questions are the size and quality of your code: I don't think any experienced mathlib contributor has looked at that yet. Bare AI output is far from good enough.</p>",
        "id": 576248215,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1772195233
    },
    {
        "content": "<p>Looking through the code, I think the answer to \"would mathlib accept this multi-thousand line file\" (which is my interpretation of the title of this thread) is \"not without a large amount of further work\". Some of the code is good, some is terrible (e.g. <code>have _ := hn0</code>), and as usual with LLM-generated code there are far too many definitions almost none of which have any API, and some of the proofs are far too long.</p>",
        "id": 576283477,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1772204837
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/gsaCJHV4bSWTqYYHcxQVK6ZA/Screenshot-2026-02-27-at-15.09.58.png\">Screenshot 2026-02-27 at 15.09.58.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/gsaCJHV4bSWTqYYHcxQVK6ZA/Screenshot-2026-02-27-at-15.09.58.png\" title=\"Screenshot 2026-02-27 at 15.09.58.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1522x1232\" src=\"/user_uploads/thumbnail/3121/gsaCJHV4bSWTqYYHcxQVK6ZA/Screenshot-2026-02-27-at-15.09.58.png/840x560.webp\"></a></div><p>Another typical issue with LLM-generated code is the \"wall of <code>have</code> phenomenon\". (this is in the middle of  a 100-line proof).</p>",
        "id": 576284388,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1772205049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Would.20mathlib.20accept.20Sylvester.E2.80.93Schur.20.28Sylvester.E2.80.99s.20theorem.29.3F/near/576239799\">said</a>:</p>\n<blockquote>\n<p>How are you verifying the cases below 2304? I know that for Bertrand's postulate you also get a similarly large lower bound, but then it turns out you only have to check that about 20 numbers are prime. Does something similar happen here?</p>\n</blockquote>\n<p>Sylvester's original proof showed (using instead the form (m+1)<em>(m+2)</em>...(m+n) ) that the result held for m&gt;n^2 and then for 13&lt;n&lt;3000 by a largish table of prime gaps.  Erdos provides no such argument for small cases, and I suspect that is not happening in the repo being submitted/refactored.  I imagine that a hand-coded version could work for the check along the lines of Sylvester's argument, but a lot of lines of code would be spent on k&lt;= 13 because of the formalization challenges.</p>",
        "id": 576358992,
        "sender_full_name": "J. J. Issai (project started by GRP)",
        "timestamp": 1772230927
    },
    {
        "content": "<p>Thanks, this is very helpful feedback.<br>\nI agree with your assessment: in its current form, this draft is not ready for mathlib. Some parts are in decent shape, but there is clearly a lot of cleanup and restructuring still needed. In particular, I need to break the file into smaller units, remove many ad hoc definitions in favor of a better API, shorten some of the longer proofs, and clean up the proof style throughout.<br>\nI’ll take this as a guide for the next round of refactoring.</p>",
        "id": 576385720,
        "sender_full_name": "Coder-Osman",
        "timestamp": 1772249957
    },
    {
        "content": "<p>Mathlib could accept this result, polished up, to answer your original query.</p>",
        "id": 576392568,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1772257121
    },
    {
        "content": "<p>I agree. I am also not at all convinced that a human with no experience of writing mathlib-standard code and armed with an LLM, however expensive, could pull this off. The LLMs aren't yet good enough and if a concerted effort is made by the human to use it to make mathlib-standard PRs it won't be long before human reviewers become exasperated with the slop and just stop reviewing. That's the unfortunate state of affairs right now.</p>\n<p>In general the community is perfectly well aware that an arbitrary mathematical result at Masters level can currently be formalised into code that compiles by a sufficiently expensive machine, and they are also well aware that this is nowhere near enough to get it into mathlib. On the other hand there is a whole crowd of people out there who are not part of this community and who are not aware of this  and each of them seems to need to be told individually.</p>",
        "id": 576404215,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1772267839
    },
    {
        "content": "<p>How about this statement (after fixing syntax errors)?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">exists_prime_gt_k_and_dvd_irred_arithprog_k</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hkn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hnd</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">=</span><span class=\"n\">gcd</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\">  </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">*</span><span class=\"n\">d</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Would that be accepted as well (and would it displace the first theorem, which is the case d=1)?  Or would both have a place in Mathlib?</p>",
        "id": 576405716,
        "sender_full_name": "J. J. Issai (project started by GRP)",
        "timestamp": 1772269251
    },
    {
        "content": "<p>Thanks — this is a fair point, and I understand the distinction you’re making between “code that compiles” and “code that is actually suitable for mathlib.”</p>\n<p>I’ll continue restructuring the proof and cleaning up the code with mathlib standards in mind. I’m not expecting reviewers to help polish an LLM-generated draft into an acceptable PR; that part is my responsibility. My goal is to reduce the amount of ad hoc material, improve the API and proof structure, and only ask for review once the development is in much better shape.</p>",
        "id": 576405794,
        "sender_full_name": "Coder-Osman",
        "timestamp": 1772269308
    }
]