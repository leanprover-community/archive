[
    {
        "content": "<p>Inspired by <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Matrix.2Econs_val_five/with/506621693\">#Is there code for X? &gt; Matrix.cons_val_five</a> I propose that we collect lemmas that should probably be simp-procified. Here is a start.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib/Data/Matrix/Notation.lean -- around L400-450</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">one_fin_three</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">!!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"c1\">--</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">natCast_fin_three</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">!!</span><span class=\"o\">[</span><span class=\"bp\">↑</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"c1\">--</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ofNat_fin_three</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">AtLeastTwo</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ofNat</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"c1\">--</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">eta_fin_three</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">!!</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">;</span>\n<span class=\"c1\">--</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mul_fin_three</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">a₁₁</span><span class=\"w\"> </span><span class=\"n\">a₁₂</span><span class=\"w\"> </span><span class=\"n\">a₁₃</span><span class=\"w\"> </span><span class=\"n\">a₂₁</span><span class=\"w\"> </span><span class=\"n\">a₂₂</span><span class=\"w\"> </span><span class=\"n\">a₂₃</span><span class=\"w\"> </span><span class=\"n\">a₃₁</span><span class=\"w\"> </span><span class=\"n\">a₃₂</span><span class=\"w\"> </span><span class=\"n\">a₃₃</span><span class=\"w\"> </span><span class=\"n\">b₁₁</span><span class=\"w\"> </span><span class=\"n\">b₁₂</span><span class=\"w\"> </span><span class=\"n\">b₁₃</span><span class=\"w\"> </span><span class=\"n\">b₂₁</span><span class=\"w\"> </span><span class=\"n\">b₂₂</span><span class=\"w\"> </span><span class=\"n\">b₂₃</span><span class=\"w\"> </span><span class=\"n\">b₃₁</span><span class=\"w\"> </span><span class=\"n\">b₃₂</span><span class=\"w\"> </span><span class=\"n\">b₃₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n</code></pre></div>",
        "id": 506635622,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742360925
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib/Data/Set/Card.lean</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">encard_eq_three</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">encard</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"c1\">--</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ncard_eq_three</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">ncard</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">encard_eq_three</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ncard_def</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast_inj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast_ofNat</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 506635692,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742360977
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib/Data/Nat/Cast/Defs.lean -- L174</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">cast_three</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 506635839,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742361051
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib/NumberTheory/Divisors.lean -- L605</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">divisorsAntidiagonal_three</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">divisorsAntidiag</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">3</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 506635929,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742361118
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib/LinearAlgebra/Matrix/Trace.lean -- L214</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">trace_fin_three</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>",
        "id": 506636204,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742361270
    },
    {
        "content": "<p>One simp-proc to rule them all:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib/Algebra/BigOperators/Fin.lean -- L114</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">prod_univ_three</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommMonoid</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∏</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>",
        "id": 506636292,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742361337
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib/Algebra/FreeMonoid/Basic.lean -- L145</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">length_eq_three</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FreeMonoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 506636416,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742361403
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Mathlib/Algebra/Order/Antidiag/Nat.lean -- L246</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">finMulAntidiag_three</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">finMulAntidiag</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>",
        "id": 506636444,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742361428
    },
    {
        "content": "<p>I found these by scanning through the output of <code>rg \"theorem.*_three\"</code></p>",
        "id": 506636469,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742361456
    },
    {
        "content": "<p>Nice trick! Now we maybe need to write a simpproc tutorial or blog post explaining how these things work. <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> ?</p>",
        "id": 506657469,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1742371238
    },
    {
        "content": "<p>I made a start on those matrix simprocs back in Lean 3!</p>",
        "id": 506670087,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742374747
    },
    {
        "content": "<p>I think it wouldn't be so hard to turn my metaprogramming study group session into a blogpost tutorial. It would be a lot harder to write a fully fledged explanation of what simprocs are and do</p>",
        "id": 506671333,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1742375079
    },
    {
        "content": "<p>Yes I pinged you precisely because of your study group talk (we are having a metaprogramming study group at Imperial)</p>",
        "id": 506675831,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1742376454
    },
    {
        "content": "<p>Is the issue here \"how to meta program\" or \"I already know basics of meta programming but idk what a simproc is\"? Because if you know how to play with <code>Expr</code> in Lean then simprocs are pretty trivial to explain.</p>",
        "id": 506680927,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1742377925
    },
    {
        "content": "<p>For me it was \"I know the very basics of metaprogramming but have no idea what the word \"simproc\" even means\", before I saw Yael's talk</p>",
        "id": 506685758,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1742379296
    },
    {
        "content": "<p>And what I realised after Johan's post was that searching for lemmas with <code>three</code> in the name might be a good way of giving some really natural examples (the first example Yael gave in the talk looked a little contrived to me but these look great)</p>",
        "id": 506686371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1742379475
    },
    {
        "content": "<p>Yeah I knew about many of these potential simprocs which you mention in your first message (although it didn't occur to me to search for <code>_three</code>!), but I thought they all had a similar flavour, so I only mentioned one of them (and then mentioned others of a different flavour)</p>",
        "id": 506691266,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1742380834
    },
    {
        "content": "<p>Btw <span class=\"user-mention\" data-user-id=\"376152\">@Paul Lezeau</span> and I are working on the <code>Nat.divisorsAntidiag</code> and <code>Int.divisorsAntidiag</code> ones in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21915\">#21915</a></p>",
        "id": 506691905,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1742380992
    },
    {
        "content": "<p>I also plan on writing a simproc to compute <code>Nat.nth Nat.Prime</code>.</p>",
        "id": 506692350,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1742381119
    },
    {
        "content": "<p>Maybe more people will write them if someone knocks off a blog post written with computer scientists in mind (ie assume some metaprogramming experience) saying \"this is what a simproc is, this is the problem they solve, here are some of the ones we need\"</p>",
        "id": 506701629,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1742383863
    },
    {
        "content": "<p>Right now there seems to be 0 resources other than the favoured-by-computer-scientists \"find an example in the source code and read it and understand it yourself\"</p>",
        "id": 506701756,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1742383900
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> and I would be happy to have a go at writing such a blog post:)</p>",
        "id": 506702048,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1742383979
    },
    {
        "content": "<p>Perhaps it should just be a section of Metaprogramming in Lean?</p>",
        "id": 506702410,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1742384099
    },
    {
        "content": "<p>I think having both could be useful as these would be complementary: a relatively brief blog post introducing these in the way Kevin suggested, and a more detailed explanation in the book</p>",
        "id": 506703616,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1742384478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/287929-mathlib4/topic/potential.20simp_procs/near/506680927\">said</a>:</p>\n<blockquote>\n<p>Is the issue here \"how to meta program\" or \"I already know basics of meta programming but idk what a simproc is\"? Because if you know how to play with <code>Expr</code> in Lean then simprocs are pretty trivial to explain.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> . What is the trivial explanation? I haven't seriously looked into simprocs yet, but would like to understand :)</p>",
        "id": 506713446,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1742387144
    },
    {
        "content": "<p>To give a simple example from <code>bv_decide</code>, say we want to detect situations where we multiply a BitVec with a BitVec constant that is a power of two and turn it into a left shift instead to get rid of the multiplication:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">simproc</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">bv_normalize</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">bv_mul_twoPow</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">let_expr</span><span class=\"w\"> </span><span class=\"n\">HMul</span><span class=\"bp\">.</span><span class=\"n\">hMul</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">rhsExpr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getBitVecValue?</span><span class=\"w\"> </span><span class=\"n\">rhsExpr</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">pow</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">isTwoPow</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``HShiftLeft.hShiftLeft</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">lhs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"n\">pow</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkApp3</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``BitVec.mul_twoPow_eq_shiftLeft</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"n\">pow</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">visit</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">proof?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p><code>[bv_normalize]</code> adds thsi simproc to the <code>[bv_normalize]</code> simpset, if you are using the default simp set you can leave that out of course, then we have the name <code>bv_mul_twoPow</code> followed by the pattern we want to trigger on: <code>((_ : BitVec _) * (BitVec.ofNat _ _))</code> a multiplication of some <code>BitVec</code> with some <code>BitVec</code> constant. If <code>simp</code> spots this pattern it is going to call the function we provide below with the expression it detected the pattern on and then we can return one of three things:</p>\n<ul>\n<li><code>.continue</code> to indicate that we are not responsible for this pattern after all</li>\n<li><code>.visit</code> or <code>.done</code> to say \"we produced this new expression, keep working on it\" (see the docstring for the precise semantics with respect to the traversal behavior of simp)</li>\n</ul>\n<p>If we decide to go for the latter both<code> visit</code> and <code>done</code> take two arguments, for one the new expression we simplified to and secondly a proof that the two are equal (or <code>none</code> if they are defeq). </p>\n<p>And that's it more or less^^</p>",
        "id": 506714901,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1742387523
    },
    {
        "content": "<p><code>simp</code>le indeed!</p>",
        "id": 506715154,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1742387606
    },
    {
        "content": "<p>Now <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> can write a bunch of simpprocs for <code>CategoryTheory</code> :)</p>",
        "id": 506727618,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1742390620
    },
    {
        "content": "<p>I'll follow up with a more powerful Qq version of the above later :)</p>",
        "id": 506729126,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742390998
    },
    {
        "content": "<p>As the target audience of having done some metaprogramming but not worked with simprocs, I think <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>'s example makes sense. Would it be mostly accurate to put it succinctly as \"adding a metaprogram that transforms <code>Expr</code>s to a simpset\"?</p>",
        "id": 506736649,
        "sender_full_name": "Chris Henson",
        "timestamp": 1742392748
    },
    {
        "content": "<p>Here's the Qq version, and an example that fails with the non-qq version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">twoPow_eq_ofNat</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">twoPow</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n<span class=\"n\">simproc</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">bv_normalize</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">bv_mul_twoPow'</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ofQ</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">w</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">rhs</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rhs_v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"bp\">.</span><span class=\"n\">natLit!</span>\n<span class=\"w\">    </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">rhs_v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">rhs_v</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">pow</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">mkRawNatLit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">rhs_v</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">pow</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨⟩</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">visit</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">      </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">((</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">twoPow_eq_ofNat</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">mul_twoPow_eq_shiftLeft</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">pow</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"mi\">64</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">bv_mul_twoPow'</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 506737537,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742392935
    },
    {
        "content": "<p>(assuming the lemma is true, of course!)</p>",
        "id": 506737790,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742392993
    },
    {
        "content": "<p>I guess the other (slightly more technical) question I would have about simproc development is about the additional stuff <code>SimpM</code> gives us over <code>MetaM</code>.</p>",
        "id": 506741488,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1742393840
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/287929-mathlib4/topic/potential.20simp_procs/near/506714901\">said</a>:</p>\n<blockquote>\n<p>secondly a proof that the two are equal</p>\n</blockquote>\n<p>One thing that always gets me is remembering which way around this proof goes: the Qq version makes it a compile error if you get this wrong :)</p>",
        "id": 506743611,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742394275
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/stream/287929-mathlib4/topic/potential.20simp_procs/near/506736649\">said</a>:</p>\n<blockquote>\n<p>As the target audience of having done some metaprogramming but not worked with simprocs, I think <span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span>'s example makes sense. Would it be mostly accurate to put it succinctly as \"adding a metaprogram that transforms <code>Expr</code>s to a simpset\"?</p>\n</blockquote>\n<p>Yes</p>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/potential.20simp_procs/near/506737537\">said</a>:</p>\n<blockquote>\n<p>Here's the Qq version, and an example that fails with the non-qq version:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">twoPow_eq_ofNat</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">twoPow</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n<span class=\"n\">simproc</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">bv_normalize</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">bv_mul_twoPow'</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ofQ</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">w</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">rhs</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rhs_v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"bp\">.</span><span class=\"n\">natLit!</span>\n<span class=\"w\">    </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">rhs_v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">rhs_v</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">pow</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">mkRawNatLit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">rhs_v</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">rhs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">pow</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨⟩</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">visit</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">      </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">((</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">twoPow_eq_ofNat</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">mul_twoPow_eq_shiftLeft</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">pow</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"mi\">64</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">bv_mul_twoPow'</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This improvement isn't really bound to Qq though, it could be added perfectly normally with core means as well. The reason that the above simproc  works like it does is because it is meant for the specific situatuon of bv_decide where the shown situation is not in scope.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/potential.20simp_procs/near/506741488\">said</a>:</p>\n<blockquote>\n<p>I guess the other (slightly more technical) question I would have about simproc development is about the additional stuff <code>SimpM</code> gives us over <code>MetaM</code>.</p>\n</blockquote>\n<p>One nice thing you can do is call <code>simp</code> (like, as a meta function) on subterms and work with it. A notable example for why this might be useful is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=reduceIte#doc\">docs#reduceIte</a>. For this its a bit important to understand the way that simp applies lemmas (and simprocs): the default way is to apply them after all sub terms have already been simplified. However if you have an if then else you might want to check \"hey, maybe the condition simps to true or false and I don't need to take a look at one of the match arms after all\". In this case you want to mark your simproc as \"pre\" (that's what the downward arrow does). reduceIte then runs simp on the condition and checks if its true or false and depending on the result drops one of the arms before you waste time running simp on it.</p>",
        "id": 506744264,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1742394411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/potential.20simp_procs/near/506743611\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/287929-mathlib4/topic/potential.20simp_procs/near/506714901\">said</a>:</p>\n<blockquote>\n<p>secondly a proof that the two are equal</p>\n</blockquote>\n<p>One thing that always gets me is remembering which way around this proof goes: the Qq version makes it a compile error if you get this wrong :)</p>\n</blockquote>\n<p>Given that it goes from input to output, left to right like everything else in simp and usual rewriting theory, that's always been pretty intuitive for me.</p>",
        "id": 506745005,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1742394561
    },
    {
        "content": "<p>I guess it's moot now that <a href=\"https://github.com/leanprover/lean4/pull/3319\">lean4#3319</a> is merged, which adds a clear docstring :)</p>",
        "id": 506745380,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742394633
    },
    {
        "content": "<p>Lemmarocs when? <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=dist_triangle8#doc\">docs#dist_triangle8</a> <span aria-label=\"melt\" class=\"emoji emoji-1fae0\" role=\"img\" title=\"melt\">:melt:</span></p>",
        "id": 506746807,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1742394947
    },
    {
        "content": "<p>we usually call them \"commands\"</p>",
        "id": 506747116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742395001
    },
    {
        "content": "<p>you can also use macros for that kind of thing</p>",
        "id": 506747304,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742395045
    },
    {
        "content": "<p>Of course, this was a joke. But the sentiment is that lemmas which are not eligible for a simproc (eg because they don't prove an equality) should not be forgotten</p>",
        "id": 506748604,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1742395325
    },
    {
        "content": "<p>oh, I thought the issue was with writing the lemma, not using it</p>",
        "id": 506749986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742395659
    },
    {
        "content": "<p>I don't know why that lemma you linked exists</p>",
        "id": 506750062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742395681
    },
    {
        "content": "<p>It's used in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=dist_integral_mulExpNegMulSq_comp_le#doc\">docs#dist_integral_mulExpNegMulSq_comp_le</a></p>",
        "id": 506750329,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742395742
    },
    {
        "content": "<p>it's a bit weird of a setup, it looks like a calc block but all of the work is outside the block and there is only one line</p>",
        "id": 506750759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742395847
    },
    {
        "content": "<p>I think it should just be proving those additions one at a time</p>",
        "id": 506751177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742395949
    },
    {
        "content": "<p>Another natural one is the dual of existsAndEq, namely forallImpEq, which would eg prove this equivalence:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>That is, if some prop-valued pi-type contains an equality, that binder can be resolved</p>",
        "id": 506764934,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1742399060
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/potential.20simp_procs/near/506691905\">said</a>:</p>\n<blockquote>\n<p>Btw <span class=\"user-mention silent\" data-user-id=\"376152\">Paul Lezeau</span> and I are working on the <code>Nat.divisorsAntidiag</code> and <code>Int.divisorsAntidiag</code> ones in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21915\">#21915</a></p>\n</blockquote>\n<p>you should add the Nat.divisors one I made too :)</p>",
        "id": 506765671,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1742399238
    },
    {
        "content": "<p>Isn't that just <code>simp +contextual</code>?</p>",
        "id": 506766327,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742399389
    },
    {
        "content": "<p>I guess that only works for one direction of equality</p>",
        "id": 506766431,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742399406
    },
    {
        "content": "<p>Right, it also keeps the forall around, unlike existsAndEq which gets rid of the exists</p>",
        "id": 506767293,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1742399591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/potential.20simp_procs/near/506765671\">said</a>:</p>\n<blockquote>\n<p>you should add the Nat.divisors one I made too :)</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/23026\">#23026</a> if anyone is interested:)</p>",
        "id": 506767831,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1742399724
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/potential.20simp_procs/near/506766431\">said</a>:</p>\n<blockquote>\n<p>I guess that only works for one direction of equality</p>\n</blockquote>\n<p>and only when the <code>∀ a</code> is next to the <code>a = x</code>. My recent best kept secrete technique is doing <code>forall_swap (β := pattern_that_matches_a_and_nothing_else)</code> to get the <code>a = x</code> binder to move leftwards until it collides with the <code>∀ a</code>.</p>",
        "id": 506771153,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1742400508
    },
    {
        "content": "<p>Does that commute it with implications as well? In any case, I'm glad to hear you have the same frustration I do :)</p>",
        "id": 506772359,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1742400803
    },
    {
        "content": "<p>Yes it does! They are non-dependent foralls after all</p>",
        "id": 506772678,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1742400869
    },
    {
        "content": "<p>I think that such a simproc would have a <code>discr_tree_key</code> of <code>_</code></p>",
        "id": 506774961,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742401438
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/potential.20simp_procs/near/506764934\">said</a>:</p>\n<blockquote>\n<p>Another natural one is the dual of existsAndEq, namely forallImpEq, which would eg prove this equivalence:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>That is, if some prop-valued pi-type contains an equality, that binder can be resolved</p>\n</blockquote>\n<p>Oh, I thought this went without saying. Yes, this also needs a simproc for exactly the same reasons</p>",
        "id": 506780780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742402878
    },
    {
        "content": "<p>Oh, here's an example I expected a simproc to solve but it doesn't:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>I thought this was within the realm of <code>existsAndEq</code>, but maybe not. <span class=\"user-mention\" data-user-id=\"552388\">@Vasilii Nesterov</span>, do you have ideas? Edit: Ah, I see it doesn't handle nested exists. In that case, that's another submission for this thread!</p>",
        "id": 506852714,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1742430690
    },
    {
        "content": "<p>(this message was edited - <a href=\"https://github.com/leanprover-community/mathlib4/pull/23125\">it originally had the specific example from #23125</a>) which was generalized above by <span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span></p>",
        "id": 506868813,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1742439574
    },
    {
        "content": "<p>To save people the reading, my example came from that PR</p>",
        "id": 506869013,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1742439670
    },
    {
        "content": "<p>should there be a simproc for reducing <code>Nat.find</code> or something? i'm guessing that this is likely a bad idea to be \"on\" by default, but having it might be useful nonetheless</p>",
        "id": 508773313,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743173185
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/287929-mathlib4/topic/potential.20simp_procs/near/506852714\">said</a>:</p>\n<blockquote>\n<p>Oh, here's an example I expected a simproc to solve but it doesn't:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>I thought this was within the realm of <code>existsAndEq</code>, but maybe not. <span class=\"user-mention silent\" data-user-id=\"552388\">Vasilii Nesterov</span>, do you have ideas? Edit: Ah, I see it doesn't handle nested exists. In that case, that's another submission for this thread!</p>\n</blockquote>\n<p>I've finally done it: <a href=\"https://github.com/leanprover-community/mathlib4/pull/23365\">#23365</a>. I think it was the hardest metaprogramming I've ever done <span aria-label=\"smiling face with tear\" class=\"emoji emoji-1f972\" role=\"img\" title=\"smiling face with tear\">:smiling_face_with_tear:</span></p>",
        "id": 508794335,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1743178540
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"376152\">Paul Lezeau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/potential.20simp_procs/near/506692350\">said</a>:</p>\n<blockquote>\n<p>I also plan on writing a simproc to compute <code>Nat.nth Nat.Prime</code>.</p>\n</blockquote>\n<p>Maybe generalize it to <code>Nat.nth P</code> with <code>DecidablePred P</code>?</p>",
        "id": 508821656,
        "sender_full_name": "Vasilii Nesterov",
        "timestamp": 1743186334
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"552388\">Vasilii Nesterov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/potential.20simp_procs/near/508821656\">said</a>:</p>\n<blockquote>\n<p>Maybe generalize it to <code>Nat.nth P</code> with <code>DecidablePred P</code>?</p>\n</blockquote>\n<p>I think both would be worth having: one general simproc for the decidable pred case, and a specialised (and faster) one for <code>Nat.Prime</code>!</p>",
        "id": 508924604,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1743256596
    },
    {
        "content": "<p>If anyone's interested, <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> and I have a draft version of the blog post <a href=\"https://github.com/leanprover-community/blog/pull/97\">here</a>. This is very much work in progress, but feedback and corrections on the content would be very much appreciated <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 509298439,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1743454512
    },
    {
        "content": "<p>Along the lines of Damiano's work on <code>compute_degree</code>, it would be nice to have a simproc that could evaluate the coefficients of polynomials expressed using <code>C</code> and <code>X</code> and analogues thereof, the sort of thing that would allow <a href=\"#narrow/channel/113489-new-members/topic/simple.20polynomial/with/512693490\">this</a> question to be solved by <code>simp</code>.</p>",
        "id": 512694738,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1744840705
    },
    {
        "content": "<p>That looks like a missing <code>simp</code> lemma to me, no proc needed</p>",
        "id": 512694965,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744840812
    },
    {
        "content": "<p>What simp lemma do you think is missing there?</p>",
        "id": 512695126,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1744840879
    },
    {
        "content": "<p>dpcs#Polynomial.coeff_ofNat</p>",
        "id": 512695167,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744840900
    },
    {
        "content": "<p>I think there may be two orthogonal issues with that question. One is the <code>ofNat</code> thing, but another is that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.coeff_C#doc\">docs#Polynomial.coeff_C</a> is (rightly) not a simp lemma, but there could be a simproc that detects when the second argument is known precisely  and computes the coefficient (perhaps only if the coefficient we are asking for is greater than or equal to the degree of the polynomial).</p>",
        "id": 512695948,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1744841238
    },
    {
        "content": "<p>My potentially hot take here is that we should rename <code>Polynomial.toFinsupp</code> to <code>Polynomial.coeff</code>, and there should be a simp lemma that says <code>(C a).coeff = AddMonoidAlgebra.of a</code></p>",
        "id": 512704898,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744845823
    },
    {
        "content": "<p>Even with the current spelling, I think we should have a lemma that says <code>(C a).coeff = Pi.single 0 a</code></p>",
        "id": 512705594,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744846280
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.coeff#doc\">docs#Polynomial.coeff</a></p>",
        "id": 512705979,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744846535
    },
    {
        "content": "<p>I was going to say \"you'll lose that it's an R-module hom\" but apparently it never was!</p>",
        "id": 512706079,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744846583
    },
    {
        "content": "<p>(Pi.single a 0 I should think)</p>",
        "id": 512706189,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744846669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"376152\">Paul Lezeau</span> <a href=\"#narrow/channel/287929-mathlib4/topic/potential.20simp_procs/near/506692350\">said</a>:</p>\n<blockquote>\n<p>I also plan on writing a simproc to compute <code>Nat.nth Nat.Prime</code>.</p>\n</blockquote>\n<p>Could we also just replace the <code>norm_num</code> extension for <code>Prime 37</code> with a simproc? (And generally, replace norm_num extensions where possible with simprocs.)</p>",
        "id": 512714683,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744852147
    },
    {
        "content": "<blockquote>\n<p>And generally, replace norm_num extensions where possible with simprocs</p>\n</blockquote>\n<p>I think we need a proof of concept for passing metadata between simprocs for that to not be a (likely significant) performance hit</p>",
        "id": 512715409,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744852669
    },
    {
        "content": "<p>(the cost is paid by parsing and then reserializing the numerals at the boundary between simprocs, unlike in norm_num where an intermediate represenation is passed all the way through)</p>",
        "id": 512715527,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744852745
    },
    {
        "content": "<p>Really? Parsing and reserializing numerals should be super fast?</p>",
        "id": 512718397,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744854630
    },
    {
        "content": "<p>Each parse also involves resythesizing (division) ring structures too</p>",
        "id": 512719148,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744855152
    },
    {
        "content": "<p>Oh, I thought we were talking about <code>Prime 37</code>.</p>",
        "id": 512719281,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744855221
    },
    {
        "content": "<p>I was referring to your \"and generally\" comment</p>",
        "id": 512719354,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744855248
    },
    {
        "content": "<p>Got it. Let's start with the low-hanging fruit. The fact that the <code>norm_num</code> architecture is not extensible has been a big problem, and we need to address it eventually.</p>",
        "id": 512719407,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744855290
    },
    {
        "content": "<p>you must mean something else by not extensible, norm_num is clearly an extensible tactic</p>",
        "id": 512744866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744869688
    },
    {
        "content": "<p>Sorry, I agree that was unclear.</p>\n<p>Oh, I meant that we've never grown beyond <code>deriveNat</code>, <code>deriveInt</code>, <code>deriveRat</code>, <code>deriveBool</code>.</p>",
        "id": 512749459,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1744871815
    },
    {
        "content": "<p>I don't see it as a problem. It is designed specifically for normalizing numerical expressions, it's right in the name. Supporting other normal forms would just turn it into simp, and would lose out on the optimizations it employs for those types. Just use simprocs if you want to norm-not-nums.</p>",
        "id": 512757604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744874948
    },
    {
        "content": "<p><code>simp</code> does not support rewriting with relations that are not equalities</p>",
        "id": 512757835,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744875021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/potential.20simp_procs/near/512706079\">said</a>:</p>\n<blockquote>\n<p>I was going to say \"you'll lose that it's an R-module hom\" but apparently it never was!</p>\n</blockquote>\n<p>But the PowerSeries one is a hom, which means it's difficult to access coeffs over things that aren't Semiring</p>",
        "id": 512960656,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1744945631
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/287929-mathlib4/topic/potential.20simp_procs/near/512757604\">said</a>:</p>\n<blockquote>\n<p>I don't see it as a problem. It is designed specifically for normalizing numerical expressions, it's right in the name. Supporting other normal forms would just turn it into simp, and would lose out on the optimizations it employs for those types. Just use simprocs if you want to norm-not-nums.</p>\n</blockquote>\n<p>Also, another consideration: since <code>norm_num</code> uses <code>simp</code>, if you write a non-numerical normalization routine as a simproc, <code>norm_num</code> will still be able to use it in conjunction with the things it does for numerals. So if you have something that e.g. mixes calculating the sum of a list and normalizing the elements of the list, that would work if the list manipulation is in a simproc</p>",
        "id": 512996627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744966092
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/25009#issuecomment-2889268838\">https://github.com/leanprover-community/mathlib4/pull/25009#issuecomment-2889268838</a> has a simproc suggestion, and a sketch, for terms like <code>cos (37* π / 3)</code></p>",
        "id": 518970376,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1747613453
    }
]