[
    {
        "content": "<p>What is a good tactic whose code I could cargo cult from for a reflection-style normalizer or solver tactic?<br>\nI hope I am using the term correctly; I mean the approach where</p>\n<ul>\n<li>I define a “normal” data type to describe the problem</li>\n<li>a tactic that parses the goal state into this data type</li>\n<li>a function that converts it back so that the tactic can replace the goal with that function applied to my custom data type</li>\n<li>a function that solves or normalizes the value, with a proof that it’s correct</li>\n<li>and then using that proof to conclude the tactic<br>\n(Maybe this is called “boolean reflection”?)</li>\n</ul>",
        "id": 359038428,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1684343866
    },
    {
        "content": "<p>Some more googling may indicate that this style of boolean reflection isn’t actually a common technique in lean? Or is that just not the right term around here? I have also seen the name “small-scale reflection”.</p>",
        "id": 359043685,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1684345240
    },
    {
        "content": "<p>maybe linarith? it's the only tactic I know that currently does something along those lines...</p>",
        "id": 359056061,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1684348784
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/data/matrix/reflection.html#matrix.mul%E1%B5%A3_eq\"><code>matrix.mulᵣ_eq</code></a> was my attempt at this in Lean3, though the <code>meta</code> portion never got merged</p>",
        "id": 359056500,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684348906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> yeah, proof by reflection is almost not used at all in mathlib. This, afaik, is because historically the kernel didn't support it very well, i.e. reflection was slow. In mathlib3, the ring2 tactic proceeds by reflection. But it is more common to do the normalisation at the meta-level, and construct a proof of its correctness (e.g. using Eq.rec) as we go.</p>",
        "id": 359085386,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1684358859
    },
    {
        "content": "<p>Here's a simple tautology tactic using proof by reflection:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Util.AtomM</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Formula</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">imp</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Formula</span>\n<span class=\"kd\">def</span> <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">var</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">V.getD</span> <span class=\"n\">n</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">not</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span> <span class=\"n\">f.eval</span> <span class=\"n\">V</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">imp</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f₁.eval</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">f₂.eval</span> <span class=\"n\">V</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">eval'</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">var</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">F.getD</span> <span class=\"n\">n</span> <span class=\"n\">False</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">not</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span> <span class=\"n\">f.eval'</span> <span class=\"n\">F</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">imp</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f₁.eval'</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">f₂.eval'</span> <span class=\"n\">F</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">taut</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f.eval</span> <span class=\"n\">V</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f.taut</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">false</span><span class=\"o\">::</span><span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">f.taut</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">::</span><span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eval_map</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f.eval'</span> <span class=\"o\">(</span><span class=\"n\">V.map</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">))</span> <span class=\"bp\">↔</span> <span class=\"n\">f.eval</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">f</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">eval'</span><span class=\"o\">,</span> <span class=\"n\">eval</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">List.getD</span><span class=\"o\">]</span>\n  <span class=\"n\">rename_i</span> <span class=\"n\">n</span>\n  <span class=\"n\">induction</span> <span class=\"n\">V</span> <span class=\"n\">generalizing</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">List.get</span><span class=\"bp\">?</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Option.getD</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">List.get</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">Option.getD</span><span class=\"o\">]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">List.get</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_val</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"n\">V.map</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨[],</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">p</span><span class=\"o\">::</span><span class=\"n\">F</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">exists_val</span> <span class=\"n\">F</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">true</span><span class=\"o\">::</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">List.map</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]⟩</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">false</span><span class=\"o\">::</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">List.map</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eval_of_taut</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span><span class=\"o\">),</span> <span class=\"n\">f.taut</span> <span class=\"n\">V.length</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">f.eval</span> <span class=\"o\">(</span><span class=\"n\">V.reverseAux</span> <span class=\"n\">W</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">W</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">taut</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">v</span><span class=\"o\">::</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">W</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">taut</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">eval_of_taut</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">::</span><span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"n\">f</span>\n    <span class=\"n\">cases</span> <span class=\"n\">v</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">h₁</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">h₂</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eval'_of_taut</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f.taut</span> <span class=\"n\">F.length</span> <span class=\"o\">[])</span> <span class=\"o\">:</span> <span class=\"n\">f.eval'</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">exists_val</span> <span class=\"n\">F</span>\n  <span class=\"n\">subst</span> <span class=\"n\">e</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">List.length_map</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eval_map</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">→</span> <span class=\"n\">f.eval</span> <span class=\"n\">V.reverse.reverse</span> <span class=\"o\">:=</span> <span class=\"n\">eval_of_taut</span> <span class=\"n\">V.reverse</span> <span class=\"o\">[]</span> <span class=\"n\">f</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">List.length_reverse</span><span class=\"o\">,</span> <span class=\"n\">List.reverse_reverse</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Formula</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Mathlib.Tactic</span> <span class=\"n\">Qq</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">imp</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"c1\">-- workaround for QQ bug?</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">parseExpr</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Prop</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">AtomM</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Formula</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">¬$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">not</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">parseExpr</span> <span class=\"n\">p</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">imp</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"bp\">$</span><span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">imp</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">parseExpr</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">parseExpr</span> <span class=\"n\">q</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">have</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.mkNatLit</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">AtomM.addAtom</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">return</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">var</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"taut\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">liftMetaTactic</span> <span class=\"k\">fun</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Prop</span><span class=\"o\">))</span> <span class=\"bp\">←</span> <span class=\"n\">checkTypeQ</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">g.getType</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"o\">))</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">atoms</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">AtomM.run</span> <span class=\"bp\">.</span><span class=\"n\">default</span> <span class=\"k\">do</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">parseExpr</span> <span class=\"n\">ty</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">atoms</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">atoms.foldr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Prop</span><span class=\"o\">))</span> <span class=\"n\">ls</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"bp\">$</span><span class=\"n\">ls</span><span class=\"o\">))</span> <span class=\"n\">q</span><span class=\"o\">([])</span>\n  <span class=\"k\">let</span> <span class=\"n\">pf</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">((</span><span class=\"bp\">$</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">taut</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"o\">[]</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span>\n  <span class=\"n\">g.assign</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Formula.eval'_of_taut</span> <span class=\"bp\">$</span><span class=\"n\">F</span> <span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"n\">pf</span><span class=\"o\">)</span>\n  <span class=\"n\">pure</span> <span class=\"o\">[]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">taut</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">taut</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">taut</span>\n</code></pre></div>",
        "id": 359284662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684368725
    },
    {
        "content": "<blockquote>\n<p>I have also seen the name “small-scale reflection”.</p>\n</blockquote>\n<p>This is not small-scale reflection. Boolean reflection in this style is \"large-scale reflection\", while ssreflect deals with using reflection to perform rewrites and other small reductions in the course of a proof. Large-scale reflection is characterized by having a single kernel proof goal like <code>myFunc = true</code> which does almost all of the actual proof work.</p>",
        "id": 359285177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684368980
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span></p>",
        "id": 359285254,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684369021
    },
    {
        "content": "<p>Cool, thanks for that example! Not too much boiler-plate code it seems.</p>",
        "id": 359350485,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1684404261
    }
]