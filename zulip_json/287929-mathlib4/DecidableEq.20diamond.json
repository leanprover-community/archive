[
    {
        "content": "<p>The following should work</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.MvPolynomial.CommRing</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">Finset</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"o\">(</span><span class=\"n\">vars</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">vars</span> <span class=\"n\">P</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vars</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">vars_sub_of_disjoint</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">vars_X</span><span class=\"o\">,</span> <span class=\"n\">mem_union</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_singleton</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>but <code>rw [mem_union]</code> fails as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">synthesized</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">expression</span> <span class=\"n\">inferred</span> <span class=\"kd\">by</span> <span class=\"n\">typing</span> <span class=\"n\">rules</span><span class=\"o\">,</span> <span class=\"n\">synthesized</span>\n  <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">instDecidableEqNat</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n<span class=\"n\">inferred</span>\n  <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Classical.propDecidable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(This appeared in <a href=\"https://github.com/leanprover-community/mathlib4/pull/3355\">!4#3355</a> at <a href=\"https://github.com/leanprover-community/mathlib4/pull/3355/files#diff-f33593ea969bf958e5cb05e696cc502c949d9abfd4241a1f4be934e01466c818R259-R271\">https://github.com/leanprover-community/mathlib4/pull/3355/files#diff-f33593ea969bf958e5cb05e696cc502c949d9abfd4241a1f4be934e01466c818R259-R271</a> )</p>",
        "id": 348166621,
        "sender_full_name": "Joël Riou",
        "timestamp": 1681117332
    },
    {
        "content": "<p>I would guess <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MvPolynomial.vars_sub_of_disjoint#doc\">docs4#MvPolynomial.vars_sub_of_disjoint</a> is to blame</p>",
        "id": 348171338,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681119077
    },
    {
        "content": "<p>It is missing a <code>DecideableEq</code> argument</p>",
        "id": 348171550,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681119154
    },
    {
        "content": "<p>Removing <code>open Classical</code> from that file should make the problem obvious</p>",
        "id": 348171807,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681119222
    },
    {
        "content": "<p>Thanks, but then there is another <code>DecidableEq</code> diamond on the set <code>σ →₀ ℕ</code> of functions which are zero almost everywhere...</p>",
        "id": 348176009,
        "sender_full_name": "Joël Riou",
        "timestamp": 1681120480
    },
    {
        "content": "<p>(I will try to investigate this another day.)</p>",
        "id": 348179039,
        "sender_full_name": "Joël Riou",
        "timestamp": 1681121411
    },
    {
        "content": "<p>Is <code>open Classical</code> ever correct? Since I learnt the basic rule of thumb (\"if the statement doesn't compile, add decidable instances; if the proof doesn't compile, use the classical tactic in the proof) I've never had this particular diamond issue (which used to plague my code before I understood the rule of thumb and was in fact the reason Jason KY and I wrote the basic <code>finsum</code> API)</p>",
        "id": 348182590,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1681122742
    },
    {
        "content": "<p>In lean 4 there's no reason to use it now the <code>classical</code> tactic works properly and the variable inclusion rules have changed</p>",
        "id": 348187288,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681124438
    },
    {
        "content": "<p>(except obviously when porting)</p>",
        "id": 348187326,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681124453
    },
    {
        "content": "<p>That is to say, <code>def foo := by classical; exact if p then x else y</code> didn't work well in Lean 3, and was the main reason that the locale was still useful</p>",
        "id": 348193848,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681126555
    },
    {
        "content": "<p>After getting rid of <code>open Classical</code> in 6 extra files, I could get <code>RingTheory.WittVector.WittPolynomial</code> to compile, but it seems I have broken everything else <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>",
        "id": 348240386,
        "sender_full_name": "Joël Riou",
        "timestamp": 1681139371
    },
    {
        "content": "<p>There's also a difference between how instance arguments are handled between Lean 3 and Lean 4. Now there's a check that the instance argument is the \"right\" one, but in Lean 3 a theorem like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.mem_union#doc\">docs4#Finset.mem_union</a> would be happy to just use the instance argument that was already there in the expression.</p>\n<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> If you made a variant of <code>Finset.mem_union</code> that takes the decidable instance as an implicit argument rather than an instance argument, I'd expect your original example to work.</p>",
        "id": 348241886,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681139798
    },
    {
        "content": "<p>Yeah, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.MvPolynomial.CommRing</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">Finset</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Finset.mem_union'</span> <span class=\"o\">{</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.mem_union</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"o\">(</span><span class=\"n\">vars</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">vars</span> <span class=\"n\">P</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vars</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">vars_sub_of_disjoint</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">vars_X</span><span class=\"o\">,</span> <span class=\"n\">mem_union'</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_singleton</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 348242379,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681139931
    },
    {
        "content": "<p>I think we're going to have to figure out the new right way to handle instance arguments in rewrite theorems, since the rules of thumb that worked for Lean 3 don't apply perfectly to Lean 4.</p>\n<p>I believe <span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span> had an example of Lean 3 style (where you have instance arguments rather than implicit arguments for everything that can be picked up from the LHS) causing timeouts for some algebraic structures in Lean 4, though I can't find the thread right now.</p>",
        "id": 348243788,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681140266
    },
    {
        "content": "<p>There have been a few. One example <code>RingTheory.Polynomial.Basic</code> </p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/blob/05186d6b6b04357326f679db65b90e45c6c8f8ed/Mathlib/RingTheory/Polynomial/Basic.lean#L864\">https://github.com/leanprover-community/mathlib4/blob/05186d6b6b04357326f679db65b90e45c6c8f8ed/Mathlib/RingTheory/Polynomial/Basic.lean#L864</a></li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/blob/05186d6b6b04357326f679db65b90e45c6c8f8ed/Mathlib/RingTheory/Polynomial/Basic.lean#L1285\">https://github.com/leanprover-community/mathlib4/blob/05186d6b6b04357326f679db65b90e45c6c8f8ed/Mathlib/RingTheory/Polynomial/Basic.lean#L1285</a> and below</li>\n</ul>",
        "id": 348244830,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1681140521
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> had some also. If you grep for <code>(_)</code> you will find a good chunk of them (I would guess)</p>",
        "id": 348244972,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1681140559
    },
    {
        "content": "<p>Oh right, I forgot about the <code>(_)</code> solution to switch the argument from being elaborated as an instance argument. Here's how that looks here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"o\">(</span><span class=\"n\">vars</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">vars</span> <span class=\"n\">P</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vars</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">vars_sub_of_disjoint</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">vars_X</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">mem_union</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">Finset.mem_singleton</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 348246075,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681140828
    },
    {
        "content": "<p>You can force Lean to use unification in place of typeclass synthesis if you use <code>(_)</code> in place of <code>_</code> when filling in all parameters (or what Kyle said :)</p>",
        "id": 348246182,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1681140846
    },
    {
        "content": "<p>In the long run it would be better to fix the classical issues, but I guess the above is a faithful port</p>",
        "id": 348247666,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681141282
    },
    {
        "content": "<p>It's a shame the instance arguments are all un-named so we can't use <code>(inst12 := _)</code> instead</p>",
        "id": 348247711,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681141299
    },
    {
        "content": "<p>(Sure, it's unhygienic; but I'd rather see <code>inst12</code> than count 12 underscores)</p>",
        "id": 348247849,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681141331
    },
    {
        "content": "<p>I agree. Is there metaprogramming solution (or approximation)?</p>",
        "id": 348250197,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1681142065
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span> I was just experimenting with something like that in the form of a <code>no_inst%</code> term elaborator that turns every instance implicit into an implicit argument:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.MvPolynomial.CommRing</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">NoInst</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Lean.Parser.Term</span>\n<span class=\"kn\">open</span> <span class=\"n\">Meta</span> <span class=\"n\">Command</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">no_inst</span><span class=\"o\">)</span> <span class=\"s2\">\"no_inst% \"</span> <span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">@[term_elab no_inst]</span>\n<span class=\"kd\">def</span> <span class=\"n\">no_inst_elab</span> <span class=\"o\">:</span> <span class=\"n\">Elab.Term.TermElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">no_inst</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">Term.resolveId</span><span class=\"bp\">?</span> <span class=\"n\">name</span> <span class=\"o\">(</span><span class=\"n\">withInfo</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n      <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"no_inst% for type {← inferType e}\"</span>\n      <span class=\"k\">let</span> <span class=\"n\">e'</span> <span class=\"bp\">←</span> <span class=\"n\">forallTelescope</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">args</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">lctx</span> <span class=\"bp\">←</span> <span class=\"n\">getLCtx</span>\n        <span class=\"n\">for</span> <span class=\"n\">arg</span> <span class=\"k\">in</span> <span class=\"n\">args</span> <span class=\"k\">do</span>\n          <span class=\"k\">let</span> <span class=\"n\">decl</span> <span class=\"o\">:=</span> <span class=\"n\">lctx.getFVar</span><span class=\"bp\">!</span> <span class=\"n\">arg</span>\n          <span class=\"k\">if</span> <span class=\"n\">decl.binderInfo.isInstImplicit</span> <span class=\"k\">then</span>\n            <span class=\"n\">lctx</span> <span class=\"o\">:=</span> <span class=\"n\">lctx.setBinderInfo</span> <span class=\"n\">decl.fvarId</span> <span class=\"bp\">.</span><span class=\"n\">implicit</span>\n        <span class=\"n\">withLCtx</span> <span class=\"n\">lctx</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getLocalInstances</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n          <span class=\"n\">mkLambdaFVars</span> <span class=\"n\">args</span> <span class=\"o\">(</span><span class=\"n\">mkAppN</span> <span class=\"n\">e</span> <span class=\"n\">args</span><span class=\"o\">)</span>\n      <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"no_inst% created type {← inferType e'}\"</span>\n      <span class=\"n\">return</span> <span class=\"n\">e'</span>\n    <span class=\"k\">else</span>\n      <span class=\"c1\">-- Generate error:</span>\n      <span class=\"n\">Term.elabTerm</span> <span class=\"n\">name</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">NoInst</span>\n\n\n<span class=\"kn\">open</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">Finset</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"o\">(</span><span class=\"n\">vars</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">vars</span> <span class=\"n\">P</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vars</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">vars_sub_of_disjoint</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">vars_X</span><span class=\"o\">,</span> <span class=\"n\">no_inst</span><span class=\"bp\">%</span> <span class=\"n\">mem_union</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_singleton</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 348251036,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681142346
    },
    {
        "content": "<p>Nice! I think turning all <code>[]</code> into <code>{}</code> might not work so well in practice though. In my experience, I've had to mix and match.</p>",
        "id": 348251781,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1681142528
    },
    {
        "content": "<p>For rewriting, it'd be better to keep track whether the instance argument is only for the RHS and leave those alone. Do you know if there are other heuristics?</p>",
        "id": 348251995,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681142589
    },
    {
        "content": "<p>Would it make sense to try unification and fall back to synthesis if that fails?</p>",
        "id": 348252103,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1681142627
    },
    {
        "content": "<p>I think you're getting into \"changes to Lean 4 core\" territory here. Anne Baanen I believe was the one who made that change to Lean 3, and it's been a nice feature.</p>",
        "id": 348252510,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681142729
    },
    {
        "content": "<p>Yeah, it seems complicated to implement well</p>",
        "id": 348252557,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1681142750
    },
    {
        "content": "<p>Unfortunately, I don't have good rules for when to do which except if it times out, then switch to <code>{}</code></p>",
        "id": 348252729,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1681142796
    },
    {
        "content": "<p>Is there any way to manually pick the instance argument(s) as Eric suggested?</p>",
        "id": 348252993,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1681142883
    },
    {
        "content": "<p>I guess: \"earlier instance parameters in the signature tend to be less problematic than later ones\" has been fairly true</p>",
        "id": 348254033,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1681143183
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span> Here's another term elaborator. This time <code>de_inst% mem_union 2</code> takes argument index 2, checks that it's an instance implicit, and then turns it into an implicit. You can give it as many argument indices as you want, like <code>de_inst% f 3 5 7</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.MvPolynomial.CommRing</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">NoInst</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Lean.Parser.Term</span>\n<span class=\"kn\">open</span> <span class=\"n\">Meta</span> <span class=\"n\">Command</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">de_inst</span><span class=\"o\">)</span> <span class=\"s2\">\"de_inst% \"</span> <span class=\"n\">ident</span> <span class=\"n\">num</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">@[term_elab de_inst]</span>\n<span class=\"kd\">def</span> <span class=\"n\">no_inst_elab</span> <span class=\"o\">:</span> <span class=\"n\">Elab.Term.TermElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">de_inst</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">name</span> <span class=\"bp\">$</span><span class=\"n\">nums</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">nums</span> <span class=\"o\">:=</span> <span class=\"n\">nums.map</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">getNat</span><span class=\"o\">)</span>\n    <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">Term.resolveId</span><span class=\"bp\">?</span> <span class=\"n\">name</span> <span class=\"o\">(</span><span class=\"n\">withInfo</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">e'</span> <span class=\"bp\">←</span> <span class=\"n\">forallTelescope</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">args</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">lctx</span> <span class=\"bp\">←</span> <span class=\"n\">getLCtx</span>\n        <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">nums</span> <span class=\"k\">do</span>\n          <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"bp\">||</span> <span class=\"n\">i</span> <span class=\"bp\">&gt;</span> <span class=\"n\">args.size</span> <span class=\"k\">then</span>\n            <span class=\"n\">throwError</span> <span class=\"s2\">\"${name} does not have argument index {i}\"</span>\n          <span class=\"k\">let</span> <span class=\"n\">arg</span> <span class=\"o\">:=</span> <span class=\"n\">args</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n          <span class=\"k\">let</span> <span class=\"n\">decl</span> <span class=\"o\">:=</span> <span class=\"n\">lctx.getFVar</span><span class=\"bp\">!</span> <span class=\"n\">arg</span>\n          <span class=\"k\">if</span> <span class=\"n\">not</span> <span class=\"n\">decl.binderInfo.isInstImplicit</span> <span class=\"k\">then</span>\n            <span class=\"n\">throwError</span> <span class=\"s2\">\"argument index {i} (of type {← inferType arg}) is not an instance implicit\"</span>\n          <span class=\"n\">lctx</span> <span class=\"o\">:=</span> <span class=\"n\">lctx.setBinderInfo</span> <span class=\"n\">decl.fvarId</span> <span class=\"bp\">.</span><span class=\"n\">implicit</span>\n        <span class=\"n\">withLCtx</span> <span class=\"n\">lctx</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getLocalInstances</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n          <span class=\"n\">mkLambdaFVars</span> <span class=\"n\">args</span> <span class=\"o\">(</span><span class=\"n\">mkAppN</span> <span class=\"n\">e</span> <span class=\"n\">args</span><span class=\"o\">)</span>\n      <span class=\"n\">return</span> <span class=\"n\">e'</span>\n    <span class=\"k\">else</span>\n      <span class=\"c1\">-- Generate error:</span>\n      <span class=\"n\">Term.elabTerm</span> <span class=\"n\">name</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">NoInst</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">Finset</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"o\">(</span><span class=\"n\">vars</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">vars</span> <span class=\"n\">P</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vars</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">vars_sub_of_disjoint</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">vars_X</span><span class=\"o\">,</span> <span class=\"n\">de_inst</span><span class=\"bp\">%</span> <span class=\"n\">mem_union</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_singleton</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 348255531,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681143648
    },
    {
        "content": "<p>The indexing could also be with respect to the instance implicit arguments themselves, but this a little easier.</p>",
        "id": 348255865,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681143741
    },
    {
        "content": "<p>Great! Yeah, I think either specifying the index or type manually probably has the widest use without getting seriously into the guts of the synthesis algorithm</p>",
        "id": 348256380,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1681143909
    },
    {
        "content": "<p>I think the big win here would be specifying the type of the target argument</p>",
        "id": 348258801,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681144635
    },
    {
        "content": "<p>Perhaps <code>foo (_ : Bar := val)</code> would be a reasonable syntax request for core?</p>",
        "id": 348259835,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681144934
    },
    {
        "content": "<p>That syntax at least seems unambiguous, and it might not be that crazy of a feature since something like <code>foo (x : Bar := val)</code> could still be valid and be helpful for elaboration of both <code>val</code> and <code>foo</code>. I guess you still have to decide how this works when there are multiple matches, either if there are two <code>Bar</code>s or if you allow <code>Bar</code> to have placeholders.</p>",
        "id": 348262762,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681145881
    },
    {
        "content": "<p>In the meantime, it's not so hard to implement this as a term elaborator, with syntax like <code>with_args% foo (_ : Bar := val)</code>.</p>",
        "id": 348262934,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681145932
    },
    {
        "content": "<p>Now <a href=\"https://github.com/leanprover-community/mathlib4/pull/3355\">!4#3355</a> changes 29 files, but it compiles!</p>",
        "id": 348415058,
        "sender_full_name": "Joël Riou",
        "timestamp": 1681207989
    },
    {
        "content": "<p>It sounds to me like it would be worth backporting some of these changes just to check they don't cause trouble elsewhere</p>",
        "id": 348423064,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681210311
    },
    {
        "content": "<p>Gah, what's going on here? I thought we decided long ago not to have any decidability instances in the polynomial library?</p>",
        "id": 351523503,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1682059832
    },
    {
        "content": "<p>I think we decided to not have them in definitions</p>",
        "id": 351533286,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682062961
    },
    {
        "content": "<p>Lemmas without them are harder to use than lemmas with them</p>",
        "id": 351533387,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682062993
    },
    {
        "content": "<p>Because they introduce non-canonical decidability instances into the goal</p>",
        "id": 351533472,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682063023
    },
    {
        "content": "<p>The problem arose while porting <code>WittVector.WittPolynomial</code>. In the proof of <code>xInTermsOfW_vars_aux</code>, there are some manipulations on <code>Finset ℕ</code>. Some lemmas used in the proof involve the <code>DecidableEq</code> instance coming from the integers and some involve the one obtained by <code>classical</code>. Lean3 <code>rw</code> was able to deal with that; but it is not so in <code>Lean4</code>. By adding <code>DecidableEq</code> in many places as I eventually did in <a href=\"https://github.com/leanprover-community/mathlib4/pull/3355\">!4#3355</a> I could have this PR compile. However, I think that either we can make <code>rw</code> work following Kyle suggestion or we should just completely get rid of any global <code>DecidableEq</code> instance that is not <code>classical.decEq</code>...</p>",
        "id": 351557405,
        "sender_full_name": "Joël Riou",
        "timestamp": 1682068967
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/3355\">!4#3355</a> changes a lot more than it needs to, as discussed in the backport</p>",
        "id": 351558397,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682069183
    },
    {
        "content": "<p>I have made other attempts, and it eventually reduces to the problem I have mentionned just above.</p>",
        "id": 351562041,
        "sender_full_name": "Joël Riou",
        "timestamp": 1682069978
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>, my point is that <a href=\"https://github.com/leanprover-community/mathlib/pull/18791\">#18791</a> (+621 −426, the backport) adds <code>decidable_eq</code> arguments to both <code>def</code>s (which Scott is rightly opposed to) and <code>lemmas</code>  (which I think we recently agreed was a good thing)</p>",
        "id": 351562645,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682070112
    },
    {
        "content": "<p>I have created a smaller PR at <a href=\"https://github.com/leanprover-community/mathlib/pull/18848\">#18848</a> (+154 −90) which should hopefully be  less controversial. <del>Getting <code>mv_polynomial.vars</code> right will need more care so as to not break everything downstream like it seem to in <a href=\"https://github.com/leanprover-community/mathlib/pull/18791\">#18791</a></del> I've added the changes to this file too.</p>",
        "id": 351563970,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682070396
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>, are you happy with <a href=\"https://github.com/leanprover-community/mathlib/pull/18848\">#18848</a>? (other than the 10 files of forward-porting burden it creates)</p>",
        "id": 352248793,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682337114
    },
    {
        "content": "<p>I better sleep before attempting to read the changes, but at least the PR description I'm happy with. :-)</p>",
        "id": 352249155,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1682337191
    },
    {
        "content": "<p><span aria-label=\"ping pong\" class=\"emoji emoji-1f3d3\" role=\"img\" title=\"ping pong\">:ping_pong:</span> on the above. I probably won't have time to respond to any review feedback this week, but it would be good not to forget about it</p>",
        "id": 357118192,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683674298
    },
    {
        "content": "<p><span aria-label=\"ping pong\" class=\"emoji emoji-1f3d3\" role=\"img\" title=\"ping pong\">:ping_pong:</span> answered!</p>",
        "id": 357224041,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1683711461
    },
    {
        "content": "<p>The forward-port, <a href=\"https://github.com/leanprover-community/mathlib4/pull/4007\">!4#4007</a>, is ready for (careful) review. This uses up 10 spots on #out-of-sync.</p>",
        "id": 358951055,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684320751
    },
    {
        "content": "<p>The <code>DecidableEq</code> problems in this PR are all gone</p>",
        "id": 360214407,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684748734
    },
    {
        "content": "<p>I got the whole thing building, but some of the porting had introduced some mistakes, so after fixing them there are some things to cleanup</p>",
        "id": 360214585,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684748757
    },
    {
        "content": "<p>Annoyingly <code>rw [Finset.sum_congr rfl]</code> no longer seems to work</p>",
        "id": 360214706,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684748766
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/3355\">!4#3355</a> for reference</p>",
        "id": 360224382,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1684751193
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/3355\">!4#3355</a> compiles now. Thanks very much <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> for your efforts!</p>",
        "id": 360291646,
        "sender_full_name": "Joël Riou",
        "timestamp": 1684766096
    },
    {
        "content": "<p>Looking over the diff against the mathport output, it looks like there are a few places that are missing porting note (at least one of them is one I introduced!)</p>",
        "id": 360291852,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684766148
    },
    {
        "content": "<p>The <code>sum_eq_zero</code> thing you mention is particularly strange; is it still a problem with all the other fixes?</p>",
        "id": 360292003,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684766175
    }
]