[
    {
        "content": "<p>Following a suggestion in one of my PR’s (<a href=\"https://github.com/leanprover-community/mathlib4/pull/8013\">#8013</a>), I’m trying to play with categories freely generated by a <code>Quiver</code>. They are built in the file <code>Mathlib/CategoryTheory/PathCategory.lean</code> and as far as I understand, the idea is to change the <code>Quiver</code> instance on the type from the original one to the one defined by <code>Quiver.Path</code>, and using the composition of Paths there.</p>\n<p>This results in a type having multiple <code>Quiver</code> instances at the same time, and looks like the elaborator really doesn’t like this. Here’s a short example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.PathCategory</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">c</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">foo</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Hom</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">→</span> <span class=\"n\">foo</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Hom</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Hom</span> <span class=\"n\">b</span> <span class=\"n\">c</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">Q</span><span class=\"o\">:</span> <span class=\"n\">Quiver</span> <span class=\"n\">foo</span> <span class=\"n\">where</span>\n  <span class=\"n\">Hom</span> <span class=\"o\">:=</span> <span class=\"n\">Hom</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">Paths</span> <span class=\"n\">foo</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">SmallCategory</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">Paths.categoryPaths</span> <span class=\"n\">foo</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Quiver.Hom.toPath</span> <span class=\"n\">foo</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">Hom.f</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Quiver.Hom.toPath</span> <span class=\"n\">foo</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">Hom.f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Paths</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span>  <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Paths</span> <span class=\"n\">foo</span><span class=\"o\">))</span> <span class=\"c1\">-- Error</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Quiver.Hom.toPath</span> <span class=\"n\">foo</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">Hom.f</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Quiver.Hom.toPath</span> <span class=\"n\">foo</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">Hom.g</span><span class=\"o\">)</span> <span class=\"c1\">-- Error here</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bar</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Quiver.Hom.toPath</span> <span class=\"n\">foo</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">Hom.f</span><span class=\"o\">)</span> <span class=\"bp\">≫</span>  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Quiver.Hom.toPath</span> <span class=\"n\">foo</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">Hom.g</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n      <span class=\"n\">Quiver.Path.cons</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Quiver.Hom.toPath</span> <span class=\"n\">foo</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">Hom.f</span><span class=\"o\">)</span> <span class=\"n\">Hom.g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">foo</span>\n</code></pre></div>\n<p>Ideally, I would like to be able to use the notations <code>⟶</code> and <code>≫</code> in a transparent way on stuff of the form <code>_.toPath</code>, but it looks like lean want me to give the explicit quiver structure at every step. Is it doomed?</p>",
        "id": 399970839,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1698939947
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> It looks like the key part of the <code>Paths</code> API is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Paths.of#doc\">docs#CategoryTheory.Paths.of</a>, which you can use to convert objects to the <code>Paths</code> category and turn morphisms into length-1 paths. (Note that having multiple instances on the same type is fine if you use a type synonym like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Paths#doc\">docs#CategoryTheory.Paths</a>, since this is a non-<code>@[reducible]</code>/<code>abbrev</code> definition, so typeclass inference sees it as being a different type.)</p>\n<p>Something that you need to make this convenient is a function to convert from your <code>Hom</code> to the <code>--&gt;</code>. I added this as the abbrev <code>Hom.toHom</code>.</p>\n<p>Also, something to be aware of is that there's a difference between <code>Paths.of.map Hom.f.toHom</code> and <code>Hom.f.toHom.toPath</code>. They might be defeq, but the first is syntactically a morphism in the path category, and the second is a <code>Quiver.Path</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.PathCategory</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">c</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">foo</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Hom</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">→</span> <span class=\"n\">foo</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Hom</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Hom</span> <span class=\"n\">b</span> <span class=\"n\">c</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">Quiver</span> <span class=\"n\">foo</span> <span class=\"n\">where</span>\n  <span class=\"n\">Hom</span> <span class=\"o\">:=</span> <span class=\"n\">Hom</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Hom.toHom</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">foo</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Hom</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⟶</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Paths.of.map</span> <span class=\"n\">Hom.f.toHom</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">Paths.of.map</span> <span class=\"n\">Hom.f.toHom</span> <span class=\"o\">:</span> <span class=\"n\">Paths.of.obj</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">Paths.of.obj</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">Paths.of.map</span> <span class=\"n\">Hom.f.toHom</span> <span class=\"bp\">≫</span> <span class=\"n\">Paths.of.map</span> <span class=\"n\">Hom.g.toHom</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bar</span> <span class=\"o\">:</span>\n    <span class=\"n\">Paths.of.map</span> <span class=\"n\">Hom.f.toHom</span> <span class=\"bp\">≫</span> <span class=\"n\">Paths.of.map</span> <span class=\"n\">Hom.g.toHom</span> <span class=\"bp\">=</span>\n      <span class=\"n\">Quiver.Path.cons</span> <span class=\"n\">Hom.f.toHom.toPath</span> <span class=\"n\">Hom.g.toHom</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">foo</span>\n</code></pre></div>",
        "id": 400004782,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698951906
    },
    {
        "content": "<p>The errors you were seeing mostly had to do with the elaborator not seeing things in the syntactic forms they're supposed to have to get different instances to be found. For example, <code>(a : Paths foo)</code> isn't enough to get <code>a</code> to <em>be</em> an object in <code>Paths foo</code>. All this does is have Lean check that <code>a</code> could be, but <code>a</code> remains having type <code>foo</code>. This is the purpose of using <code>Paths.of.obj</code> directly; it inserts the necessary retyping.</p>\n<p>Also, just so you know, you don't need to create instances yourself. This pattern</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">Paths</span> <span class=\"n\">foo</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">SmallCategory</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">Paths.categoryPaths</span> <span class=\"n\">foo</span>\n</code></pre></div>\n<p>is for creating a new type without any instances and then copying over an instance (<code>instance : SmallCategory C := inferInstanceAs &lt;| SmallCategory (Paths foo)</code> is the same but a bit nicer because it doesn't name the instance). If you did</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">Paths</span> <span class=\"n\">foo</span>\n</code></pre></div>\n<p>then <code>C</code> would have all the instances on <code>Paths foo</code>.</p>",
        "id": 400005325,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698952183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Dealing.20with.20multiple.20instances.20on.20a.20single.20type/near/400004782\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> It looks like the key part of the <code>Paths</code> API is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Paths.of#doc\">docs#CategoryTheory.Paths.of</a>, which you can use to convert objects to the <code>Paths</code> category and turn morphisms into length-1 paths. (Note that having multiple instances on the same type is fine if you use a type synonym like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Paths#doc\">docs#CategoryTheory.Paths</a>, since this is a non-<code>@[reducible]</code>/<code>abbrev</code> definition, so typeclass inference sees it as being a different type.)</p>\n<p>Something that you need to make this convenient is a function to convert from your <code>Hom</code> to the <code>--&gt;</code>. I added this as the abbrev <code>Hom.toHom</code>.</p>\n<p>Also, something to be aware of is that there's a difference between <code>Paths.of.map Hom.f.toHom</code> and <code>Hom.f.toHom.toPath</code>. They might be defeq, but the first is syntactically a morphism in the path category, and the second is a <code>Quiver.Path</code>.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.PathCategory</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">c</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">foo</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Hom</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">→</span> <span class=\"n\">foo</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Hom</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Hom</span> <span class=\"n\">b</span> <span class=\"n\">c</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">Quiver</span> <span class=\"n\">foo</span> <span class=\"n\">where</span>\n  <span class=\"n\">Hom</span> <span class=\"o\">:=</span> <span class=\"n\">Hom</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Hom.toHom</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">foo</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Hom</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⟶</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Paths.of.map</span> <span class=\"n\">Hom.f.toHom</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">Paths.of.map</span> <span class=\"n\">Hom.f.toHom</span> <span class=\"o\">:</span> <span class=\"n\">Paths.of.obj</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">Paths.of.obj</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">Paths.of.map</span> <span class=\"n\">Hom.f.toHom</span> <span class=\"bp\">≫</span> <span class=\"n\">Paths.of.map</span> <span class=\"n\">Hom.g.toHom</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bar</span> <span class=\"o\">:</span>\n    <span class=\"n\">Paths.of.map</span> <span class=\"n\">Hom.f.toHom</span> <span class=\"bp\">≫</span> <span class=\"n\">Paths.of.map</span> <span class=\"n\">Hom.g.toHom</span> <span class=\"bp\">=</span>\n      <span class=\"n\">Quiver.Path.cons</span> <span class=\"n\">Hom.f.toHom.toPath</span> <span class=\"n\">Hom.g.toHom</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">foo</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thank you a lot for pointing out that <code>Paths.of</code> is a thing and for the detailed explanations of how things work, this is really instructive!</p>",
        "id": 400012418,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1698955769
    }
]