[
    {
        "content": "<p>I have always ignored how type class inference works in the past, dismissing it as \"too CS for me\". My current level of understanding is that I'm dimly aware that it might be a \"prolog-like search\" but I don't really know what that means. Of course I know in practice what type class inference <em>does</em> in mathlib, and that understanding of the \"basic idea\" has been all I've needed.</p>\n<p>In the past I have been able to remain ignorant about the details of type class inference very effectively because type class inference issues never really affected me in Lean 3. There were plenty of experts here who had mastered them, and my experience with Lean 3 was that they \"just worked\". </p>\n<p>With Lean 4 the situation is different. There are type class inference issues coming up all the time, when porting files I care about, and in stark contrast to Lean 3 right now there are more questions than answers. Just in the last two days we've had <a href=\"#narrow/stream/287929-mathlib4/topic/Algebra.2EModule.2EEquiv.20mathlib4.231732/near/322979337\">this question</a> and <a href=\"#narrow/stream/287929-mathlib4/topic/Order.2EHom.2ELattice/near/323360873\">this question</a>, and there are issues <a href=\"https://github.com/leanprover/lean4/pull/1852\">lean4#1852</a> (which I don't understand properly) and of course <a href=\"https://github.com/leanprover/lean4/pull/2003\">lean4#2003</a> fixing my issue <a href=\"https://github.com/leanprover/lean4/pull/1986\">lean4#1986</a> but still not merged so we're still having to work around it, as well as my new issue <a href=\"https://github.com/leanprover/lean4/pull/2055\">lean4#2055</a>. I'm hence minded to actually try and understand properly how type class inference works, not least because I suspect that it will not be too hard for me to get my head around it given that I have a pretty good working knowledge of what it's doing in practice.</p>\n<p>In the past when I have not understood things I have attempted to write documents explaining them: for example I wrote the first version of <a href=\"https://leanprover-community.github.io/extras/simp.html\">this page</a> on <code>simp</code> many years ago, when I was getting the hang of <code>simp</code>, and the write-up was so bad that it forced other people to write a better one ;-) I now understand <code>simp</code> so well that I can teach it. I would like to get to the same situation with type class inference.</p>\n<p>A lot of discussion recently has been about <code>outParams</code>, as <code>out_param</code>s are called in Lean 4. One marked improvement of Lean 4 over Lean 3 is that documentation of the source code is much better, so I can read the docstring for <code>outParam</code>, which I quote here:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>Gadget for marking output parameters in type classes.\n\nFor example, the `Membership` class is defined as:\n```\nclass Membership (Œ± : outParam (Type u)) (Œ≥ : Type v)\n```\nThis means that whenever a typeclass goal of the form `Membership ?Œ± ?Œ≥` comes\nup, lean will wait to solve it until `?Œ≥` is known, but then it will run\ntypeclass inference, and take the first solution it finds, for any value of `?Œ±`,\nwhich thereby determines what `?Œ±` should be.\n\nThis expresses that in a term like `a ‚àà s`, `s` might be a `Set Œ±` or\n`List Œ±` or some other type with a membership operation, and in each case\nthe \"member\" type `Œ±` is determined by looking at the container type.\n</code></pre></div>\n<p>I am already a little lost with this, and it's a pretty simple example. I can write my own <code>Membership'</code> without the <code>outParam</code> and it seems to work fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">a</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span> <span class=\"c1\">-- works fine</span>\n\n<span class=\"c1\">-- no outParam</span>\n<span class=\"kd\">class</span> <span class=\"n\">Membership'</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ≥</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- The membership relation `a ‚àà s : Prop` where `a : Œ±`, `s : Œ≥`. -/</span>\n  <span class=\"n\">mem</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≥</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Membership'</span> <span class=\"n\">Œ±</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mem</span> <span class=\"o\">:=</span> <span class=\"n\">Set.Mem</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Membership'.mem</span> <span class=\"n\">a</span> <span class=\"n\">S</span> <span class=\"c1\">-- works fine</span>\n</code></pre></div>\n<p>So clearly the <code>outParam</code> is needed to cover some other use case. But I don't understand what that use case is: I'm missing something completely fundamental. The docs say \"This means that whenever a typeclass goal of the form <code>Membership ?Œ± ?Œ≥</code> comes<br>\nup...\". When does such a goal ever come up? I never write <code>_ ‚àà _</code> in my code, I write <code>a ‚àà S</code>, and I would not expect <code>_ ‚àà _</code> to ever be useful. What am I missing?</p>\n<p>I think my problem is that my model of what type class inference does is \"it solves <code>monoid X</code> given <code>normed_field X</code>\", but that this model is too simplistic. What is the next simplest case? What is the simplest case of type class inference which actually happens in practice and needs <code>outParam</code>s? I had a vague idea that it showed up in <code>Module R M</code> but I've looked at the source code and I can't see any <code>outParam</code>s there.</p>",
        "id": 323522673,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674662388
    },
    {
        "content": "<p>Non-mathlib example: remember that we has <code>class module (R : out_param Type) (M : Type)</code>?<br>\nThat way, if you passed around some <code>x : M</code>, Lean would be able to figure out <code>R</code> from that info.</p>",
        "id": 323525449,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1674663020
    },
    {
        "content": "<p>But we decided (rightly), that we want multiple <code>R</code>s for one <code>M</code>. So in that case <code>out_param</code> was a bad design choice.</p>",
        "id": 323525560,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1674663048
    },
    {
        "content": "<p>The goal of <code>outParam</code> is that type class inference search will fire if that argument is unknown. So the fact that <code>Œ±</code>is an out-param of <code>Membership</code> means that Lean can understand what <code>a ‚àà S</code> means even though it doesn't know the type of <code>a</code> (if it knows the type of <code>S</code>). Here is how the difference shows in your example. Note that I'm not specifying the type of <code>a</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span> <span class=\"c1\">-- works fine</span>\n\n<span class=\"c1\">-- no outParam</span>\n<span class=\"kd\">class</span> <span class=\"n\">Membership'</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ≥</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- The membership relation `a ‚àà s : Prop` where `a : Œ±`, `s : Œ≥`. -/</span>\n  <span class=\"n\">mem</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≥</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Membership'</span> <span class=\"n\">Œ±</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mem</span> <span class=\"o\">:=</span> <span class=\"n\">Set.Mem</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Membership'.mem</span> <span class=\"n\">a</span> <span class=\"n\">S</span> <span class=\"c1\">-- cannot figure out the type of `a`.</span>\n</code></pre></div>",
        "id": 323525603,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1674663059
    },
    {
        "content": "<p>OK so this I understand. What I don't understand is why typeclass inference ever needs to solve such a problem. Maybe I should now go back and look at the issues which had come up recently.</p>",
        "id": 323527594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674663600
    },
    {
        "content": "<p>So let's take a look at this example from one of the threads:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Hom.Basic</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">SupHomClass</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">HasSup</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasSup</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">FunLike</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Œ≤</span> <span class=\"n\">where</span>\n  <span class=\"n\">map_sup</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">‚äî</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">‚äî</span> <span class=\"n\">f</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">LatticeHomClass</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">SupHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"n\">where</span>\n  <span class=\"n\">map_inf</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">‚äì</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">‚äì</span> <span class=\"n\">f</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">BoundedLatticeHomClass</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">LatticeHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"n\">where</span>\n  <span class=\"n\">map_top</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">‚ä§</span> <span class=\"bp\">=</span> <span class=\"bp\">‚ä§</span>\n  <span class=\"n\">map_bot</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">‚ä•</span> <span class=\"bp\">=</span> <span class=\"bp\">‚ä•</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"n\">SupHomClass.toOrderHomClass</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">SupHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OrderHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"o\">‚Äπ</span><span class=\"n\">SupHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">‚Ä∫</span> <span class=\"k\">with</span>\n    <span class=\"n\">map_rel</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">sup_eq_right</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">map_sup</span><span class=\"o\">,</span> <span class=\"n\">sup_eq_right.2</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedLatticeHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">OrderHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n<span class=\"n\">SupHomClass.toOrderHomClass</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">synthInstance.maxHeartbeats</span> <span class=\"mi\">400</span> <span class=\"k\">in</span> <span class=\"c1\">-- to stop huge outputs crashing VS code</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.synthInstance</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedLatticeHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">OrderHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n<span class=\"n\">inferInstance</span> <span class=\"c1\">-- loops</span>\n</code></pre></div>\n<p>My completely deficient mental model of this situation is: the typeclass inference system is asked \"I'll give you instances of <code>Lattice Œ±</code>, <code>Lattice Œ≤</code> etc -- now you go and find me an instance of <code>OrderHomClass F Œ± Œ≤</code>. My answer to that (I am \"being the type class inference system\") is \"[pause while I shuffle through this big list of instances I have...] sure: <code>SupHomClass.toOrderHomClass</code> is an instance so I'll use that -- I guess I need to now find instances of <code>SemilatticeSup Œ±</code>, <code>SemilatticeSup Œ≤</code> and <code>SupHomClass F Œ± Œ≤</code> but these are equally easily solved using other instances in my database\". Job done! What am I missing? Why are people going on about outParams in that thread?</p>",
        "id": 323529731,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674664092
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedLatticeHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span>\n<span class=\"n\">inferInstance</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedLatticeHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">SupHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n<span class=\"n\">inferInstance</span>\n</code></pre></div>\n<p>etc</p>",
        "id": 323530570,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674664302
    },
    {
        "content": "<p>The important part about out params is that they allow Lean to solve goals of the form <code>OrderHomClass F ?_ ?_</code>, where the values for <code>Œ±</code> and <code>Œ≤</code> are not yet known. This is useful because it allows you to write something like <code>‚àÄ x y, f x ‚â§ f y</code> without having to hint that <code>x : Œ±</code> and <code>f x : Œ≤</code>: those are the output of searching for the instance (hence out-param).</p>",
        "id": 323530851,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1674664376
    },
    {
        "content": "<p>Due to dependent types, we could (and did, in the case of <code>has_coe_to_fun</code> before it was backported from Lean 4) instead turn <code>Œ±</code> and <code>Œ≤</code> into fields in the class, so something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">CoeFun</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">toFun</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This should give you exactly the same mental image of the class as the current <code>outParam</code> based implementation.</p>\n<p>(I'm omitting universe parameters, which would make this slightly more awkward.)</p>",
        "id": 323531644,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1674664566
    },
    {
        "content": "<p>Note also that the behavior of outParams and \"in params\" (all other params) is in fact disjoint: If you ask Lean to infer <code>OrderHomClass F Œ± Œ≤</code>, it will actually start with the goal <code>OrderHomClass F ?Œ± ?Œ≤</code> -- it will actively forget that it already knew something about the outParam values, which is important to make elaboration less dependent on the exact elaboration ordering. So as the next step it will try to infer <code>[Lattice ?Œ±]</code>, which is usually a bad idea.</p>",
        "id": 323532517,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674664815
    },
    {
        "content": "<p>However, we get a problem when we want to talk about the order on <code>Œ±</code> and <code>Œ≤</code>. We would have to add these orderings as fields:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">OrderHomClass</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">leŒ±</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">leŒ≤</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">toFun</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">map_le</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">‚â§</span> <span class=\"n\">y</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">toFun</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">‚â§</span> <span class=\"n\">toFun</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Now trying to apply <code>OrderHomClass.map_le f</code> doesn't give you any guarantee that <code>f</code>'s idea of <code>‚â§</code> coincides with yours. So we somehow have to put the <code>LE</code> instances into the type of <code>map_le</code>. And we can only do this when <code>Œ± Œ≤</code> are also in the type, which we can only do by making them <code>outParam</code>s.</p>",
        "id": 323532696,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1674664863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/287929-mathlib4/topic/What.20is.20an.20outParam.3F/near/323532517\">said</a>:</p>\n<blockquote>\n<p>it will actively forget that it already knew something about the outParam values</p>\n</blockquote>\n<p>Note however that this only applies to the initial TC goal; as soon as typeclass inference is running, <code>outParam</code> is irrelevant</p>",
        "id": 323533004,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674664947
    },
    {
        "content": "<p>Wait a minute!</p>\n<blockquote>\n<p>If you ask Lean to infer OrderHomClass F Œ± Œ≤, it will actually start with the goal OrderHomClass F ?Œ± ?Œ≤</p>\n</blockquote>\n<p>Why? Isn't that a crazy idea?</p>\n<blockquote>\n<p>which is important to make elaboration less dependent on the exact elaboration ordering</p>\n</blockquote>\n<p>I don't understand what this means.</p>",
        "id": 323533180,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674665007
    },
    {
        "content": "<p>Strictly speaking it's in the name: it is (purely) an output of TC inference. Everything that is not an output is an input, the two are never mixed.</p>",
        "id": 323533507,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674665092
    },
    {
        "content": "<p>Is there a technical reason why we <em>have to</em> turn them into metavariables? Or is it (I suppose) just for ease of implementation?</p>",
        "id": 323534073,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1674665259
    },
    {
        "content": "<p>I came across some cases where Lean 3 would accept an out-param where it wouldn't an in-param: <a href=\"https://github.com/leanprover-community/mathlib/pull/18291/commits/fa1a311b0fdf0784bc0e7830e4e8f9f4985a91b0\">https://github.com/leanprover-community/mathlib/pull/18291/commits/fa1a311b0fdf0784bc0e7830e4e8f9f4985a91b0</a> but that seems to be more of a case of the resulting out-params being checked at semireducible transparency vs. in-params being checked at the point the instance is applied, with instance-reducible transparency.</p>",
        "id": 323534669,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1674665417
    },
    {
        "content": "<p>So right now TCI (if I can call it that) when faced with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BoundedLatticeHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">OrderHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n<span class=\"n\">inferInstance</span>\n</code></pre></div>\n<p>says \"Ok I want to solve <code>OrderHomClass F Œ± Œ≤</code> and because the definition of <code>OrderHomClass</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">OrderHomClass</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">RelHomClass</span> <span class=\"n\">F</span> <span class=\"o\">((</span><span class=\"bp\">¬∑</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">¬∑</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"bp\">¬∑</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">¬∑</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Œ≤</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which mentions outParams I will instead try and solve <code>OrderHomClass F ?1 ?2</code> <em>even though I know what ?1 and ?2 are</em>. I will now look in my big list of instances -- oh look, here's <code>SupHomClass.toOrderHomClass</code>, so now I need to solve <code>SemilatticeSup ?1</code> and <code>SemilatticeSup ?2</code> and <code>SupHomClass F ?1 ?2</code>\", and the point is that it's trying to solve <code>SemilatticeSup ?1</code> next <em>even though it knows what <code>?1</code> is</em> but somehow has now forgotten?</p>",
        "id": 323534814,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674665445
    },
    {
        "content": "<p>The most important property for elaboration robustness is what I and maybe no-one else is calling <em>monotonicity</em>: assigning a metavariable should not <em>change</em> the output of a subsequent elaboration step other than to change it from failure to success. But if we allowed mixed in/out TC parameters, <code>[OrderHomClass F ?Œ± ?Œ≤]</code> and <code>OrderHomClass F Œ± ?Œ≤]</code> could certainly both succeed with different answers.</p>",
        "id": 323534863,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674665461
    },
    {
        "content": "<p>Wait -- isn't there supposed to be precisely one answer to that typeclass problem?</p>",
        "id": 323535058,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674665515
    },
    {
        "content": "<p>No, Lean TC problems can have many solutions. The second one is more constrained, so it may skip the first's solution and find a different one.</p>",
        "id": 323535330,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674665588
    },
    {
        "content": "<p>Replace <code>Œ±</code> with some constant in the second problem to maybe make it more realistic</p>",
        "id": 323535467,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674665632
    },
    {
        "content": "<p>Certainly it seems possible and useful to have a local instance that differs from a global default one, which would violate the one-answer rule.</p>",
        "id": 323535593,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1674665661
    },
    {
        "content": "<p>In other words, this property is important to guarantee that it doesn't matter in which order we solve TC problems, as long as we can solve them at all</p>",
        "id": 323535793,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674665721
    },
    {
        "content": "<p>Why doesn't the typeclass inference system immediately abort when faced with the goal <code>SemilatticeSup ?Œ±</code>? It's a manifestly dumb question. The point is that right now there is no way of telling the system this, other than just by letting it time out?</p>\n<p>With regards to <code>OrderHomClass</code>, isn't <code>F</code> is supposed to be some proxy for <code>Œ± -&gt; Œ≤</code>? I don't understand why <code>OrderHomClass F ?Œ± ?Œ≤</code> doesn't have a unique solution (I mean one solution for <code>?alpha</code>, one for <code>?beta</code> and one for the term of type <code>OrderHomClass F alpha beta</code>.</p>",
        "id": 323535843,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674665740
    },
    {
        "content": "<p>On the other hand I have been considering writing a linter that enforces all of these overlapping instances (to use Haskell terminology) are definitionally equal, and I am rather sure this would save a lot of headaches in mathlib while not majorly breaking any existing patterns.</p>",
        "id": 323536017,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1674665787
    },
    {
        "content": "<p>Also, I'm not saying that Lean elaboration is perfectly monotonic everywhere, but since TC resolution is deferred by default it's a good property to have here</p>",
        "id": 323536072,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674665806
    },
    {
        "content": "<p>So my answer would be: the meaning of \"supposed\" is \"library maintainers should check this\", not \"the compiler enforces this\".</p>",
        "id": 323536167,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1674665834
    },
    {
        "content": "<p>I thought the whole point of type class inference was that it was supposed to be running under the assumption that there was only one solution to every question it was asked, and it was up to maintainers to ensure that this is the case? And yet you're now suggesting that it's been designed to allow the possibility that this is false?</p>",
        "id": 323536596,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674665951
    },
    {
        "content": "<p>I thought that we remove diamonds from mathlib because they were breaking proofs because they were contradicting assumptions which the typeclass inference system was designed to assume.</p>",
        "id": 323537085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674666058
    },
    {
        "content": "<p>That's not really on the TC system, it could happen even without any inference. If you have two ways to state something, and you use, or have inferred, both of them in two different contexts and then try to combine these parts, you're in trouble unless they are defeq.</p>",
        "id": 323537866,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674666272
    },
    {
        "content": "<p>For what it's worth, I believe proper use and propagation of <code>outParams</code> would be far easier to systematically enforce (as in Kevin's</p>\n<blockquote>\n<p>Why doesn't the typeclass inference system immediately abort when faced with the goal SemilatticeSup ?Œ±</p>\n</blockquote>\n<p>) than uniqueness of TC solutions, but this is probably not the time to revise the design of TC inference in such a way...</p>",
        "id": 323538582,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674666478
    },
    {
        "content": "<p>Right! And for <code>module ?a M</code> we definitely want more than one solution (which is why <code>R</code> is not an outParam). But for <code>OrderHomClass F ?a ?b</code> I am claiming that mathlib is set up so that there is only one solution to that up to defeq, i.e. one choice for ?a, one for ?b, and one for the term of type <code>OrderHomClass F (the right answer) (the right answer)</code>, and the <code>outParam</code> is supposed to be telling the system this. </p>\n<p>Going back to the example I posted above, the trace looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"bp\">üí•</span> <span class=\"n\">RelHomClass</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">‚â§</span> <span class=\"n\">x_1</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">‚â§</span> <span class=\"n\">x_1</span> <span class=\"bp\">‚ñº</span>\n  <span class=\"o\">[]</span> <span class=\"n\">new</span> <span class=\"n\">goal</span> <span class=\"n\">RelHomClass</span> <span class=\"n\">F</span> <span class=\"n\">_tc.2</span> <span class=\"n\">_tc.3</span> <span class=\"bp\">‚ñ∂</span>\n  <span class=\"o\">[]</span> <span class=\"bp\">‚úÖ</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">SupHomClass.toOrderHomClass</span> <span class=\"n\">to</span> <span class=\"n\">RelHomClass</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">‚â§</span> <span class=\"n\">x_1</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">‚â§</span> <span class=\"n\">x_1</span> <span class=\"bp\">‚ñº</span>\n    <span class=\"o\">[</span><span class=\"n\">tryResolve</span><span class=\"o\">]</span> <span class=\"bp\">‚úÖ</span> <span class=\"n\">RelHomClass</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">‚â§</span> <span class=\"n\">x_1</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">‚â§</span> <span class=\"n\">x_1</span> <span class=\"bp\">‚âü</span> <span class=\"n\">RelHomClass</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">‚â§</span> <span class=\"n\">x_1</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">‚â§</span> <span class=\"n\">x_1</span>\n    <span class=\"o\">[]</span> <span class=\"n\">new</span> <span class=\"n\">goal</span> <span class=\"n\">SemilatticeSup</span> <span class=\"n\">_tc.0</span> <span class=\"bp\">‚ñº</span>\n      <span class=\"o\">[</span><span class=\"n\">instances</span><span class=\"o\">]</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">Lattice.toSemilatticeSup</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">semilatticeSup</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">WithBot.semilatticeSup</span><span class=\"o\">,</span> <span class=\"n\">OrderDual.semilatticeSup</span><span class=\"o\">,</span> <span class=\"n\">Prod.semilatticeSup</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">WithTop.semilatticeSup</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and I now understand why the goal has changed from <code>RelHomClass F alpha beta</code> to <code>RelHomClass F _? _?</code> but now it seems that if we want to use <code>SupHomClass.toOrderHomClass</code> (and we do) then there are three typeclass problems to solve, and typeclass inference is solving them in the wrong order (you can see it trying to solve <code>SemilatticeSup _?</code> which is a disaster). What is determining the order in which these things are being solved?</p>",
        "id": 323538907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674666560
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/287929-mathlib4/topic/What.20is.20an.20outParam.3F/near/323538582\">said</a>:</p>\n<blockquote>\n<p>For what it's worth, I believe proper use and propagation of <code>outParams</code> would be far easier to systematically enforce (as in Kevin's</p>\n<blockquote>\n<p>Why doesn't the typeclass inference system immediately abort when faced with the goal SemilatticeSup ?Œ±</p>\n</blockquote>\n<p>) than uniqueness of TC solutions, but this is probably not the time to revise the design of TC inference in such a way...</p>\n</blockquote>\n<p>Aren't things like <a href=\"https://github.com/leanprover/lean4/pull/2003\">lean4#2003</a> precisely redesigning TC inference? And aren't issues like <a href=\"https://github.com/leanprover/lean4/pull/1901\">lean4#1901</a> indicating that they need to be redesigned some more?</p>",
        "id": 323539199,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674666639
    },
    {
        "content": "<p>The first one is not really TC, while the second one is important enough with immediate impact to consider</p>",
        "id": 323539703,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674666760
    },
    {
        "content": "<p>If for example we enforced the handling of outParams and metavariables at the start of TC resolution throughout it as well, that would be a far greater change with unclear repercussions</p>",
        "id": 323540314,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674666917
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/What.20is.20an.20outParam.3F/near/323538907\">said</a>:</p>\n<blockquote>\n<p>What is determining the order in which these things are being solved?</p>\n</blockquote>\n<p>Right now it's simply left-to-right. The second issue you linked considers changing that.</p>",
        "id": 323541489,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674667220
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/287929-mathlib4/topic/What.20is.20an.20outParam.3F/near/323540314\">said</a>:</p>\n<blockquote>\n<p>If for example we enforced the handling of outParams and metavariables at the start of TC resolution throughout it as well, that would be a far greater change with unclear repercussions</p>\n</blockquote>\n<p>Well now I see that 1901 does go in that direction, though not the metavariables part that may be the bigger change and give your \"immediate abort\" semantics</p>",
        "id": 323541809,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674667305
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/287929-mathlib4/topic/What.20is.20an.20outParam.3F/near/323541489\">said</a>:</p>\n<blockquote>\n<p>Right now it's simply left-to-right. The second issue you linked considers changing that.</p>\n</blockquote>\n<p>Aargh! And we can't change the order and write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">SupHomClass.toOrderHomClass</span> <span class=\"o\">[</span><span class=\"n\">SupHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>because <code>SupHomClass F Œ± Œ≤</code> needs the Sup on alpha from <code>SemilatticeSup Œ±</code>!</p>",
        "id": 323544573,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674668001
    },
    {
        "content": "<p>I found an example showing sometimes sensible-looking instances* mean you actually have to search for an instance with metavariables: <a href=\"#narrow/stream/113488-general/topic/Instance.20diamonds.20depending.20on.20.60outParam.60s\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Instance.20diamonds.20depending.20on.20.60outParam.60s</a></p>",
        "id": 323545991,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1674668402
    },
    {
        "content": "<p>(* Sensible here means: it was the logical consequence of the <code>FunLike</code> pattern in the circumstances and it took a lot of thinking to figure out why it wouldn't work.)</p>",
        "id": 323546317,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1674668492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/What.20is.20an.20outParam.3F/near/323544573\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/287929-mathlib4/topic/What.20is.20an.20outParam.3F/near/323541489\">said</a>:</p>\n<blockquote>\n<p>Right now it's simply left-to-right. The second issue you linked considers changing that.</p>\n</blockquote>\n<p>Aargh! And we can't change the order and write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">SupHomClass.toOrderHomClass</span> <span class=\"o\">[</span><span class=\"n\">SupHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>because <code>SupHomClass F Œ± Œ≤</code> needs the Sup on alpha from <code>SemilatticeSup Œ±</code>!</p>\n</blockquote>\n<p>Yes, which is where you would apply the workaround the issue mentioned</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">SupHomClass.toOrderHomClass</span> <span class=\"o\">{</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">SupHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>(untested), which is effectively doing a manual reordering/delaying of subgoals</p>",
        "id": 323547406,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1674668799
    },
    {
        "content": "<p>Aah I now see where these <code>{}</code>s are coming from! Many thanks to all, I've learnt a lot from this. I realised that conversations were happening which I could not be a part of because I hadn't understood the basics, and now I'm in much better shape. Anne yes I rememember that post and I remember at the time just ignoring it because I didn't understand it (because it mentioned outParams).</p>",
        "id": 323550553,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674669666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/287929-mathlib4/topic/What.20is.20an.20outParam.3F/near/323538582\">said</a>:</p>\n<blockquote>\n<p>For what it's worth, I believe proper use and propagation of <code>outParams</code> would be far easier to systematically enforce (as in Kevin's</p>\n</blockquote>\n<p>We do have a linter for that.  And if you follow its advice you should never get a <code>SemilatticeSup ?L</code> subgoal.</p>",
        "id": 323550866,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1674669761
    },
    {
        "content": "<p>Ha yes I had just independently discovered this and came back to post here! I think that yesterday's thread might be another instance of autoported code failing to lint.</p>",
        "id": 323551788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674670019
    },
    {
        "content": "<p>Yeah it is. That's funny, not only has this conversation taught me a great deal but it's also exposed a bug in my workflow. When I'm porting a file I first try to get everything compiling, and then and only then do I lint (in the sense that I push and then CI lints for me). I should be linting earlier: a whole bunch of these early instances in <code>Order.Hom.Lattice</code> are dangerous in Lean 4 (before the problems start).</p>\n<p>Dare I ask why they weren't dangerous in Lean 3?</p>",
        "id": 323553896,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674670613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/287929-mathlib4/topic/What.20is.20an.20outParam.3F/near/323547406\">said</a>:</p>\n<blockquote>\n<p>Yes, which is where you would apply the workaround the issue mentioned</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">SupHomClass.toOrderHomClass</span> <span class=\"o\">{</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">SupHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>(untested), which is effectively doing a manual reordering/delaying of subgoals</p>\n</blockquote>\n<p>This pattern presumably doesn't work if our lemma requires something stronger than <code>SemilatticeSup Œ±</code>, and the stronger something participates in a defeq diamond such that it can no longer be found by unification</p>",
        "id": 323554146,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674670684
    },
    {
        "content": "<p>Unification can call TC synthesis in that case.  It's not ideal because it doesn't participate in the tabled resolution mechanism, etc., but it should work for this.</p>",
        "id": 323555218,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1674670965
    },
    {
        "content": "<p>So for instance, if it requires <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CoFrame#doc\">docs4#CoFrame</a> but the actual application is looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompleteDistribLattice#doc\">docs4#CompleteDistribLattice</a>; the term we have might look like <code>(CompleteDistribLattice.toFrame I).toCompleteLattice.toSemilatticeSup</code> but the one we have available might look like <code>(Coframe.toCompleteLattice _).toSemilatticeSup</code>.</p>",
        "id": 323555288,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674670982
    },
    {
        "content": "<p>So unification uses TC synthesis to produce <code>_ = (CompleteDistribLattice.toCoframe I)</code> there?</p>",
        "id": 323555457,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674671025
    },
    {
        "content": "<p>This is related to why Gabriel uses the term \"bandaid\" in <a href=\"https://github.com/leanprover/lean4/pull/1901\">lean4#1901</a>, presumably?</p>",
        "id": 323555580,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674671055
    },
    {
        "content": "<p>(the picture in my example is that <code>CompleteDistribLattice</code> is at the top of the diamond, <code>Frame</code> and <code>Coframe</code> are at the sides, and <code>CompleteLattice</code> is at the bottom; with arrows going top to bottom)</p>",
        "id": 323555704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674671094
    },
    {
        "content": "<p>Yes, if you unify <code>(Coframe.toCompleteLattice ?inst).toSemilatticeSup</code> with another instance side of the diamond, then Lean will try to fill in <code>?inst</code> using TC synthesis.</p>",
        "id": 323556104,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1674671212
    },
    {
        "content": "<p>Would the following have any drawback?</p>\n<ul>\n<li>First solve from left to right all TC that have outparams</li>\n<li>Then solve from left to right the other ones</li>\n</ul>",
        "id": 323556114,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1674671217
    },
    {
        "content": "<p>This would avoid the workarounds with <code>{...}</code>that are bound to trip many users.</p>",
        "id": 323556420,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1674671300
    },
    {
        "content": "<p>Here's another question: if right now the dangerous instance linter is supposed to flag instances which can yield goals of the form <code>SemilatticeSup _?</code> then why does it not complain about</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"n\">SupHomClass.toOrderHomClass</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">SupHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OrderHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"o\">‚Äπ</span><span class=\"n\">SupHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">‚Ä∫</span> <span class=\"k\">with</span>\n    <span class=\"n\">map_rel</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">sup_eq_right</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">map_sup</span><span class=\"o\">,</span> <span class=\"n\">sup_eq_right.2</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>(the instance which caused all the problems yesterday)?</p>",
        "id": 323556672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674671368
    },
    {
        "content": "<p>Yes, that is the next step here.  (Although you can skip the second step IIUYC, those are already filled in via unification)</p>",
        "id": 323556719,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1674671382
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Is the <code>Œ±</code>/<code>Œ≤</code> in <code>OrderHomClass</code> tagged with <code>outParam</code>?</p>",
        "id": 323556995,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1674671455
    },
    {
        "content": "<p>If you have a repro, I can investigate more.</p>",
        "id": 323557307,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1674671525
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">OrderHomClass</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">RelHomClass</span> <span class=\"n\">F</span> <span class=\"o\">((</span><span class=\"bp\">¬∑</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">¬∑</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"bp\">¬∑</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">¬∑</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Œ≤</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(and RelHomClass also has outParams on everything). But <a href=\"#narrow/stream/287929-mathlib4/topic/Order.2EHom.2ELattice/near/323368211\">as we saw yesterday</a>, this instance was still causing goals of the form <code>SemilatticeSup _?</code>.</p>",
        "id": 323557828,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674671684
    },
    {
        "content": "<p>By a repro, do you mean a mathlib-free one? </p>\n<p>Youch, what does one do here? The linter isn't complaining about the class, but one of the projections.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Hom.Basic</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">SupHomClass</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">HasSup</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasSup</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">FunLike</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Œ≤</span> <span class=\"n\">where</span>\n  <span class=\"n\">map_sup</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">‚äî</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">‚äî</span> <span class=\"n\">f</span> <span class=\"n\">b</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The `dangerousInstance` linter reports:</span>\n<span class=\"cm\">SOME INSTANCES ARE DANGEROUS</span>\n<span class=\"cm\">During type-class search, they produce subgoals like `Group ?M`.</span>\n<span class=\"cm\">Try marking the dangerous arguments as implicit instead. -/</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">SupHomClass.toFunLike</span> <span class=\"c\">/-</span><span class=\"cm\"> generates subgoals with metavariables: argument 4 inst‚úù¬π : HasSup</span>\n<span class=\"cm\">  ?Œ±, argument 5 inst‚úù : HasSup ?Œ≤ -/</span>\n</code></pre></div>\n<p>Here</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">SupHomClass.toFunLike</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">‚Üí</span>\n  <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"bp\">‚Üí</span>\n    <span class=\"o\">{</span><span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">HasSup</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">[</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">HasSup</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">[</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">SupHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">FunLike</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Œ≤</span>\n</code></pre></div>",
        "id": 323558805,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674672010
    },
    {
        "content": "<p>Oh this is precisely <a href=\"https://github.com/leanprover/lean4/pull/1901\">lean4#1901</a> -- I had not read this issue in the past because the <code>outParam</code> always intimidated me.</p>",
        "id": 323561266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674672736
    },
    {
        "content": "<p>Aah, I see; alpha and beta need to be outParams here.</p>",
        "id": 323563344,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674673366
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> suggested <code>@[infer_tc_goals_rl]</code> but the dangerousInstance linter still complains. Is this instance really still dangerous with this attribute <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Hom.Basic</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">SupHomClass</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">HasSup</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasSup</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">FunLike</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Œ≤</span> <span class=\"n\">where</span>\n  <span class=\"n\">map_sup</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">‚äî</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">‚äî</span> <span class=\"n\">f</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">SupBotHomClass</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">HasSup</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasSup</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Bot</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Bot</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">SupHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"n\">where</span>\n  <span class=\"n\">map_bot</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">‚ä•</span> <span class=\"bp\">=</span> <span class=\"bp\">‚ä•</span>\n\n<span class=\"kd\">@[infer_tc_goals_rl]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"n\">OrderIsoClass.toSupBotHomClass</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OrderBot</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OrderBot</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OrderIsoClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">SupBotHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[infer_tc_goals_rl]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"n\">OrderIsoClass.toSupBotHomClass'</span> <span class=\"o\">{</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">OrderBot</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">SemilatticeSup</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">OrderBot</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">OrderIsoClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">SupBotHomClass</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n\n<span class=\"bp\">#</span><span class=\"n\">lint</span> <span class=\"n\">only</span> <span class=\"n\">dangerousInstance</span>\n<span class=\"c\">/-</span><span class=\"cm\"> The `dangerousInstance` linter reports:</span>\n<span class=\"cm\">SOME INSTANCES ARE DANGEROUS</span>\n<span class=\"cm\">During type-class search, they produce subgoals like `Group ?M`.</span>\n<span class=\"cm\">Try marking the dangerous arguments as implicit instead. -/</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">OrderIsoClass.toSupBotHomClass</span> <span class=\"c\">/-</span><span class=\"cm\"> generates subgoals with metavariables: argument 4 inst‚úù‚Å¥ : SemilatticeSup</span>\n<span class=\"cm\">  ?Œ±, argument 6 inst‚úù¬≤ : SemilatticeSup ?Œ≤ -/</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">OrderIsoClass.toSupBotHomClass'</span> <span class=\"c\">/-</span><span class=\"cm\"> unassigned metavariable in out-param: SupBotHomClass F Œ± Œ≤ -/</span>\n</code></pre></div>\n<p>I had guessed that both instances should be fine and that the first is preferable because it's less confusing for the user with the square brackets.</p>",
        "id": 324204487,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674868776
    },
    {
        "content": "<p>The linter doesn't know about the attribute.  As far as I'm concerned the attribute is only there for testing purposes, and should not be used in production.</p>",
        "id": 324204641,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1674868860
    },
    {
        "content": "<p>Possibly relevant definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The class `EquivLike E Œ± Œ≤` expresses that terms of type `E` have an</span>\n<span class=\"sd\">injective coercion to bijections between `Œ±` and `Œ≤`.</span>\n\n<span class=\"sd\">This typeclass is used in the definition of the homomorphism typeclasses,</span>\n<span class=\"sd\">such as `ZeroEquivClass`, `MulEquivClass`, `MonoidEquivClass`, ....</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">class</span> <span class=\"n\">EquivLike</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- The coercion to a function in the forward direction. -/</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span>\n  <span class=\"sd\">/-- The coercion to a function in the backwards direction. -/</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span>\n  <span class=\"sd\">/-- The coercions are left inverses. -/</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">Function.LeftInverse</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- The coercions are right inverses. -/</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">Function.RightInverse</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- If two coercions to functions are jointly injective. -/</span>\n  <span class=\"n\">coe_injective'</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">e</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">coe</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">coe</span> <span class=\"n\">g</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">inv</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">inv</span> <span class=\"n\">g</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>\n  <span class=\"c1\">-- This is mathematically equivalent to either of the coercions to functions being injective, but</span>\n  <span class=\"c1\">-- the `inv` hypothesis makes this easier to prove with `congr'`</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">OrderIsoClass</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">EquivLike</span> <span class=\"n\">F</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- An order isomorphism respects `‚â§`. -/</span>\n  <span class=\"n\">map_le_map_iff</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">‚â§</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">a</span> <span class=\"bp\">‚â§</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>Edit: <span aria-label=\"racecar\" class=\"emoji emoji-1f3ce\" role=\"img\" title=\"racecar\">:racecar:</span></p>",
        "id": 324204655,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674868864
    }
]