[
    {
        "content": "<p>I have a preliminary idea for a simple tool that would help building API for a definition, and I would like to hear other's opinions about whether it would be useful and how best to do it.</p>\n<h3>Example of the issue I want to solve</h3>\n<p>Let say that I defined <code>def foo (a : A) (b : B)</code> where <code>A</code> and <code>B</code> are types with some typeclasses on them. For example <code>A</code> is defined in a <code>variable</code> line and has <code>[AddCommMonoid A]</code> and  <code>B</code> is <code>Measure X</code> for some other type <code>X</code>. Then I add several lemmas. At the time of adding the definition, I have in mind applications in which <code>a</code> changes, but <code>b</code> is a given measure. I think about adding <code>foo_add</code> for <code>foo (a + a') b</code>, and <code>foo_zero_left</code>, perhaps <code>foo_zero_right</code> about <code>b=0</code>. But since I don't think about changing <code>b</code>, which is not something I do in my application, I don't think about adding any lemma about the addition, the order or the lattice structure of <code>Measure X</code>. I also don't think about those because those typeclasses are not readily apparent when I look at the context of my definition: I only see <code>Measure X</code>.<br>\nThen a few months later someone wants to use <code>foo</code> for another application, and they find holes in the API: they would like <code>foo_mono_right</code> stating that foo is monotone for the order on measures.<br>\nThat scenario with measures happened to me recently with <code>Measure.withDensity</code>.</p>\n<h3>Idea for a solution</h3>\n<p>Could we help the person writing the definition by providing suggestions for the API? I am thinking of a command <code>#suggest_api foo</code> that would provide a list of lemma statements with proof <code>sorry</code>.</p>\n<ul>\n<li>If there is a zero in <code>A</code>, it adds  <code>lemma foo_zero_left (b : B) : foo (0 : A) b = sorry := sorry</code></li>\n<li>If there is an addition, it adds <code>lemma foo_add_left (a a' : A) (b : B) : foo (a + a') b = sorry := sorry</code>. Similarly for multiplication.</li>\n<li>It also creates default lemmas for any detected order, or for sup and inf for a lattice. Possibly for more typeclasses as well.</li>\n<li>Do that for all explicit arguments, and ignore implicit arguments?</li>\n<li>If the definition is <code>foo (a a' : A)</code>, we could add a lemma for the case <code>a = a'</code>.</li>\n</ul>\n<p>We could consider going further and if for example there is an order on <code>A</code> and on the type of <code>foo a b</code>, suppose that <code>foo</code> is monotone and create a lemma for that. Suppose that the value at 0 or 1 is 0 or 1 (if those exist), etc.</p>\n<p>The result of the command is a big block of code with many statements, that can be inserted at the point where the command is written.</p>\n<p>It is likely that many of those lemmas are not interesting: perhaps <code>foo</code> does not interact well with addition, or has no special value at 0. But then the user can very simply delete those and keep only the relevant entries.<br>\nThe idea is to create many plausible statements to help the definition creator think about all the API lemmas needed, even if most are not useful: deleting is cheap.</p>\n<p>There is an issue with automatic naming. <code>_left</code> and <code>_right</code> are fine in the example above because there is only two arguments, but that does not work if there are 3. I think getting the names right matters, since newer contributors will tend to think that the auto-generated names follow the naming convention.</p>\n<p>I would like to know if that seems useful. Also I don't currently have the Lean programming knowledge to create that command myself, and I don't think that I will find a time to learn that soon. So this post is also a call to anybody interested: if it looks useful to you, feel free to implement that yourself!<br>\nEven a very simple implementation that does not try to be smart about the lemmas created would already bring most of the benefits.</p>",
        "id": 486768980,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1733663581
    },
    {
        "content": "<p>A small negative of this is that it could waste effort on API nobody will ever use. I don't know how that compares to the inconvenience of missing API</p>",
        "id": 486772339,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1733666531
    },
    {
        "content": "<p>Yes it could waste some effort. But it would not force you to prove any of the suggestions, it would just hint that those might be lemmas you want. If you don't want to spend time on them, you remove them. In my mind, the majority of the suggestions will be simply deleted.</p>\n<p>I just feel like I often have to PR an obvious lemma <code>foo_zero</code> to some definition just because someone (often me) forgot to include it earlier.</p>",
        "id": 486774166,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1733668065
    }
]