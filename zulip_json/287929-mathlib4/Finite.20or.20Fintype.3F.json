[
    {
        "content": "<p>I no longer understand mathlib's policy about stating theorems involving finite types. I've written this in FLT:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">τR</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsModuleTopology</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">pi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsModuleTopology</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>\"The product topology for a finite product of modules with the module topology, is the module topology\". But when I PR this to mathlib am I supposed to be using <code>[Finite ι] </code> or <code>[Fintype ι]</code>? What is the rule? I know that Thomas Browning has been going through finite group theory changing Fintypes to Finites but don't really understand why (I have a preference for Finite because it's Prop-valued so you can't get into a pickle with two instances, but it's only a mild one because I understand how to avoid these problems nowadays).</p>",
        "id": 489463065,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734435045
    },
    {
        "content": "<p>I think <code>Finite</code> is perfectly fine here. Going from <code>Fintype</code> to <code>Finite</code> is possible (without any choice) so this shouldn't harm anything, and in my opinion is closer to the mathematical notion.</p>",
        "id": 489465446,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1734435883
    },
    {
        "content": "<p>If <code>IsModuleTopology </code> is  prop-valued then <code>Finite</code> is certainly the right choice here</p>",
        "id": 489465590,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734435948
    },
    {
        "content": "<p>Yes it's Prop-valued (yay for the <code>Is</code> naming convention). I'm well aware of how to move between <code>Fintype</code> and <code>Finite</code> so my response to Riccardo is \"yes but going from <code>Finite</code> to <code>Fintype</code> is also possible\", and my response to Eric is \"why?\"</p>",
        "id": 489466953,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734436401
    },
    {
        "content": "<p>If you have a <code>Fintype</code> instance, then typeclass inference will also find a <code>Finite</code> instance. If you have a <code>Finite</code> instance, then typeclass inference <em>won't</em> find a <code>Fintype</code> instance, since there is additional data to be produced. So, if you assume <code>Finite</code> in your lemma, it will apply in more situations.</p>",
        "id": 489471613,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1734437849
    },
    {
        "content": "<p>Then why were we using Fintype in 2017? Why do we use Fintype at all?</p>",
        "id": 489472362,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734438128
    },
    {
        "content": "<p>Exactly, it is possible via a choice, in particular it won't be computable.</p>",
        "id": 489472397,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1734438143
    },
    {
        "content": "<p>If you have a <code>Fintype</code> you can use <code>decide</code> (or whatever) to check all the cases, one by one.</p>",
        "id": 489472448,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1734438165
    },
    {
        "content": "<p>I know that, and this is exactly what means that I don't understand why I'm supposed to be using \"Finite\". You were saying \"oh look, with <code>Finite</code> there is an advantage\" and now you're saying \"oh look, with <code>Fintype</code> there is a different advantage\"</p>",
        "id": 489472891,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734438314
    },
    {
        "content": "<p>And because I'm now proficient at moving between them it's got to the point where I don't even care which one I use, so I'm trying to establish what the mathlib convention is and why.</p>",
        "id": 489473072,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734438365
    },
    {
        "content": "<p>I <em>think</em> <code>Fintype</code> is similar to \"Kuratowski finite\", and <code>Finite</code> is \"Dedekind Finite\" (<a href=\"https://en.wikipedia.org/wiki/Finite_set#Necessary_and_sufficient_conditions_for_finiteness\">wiki</a>)</p>",
        "id": 489473085,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1734438371
    },
    {
        "content": "<p>for you those are completely the same because you don't care about computability</p>",
        "id": 489473178,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1734438398
    },
    {
        "content": "<p>Long story short, use <code>Finite</code> unless your statement needs <code>Fintype</code></p>",
        "id": 489474376,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1734438826
    },
    {
        "content": "<p>I'd go a little further than that, the norm on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PiLp#doc\">docs#PiLp</a> is defined with <code>Fintype</code> (which IMO is correct) not because the statement needs <code>Fintype</code>, but because the data within the definition (and the lemma expanding that definition) does.</p>",
        "id": 489476289,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734439439
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20or.20Fintype.3F/near/489474376\">said</a>:</p>\n<blockquote>\n<p>Long story short, use <code>Finite</code> unless your statement needs <code>Fintype</code></p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/10235\">#10235</a> adds a linter (AIUI, porting an analogous mathlib3 linter) for this.</p>\n<p>It's waiting on somebody (e.g. me) finding the time to make the linter fast enough to land. If that's urgent for you, let me know and I prioritise my mathlib time there.</p>",
        "id": 489479895,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1734440396
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20or.20Fintype.3F/near/489472362\">said</a>:</p>\n<blockquote>\n<p>Then why were we using Fintype in 2017? Why do we use Fintype at all?</p>\n</blockquote>\n<p>A strong reason for this is that we didn't have <code>Finite</code> until 2022 :-) <a href=\"https://github.com/leanprover-community/mathlib3/pull/14373\">mathlib3#14373</a></p>\n<p>The port caused a little bit of a disruption to the \"finite-ification\" of mathlib, but I'm happy to see that it's been progressing.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Finite.20or.20Fintype.3F/near/489463065\">said</a>:</p>\n<blockquote>\n<p>I have a preference for Finite because it's Prop-valued so you can't get into a pickle with two instances, but it's only a mild one because I understand how to avoid these problems nowadays</p>\n</blockquote>\n<p>Yes, this was one of the motivations for <code>Finite</code>. Even though the issues are surmountable, when proving theorems it's purely wasted effort.</p>\n<p>Another motivation is that people were tempted to add <code>noncomputable</code> <code>Fintype</code> instances, which defeats the purpose of <code>Fintype</code>, which is that it's supposed to be computable. Now those can safely be <code>Finite</code> instances instead.</p>\n<p>A last main motivation is that moving to <code>Finite</code> tends to mean you can avoid needing any <code>Decidable</code> instances, which also add friction to doing math.</p>\n<p>Re \"yes but going from <code>Finite</code> to <code>Fintype</code> is also possible\": this is exactly like making use of classical decidable instances. It works, but it can cause the usual sorts of problems where you have the 'wrong' instance somewhere. It's easier to stick with <code>Finite</code> and not worry about it.</p>",
        "id": 489554441,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734462571
    },
    {
        "content": "<p>My takeaway from this is \"going forward, use <code>Finite</code>\". So should I also be moving away from <code>Finset.sum</code>?</p>",
        "id": 489555541,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734463010
    },
    {
        "content": "<p>I'm not sure what the current status is there.</p>\n<p>Something I've wanted to see is a <code>FiniteSet</code> type that's bundles a <code>Set</code> and a <code>Set.Finite</code> proof, and then have all the theory be developed for that, and perhaps we could use a <code>FiniteSet.sum</code>. This would be the type you need to comfortably work with the lattice of finite sets, free from any complications from <code>Fintype</code> or <code>DecidableEq</code>.</p>\n<p>At least there's <code>∑'</code> (<code>tsum</code>), which works right now. For infinite domains the fact it deals with convergence could be regarded as a 'junk value' when things do happen to converge.</p>",
        "id": 489556871,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734463475
    },
    {
        "content": "<p>There's something to be said for definitions that don't unnecessarily require additional hypotheses (like finiteness), since there's less chance for DTT hell. A definition like that is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.card#doc\">docs#Nat.card</a>, which doesn't require that the type be finite, eliminating large classes of \"motive not type correct\" errors.</p>",
        "id": 489557713,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734463799
    },
    {
        "content": "<p>There's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finsum#doc\">docs#finsum</a></p>",
        "id": 489930788,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1734604331
    },
    {
        "content": "<p><code>Fintype</code> is useful for computational applications, such as using <code>fin_cases</code>. There's otherwise very little reason to use it.</p>",
        "id": 491997765,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1736110498
    }
]