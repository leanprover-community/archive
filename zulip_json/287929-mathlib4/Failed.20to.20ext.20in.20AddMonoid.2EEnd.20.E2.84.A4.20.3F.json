[
    {
        "content": "<p>Hi!<br>\nI'm writing a prove that the endomorphism ring of ℤ is isomorphic to ℤ.<br>\nSpecifically, I'm aiming to set up an equivalence <code>AddMonoid.End ℤ ≃+* ℤ</code> where:</p>\n<ul>\n<li><code>toFun</code> maps <code>f : AddMonoid.End ℤ</code> to <code>f 1</code></li>\n<li><code>invFun</code> maps an integer n to the endomorphism that sends each integer x to n * x.</li>\n</ul>\n<p>I'm encountering a problem with proving <code>left_inv</code> in my code. The <code>ext</code> tactic fails to work as expected.<br>\nHere's the relevant code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">zEnd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">ℤ</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">l_1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">→+</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">AddMonoidHom</span><span class=\"bp\">.</span><span class=\"n\">apply_int</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">this</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">≃+*</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"w\">  </span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">      </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">      </span><span class=\"n\">map_zero'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">      </span><span class=\"n\">map_add'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">ring</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">l_1</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ext failed</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n\n<span class=\"w\">  </span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n\n<span class=\"w\">  </span><span class=\"n\">map_mul'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">l_1</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">mul_comm</span><span class=\"o\">]</span>\n\n<span class=\"w\">  </span><span class=\"n\">map_add'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Any insights into why ext isn't working in this context, or suggestions on alternative approaches for this proof, would be very helpful. Thanks!</p>",
        "id": 480965927,
        "sender_full_name": "Zhu",
        "timestamp": 1730913316
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/8pH9Yt0k4PFcJ9FMQG4kqLi7/image.png\">image.png</a><br>\nThis is the goal of  <code>left_inv</code> after simp.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/8pH9Yt0k4PFcJ9FMQG4kqLi7/image.png\" title=\"image.png\"><img data-original-dimensions=\"709x205\" src=\"/user_uploads/thumbnail/3121/8pH9Yt0k4PFcJ9FMQG4kqLi7/image.png/840x560.webp\"></a></div>",
        "id": 480966345,
        "sender_full_name": "Zhu",
        "timestamp": 1730913464
    },
    {
        "content": "<p>does <code>AddMonoid.End</code> have an ext lemma?</p>",
        "id": 480967641,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1730913929
    },
    {
        "content": "<p>you could <code>apply AddMonoidHom.ext</code>.</p>",
        "id": 480967696,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1730913948
    },
    {
        "content": "<p>Also, using <code>instance</code> to define this equivalence is not the right approach. <code>instance</code> is used to define instances of type classes.</p>",
        "id": 480967836,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1730913985
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"bp\">.</span><span class=\"n\">End</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>also works for the first sorry.</p>",
        "id": 480970435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730914929
    },
    {
        "content": "<p>Also, I note that the <code>unfold</code> approach is somehow more powerful than <code>apply AddMonoidHom.ext</code> because after unfolding, <code>ext</code> somehow knows that it suffices to check equality after evaluation at <code>1</code> whereas <code>AddMonoidHom.ext</code> still demands that you check equality at all inputs.</p>",
        "id": 480970910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730915131
    },
    {
        "content": "<p>Thanks for the help! I’ve updated the code based on your suggestions, and it’s working now. <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">zEnd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">ℤ</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">l_1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">→+</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">AddMonoidHom</span><span class=\"bp\">.</span><span class=\"n\">apply_int</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">this</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">≃+*</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"w\">  </span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">      </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">      </span><span class=\"n\">map_zero'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">      </span><span class=\"n\">map_add'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">ring</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n\n<span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> old approach</span>\n<span class=\"cm\">    apply AddMonoidHom.ext</span>\n<span class=\"cm\">    simp [mul_comm, ← l_1 f]</span>\n<span class=\"cm\">    -/</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"bp\">.</span><span class=\"n\">End</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n\n\n<span class=\"w\">  </span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> old approach</span>\n<span class=\"cm\">    simp</span>\n<span class=\"cm\">    conv =&gt;</span>\n<span class=\"cm\">      rhs</span>\n<span class=\"cm\">      rw [Eq.symm (Int.mul_one n)]</span>\n<span class=\"cm\">    rfl</span>\n<span class=\"cm\">    -/</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"bp\">.</span><span class=\"n\">End</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n\n\n<span class=\"w\">  </span><span class=\"n\">map_mul'</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">l_1</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">mul_comm</span><span class=\"o\">]</span>\n\n<span class=\"w\">  </span><span class=\"n\">map_add'</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 480971277,
        "sender_full_name": "Zhu",
        "timestamp": 1730915273
    },
    {
        "content": "<p><code>l_1</code> can also be written more concisely using <code>unfold</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">l_1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">AddMonoidHom</span><span class=\"bp\">.</span><span class=\"n\">apply_int</span>\n</code></pre></div>",
        "id": 480972882,
        "sender_full_name": "Zhu",
        "timestamp": 1730915875
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Failed.20to.20ext.20in.20AddMonoid.2EEnd.20.E2.84.A4.20.3F/near/480970435\">said</a>:</p>\n<blockquote>\n<p><code>ext</code> somehow knows that it suffices to check equality after evaluation at <code>1</code></p>\n</blockquote>\n<p>This is probably the difference between <code>ext1</code> and <code>ext</code>. The first applies a single ext lemma, and the second chains them.</p>",
        "id": 480973070,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730915955
    },
    {
        "content": "<p>I would instead think it's a specialized ext lemma that uses the monoid hom structure</p>",
        "id": 480973210,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1730916004
    }
]