[
    {
        "content": "<p>Currently, the cast <code>ℕ → Cardinal</code> is defined as <code>#(Fin n)</code>. I get this is really nice from a mathematical perspective, but is it really useful?</p>",
        "id": 466758885,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725223121
    },
    {
        "content": "<p>What do you suggest?</p>",
        "id": 466759045,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1725223265
    },
    {
        "content": "<p>Well, I'm wondering why not just use the default <code>natCast</code> implementation</p>",
        "id": 466759076,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725223297
    },
    {
        "content": "<p>That way <code>↑0 = 0</code>, <code>↑1 = 1</code>, and <code>↑(n + 1) = ↑n + 1</code> are all def-eq</p>",
        "id": 466759081,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725223320
    },
    {
        "content": "<p><code>#(Fin n) = n</code> can be a <code>simp</code> lemma rather than a definitional equality</p>",
        "id": 466759138,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725223348
    },
    {
        "content": "<p>This is what <code>Ordinal</code> does btw, even though we very well could have had <code>↑n = @type (Fin n) (· &lt; ·)</code></p>",
        "id": 466759189,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725223383
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/mathlib4/pull/6384\">#6384</a></p>",
        "id": 466759272,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1725223459
    },
    {
        "content": "<p>Authored by <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span></p>",
        "id": 466759285,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1725223490
    },
    {
        "content": "<p>Hm yeah, I'm not sure I agree with that rationale</p>",
        "id": 466759496,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725223617
    },
    {
        "content": "<p>I'd argue the main reason to choose one implementation of something like <code>NatCast</code> over another is the def-eqs. After all, all implementations are supposed to be prop-eq anyways.</p>",
        "id": 466760113,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725223810
    },
    {
        "content": "<p><code>#(Fin n)</code> gives us nothing of the sort. The fact <code>Zero</code> and <code>One</code> had to be redefined from what I'd argue are pretty clear canonical definitions <code>#PEmpty</code> and <code>#PUnit</code> just illustrates that further</p>",
        "id": 466760173,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725223854
    },
    {
        "content": "<p>Let's wait for Sébastien.</p>",
        "id": 466763043,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1725225238
    },
    {
        "content": "<p>I don't really remember the details, but for me the main point is that it's a good mathematical definition. The defeq <code>↑(n + 1) = ↑n + 1</code> that you would get from the other definition is in my opinion not something important, for computations you have lemmas, while having a definition that makes sense is much more enlightening. I think it would be a good idea to do the same for ordinals, by the way, I just didn't have time to do it then!</p>",
        "id": 466856731,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1725262498
    },
    {
        "content": "<p>I'd oppose this on ordinals even more. Def-eqs work even nicer on them, since we can define <code>succ x</code> as <code>x + 1</code>. So for instance, <code>succ 2 = 3</code> is currently def-eq.</p>",
        "id": 466888067,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725269296
    },
    {
        "content": "<p>I don't think either definition is any more illuminating than the other, they both satisfy the same theorems. But one is slightly more annoying to work with.</p>",
        "id": 466888878,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725269456
    },
    {
        "content": "<p>Here's the example that prompted me to create this thread. Consider the statement <code>#{a, b, c, d} ≤ 4</code>. By using <code>Cardinal.mk_insert_le</code> repeatedly, you can show <code>#{a, b, c, d} ≤ 1 + 1 + 1 + 1</code>. But because of the nonstandard NatCast, to get from <code>1 + 1 + 1 + 1</code> to <code>4</code> you need to either use <code>Nat.cast_add_one</code> a couple of times or insert <code>norm_cast</code> somewhere.</p>",
        "id": 466890767,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725269806
    },
    {
        "content": "<p>Hypothetically with <code>4</code> def-eq to <code>#(Fin n)</code> you could call <code>Cardinal.mk_le</code> and establish an injection between your set and <code>Fin 4</code>, or something of the sort, but all that seems strictly more convoluted.</p>",
        "id": 466891682,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725270001
    },
    {
        "content": "<p>Having <code>#(Fin n) = n</code> in a defeq way seems to me much more important that defeqs for cardinal arithmetic (which should be handled by norm_num or suitable simp lemmas, definitely not rely on defeq coincidence): <code>Fin n</code> is used in Mathlib as the reference set of cardinality <code>n</code>, so we should make sure that this is reflected in the design choices.</p>",
        "id": 466895203,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1725270765
    },
    {
        "content": "<p>I wouldn't call it \"defeq coincidence\", the default <code>NatCast</code> implementation is pretty deliberate in what def-eqs you get. 0 = ↑0, 1 = ↑1, and ↑(n + 1) = ↑n + 1.</p>",
        "id": 466898937,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725271586
    },
    {
        "content": "<p>If the reasoning is ultimately that \"<code>#(Fin n)</code> is the standard mathematical definition and we got to stick to it\", so be it, but I'll still disagree.</p>",
        "id": 466899212,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725271650
    },
    {
        "content": "<p>I think your feeling is guided by the fact that you're doing a lot of operations on cardinals and ordinals currently, and for this the defeq you're advocating for would be most convenient. But in mathematics, 95% of the time, cardinals are used to compare the size of things, not to do operations on them, so it seems natural to have a definition fitting these 95% of uses.</p>",
        "id": 466914710,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1725275501
    },
    {
        "content": "<p>Alright, I agree with that logic.</p>",
        "id": 467009416,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725298383
    },
    {
        "content": "<p>I've thought about this for a while and I think I do agree that using the default natcast isn't always the best idea. I'll look into redefining the cast for ordinals as <code>type (Fin n)</code></p>",
        "id": 469256982,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726021665
    },
    {
        "content": "<p>And on that note, another weird <code>NatCast</code> instance we have is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SetTheory.PGame.instNatCast#doc\">docs#SetTheory.PGame.instNatCast</a>, which doesn't even agree with the usual definition of natural numbers as pre-games (it yields an <em>equivalent</em> but not an <em>identical</em> game)</p>",
        "id": 469257266,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726021732
    },
    {
        "content": "<p>I'll try and fix that</p>",
        "id": 469257315,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726021741
    },
    {
        "content": "<p>...actually, I'd like to discuss that instance separately</p>",
        "id": 469290251,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726034339
    },
    {
        "content": "<p>Heh, looks like I already had a thread here for it, but I can't edit it anymore</p>",
        "id": 469290380,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726034403
    }
]