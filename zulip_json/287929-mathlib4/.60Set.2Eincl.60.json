[
    {
        "content": "<p>I want to reignite a discussion from a while back (<a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Spelling.20of.20Subtype.2Eval.20in.20LinearIndependent\">#mathlib4 &gt; Spelling of Subtype.val in LinearIndependent</a>), and argue that the following suggestion of <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  should be added to mathlib. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">incl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">â†‘</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The spelling <code>((â†‘) : s â†’ Î±)</code> doesn't seem so bad, until <code>s</code> and <code>Î±</code> get complicated, when it begins to be very unwieldy. For instance, I just found myself writing <code>((â†‘) : (insert f (v '' B) : Set W) â†’ W)</code>; this doesn't parse correctly without the inner coercion. </p>\n<p><code>incl</code> is also useful as something to refer to in lemma names. </p>\n<p>For me, the applications where the absence of this is making things difficult are in linear algebra, when considering linear independence/dependence for subsets of the indices. Of course arbitrary indexing types are correct for the definition of <code>LinearIndependent</code>, but manipulating linear independence for explicit sets of vectors is also useful, and <br>\nbeing able to say <code>LinearIndependent ğ”½ (insert f (v '' B)).incl</code>would be so much nicer than <code>LinearIndependent ğ”½ ((â†‘) : (insert f (v '' B) : Set W) â†’ W)</code>. That's only the case where <code>W</code> is a single-letter type.</p>",
        "id": 496396592,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738088019
    },
    {
        "content": "<p>Could you phrase these examples as <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> s?</p>",
        "id": 496413639,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738094004
    },
    {
        "content": "<p>Here is an example with set differences. It's not that anything is broken - it's just that the second version is so much better than the first, even when the type doesn't have a long name. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">LinearIndependent</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">LongNameType</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">LongNameType</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"n\">LongNameType</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">LongNameType</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"bp\">.</span><span class=\"n\">diff_index</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hli</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">â†‘</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">LongNameType</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">â†‘</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">LongNameType</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">LongNameType</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">incl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">â†‘</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"bp\">.</span><span class=\"n\">diff_index_better</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hli</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">incl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">incl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 496415278,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738094651
    },
    {
        "content": "<p>An alternative option here would be to define <code>LinearIndependentSet</code></p>",
        "id": 496415889,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738094937
    },
    {
        "content": "<p>Which matches (edit: the old names of) <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SupIndep#doc\">docs#SupIndep</a> vs <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=iSupIndep#doc\">docs#iSupIndep</a></p>",
        "id": 496415919,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738094952
    },
    {
        "content": "<p>I like that.</p>",
        "id": 496415920,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738094952
    },
    {
        "content": "<p>But for the particular example above, you can also write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"bp\">.</span><span class=\"n\">diff_index_better2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hli</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î¹</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î¹</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">â†¥</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>which doesn't mention <code>LongTypeName</code> at all</p>",
        "id": 496419611,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738096520
    },
    {
        "content": "<p>(and this really is better than <code>.diff_index</code>, as it actually shows the set in question when you hover over the lemma)</p>",
        "id": 496419689,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738096556
    },
    {
        "content": "<p>But I could be persuaded by <code>iLinearIndependent</code> and <code>LinearIndependent</code> as there's precedent elsewhere</p>",
        "id": 496419821,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738096609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60Set.2Eincl.60/near/496415889\">said</a>:</p>\n<blockquote>\n<p>An alternative option here would be to define <code>LinearIndependentSet</code></p>\n</blockquote>\n<p>Generally, mathlib predicates that only exist in either the set or indexed family version are painful to use.</p>",
        "id": 496436699,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1738104193
    },
    {
        "content": "<p>That's a vote in favor of that suggestion (modulo renaming) then?</p>",
        "id": 496437697,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738104825
    },
    {
        "content": "<p>(also please please use <code>Indep</code> instead of <code>Independent</code>, the current name is a pain to write for no gain in clarity, and other parts of mathlib already use <code>Indep</code>, eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=iSupIndep#doc\">docs#iSupIndep</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.IndepFun#doc\">docs#ProbabilityTheory.IndepFun</a> and around)</p>",
        "id": 496437947,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1738104970
    },
    {
        "content": "<p>Does the naming guide allow <code>iSupIndep</code> / <code>iIndepFun</code> / <code>iLinearIndep</code>?</p>",
        "id": 496438142,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738105104
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 496438165,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738105121
    },
    {
        "content": "<p>I defined an abbrev <code>Set.AlgebraicIndependent</code> in a local branch so maybe you can name it <code>Set.LinearIndependent</code>. If you want to name it <code>Set.LinearIndep</code> or even <code>Set.LinIndep</code>, maybe first rename <code>LinearIndependent</code>?<br>\nBy the way, I think you also get a matroid over <code>DivisionRing</code>s, not just <code>Field</code>s.</p>",
        "id": 496443626,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738108163
    },
    {
        "content": "<p>Here's another annoying example, that isn't directly solved by a predicate on sets. The internal coercion and <code>fun</code> notation is still awkward, and I really don't want to have to type <code>â†¥</code> regularly in code.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">LinearIndependent</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î¹</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Î¹</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î¹</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"bp\">.</span><span class=\"n\">diff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Î¹</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">incl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">â†‘</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"bp\">.</span><span class=\"n\">diff_incl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">âˆ˜</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">incl</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">âˆ˜</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">incl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 496449297,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738111555
    },
    {
        "content": "<p>Maybe <code>LinearIndependentOn ğ”½ v s</code> would make sense?</p>",
        "id": 496449567,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738111749
    },
    {
        "content": "<p>I'm not sure we want that lemma to exist at all; the proof is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"bp\">.</span><span class=\"n\">diff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">ğ”½</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">â†¥</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">inclusion_injective</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">diff_subset</span>\n</code></pre></div>\n<p>and of course generalizes to every subset relation that exists</p>",
        "id": 496450453,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738112321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Set.2Eincl.60/near/496449297\">said</a>:</p>\n<blockquote>\n<p>and I really don't want to have to type <code>â†¥</code> regularly in code.</p>\n</blockquote>\n<p>We could consider making the abbreviation easier to type.</p>",
        "id": 496450502,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738112364
    },
    {
        "content": "<p>You can also write <code>(fun x : (s \\ t :) â†¦ v x)</code> instead, but it's less clear</p>",
        "id": 496450524,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738112382
    },
    {
        "content": "<p>And <code>â†¥</code> is unclear as well. When I was starting out, <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> described that symbol to me as something only for the infoview, rather than a preferred spelling in actual typed code.</p>",
        "id": 496450655,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738112443
    },
    {
        "content": "<p><code>â†¥</code> at least has a hover docstring that is relevant, unlike <code>:)</code> which does not</p>",
        "id": 496450732,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738112494
    },
    {
        "content": "<p>Yes, I'm happy to agree that <code>:)</code> is worse.</p>",
        "id": 496450750,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738112512
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, do you think it would be sensible to make set / lattice operators elaborate without an expected type if they see that the expected type is <code>Type</code>? Then we wouldn't need either annotation here.</p>",
        "id": 496451087,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738112638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Set.2Eincl.60/near/496449567\">said</a>:</p>\n<blockquote>\n<p>Maybe <code>LinearIndependentOn ğ”½ v s</code> would make sense?</p>\n</blockquote>\n<p>This indeed solves the problem, but is a third API that has to be written, and I'm not sure if it carries its weight.</p>",
        "id": 496451512,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738112886
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Set.2Eincl.60/near/496450732\">said</a>:</p>\n<blockquote>\n<p><code>â†¥</code> at least has a hover docstring that is relevant, unlike <code>:)</code> which does not</p>\n</blockquote>\n<p>What do you mean? I get (in the web editor)</p>\n<blockquote>\n<p>Type ascription notation:Â <code>(0 : Int)</code>Â instructs Lean to processÂ <code>0</code>Â as a value of typeÂ <code>Int</code>. An empty type ascriptionÂ <code>(e :)</code>Â elaboratesÂ <code>e</code>Â without the expected type. This is occasionally useful when Lean's heuristics for filling arguments from the expected type do not yield the right result.</p>\n</blockquote>\n<p>Do you see something diferent?</p>",
        "id": 496454629,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1738115118
    },
    {
        "content": "<p>(Edit: whoops, misunderstood something, please ignore)</p>\n<p>Here's a <code>Set.incl</code> proposal <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span>:</p>\n<ul>\n<li>Currently the coercion is defined at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Notation.instCoeHeadElem#doc\">docs#Set.Notation.instCoeHeadElem</a></li>\n<li>It is defined as <code>Subtype.val '' s</code></li>\n<li>We can define a specific <code>Set.incl</code> function to use for this coercion instead. The definition should be an abbreviation that <code>Set.incl s</code> is <code>Subtype.val '' s</code>.</li>\n<li>Then we need to make sure we use <code>Set.incl</code> instead of <code>Subtype.val '' .</code> everywhere, for consistency.</li>\n<li>We should also then take a look its adjoint in <code>Mathlib/Data/Set/Subset.lean</code> to make sure the theorems make sense.</li>\n</ul>\n<p>A counterpoint to this proposal is \"Writing <code>Subtype.val '' s</code> isn't so much worse than <code>Set.incl s</code>\" (you don't need to be using <code>â†‘</code> notation, and <code>Subtype.val '' s</code> is more likely to work without type ascriptions). However, perhaps one might argue it's nice having a <code>Set.incl</code> function that avoids exposing the fact that the <code>Set</code>-to-type coercion is <code>Subtype</code>.</p>",
        "id": 496466579,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738123237
    },
    {
        "content": "<p><code>Subtype.val '' s</code> is a set, and therefore has a different type than <code>Set.incl s</code>... are sure you found the right instance?</p>",
        "id": 496488937,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1738137520
    },
    {
        "content": "<p>Looking into it, that coercion only turns elements of <code>Set s</code> into <code>Set a</code> where <code>s : Set a</code>. That is not what <code>Set.incl</code> is proposed to do, though</p>",
        "id": 496489625,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1738137816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">YaÃ«l Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Set.2Eincl.60/near/496437947\">said</a>:</p>\n<blockquote>\n<p>(also please please use <code>Indep</code> instead of <code>Independent</code>, the current name is a pain to write for no gain in clarity, and other parts of mathlib already use <code>Indep</code>, eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=iSupIndep#doc\">docs#iSupIndep</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.IndepFun#doc\">docs#ProbabilityTheory.IndepFun</a> and around)</p>\n</blockquote>\n<p>I would vote against this -- this attitude is why we ended up with <code>Doset</code> -- what could be clearer than the English word?</p>",
        "id": 496504802,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738143323
    },
    {
        "content": "<p>Kevin, would you argue we should instead rename SupIndep and IndepFun?</p>",
        "id": 496507509,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738144173
    },
    {
        "content": "<p>I think consistency of abbreviation is important here</p>",
        "id": 496507557,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738144190
    },
    {
        "content": "<p>I think I'm less averse to long names than others here but that would be my personal instinct.</p>",
        "id": 496508120,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738144343
    },
    {
        "content": "<p>I've created a poll at <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Indep.20vs.20Independent/near/496508710\">#mathlib4 &gt; Indep vs Independent @ ğŸ’¬</a></p>",
        "id": 496508905,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738144581
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Set.2Eincl.60/near/496466579\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Then we need to make sure we use <code>Set.incl</code> instead of <code>Subtype.val '' .</code> everywhere, for consistency.</li>\n</ul>\n</blockquote>\n<p>Not \"everywhere\", only places that about <code>Set.Elem</code> rather than <code>Subtype</code>. But now we need two copies of every lemma, one for set-subtypes and one for every-other-subtype (otherwise how do we decide whether to call them <code>incl</code> or <code>subtypeVal</code> in the name?)</p>",
        "id": 496509540,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738144782
    },
    {
        "content": "<p>But I think as <span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> points out, you're not describing the same function that Peter is</p>",
        "id": 496509781,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738144841
    },
    {
        "content": "<p>I donâ€™t think it would need two copies of every lemma, just in places where this stuff is an impediment to things being easy to read and work with. Itâ€™s an abbrev, so this wonâ€™t disempower any of the existing API.</p>\n<p>Also, the inclusion map from a set to its type is an actual mathematical object, and â€˜inclusionâ€™ is the word we use to describe it. I donâ€™t agree with the attitude that it doesnâ€™t need a name in mathlib because we can express it with arrows. We can also express subtraction without its own symbol and name.</p>",
        "id": 496526440,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738150199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60Set.2Eincl.60/near/496504802\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">YaÃ«l Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Set.2Eincl.60/near/496437947\">said</a>:</p>\n<blockquote>\n<p>(also please please use <code>Indep</code> instead of <code>Independent</code>, the current name is a pain to write for no gain in clarity, and other parts of mathlib already use <code>Indep</code>, eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=iSupIndep#doc\">docs#iSupIndep</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.IndepFun#doc\">docs#ProbabilityTheory.IndepFun</a> and around)</p>\n</blockquote>\n<p>I would vote against this -- this attitude is why we ended up with <code>Doset</code> -- what could be clearer than the English word?</p>\n</blockquote>\n<p>I am only pushing for abbreviations that are standard, eg that people could write on a board during a chalktalk to save some time</p>",
        "id": 496558518,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1738160236
    },
    {
        "content": "<p>There's not a lot of words that start with \"indep\" (indeprivable?) so the meaning is clear, particularly when combined with \"linear\". Whereas \"doset\" takes two syllables from two different words, neither of which accurately represents their respective words.</p>",
        "id": 496643281,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1738184813
    },
    {
        "content": "<p>Clarity is certainly more important than verboseness, but here I don't think there's any tradeoff being made.</p>",
        "id": 496643528,
        "sender_full_name": "Violeta HernÃ¡ndez",
        "timestamp": 1738184937
    },
    {
        "content": "<p>I've just made a PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/21520\">#21520</a>) that adds some lemmas about linear independence for sets of indices. I've used the spelling <code>LinearIndependent R (s.restrict f)</code> to say that the vectors <code>{f i : i in s}</code> for a set <code>s</code> are linearly independent. <br>\n(Note that <code>LinearIndependent R (f '' s)</code> isn't the same thing, so can't be a substitute). Here is an example of a lemma from the PR. (<span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> , I don't think this can be discounted as having a one-line proof).  </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">linearIndependent_restrict_union</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">Î¹</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Î¹</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î¹</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">restrict</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ht</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">restrict</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hdj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">restrict</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I don't love the <code>restrict</code> spelling, mainly because <code>f.restrict s</code> would read better than <code>s.restrict f</code>. But I think this spelling is more readable than <code>fun x : s â†¦ f x</code> or similar, which requires mentally erasing the <code>x</code>s and arrows from the actually relevant <code>s</code> and <code>f</code> every time you look at it. It also requires the ugly â†¥ symbol or lots of brackets if the set <code>s</code> is a more complicated expression. </p>\n<p>A secondary concern is that there isn't an obvious English word/phrase to include in names to indicate that a lemma is about <code>fun x : s â†¦ f x</code>. 'index' is used in some places, but this word is quite generic-sounding.  For <code>f.restrict s</code>, at least the word 'restrict' will do the job, as it has in my PR. </p>\n<p>I would like a better solution, since I think set-theoretic reasoning about indices and linear independence is important enough to be made ergonomic. Here is a suggestion for some notation. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">notation</span><span class=\"o\">:</span><span class=\"mi\">65</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"mi\">65</span><span class=\"w\"> </span><span class=\"s2\">\" â†¾ \"</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"mi\">66</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">â†¥</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">linearIndependent_restrict_union</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">Î¹</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Î¹</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î¹</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">â†¾</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ht</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">â†¾</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hdj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">â†¾</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 498193373,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738869274
    },
    {
        "content": "<p>I'm not really sold on <code>restrict</code> being a good idea here: I think we almost always want the function argument to <code>LinearIndependent</code> to be eta-expanded (as this allows more lemmas to apply), and at that point, <code>restrict</code> is not the simp-normal form.</p>",
        "id": 498194343,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738869663
    },
    {
        "content": "<p>So what is a good idea? (Note that my proposed notation doesn't refer to <code>restrict</code> - I don't know if that makes a difference to your point)</p>",
        "id": 498194522,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738869726
    },
    {
        "content": "<p>The notation indeed avoids that specific concern, though we already have three other uses of that notation in mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- from #find_syntax \"â†¾\"</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.Â«</span><span class=\"n\">term</span><span class=\"bp\">â†¾_Â»</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Matroid</span><span class=\"bp\">.Â«</span><span class=\"n\">term_</span><span class=\"bp\">â†¾_Â»</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"bp\">.Â«</span><span class=\"n\">term</span><span class=\"bp\">â†¾_Â»</span>\n</code></pre></div>",
        "id": 498196138,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738870251
    },
    {
        "content": "<p>What about this one? <code>â‡‚</code></p>",
        "id": 498196743,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738870459
    },
    {
        "content": "<p>I'll let someone else weight in on how many unicode arrows is too many arrows.</p>",
        "id": 498196855,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738870515
    },
    {
        "content": "<p>Fair enough. I would just be happy with pretty much any standard spelling over <code>fun x : s â†¦ f x</code> and all its issues.</p>",
        "id": 498197404,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738870719
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Set.2Eincl.60/near/498193373\">said</a>:</p>\n<blockquote>\n<p>@Eric Wieser , I don't think this can be discounted as having a one-line proof</p>\n</blockquote>\n<p>In this case I agree that the lemma should exist in some form, but it should be phrased in the same way as the existing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=linearIndependent_insert%27#doc\">docs#linearIndependent_insert'</a>. If we're going to redesign the API in the file, it would be best to do it separately from adding new mathematical results, and we should apply it to all the existing lemmas too.</p>",
        "id": 498199123,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738871463
    },
    {
        "content": "<p>I think that  <code>linearIndependent_insert'</code> and <code>linearIndependent_image</code> + variants are the only lemmas of that form. I could rephrase them as part of the PR, but I wouldn't call this an API redesign. </p>\n<p>The PR is addressing an almost complete lack of API in this regard <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 498199645,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1738871665
    },
    {
        "content": "<p>It would be nice to have some wider input on the spelling issues here - we've certainly heard my opinions and  <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>'s, and this needs to be resolved before linearly representable matroids make it into mathlib.</p>\n<p>To summarize, here are three options for stating the same lemma - <a href=\"https://github.com/leanprover-community/mathlib4/pull/21520\">#21520</a> contains many analogous lemmas for which the same kind of options apply. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">Î¹</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î¹</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Î¹</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î¹</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n\n<span class=\"c1\">-- Option 1</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">linearIndependent_union_index</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ht</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hdj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">â†¥</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- Option 2</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">linearIndependent_restrict_union</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">restrict</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ht</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">restrict</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hdj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">restrict</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">notation</span><span class=\"o\">:</span><span class=\"mi\">65</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"mi\">65</span><span class=\"w\"> </span><span class=\"s2\">\" â‡‚ \"</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"mi\">66</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">â†¥</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"c1\">-- Option 3</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">linearIndependent_restrict_union'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">â‡‚</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ht</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">â‡‚</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hdj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">â‡‚</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Option 1 is the status quo naming/notational convention, but this applies to only about 3 lemmas currrently in mathlib. I think that both the naming and the notation for this option is unintuitive. But Eric has voiced issues with Option 2. It would be good to have some kind of broader consensus.</p>",
        "id": 498501253,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1739020520
    },
    {
        "content": "<p>I originally liked option 2 (or having both 1 and 2), but after seeing Eric's concerns with it I agree with them. I'll paste them here for visibility:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">don't</span><span class=\"w\"> </span><span class=\"n\">think</span><span class=\"w\"> </span><span class=\"n\">we</span><span class=\"w\"> </span><span class=\"n\">want</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">restate</span><span class=\"w\"> </span><span class=\"n\">every</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">restrict</span><span class=\"w\"> </span><span class=\"n\">folded</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">unfolded</span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">If</span><span class=\"w\"> </span><span class=\"n\">we</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">want</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">pursue</span><span class=\"w\"> </span><span class=\"n\">restrict</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">we</span><span class=\"w\"> </span><span class=\"n\">probably</span><span class=\"w\"> </span><span class=\"n\">should</span><span class=\"w\"> </span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"n\">rather</span><span class=\"w\"> </span><span class=\"n\">than</span><span class=\"w\"> </span><span class=\"n\">duplicate</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">existing</span><span class=\"w\"> </span><span class=\"n\">lemmas</span><span class=\"bp\">.</span>\n\n<span class=\"n\">An</span><span class=\"w\"> </span><span class=\"n\">argument</span><span class=\"w\"> </span><span class=\"n\">against</span><span class=\"w\"> </span><span class=\"n\">trying</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">restrict</span><span class=\"w\"> </span><span class=\"n\">everywhere</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">doesn't</span><span class=\"w\"> </span><span class=\"n\">work</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">things</span><span class=\"w\"> </span><span class=\"n\">like</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LinearIndependent</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">â†¥</span><span class=\"o\">(</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"n\">we</span><span class=\"w\"> </span><span class=\"n\">want</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">restrict</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">which</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">probably</span><span class=\"w\"> </span><span class=\"n\">harder</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">simplify</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>In my view the notation idea is nice, since this operation does show up quite often.</p>",
        "id": 499272913,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739376676
    },
    {
        "content": "<p>Working with subsets like this (rather than types) is slightly different to the proven path in Mathlib. I presume that there's no way you could use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearIndependent.sum_type#doc\">docs#LinearIndependent.sum_type</a> instead?</p>",
        "id": 499284582,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1739379821
    },
    {
        "content": "<p>I also note that your goals might be setting someone up for DTT hell since they create a term whose type depends on data. If you persist in this approach, a possible solution would be to add <code>(u : Set Î¹) (hu : u = s âˆª t)</code> and make statements about <code>u</code>.</p>",
        "id": 499285078,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1739379953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Set.2Eincl.60/near/499284582\">said</a>:</p>\n<blockquote>\n<p>Working with subsets like this (rather than types) is slightly different to the proven path in Mathlib. I presume that there's no way you could use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearIndependent.sum_type#doc\">docs#LinearIndependent.sum_type</a> instead?</p>\n</blockquote>\n<p>The proven path you're talking about makes sense for the algebraic hierarchy, but non-injective vector-valued functions do arise in combinatorics, and you  really need to nontrivially reason about interrelated subsets of the domain. Approaches where you have to move back and forth between each set <code>s</code> and the associated subtype will work at the scale of API lemmas, but will scale very badly. Think of using the above lemma twice to apply to three sets <code>s</code>,<code>t</code> and <code>r</code>, for example. </p>\n<p>On your second point, I don't think I understand what the examples where DTT hell would arise would actually look like. Could you elaborate?</p>",
        "id": 499288740,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1739380981
    },
    {
        "content": "<p>I think I would have to study an specific an example to appreciate the point you're making about why not to follow the proven path.</p>\n<p>The DTT hell point is easier though. For example the following will not even typecheck:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">restrict</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">restrict</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>",
        "id": 499290899,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1739381611
    },
    {
        "content": "<p>Do we have the option of having two versions of LinearIndependent: one for indexed families and one for sets? The difficulty in this thread seems to be from using the indexed family version for operations which are natural in the set context. There's also already precedent for having two versions in this way, eg sSup vs iSup.</p>",
        "id": 499303887,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739385791
    },
    {
        "content": "<p>there are lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/LinearIndependent.html#linearIndependent_subtype_range\">linearIndependent_subtype_range</a> for doing some basic set things</p>",
        "id": 499304233,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739385905
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Set.2Eincl.60/near/499290899\">said</a>:</p>\n<blockquote>\n<p>I think I would have to study an specific an example to appreciate the point you're making about why not to follow the proven path.</p>\n<p>The DTT hell point is easier though. For example the following will not even typecheck:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">restrict</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">âˆª</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">restrict</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Ah right, I see that. I don't know a way around this, though. </p>\n<p>The example is linear matroids. A matroid (which you can think of as a predicate <code>Indep : Set a - &gt; Prop</code> for a type <code>a</code> with certain properties) is linearly representable if there is a function <code>f : a -&gt; V</code> for a vector space <code>V</code> such that <code>Indep s &lt;-&gt; LinearIndep (s.restrict f)</code> for each set <code>s</code>. </p>\n<p>Matroid reasoning is all happening in <code>Set a</code>, and involves unions, intersections, insertions, differences, subsets, and other operations involving both elements and sets. See <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Matroid/Basic.html#Matroid.Basis.mem_of_insert_indep\">the <code>Matroid.Indep</code> section in mathlib</a> for examples. </p>\n<p>All the API for linear matroid representations is relating properties in the matroid world to ones in linear algebra - <code>Matroid.Indep</code> corresponds (by construction) to <code>LinearIndep</code>, but also <code>Matroid.Basis</code> corresponds to <code>Basis</code>, <code>Matroid.closure</code> corresponds to <code>Submodule.Span</code>, etc. See <a href=\"https://github.com/apnelson1/Matroid/blob/main/Matroid/Representation/Basic.lean\">the representation section of my repo</a> for examples in development. </p>\n<p>I don't know how to express these ideas without talking (a lot) about linear independence of functions out of sets coerced to subtypes. And this kind of thing is a necessary first step for all the <a href=\"https://arxiv.org/pdf/2211.05724\">recent breakthrough results</a> in the relationship between matroids and algebraic geometry.</p>",
        "id": 499305038,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1739386171
    },
    {
        "content": "<p><code>LinearIndepOn</code> would indeed solve the dtt hell issue (or at least, hide it within the API)</p>",
        "id": 499306046,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739386557
    },
    {
        "content": "<p>Thinking about this more, a useful comparison here might be to lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=continuousOn_iff_continuous_restrict#doc\">docs#continuousOn_iff_continuous_restrict</a>. <code>Set.restrict</code> has the same DTT problems as described here, but lemmas like this one and the api for ContinuousOn mean that this isn't really an issue. Indeed I think definitions like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousOn#doc\">docs#ContinuousOn</a> are evidence that working on subsets isn't so far off the beaten path in an analysis context.</p>",
        "id": 499306226,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739386623
    },
    {
        "content": "<p>(It's worth remarking that this issue is unrelated to the 'embedded ground set' design of matroids that has also seen much discussion for going against the mathlib grain)</p>",
        "id": 499306272,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1739386640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Set.2Eincl.60/near/499306226\">said</a>:</p>\n<blockquote>\n<p>Indeed I think definitions like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousOn#doc\">docs#ContinuousOn</a> are evidence that working on subsets isn't so far off the beaten path in an analysis context.</p>\n</blockquote>\n<p>Indeed, <code>ContinuousOn</code> is (a large part of) the way we solved DTT problems in developing the continuous functional calculus, where the natural homomorphism has domain the continuous functions on a subset of <code>â„‚</code>(coerced to a type).</p>",
        "id": 499307998,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1739387239
    },
    {
        "content": "<p>My preference is to go with this option then: adding LinearIndepOn.<br>\nPros: </p>\n<ul>\n<li>It's consistent with foundational definitions in mathlib such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.InjOn#doc\">docs#Set.InjOn</a> as well as commonly used ones like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousOn#doc\">docs#ContinuousOn</a></li>\n<li>It avoids the DTT problems without compromising on usability in practice</li>\n<li>It allows us to be more expressive when working with restricting the domain</li>\n<li>We can avoid having a new arrow</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>We have a new definition which requires its own API</li>\n<li>Any others?</li>\n</ul>",
        "id": 499308664,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739387473
    },
    {
        "content": "<p>I'm all for it (as previously stated in the previous thread)</p>",
        "id": 499311363,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1739388246
    },
    {
        "content": "<p>I don't think the API con is even too much of a con, since the lemmas need to be there in some form anyway. The only difference is one extra definition.</p>",
        "id": 499311838,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1739388403
    },
    {
        "content": "<p>And thanks <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> for pointing out the obvious DTT issues with my suggestions.</p>",
        "id": 499311963,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1739388439
    },
    {
        "content": "<p>(Previous discussion is earlier in this thread: <a href=\"#narrow/channel/287929-mathlib4/topic/.60Set.2Eincl.60/near/496415889\">#mathlib4 &gt; &#96;Set.incl&#96; @ ğŸ’¬</a>)</p>",
        "id": 499312770,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739388680
    },
    {
        "content": "<p>I'm happy enough about this to work on a PR. The <code>LinearIndependent</code> file is already on the long side - would it make sense to move the existing file to <code>LinearAlgebra.LinearIndependent.Basic</code> and all the set-related things to <code>LinearAlgebra.LinearIndependent.Set</code>? (There is already quite a lot of API for sets of vectors)</p>",
        "id": 499315054,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1739389393
    },
    {
        "content": "<p>I would hope there's a better split available than set vs indexed family, but haven't thought very much about it</p>",
        "id": 499320003,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1739391134
    },
    {
        "content": "<p>I think this split would be good. It is currently quite hard to tell at a glance which <code>LinearIndependent</code> lemmas apply to sets and which don't, and the dependencies are all in the right direction.</p>",
        "id": 499321044,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1739391529
    },
    {
        "content": "<p>That said, I'd be happier to leave a split to others if adding a new definition and a dozen lemmas to a 1700-line file is ok.</p>",
        "id": 499321826,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1739391789
    },
    {
        "content": "<p>My main concern is this not being held up.</p>",
        "id": 499322024,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1739391852
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60Set.2Eincl.60/near/499321826\">said</a>:</p>\n<blockquote>\n<p>I'd be happier to leave a split to others if adding a new definition and a dozen lemmas to a 1700-line file is ok.</p>\n</blockquote>\n<p>It's okay by me, at least</p>",
        "id": 499333338,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1739396291
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/21799\">#21799</a> - this basically just adds the definition and the simplest of API lemmas.</p>",
        "id": 499357583,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1739408630
    },
    {
        "content": "<p>One question is whether <code>LinearIndependentOn R id s</code> becomes the spelling for linear independence of <code>s : Set V</code>. I don't know if this improves the current situation.</p>",
        "id": 499357736,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1739408720
    },
    {
        "content": "<p>I prefer this, particularly because the current version shows up in the docs as <code>LinearIndependent R Subtype.val</code>, and it's not nearly as clear what the set in question is. For instance <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=linearIndependent_finset_map_embedding_subtype#doc\">docs#linearIndependent_finset_map_embedding_subtype</a> would make some more sense in the documentation.</p>",
        "id": 499359334,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739409726
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/21866\">#21866</a> is a refactor to use <code>LinearIndepOn</code> spellings everywhere. </p>\n<p><a class=\"stream-topic\" data-stream-id=\"144837\" href=\"/#narrow/channel/144837-PR-reviews/topic/.2321886.20LinearIndepOn.20refactor/with/500527995\">#PR reviews &gt; #21886 LinearIndepOn refactor</a></p>",
        "id": 500528262,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1739920363
    }
]