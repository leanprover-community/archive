[
    {
        "content": "<p>The main construction for sheafification in mathlib right now is via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.instHasSheafifyOfPreservesLimitsForgetOfHasFiniteLimitsOfSmallOppositeCover#doc\">docs#CategoryTheory.instHasSheafifyOfPreservesLimitsForgetOfHasFiniteLimitsOfSmallOppositeCover</a> (the plus-plus construction). In practice, as far as I can tell, this has only ever been applied in (essentially) small categories, where all the necessary limits and colimits always exist.</p>\n<p>If we have a big category though, sheafification will in general not exist, but I think we can do slightly better than what we currently have. The main conditions of the above lemma are (here <code>J</code> is a Grothendieck topology on the category <code>C : Type (u + 1)</code> (with say <code>[Category.{u} C]</code>):</p>\n<ol>\n<li>for every <code>X</code>, various colimits of shape <code>(J.Cover X)ᵒᵖ</code> must exist and be preserved by suitable functors.</li>\n<li><code>∀ (P : Functor Cᵒᵖ (Type u)) (X : C) (S : J.Cover X), Limits.HasMultiequalizer (S.index P)</code></li>\n</ol>\n<p>Now let's suppose <code>J</code> is generated by a pretopology <code>K</code>. Then one can define similar categories <code>K.Cover X</code> (with a suitable preorder that is not the one coming from inclusion of presieves!) and there is an obvious initial functor <code>K.Cover X ⥤ J.Cover X</code>.</p>\n<p>Let's now suppose the categories <code>K.Cover X</code> are all (essentially) small and for every <code>X</code> and <code>R</code> a covering presieve of <code>X</code> wrt. to <code>K</code>, <code>R</code> is<code>u</code>-small. Then condition</p>\n<ol>\n<li>\n<p>is satisfied, because via the initial functor <code>K.Cover X ⥤ J.Cover X</code> we can check things on <code>K.Cover X</code> which is (essentially) small.</p>\n</li>\n<li>\n<p>is harder: If <code>S : Sieve X</code> and <code>R : Presieve X</code> with <code>S = Sieve.generate R</code>, then <code>HasMultiequalizer (R.index P)</code> implies <code>HasMultiequalizer (S.index P)</code>. But the sieves of <code>J = K.toGrothendieck</code> are all sieves that <em>contain</em> a covering presieve of <code>K</code>. This means that even if all covering presieves are small, we won't be able to deduce <code>HasMultiequalizer (S.index P)</code> for every <code>J</code>-sieve <code>S</code>. But since <code>K.Cover X ⥤ J.Cover X</code> is initial, I think it should be sufficient, in the plus-plus construction, to only consider sieves in the image of this functor. Those are precisely the ones that satisfy <code>S = Sieve.generate R</code> for some <code>K</code>-presieve and hence the multiequalizers exist with our smallness assumptions.</p>\n</li>\n</ol>\n<p>One way to use this last point, is to change the plus-plus construction and start with a setup like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"bp\">.</span><span class=\"n\">Cover</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Initial</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">HasMultiequalizer</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">index</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)]</span>\n</code></pre></div>\n<p>(where later <code>T X = K.Cover X</code>) and replace all occurences of <code>J.Cover X</code> with <code>T X</code>. I have not checked yet if everything goes through.</p>\n<p>Do you think it worth to do this refactor? Is there a better approach?<br>\n(Probably at least <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> is interested.)</p>",
        "id": 525010802,
        "sender_full_name": "Christian Merten",
        "timestamp": 1750413038
    },
    {
        "content": "<p>For sites like the \"small\" étale site, I have a WIP PR handling such cases because there is a small dense subsite with an equivalent category of sheaves. (This is based on the notion of <code>1</code>-hypercover.) This approach would not work for the Zariski sheafification of presheaves over a large category though.<br>\nIf we refactor the sheafification, I would rather see a \"direct\" construction of the sheafification by using colimits over a (homotopy) category of <code>1</code>-hypercovers. (Contrary to the \"plus-plus\" construction, we would have to apply the construction only once.)</p>",
        "id": 525026059,
        "sender_full_name": "Joël Riou",
        "timestamp": 1750419261
    },
    {
        "content": "<p>Yes, I am aware of your approach for the étale site, but I was indeed thinking how to get sheafification for the big zariski site.</p>",
        "id": 525037308,
        "sender_full_name": "Christian Merten",
        "timestamp": 1750423882
    },
    {
        "content": "<p>Do you have a reference explaining this 1-hypercover sheafification process?</p>",
        "id": 525037906,
        "sender_full_name": "Christian Merten",
        "timestamp": 1750424139
    },
    {
        "content": "<p>I do not know a reference, but it would be safe to start looking at SGA 4 V or the stacks project.</p>",
        "id": 525039719,
        "sender_full_name": "Joël Riou",
        "timestamp": 1750424855
    },
    {
        "content": "<p>(Note that there are minor subtle differences between <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.GrothendieckTopology.OneHypercover#doc\">docs#CategoryTheory.GrothendieckTopology.OneHypercover</a> and general <code>n</code>-hypercovers in the particular case <code>n = 1</code>. Here, the first steps would be to understand what is \"map\" between two <code>OneHypercover</code> and what is a homotopy.)</p>",
        "id": 525041294,
        "sender_full_name": "Joël Riou",
        "timestamp": 1750425512
    },
    {
        "content": "<p>I made an attempt here: <a href=\"https://github.com/leanprover-community/mathlib4/pull/26326\">#26326</a>.</p>",
        "id": 525416219,
        "sender_full_name": "Christian Merten",
        "timestamp": 1750718175
    }
]