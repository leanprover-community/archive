[
    {
        "content": "<p>Is Expr.foldlM supposed to traverse all subexpressions recursively, or just direct children?  The name and docstring suggest the former, but based on this example, it seems to do the latter:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean.Expr</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Lean.Expr.Traverse</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"n\">Lean.Meta</span> <span class=\"n\">Tactic</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span><span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"bp\">-&gt;</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">logSubexprs</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">MetaM</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">dbg_trace</span> <span class=\"n\">e</span>\n  <span class=\"n\">return</span> <span class=\"mi\">0</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">foo.foldlM</span> <span class=\"n\">logSubexprs</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>Normally I would look at the implementation to figure out what it's supposed to do, but it's a bit over my head:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/77ba88838571d5d50acc4a65740e1080026fa12e/Mathlib/Lean/Expr/Traverse.lean#L28-L30\">https://github.com/leanprover-community/mathlib4/blob/77ba88838571d5d50acc4a65740e1080026fa12e/Mathlib/Lean/Expr/Traverse.lean#L28-L30</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- `e.foldlM f a` folds the monadic function `f` over the subterms of the expression `e`,</span>\n<span class=\"sd\">with initial value `a`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">foldlM</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">Prod.snd</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"o\">(</span><span class=\"n\">StateT.run</span> <span class=\"o\">(</span><span class=\"n\">e.traverseChildren</span> <span class=\"bp\">$</span> <span class=\"k\">fun</span> <span class=\"n\">e'</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">Functor.mapConst</span> <span class=\"n\">e'</span> <span class=\"o\">(</span><span class=\"n\">get</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">monadLift</span> <span class=\"bp\">∘</span> <span class=\"n\">flip</span> <span class=\"n\">f</span> <span class=\"n\">e'</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">set</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>What would be the recommended way of folding over all children recursively, would I just use <code>MetaM.transform</code>?</p>",
        "id": 362824206,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1685638986
    },
    {
        "content": "<p>It's a fold over the immediate subexpressions of each expression</p>",
        "id": 362827060,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1685639631
    },
    {
        "content": "<p>I don't know the answer to your question, but one recursive version of that is <a href=\"https://github.com/leanprover-community/mathlib4/blob/f7b450735677ab422ab00e78d84818f9c5f96d86/Mathlib/Lean/Expr/ReplaceRec.lean#L28\">https://github.com/leanprover-community/mathlib4/blob/f7b450735677ab422ab00e78d84818f9c5f96d86/Mathlib/Lean/Expr/ReplaceRec.lean#L28</a></p>",
        "id": 362827444,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1685639717
    },
    {
        "content": "<p>This seems to do the trick for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Expr.foldlRecM</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddMessageContext</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadOptions</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadLiftT</span> <span class=\"n\">MetaM</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadControlT</span> <span class=\"n\">MetaM</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadTrace</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadRef</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Expr</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">init</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">):</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">Prod.snd</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"o\">(</span><span class=\"n\">StateT.run</span> <span class=\"o\">(</span><span class=\"n\">transform</span> <span class=\"n\">e</span> <span class=\"bp\">$</span> <span class=\"k\">fun</span> <span class=\"n\">e'</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">Functor.mapConst</span> <span class=\"n\">TransformStep.continue</span> <span class=\"o\">(</span><span class=\"n\">get</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">monadLift</span> <span class=\"bp\">∘</span> <span class=\"n\">flip</span> <span class=\"n\">f</span> <span class=\"n\">e'</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">set</span><span class=\"o\">))</span> <span class=\"n\">init</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 363609818,
        "sender_full_name": "Jeremy Salwen",
        "timestamp": 1685942344
    }
]