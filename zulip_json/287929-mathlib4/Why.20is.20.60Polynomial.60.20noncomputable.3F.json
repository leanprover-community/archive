[
    {
        "content": "<p>In Mathlib.Data.Polynomial.Basic, the structure <code>Polynomial</code> is defined in a noncomputable section. Is there any reason for not applying noncomputable for noncomputable types only? Any other building blocks of <code>Polynomial</code> doesn't seem to be noncomputable.</p>",
        "id": 422258586,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1708356965
    },
    {
        "content": "<p>The reason is that we decided not to care about computability of polynomials when they were defined. Now there is a lot more reason to care about computability but it's going to be a lot of work to do so nicely. See e.g. <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Polynomial.20uncomputable\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/.E2.9C.94.20Polynomial.20uncomputable</a></p>",
        "id": 422259107,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1708357161
    },
    {
        "content": "<p>Here is a wiki page with even more information: <a href=\"https://github.com/leanprover-community/mathlib4/wiki/Computation-models-for-polynomials-and-finitely-supported-functions\">https://github.com/leanprover-community/mathlib4/wiki/Computation-models-for-polynomials-and-finitely-supported-functions</a></p>",
        "id": 422259201,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1708357194
    },
    {
        "content": "<p>Please add this Zulip thread to the list of Zulip topics on that page :)</p>",
        "id": 422268732,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708359562
    },
    {
        "content": "<p>(having a record of this being asked for is helpful in justifying the change in future, if it is ever made)</p>",
        "id": 422268835,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708359589
    },
    {
        "content": "<p>While staring at the wiki page, I couldn't figure out how de-classified <code>Finsupp</code>, <code>DFinsupp</code>, and <code>DFinsupp'</code> achieve <code>f i</code> (aka <code>p.coeff i</code>) without <code>DecidableEq ι</code>. How can it compute <code>f j</code> if <code>f = single i 1</code> and <code>i = j</code> but doesn't have <code>DecideableEq ι</code> property?</p>",
        "id": 422284792,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1708365458
    },
    {
        "content": "<p>I'd also like to share my idea of computable <code>Finsupp</code>. Let <code>ι</code> be a type which we can choose one element (if not empty) without classical choose, for example zero. Also let <code>Finsupp ι R</code> contain <code>f</code> which is a finite set of functions from <code>ι</code> to <code>ι</code>, which is likely to be computable. This will require the same restriction as the quotient of inductive type method for operations listed in the table, while not being inductive.</p>",
        "id": 422286196,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1708366114
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574112\">Jihoon Hyun</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/422284792\">said</a>:</p>\n<blockquote>\n<p>While staring at the wiki page, I couldn't figure out how de-classified <code>Finsupp</code>, <code>DFinsupp</code>, and <code>DFinsupp'</code> achieve <code>f i</code> (aka <code>p.coeff i</code>) without <code>DecidableEq ι</code>. How can it compute <code>f j</code> if <code>f = single i 1</code> and <code>i = j</code> but doesn't have <code>DecideableEq ι</code> property?</p>\n</blockquote>\n<p>Because the <code>DecidableEq</code> obligation appeands at <code>f = single i 1</code> not at <code>f i</code></p>",
        "id": 422287642,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708366935
    },
    {
        "content": "<p>I don't really understand your suggestion (I think it has at least one typo, because you don't mention <code>R</code> in your definition)</p>",
        "id": 422287725,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708366991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/422287642\">말함</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"574112\">Jihoon Hyun</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/422284792\">said</a>:</p>\n<blockquote>\n<p>While staring at the wiki page, I couldn't figure out how de-classified <code>Finsupp</code>, <code>DFinsupp</code>, and <code>DFinsupp'</code> achieve <code>f i</code> (aka <code>p.coeff i</code>) without <code>DecidableEq ι</code>. How can it compute <code>f j</code> if <code>f = single i 1</code> and <code>i = j</code> but doesn't have <code>DecideableEq ι</code> property?</p>\n</blockquote>\n<p>Because the <code>DecidableEq</code> obligation appeands at <code>f = single i 1</code> not at <code>f i</code></p>\n</blockquote>\n<p>Thank you for the explanation! Then it seems like the deterministic equality checking of index is not an issue when working on <code>f i</code>, right? Why is this the case?</p>",
        "id": 422289792,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1708368189
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/422287725\">말함</a>:</p>\n<blockquote>\n<p>I don't really understand your suggestion (I think it has at least one typo, because you don't mention <code>R</code> in your definition)</p>\n</blockquote>\n<p>I meant that <code>single i r</code> or <code>+</code> in the table doesn't require <code>DecidableEq</code> for both types, while <code>f i</code> requires <code>DecidableEq ι</code> and <code>support</code> needs both <code>DecidableEq ι</code> and <code>DecidableEq R</code>, just like the 'quotient of inductive type'.</p>\n<p>I'll explain more about the method. Each element <code>F</code> of <code>Finsupp ι R</code> of mine will hold functions from <code>ι</code> to <code>ι</code>, which denotes an index <code>f 0</code> for each <code>f</code> in <code>F</code> . <code>single i r</code> is constructible by choosing a singleton set <code>F</code> which  contains a function <code>f</code> which maps <code>0</code> to <code>i</code>, along with <code>r</code>. <code>+</code> can be lazily operated without comparison on <code>ι</code>. If we don't need to deterministically check for equality as stated above, then it seems like the <code>DecidabeEq ι</code> can also be cancelled out, but for <code>support</code> operation we still need both <code>DecidableEq</code> constraints.</p>",
        "id": 422291176,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1708369026
    },
    {
        "content": "<p>It's hard to understand your idea by words. I wrote down some possible implementations of Finsupp <a href=\"#narrow/stream/116395-maths/topic/Lagrange.20interpolants/near/287806674\">here</a> (in Lean 3). Can you take a look and how your approach differ, preferably with some actual code?</p>",
        "id": 422293056,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1708370018
    },
    {
        "content": "<p>If you want to compute with polynomials, there is the <a href=\"#narrow/stream/113489-new-members/topic/Compute.20roots.20of.20polynomials/near/420713624\"><code>polynomial</code> tactic</a> as well as a <a href=\"#narrow/stream/113489-new-members/topic/Compute.20roots.20of.20polynomials/near/420832934\">new approach</a> of mine that works for polynomials over types with decidable equality and computable arithmetic operations, like ℕ, ℤ, and ℚ.</p>",
        "id": 422293639,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1708370329
    },
    {
        "content": "<p>It seems like my idea was not that good after all. I tried creating an equivalence relation on <code>ι -&gt; ι</code>, then noticed that there is a bijection between the created equivalence classes and <code>ι</code> itself, which implies that what I have thought was actually similar to that of <code>DFinsupp</code>.</p>",
        "id": 422586903,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1708511444
    },
    {
        "content": "<p>i think we should refactor polynomials to make it more computable</p>",
        "id": 520527462,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748292223
    },
    {
        "content": "<p>I still don't see how making polynomials computable would be a huge issue</p>",
        "id": 520527861,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1748292413
    },
    {
        "content": "<p>Well I don't think that's going to happen any time soon because the moment you do this then 1000 things will break and it will be very hard to fix them, and then a bunch of people will complain that you implemented the wrong kind of computability for their application (because there are several different ways that you can make them computable)</p>",
        "id": 520527876,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748292419
    },
    {
        "content": "<p>Kenny is old enough to remember why we made polynomials noncomputable, to fix slowdowns and constructivity  issues. I can't imagine ever going back to be honest, whatever people want. It would be a gigantic mountain and at the end of it mathlib would compile more slowly and people would say \"what exactly have we gained here and is it worth paying the price?\" and my bet is that the answer will be \"no\".</p>",
        "id": 520528369,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748292678
    },
    {
        "content": "<p>I think the solution is to have some kind of axiom free version of <code>csimp</code> or <code>implement_by</code> where you map everything under an iso that preserves certain operations to an computable model, do kernel reduce on that model and then map back.</p>",
        "id": 520528396,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1748292702
    },
    {
        "content": "<p>But that's just my guess as to what would happen, obviously we'll only know for sure if someone does it. First you have to bikeshed about whether your representation has <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>X</mi><msup><mn>10</mn><mn>10</mn></msup></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">X^{10^{10}}-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0702em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9869em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\"><span class=\"mord mtight\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913em;\"><span style=\"top:-2.931em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">10</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> overflowing memory or not.</p>",
        "id": 520528534,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748292757
    },
    {
        "content": "<p>Yes Andrew's idea is what we should really do, we don't want to go back to Finsupp.</p>",
        "id": 520528680,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748292840
    },
    {
        "content": "<p>yeah, how does Nat outsource addition externally?</p>",
        "id": 520528783,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748292886
    },
    {
        "content": "<p>Lean4 now trusts GMP :)</p>",
        "id": 520528822,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1748292912
    },
    {
        "content": "<p>I suppose a good enough normal form algorithm for polynomial rings (last time I checked this was missing) is equivalent to computability.</p>",
        "id": 520528850,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748292923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Z.5B.281.2Bsqrt.281.2B4k.29.29.2F2.5D/near/520528850\">said</a>:</p>\n<blockquote>\n<p>I suppose a good enough normal form algorithm for polynomial rings (last time I checked this was missing) is equivalent to computability.</p>\n</blockquote>\n<p>This doesn't help with <code>#eval</code>ing</p>",
        "id": 520529264,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1748293111
    },
    {
        "content": "<p>There is always <code>ring</code>, which in some sense is a normal form algorithm for multivariate polynomials. But I really wish it supports grouping things wrt a chosen variable (e.g. to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">)</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">)</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">)</mo><msup><mi>x</mi><mn>37</mn></msup></mrow><annotation encoding=\"application/x-tex\">(..)x^2 + (...)x^3 + (...)x^{37}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">..</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">...</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">...</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">37</span></span></span></span></span></span></span></span></span></span></span></span> instead of expanding all out)</p>",
        "id": 520529348,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1748293159
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Z.5B.281.2Bsqrt.281.2B4k.29.29.2F2.5D/near/520529264\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Z.5B.281.2Bsqrt.281.2B4k.29.29.2F2.5D/near/520528850\">said</a>:</p>\n<blockquote>\n<p>I suppose a good enough normal form algorithm for polynomial rings (last time I checked this was missing) is equivalent to computability.</p>\n</blockquote>\n<p>This doesn't help with <code>#eval</code>ing</p>\n</blockquote>\n<p>yes, but you don't use <code>#eval</code> in proofs.</p>",
        "id": 520529561,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748293249
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Z.5B.281.2Bsqrt.281.2B4k.29.29.2F2.5D/near/520529264\">said</a>:</p>\n<blockquote>\n<p>This doesn't help with <code>#eval</code>ing</p>\n</blockquote>\n<p>Continuing with my proposition, you could then create an <code>#eval with model</code> command that applies the iso and the relevant lemmas showing how each operation in the expression is equivalent to which computable functions under the iso and then do <code>#eval</code> and then output <code>iso.symm &lt;the eval result&gt;</code>.</p>",
        "id": 520529603,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1748293274
    },
    {
        "content": "<p>yes please have <code>ComputablePolynomial</code></p>",
        "id": 520529770,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748293353
    },
    {
        "content": "<p>and then you can also have a different model for different kinds of operations (e.g. for polys and matrices we probably at least want a dense representation and a sparse one)</p>",
        "id": 520529826,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1748293386
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Z.5B.281.2Bsqrt.281.2B4k.29.29.2F2.5D/near/520529561\">said</a>:</p>\n<blockquote>\n<p>yes, but you don't use <code>#eval</code> in proofs.</p>\n</blockquote>\n<p>Lean is a programming language too</p>",
        "id": 520529870,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1748293413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Z.5B.281.2Bsqrt.281.2B4k.29.29.2F2.5D/near/520529603\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Z.5B.281.2Bsqrt.281.2B4k.29.29.2F2.5D/near/520529264\">said</a>:</p>\n<blockquote>\n<p>This doesn't help with <code>#eval</code>ing</p>\n</blockquote>\n<p>Continuing with my proposition, you could then create an <code>#eval with model</code> command that applies the iso and the relevant lemmas showing how each operation in the expression is equivalent to which computable functions under the iso and then do <code>#eval</code> and then output <code>iso.symm &lt;the eval result&gt;</code>.</p>\n</blockquote>\n<p>This is starting to sound like something I would want</p>",
        "id": 520529892,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1748293429
    },
    {
        "content": "<p>Yeah this is the way to fix Polynomial, I don't think we should touch mathlib but if we want Lean to be a CAS as well then we can build <code>ComputablePolynomial</code> and if we want extreme awesomeness then we somehow get Andrew's ideas implemented to join the two concepts</p>",
        "id": 520530655,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748293755
    },
    {
        "content": "<p>I personally hope Lean could be a CAS, or at least hope there will eventually be a day where some CAS could output a proof term along with the results. (Most CAS already output some kind of proof certificate but the \"proof certificates\" are mostly more numbers that one needs to write another program to check and one could only hope there are no bugs in either of the programs)</p>\n<p>But emphasis on \"hope\", I am not that actually invested to work on it myself :P</p>",
        "id": 520531342,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1748294134
    },
    {
        "content": "<p>if only mathematica made its algorithm public</p>",
        "id": 520532180,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748294552
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Z.5B.281.2Bsqrt.281.2B4k.29.29.2F2.5D/near/520528369\">said</a>:</p>\n<blockquote>\n<p>Kenny is old enough to remember why we made polynomials noncomputable, to fix slowdowns and constructivity  issues. </p>\n</blockquote>\n<p>That was Lean3.</p>",
        "id": 520532401,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748294670
    },
    {
        "content": "<p>If we want to be fast, aren't there multiple pertinent ways to represent polynomials depending on the situation ? In the same way that computer scientists have a notion of \"sparse matrix\" where they don't keep track of all the zeros ? This would make for a(nother) good argument to <em>not</em> choose any specific representation for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial#doc\">docs#Polynomial</a> but have multiple implementations sitting on the side.</p>",
        "id": 520534891,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1748296126
    },
    {
        "content": "<p>I think a lot of time we don't care about being fast, and we just want to evaluate something very small by any means</p>",
        "id": 520537221,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748297582
    },
    {
        "content": "<p>There's earlier discussion on computable polynomial and finsupp here as well: <a href=\"https://github.com/leanprover-community/mathlib4/wiki/Computation-models-for-polynomials-and-finitely-supported-functions\">https://github.com/leanprover-community/mathlib4/wiki/Computation-models-for-polynomials-and-finitely-supported-functions</a></p>",
        "id": 520659207,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1748349833
    },
    {
        "content": "<p>I think that issue goes down the wrong track. Multiset and Finset should be avoided in the first place: sparse polynomials (operations, not theory) should be a pre-Mathlib library built in top of HashMap and TreeMap.</p>\n<p>Now that we have ExtHashMap the groundwork is there. We need a wrapper ExtHashMapD which forbids values equal to zero (or default, depending on the design), which is then equivalently to finitely supported functions but really fast. </p>\n<p>Then we need an analogue of the mergeWith function that lets you implement (pointwise) multiplication. (The current function just copies values that appear in only one map, so can only be used for addition.) </p>\n<p>Then we need to do all of the above with TreeMap (including the extensional version, which is missing), because polynomials usually have a monomial order and using this speeds up operations. </p>\n<p>None of this should touch Mathlib.</p>",
        "id": 520766353,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1748383366
    },
    {
        "content": "<p>I added a new section to that wiki page that shows how to make kernel- and interpreter- computable polynomials today in two lines</p>",
        "id": 520768705,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748384785
    },
    {
        "content": "<p>I don't see how a <code>HashMap</code>/<code>TreeMap</code> implementation will help with things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">X</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">X</span><span class=\"bp\">^</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 520768838,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748384854
    },
    {
        "content": "<p>The point of doing this in lean is to get provable algorithms and proof terms as certificates IMO, which <code>HashMap</code> cannot do and <code>TreeMap</code> might be able to but needs significant change to make it kernel reducible.</p>",
        "id": 520770133,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1748385782
    },
    {
        "content": "<p>I just added another example to that page for multivariate polynomials</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">^</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CMvPolynomial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 520770248,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748385876
    },
    {
        "content": "<p>Another issue with \"computable polynomials\" is that there seem to be several genuinely different interpretations of the details of what the phrase actually means</p>",
        "id": 520770472,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748386026
    },
    {
        "content": "<p>it seems to not matter if we only use it meta-ly</p>",
        "id": 520770501,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748386055
    },
    {
        "content": "<p>... which is one meaning, but it's ergonomically not the same as  \"I want to use <code>#eval</code>\"-ly, and certainly not the same as \"kernel-y\"</p>",
        "id": 520770632,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748386128
    },
    {
        "content": "<p>I actually suspect you could replace <code>Polynomial</code> with <code>CPolynomial</code> in mathlib without too much work, as long as you were willing to incrementally make things computable rather than all at once</p>",
        "id": 520770783,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748386231
    },
    {
        "content": "<p>That is, replace the <code>ofFinsupp :: toFinsupp</code> constructor with <code>ofDirectSum :: toDirectSum</code>, adjust the ring structure, then define <code>ofFinsupp</code> and <code>toFinsupp</code> manually and prove they are still well-behaved</p>",
        "id": 520770820,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748386271
    },
    {
        "content": "<p>Everything downstream should either use only the ring structure, or go via <code>toFinsupp</code>, so there should be minimal breakage except where defeqs are exploited</p>",
        "id": 520770855,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748386309
    },
    {
        "content": "<p>45 messages were moved here from <a href=\"#narrow/channel/217875-Is-there-code-for-X.3F/topic/Z.5B.281.2Bsqrt.281.2B4k.29.29.2F2.5D\">#Is there code for X? &gt; Z&#91;(1+sqrt(1+4k))/2&#93;</a> by <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>.</p>",
        "id": 520772552,
        "sender_full_name": "Notification Bot",
        "timestamp": 1748387383
    },
    {
        "content": "<p>Filip Jonsson Kling from Stockholm Uni was proving results about the resultant and the corresponding resultant matrix. I made him define the resultant matrix of <code>A B : R[X]</code> as a matrix <code>Matrix (Fin &lt;| A.natDegree + B.natDegree) (Fin &lt;| A.natDegree + B.natDegree) R</code>. Then he tried to compute the resultant of <code>X + a</code> and <code>X + b</code> and instantly got blocked by the fact that <code>Matrix (Fin &lt;| (X + C a).natDegree + (X + C b).natDegree) (Fin &lt;| (X + C a).natDegree + (X + C b).natDegree) R</code> doesn't reduce to <code>Matrix (Fin 2) (Fin 2) R</code> to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.det_fin_two#doc\">docs#Matrix.det_fin_two</a></p>",
        "id": 520812311,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1748413334
    },
    {
        "content": "<p>I am aware of <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>'s <a href=\"https://github.com/leanprover-community/mathlib4/tree/kckennylau/resultant\"><code>kckennylau/resultant</code></a> branch, which sidesteps the issue by allowing padding the resultant matrix.</p>",
        "id": 520812477,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1748413427
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> and I independently came up with the same idea of having the size of the matrix be free</p>",
        "id": 520812569,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748413456
    },
    {
        "content": "<p>but for <code>natDegree &lt;| X + C a</code> to reduce to <code>1</code>, it would require us to do case matching on <code>Nontrivial R</code>... which now that I think about it, can be solved by having a <code>DecidableEq</code> on <code>R</code>... which on further thought seems to be undesirable</p>",
        "id": 520812810,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748413573
    },
    {
        "content": "<p>i suppose this is one of the \"problems\" of kernel reduction</p>",
        "id": 520812893,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748413622
    },
    {
        "content": "<p>we can't just have a reduction rule that says if <code>Nontrivial R</code> then reduce etc.</p>",
        "id": 520812923,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748413637
    },
    {
        "content": "<p>having conditional reduction rules might be nice</p>",
        "id": 520812976,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748413672
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/520812311\">said</a>:</p>\n<blockquote>\n<p>Filip Jonsson Kling from Stockholm Uni was proving results about the resultant and the corresponding resultant matrix. I made him define the resultant matrix of <code>A B : R[X]</code> as a matrix <code>Matrix (Fin &lt;| A.natDegree + B.natDegree) (Fin &lt;| A.natDegree + B.natDegree) R</code>. Then he tried to compute the resultant of <code>X + a</code> and <code>X + b</code> and instantly got blocked by the fact that <code>Matrix (Fin &lt;| (X + C a).natDegree + (X + C b).natDegree) (Fin &lt;| (X + C a).natDegree + (X + C b).natDegree) R</code> doesn't reduce to <code>Matrix (Fin 2) (Fin 2) R</code> to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.det_fin_two#doc\">docs#Matrix.det_fin_two</a></p>\n</blockquote>\n<p>Oh defeq problem... What about <code>resultant A B m hm : Matrix (Fin m) (Fin m) R</code> where <code>hm : m = A.natDegree + B.natDegree</code>?</p>",
        "id": 520819286,
        "sender_full_name": "Jz Pan",
        "timestamp": 1748416216
    },
    {
        "content": "<p>Yes, and then you notice that actually assuming <code>hm : A.natDegree + B.natDegree ≤ m</code> instead doesn't hurt, and then you think for a second and you fully drop the assumption</p>",
        "id": 520820077,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1748416514
    },
    {
        "content": "<p>(the resultant actually changes when you enlarge the degrees, and it might be useful to actually consider those cases as well)</p>",
        "id": 520820264,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748416578
    },
    {
        "content": "<p>Similarly we also have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.reflect#doc\">docs#Polynomial.reflect</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.reverse#doc\">docs#Polynomial.reverse</a> so I think this is the right (and battle-tested) way to go.</p>",
        "id": 520820704,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1748416751
    },
    {
        "content": "<p>A polynomial k-algebra on a set is the result of the application of the left adjoint to the forgetful functor from commutative <code>k</code>-algebras to sets. </p>\n<p>To me, this says we need to break up <code>Polynomial</code> into an implementation layer and the desired invariants. Something like <code>PrePolynomial</code> and <code>IsPolynomial</code>. Ideally a downstream user could plug in any <code>PrePolynomial</code> implementation that is proven to satisfy <code>IsPolynomial</code> and get access to the vast majority of the API. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Algebra.Algebra.Hom</span>\n\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">PrePolynomial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">mon</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">carrier</span>\n\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">IsPolynomialAlg</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrePolynomial</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">P.carrier</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">P.carrier</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P.carrier</span><span class=\"w\"> </span><span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">P.mon</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">unique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ₁</span><span class=\"w\"> </span><span class=\"n\">φ₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P.carrier</span><span class=\"w\"> </span><span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">φ₁</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">P.mon</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">φ₂</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">P.mon</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">φ₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">φ₂</span>\n</code></pre></div>\n<p>Running heavily via <code>decide</code> seems like too much lock in.</p>",
        "id": 520898792,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1748440493
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span> we already have external capabilities, calculations on <code>Nat</code> are all done externally (proof: see how fast <code>#eval 641 * 6700417</code> is); we just haven't done this for polynomials, and I don't know how to; but we shouldn't make things like <code>PrePolynomial</code> inside Lean</p>",
        "id": 520899399,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1748440663
    },
    {
        "content": "<p>Yes, I am well aware of the kernel accelerated arithmetic operations, compiler generated representations, tactic generated representations etc. I also know how to do something similar (in broad strokes) for the current model of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial#doc\">docs#Polynomial</a>. </p>\n<p>The main difference between <code>Nat</code> and <code>Polynomial</code> is that we all agree on the implementation of <code>Nat</code> (at least on this zulip instance). For polynomials, this is not the case. See the wiki. I think that is good thing. Different goals prioritize different representations. It is most useful broadly to be able to address them generally and abstractly.</p>",
        "id": 520902237,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1748441358
    },
    {
        "content": "<p>I think the whole <code>computable</code> vs <code>noncomputable</code> is also an incarnation of being too close to a particular implementation of polynomials and being forced to carry around too much to get tasks done.</p>",
        "id": 520903046,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1748441580
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/520902237\">said</a>:</p>\n<blockquote>\n<p>is that we all agree on the implementation of <code>Nat</code> (at least on this zulip instance</p>\n</blockquote>\n<p>This isn't true? Some of us use GMP, the rest (Windows) use a lean-internal nat implementation</p>",
        "id": 520909550,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748443164
    },
    {
        "content": "<p>I was saying in Lean itself but you are also making my point more generally.</p>",
        "id": 520909952,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1748443251
    },
    {
        "content": "<p>I don't really buy this argument though; I think a lot of us here don't agree on how <code>Int</code> is defined (I believe Kevin has wanted to teach it as a quotient in the past), but the API is such that we immediately stop caring</p>",
        "id": 520911909,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748443723
    },
    {
        "content": "<p>If we redefined <code>Int</code> such that <code>#eval (1 + 2 : Int)</code> complained, this would surely be very unpopular</p>",
        "id": 520913983,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748444268
    },
    {
        "content": "<p>So I don't understand the argument for why we shouldn't fix <code>#eval (1 + 2 : R[X])</code>, especially if the fix doesn't affect the API</p>",
        "id": 520914115,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748444292
    },
    {
        "content": "<p>I agree that <code>Int</code> is not a mathematician's implementation. I am not sure we stopped caring but more so just lived with it. But polynomials also have more moving parts than integers. It seems more feasible to me to directly translate and transport invariants between different models of the integers than different models of polynomials. </p>\n<p>I would be a pretty rough to tell someone who showed up that we don't support their model of the polynomials and they have to roll their own verification at best cribbing off mathlib.</p>",
        "id": 520914299,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1748444349
    },
    {
        "content": "<p>Do any of the computational models on <a href=\"https://github.com/leanprover-community/mathlib4/wiki/Computation-models-for-polynomials-and-finitely-supported-functions\">the wiki</a> avoid the fundamental issue that polynomial operations result in closures that are not memoized?</p>\n<p>If you make your point <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> of \"yes, but computational polynomials help discharge goals about small polynomials\", a big difference between polynomials and Nat/Int is that Nat/Int are good at all scales. Why should mathematical theory have additional complications (decidability assumptions for example) just to support a computational model that is not good for large computations?</p>",
        "id": 520914453,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748444398
    },
    {
        "content": "<p>My claim is that <a href=\"https://github.com/leanprover-community/mathlib4/wiki/Computation-models-for-polynomials-and-finitely-supported-functions#i-want-computable-polynomials-today\">no such assumptions are needed</a> to fix <code>+</code>, <code>*</code>, and <code>X</code></p>",
        "id": 520914729,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748444449
    },
    {
        "content": "<p>What about the rest of the operations that the rest of the theory would want to use?</p>",
        "id": 520914831,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748444481
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/520914115\">said</a>:</p>\n<blockquote>\n<p>So I don't understand the argument for why we shouldn't fix <code>#eval (1 + 2 : R[X])</code>, especially if the fix doesn't affect the API</p>\n</blockquote>\n<p>Do we just want that to give a number?</p>",
        "id": 520914842,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1748444485
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/520914831\">said</a>:</p>\n<blockquote>\n<p>What about the rest of the operations that the rest of the theory would want to use?</p>\n</blockquote>\n<p>We can decide that on a case-by-case basis, just like we do for other types</p>",
        "id": 520914903,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748444506
    },
    {
        "content": "<p>At some point we can say \"no, the <code>[Decidable]</code> tradeoff isn't worth it for <code>Polynomial.foo</code>\", like we do for <code>Finset.preimage</code></p>",
        "id": 520915145,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748444559
    },
    {
        "content": "<p>It would be really nice if this doesn't have to be decided case-by-case so that theory never has to make any compromises.</p>\n<p>Regarding <code>Finset</code>, I really want there to be a <code>FiniteSet</code> type that similarly is pure theory (a <code>Set</code> plus a <code>Set.Finite</code> proof).</p>",
        "id": 520915368,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748444620
    },
    {
        "content": "<p>Do you have any answer about my closure point? Or is it still \"that doesn't matter for small polynomials, and computable just means small polynomials\"?</p>",
        "id": 520915491,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748444650
    },
    {
        "content": "<p>You're correct that the closure is present in all of them today, but I believe you could implement <code>Polynomial.add a b</code> as <code>{ toDirectSum := memoize (a.toDirectSum + b.toDirectSum) }</code></p>",
        "id": 520915680,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748444704
    },
    {
        "content": "<p>Hopefully memoization doesn't cause any issues for kernel reduction</p>",
        "id": 520916166,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748444839
    },
    {
        "content": "<p>Could <code>csimp</code> solve that?</p>",
        "id": 520916229,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748444856
    },
    {
        "content": "<p>Regarding <code>Finset</code>, it would be a shame for <code>FiniteSet</code> to replace it and leave me unable to <code>#eval (Finset.offDiag {1, 2, 3}).powersetCard 2</code></p>",
        "id": 520916469,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748444914
    },
    {
        "content": "<p>(to be clear: the un-memoized closures only matter for execution, not for kernel-reduction, right?)</p>",
        "id": 520916722,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748445001
    },
    {
        "content": "<p>Kernel reduction is probably ok with unmemoized closures since it memoizes everything itself.</p>",
        "id": 520917829,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748445350
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/520916469\">said</a>:</p>\n<blockquote>\n<p>Regarding <code>Finset</code>, it would be a shame for <code>FiniteSet</code> to replace it and leave me unable to <code>#eval (Finset.offDiag {1, 2, 3}).powersetCard 2</code></p>\n</blockquote>\n<p>It wouldn't replace it. It's just a missing corner of the 2x2 quadrant for finiteness of types/sets and computable/theoretical.</p>\n<p>Independently, I think there should be a more powerful csimp that can be used to give mathematical expressions computational content.</p>",
        "id": 520918111,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748445445
    },
    {
        "content": "<p>It sort of shares that corner with <code>Set.Finite</code> I guess?</p>",
        "id": 520918286,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748445486
    },
    {
        "content": "<p>Maybe there's a 2x2x2 with bundled/unbundled as well.</p>",
        "id": 520920043,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748446012
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/520918111\">said</a>:</p>\n<blockquote>\n<p>Independently, I think there should be a more powerful csimp that can be used to give mathematical expressions computational content.</p>\n</blockquote>\n<p>What do you mean by this?</p>",
        "id": 520922359,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1748446688
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> Imagine something like this:</p>\n<ol>\n<li>There is a system to associate \"computational types\" to types, perhaps via a typeclass. The typeclass includes a coercion function <code>compute : T -&gt; C</code> from the type to its computational type, for theoretical purposes.</li>\n<li>There is a system of lemmas for pushing <code>compute</code> inwards.</li>\n<li>There is a metaprogram to drive the pushing.</li>\n</ol>\n<p>Back in Lean 3 I tried doing this with just typeclasses (and worked on the Lean 3 noncomputability checker to get Lean to see that the compute function was computable), but it was too ineffective. Some sort of systematic compiler would be better. (And maybe it can be implemented almost entirely with <code>simp</code>!)</p>",
        "id": 520924669,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748447347
    },
    {
        "content": "<p>Unlike csimp, the lemmas could be conditional on typeclasses that synthesize for specific types, giving better algorithms than a lowest common denominator.</p>",
        "id": 520925041,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748447442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/520528369\">said</a>:</p>\n<blockquote>\n<p>Kenny is old enough to remember why we made polynomials noncomputable, to fix slowdowns and constructivity  issues. I can't imagine ever going back to be honest, whatever people want. It would be a gigantic mountain and at the end of it mathlib would compile more slowly and people would say \"what exactly have we gained here and is it worth paying the price?\" and my bet is that the answer will be \"no\".</p>\n</blockquote>\n<p>I viewed discussions on <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/timeout.20when.20working.20with.20ideal.20of.20polynomial.20ring/with/173206867\">#general &gt; timeout when working with ideal of polynomial ring</a>, where timeout happened when lean was searching for instance. I still don't know why making polynomial classical did \"fix\" it. Did it just avoid some ineffective/slow search routes?<br>\n(The way <code>polynomial</code> was computed was ineffective, but it seems unrelated to such a timeout in instance search.)</p>",
        "id": 520955768,
        "sender_full_name": "Hagb (Junyu Guo)",
        "timestamp": 1748458602
    },
    {
        "content": "<p>What Kyle describes sounds pretty cool. But, in the big picture, what would be the goal here? Are we just making it so people stop asking the titular question? Are we looking at generating something performant for some set of real-world use cases? If so, how good?</p>",
        "id": 521105222,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1748528680
    },
    {
        "content": "<p>Big picture, think of this being a framework for a <code>decide</code>-like tactic that reduces some mathematical goal into a routine computation (two possibilities here: good for kernel reduction, or good for <code>#eval</code>). This could subsume <code>decide</code> — in this framework, that tactic uses <code>Bool</code> for the computation type of <code>Prop</code>.</p>\n<p>While I think this would all be useful, more realistically, when it comes to polynomials, having a <code>normalg</code> tactic that does what <code>normnum</code> does but normalizes anything algebraic, like a CAS, would solve most problems. (The common case for <code>decide</code> is for simple things, not heavy calculations, right? How often would it be better to use a heavy <code>compute</code> rather than a <code>normalg</code>?)</p>\n<p>On the flip side, to prove things about programs that use, for example, computable polynomials, you'd want a \"<code>proofify</code>\" tactic to turn the program into a mathematical specification that uses the mathematical polynomials.</p>",
        "id": 521124839,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748534735
    },
    {
        "content": "<p>Thanks. That is a good clarification of the scope: computation in service of verification.</p>",
        "id": 521126733,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1748535309
    },
    {
        "content": "<p><code>normalg</code> is also known as <code>ring_nf</code> though...</p>",
        "id": 521163209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1748549413
    },
    {
        "content": "<p><code>ring_nf</code> is an element of a <code>normalg</code>, yes, but there's more to algebra than rings and polynomials with natural number exponents</p>",
        "id": 521164767,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1748550194
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>PARI/GP is free software, covered by the GNU General Public License, and comes WITHOUT ANY WARRANTY WHATSOEVER.\n\nType ? for help, \\q to quit.\nType ?18 for how to get moral (and possibly technical) support.\n\nparisize = 8000000, primelimit = 500000, nbthreads = 20\n? 1/(1-x)+O(x^10)\n%1 = 1 + x + x^2 + x^3 + x^4 + x^5 + x^6 + x^7 + x^8 + x^9 + O(x^10)\n? 1/7+O(2^10)\n%2 = 1 + 2 + 2^2 + 2^4 + 2^5 + 2^7 + 2^8 + O(2^10)\n? exp(x^2)+O(x^10)\n%3 = 1 + x^2 + 1/2*x^4 + 1/6*x^6 + 1/24*x^8 + O(x^10)\n?\n</code></pre></div>\n<p>etc etc</p>",
        "id": 521167988,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748551703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/520924669\">said</a>:</p>\n<blockquote>\n<p>And maybe it can be implemented almost entirely with <code>simp</code>!</p>\n</blockquote>\n<p>It is definitely possible. I have few experiments of translating reals to floats that do this.</p>\n<p>What sort of stopped me was dealing with structures. If you define a structure/inductive type that uses reals then you need to define new structure that uses equivalent floats. Then you need to write down all the theorems for all the projections etc. it gets really tedious and one should write some meta programs to do this automatically.</p>\n<p>Also this translation is often functorial and it might be advantageous to write custom extension to simp that is better at applying composition theorem than lean's unification.</p>",
        "id": 521232262,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1748587765
    },
    {
        "content": "<p>There is another way to compute polynomials - as a <code>DirectLimit</code> rather than a <code>DirectSum</code>, essentially. I somewhat assume we have a link between these two things already, though.</p>",
        "id": 524669724,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1750240523
    }
]