[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/25499\">#25499</a>, I introduced monoidal left actions of a monoidal category on a category. I followed the reference <a href=\"http://www.tac.mta.ca/tac/volumes/9/n4/9-04abs.html\">here</a>. The data of a monoidal left action of <code>C</code> on <code>D</code> consists on a bifunctor <code>- ‚äô - : C ‚•§ D ‚•§ D</code>, along with a natural isomorphism <code>(x ‚äó y) ‚äô z ‚âÖ x ‚äô y ‚äô z</code>, and natural isomorphism <code>ùüô_ C ‚äô x ‚âÖ x</code>, these isomorphism satisfy compatibility conditions that are like the pentagon and triangle axioms for monoidal categories. A monoidal category <code>C</code> acts on itself via the tensor product, etc. So far, everything seems pretty moral.</p>\n<p>There is a second point of view on such objects (which is in fact the definition in the reference I gave): they are monoidal functors <code>C ‚•§ D ‚•§ D</code>, where <code>D ‚•§ D</code> has the \"composition\" monoidal structure. Also, for every (not necessarily monoidal) category <code>C</code> there is a left action of <code>C ‚•§ C</code> (again with composition monoidal structure) on <code>C</code>, corresponding to the identity monoidal functor from <code>C ‚•§ C</code> to itself, the \"action\" being evaluation.</p>\n<p>This must be very straightforward to prove, right? Well, turns out it‚Äôs not. The issue is that for mathlib's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.endofunctorMonoidalCategory#doc\">docs#CategoryTheory.endofunctorMonoidalCategory</a> the tensor product of <code>F</code> and <code>G</code> is <code>F ‚ãô G</code>, rather than <code>G ‚ãô F</code>, this is an artifact of mathlib's choice to have composition reversed up. Hence, <code>(F ‚äó G) ‚äô x </code> is <code>G.obj (F.obj x)</code>, while <code>F ‚äô G ‚äô x</code> is <code>F.obj (G.obj x)</code>.</p>\n<p>This can be \"corrected\" if we use the monoidal opposite of <code>C ‚•§ C</code> instead of <code>C ‚•§ C</code>. But suddenly, the story in the first (edit: and second) paragraph don‚Äôt look as nice.<br>\nI would advocate refactoring <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.endofunctorMonoidalCategory#doc\">docs#CategoryTheory.endofunctorMonoidalCategory</a> to make its tensor product be <code>F ‚äó G := G ‚ãô F</code>. Note that this should also not impact the equivalence we have between monoids in the endofunctor categories and monads: for this equivalence, we‚Äôre tensoring a functor with itself, so order doesn‚Äôt matter!</p>",
        "id": 523083329,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749472896
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/287929-mathlib4/topic/endofunctorMonoidalCategory.20is.20.22wrong.22/near/523083329\">said</a>:</p>\n<blockquote>\n<p>This can be \"corrected\" if we use the monoidal opposite of <code>C ‚•§ C</code> instead of <code>C ‚•§ C</code>. But suddenly, the story in the first paragraph doesn‚Äôt look as nice.<br>\nI would advocate refactoring <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.endofunctorMonoidalCategory#doc\">docs#CategoryTheory.endofunctorMonoidalCategory</a> to make its tensor product be <code>F ‚äó G := G ‚ãô F</code>. Note that this should also not impact the equivalence we have between monoids in the endofunctor categories and monads: for this equivalence, we‚Äôre tensoring a functor with itself, so order doesn‚Äôt matter!</p>\n</blockquote>\n<p>I should warn you that if you try this, you would have to refactor basically all the theory of shift functors that is used in the context of triangulated categories.<br>\nThe easier fix would be to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.MonoidalOpposite#doc\">docs#CategoryTheory.MonoidalOpposite</a></p>",
        "id": 523087512,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1749474340
    },
    {
        "content": "<p>Also, a compelling argument for the refactor is that when we think of a monad <code>T</code> as a monoid in the category of endofunctors, then the modules in <code>C</code> over that monoids are the <code>T</code>-algebras. I think I can still prove that with the current Mathlib‚Äôs definitions <code>T</code>-algebras are modules over some monoid in the monoidal opposite of <code>C ‚•§ C</code> through some general equivalence between <code>Mon_ C</code> and <code>Mon_ C·¥π·µí·µñ</code>, but this would make the statement pointlessly complicated IMO.</p>",
        "id": 523087540,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749474348
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Jo√´l Riou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/endofunctorMonoidalCategory.20is.20.22wrong.22/near/523087512\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/287929-mathlib4/topic/endofunctorMonoidalCategory.20is.20.22wrong.22/near/523083329\">said</a>:</p>\n<blockquote>\n<p>This can be \"corrected\" if we use the monoidal opposite of <code>C ‚•§ C</code> instead of <code>C ‚•§ C</code>. But suddenly, the story in the first paragraph doesn‚Äôt look as nice.<br>\nI would advocate refactoring <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.endofunctorMonoidalCategory#doc\">docs#CategoryTheory.endofunctorMonoidalCategory</a> to make its tensor product be <code>F ‚äó G := G ‚ãô F</code>. Note that this should also not impact the equivalence we have between monoids in the endofunctor categories and monads: for this equivalence, we‚Äôre tensoring a functor with itself, so order doesn‚Äôt matter!</p>\n</blockquote>\n<p>I should warn you that if you try this, you would have to refactor basically all the theory of shift functors that is used in the context of triangulated categories.<br>\nThe easier fix would be to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.MonoidalOpposite#doc\">docs#CategoryTheory.MonoidalOpposite</a></p>\n</blockquote>\n<p>To be fair, not having <code>C ‚•§ C</code> acting on <code>C</code> via evaluation \"directly\" feels so silly that I would almost take the time  to refactor the shifts.</p>\n<p>I guess yet an other option is to add notations and names for actions of <code>C·¥π·µí·µñ</code>, but then we‚Äôre probably close to <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s favorite conundrum about left and right actions.</p>",
        "id": 523088160,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749474610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/287929-mathlib4/topic/endofunctorMonoidalCategory.20is.20.22wrong.22/near/523087540\">said</a>:</p>\n<blockquote>\n<p>Also, a compelling argument for the refactor is that when we think of a monad <code>T</code> as a monoid in the category of endofunctors, then the modules in <code>C</code> over that monoids are the <code>T</code>-algebras. I think I can still prove that with the current Mathlib‚Äôs definitions <code>T</code>-algebras are modules over some monoid in the monoidal opposite of <code>C ‚•§ C</code> through some general equivalence between <code>Mon_ C</code> and <code>Mon_ C·¥π·µí·µñ</code>, but this would make the statement pointlessly complicated IMO.</p>\n</blockquote>\n<p>(Note also that  this equivalence with algebras is important: once we will have monoidal bar constructions on monoids, this kind of statements should be used to obtain \"monadic\" bar constructions, and here I believe we want the action to have good definitional properties, which I‚Äôm not sure we will have by using opposites.)</p>",
        "id": 523088567,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749474773
    },
    {
        "content": "<p>If you change the monoidal structure on endofunctors, the best solution may be to replace monoidal functors <code>Discrete A ‚•§ C ‚•§ C</code> in the definition of shifts by <code>Discrete A ‚•§ (C ‚•§ C)·¥π·µí·µñ</code>. As I have made the API of shifts mostly separated from that of monoidal functors, this should require only small changes to the more lowlevel shift files.</p>",
        "id": 523091816,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1749474867
    },
    {
        "content": "<p><del>Well, would‚Äôt that be a compelling reasons to use <code>MonoidalLeftAction (Discrete A) C</code> in shifts?‚ÄØThat would of course need to go deeper that what you suggest but this would feel more \"moral\", no? Or do you really prefer to have things use as little general monoidal category theory as possible?</del> Silly me, this is a right action if we change the composition order.</p>",
        "id": 523092176,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749475002
    },
    {
        "content": "<p>Looking at it with everything reversed, it now looks weird that the whiskerLeft of <code>endofunctorMonoidalCategory</code> is the whiskerRight, and <code>whiskerRight</code> is the whisker left, and the horizontal composition is also \"reversed\".</p>\n<p>So I guess maybe I was overly optimistic on how everything would looks better with everything reversed and I apologize for calling an immediate refactor a bit quickly.</p>\n<p>The question boils down to how much we want to align with the non-mathlib litterature.</p>\n<p>Do we prefer something that is something which is \"in line\" with the litterature, in which case we must reverse this strucure because what we call \"the composition monoidal structure\", is what everyone else would call its opposite. Or do we want something that is more coherent with mathlib‚Äôs choice, and keep things as is?</p>\n<p>The last option is to just redefine left actions to be in sync with monoidal functors to endofunctors, and then we have <code>(x ‚äó y) ‚äô z ‚âÖ y ‚äô x ‚äô z</code> and we tell people to \"just get over to it\" the same way we tell them to get used to the reverse composition order. With this, we still get a nice evaluation left action. It‚Äôs also the easiest refactor since left actions aren‚Äôt even merged.</p>\n<p>I see pros and cons for every single of these options. So I‚Äôll wait for more feedback from maintainers.<br>\nPerhaps <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> considered this when introducing this monoidal structure back in 2020?</p>",
        "id": 523097701,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749477026
    },
    {
        "content": "<p>After thinking a bit more about this, I think the best course of action is the following:</p>\n<ul>\n<li>Keep <code>endoFunctorMonoidalCategory</code> as is, however, add to its docstring that it is the monoidal opposite of what is usually considered in the literature under this name.</li>\n<li>Introduce right actions, with their set of notations and lemmas (this one is already done at <a href=\"https://github.com/leanprover-community/mathlib4/pull/25840\">#25840</a>)</li>\n<li>Prove left actions correspond to monoidal functors <code>_ ‚•§ (_ ‚•§ _)·¥π·µí·µñ</code>, and that right actions correspond to monoidal functors <code>_ ‚•§ (_ ‚•§ _)</code>. </li>\n<li>Endofunctors acts on the right on the base category, and document in the docstring that it is because of the fact that endofunctors are monoidal opposite to the construction used in the literature.</li>\n<li>Quality of life and also WIP: various constructors/equivalences between left/right actions and right/left <code>·¥π·µí·µñ</code> actions.</li>\n</ul>",
        "id": 524049106,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749888882
    },
    {
        "content": "<p>Optionally, when all this is done, I guess shifts could be refactored as right actions? this would be completely cosmetic and it would bring nothing more than some satisfaction of making it fit in a general framework, and perhaps remove some code duplication?</p>",
        "id": 524049261,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749889069
    },
    {
        "content": "<p>Also, I suppose the plan above should also include defining (internal) right modules, with an equivalence with usual (left) modules over the monoidal opposite of the algebra, through the equivalence <code>Mon_ C ‚âå Mon_ C·¥π·µí·µñ</code> defined in <a href=\"https://github.com/leanprover-community/mathlib4/pull/25854\">#25854</a>.</p>",
        "id": 524050145,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749890076
    },
    {
        "content": "<p>Points 3 and 4 in list above are now at <a href=\"https://github.com/leanprover-community/mathlib4/pull/25875\">#25875</a></p>",
        "id": 524078335,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749923009
    },
    {
        "content": "<p>Last point is at <a href=\"https://github.com/leanprover-community/mathlib4/pull/25860\">#25860</a></p>",
        "id": 524078355,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749923038
    }
]