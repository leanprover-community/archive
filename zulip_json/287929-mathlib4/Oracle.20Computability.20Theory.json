[
    {
        "content": "<p>I have formalised the Kleene-Post theorem in computability theory, along with a large amount of mechanical foundations for it in <a href=\"https://github.com/hyeoniuwu/CiL\">https://github.com/hyeoniuwu/CiL</a>. (The capstone KP54 proof is found in <a href=\"https://github.com/hyeoniuwu/CiL/blob/main/Computability/Constructions/KP54.lean\">https://github.com/hyeoniuwu/CiL/blob/main/Computability/Constructions/KP54.lean</a>). (There are also other basic degree theoretic theorems and proofs included.)</p>\n<p>I have not yet refactored the codebase yet, so it's largely uncommented/poorly organised/is very slow, but I'm wondering if this is something people would be interested evnetually being merged into mathlib?</p>\n<p>One thing of note is that I \"redo\" a lot of the primitive recursive constructions in a different format from the current way in Mathlib, which helps in later constructions for the KP54 proof.</p>",
        "id": 567461173,
        "sender_full_name": "Edwin Park",
        "timestamp": 1768205694
    },
    {
        "content": "<p>Have you considered <a class=\"stream\" data-stream-id=\"513188\" href=\"/#narrow/channel/513188-CSLib\">#CSLib</a>?</p>",
        "id": 567654521,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1768256921
    },
    {
        "content": "<p>This is firmly within mathematics IMO, and isn't very related to the kind of cs theory that would go into cslib. the main difficulty would be finding reviewers for this kind of content, but that wouldn't be any easier at cslib.</p>\n<p>I think this would be great to have in mathlib personally</p>",
        "id": 567666919,
        "sender_full_name": "Tanner Duve",
        "timestamp": 1768265180
    },
    {
        "content": "<p>Interesting project!</p>\n<p>Just out of curiosity, why did you have to modify the way primitive recursion is defined in Mathlib?</p>",
        "id": 568423893,
        "sender_full_name": "Thomas C.",
        "timestamp": 1768566867
    },
    {
        "content": "<p>It's not a huge modification, but it makes proving certain theorems much more convenient.</p>\n<p>The way I build primitive recursive functions in this project is by building an explicit code, asserting that it is built only from primitive recursive constructors, then proving that it has a specified behavior on evaluation; for example, that it implements the addition function. This is opposed to just giving a theorem that addition is primitive recursive, where the \"code\" is kinda fuzzily written in the proof itself, making it hard to extract when needed.</p>\n<p>A practical example where my approach is needed is when proving (primitive) recursiveness of functions from codes to codes.</p>\n<p>For example, consider the foldl operator (as an operator from functions to functions), and suppose we have shown</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right\" columnspacing=\"\"><mtr><mtd class =\"mtr-glue\"></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mtext>Property 1. </mtext><mi>f</mi><mo>∈</mo><mtext>PRIMREC</mtext><mo>⇒</mo><mtext>foldl</mtext><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><mtext>PRIMREC</mtext><mi mathvariant=\"normal\">.</mi></mrow></mstyle></mtd><mtd class =\"mtr-glue\"></mtd><mtd class =\"mml-eqn-num\"></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{align}\n    \\text{Property 1. }f\\in\\text{PRIMREC}\\Rightarrow\\text{foldl}(f)\\in\\text{PRIMREC}.\n\\end{align}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.5em;vertical-align:-0.5em;\"></span><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1em;\"><span style=\"top:-3.16em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Property 1. </span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord text\"><span class=\"mord\">PRIMREC</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord text\"><span class=\"mord\">foldl</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord text\"><span class=\"mord\">PRIMREC</span></span><span class=\"mord\">.</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5em;\"><span></span></span></span></span></span></span></span><span class=\"tag\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:2.84em;\"></span><span class=\"eqn-num\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5em;\"><span></span></span></span></span></span></span></span></span></p>\n<p>Oftentimes however, one also has to prove that the operator <em>itself</em> is a primitive recursive function, from codes to codes. (Property 1 only states that the output of the operator is primitive recursive, if the input is.) That is,</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right\" columnspacing=\"\"><mtr><mtd class =\"mtr-glue\"></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mtext>Property 2. </mtext><mi mathvariant=\"normal\">∃</mi><mi>g</mi><mo>∈</mo><mtext>PRIMREC</mtext><mo separator=\"true\">,</mo><mtext> eval </mtext><mi>g</mi><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mtext>foldl</mtext><mo stretchy=\"false\">(</mo><mtext>eval </mtext><mi>c</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow></mstyle></mtd><mtd class =\"mtr-glue\"></mtd><mtd class =\"mml-eqn-num\"></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{align}\n    \\text{Property 2. }\\exists g\\in\\text{PRIMREC},\\ \\text{eval}\\ g(c)=\\text{foldl}(\\text{eval}\\ c).\n\\end{align}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.5em;vertical-align:-0.5em;\"></span><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1em;\"><span style=\"top:-3.16em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Property 2. </span></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord text\"><span class=\"mord\">PRIMREC</span></span><span class=\"mpunct\">,</span><span class=\"mspace\"> </span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">eval</span></span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord text\"><span class=\"mord\">foldl</span></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">eval</span></span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span><span class=\"mord\">.</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5em;\"><span></span></span></span></span></span></span></span><span class=\"tag\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:2.84em;\"></span><span class=\"eqn-num\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5em;\"><span></span></span></span></span></span></span></span></span></p>\n<p>Our approach allows easily proving the second property from the first, while this can't really be done directly with the way it's done in Mathlib.</p>\n<p>(For reference, see the foldl theorem in mathlib: <a href=\"https://github.com/leanprover-community/mathlib4/blob/1839d10be81233f804dab4e1d43fc1027219d3fa/Mathlib/Computability/Primrec/List.lean#L53\">https://github.com/leanprover-community/mathlib4/blob/1839d10be81233f804dab4e1d43fc1027219d3fa/Mathlib/Computability/Primrec/List.lean#L53</a>.)</p>\n<p>The actual construction of foldl is in the proof, not explicitly defined outside. The problem is that the second property relies on the details of that construction. So to prove the second property, one effectively has to repeat the construction in the first property, and furthermore demonstrate the primitive recursiveness of the process.</p>\n<p>This is trivial in our approach, because those construction procedures are explicitly defined, as codes. Once one has property 1, one can get property 2 \"for free\".</p>",
        "id": 568617480,
        "sender_full_name": "Edwin Park",
        "timestamp": 1768685666
    },
    {
        "content": "<p>Thanks for the explanation!</p>\n<p>Wouldn't such a change require rewriting most proofs using e.g. <code>Primrec</code>?</p>\n<p>Maybe <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> would have something to say about it since he wrote the initial formalization of computability in Lean? (see <a href=\"https://arxiv.org/abs/1810.08380\">https://arxiv.org/abs/1810.08380</a>)</p>",
        "id": 568841620,
        "sender_full_name": "Thomas C.",
        "timestamp": 1768840594
    },
    {
        "content": "<p>This principle is already applied for the most part in the primrec library; the reason why those early examples are done directly is because <code>Code</code> has not been defined yet</p>",
        "id": 568842337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1768840807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"666160\">Thomas C.</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Oracle.20Computability.20Theory/near/568841620\">said</a>:</p>\n<blockquote>\n<p>Wouldn't such a change require rewriting most proofs using e.g. <code>Primrec</code>?</p>\n</blockquote>\n<p>Yes, but rewriting existing theorems is most of the time trivial.</p>",
        "id": 568912525,
        "sender_full_name": "Edwin Park",
        "timestamp": 1768862302
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> </p>\n<p>By the principle being applied in the library, did you mean there are examples of property 2 being proven trivially from property 1 (or the converse)? If so, could you point me to an example?</p>",
        "id": 568915641,
        "sender_full_name": "Edwin Park",
        "timestamp": 1768863042
    },
    {
        "content": "<p>I think most of the code functions are proved unapplied</p>",
        "id": 568918991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1768864956
    },
    {
        "content": "<p>part of the issue might be that the definition of Code is one of the last things in the library since the original goal was to prove the smn theorem and undecidability of the halting problem</p>",
        "id": 568919076,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1768865006
    },
    {
        "content": "<p>I have a few comments to make.</p>\n<p>Firstly, the definition of TuringDegree in mathlib currently is incorrect.</p>\n<p>It defines the \"oracles\" as partial functions - this is not equivalent to having set oracles. Instead, the oracle functions should be total. (See <a href=\"https://link.springer.com/chapter/10.1007/BFb0086114\">https://link.springer.com/chapter/10.1007/BFb0086114</a>.)</p>\n<p>Also, I would like to merge some of my work into Mathlib. One \"weird\" thing  however is that the first few files in my formalisation are simply relativisations of existing Mathlib code (<a href=\"https://github.com/hyeoniuwu/CiL/blob/main/Computability/Oracle.lean\">Oracle.lean</a> and <a href=\"https://github.com/hyeoniuwu/CiL/blob/main/Computability/Encoding.lean\">Encoding.lean</a>), so there'd be some code duplication - is this fine?</p>",
        "id": 574203895,
        "sender_full_name": "Edwin Park",
        "timestamp": 1771291311
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TuringDegree#doc\">docs#TuringDegree</a></p>",
        "id": 574205126,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1771292614
    },
    {
        "content": "<p>Rather, maybe I should've said the problem is with <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/TuringDegree.html#TuringReducible\">TuringReducible</a>; Turing reducibility is a relation on oracles (i.e. total functions) not partial functions</p>",
        "id": 574205289,
        "sender_full_name": "Edwin Park",
        "timestamp": 1771292775
    },
    {
        "content": "<p>does it restrict to the correct relation if you only feed it total functions?</p>",
        "id": 574205503,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1771292966
    },
    {
        "content": "<p>I believe so. But that doesn't change the fact that the current definition of \"TuringDegree\" is not what a Turing degree actually is.</p>",
        "id": 574206003,
        "sender_full_name": "Edwin Park",
        "timestamp": 1771293357
    },
    {
        "content": "<p>The current definition is actually the enumeration degrees, right?</p>",
        "id": 574206754,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771293939
    },
    {
        "content": "<p>Oh, I should have looked at your link.</p>",
        "id": 574206864,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771294025
    },
    {
        "content": "<p>I believe page 61 of my link shows that they are different</p>",
        "id": 574207100,
        "sender_full_name": "Edwin Park",
        "timestamp": 1771294223
    },
    {
        "content": "<p>Right, I'm seeing that now.</p>",
        "id": 574207205,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771294330
    },
    {
        "content": "<p>In any case, this will be pretty easy to fix, right?</p>",
        "id": 574208386,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771295405
    },
    {
        "content": "<p>I've already fixed it in <a href=\"https://github.com/hyeoniuwu/CiL/blob/ee2e1648d8b34f8c2a849de9cb0e5fb8d1ee5429/Computability/Oracle.lean#L145\">https://github.com/hyeoniuwu/CiL/blob/ee2e1648d8b34f8c2a849de9cb0e5fb8d1ee5429/Computability/Oracle.lean#L145</a></p>",
        "id": 574208505,
        "sender_full_name": "Edwin Park",
        "timestamp": 1771295497
    },
    {
        "content": "<p>I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RecursiveIn#doc\">docs#RecursiveIn</a> should definitely take a set of partial functions</p>",
        "id": 574208902,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1771295758
    },
    {
        "content": "<p>Is this notion still called 'T-reducibility'? My gut tells me that name probably wouldn't have caught on.</p>",
        "id": 574208921,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771295768
    },
    {
        "content": "<p>I'm not aware of any work on 'T-reducibility' after that paper, I'd love to know too though</p>",
        "id": 574209066,
        "sender_full_name": "Edwin Park",
        "timestamp": 1771295870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Oracle.20Computability.20Theory/near/574208902\">said</a>:</p>\n<blockquote>\n<p>I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RecursiveIn#doc\">docs#RecursiveIn</a> should definitely take a set of partial functions</p>\n</blockquote>\n<p>Why? Oracles are supposed to give you answers in finite time, so it doesn't make sense for them to be partial</p>",
        "id": 574209114,
        "sender_full_name": "Edwin Park",
        "timestamp": 1771295904
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"937245\">Edwin Park</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Oracle.20Computability.20Theory/near/574209114\">said</a>:</p>\n<blockquote>\n<p>Why? Oracles are supposed to give you answers in finite time, so it doesn't make sense for them to be partial</p>\n</blockquote>\n<p>Computability relative to a Turing ideal is something that shows up kind of often, so there's a case for the more general definition there.</p>",
        "id": 574209217,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771295973
    },
    {
        "content": "<p>Specifically allowing a set of oracles rather than just a single oracle.</p>",
        "id": 574209241,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771295991
    },
    {
        "content": "<p>I see. But in that case wouldn't it still be a set of total functions, not partial functions</p>",
        "id": 574209658,
        "sender_full_name": "Edwin Park",
        "timestamp": 1771296302
    },
    {
        "content": "<p>Right.</p>",
        "id": 574209998,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771296558
    },
    {
        "content": "<p>It's not clear to me what the 'right' base level of generality is for this.</p>",
        "id": 574210013,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771296568
    },
    {
        "content": "<p>Most degree structures naturally embed into the Muchnik degrees, for instance, but that might not be a good definition to work from.</p>",
        "id": 574210100,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771296634
    },
    {
        "content": "<p>(Although that said I don't know for a fact that the T-degrees do.)</p>",
        "id": 574210110,
        "sender_full_name": "James E Hanson",
        "timestamp": 1771296645
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"677310\">@Tanner Duve</span> has some open PRs in this area</p>",
        "id": 574216085,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1771302176
    },
    {
        "content": "<p>I think the concerns above are correct. But the definition of <code>TuringReducible</code> we currently have is a strict generalization of the typical definition. We can perhaps change the current <code>TuringReducible</code> to something like <code>PartialReducible</code> and then we can recover the typical reducibility definition as something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">TuringReducible</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\"> </span><span class=\"n\">PartialReducible</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Part</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Part</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>\n<p><code>RecursiveIn</code> I think is fine as-is as a general definition. A total function is just a partial function which is total. Making these edits in a PR would make more sense to me than replacing the existing API with something less general. I think this is more an issue of misnaming than definitions being incorrect.</p>",
        "id": 574220997,
        "sender_full_name": "Tanner Duve",
        "timestamp": 1771306873
    },
    {
        "content": "<p>The question of what to do with Encoding is a good one. I have an encoding for the general \"set of partial oracles\" <code>RecursiveIn</code> definition which is similar to the one <span class=\"user-mention\" data-user-id=\"937245\">@Edwin Park</span> has for the single total oracle definition. But there would be code duplication if we just added an encoding. One idea is to redefine <code>Partrec</code> as \"recursive in the empty set\" which <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> mentioned at some point before, but this would incur a large refactor I think.</p>",
        "id": 574223647,
        "sender_full_name": "Tanner Duve",
        "timestamp": 1771308948
    },
    {
        "content": "<p>IMO we shouldn't change the definitions here, this is like the question of whether to use VectorSpace or Module over a field. It's better to take the trivial generalization since it is available, since getting the equivalent notion is much harder without it (not even sure it is possible). If you want to talk about total functions, that's the responsibility of whatever derived notion writes a quantification over those functions</p>",
        "id": 576193852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1772176994
    },
    {
        "content": "<p>Computable functions that take partial oracles are natural notion when considering higher-order recursion theory (e.g. partial computable functional), so I think the idea of computable functions that take partial oracles isn't so nonsensical.  Defining <code>TuringReducible</code> from <code>PartialReducible</code> feels reasonable.</p>",
        "id": 576237122,
        "sender_full_name": "Palalansoukî",
        "timestamp": 1772191651
    },
    {
        "content": "<p>Fair.</p>",
        "id": 576387845,
        "sender_full_name": "Edwin Park",
        "timestamp": 1772252171
    }
]