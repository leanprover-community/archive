[
    {
        "content": "<p>Hi, I am relatively new to Mathlib and trying to get a sense of all the theorems in the library, by domain. I know it was done in 2020 as part of <br>\n<a href=\"https://writings.stephenwolfram.com/2018/03/roaring-into-2018-with-another-big-release-launching-version-11-3-of-the-wolfram-language-mathematica/#proofs\">https://writings.stephenwolfram.com/2018/03/roaring-into-2018-with-another-big-release-launching-version-11-3-of-the-wolfram-language-mathematica/#proofs</a><br>\nwhere these cloud links give the exact data<br>\n<a href=\"https://www.wolframcloud.com/obj/sw-blog/EuclidBlog/Programs/Programs-04.wl\">https://www.wolframcloud.com/obj/sw-blog/EuclidBlog/Programs/Programs-04.wl</a><br>\nAlso has a wonderful dependency graph of theorems!<br>\n<a href=\"https://www.wolframcloud.com/obj/sw-blog/EuclidBlog/Programs/Programs-05.wl\">https://www.wolframcloud.com/obj/sw-blog/EuclidBlog/Programs/Programs-05.wl</a><br>\nWould anyone know how to go about this? I would like to see how Mathlib has developed, i.e. what theorems by category are there (and ideally, how do the interrelate). Would web/directory scraping be the way to do it?</p>",
        "id": 373811660,
        "sender_full_name": "Jack Heseltine",
        "timestamp": 1688955156
    },
    {
        "content": "<p>I doubt looking at those mathematica notebooks is particularly helpful. There are much better metaprogramming tools available in Lean 4. Perhaps you could explain in more detail what you are looking to see?</p>",
        "id": 373812006,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1688955351
    },
    {
        "content": "<p>One useful tool (still only in a PR, so you'd need to check out a copy of <a href=\"https://github.com/leanprover-community/mathlib4/pull/5513\">#5513</a>) is <code>lake exe graph</code>, which draws visualisation of the import graph.</p>",
        "id": 373812150,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1688955411
    },
    {
        "content": "<p>For the whole library there is just too much information there (let alone any visualisation at theorem level of granularity), but the <code>--to</code> and <code>--from</code> flags let you zoom in to parts of the import hierarchy.</p>",
        "id": 373812226,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1688955447
    },
    {
        "content": "<p>Also, remember that that the directory structure in Mathlib is fairly ad-hoc and to a large extent based on historical accident, so be very skeptical of any \"overview\" based on analyzing file names or namespaces!</p>",
        "id": 373812346,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1688955509
    },
    {
        "content": "<p>Overall, I would say Mathlib is already too big to \"get a sense of all the theorems\" in any meaningful! I'm sure every expert here is regularly surprised to find that something is, or is not, in the library. (Within specific areas this is not true.)</p>",
        "id": 373812730,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1688955701
    },
    {
        "content": "<p>Hi, looking into the tool! Thanks. The context is, I would for example like to situate the theorem \"nat.prime.dvd_of_dvd_pow\" (how do I find the name of this? I posted in the new members forum as well) in the way it is done in that kind of import graph: Alternatively I would like to look at that area of Mathlib (<a href=\"http://nat.prime\">nat.prime</a>), which would also be helpful.</p>",
        "id": 373819937,
        "sender_full_name": "Jack Heseltine",
        "timestamp": 1688959630
    },
    {
        "content": "<p>I am comparing to a similar visualization done using this tool: <a href=\"https://github.com/minchaowu/mm-lean\">https://github.com/minchaowu/mm-lean</a> So this has a bit of a Mathematica slant, what I am trying to do, that is why I reference the notebooks.</p>",
        "id": 373820134,
        "sender_full_name": "Jack Heseltine",
        "timestamp": 1688959743
    },
    {
        "content": "<blockquote>\n<p>how do I find the name of this?</p>\n</blockquote>\n<p>We try to give lemmas very predictable names based on their types. It would be nice to have something like <a href=\"https://hoogle.haskell.org/\">https://hoogle.haskell.org/</a> in the future though.</p>",
        "id": 373820808,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688960088
    },
    {
        "content": "<p>With ~100K theorems (slightly less if you grep for <code>^theorem</code>, more if you count autogenerated theorems; we have 130K <code>#align</code>s) it's hard to find something using graph visualization.</p>",
        "id": 373821065,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688960211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Metamathematics.3A.20Theorems.20by.20Domain.20Areas/near/373821065\">said</a>:</p>\n<blockquote>\n<p>With ~100K theorems (slightly less if you grep for <code>^theorem</code>, more if you count autogenerated theorems; we have 130K <code>#align</code>s) it's hard to find something using graph visualization.</p>\n</blockquote>\n<p>Can I follow up on this? The 100K, how might I get a number like that by grepping or similar? I am running a regex python script on my download of <a href=\"https://github.com/leanprover-community/mathlib\">https://github.com/leanprover-community/mathlib</a> and particularly the src folder but getting a much lower number, 2-3K for \"lemma\", 1-2K for \"theorem\".</p>",
        "id": 374076625,
        "sender_full_name": "Jack Heseltine",
        "timestamp": 1689020597
    },
    {
        "content": "<p>My script is: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">count_files</span><span class=\"o\">(</span><span class=\"n\">path</span><span class=\"o\">,</span> <span class=\"n\">regex</span><span class=\"o\">):</span>\n    <span class=\"n\">regObj</span> <span class=\"bp\">=</span> <span class=\"n\">re.compile</span><span class=\"o\">(</span><span class=\"n\">regex</span><span class=\"o\">)</span>\n    <span class=\"n\">ct</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n    <span class=\"n\">for</span> <span class=\"n\">root</span><span class=\"o\">,</span> <span class=\"n\">dirs</span><span class=\"o\">,</span> <span class=\"n\">fnames</span> <span class=\"k\">in</span> <span class=\"n\">os.walk</span><span class=\"o\">(</span><span class=\"n\">path</span><span class=\"o\">):</span>\n        <span class=\"n\">for</span> <span class=\"n\">fname</span> <span class=\"k\">in</span> <span class=\"n\">fnames</span><span class=\"o\">:</span>\n            <span class=\"n\">file_path</span> <span class=\"bp\">=</span> <span class=\"n\">os.path.join</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">,</span> <span class=\"n\">fname</span><span class=\"o\">)</span>\n            <span class=\"k\">with</span> <span class=\"kn\">open</span><span class=\"o\">(</span><span class=\"n\">file_path</span><span class=\"o\">,</span> <span class=\"sc\">'r'</span><span class=\"o\">,</span> <span class=\"n\">errors</span><span class=\"bp\">='</span><span class=\"n\">ignore'</span><span class=\"o\">)</span> <span class=\"n\">as</span> <span class=\"n\">f</span><span class=\"o\">:</span>\n                <span class=\"n\">content</span> <span class=\"bp\">=</span> <span class=\"n\">f.read</span><span class=\"o\">()</span>\n                <span class=\"k\">if</span> <span class=\"n\">regObj.search</span><span class=\"o\">(</span><span class=\"n\">content</span><span class=\"o\">):</span>\n                    <span class=\"n\">ct</span> <span class=\"bp\">+=</span> <span class=\"mi\">1</span>\n    <span class=\"n\">return</span> <span class=\"n\">ct</span>\n\n<span class=\"n\">print</span><span class=\"o\">(</span><span class=\"n\">count_files</span><span class=\"o\">(</span><span class=\"bp\">'...\\\\</span><span class=\"n\">mathlib</span><span class=\"bp\">\\\\</span><span class=\"n\">src</span><span class=\"bp\">\\\\.'</span><span class=\"o\">,</span> <span class=\"n\">r'lemma'</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 374076771,
        "sender_full_name": "Jack Heseltine",
        "timestamp": 1689020643
    },
    {
        "content": "<p>Lean has very strong introspection capabilities that allow a much more precise count.</p>",
        "id": 374076798,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1689020646
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Metamathematics.3A.20Theorems.20by.20Domain.20Areas/near/374076798\">said</a>:</p>\n<blockquote>\n<p>Lean has very strong introspection capabilities that allow a much more precise count.</p>\n</blockquote>\n<p>Oh, could you tell me more/refer me to the docs? Sorry, still learning.</p>",
        "id": 374076877,
        "sender_full_name": "Jack Heseltine",
        "timestamp": 1689020677
    },
    {
        "content": "<p>You seem to be counting files that contain lemmas, not lemmas themselves.</p>",
        "id": 374077014,
        "sender_full_name": "Reid Barton",
        "timestamp": 1689020735
    },
    {
        "content": "<p>A little hard to tell: see <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> for formatting tips</p>",
        "id": 374077058,
        "sender_full_name": "Reid Barton",
        "timestamp": 1689020761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Metamathematics.3A.20Theorems.20by.20Domain.20Areas/near/374077058\">said</a>:</p>\n<blockquote>\n<p>A little hard to tell: see <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> for formatting tips</p>\n</blockquote>\n<p>fixed</p>",
        "id": 374077552,
        "sender_full_name": "Jack Heseltine",
        "timestamp": 1689020932
    },
    {
        "content": "<p>For a <em>very</em> naïve count</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">git</span> <span class=\"n\">ls</span><span class=\"bp\">-</span><span class=\"n\">files</span> <span class=\"s2\">\"*.lean\"</span> <span class=\"bp\">|</span> <span class=\"n\">xargs</span> <span class=\"n\">grep</span> <span class=\"s2\">\"^theorem\"</span> <span class=\"bp\">|</span> <span class=\"n\">wc</span> <span class=\"bp\">-</span><span class=\"n\">l</span>\n</code></pre></div>\n<p>yields 91728 hits.</p>",
        "id": 374077629,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1689020963
    },
    {
        "content": "<p>Or</p>\n<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"gp\">$ </span>git<span class=\"w\"> </span>grep<span class=\"w\"> </span><span class=\"s1\">'^\\(@\\[[^]]*\\]\\)\\? *\\(theorem\\|lemma\\)'</span><span class=\"w\"> </span><span class=\"p\">|</span><span class=\"w\"> </span>wc<span class=\"w\"> </span>-l\n<span class=\"go\">93731</span>\n<span class=\"gp\">$ </span>git<span class=\"w\"> </span>grep<span class=\"w\"> </span><span class=\"s1\">'^#align'</span><span class=\"w\"> </span><span class=\"s1\">'*.lean'</span><span class=\"w\"> </span><span class=\"p\">|</span><span class=\"w\"> </span>wc<span class=\"w\"> </span>-l\n<span class=\"go\">130828</span>\n</code></pre></div>",
        "id": 374078720,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689021324
    },
    {
        "content": "<blockquote>\n<p><code>('...\\\\mathlib\\\\src\\\\.', r'lemma')</code></p>\n</blockquote>\n<p>I suspect you don't fully understand what <code>r''</code> means in python.</p>",
        "id": 374079208,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1689021517
    },
    {
        "content": "<p>You're using it where it does nothing and don't use it where it would be useful.</p>",
        "id": 374079255,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1689021537
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631270\">Jack Heseltine</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Metamathematics.3A.20Theorems.20by.20Domain.20Areas/near/374076877\">said</a>:</p>\n<blockquote>\n<p>Oh, could you tell me more/refer me to the docs? Sorry, still learning.</p>\n</blockquote>\n<p>A good place to start is the Lean4 metaprogramming book: <a href=\"https://github.com/arthurpaulino/lean4-metaprogramming-book\">https://github.com/arthurpaulino/lean4-metaprogramming-book</a></p>",
        "id": 374079334,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1689021562
    },
    {
        "content": "<p>You may want to google python raw string</p>",
        "id": 374079361,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1689021577
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Metamathematics.3A.20Theorems.20by.20Domain.20Areas/near/374078720\">said</a>:</p>\n<blockquote>\n<p>Or</p>\n<p><div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"gp\">$ </span>git<span class=\"w\"> </span>grep<span class=\"w\"> </span><span class=\"s1\">'^\\(@\\[[^]]*\\]\\)\\? *\\(theorem\\|lemma\\)'</span><span class=\"w\"> </span><span class=\"p\">|</span><span class=\"w\"> </span>wc<span class=\"w\"> </span>-l\n<span class=\"go\">93731</span>\n<span class=\"gp\">$ </span>git<span class=\"w\"> </span>grep<span class=\"w\"> </span><span class=\"s1\">'^#align'</span><span class=\"w\"> </span><span class=\"s1\">'*.lean'</span><span class=\"w\"> </span><span class=\"p\">|</span><span class=\"w\"> </span>wc<span class=\"w\"> </span>-l\n<span class=\"go\">130828</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks Yury, Damiano and Patrick, still trying to reproduce in Python, taking all the feedback into account. I am getting close (slightly over), in case anyone has a Python suggestion (comparing to Yury's \"$ git grep '^\\(@\\[[^]]*\\]\\)\\? *\\(theorem\\|lemma\\)' | wc -l\" which gives 93731):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">count_occurrences</span><span class=\"o\">(</span><span class=\"n\">path</span><span class=\"o\">,</span> <span class=\"n\">regex</span><span class=\"o\">):</span>\n    <span class=\"n\">regObj</span> <span class=\"bp\">=</span> <span class=\"n\">re.compile</span><span class=\"o\">(</span><span class=\"n\">regex</span><span class=\"o\">)</span>\n    <span class=\"n\">count</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n    <span class=\"n\">for</span> <span class=\"n\">root</span><span class=\"o\">,</span> <span class=\"n\">dirs</span><span class=\"o\">,</span> <span class=\"n\">fnames</span> <span class=\"k\">in</span> <span class=\"n\">os.walk</span><span class=\"o\">(</span><span class=\"n\">path</span><span class=\"o\">):</span>\n        <span class=\"n\">for</span> <span class=\"n\">fname</span> <span class=\"k\">in</span> <span class=\"n\">fnames</span><span class=\"o\">:</span>\n            <span class=\"n\">file_path</span> <span class=\"bp\">=</span> <span class=\"n\">os.path.join</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">,</span> <span class=\"n\">fname</span><span class=\"o\">)</span>\n            <span class=\"k\">with</span> <span class=\"kn\">open</span><span class=\"o\">(</span><span class=\"n\">file_path</span><span class=\"o\">,</span> <span class=\"sc\">'r'</span><span class=\"o\">,</span> <span class=\"n\">errors</span><span class=\"bp\">='</span><span class=\"n\">ignore'</span><span class=\"o\">)</span> <span class=\"n\">as</span> <span class=\"n\">f</span><span class=\"o\">:</span>\n                <span class=\"n\">content</span> <span class=\"bp\">=</span> <span class=\"n\">f.read</span><span class=\"o\">()</span>\n                <span class=\"n\">matches</span> <span class=\"bp\">=</span> <span class=\"n\">regObj.findall</span><span class=\"o\">(</span><span class=\"n\">content</span><span class=\"o\">)</span>\n                <span class=\"n\">count</span> <span class=\"bp\">+=</span> <span class=\"n\">len</span><span class=\"o\">(</span><span class=\"n\">matches</span><span class=\"o\">)</span>\n    <span class=\"n\">return</span> <span class=\"n\">count</span>\n\n<span class=\"n\">print</span><span class=\"o\">(</span><span class=\"n\">count_occurrences</span><span class=\"o\">(</span><span class=\"bp\">'</span><span class=\"n\">C</span><span class=\"o\">:</span><span class=\"bp\">\\\\..\\\\</span><span class=\"n\">mathlib</span><span class=\"bp\">\\\\</span><span class=\"n\">src'</span><span class=\"o\">,</span> <span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"kd\">theorem</span><span class=\"bp\">|</span><span class=\"kd\">lemma</span><span class=\"o\">)</span><span class=\"bp\">'</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I assume it is the missing caret ^ to mark the occurrence at the beginning but if I do \"print(count_occurrences('C:\\\\..\\\\mathlib\\\\src', '(^theorem|^lemma)'))\" I actually get 0 results, which has me confused at this point.</p>\n<p>Using it the way as printed gives me 102132 at the moment.</p>",
        "id": 374084926,
        "sender_full_name": "Jack Heseltine",
        "timestamp": 1689023434
    },
    {
        "content": "<p>I would strongly discourage spending any more time trying to do this counting with regex; there are lots of theorems that you will never find without implementing a full lean parser. Handily, we already have one of those!</p>",
        "id": 374087223,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689024368
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Metamathematics.3A.20Theorems.20by.20Domain.20Areas/near/374087223\">said</a>:</p>\n<blockquote>\n<p>I would strongly discourage spending any more time trying to do this counting with regex; there are lots of theorems that you will never find without implementing a full lean parser. Handily, we already have one of those!</p>\n</blockquote>\n<p>Ok, got it. I am reading the Lean programming book but would you want to go into how you would do it, Lean-natively?</p>",
        "id": 374087910,
        "sender_full_name": "Jack Heseltine",
        "timestamp": 1689024633
    },
    {
        "content": "<p>Ultimately you look for the function that says \"give me everything in the environment\", and then filter it for things that are theorems (as opposed to definitions or axioms). In the same way as in python, you'd use <code>dir(some_module)</code> or <code>globals()</code> instead of loading in the source code.</p>",
        "id": 374089667,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689025325
    },
    {
        "content": "<p>In lean 3 it was <a href=\"https://leanprover-community.github.io/mathlib_docs/find/environment.get_decls\">docs3#environment.get_decls</a></p>",
        "id": 374089697,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689025341
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">State</span> <span class=\"n\">where</span>\n  <span class=\"kd\">axioms</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">defs</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">thms</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">inductives</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">ctors</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">other</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"count_decls\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">consts</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kd\">constants</span>\n  <span class=\"k\">let</span> <span class=\"n\">update</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ConstantInfo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"n\">c.isUnsafe</span> <span class=\"k\">then</span> <span class=\"n\">s</span> <span class=\"k\">else</span>\n    <span class=\"k\">match</span> <span class=\"n\">c</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">axiomInfo</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"kd\">axioms</span> <span class=\"o\">:=</span> <span class=\"n\">s.axioms</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">defnInfo</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">defs</span> <span class=\"o\">:=</span> <span class=\"n\">s.defs</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">thmInfo</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">thms</span> <span class=\"o\">:=</span> <span class=\"n\">s.thms</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inductInfo</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">inductives</span> <span class=\"o\">:=</span> <span class=\"n\">s.inductives</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ctorInfo</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">ctors</span> <span class=\"o\">:=</span> <span class=\"n\">s.ctors</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"n\">other</span> <span class=\"o\">:=</span> <span class=\"n\">s.other</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">State</span> <span class=\"o\">:=</span> <span class=\"n\">consts.fold</span> <span class=\"n\">update</span> <span class=\"o\">{}</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{repr s}\"</span>\n\n<span class=\"n\">count_decls</span>\n</code></pre></div>",
        "id": 374090639,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689025696
    },
    {
        "content": "<p>This gives</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span> <span class=\"kd\">axioms</span> <span class=\"o\">:=</span> <span class=\"mi\">6</span><span class=\"o\">,</span>\n  <span class=\"n\">defs</span> <span class=\"o\">:=</span> <span class=\"mi\">156316</span><span class=\"o\">,</span>\n  <span class=\"n\">thms</span> <span class=\"o\">:=</span> <span class=\"mi\">155485</span><span class=\"o\">,</span>\n  <span class=\"n\">inductives</span> <span class=\"o\">:=</span> <span class=\"mi\">3413</span><span class=\"o\">,</span>\n  <span class=\"n\">ctors</span> <span class=\"o\">:=</span> <span class=\"mi\">5010</span><span class=\"o\">,</span>\n  <span class=\"n\">other</span> <span class=\"o\">:=</span> <span class=\"mi\">5455</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>(Edit: I changed it to count only declarations not marked \"unsafe\", which excludes only things not having to do with proving theorems.)</p>",
        "id": 374091112,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689025866
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Environment.constants#doc\">docs#Lean.Environment.constants</a></p>",
        "id": 374091490,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689026023
    },
    {
        "content": "<p>If you want to see the six defined axioms, an easy way is to change line 19 to <code>| .axiomInfo .. =&gt; dbg_trace \"axiom: {n}\"; {s with axioms := s.axioms + 1}</code>. Here they are:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span><span class=\"o\">:</span> <span class=\"n\">sorryAx</span>\n<span class=\"kd\">axiom</span><span class=\"o\">:</span> <span class=\"n\">Quot.sound</span>\n<span class=\"kd\">axiom</span><span class=\"o\">:</span> <span class=\"n\">Lean.ofReduceNat</span>\n<span class=\"kd\">axiom</span><span class=\"o\">:</span> <span class=\"n\">propext</span>\n<span class=\"kd\">axiom</span><span class=\"o\">:</span> <span class=\"n\">Lean.ofReduceBool</span>\n<span class=\"kd\">axiom</span><span class=\"o\">:</span> <span class=\"n\">Classical.choice</span>\n</code></pre></div>",
        "id": 374092671,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689026473
    },
    {
        "content": "<p>I'm curious how many of those defs are morally theorems (from what I remember things in Prop like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype.property#doc\">docs#Subtype.property</a> end up as defs)</p>",
        "id": 374094207,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689027087
    },
    {
        "content": "<p>Yeah, also there are probably lots of metaprogramming-generated def theorems. Here's a count that splits up the definition count into defs that are  strictly<code>Prop</code>-valued (\"<code>defThms</code>\") and the rest of the <code>defs</code>. (Edit: and theorems that aren't strictly <code>Prop</code>-valued, \"<code>thmDefs</code>\")</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>import Mathlib\n\nopen Lean Elab\n\nstructure State where\n  axioms : Nat := 0\n  defs : Nat := 0\n  defThms : Nat := 0\n  thms : Nat := 0\n  inductives : Nat := 0\n  ctors : Nat := 0\n  other : Nat := 0\n  deriving Repr\n\nelab &quot;count_decls&quot; : command =&gt; do\n  let consts := (← getEnv).constants\n  let update (s : State) (_ : Name) (c : ConstantInfo) : Command.CommandElabM State :=\n    if c.isUnsafe then return s else\n    match c with\n    | .axiomInfo .. =&gt; return {s with axioms := s.axioms + 1}\n    | .defnInfo .. =&gt; do\n      if ← Command.liftTermElabM (Meta.isProp c.type) then\n        return {s with defThms := s.defThms + 1}\n      else\n        return {s with defs := s.defs + 1}\n    | .thmInfo .. =&gt; do\n      if ← Command.liftTermElabM (Meta.isProp c.type) then\n        return {s with thms := s.thms + 1}\n      else\n        return {s with thmDefs := s.thmDefs + 1}\n    | .inductInfo .. =&gt; return {s with inductives := s.inductives + 1}\n    | .ctorInfo .. =&gt; return {s with ctors := s.ctors + 1}\n    | _ =&gt; return {s with other := s.other + 1}\n  let s : State ← consts.foldM update {}\n  logInfo s!&quot;{repr s}&quot;\n\ncount_decls\n</code></pre></div>\n</div></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">{ axioms := 6,</span>\n<span class=\"cm\">  defs := 89384,</span>\n<span class=\"cm\">  defThms := 66936,</span>\n<span class=\"cm\">  thms := 155474,</span>\n<span class=\"cm\">  thmDefs := 11,</span>\n<span class=\"cm\">  inductives := 3413,</span>\n<span class=\"cm\">  ctors := 5010,</span>\n<span class=\"cm\">  other := 5455 }</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 374095894,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689027873
    },
    {
        "content": "<p>Wow, that's almost an order of magnitude larger than I expected</p>",
        "id": 374097206,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689028541
    },
    {
        "content": "<p>I assume there are almost no thmDefs</p>",
        "id": 374097227,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689028555
    },
    {
        "content": "<p>There are 11:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">thmDef</span><span class=\"o\">:</span> <span class=\"n\">Nat.caseStrongInductionOn</span>\n<span class=\"n\">thmDef</span><span class=\"o\">:</span> <span class=\"n\">Nat.div.inductionOn</span>\n<span class=\"n\">thmDef</span><span class=\"o\">:</span> <span class=\"n\">HEq.ndrec</span>\n<span class=\"n\">thmDef</span><span class=\"o\">:</span> <span class=\"n\">WellFounded.recursion</span>\n<span class=\"n\">thmDef</span><span class=\"o\">:</span> <span class=\"n\">HEq.elim</span>\n<span class=\"n\">thmDef</span><span class=\"o\">:</span> <span class=\"n\">Nat.strongInductionOn</span>\n<span class=\"n\">thmDef</span><span class=\"o\">:</span> <span class=\"n\">Lean.Data.AC.List.two_step_induction</span>\n<span class=\"n\">thmDef</span><span class=\"o\">:</span> <span class=\"n\">Nat.div.inductionOn._unary</span>\n<span class=\"n\">thmDef</span><span class=\"o\">:</span> <span class=\"n\">HEq.ndrecOn</span>\n<span class=\"n\">thmDef</span><span class=\"o\">:</span> <span class=\"n\">Lean.Data.AC.Context.unwrap_isNeutral</span>\n<span class=\"n\">thmDef</span><span class=\"o\">:</span> <span class=\"n\">Nat.mod.inductionOn</span>\n</code></pre></div>",
        "id": 374097714,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1689028802
    },
    {
        "content": "<p>what are the 6 axioms? I'm guessing the 3 usual ones plus the other constants involved in defining <code>Quot</code>?</p>",
        "id": 374131244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1689047105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Metamathematics.3A.20Theorems.20by.20Domain.20Areas/near/374092671\">said</a>:</p>\n<blockquote>\n<p>If you want to see the six defined axioms, an easy way is to change line 19 to <code>| .axiomInfo .. =&gt; dbg_trace \"axiom: {n}\"; {s with axioms := s.axioms + 1}</code>. Here they are:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span><span class=\"o\">:</span> <span class=\"n\">sorryAx</span>\n<span class=\"kd\">axiom</span><span class=\"o\">:</span> <span class=\"n\">Quot.sound</span>\n<span class=\"kd\">axiom</span><span class=\"o\">:</span> <span class=\"n\">Lean.ofReduceNat</span>\n<span class=\"kd\">axiom</span><span class=\"o\">:</span> <span class=\"n\">propext</span>\n<span class=\"kd\">axiom</span><span class=\"o\">:</span> <span class=\"n\">Lean.ofReduceBool</span>\n<span class=\"kd\">axiom</span><span class=\"o\">:</span> <span class=\"n\">Classical.choice</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 374132348,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689047884
    },
    {
        "content": "<p>oh, that makes sense</p>",
        "id": 374132644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1689048060
    }
]