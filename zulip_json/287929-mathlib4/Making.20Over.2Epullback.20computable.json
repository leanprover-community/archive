[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/31033\">#31033</a> I am making <code>Over.pullback</code> computable (at least not noncomputable). This is part of (re)developing the theory of locally cartesian closed categories (LCCCs) (see old <a href=\"https://github.com/leanprover-community/mathlib4/pull/22340\">#22340</a>), using <code>ChosenPullback.pullback</code> instead of already existing <code>Over.pullback</code>. </p>\n<p><code>Over.pullback</code> defined in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Comma/Over/Pullback\">Comma.Over.Pullback</a> uses <code>pullback</code> and the limit API which uses choice, hence noncomputable. </p>\n<p>One advantage gained by building LCCCs on <code>ChosenPullback.pullback</code> instead is that in the category of types we have <code>ChosenPullbacks</code>, and indeed we get good defeq properties:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pullbackObj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Types</span><span class=\"bp\">.</span><span class=\"n\">PullbackObj</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ChosenPullbacks</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ChosenPullbacks</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>etc. Moreover right adjoint to <code>ChosenPullback.pullback</code> (namely the pushforward functor) is then computed by <code>Œ†</code>, i.e. the dependent function type.</p>\n<p>Here comes the <strong>question</strong>:</p>\n<p>In developing LCCCs I need  <code>toOver (I : C) : C ‚•§ Over I</code> which is the computable version of already existing<code>Over.star</code> and also <code>toOverUnit : C ‚•§ Over (ùüô_ C)</code>. These  are defined in <a href=\"https://github.com/leanprover-community/mathlib4/pull/30373\">#30373</a> but assuming a <code>CartesianMonoidalCategory</code> structure on <code>C</code>. They can be defined more generally though: <code>toOver </code> uses only <code>ChosenBinaryProduct</code> and <code>toOverUnit</code> could be written in a way to use only <code>ChosenTerminal</code>.</p>\n<p>But afaik we don't have <code>ChosenBinaryProduct</code> and <code>ChosenTerminal</code>. <strong>Is it worth adding them to mathlib?</strong> </p>\n<p>Hope to hear from <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> <span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span> <span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> and anyone else who has an opinion on this.</p>",
        "id": 554096063,
        "sender_full_name": "Sina Hazratpour",
        "timestamp": 1762437464
    },
    {
        "content": "<p>I am slightly concerned if this is the right direction or if this will lead to large API duplication.</p>",
        "id": 554097695,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1762437851
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> <br>\nI should have mentioned that we had a bit of discussion on this with <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> and <span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span> about this direction. See <a href=\"https://github.com/leanprover-community/mathlib4/pull/21525\">#21525</a></p>\n<p>In the beginning that was my sense too, but so far it has not been too bad. However, with adding <code>ChosenBinaryProduct</code>¬†and¬†<code>ChosenTerminal</code> this might indeed create a lot of duplicates, thought I am curious to hear what others think. The idea of needing <code>ChosenTerminal</code> has also come up in our HoTTLean downstream project.</p>",
        "id": 554098012,
        "sender_full_name": "Sina Hazratpour",
        "timestamp": 1762437923
    },
    {
        "content": "<p>I think the choice was made to have Cartesian monoidal categories be the preferred spelling of <code>ChosenBinaryProduct</code> + <code>ChosenTerminal</code>.<br>\n I'm kind of worried that if we were to introduce these and spell things using them we'd end up with possible \"multiple spellings\" of e.g products (either the monoidal spelling, and the other), and then losing the advantage of monoidal notations (e.g coherence) when both a chosen binary and terminal are present (and for the same reason that motivated the move from <code>ChosenFiniteProducts</code> to <code>CartesianMonoidalCategory</code>, we don't want auto instances \"chosen binary products and terminal -&gt; Cartesian monoidal\" here I think?)</p>",
        "id": 554098794,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1762438092
    },
    {
        "content": "<p>^I had the same thought, how does what you envision for <code>ChosenBinaryProduct</code> compare to the now deprecated <code>ChosenFiniteProducts</code>?</p>",
        "id": 554099303,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762438198
    },
    {
        "content": "<blockquote>\n<p>See¬†<a href=\"https://github.com/leanprover-community/mathlib4/pull/21525\">#21525</a></p>\n</blockquote>\n<p>Would you mind giving a more precise link? I cannot find the relevant discussion.</p>",
        "id": 554099570,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1762438256
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> <br>\n<code>ChosenFiniteProducts</code> is the same as <code>ChosenBinaryProduct</code>¬†+¬†<code>ChosenTerminal</code> however sometimes you want one summand only because that is the weaker assumption.</p>",
        "id": 554099633,
        "sender_full_name": "Sina Hazratpour",
        "timestamp": 1762438267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Over.2Epullback.20computable/near/554099570\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>See¬†<a href=\"https://github.com/leanprover-community/mathlib4/pull/21525\">#21525</a></p>\n</blockquote>\n<p>Would you mind giving a more precise link? I cannot find the relevant discussion.</p>\n</blockquote>\n<p>Maybe <span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span>  can provide more context about his discussion with <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> about this. I'm also curious what are his motivations. My motivation is explained in above (i.e. in types we know what pullbacks are exactly and the LCCC constructs when specialized to Types should match definitionally to dependent sum and function types.)</p>",
        "id": 554100243,
        "sender_full_name": "Sina Hazratpour",
        "timestamp": 1762438404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Over.2Epullback.20computable/near/554098794\">said</a>:</p>\n<blockquote>\n<p>I think the choice was made to have Cartesian monoidal categories be the preferred spelling of <code>ChosenBinaryProduct</code> + <code>ChosenTerminal</code>.<br>\n I'm kind of worried that if we were to introduce these and spell things using them we'd end up with possible \"multiple spellings\" of e.g products (either the monoidal spelling, and the other), and then losing the advantage of monoidal notations (e.g coherence) when both a chosen binary and terminal are present (and for the same reason that motivated the move from <code>ChosenFiniteProducts</code> to <code>CartesianMonoidalCategory</code>, we don't want auto instances \"chosen binary products and terminal -&gt; Cartesian monoidal\" here I think?)</p>\n</blockquote>\n<p>That was also my sense and that is why so far I opted for <code>CartesianMonoidalCategory</code> instead of the weaker assumptions <code>ChosenBinaryProduct</code> for  defining <code>toOver (I : C) : C ‚•§ Over I</code>. But I was wondering if there could be other workarounds.</p>",
        "id": 554101068,
        "sender_full_name": "Sina Hazratpour",
        "timestamp": 1762438617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"420917\">Sina Hazratpour</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Over.2Epullback.20computable/near/554099633\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <br>\n<code>ChosenFiniteProducts</code> is the same as <code>ChosenBinaryProduct</code>¬†+¬†<code>ChosenTerminal</code> however sometimes you want one summand only because that is the weaker assumption.</p>\n</blockquote>\n<p>I'm not sure of the broader impact, but I agree this is sometimes useful.</p>",
        "id": 554101606,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762438760
    },
    {
        "content": "<p>Without seeing the discussions my first questions would be</p>\n<ol>\n<li>Is the defeq really that useful? In the end you still wouldn't be able to make them reducibly equal so that rw still wouldn't work etc and you will still need to build API on top of it. And regardless of the defeq you can always write the recursor <code>((x : X) -&gt; (y : Y) -&gt; (h : f x = g y) -&gt; P) -&gt; (pullback f g -&gt; P)</code> and it usually doesn't matter if this recursor comes from inductive types or not.</li>\n<li>If we were to adopt this, to what extent are you duplicating the <code>Mathlib/CategoryTheory/Limits/Shapes/Pullback</code> folder?</li>\n</ol>",
        "id": 554102784,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1762439070
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> My sense is that for LCCCs basically what is in <a href=\"https://github.com/leanprover-community/mathlib4/pull/31033\">#31033</a> which is to say not much. Once you obtain the adjunction, you basically use mate stuff so you don't need to work with actual pullbacks that much. I needed to prove <code>ChosenPullback</code> yields a <code>IsPullback</code> so that i could actually prove existence of pushforwards implies slices are cartesian closed (i.e. local cartesian closure). But most of the theory of LCCCs goes thru pull-push adjunction not thru API of pullbacks.</p>",
        "id": 554104258,
        "sender_full_name": "Sina Hazratpour",
        "timestamp": 1762439415
    },
    {
        "content": "<p>I think we have seen that chosen finite products are quite useful in practice. I think having a <code>ChosenPullbacks</code> class would be similarly useful.</p>",
        "id": 554104472,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1762439467
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> And my question of this thread was basically could having <code>ChosenBinaryProduct</code> be also useful, or not worth the tradeoff? </p>\n<p>For instance the category of topological spaces and local homeomorphisms does not have a terminal object but has (chosen) binary product so it is not monoidal cartesian but you could define the functor I care about </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toOver</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">CartesianMonoidalCategory</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">I</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"bp\">.</span><span class=\"n\">homMk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∑</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 554105291,
        "sender_full_name": "Sina Hazratpour",
        "timestamp": 1762439666
    },
    {
        "content": "<p>Maybe we should go all the way and make <code>ChosenLimitsOfShape</code>?</p>",
        "id": 554105595,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1762439731
    },
    {
        "content": "<p>And then you duplicate all of the limits API?</p>",
        "id": 554105773,
        "sender_full_name": "Christian Merten",
        "timestamp": 1762439778
    },
    {
        "content": "<p>It wont be too much duplication, just a thin wrapper around the existing cones and <code>IsLimit</code></p>",
        "id": 554105990,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1762439826
    },
    {
        "content": "<p>Aside: ive been thinking a lot about categorical logic recently, and having categorical constructions be computable would be genuinely useful since it would allow you to actually ‚Äúprogram‚Äù with categories.</p>",
        "id": 554106505,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1762439915
    },
    {
        "content": "<p>But to make this ergonomic, I would expect you would want to have analogs of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Limits.prod.fst#doc\">docs#Limits.prod.fst</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Limits.prod.lift#doc\">docs#Limits.prod.lift</a> etc. for every standard shape.</p>",
        "id": 554106865,
        "sender_full_name": "Christian Merten",
        "timestamp": 1762439975
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Over.2Epullback.20computable/near/554106505\">said</a>:</p>\n<blockquote>\n<p>Aside: ive been thinking a lot about categorical logic recently, and having categorical constructions be computable would be genuinely useful since it would allow you to actually ‚Äúprogram‚Äù with categories.</p>\n</blockquote>\n<p>This is close to what I had in mind as well. For say categorical semantics of lambda calculi, we sometimes care about terminal objects and products separately, and it would be nice to be able to specifically and computably specify this.</p>",
        "id": 554109262,
        "sender_full_name": "Chris Henson",
        "timestamp": 1762440391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"420917\">Sina Hazratpour</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Over.2Epullback.20computable/near/554096063\">said</a>:</p>\n<blockquote>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/31033\">#31033</a> I am making <code>Over.pullback</code> computable (at least not noncomputable).</p>\n</blockquote>\n<p>Maybe I'm reading too quickly, but I haven't seen an actual motivation behind this</p>",
        "id": 554112878,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1762441162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Over.2Epullback.20computable/near/554112878\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"420917\">Sina Hazratpour</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Over.2Epullback.20computable/near/554096063\">said</a>:</p>\n<blockquote>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/31033\">#31033</a> I am making <code>Over.pullback</code> computable (at least not noncomputable).</p>\n</blockquote>\n<p>Maybe I'm reading too quickly, but I haven't seen an actual motivation behind this</p>\n</blockquote>\n<p>Having chosen finite products is extremely useful. Without this, I would certainly not have been able to formalize the homotopy theory of simplicial sets (and having chosen pullbacks may have helped a little bit also). Similarly, we have quite explicit constructions of \"chosen\" pullbacks in certain categories, and using an explicit \"Over.pullback\" functor would make it easier to prove things (for example, in <a href=\"https://github.com/leanprover-community/mathlib4/pull/28908\">#28908</a>, I had to transport an adjunction via an isomorphism, which would be unnecessary using <code>ChosenPullbacks</code>).<br>\nSimilarly, in monoidal closed categories, the internal hom is a data: it does not have to be the right adjoint which is given by using AC.</p>",
        "id": 554119084,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1762442598
    },
    {
        "content": "<p>I am not sure there is a need for <code>ChosenTerminal</code> (why not use a <code>IsTerminal X</code> variable at all times in such situations?). For <code>ChosenBinaryProduct</code>, if significant results really need this, this could be considered, but it seems difficult to keep the monoidal notations (which is part of the very nice recent <code>CartesianMonoidalCategory</code> refactor) as <span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> pointed it out.<br>\nI am not convinced about <code>ChosenLimitsOfShape</code> because part of what the chosen finite products API facilitates is the packaging/unpackaging of binary fans into pairs of objects.</p>",
        "id": 554120571,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1762442923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Jo√´l Riou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Over.2Epullback.20computable/near/554120571\">said</a>:</p>\n<blockquote>\n<p>I am not sure there is a need for <code>ChosenTerminal</code> (why not use a <code>IsTerminal X</code> variable at all times in such situations?). For <code>ChosenBinaryProduct</code>, if significant results really need this, this could be considered, but it seems difficult to keep the monoidal notations (which is part of the very nice recent <code>CartesianMonoidalCategory</code> refactor) as <span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> pointed it out.<br>\nI am not convinced about <code>ChosenLimitsOfShape</code> because part of what the chosen finite products API facilitates is the packaging/unpackaging of binary fans into pairs of objects.</p>\n</blockquote>\n<p>If I want to say that an object <code>X : Grpd</code> is fibrant, meaning the unique map to the terminal groupoid is an isofibration, I wouldn't want that definition to have a variable <code>T : Grpd</code> satisfying <code>hT : IsTerminal T</code>. I think it is reasonable to ask for the unique map to a chosen terminal object to be an isofibration</p>",
        "id": 554165035,
        "sender_full_name": "joseph hua",
        "timestamp": 1762454681
    },
    {
        "content": "<p>This is a situation where we should use the terminal object from the limits API  (using AC) , and the isofibrations API should allow the user to specify their preferred terminal object (see <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/AlgebraicTopology/ModelCategory/IsCofibrant.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/AlgebraicTopology/ModelCategory/IsCofibrant.html</a>)<br>\nFor example, in the category of simplicial sets, there are three reasonable terminal objects : <code>‚ä•_ SSet</code>, <code>ùüô_ SSet</code> and <code>Œî[0]</code>.</p>",
        "id": 554167424,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1762455463
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"420917\">Sina Hazratpour</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Over.2Epullback.20computable/near/554096063\">said</a>:</p>\n<blockquote>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/31033\">#31033</a> I am making <code>Over.pullback</code> computable (at least not noncomputable). </p>\n</blockquote>\n<p>I'm completely in favour of this change: <code>Over.pullback</code> was intended to be computable from the start, and one of the main reasons I objected to computable pullbacks being removed was precisely for formalising LCCCs.</p>",
        "id": 554508024,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1762633036
    },
    {
        "content": "<p>out of curiosity, what kind of considerations did you have when designing the <code>ChosenPullback</code> class? Did you consider having it be a class which takes two morphisms as arguments, and contains the data of <code>IsLimit (PullbackCone.mk _ _ _)</code>? (since this would make it possible to have more control over what pullbacks do/don't have a computable/chosen representation)</p>",
        "id": 554508769,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1762633895
    },
    {
        "content": "<p>as is, maybe a better name would be <code>ChosenPullbacksAlong</code>?</p>",
        "id": 554508929,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1762634099
    },
    {
        "content": "<p>We have a general limits API which allow to construct certain (computable or not) co(cones) and <code>IsLimit/IsColimit</code> structures. For pullbacks, we have <code>PullbackCone</code> (and the noncomputable <code>IsPullback</code>).<br>\nBut, I agree that <code>ChosenPullbacksAlong</code> would be a better name (<span class=\"user-mention\" data-user-id=\"420917\">@Sina Hazratpour</span>: could you make the change?).</p>",
        "id": 554552424,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1762684082
    },
    {
        "content": "<p>I am actually not a fan of <code>ChosenPullbacksAlong</code>; <code>ChosenPullback f</code> says we have a _choice_ of _pullback_ for very morphism <code>g</code> with the same codomain as <code>f</code>, hence <code>ChosenPullback</code>.  To me, <code>ChosenPullbackAlong</code> sounds more like the category <code>C</code> has chosen pullbacks along <code>f</code>. But <code>ChosenPullback</code> is not so much the property/structure of the category but the property/structure of <code>f</code> itself. Also, <code>ChosenPullback</code> is shorter.</p>",
        "id": 554553363,
        "sender_full_name": "Sina Hazratpour",
        "timestamp": 1762685175
    },
    {
        "content": "<p>This is to parallel <code>HasPullbacksAlong</code>.</p>",
        "id": 554553414,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1762685244
    },
    {
        "content": "<p>Even for <code>HasPullback</code>, I would argue <code>HasPullback f</code> is the correct naming, and it should mean <code>\\all g, HasPullback f g</code> which is compatible with viewing <code>HasPullback</code> as a two-variable function to <code>Prop</code>.</p>",
        "id": 554553676,
        "sender_full_name": "Sina Hazratpour",
        "timestamp": 1762685568
    },
    {
        "content": "<p>We are not going to change <code>HasPullback</code>.</p>",
        "id": 554553699,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1762685599
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"420917\">Sina Hazratpour</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Making.20Over.2Epullback.20computable/near/554553363\">said</a>:</p>\n<blockquote>\n<p><code>ChosenPullback f</code> says we have a _choice_ of _pullback_ for very morphism <code>g</code> with the same codomain as <code>f</code>, hence <code>ChosenPullback</code>. To me, <code>ChosenPullbackAlong</code> sounds more like the category <code>C</code> has chosen pullbacks along <code>f</code>.</p>\n</blockquote>\n<p>You seem to be arguing that there is a difference in meaning between the names... However, to me these descriptions seem like the same thing? A pullback of <code>g</code> along <code>f</code> is precisely the right/left (i forget which one) projection from the pullback of <code>f</code> and <code>g</code>, no? So if you say for every <code>g</code>, we choose a pullback of <code>f</code> and <code>g</code>, you choose all pullbacks along <code>f</code>?</p>",
        "id": 554565704,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1762697709
    }
]