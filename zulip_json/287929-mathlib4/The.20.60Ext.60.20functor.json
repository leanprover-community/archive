[
    {
        "content": "<p>We are going to formalize the following proposition: Let <code>R</code> be a Noetherian ring, <code>M</code> a finite <code>R</code>-module, and <code>I</code> an ideal such that <code>IM ‚â† M</code>. Then all maximal <code>M</code>-sequences in <code>I</code> have the same length <code>n</code> given by</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>n</mi><mo>=</mo><mi>min</mi><mo>‚Å°</mo><mo stretchy=\"false\">{</mo><mi>i</mi><mo>:</mo><msubsup><mrow><mi mathvariant=\"normal\">Ext</mi><mo>‚Å°</mo></mrow><mi>R</mi><mi>i</mi></msubsup><mo stretchy=\"false\">(</mo><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>I</mi><mo separator=\"true\">,</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo mathvariant=\"normal\">‚â†</mo><mn>0</mn><mo stretchy=\"false\">}</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">\nn = \\min\\{i : \\operatorname{Ext}_R^i(R/I, M) \\neq 0\\}.\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">min</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1479em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">Ext</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8979em;\"><span style=\"top:-2.453em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span><span style=\"top:-3.1362em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\">ÓÄ†</span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">}</span><span class=\"mord\">.</span></span></span></span></span></p>\n<p>However I found two <code>Ext</code> functor (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Abelian.Ext#doc\">docs#CategoryTheory.Abelian.Ext</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ext#doc\">docs#Ext</a>) in Mathlib. The first <code>Ext</code> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Abelian.Ext#doc\">docs#CategoryTheory.Abelian.Ext</a> doesn't seem to have the <code>HasExt</code> instance for <code>ModuleCat</code> available, while the second <code>Ext</code> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ext#doc\">docs#Ext</a> seems to lack the long exact sequence. Are there simple ways to address these missing properties?</p>",
        "id": 510114834,
        "sender_full_name": "Yongle Hu",
        "timestamp": 1743753395
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span></p>",
        "id": 510116508,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1743753934
    },
    {
        "content": "<p>It is better to work with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Abelian.Ext#doc\">docs#CategoryTheory.Abelian.Ext</a> because <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ext#doc\">docs#Ext</a> is meant to be removed (replaced by <code>Abelian.Ext</code>) in a not so distant future.<br>\nIn <a href=\"https://github.com/leanprover-community/mathlib4/pull/19591\">#19591</a> (which should hopefully be merged soon), I show that <code>HasExt</code> holds when there are enough projectives (and that <code>Ext^0</code> compares to <code>Hom</code>), which will obviously apply to suitable categories of modules. In between, you may just use <code>HasExt</code> as a variable.<br>\n(Also, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.HasProjectiveDimensionLT#doc\">docs#CategoryTheory.HasProjectiveDimensionLT</a> could be of interest.)</p>",
        "id": 510190138,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1743770024
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631684\">Yongle Hu</span> has marked this topic as resolved.</p>",
        "id": 510211526,
        "sender_full_name": "Notification Bot",
        "timestamp": 1743775457
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631684\">Yongle Hu</span> has marked this topic as unresolved.</p>",
        "id": 510340893,
        "sender_full_name": "Notification Bot",
        "timestamp": 1743835226
    },
    {
        "content": "<p>Thank you very much for your detailed reply! Regarding <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Abelian.Ext#doc\">docs#CategoryTheory.Abelian.Ext</a>, I still have some questions:</p>\n<ol>\n<li>\n<p>I found the theorem <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.HasExt.standard#doc\">docs#CategoryTheory.HasExt.standard</a>, but I'm not sure about the meaning of this theorem. Is it saying that <code>Ext</code> can be defined in any Abelian category (even without proving there are enough projectives)?</p>\n</li>\n<li>\n<p>Currently there is the canonical map <code>(X ‚ü∂ Y) ‚Üí Ext X Y 0</code>. Can it be proven that it is an Abelian group homomorphism? Furthermore, in <code>ModuleCat R</code>, can <code>Ext X Y n</code> be equipped with an <code>R</code>-module structure?</p>\n</li>\n<li>\n<p>Is it now possible to compute <code>Ext X Y n</code> using projective resolutions?</p>\n</li>\n</ol>",
        "id": 510340900,
        "sender_full_name": "Yongle Hu",
        "timestamp": 1743835240
    },
    {
        "content": "<ol>\n<li>Yes, the point of this construction is that it can be defined in any abelian category, but the <code>Ext</code>-groups may be defined only in a higher universe.</li>\n<li>/3. Not yet in mathlib.</li>\n</ol>",
        "id": 510353083,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1743844754
    },
    {
        "content": "<p>I think the existing properties of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Abelian.Ext#doc\">docs#CategoryTheory.Abelian.Ext</a> in Mathlib together with <code>Ext X Y 0 ‚âÉ (X ‚ü∂ Y)</code> should be almost sufficient to complete our proof. Thanks a lot for your patient replies!</p>",
        "id": 510359496,
        "sender_full_name": "Yongle Hu",
        "timestamp": 1743849769
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631684\">Yongle Hu</span> has marked this topic as resolved.</p>",
        "id": 510359498,
        "sender_full_name": "Notification Bot",
        "timestamp": 1743849773
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span></p>\n<p>We are going to formalize the following proposition: (Auslander--Buchsbaum) Let <code>R</code> be a Noetherian local ring, <code>M</code> a finite <code>R</code>-module. </p>\n<p>If</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi mathvariant=\"normal\">proj‚Äâdim</mi><mo>‚Å°</mo><mi>M</mi><mo>&lt;</mo><mi mathvariant=\"normal\">‚àû</mi></mrow><annotation encoding=\"application/x-tex\">\n\\operatorname{proj\\,dim} M &lt; \\infty\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">proj</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathrm\">dim</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">‚àû</span></span></span></span></span></p>\n<p>then</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi mathvariant=\"normal\">proj</mi><mo>‚Å°</mo><mi>dim</mi><mo>‚Å°</mo><mi>M</mi><mo>+</mo><mi mathvariant=\"normal\">depth</mi><mo>‚Å°</mo><mi>M</mi><mo>=</mo><mi mathvariant=\"normal\">depth</mi><mo>‚Å°</mo><mi>R</mi><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">\n\\operatorname{proj}\\dim M + \\operatorname{depth} M = \\operatorname{depth} R.\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">proj</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">dim</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">depth</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">depth</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">.</span></span></span></span></span></p>\n<p>We'd like to find proj resolution or projective module ext to solve the question. But in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.HasProjectiveDimensionLT#doc\">docs#CategoryTheory.HasProjectiveDimensionLT</a> we do not find some of good use. We seem to think the definition of Ext in Lean cannot support us to finish the proof.</p>",
        "id": 510437562,
        "sender_full_name": "Nick_adfor",
        "timestamp": 1743908371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"877182\">Nick_adfor</span> has marked this topic as unresolved.</p>",
        "id": 510438153,
        "sender_full_name": "Notification Bot",
        "timestamp": 1743908800
    },
    {
        "content": "<p>Is there an algorithm that can be implemented in Lean for the proj resolution of an A/I where the base ring A is a complete intersection?</p>",
        "id": 510438163,
        "sender_full_name": "Nick_adfor",
        "timestamp": 1743908812
    },
    {
        "content": "<p>We even considered formalizing derived categories or triangulated categories. That's really crazy. We do need some help.</p>\n<p>(Since we haven't come up with a suitable method for this part, today our work has shifted to formalizing Koszul complex.)</p>",
        "id": 510438710,
        "sender_full_name": "Nick_adfor",
        "timestamp": 1743909247
    },
    {
        "content": "<p>The vanishing of higher  <code>Ext</code> for projective objects has been proved <a href=\"https://github.com/leanprover-community/mathlib4/blob/32f5138e6bf2d77cb4caea9118b8225123ba8d11/Mathlib/Algebra/Homology/DerivedCategory/Ext/HasEnoughProjectives.lean#L94\">here</a>.</p>",
        "id": 510438721,
        "sender_full_name": "Yongle Hu",
        "timestamp": 1743909261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"877182\">Nick_adfor</span> <a href=\"#narrow/channel/287929-mathlib4/topic/The.20.60Ext.60.20functor/near/510438710\">said</a>:</p>\n<blockquote>\n<p>We even considered formalizing derived categories or triangulated categories.</p>\n</blockquote>\n<p>Seems that there are triangulated categories in mathlib, but not derived categories.</p>",
        "id": 510455669,
        "sender_full_name": "Jz Pan",
        "timestamp": 1743923642
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/287929-mathlib4/topic/The.20.60Ext.60.20functor/near/510455669\">said</a>:</p>\n<blockquote>\n<p>Seems that there are triangulated categories in mathlib, but not derived categories.</p>\n</blockquote>\n<p>Seems you did not search very thoroughly.</p>",
        "id": 510456694,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1743924489
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Jo√´l Riou</span> <a href=\"#narrow/channel/287929-mathlib4/topic/The.20.60Ext.60.20functor/near/510456694\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/channel/287929-mathlib4/topic/The.20.60Ext.60.20functor/near/510455669\">said</a>:</p>\n<blockquote>\n<p>Seems that there are triangulated categories in mathlib, but not derived categories.</p>\n</blockquote>\n<p>Seems you did not search very thoroughly.</p>\n</blockquote>\n<p>You are right <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span> I only checked files under <code>CategoryTheory</code> directory and found nothing...</p>",
        "id": 510459550,
        "sender_full_name": "Jz Pan",
        "timestamp": 1743926839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"877182\">Nick_adfor</span> <a href=\"#narrow/channel/287929-mathlib4/topic/The.20.60Ext.60.20functor/near/510438710\">said</a>:</p>\n<blockquote>\n<p>(Since we haven't come up with a suitable method for this part, today our work has shifted to formalizing Koszul complex.)</p>\n</blockquote>\n<p>I‚Äôll allow myself to chime in this conversation as I thought about this at some point.</p>\n<p>The Koszul complex seems like something that has to be formalized at one point or an other anyway, so this might be the right thing to do. It is a fundamental construction, and if you read Serre's book \"local algebra\" it is clear that it is the backbone of this theory.</p>\n<p>I considered ways to formalize it at some point, but to me the most \"canonical\" way to do it would be to formalize arbitrary n-ary tensor products of objects in a (symmetric) monoidal category, and then apply this to the category of complexes, applied to suitable family of objects (the length 2 \"multiplication by -\" complexes if I recall correctly). I am currently thinking of a rather roundabout way of having a nice enough n-ary tensors products in arbitrary monoidal categories, but it will take time before this is usable, probably more time than you are willing to wait.</p>\n<p>I guess there would then be the issue of comparing it with the \"usual\" one, defined with exteriors powers (last time I checked, mathlib did not even have the basis of exteriors powers of a free module.)</p>\n<p>(Edit: there is of course the option of taking a shortcut and and define it directly the usual way, and that might be more suited for you need, so the above is of course a rather subjective view of the construction.)</p>\n<p>Perhaps an unprompted opinion, but I feel like this kind of commutative algebra that relies heavily on homological invariants should wait on more rock-solid homological/derived infrastructure in mathlib, and we‚Äôre slowly but surely getting there thanks to <span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span>'s work.</p>",
        "id": 510462590,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1743929080
    },
    {
        "content": "<p>On the other hand, having applications can help build solid foundations</p>",
        "id": 510462895,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1743929305
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/stream/287929-mathlib4/topic/The.20.60Ext.60.20functor/near/510462590\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"877182\">Nick_adfor</span> <a href=\"#narrow/channel/287929-mathlib4/topic/The.20.60Ext.60.20functor/near/510438710\">said</a>:</p>\n<blockquote>\n<p>(Since we haven't come up with a suitable method for this part, today our work has shifted to formalizing Koszul complex.)</p>\n</blockquote>\n<p>(Edit: there is of course the option of taking a shortcut and and define it directly the usual way, and that might be more suited for you need, so the above is of course a rather subjective view of the construction.)</p>\n<p>Perhaps an unprompted opinion, but I feel like this kind of commutative algebra that relies heavily on homological invariants should wait on more rock-solid homological/derived infrastructure in mathlib, and we‚Äôre slowly but surely getting there thanks to <span class=\"user-mention silent\" data-user-id=\"459699\">Jo√´l Riou</span>'s work.</p>\n</blockquote>\n<p>Just as you have said, I am also confused about how to choose the optimal (easiest to derive conclusions from) definition to formalize in Lean when encountering equivalent definitions in mathematics.</p>\n<p>Not far ago, I was curious of the difference between Dedekind Real Number and Cauchy Real Number. (Lean is based on Cauchy Real Number)</p>",
        "id": 510560050,
        "sender_full_name": "Nick_adfor",
        "timestamp": 1744001596
    },
    {
        "content": "<p>The actual \"under the hood\" definition of a real number should be of no interest to the general mathlib user, because the API is there enabling you to use real numbers like Euler and Riemann, who neither knew nor cared about what a real number \"actually was\". More precisely, we have proofs that mathlib's real numbers are a complete ordered Archimedean field and that, up to unique isomorphism, there is only one complete ordered Archimedean field. </p>\n<p>The situation with Koszul complexes is different. Here there is a lot of fiddling around with explicit finite complexes and techniques needed which might not be in mathlib in a convenient form.. However I agree with Ruben that having some concrete goals here is a very good way of actually informing the developmrnt of that homological API</p>",
        "id": 510567690,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744005745
    },
    {
        "content": "<p>I agree that trying to work on concrete tasks is helpful for building the homological algebra infrastructure in Mathlib. During this we can identify which properties are crucial and which APIs are convenient to use.</p>\n<p>Now we have completed the proof for the theorem I initially mentioned (in this <a href=\"https://github.com/xyzw12345/CohenMacaulay\">repo</a>). Then we will be able to define depth (maybe <code>depthGE</code>?).<br>\nAlso, we are formalizing the Koszul complex (in this <a href=\"https://github.com/mbkybky/KoszulComplex\">repo</a>) and plan to prove some properties related to the Koszul complex and regular sequences, for example, the relation of Koszul homology and <code>Hom(R/x, M/xM)</code> when <code>x</code> is a weak regular sequence.</p>\n<p>During the formalization process, we found that the results in <a href=\"https://github.com/leanprover-community/mathlib4/pull/19591\">#19591</a> is critical to our proof. Additionally, since the vanishing of <code>Ext X I (n + 1)</code> for an injective object <code>I</code> hasn't been proven yet, some parts of the proof are slightly more complicated. We also found that the universe levels in many homological algebra results are unsatisfactory, for example, the fact that <code>ModuleCat</code> has enough projectives is currently only proven when the module <code>M</code>'s universe level is <code>max u v</code> (I've opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/23690\">#23690</a> to address this), and the tensor product functor in <code>ModuleCat</code> is currently only defined when the ring <code>R</code> and the module <code>M</code> share the same universe level.</p>",
        "id": 510629723,
        "sender_full_name": "Yongle Hu",
        "timestamp": 1744023127
    },
    {
        "content": "<p>I would say that generalizing some results for <code>ModuleCat.{v} R</code> under the <code>[Small.{v} R]</code> assumption seems to go in the right direction, including for the monoidal category structure (even though this may break some definitional properties for the unit).<br>\nI can add dual results to <a href=\"https://github.com/leanprover-community/mathlib4/pull/19591\">#19591</a> for injective objects if there is a need.<br>\nIn general, I would say that mathlib is almost ready to have more developments for the part of local algebra which involves <code>Ext</code>-groups. For results about <code>Tor</code>, we may have to wait as it may take a certain time to obtain the monoidal category structure on the derived category (even though I have a quite precise plan). However, we already have the tensor product of chain complexes.<br>\nFor Koszul complexes, the better definition is probably using exterior powers as <span class=\"user-mention\" data-user-id=\"631684\">@Yongle Hu</span> does, but it will also be important to give concrete formulas (case of a finitely generated free module, induction, etc) which will be useful in computations.<br>\n(Note: there are some chunks of code like <a href=\"https://github.com/xyzw12345/CohenMacaulay/blob/master/CohenMacaulay/Dependency/CategoryCenter.lean\">https://github.com/xyzw12345/CohenMacaulay/blob/master/CohenMacaulay/Dependency/CategoryCenter.lean</a> which intersect with code that I have at <a href=\"https://github.com/leanprover-community/mathlib4/pull/4197/files#diff-53530e7726155c41dea96c1f9436ce8e717954dbaaf92306011fe51ab4a39242\">https://github.com/leanprover-community/mathlib4/pull/4197/files#diff-53530e7726155c41dea96c1f9436ce8e717954dbaaf92306011fe51ab4a39242</a> and which shall eventually show that the derived category of a <code>R</code>-linear category if <code>R</code>-linear, and then the <code>Ext</code> are also <code>R</code>-modules.)</p>",
        "id": 510661395,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1744030449
    },
    {
        "content": "<p>Maybe a bit inappropriate place to ask, do anyone have a plan for <code>Tor</code> functor?<br>\n<span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span> do you have a plan for this?</p>",
        "id": 541668583,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1758893173
    },
    {
        "content": "<p>Or somebody have already (</p>",
        "id": 541668660,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1758893197
    },
    {
        "content": "<p>I have a plan, but it will take a lot of time before it can enter mathlib (see <a class=\"message-link\" href=\"/#narrow/channel/335062-homology/topic/Derived.20hom.20and.20tensor/near/518154229\">#homology &gt; Derived hom and tensor @ üí¨</a>).</p>",
        "id": 541680676,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1758896703
    },
    {
        "content": "<p>We can base our works on your branches just like what we did in the CM ring project. Only being curious, how long do you expect we can have <code>Tor</code> with linear long exact sequence?<br>\nThanks.</p>",
        "id": 541776217,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1758950263
    },
    {
        "content": "<p>I do not think it is reasonable to expect to have this in mathlib within the next six months. This is the reason I encouraged you to pursue results about <code>Ext</code> rather than <code>Tor</code>!</p>",
        "id": 541777838,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1758952089
    },
    {
        "content": "<p>Anyway, thanks for your help, we would try to use <code>Ext</code> as much as possible. Hoever then definition of betty number might be a problem, but just as what we did on projective dimension, there might be a way through(:</p>",
        "id": 541809300,
        "sender_full_name": "Nailin Guan",
        "timestamp": 1758982168
    }
]