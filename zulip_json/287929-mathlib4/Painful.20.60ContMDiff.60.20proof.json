[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/22784\">#22784</a>, I'm trying to prove <code>Diffeomorph.sumSumSumComm</code> (for my bordism theory project). The result is painful, though:</p>\n<p>Is there a tactic I'm missing? (<code>fun_prop</code> is not set up for <code>ContMDiff</code>; I imagine it would have trouble guessing the intermediate models <code>I</code>.) Or should I be writing lots of <code>Diffeomorph.trans</code>? (Doing that naively fails, but it's conceivable it could work with <em>lots</em> of additional type annotations.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Four-way commutativity of the disjoint union of manifolds -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sumSumSumComm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Diffeomorph</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">N'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">N'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toEquiv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">sumSumSumComm</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">N'</span>\n<span class=\"w\">  </span><span class=\"n\">contMDiff_toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Please, tell me there is a tactic for this! Or is there a better way?</span>\n<span class=\"w\">    </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">sumSumSumComm</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- change ContMDiff I I n ((Diffeomorph.sumAssoc I (M ⊕ N) n M' N') ∘</span>\n<span class=\"w\">    </span><span class=\"c1\">--   (Diffeomorph.sumCongr ((Diffeomorph.sumAssoc I M n N M').symm) (Diffeomorph.refl I N' n)) ∘</span>\n<span class=\"w\">    </span><span class=\"c1\">--   Diffeomorph.sumCongr</span>\n<span class=\"w\">    </span><span class=\"c1\">--     (Diffeomorph.sumCongr (Diffeomorph.refl I M n) (Diffeomorph.sumComm I M' n N))</span>\n<span class=\"w\">    </span><span class=\"c1\">--     (Diffeomorph.refl I _ n) ∘</span>\n<span class=\"w\">    </span><span class=\"c1\">--   (Diffeomorph.sumCongr (Diffeomorph.sumAssoc I M n M' N) (Diffeomorph.refl I _ n)) ∘</span>\n<span class=\"w\">    </span><span class=\"c1\">--   (Diffeomorph.sumAssoc I (M ⊕ M') n N N').symm)</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">ContMDiff</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Diffeomorph</span><span class=\"bp\">.</span><span class=\"n\">contMDiff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sumAssoc</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"w\"> </span><span class=\"n\">N'</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">ContMDiff</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Diffeomorph</span><span class=\"bp\">.</span><span class=\"n\">contMDiff</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">sumAssoc</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">sumCongr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Diffeomorph</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">N'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">ContMDiff</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Diffeomorph</span><span class=\"bp\">.</span><span class=\"n\">contMDiff</span>\n<span class=\"w\">            </span><span class=\"o\">(((</span><span class=\"n\">Diffeomorph</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sumCongr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sumComm</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sumCongr</span>\n<span class=\"w\">              </span><span class=\"o\">(</span><span class=\"n\">Diffeomorph</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">N'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"w\">        </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">ContMDiff</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Diffeomorph</span><span class=\"bp\">.</span><span class=\"n\">contMDiff</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">sumAssoc</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sumCongr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Diffeomorph</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">N'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"w\">          </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Diffeomorph</span><span class=\"bp\">.</span><span class=\"n\">contMDiff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sumAssoc</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">N'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"n\">contMDiff_invFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- omitted</span>\n</code></pre></div>",
        "id": 504598607,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1741616770
    },
    {
        "content": "<p>I would like <code>fun_prop</code> to be able to solve this and as you exactly pointed out, the issue is the intermediate model <code>I'</code>. There has to be some heuristic on how to pick it, or maybe I can keep it as a meta variable as long as possible and somehow resolve it at the end. </p>\n<p>Anyway, if you have more examples of tedious proofs like this send them my way. I would like to have a look at this at some point.</p>",
        "id": 504614577,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1741619881
    },
    {
        "content": "<p>I haven't looked at differential geometry design decisions since Lean 4. <br>\nShould we investigate whether it is possible to make <code>I</code> an <code>outParam</code> in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsManifold#doc\">docs#IsManifold</a> ? If that is possible, that would clean-up the manifold library substantially. A disadvantage is that we would require type synonyms whenever we change the field/model space, but that seems like a very small price to pay.</p>",
        "id": 504637506,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1741624681
    },
    {
        "content": "<p>Two other design decisions in the manifold library that should probably be changed/investigated:</p>\n<ul>\n<li><del>Is the library note <code>Manifold type tags</code> still relevant in Lean 4 now that we have structure-eta?</del> (also rebutted by Sebastien below)</li>\n<li>Change the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ModelWithCorners#doc\">docs#ModelWithCorners</a> (see discussion in <a href=\"https://github.com/leanprover-community/mathlib4/pull/18403\">#18403</a>)</li>\n</ul>",
        "id": 504637958,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1741624794
    },
    {
        "content": "<p>No, it's not possible to make <code>I</code> an outparam, because <code>E x F</code> is a manifold in two different ways, when <code>E</code> and <code>F</code> are vector spaces: it's a product manifold (as the product of two manifolds), and it's a manifold because it's a vector space. Those two ways to be a manifold are not defeq, and to avoid diamonds they don't correspond to the same model with corners.</p>",
        "id": 504643846,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1741626468
    },
    {
        "content": "<p>That makes it indeed tricky. It might still be possible to do this if we add a type synonym for \"treat this vector space as a manifold\". Then a vector space is only a manifold when using the type synonym, and the product is an instance without type synonyms. <br>\nThis change would be annoying in a lot more places, so is maybe not good. Then again, maybe not that annoying compared to the already existing type synonyms such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ModelProd#doc\">docs#ModelProd</a>.</p>",
        "id": 504657581,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1741630544
    },
    {
        "content": "<p>Here is another possibility, which would solve the prod diamond issue and make it possible to have <code>I</code> as an outparam (still depending on the field): forgetful inheritance.</p>\n<p>In normed spaces, one would add another data field <code>d</code> which would essentially be a manifold structure over itself, and a prop field saying that this manifold structure coincides propositionally with the trivial one. Associating a manifold structure to a vector space would be done through <code>d</code>. Then, when declaring the product of two vector spaces, the <code>d</code> of the product would match exactly the one that is done when building the product of two manifolds. In this way, given <code>E</code> and <code>F</code> two vector spaces, seeing <code>E</code> and <code>F</code> as manifolds and taking their product would give definitionally the same manifold structure as the one on the vector space <code>E x F</code>.</p>\n<p>I'm not sure how painful the refactor would be, but this idea seems quite promising to me. Any thoughts?</p>",
        "id": 504674298,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1741636139
    },
    {
        "content": "<p>Hmm... That's essentially what we do with MetricSpace + UniformSpace, and there it works very well. That sounds really promising.<br>\nIt would result in import increases + extra work to define normed spaces... So it's not for free.</p>",
        "id": 504699891,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1741645694
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"646363\">@Ben Eltschig</span> There is an issue with topology on product spaces and diffeology. I have a feeling that the problem is very similar as with manifolds mentioned here. Is it the case? Would the proposed solution by <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span> . also help or the opposite? (I don't fully understand the math nor the TC voodoo here so these two problems might be completely unrelated)</p>",
        "id": 504702098,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1741646734
    },
    {
        "content": "<p>In other words, if such a refactor happens it would be nice if it plays well with diffeology too. I know diffeology is not even in mathlib yet but future proofing for it would be nice and, I think, would make few physicists here happy.</p>",
        "id": 504703047,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1741647200
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> here is an example of this phenomenon which is hopefully simpler to understand than this manifold stuff. A metric space structure on a type is a bunch of data (a distance function + axioms). A topological space structure on a type is another bunch of data (a collection of open sets + axioms). It's a standard result that \"every metric space is a topological space\" i.e. given a metric space structure on a type, there is a canonical topological space structure coming from the metric. Metric spaces and topological space structures on a type are implented as classes, and one can make an instance from <code>MetricSpace X</code> to <code>TopologicalSpace X</code> to capture this construction. So far so good.</p>\n<p>It's also standard that the product of two metric spaces is a metric space, and the product of two topological spaces is a topological space. One can make these both instances too! And then bingo, you have a diamond in the typeclass system, because if you have two metric spaces X and Y, then there's two ways to get a topological space structure on the product X x Y, namely (1) take the product metric and then take the associated topology, or (2) take the associated topological spaces and then take the product topology. These two constructions are well-known to give the same answer, but the equality is not definitional, so typeclass inference breaks.</p>\n<p>The way this issue is dealt with in mathlib is that the definition of a metric space also contains all the data of a topology, plus a proof field saying that the topology is the one coming from the metric! So internally a metric space is carrying around far more data than a mathematician would expect. But this solves the diamond problem because in the definition of the product of two metric spaces, you <em>define</em> the topology on the product to be the product of the topologies, and the proof field is not <code>rfl</code>, it is where you insert this well-known mathematical proof that the two topologies (one coming from the product metric, the other coming from the product topology) are equal. </p>\n<p>So this is part of a phenomenon where you overload classes with extra information which can be derived from the data you have. It's the same sort of reason we have an action of Z in the definition of a group.</p>",
        "id": 504703102,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741647238
    },
    {
        "content": "<p>I've bent the truth a bit above: this is how it was in 2017. Now we actually have some slightly different structure called a uniform space embedded into the definition of a metric space, instead of a topological space. But the principle is exactly the same.</p>",
        "id": 504703369,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741647368
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Painful.20.60ContMDiff.60.20proof/near/504702098\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"646363\">Ben Eltschig</span> There is an issue with topology on product spaces and diffeology. I have a feeling that the problem is very similar as with manifolds mentioned here. Is it the case? Would the proposed solution by <span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> . also help or the opposite? (I don't fully understand the math nor the TC voodoo here so these two problems might be completely unrelated)</p>\n</blockquote>\n<p>The issue with product spaces and the D-topology is actually worse than this, because the D-topology genuinely does not commute with binary products - the two topologies you get on products of topological spaces are actually different, not just non-defeq. So I don't think there really is a better solution than the <code>IsDTopCompatible</code> typeclass we have now.</p>",
        "id": 504703490,
        "sender_full_name": "Ben Eltschig",
        "timestamp": 1741647430
    },
    {
        "content": "<p>Thanks a lot <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I had a very vague understanding of this but your explanation made it super clear!</p>",
        "id": 504703816,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1741647574
    },
    {
        "content": "<p>At least for the typical product types, that is - we can still introduce a type synonym that carries the topology of the product taken in the category of delta-generated spaces, and define the diffeology on it in such a way that the D-topology is defeq to the topology the type carries. I imagine a similar solution is probably getting thought about for CW complexes and products of compactly generated spaces, but I don't know for sure</p>",
        "id": 504703839,
        "sender_full_name": "Ben Eltschig",
        "timestamp": 1741647591
    },
    {
        "content": "<p>A more fitting parallel to the problem with manifolds this thread is about: the functor equipping normed spaces with their natural diffeologies <em>does</em> preserve products, but it can't be registered as an instance because the two diffeologies you get on products of normed spaces would be non-defeq despite being equal. This could in theory be fixed by making a diffeology part of the data of <code>NormedSpace</code> similar to what Sébastien suggested, but I imagine it's hard to do without creating an import loop (or even worse, an actual cyclic dependency in the definitions. Diffeologies depend on smoothness after all, which depends on normed spaces). I fear that in the case of manifolds you might run into the same problem, but that's also just a guess.</p>",
        "id": 504704418,
        "sender_full_name": "Ben Eltschig",
        "timestamp": 1741647832
    },
    {
        "content": "<p>I see, yeah I don't fully understand the math :) I just know that diffeology provides some useful theorems I want to use at some point. Thanks for the explanation!</p>",
        "id": 504704419,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1741647833
    },
    {
        "content": "<p>A slightly different question: isn't it also the case that if <code>I</code> was an outparam, it would be hard to talk about manifolds as manifolds with (empty) boundary?</p>",
        "id": 504705018,
        "sender_full_name": "Ben Eltschig",
        "timestamp": 1741648114
    },
    {
        "content": "<p>Let me revive this thread: see <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Making.20fun_prop.20support.20ContMDiff/with/555097183\">#mathlib4 &gt; Making fun_prop support ContMDiff</a></p>",
        "id": 555097277,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1762947975
    }
]