[
    {
        "content": "<p>I am here to advertise that <a href=\"https://github.com/leanprover-community/mathlib4/pull/32534\">#32534</a> contains a sorry free proof of Zariski's main theorem for affine morphisms, <a href=\"https://github.com/leanprover-community/mathlib4/blob/47345ed154e6686912f6873ef6cff2b2a405719f/Mathlib/AlgebraicGeometry/Morphisms/QuasiFinite.lean#L127\">Which says that</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">**Zariski's main theorem** for affine morphisms.</span>\n\n<span class=\"sd\">Recall that any qcqs morphism `f : X ‚ü∂ Y` factors through the relative normalization via</span>\n<span class=\"sd\">`f.toNormalization : X ‚ü∂ f.normalization` (a dominant morphism) and</span>\n<span class=\"sd\">`f.fromNormalization : f.normalization ‚ü∂ Y` (an integral morphism).</span>\n\n<span class=\"sd\">Let `f : X ‚ü∂ Y` be an affine morphism locally of finite type.</span>\n\n<span class=\"sd\">then there exists `U : f.normalization.Opens`, such that</span>\n<span class=\"sd\">1. `f.toNormalization ‚à£_ U` is an isomorphism</span>\n<span class=\"sd\">2. `f.toNormalization ‚Åª¬π·µÅ U` is the quasi-finite locus of `f`</span>\n\n<span class=\"sd\">The full version for non-affine morphisms is much harder.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[</span><span class=\"n\">stacks</span><span class=\"w\"> </span><span class=\"mi\">03</span><span class=\"n\">GT</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"bp\">.</span><span class=\"n\">Hom</span><span class=\"bp\">.</span><span class=\"n\">exists_isIso_morphismRestrict_toNormalization</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LocallyOfFiniteType</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsAffineHom</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">normalization</span><span class=\"bp\">.</span><span class=\"n\">Opens</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toNormalization</span><span class=\"w\"> </span><span class=\"bp\">‚à£_</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toNormalization</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π·µÅ</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">quasiFiniteLocus</span>\n</code></pre></div>\n<p>And I would love to see this in mathlib sooner rather than later. Here is a list of prerequisite PRs that are currently open for review, a fair chunk of them are also interesting in and of themselves.</p>\n<ul>\n<li><del>#32530: API about <code>IsDiscrete</code> (topology)</del></li>\n<li><del>#32528: Going-down for integrally closed domains</del></li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32429\">#32429</a>: <code>IsIntegrallyClosed R[X]</code></li>\n<li><del>#32375: More API for¬†<code>Ideal.ResidueField</code></del></li>\n<li><del>#32536: If <code>A/I</code> is <code>R</code>-finite and <code>I</code> is fg and nilpotent then so is <code>A</code>.</del></li>\n<li><del>#32537: Strongly transcendental elements</del></li>\n<li><del>#32596: localization commutes with integral closure</del></li>\n<li><del>#32595: \"Relative Spec for <code>ùí™‚Çì</code>-algebras\" (algebraic geometry)</del></li>\n</ul>",
        "id": 562546313,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1765223191
    },
    {
        "content": "<p>I am back with more advertisements, about applications of Zariski's main theorem:</p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/blob/c6f1b19c0e33c7be0155605faba9e84d61299690/Mathlib/CFT/IsStandardEtale.lean#L828\">etale algebras are locally standard etale</a></li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/blob/c6f1b19c0e33c7be0155605faba9e84d61299690/Mathlib/CFT/Junk.lean#L58\">etale lifting property of henselian local rings</a></li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/blob/c6f1b19c0e33c7be0155605faba9e84d61299690/Mathlib/CFT/SmoothFibers.lean#L514\">unramified + flat =&gt; etale</a> (technically doesn't need ZMT but is part of the branch anyways)</li>\n<li>classification of finite etale algebras over henselian local rings, which in turn imply <a href=\"https://github.com/leanprover-community/mathlib4/blob/c6f1b19c0e33c7be0155605faba9e84d61299690/Mathlib/CFT/ActualStuff.lean\">the classification of unramified extensions of local fields</a>. This was my main motivation and it somehow took ages.</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CFT</span><span class=\"bp\">.</span><span class=\"n\">Junk</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CFT</span><span class=\"bp\">.</span><span class=\"n\">Nonsense</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CFT</span><span class=\"bp\">.</span><span class=\"n\">SeparableResidueStruct</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">IsLocalRing</span>\n\n<span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"s2\">\"ùìÄ[\"</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"s2\">\"]\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ResidueField</span><span class=\"w\"> </span><span class=\"n\">R</span>\n<span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"s2\">\"ùìÇ[\"</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"s2\">\"]\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">maximalIdeal</span><span class=\"w\"> </span><span class=\"n\">R</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! Let `R` be a complete DVR. -/</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDomain</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDiscreteValuationRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsAdicComplete</span><span class=\"w\"> </span><span class=\"n\">ùìÇ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! ## Essentially surjective</span>\n<span class=\"cm\">    Each finite separable extension over `ùìÄ[R]` comes from some finite unramified extension. -/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">ùìÄ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"n\">ùìÄ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">IsSeparable</span><span class=\"w\"> </span><span class=\"n\">ùìÄ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsDomain</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsDiscreteValuationRing</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FaithfulSMul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Unramified</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ùìÄ</span><span class=\"o\">[</span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ‚Çê</span><span class=\"o\">[</span><span class=\"n\">ùìÄ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]]</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">ùìü</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">e</span><span class=\"bp\">‚ü©‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SeparableResidueStruct</span><span class=\"bp\">.</span><span class=\"n\">exists_of_isSeparable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">ùìü</span><span class=\"bp\">.</span><span class=\"n\">Ring</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">inferInstance</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">e</span><span class=\"bp\">‚ü©‚ü©</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">IsDomain</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDiscreteValuationRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">FaithfulSMul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Unramified</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">IsDomain</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDiscreteValuationRing</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">FaithfulSMul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Unramified</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! ## Full</span>\n<span class=\"cm\">    Every map between residue fields lifts to a map between the unramified extension. -/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùìÄ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚Üí‚Çê</span><span class=\"o\">[</span><span class=\"n\">ùìÄ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]]</span><span class=\"w\"> </span><span class=\"n\">ùìÄ</span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚Üí‚Çê</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">ResidueField</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">toRingHom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toRingHom</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">‚ü®_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HenselianLocalRing</span><span class=\"bp\">.</span><span class=\"n\">exist_residueFieldMap_eq_of_etale</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! ## Faithful</span>\n<span class=\"cm\">    Maps between unramified extensions are equal if they are equal on the residue field. -/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">f‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùìÄ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚Üí‚Çê</span><span class=\"o\">[</span><span class=\"n\">ùìÄ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]]</span><span class=\"w\"> </span><span class=\"n\">ùìÄ</span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"o\">])</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ResidueField</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f‚ÇÅ</span><span class=\"bp\">.</span><span class=\"n\">toRingHom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ResidueField</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f‚ÇÇ</span><span class=\"bp\">.</span><span class=\"n\">toRingHom</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">HenselianLocalRing</span><span class=\"bp\">.</span><span class=\"n\">eq_of_residueFieldMap_eq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">H</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! ## Reflects isos</span>\n<span class=\"cm\">    Unramified extensions with isomorphic residue fields are isomorphic. -/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ùìÄ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ‚Çê</span><span class=\"o\">[</span><span class=\"n\">ùìÄ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]]</span><span class=\"w\"> </span><span class=\"n\">ùìÄ</span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ‚Çê</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">ResidueField</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">toRingHom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">toRingHom</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">‚ü®_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HenselianLocalRing</span><span class=\"bp\">.</span><span class=\"n\">exist_algEquiv_residueFieldMap_eq_of_etale</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"bp\">‚ü©</span>\n</code></pre></div>\n<p>All of them are sorry free and could be in mathlib today if you click the big shiny merge button <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> <br>\n(terms and conditions may apply)</p>\n<p>But if you rather review the prerequisites instead, here are the new PRs </p>\n<ul>\n<li><del>#32540: properties on <code>Algebra.TensorProduct.map</code>.</del></li>\n<li><del>#32529: etale locus</del></li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32665\">#32665</a>: quasi-finite algebras</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32617\">#32617</a>: field extension over perfect fields are smooth¬†</li>\n</ul>\n<p>Half of the PRs last time are also still open for review.</p>",
        "id": 563435086,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1765533664
    },
    {
        "content": "<p>I have merged <a href=\"https://github.com/leanprover-community/mathlib4/pull/32540\">#32540</a> and delegated <a href=\"https://github.com/leanprover-community/mathlib4/pull/32529\">#32529</a>. I would let others (who know the <code>Algebra/RingTheory</code> hierarchy better than I know) look at the two other prerequisites, but this looks great!</p>",
        "id": 563438581,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1765534816
    },
    {
        "content": "<p>Thanks a lot for the reviews! The new batch of PRs just arrived, all ready for review, and I believe we are two or three PRs away from the proof of Zariski's main theorem after they are reviewed.</p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32823\">#32823</a>: construct etale neighborhood that isolates point in fiber </li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32823\">#32823</a>: relative normalization of schemes (algebraic geometry)</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32811\">#32811</a>: the statement of Zariski's main theorem</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32809\">#32809</a>: residue field of I[X] </li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32806\">#32806</a>: base change of ideal with flat quotients </li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32803\">#32803</a>: more-linear version of tensorKaehlerEquiv</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32802\">#32802</a>: more ergonomic version of jacobi criterion for smoothness</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32837\">#32837</a>: noetherian model for etale algebras</li>\n</ul>",
        "id": 563582769,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1765588724
    },
    {
        "content": "<p>Final update (at least for this year): <br>\nI had planned to stop here but I was very surprised to learn that the full version of Zariski's main theorem also has a purely algebraic proof (i.e. no cohomology) so naturally I had to formalize it as well. This is sorry free <a href=\"https://github.com/erdOne/mathlib4/commit/ec96d9ddc513326154c74e524589fe3749019a00#diff-7a5ddc3ac54befe01d216ceba32a69a5d40d57f49990a8eaf6e175792b2b3e56R109\">here</a> in the same PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/32534\">#32534</a> as before.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"bp\">.</span><span class=\"n\">Hom</span><span class=\"bp\">.</span><span class=\"n\">exists_isIso_morphismRestrict_toNormalization</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">LocallyOfFiniteType</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsSeparated</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">QuasiCompact</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">‚àÉ</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">normalization</span><span class=\"bp\">.</span><span class=\"n\">Opens</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toNormalization</span><span class=\"w\"> </span><span class=\"bp\">‚à£_</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toNormalization</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π·µÅ</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">quasiFiniteLocus</span>\n</code></pre></div>\n<p>As a corollary, we also get that <a href=\"https://github.com/erdOne/mathlib4/commit/ec96d9ddc513326154c74e524589fe3749019a00#diff-7a5ddc3ac54befe01d216ceba32a69a5d40d57f49990a8eaf6e175792b2b3e56R235\">finite = proper + finite fibers</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">IsFinite</span><span class=\"bp\">.</span><span class=\"n\">iff_isProper_and_locallyQuasiFinite</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsFinite</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">IsProper</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">LocallyQuasiFinite</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>\n<p>One can see the currently open PRs leading toward this at <a href=\"https://github.com/leanprover-community/mathlib4/pull/32534\">#32534</a>:</p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32665\">#32665</a>: quasi-finite algebras </li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32823\">#32823</a>: construct etale neighborhood that isolates point in fiber</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32811\">#32811</a>: predicate on satisfying Zariski's main theorem</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32806\">#32806</a>: feat(RingTheory): base change of ideal with flat quotients</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32803\">#32803</a>: more-linear version of tensorKaehlerEquiv </li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/32837\">#32837</a>: noetherian model for etale algebras</li>\n</ul>",
        "id": 565848965,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1767144847
    },
    {
        "content": "<p>Could I ask someone to review <a href=\"https://github.com/leanprover-community/mathlib4/pull/32811\">#32811</a>? It had been sitting for a month now. Once this and <a href=\"https://github.com/leanprover-community/mathlib4/pull/33718\">#33718</a> are merged I think we are ready for the PR on the algebraic Zariski's main theorem.</p>",
        "id": 567618242,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1768243844
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/33469\">#33469</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/32803\">#32803</a> has been sitting for three weeks now. They are both routine generalizations of existing definitions that makes <code>R</code>-linear maps <code>S</code>-linear instead. It would be great if someone can take a look.</p>",
        "id": 569139627,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1768948343
    }
]