[
    {
        "content": "<p>In the <a href=\"https://github.com/leanprover-community/mathlib4/tree/turan\"><code>turan</code></a> branch:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">cliqueFree_of_replaceVertex_cliqueFree</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.CliqueFree</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">G.replaceVertex</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">CliqueFree</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">contrapose</span> <span class=\"n\">h</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">topEmbeddingOfNotCliqueFree</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Function.Embedding.coeFn_mk</span><span class=\"o\">,</span> <span class=\"n\">top_adj</span><span class=\"o\">,</span> <span class=\"n\">replaceVertex</span><span class=\"o\">,</span> <span class=\"n\">incidenceSet</span><span class=\"o\">,</span>\n    <span class=\"n\">mem_neighborSet</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_diff</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_singleton_iff</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">sup_apply</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">sdiff_apply</span><span class=\"o\">,</span>\n    <span class=\"n\">Sym2.toRel_prop</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_setOf_eq</span><span class=\"o\">,</span> <span class=\"n\">mem_edgeSet</span><span class=\"o\">,</span> <span class=\"n\">Sym2.mem_iff</span><span class=\"o\">,</span> <span class=\"n\">Quotient.eq</span><span class=\"o\">,</span> <span class=\"n\">Sym2.rel_iff</span><span class=\"o\">,</span>\n    <span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"n\">le_Prop_eq</span><span class=\"o\">,</span> <span class=\"n\">forall_exists_index</span><span class=\"o\">,</span> <span class=\"n\">and_imp</span><span class=\"o\">,</span> <span class=\"n\">sdiff_le_iff</span><span class=\"o\">,</span> <span class=\"n\">sup_Prop_eq</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ha</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">not_cliqueFree_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">mt</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.range</span> <span class=\"n\">f</span>\n  <span class=\"bp\">·</span> <span class=\"n\">by_cases</span> <span class=\"n\">ms</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.range</span> <span class=\"n\">f</span>\n    <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n    <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">·</span> <span class=\"n\">use</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp_all</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"bp\">@</span><span class=\"n\">ha</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"n\">mta</span> <span class=\"o\">:=</span> <span class=\"n\">eq_false</span> <span class=\"o\">(</span><span class=\"n\">mt</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">eq_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">mta</span>\n    <span class=\"k\">have</span> <span class=\"n\">mtb</span> <span class=\"o\">:=</span> <span class=\"n\">eq_false</span> <span class=\"o\">(</span><span class=\"n\">mt</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">eq_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">mtb</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mta</span><span class=\"o\">,</span> <span class=\"n\">mtb</span><span class=\"o\">,</span> <span class=\"n\">or_self</span><span class=\"o\">,</span> <span class=\"n\">and_false</span><span class=\"o\">,</span> <span class=\"n\">false_and</span><span class=\"o\">,</span> <span class=\"n\">exists_false</span><span class=\"o\">,</span> <span class=\"n\">or_false</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>After <code>simp only [mta, mtb, or_self, and_false, false_and, exists_false, or_false]</code> I have the goal <code>Adj G (f a) (f b) ↔ Adj G (f a) (f b) \\ False</code> which neither <code>aesop</code> or <code>simp</code> or <code>tauto</code> can close. How do I close it?</p>",
        "id": 387419773,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1693050846
    },
    {
        "content": "<p>This is part of proving the first step in the \"non-adjacency is an equivalence relation\" proof, that a graph with more edges can be obtained from a graph with non-adjacent edges of different degrees</p>",
        "id": 387419905,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1693051002
    },
    {
        "content": "<p>Or is there a cheaper way to show <code>cliqueFree_of_replaceVertex_cliqueFree</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The graph formed by replacing `t` with a copy of `s`, by changing `t`'s neighbours to match.</span>\n<span class=\"sd\">The `s-t` edge is removed if present. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">replaceVertex</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span> <span class=\"n\">where</span>\n  <span class=\"n\">Adj</span> <span class=\"o\">:=</span> <span class=\"n\">G.Adj</span> <span class=\"bp\">\\</span> <span class=\"n\">Sym2.ToRel</span> <span class=\"o\">(</span><span class=\"n\">G.incidenceSet</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">⊔</span> <span class=\"n\">Sym2.ToRel</span> <span class=\"o\">{</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">G.neighborSet</span> <span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}}</span>\n  <span class=\"n\">symm</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">h</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inl</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">adj_comm</span><span class=\"o\">,</span> <span class=\"n\">Sym2.eq_swap</span><span class=\"o\">])</span>\n    <span class=\"bp\">·</span> <span class=\"n\">aesop</span>\n  <span class=\"n\">loopless</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_diff</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">sup_apply</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">sdiff_apply</span><span class=\"o\">,</span> <span class=\"n\">SimpleGraph.irrefl</span><span class=\"o\">,</span>\n    <span class=\"n\">Sym2.toRel_prop</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_setOf_eq</span><span class=\"o\">,</span> <span class=\"n\">Quotient.eq</span><span class=\"o\">,</span> <span class=\"n\">Sym2.rel_iff</span><span class=\"o\">,</span> <span class=\"n\">or_self</span><span class=\"o\">,</span> <span class=\"n\">exists_eq_right_right</span><span class=\"o\">,</span>\n    <span class=\"n\">le_Prop_eq</span><span class=\"o\">,</span> <span class=\"n\">sdiff_le_iff</span><span class=\"o\">,</span> <span class=\"n\">IsEmpty.forall_iff</span><span class=\"o\">,</span> <span class=\"n\">sup_of_le_right</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">tauto</span>\n</code></pre></div>",
        "id": 387419928,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1693051031
    },
    {
        "content": "<p>I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=sdiff_bot#doc\">docs#sdiff_bot</a> is supposed to be able to apply, but something's gone wrong and bot became <code>False</code>. I've noticed this sort of thing happening before but didn't investigate.</p>",
        "id": 387420044,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693051145
    },
    {
        "content": "<p>Well a <code>change</code> works, but this branch of the proof looks very unsightly. There must be a better way to rewrite <code>cliqueFree_of_replaceVertex_cliqueFree</code> and/or <code>replaceVertex</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Clique-freeness is preserved by `replaceVertex`. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">cliqueFree_of_replaceVertex_cliqueFree</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.CliqueFree</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">G.replaceVertex</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">CliqueFree</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">contrapose</span> <span class=\"n\">h</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">topEmbeddingOfNotCliqueFree</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Function.Embedding.coeFn_mk</span><span class=\"o\">,</span> <span class=\"n\">top_adj</span><span class=\"o\">,</span> <span class=\"n\">replaceVertex</span><span class=\"o\">,</span> <span class=\"n\">incidenceSet</span><span class=\"o\">,</span>\n    <span class=\"n\">mem_neighborSet</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_diff</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_singleton_iff</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">sup_apply</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">sdiff_apply</span><span class=\"o\">,</span>\n    <span class=\"n\">Sym2.toRel_prop</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_setOf_eq</span><span class=\"o\">,</span> <span class=\"n\">mem_edgeSet</span><span class=\"o\">,</span> <span class=\"n\">Sym2.mem_iff</span><span class=\"o\">,</span> <span class=\"n\">Quotient.eq</span><span class=\"o\">,</span> <span class=\"n\">Sym2.rel_iff</span><span class=\"o\">,</span>\n    <span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"n\">le_Prop_eq</span><span class=\"o\">,</span> <span class=\"n\">forall_exists_index</span><span class=\"o\">,</span> <span class=\"n\">and_imp</span><span class=\"o\">,</span> <span class=\"n\">sdiff_le_iff</span><span class=\"o\">,</span> <span class=\"n\">sup_Prop_eq</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ha</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">not_cliqueFree_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">mt</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.range</span> <span class=\"n\">f</span>\n  <span class=\"bp\">·</span> <span class=\"n\">by_cases</span> <span class=\"n\">ms</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.range</span> <span class=\"n\">f</span>\n    <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n    <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">·</span> <span class=\"n\">use</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_range</span><span class=\"o\">,</span> <span class=\"n\">not_exists</span><span class=\"o\">,</span> <span class=\"n\">Function.Embedding.coeFn_mk</span><span class=\"o\">,</span> <span class=\"n\">top_adj</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"bp\">@</span><span class=\"n\">ha</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"n\">mta</span> <span class=\"o\">:=</span> <span class=\"n\">eq_false</span> <span class=\"o\">(</span><span class=\"n\">mt</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">eq_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">mta</span>\n    <span class=\"k\">have</span> <span class=\"n\">mtb</span> <span class=\"o\">:=</span> <span class=\"n\">eq_false</span> <span class=\"o\">(</span><span class=\"n\">mt</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">eq_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">mtb</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mta</span><span class=\"o\">,</span> <span class=\"n\">mtb</span><span class=\"o\">,</span> <span class=\"n\">or_self</span><span class=\"o\">,</span> <span class=\"n\">and_false</span><span class=\"o\">,</span> <span class=\"n\">false_and</span><span class=\"o\">,</span> <span class=\"n\">exists_false</span><span class=\"o\">,</span> <span class=\"n\">or_false</span><span class=\"o\">]</span>\n    <span class=\"n\">change</span> <span class=\"n\">_</span> <span class=\"bp\">↔</span> <span class=\"n\">_</span> <span class=\"bp\">\\</span> <span class=\"bp\">⊥</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sdiff_bot</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 387421499,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1693052387
    },
    {
        "content": "<p>I think we're missing some simp lemmas for the lattice instance on Prop</p>",
        "id": 387432239,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1693061145
    },
    {
        "content": "<p>I've completed the proof of <code>cliqueFree_of_vertexReplace_cliqueFree</code>. Now I am at the following sorry:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">one</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">∈</span> <span class=\"n\">turanSet</span> <span class=\"n\">n</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">G.Adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">G.degree</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">G.degree</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">¬</span><span class=\"n\">G.IsTuranMaximal</span> <span class=\"n\">n</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">wlog</span> <span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">G.degree</span> <span class=\"n\">w</span> <span class=\"bp\">&lt;</span> <span class=\"n\">G.degree</span> <span class=\"n\">v</span> <span class=\"n\">generalizing</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">adj_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ha</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">w</span> <span class=\"n\">v</span> <span class=\"n\">ha</span> <span class=\"n\">hd.symm</span> <span class=\"o\">(</span><span class=\"n\">hd.lt_or_lt.resolve_right</span> <span class=\"n\">hg</span><span class=\"o\">)</span>\n  <span class=\"n\">clear</span> <span class=\"n\">hd</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">IsTuranMaximal</span><span class=\"o\">,</span> <span class=\"n\">isMaxOn_iff</span><span class=\"o\">,</span> <span class=\"n\">not_forall</span><span class=\"o\">,</span> <span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">not_le</span><span class=\"o\">]</span>\n  <span class=\"n\">use</span> <span class=\"n\">G.replaceVertex</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">G.mem_replaceVertex_of_mem_turanSet</span> <span class=\"n\">n</span> <span class=\"n\">r</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">hm</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The goal at the sorry is <code>Set.ncard (edgeSet G) &lt; Set.ncard (edgeSet (replaceVertex G v w))</code>. This seems impenetrable. Is there a way forth?</p>",
        "id": 387506497,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1693123261
    },
    {
        "content": "<p>The definition of vertex replacement is now at <a href=\"https://github.com/leanprover-community/mathlib4/pull/6808\">#6808</a></p>",
        "id": 387507826,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1693124245
    },
    {
        "content": "<p><code>lemma one</code> says that \"if there are two nonadjacent vertices in a clique-free graph with differing degree, I can get a clique-free graph with more edges\"</p>",
        "id": 387508008,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1693124398
    },
    {
        "content": "<p>Then there will be <code>lemma two</code>: once nonadjacent vertices have the same degree, if three vertices <code>a b c</code> are such that <code>a !~ b</code> (non-adjacent) and <code>b !~c</code> but <code>a ~ c</code> (adjacent), I still can form a clique-free graph with more edges by replacing <code>a c</code> with copies of <code>b</code></p>",
        "id": 387508613,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1693124910
    },
    {
        "content": "<p>It's taken so long, but I've <strong>FINALLY</strong> done it<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/9317\">#9317</a></p>",
        "id": 410312482,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1703779021
    },
    {
        "content": "<p>The previous announcement was a bit premature because I had only proven one direction. I have now proven the other direction and bundled the theorems into the definitive statement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- **Turán's theorem**. `turanGraph n r` is, up to isomorphism, the unique</span>\n<span class=\"sd\">`r + 1`-cliquefree Turán-maximal graph on `n` vertices. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">isTuranMaximal_iff_nonempty_iso_turanGraph</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">G.IsTuranMaximal</span> <span class=\"n\">r</span> <span class=\"bp\">↔</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">≃</span><span class=\"n\">g</span> <span class=\"n\">turanGraph</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9317/commits/e0d44277b3cdbd10376df2302d81e68f60079392\">https://github.com/leanprover-community/mathlib4/pull/9317/commits/e0d44277b3cdbd10376df2302d81e68f60079392</a></p>",
        "id": 411684120,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1704699432
    },
    {
        "content": "<p>Feel free to take whatever individual part seems deserving of a mathlib4 PR and PR it</p>",
        "id": 411684644,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1704699759
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9317\">#9317</a> now contains a supremely short proof of the reverse direction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- **Turán's theorem**, reverse direction.</span>\n\n<span class=\"sd\">Any graph isomorphic to `turanGraph n r` is itself Turán-maximal. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isTuranMaximal_of_iso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">turanGraph</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsTuranMaximal</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">J</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">exists_isTuranMaximal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hr</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">g</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"bp\">.</span><span class=\"n\">nonempty_iso_turanGraph</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">card_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card_fin</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">turanGraph_cliqueFree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">cf</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card_edgeFinset_eq</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">cf</span>\n\n<span class=\"sd\">/-- For `0 &lt; r`, `turanGraph n r` is Turán-maximal. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isTuranMaximal_turanGraph</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">turanGraph</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">IsTuranMaximal</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">isTuranMaximal_of_iso</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"n\">Iso</span><span class=\"bp\">.</span><span class=\"n\">refl</span>\n\n<span class=\"sd\">/-- **Turán's theorem**. `turanGraph n r` is, up to isomorphism, the unique</span>\n<span class=\"sd\">`r + 1`-cliquefree Turán-maximal graph on `n` vertices. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isTuranMaximal_iff_nonempty_iso_turanGraph</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsTuranMaximal</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">turanGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">nonempty_iso_turanGraph</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">isTuranMaximal_of_iso</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>Still waiting for a maintainer to merge the dependency PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/11990\">#11990</a> please!</p>",
        "id": 446215856,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1719028323
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/11990\">#11990</a> is now merged, now time to review <a href=\"https://github.com/leanprover-community/mathlib4/pull/9317\">#9317</a></p>",
        "id": 446363766,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1719114639
    },
    {
        "content": "<p>And then it will be done</p>",
        "id": 446363783,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1719114673
    }
]