[
    {
        "content": "<p>Hi everyone,</p>\n<p>I found that the <code>MulEquivClass</code> is very hard to use. One reason is that there is no <code>MulEquivClass.symm</code> defined (although there is <code>EquivLike.inv</code>), and this forces one to write <code>(MulEquivClass.toMulEquiv f).symm</code> and <code>simp</code> fails on proofs like <code>(MulEquivClass.toMulEquiv f).symm (f x) = x</code> due to different coercion target type of <code>f</code> in the expression. </p>\n<p>The following is an example</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">Units</span><span class=\"bp\">.</span><span class=\"n\">Hom</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EquivLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulEquivClass</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">≃*</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">IsUnit</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">≃*</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"c1\">-- cannot simp IsUnit ((↑f).symm (f x)) to IsUnit x</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"c1\">-- failed</span>\n</code></pre></div>\n<p>My current solution is to add the exact simp lemmas that I need, e.g. <code>(MulEquivClass.toMulEquiv f).symm (f x) = x</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/17085\">#17085</a> but I think this is a common problem for all classes extends <code>EquivLike</code>. </p>\n<p>Do you have some ideas on this problem? Thank you!</p>",
        "id": 472685102,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1727267440
    },
    {
        "content": "<p>You can just replace <code>f</code> with its coercion everywhere, and then the standard <code>simp</code> lemmas will fire.</p>",
        "id": 472717421,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1727276259
    },
    {
        "content": "<p>Oh, actually maybe it won't.</p>",
        "id": 472718559,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1727276575
    },
    {
        "content": "<p>So we need a canonical way to talk about the inverse of a FooBarEquivClass. And I agree that <code>(MulEquivClass.toMulEquiv f).symm</code> is not a good solution.<br>\nBut I'm at a loss for what we should do instead.</p>\n<p>Surely we don't want to start adding an extra parameter \"type of inverse equivs\" to the entire <code>FooBarEquivClass</code> hierarchy...</p>",
        "id": 472829160,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727335061
    },
    {
        "content": "<p>Maybe Equivlike should assume <code>invFun</code> is <code>F -&gt; F</code>?</p>",
        "id": 472830816,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727335727
    },
    {
        "content": "<p>That doesn't make sense, right? <code>F</code> is the type of homs, and <code>M</code> and <code>N</code> are the domain an codomain of the homs.</p>",
        "id": 472831376,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727335915
    },
    {
        "content": "<p>And so the inverse should live in some type <code>G</code> of homs going from <code>N</code> to <code>M</code>.</p>",
        "id": 472831464,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727335932
    },
    {
        "content": "<p>Ah right</p>",
        "id": 472831840,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727336060
    },
    {
        "content": "<p>To be clear, <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> has already thought quite extensively about this</p>",
        "id": 472835310,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727337134
    },
    {
        "content": "<p>would there be an issue having something like <code>EquivSymmPairClass</code>?</p>",
        "id": 472836770,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727337588
    },
    {
        "content": "<p>i'm thinking along these lines:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">EquivSymmPairClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">EquivLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EquivLike</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span>\n<span class=\"w\">  </span><span class=\"n\">symm_eq_inv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">F</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">invFun</span>\n<span class=\"w\">  </span><span class=\"n\">symm_inv_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">F</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>",
        "id": 472838355,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727338085
    },
    {
        "content": "<p>akin to how <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHomInvPair#doc\">docs#RingHomInvPair</a> is used</p>",
        "id": 472838398,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727338101
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60MulEquivClass.60.20has.20no.20.60symm.60/near/472835310\">said</a>:</p>\n<blockquote>\n<p>To be clear, <span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> has already thought quite extensively about this</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> has tried out quite a few options here too!</p>\n<p>I have tried out a few options (mostly back in Lean 3 times), and ran into limitations with dependent parameters: very often we know the type of the <em>inverse</em> function and so we can't easily infer the type of the forward function. Lean 4 doesn't behave more flexibly here (last time I tried) so I don't expect the limitations are lifted.</p>",
        "id": 472859810,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1727345086
    },
    {
        "content": "<p>Essentially we want to claim that knowing either <code>F</code> or <code>G</code> is enough to infer the rest, but the <code>outParam</code> system only allows us to pick one of the two.</p>",
        "id": 472860102,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1727345184
    },
    {
        "content": "<p>Note that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHomInvPair#doc\">docs#RingHomInvPair</a> says two specific <em>maps</em> are each others' inverses, while we need that two <em>types</em> contain each others' inverses.</p>",
        "id": 472860318,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1727345258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60MulEquivClass.60.20has.20no.20.60symm.60/near/472860102\">said</a>:</p>\n<blockquote>\n<p>Essentially we want to claim that knowing either <code>F</code> or <code>G</code> is enough to infer the rest, but the <code>outParam</code> system only allows us to pick one of the two.</p>\n</blockquote>\n<p>I don't know much about elaboration, but would it be possible to write a custom elaborator for that (and add some notation)?</p>",
        "id": 472905743,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727359640
    },
    {
        "content": "<p>Or maybe a unification hint?</p>",
        "id": 472907391,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727360107
    },
    {
        "content": "<p>I don't know whether the following question makes sense.</p>\n<p>Is it possible to find some way to generate all coercion-related simp lemmas of<code>MulEquivClass</code> from lemmas of <code>MulEquiv</code> automatically? There are plenty of coe lemmas of <code>MulEquiv</code> in mathlib already. For example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MulEquiv</span><span class=\"bp\">.</span><span class=\"n\">symm_apply_apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">≃*</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>The problem is that it does not work for <code>MulEquivClass</code>. Given <code>[MulEquivClass F M N] (f : F)</code>, the<br>\n<code>f</code> in <code>f x</code> will be coerced to the type <code>M → N</code> in such a way without passing through <code>M ≃* N</code>, although different coercion ways will always result in rfl functions in <code>M → N</code> in the end. (I am not sure how <code>simp</code> works here when trying to find patterns that match <code>MulEquiv.symm_apply_apply </code>.) Is it possible to auto generate simp lemmas for each different coercion ways?</p>",
        "id": 473068254,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1727431416
    },
    {
        "content": "<p>I made a crude solution using a similar method to <a href=\"https://github.com/leanprover-community/mathlib4/pull/16421\">#16421</a>. There is more complexity here than in <a href=\"https://github.com/leanprover-community/mathlib4/pull/16421\">#16421</a>, and I expect there will be more trouble with this.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">EquivSymmPairClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">toEquivLikeF</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EquivLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">toEquivLikeG</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EquivLike</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G</span>\n<span class=\"w\">  </span><span class=\"n\">symm_eq_inv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">EquivLike</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">symm_inv_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">EquivLike</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">EquivSymmPairClass'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EquivSymmPairClass</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">symmPair</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"symm(\"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"s2\">\")\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Qq</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span><span class=\"w\"> </span><span class=\"n\">symmPair</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">symmPairImpl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElab</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"n\">typ?</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">symm</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">stx</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">failure</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">typ?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">EquivSymmPairClass</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">stx</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">typ?</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">expectedType</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">synthesizeSyntheticMVars</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">expectedType</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">isMVar</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">EquivSymmPairClass</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">stx</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">typ?</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">mkFreshLevelMVar</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVarQ</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshLevelMVar</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVarQ</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshLevelMVar</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVarQ</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshLevelMVar</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkFreshExprMVarQ</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">EquivSymmPairClass</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">trySynthInstanceQ</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">EquivSymmPairClass'</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">inst</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span>\n<span class=\"w\">        </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">EquivSymmPairClass</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">stx</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">typ?</span>\n<span class=\"w\">      </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">EquivSymmPairClass</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Qq</span><span class=\"bp\">.</span><span class=\"n\">elabTermEnsuringTypeQ</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">F</span><span class=\"o\">)))</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃+*</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EquivSymmPairClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃+*</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">≃+*</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EquivSymmPairClass'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃+*</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">≃+*</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"sd\">/-- info: fun x =&gt; EquivSymmPairClass.symm x : A ≃+* B → B ≃+* A -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">symm</span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">≃+*</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"sd\">/-- info: fun x =&gt; EquivSymmPairClass.symm x : A ≃+* B → B ≃+* A -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">symm</span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≃+*</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 473268581,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1727490010
    },
    {
        "content": "<p>It would be easier to test this method with mathlib if the custom elaborator could be made for the function and resolve <a href=\"https://github.com/leanprover/lean4/pull/5482\">lean4#5482</a>.</p>",
        "id": 473268857,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1727490259
    },
    {
        "content": "<p>Today I met another case where I was blocked by the lack of <code>MulEquivClass.symm</code>. The following theorem is currently in Mathlib.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">map_dvd_iff</span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semigroup</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semigroup</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_3</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EquivLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulEquivClass</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>I want to add a theorem saying that <code>f a ∣ b ↔ a ∣ f.symm b</code>. But I think it is not possible to do it now.</p>",
        "id": 479227606,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1730106870
    }
]