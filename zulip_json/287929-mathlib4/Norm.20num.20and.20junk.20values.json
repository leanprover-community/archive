[
    {
        "content": "<p>Hi all! I'm working on a proof-of-concept extension for simplifying trigonometric expressions (similar to grind and lean-egg in implementation). I noticed that integrating norm num into it results in a lot of (mathematically) incorrect simplifications, due to junk value conventions (e.g. 0 / 0 = 0). Does norm_num or Lean have a way to check whether junk value conventions are used? Or should I be building a verifier within my extension that makes sure no junk simplifications occur?</p>",
        "id": 572402868,
        "sender_full_name": "Darylgolden",
        "timestamp": 1770391133
    },
    {
        "content": "<p>Can you give an example of an incorrect semplification? For Lean junk values are just values, it is a \"human notion\".</p>",
        "id": 572405158,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1770391681
    },
    {
        "content": "<p>See also <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a></p>",
        "id": 572406676,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1770392117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Norm.20num.20and.20junk.20values/near/572405158\">said</a>:</p>\n<blockquote>\n<p>For Lean junk values are just values, it is a \"human notion\".</p>\n</blockquote>\n<p>I.e., Lean cannot conveniently formalize basic mathematics as it is commonly understood.</p>",
        "id": 572410153,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770393054
    },
    {
        "content": "<p>Junk values for things like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">1/0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/0</span></span></span></span> have nothing to do with humans vs. computers. It's a byproduct of the formalism used by Lean.</p>",
        "id": 572410553,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770393160
    },
    {
        "content": "<p>And in fact there are many, <em>many</em> computer mathematics systems that handle <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">1/0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/0</span></span></span></span> correctly. If I boot up Sage and evaluate <code>1/0</code>, I get an error.</p>",
        "id": 572410990,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770393266
    },
    {
        "content": "<p>humans don't get an error when dividing by zero, they just say \"don't do it in the first place\". the fact that it errors is a byproduct of the formalism used by sage.</p>",
        "id": 572415811,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1770394597
    },
    {
        "content": "<p>basically, one can argue that erroring is not \"handling correctly\"</p>",
        "id": 572415984,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1770394652
    },
    {
        "content": "<p>And in any case, the wider question of junk values is off topic for <span class=\"user-mention\" data-user-id=\"452938\">@Darylgolden</span>'s question</p>",
        "id": 572416068,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1770394676
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Norm.20num.20and.20junk.20values/near/572410990\">said</a>:</p>\n<blockquote>\n<p>And in fact there are many, <em>many</em> computer mathematics systems that handle <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">1/0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/0</span></span></span></span> correctly. If I boot up Sage and evaluate <code>1/0</code>, I get an error.</p>\n</blockquote>\n<p>Hmm, I think you’re conflating different sorts of computer mathematics systems. Computer algebra systems like sage can afford to just manipulate away and then throw an error at the last minute when something definitely bad is encountered. But <em>formalizing</em> math in a computer has a different set of needs, and is a different sense of “handling” than sage’s sense.</p>\n<p>I think intrinsic to the needs of formalization is dealing with the fact that <code>x / y</code> might not even be well-defined if we were to take the natural language approach. Our options for formalization seem to be</p>\n<ol>\n<li>demand a proof that <code>y</code> is not 0 before you’re allowed to write <code>x / y</code></li>\n<li>always allow writing <code>x / y</code>, but use a junk value when <code>y = 0</code>, and have this junk operation only be guaranteed to coincide with the familiar one when we know <code>y</code> is not zero</li>\n<li>allow writing <code>x / y</code> but interpret it as a “fallible number” and prove things about these, and only allow converting to actual numbers when it turns out that <code>y</code> is not zero</li>\n</ol>\n<p>Which of these is most ergonomic is indeed going to be a byproduct of the features of your proof assistant, but all of them are pretty different from what humans do.</p>",
        "id": 572416153,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770394698
    },
    {
        "content": "<p>To get back to the original question, <span class=\"user-mention\" data-user-id=\"452938\">@Darylgolden</span> (hello!), I’d like to ask: does the fact that these are occurring mean that the relevant expressions have divisions by zero in them? If so, are you sure that the issue is the simplification, and not the formation of the expressions in the first place?</p>\n<p>Basically, there is no mathematical problem with simplifying to junk values—you just wind up with junk facts. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> (I.e., facts that are still mathematically true about our extended <code>/</code> operation and do not contradict ordinary ones, but are useless.)</p>\n<p>(Also, it might indeed be reasonable for <code>norm_num</code> to warn on simplifying to junk values! :) It does not currently.)</p>",
        "id": 572416897,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770394915
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Norm.20num.20and.20junk.20values/near/572405158\">said</a>:</p>\n<blockquote>\n<p>Can you give an example of an incorrect semplification? For Lean junk values are just values, it is a \"human notion\".</p>\n</blockquote>\n<p>I'm away from my computer, so I don't have the exact chain of steps, but something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo><mi>cos</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>cos</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi>sin</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\sin (3) \\cos(1) + \\cos(1) \\sin(3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">sin</span><span class=\"mopen\">(</span><span class=\"mord\">3</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">cos</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">cos</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">sin</span><span class=\"mopen\">(</span><span class=\"mord\">3</span><span class=\"mclose\">)</span></span></span></span>, which I expect to be simplified to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mn>4</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\sin(4)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">sin</span><span class=\"mopen\">(</span><span class=\"mord\">4</span><span class=\"mclose\">)</span></span></span></span> by the addition identity, is instead simplified to 0. Note that the technique I'm using, equality saturation, is essentially a brute-force technique that can do a lot of things that a human would never do (for example, a human would never end up with a division by 0 in the process of simplifying this expression and most others, but a brute-force technique might). Because I'm optimizing for the smallest AST size, empirically it's often the case that the simplifier manages to find some convoluted way of simplifying many nonzero expressions to 0, using a junk value convention along the way. I'm aware that junk values are not \"wrong\" per se, but in a scenario where I'm attempting to work with standard operations over the reals, it seems there should be some way to at least warn the user that the result may not be what they expect <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 572418596,
        "sender_full_name": "Darylgolden",
        "timestamp": 1770395381
    },
    {
        "content": "<p>Lean allows you to prove 1/0 = 0, but it doesn’t allow you to prove sin(4) = 0. Something weird is going on in your code.</p>",
        "id": 572419331,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770395548
    },
    {
        "content": "<p>Junk values allow you to prove junk theorems, but not false theorems <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 572419439,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1770395577
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Norm.20num.20and.20junk.20values/near/572419331\">said</a>:</p>\n<blockquote>\n<p>Lean allows you to prove 1/0 = 0, but it doesn’t allow you to prove sin(4) = 0. Something weird is going on in your code.</p>\n</blockquote>\n<p>I should mention I'm not converting my simplifications into Lean proofs yet. They exist as \"explanations\" in the egg Rust library. But making sure that the simplifications don't allow junk values would be a first step.</p>",
        "id": 572419867,
        "sender_full_name": "Darylgolden",
        "timestamp": 1770395684
    },
    {
        "content": "<p>Hmm, if you’re inclined to insert division by zero in the course of simplification, I suspect that doing so is the actual problem <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span>I think you probably don’t want to do this, junk value or no. Is there another more formally correct operation that could replace these desired divisions?</p>",
        "id": 572420393,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770395829
    },
    {
        "content": "<p>As mentioned, it's sort of a brute force technique that essentially comes up with loads of equivalent expressions that no human would ever think of. There of course is more directed ways of simplifying trigonometric expressions specifically, for example modelling the process taken in SymPy more directly, but my current project aims to investigate e-graph methods, so that's slightly out of scope for me at the moment. I could of course write my own verifier to check that the calls to norm num aren't anything bad, but I was wondering if there are existing ways of doing it.</p>",
        "id": 572421533,
        "sender_full_name": "Darylgolden",
        "timestamp": 1770396147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"452938\">Darylgolden</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Norm.20num.20and.20junk.20values/near/572419867\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Norm.20num.20and.20junk.20values/near/572419331\">said</a>:</p>\n<blockquote>\n<p>Lean allows you to prove 1/0 = 0, but it doesn’t allow you to prove sin(4) = 0. Something weird is going on in your code.</p>\n</blockquote>\n<p>I should mention I'm not converting my simplifications into Lean proofs yet. They exist as \"explanations\" in the egg Rust library. But making sure that the simplifications don't allow junk values would be a first step.</p>\n</blockquote>\n<p>You seem to misunderstand the notion of junk values here. Rewriting with <code>n / 0 = 0</code> is <em>correct</em> in Lean, there is no question about it and it is fully accepted and embraced by the community. It's just as valid of a simplification as <code>1  + 1 = 2</code>. If you are working from some expression <code>A</code> that is not equal to <code>0</code> to another expression <code>B</code> which then simplifies to say <code>C = 0</code> through a junk value rule the issue is not the step <code>B = C</code> but the step <code>A = B</code>. You would find when converting them to a Lean proof that <code>A = B</code> is not going to be provable.</p>",
        "id": 572422104,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1770396304
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"452938\">@Darylgolden</span>) My point is that I think this is actually exposing some incorrect simplification step, and that a simplification which may introduce division by zero ought to probably be avoided, whether it involves a junk value or not: such an expression is not mathematically equivalent to the original one. That is, norm_num warning you that it was using a junk value would not save you! <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 572422300,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770396365
    },
    {
        "content": "<p>I don't think I'm misunderstanding it. I understand that it's correct in Lean, but my intention is to work with real numbers with standard real operations.</p>",
        "id": 572422304,
        "sender_full_name": "Darylgolden",
        "timestamp": 1770396367
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Norm.20num.20and.20junk.20values/near/572416153\">said</a>:</p>\n<blockquote>\n<p>Hmm, I think you’re conflating different sorts of computer mathematics systems. Computer algebra systems like sage can afford to just manipulate away and then throw an error at the last minute when something definitely bad is encountered. But <em>formalizing</em> math in a computer has a different set of needs, and is a different sense of “handling” than sage’s sense.</p>\n</blockquote>\n<p>I just find it a little bit difficult to accept the lengths people will go to justify what is really a fundamental UX failure of Lean.</p>\n<p>Compare the way Lean handles <code>1/0</code> and <code>[0,1,2][5]</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- info: 0 -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">0</span>\n\n<span class=\"sd\">/-- error: failed to prove index is valid, possible solutions:</span>\n<span class=\"sd\">  - Use `have`-expressions to prove the index is valid</span>\n<span class=\"sd\">  - Use `a[i]!` notation instead, runtime check is performed, and 'Panic' error message is produced if index is not valid</span>\n<span class=\"sd\">  - Use `a[i]?` notation instead, result is an `Option` type</span>\n<span class=\"sd\">  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid</span>\n<span class=\"sd\">⊢ 5 &lt; [0, 1, 2].length -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">][</span><span class=\"mi\">5</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>With array indexing, Lean goes to great lengths to cater to the expectation among programmers that you will be able to write <code>a[5]</code> and have it just work when it's supposed to. By contrast, with division (and subtraction on the naturals), Lean just happily silently behaves in a way that does not agree with what the symbols means in all contexts in mathematics and computer science other than that of certain proof assistants.</p>\n<p>I agree that on some formal level, the junk value approach is probably the most ergonomic given the type-theoretic formalism of Lean, but the way the symbols <code>/</code> and <code>-</code> are being used is just wrong, period. That's just a fact.</p>",
        "id": 572422321,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770396372
    },
    {
        "content": "<p>There should <em>at the very least</em> be a warning that you're producing a non-standard junk value.</p>",
        "id": 572422448,
        "sender_full_name": "James E Hanson",
        "timestamp": 1770396402
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"452938\">@Darylgolden</span>  Right now you are doing a really bad job of explaining your problem. Claims such as \"Lean reduces sin(3)cos(1)+cos(1)sin(3) to 0\" are a strong indication that you have not understood something properly, because it is not possible to make Lean do this. Sometimes asking a question with a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> is much better than words. Can you give an example of something you're concerned about using code?</p>",
        "id": 572422507,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770396419
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"904624\">@James E Hanson</span> your comments, whilst valid, and also a pet peeve of yours, might be better expressed in another thread. It's not yet clear to me that they are relevant to the actual question here. If the question is not junk then the answer will not be junk so either the OP is asking junk questions (in which case they get the chaos you are describing) or they are not (in which case they should not be having problems), and my impression is that they are not asking junk questions and are claiming they're getting junk answers, so perhaps the real issue lies elsewhere.</p>",
        "id": 572423335,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770396645
    },
    {
        "content": "<p>Note that we have, e.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=divp#doc\">docs#divp</a> to encode the \"mathematical\" notion of division.</p>",
        "id": 572423359,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1770396651
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"904624\">@James E Hanson</span> I don’t want to hijack this thread any further, but I’ll just quickly point out: (1) I think the UX being optimized for here first is proof, not evaluation, and the behavior you want is further out of reach due to intrinsic needs there (2) but yeah, why <em>not</em> warn when using a nonstandard junk value in <code>#eval</code> and <code>norm_num</code>? Let’s optimize both UX’s! But that’s the last I’ll comment on it here. <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 572423775,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770396758
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  I'm not claiming that Lean reduces the given trigonometric expression to 0. I'm claiming that my simplification procedure, which calls norm num using some junk values (and to be fair, there could and likely are many bugs in this procedure that might have resulted in this, other than the junk value conventions) resulted in this incorrect simplification. I only mentioned this specific example because I was asked about it; I apologize if it seemed like I was accusing this is Lean's fault.</p>\n<p>My initial question was simple, and I believe doesn't require a mwe: is there established methods of detecting, in norm_num, whether a junk value convention is used?</p>",
        "id": 572424187,
        "sender_full_name": "Darylgolden",
        "timestamp": 1770396863
    },
    {
        "content": "<p>AFAIK, no. An <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> would help to better understand what's happening.</p>",
        "id": 572424380,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1770396915
    },
    {
        "content": "<p>So are you using Lean's decision procedures to power your external tool in hopes of getting more correct results?</p>",
        "id": 572424381,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1770396915
    },
    {
        "content": "<p>I really think the simplification steps <em>prior</em> to norm_num are mathematically incorrect, and that detecting norm_num’s behavior would not really help. (I’m trying to <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> a bit here, to be clear! :) ) Unless you want your simplification to be able to fail, and just want to filter out incorrect results?</p>",
        "id": 572424675,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770396991
    },
    {
        "content": "<p>Instead of asking Lean to tell you that you've used junk values, why don't you just check yourself? Here are the things which you shouldn't do: (1) divide by 0. (2) subtract naturals. (3) divide naturals or integers. Do you have any reason to do any of those things? I don't understand the difference in practice between \"get Lean to tell me I just did one of those things\" and \"use Lean to check whether I am about to do one of those things\".</p>",
        "id": 572426080,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770397369
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Norm.20num.20and.20junk.20values/near/572424380\">said</a>:</p>\n<blockquote>\n<p>AFAIK, no. An <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> would help to better understand what's happening.</p>\n</blockquote>\n<p>I suppose that's the answer I need. As for a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, I'm not at my computer now (it's quite late for me), and am typing this on my phone. I can try to post one tomorrow, but I'm not sure in what form. The minimal case for my application would involve a plugin with a C and Rust FFI, not to mention it's still in a very messy state. I could also try to isolate the incorrect simplification and see if I can replicate the simplification proof in Lean itself (not in a Rust egg explanation, which is a separate DSL that has yet to be converted into a Lean proof), but I don't think that's of interest to either me or anyone else (since even if it works, it would be correct in a junk value sense, which isn't interesting mathematically)</p>",
        "id": 572426357,
        "sender_full_name": "Darylgolden",
        "timestamp": 1770397451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Norm.20num.20and.20junk.20values/near/572426080\">said</a>:</p>\n<blockquote>\n<p>Instead of asking Lean to tell you that you've used junk values, why don't you just check yourself? Here are the things which you shouldn't do: (1) divide by 0. (2) subtract naturals. (3) divide naturals or integers. Do you have any reason to do any of those things? I don't understand the difference in practice between \"get Lean to tell me I just did one of those things\" and \"use Lean to check whether I am about to do one of those things\".</p>\n</blockquote>\n<p>What does \"check myself\" mean? The code I'm running does lots of (mostly stupid and absurd) calls to norm num. These are computed at runtime and not something I can precheck by hand. Of course I could write code to check it, but my question is just precisely that: has anyone made something that checks it before, or is it already built into Lean or mathlib, and I've somehow missed it? It seems like the answer is no, so I think I'll proceed to write my own checker.</p>",
        "id": 572427535,
        "sender_full_name": "Darylgolden",
        "timestamp": 1770397759
    },
    {
        "content": "<p>I guess I don't properly understand what you're doing. If I'm writing code manually then \"check myself\" means \"don't press the <code>/</code> button on my keyboard unless the basic sanity checks are passed\", and this would have some analogue in my naive mental model of what you are doing but perhaps my naive mental model is too naive.</p>",
        "id": 572428294,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770398006
    },
    {
        "content": "<p><code>norm_num</code> is not going to do anything junky by itself; this is my main sticking point in trying to understand your question. If norm_num simplifies 1/0 to 0 then for me the question is how you ended up with 1/0 in the first place, not why norm_num simplified it to 0. The mathematically invalid step occurred earlier.</p>",
        "id": 572428557,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770398093
    },
    {
        "content": "<p>There is very likely something going wrong with my code, but this seems orthogonal to the fact that there can still be a warning if a junk convention simplification is used, and it seems to me like this would be a helpful thing.</p>",
        "id": 572432385,
        "sender_full_name": "Darylgolden",
        "timestamp": 1770399418
    },
    {
        "content": "<p>Well, a junk value simplification is only used if the input contains junk values, so the warning will only flag if you're already doing something silly like dividing by zero.</p>",
        "id": 572432577,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1770399483
    },
    {
        "content": "<p>(I do think a warning from <code>norm_num</code> that you’re likely doing something silly is probably helpful in general, though I’m (also) skeptical it’s what’s actually needed for this application, as it would merely repeat some of the advice on this zulip thread :) )</p>",
        "id": 572433358,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770399748
    },
    {
        "content": "<p>another way people usually call this is what some people call the \"GIGO\" principle: Garbage in, garbage out.  It'd be interesting to understand where the \"garbage in\" part came from e.g. by looking at the explanation. Equality saturation shouldn't unify the eclasses of your original expression with <code>0/0</code>, so the junk values are a bit of a red herring here</p>",
        "id": 572433372,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1770399754
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Norm.20num.20and.20junk.20values/near/572433358\">said</a>:</p>\n<blockquote>\n<p>(I do think a warning from <code>norm_num</code> that you’re likely doing something silly is probably helpful in general, though I’m (also) skeptical it’s what’s actually needed for this application, as it would merely repeat some of the advice on this zulip thread :) )</p>\n</blockquote>\n<p><code>norm_num</code> isn't the only tactic that might be presented with some expression which involves a junk value though right, so it'd be broader than just one tactic -- and the list of junk values is not even finite right, someone can at any time add some completely new definition somewhere which is undefined on paper at value <code>foo</code> of its domain and then if you evaluate that thing there you're doing junk math but it all works out anyhow.</p>",
        "id": 572435161,
        "sender_full_name": "Julian Berman",
        "timestamp": 1770400305
    },
    {
        "content": "<p>Right, but this is no reason to avoid improving the UX in the common and feasible cases. :)</p>",
        "id": 572440906,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770402339
    },
    {
        "content": "<p>Fair point!</p>",
        "id": 572441881,
        "sender_full_name": "Julian Berman",
        "timestamp": 1770402697
    },
    {
        "content": "<p>If we do make a <code>norm_num</code> warning for junk values, it should be strictly opt-in. There are legitimate reasons to prove \"junk\" theorems within Mathlib.</p>",
        "id": 572442101,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1770402789
    },
    {
        "content": "<p>Ah, okay, like what? I’m wondering what we would lose by having the warning be opt-<em>out</em>, so that it’s reflected in source that you’re depending on junk values.</p>",
        "id": 572442299,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770402868
    },
    {
        "content": "<p>(That is, I’m imagining some syntax would be available, e.g. <code>norm_num +junk</code>, to proceed without warnings. Or maybe this is compatible with what you’re thinking about?)</p>",
        "id": 572442520,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770402949
    },
    {
        "content": "<p>It's not clear to me why junk values are norm_num's problem; if you want better UX for surprising junk values, this sounds like the job of a linter that looks at the generated terms</p>",
        "id": 572443271,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1770403231
    },
    {
        "content": "<p>(There is also the question of what to do, if anything, about <code>simp</code> theorems which exploit junk values. A different simp set? And what about simp theorems about e.g. <code>/</code> which are familiar and true everywhere, but only because we happen to have chosen <code>_ / 0 = 0</code>? Do we sequester those? This might be a nontrivial design choice.)</p>",
        "id": 572443339,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770403255
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Norm.20num.20and.20junk.20values/near/572443271\">said</a>:</p>\n<blockquote>\n<p>It's not clear to me why junk values are norm_num's problem; if you want better UX for surprising junk values, this sounds like the job of a linter that looks at the generated terms</p>\n</blockquote>\n<p>My thinking is basically because norm_num is the thing responsible for “actually applying” such a fact…in some sense. Also feasibility reasons: I’m not sure traversing proof terms with a linter would be performant enough, but it’s easy for norm_num to catch itself in the act.</p>\n<p>It would be less of a principled approach to linting against junk values than “hey, I can <em>definitely</em> be sure you’re using them here, so I may as well let you know something’s fishy”. Maybe we don’t want this approach (and the warning itself would have to disclaim this), but I think it’s worth considering; it could be useful, especially for new users.</p>",
        "id": 572443850,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770403472
    },
    {
        "content": "<p>But so is <code>simp</code></p>",
        "id": 572444586,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1770403759
    },
    {
        "content": "<p>Ah, i.e. simp is also responsible for applying these facts? Indeed! Hence the message about simp above <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> (norm_num of course preprocesses via simp, so it’s not much use considering one without the other imo.)</p>",
        "id": 572445240,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770404009
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>for example</p>",
        "id": 572446340,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1770404392
    },
    {
        "content": "<p>Yes, I think we agree; did you see my message about simp above?</p>",
        "id": 572446447,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770404433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Norm.20num.20and.20junk.20values/near/572442299\">said</a>:</p>\n<blockquote>\n<p>Ah, okay, like what?</p>\n</blockquote>\n<p>If you have theorems about functions that can return junk values then you usually have to add a side condition saying the input is not junk. But if the conclusion also happens to hold for junk inputs, then you can drop this assumption.</p>",
        "id": 572447090,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1770404637
    },
    {
        "content": "<p>Right, the latter is what I’m talking about here:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Norm.20num.20and.20junk.20values/near/572443339\">said</a>:</p>\n<blockquote>\n<p>And what about simp theorems about e.g. <code>/</code> which are familiar and true everywhere, but only because we happen to have chosen <code>_ / 0 = 0</code>? Do we sequester those? This might be a nontrivial design choice.</p>\n</blockquote>\n<p>It’s indeed not clear to me what should happen in this case. The thing we care about is unexpected behavior, and I imagine sometimes this would produce unexpected behavior and sometimes not. I’m guessing we could cook up examples where the behavior is unexpected but nothing in the proof or term is untoward.</p>",
        "id": 572447838,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770404938
    },
    {
        "content": "<p>(With norm_num, though, worth pointing out that it is very obvious whether the core normalization is doing something unexpected, given that it handles numerals. Can’t do anything if norm_num’s call to simp gets there first, though.)</p>",
        "id": 572448126,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1770405072
    }
]