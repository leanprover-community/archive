[
    {
        "content": "<p>Motivated by <a href=\"https://github.com/leanprover-community/mathlib4/pull/14990\">#14990</a>, I thought it was probably time to update our good old \"algebraic filter bases\" API to modern mathlib practices. <a href=\"https://github.com/leanprover-community/mathlib4/pull/18202\">#18202</a> (still marked as draft just because it's too big, otherwise I'm happy with it) is an attempt at doing this. Broadly speaking, here's what it does:</p>\n<ol>\n<li>In a huge majority of cases, Mathlib uses filter bases by the means of the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.HasBasis#doc\">docs#Filter.HasBasis</a> API. Of course this is only suitable when we already \"have\" the generated filter. When we want to <em>build</em> that filter, we have both <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FilterBasis#doc\">docs#FilterBasis</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.IsBasis#doc\">docs#Filter.IsBasis</a>. My point is the latter is much cleaner to use because the translation to <code>HasBasis</code> is seamless (the data is the same, a predicate and an indexed family). So, I changed <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=GroupFilterBasis#doc\">docs#GroupFilterBasis</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingFilterBasis#doc\">docs#RingFilterBasis</a>, ... to predicates <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.IsGroupBasis#doc\">docs#Filter.IsGroupBasis</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.IsRingBasis#doc\">docs#Filter.IsRingBasis</a>, ... using the <code>IsBasis</code> model. For a detailed explanation, read the docstring of <a href=\"https://github.com/leanprover-community/mathlib4/blob/AD_algebra_filter_bases/Mathlib/Topology/Algebra/FilterBasis.lean\">https://github.com/leanprover-community/mathlib4/blob/AD_algebra_filter_bases/Mathlib/Topology/Algebra/FilterBasis.lean</a></li>\n<li>Now, on top of the general setup, we have extra constructions for bases made of algebraic subobjects, such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingSubgroupsBasis#doc\">docs#RingSubgroupsBasis</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingSubmodulesBasis#doc\">docs#RingSubmodulesBasis</a>, ... Apart from the naming which sounds really weird to me, my main concerns about these were (i) these use indexed family but no predicate, so they are inconsistent with everything (ii) this sounds like extra definitions for not much gain. So I changed them to new constructors for the general definitions (adding a bit of <code>SetLike</code> magic to remove some duplication), and I believe everything is now much cleaner. See <a href=\"https://github.com/leanprover-community/mathlib4/blob/AD_algebra_filter_bases/Mathlib/Topology/Algebra/Nonarchimedean/Bases.lean\">https://github.com/leanprover-community/mathlib4/blob/AD_algebra_filter_bases/Mathlib/Topology/Algebra/Nonarchimedean/Bases.lean</a></li>\n<li>Since I had to fix a lot of things depending on it, I ended up refactoring some of it slightly along the way. This is what causes the PR to be so big, and of course I want some more eyes to look at what I did in this step.</li>\n</ol>",
        "id": 479437345,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1730194882
    },
    {
        "content": "<p>Now, correct me if I'm wrong, but I don't think anyone will be okay with merging a PR of that size. My plan then is to first add the new versions while keeping the old ones, then refactoring the use places in a few separate PRs, and finally removing the current setup. Does it sound good?</p>",
        "id": 479437714,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1730195003
    },
    {
        "content": "<p>Ping <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> <span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> <span class=\"user-mention\" data-user-id=\"406490\">@María Inés de Frutos Fernández</span> <span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span></p>",
        "id": 479437966,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1730195082
    },
    {
        "content": "<p>This looks like a very good idea! I myself tried using the filter bases API a few months ago and basically failed due to all those mismatches between predicates and non-predicates. I ended up stating my result very concretely without using the filter basis machinery.</p>",
        "id": 479439230,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730195489
    },
    {
        "content": "<p>\"my result\" being <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_mem_interior_convexHull_affineBasis#doc\">docs#exists_mem_interior_convexHull_affineBasis</a></p>",
        "id": 479439431,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730195549
    },
    {
        "content": "<p>I'm not sure I understand correctly what you mean by this. If you mean \"this should be stated in terms of filter basis\" then yes, but the existing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.HasBasis#doc\">docs#Filter.HasBasis</a> works as a charm for that.<br>\nThe other option is that you were talking about the following alternate proof : start by proving that simplicial neighborhoods form a basis for a T2 vector space topology, and then use something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Basis.equivFunL#doc\">docs#Basis.equivFunL</a> to get that the topology is the original one ? If so that is quite smart, but I'm not sure how easy that would be in practice.<br>\nAm I missing something obvious ?</p>",
        "id": 479443071,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1730196705
    },
    {
        "content": "<p>I think globally this is a good idea. The old API comes straight from the perfectoid spaces project in 2018 and we learned a lot since then.</p>",
        "id": 479445971,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1730197757
    },
    {
        "content": "<p>In a context where we try to disentangle the import hierarchy, maybe we should be careful with files doing stuff for all algebraic structures. But this may be a virtual concern in the sense that everything will be already imported anyway.</p>",
        "id": 479446326,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1730197880
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/18437\">#18437</a> adds the new core API without touching any existing files.</p>",
        "id": 479674028,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1730292218
    },
    {
        "content": "<p>I have another question about this design. Why do we define predicates on filter bases, not on filters?</p>",
        "id": 480002405,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730441640
    },
    {
        "content": "<p>E.g., we can have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">GroupFilter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pure_le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">toFilter</span>\n<span class=\"w\">  </span><span class=\"n\">tendsto_inv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tendsto</span><span class=\"w\"> </span><span class=\"n\">Inv</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">toFilter</span><span class=\"w\"> </span><span class=\"n\">toFilter</span>\n<span class=\"w\">  </span><span class=\"n\">tendsto_mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tendsto</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">×ˢ</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">l</span>\n</code></pre></div>\n<p>Then <code>GroupFilter</code>s form a <code>CompleteLattice</code> which is equivalent to the lattice of <code>GroupTopology</code>s.</p>",
        "id": 480002685,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730441801
    },
    {
        "content": "<p>Then any basis will be a <code>GroupFilterBasis</code>.</p>",
        "id": 480002722,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730441840
    },
    {
        "content": "<p>I can't speak for Patrick but I am a consumer of these funny things and in my experience you only really want them as technical intermediate tools along the way to prove that eg a ring with a topology is a topological ring. For example our proof that the finite adeles are a topological ring uses this kind of machinery.</p>\n<p>See for example <a href=\"https://github.com/leanprover-community/mathlib4/blob/318cb7184d6e13f32a69869057dab5bcfe652f0d/Mathlib/RingTheory/DedekindDomain/FiniteAdeleRing.lean#L398-L399\">https://github.com/leanprover-community/mathlib4/blob/318cb7184d6e13f32a69869057dab5bcfe652f0d/Mathlib/RingTheory/DedekindDomain/FiniteAdeleRing.lean#L398-L399</a></p>",
        "id": 480044301,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730464384
    },
    {
        "content": "<p>Hmmmm, so Yury is indeed raising an interesting point. First, let me mention that most of the interesting results <em>do</em> exist in a version that does not mention filter bases, but they don't have fancy bundling (e.g <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopologicalGroup.of_nhds_one#doc\">docs#TopologicalGroup.of_nhds_one</a>). But indeed:</p>\n<ol>\n<li>We don't have the construction of the topology starting from a \"group filter\" (we do for filter bases)</li>\n<li>It would make sense to just move bases later (e.g have a theorem characterizing group filters in terms of filter bases directly)</li>\n</ol>\n<p>This doesn't make my life easier because it means more refactoring, but I guess that makes sense. I don't think we want to bundle it on top of filter though (I'd prefer a predicate on filters), precisely because I don't want these things to leak outside of the \"I'm building up some topology and proving it's compatible with algebra\" phase : we want most people to deal with usual <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter#doc\">docs#Filter</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.HasBasis#doc\">docs#Filter.HasBasis</a> only.</p>",
        "id": 480052126,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1730467900
    },
    {
        "content": "<p>So I guess I need to do that next (no guarantee about the time of completion), unless someone has some objection</p>",
        "id": 480052237,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1730467936
    },
    {
        "content": "<p>/me is realizing the size of that second refactor...</p>",
        "id": 480061074,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1730471386
    },
    {
        "content": "<p>One problem I have (apart from not wanting to spend my weekend on that) is that I won't be able to make the API uniform because of mathematical problems. For example, if I were to modify <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopologicalGroup.of_nhds_one#doc\">docs#TopologicalGroup.of_nhds_one</a> to assume <code>IsGroupFilter</code>, it would be natural to do the same for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousInv.of_nhds_one#doc\">docs#ContinuousInv.of_nhds_one</a>. The problem is, the natural <code>IsContinuousInvFilter</code> definition would <em>not</em> be strong enough to ensure that there exists a topology with continuous inversion and that filter as neighborhoods of one.</p>",
        "id": 480071443,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1730475250
    },
    {
        "content": "<p>So I really don't know what is the best approach anymore</p>",
        "id": 480071569,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1730475303
    },
    {
        "content": "<p>Thinking that maybe one step today is better than two steps in one month, let me ask two questions:<br>\nWould Anatole's suggested refactoring prevent a subsequent refactor along the lines indicated by Yuri? Would it be made obsolete?</p>",
        "id": 480071939,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1730475458
    },
    {
        "content": "<p>Note: I don't use this part of the library. I've asked a question that looks reasonable to me, but I know nothing about applications (in particular, I can't understand mathematically what <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> is talking about since I don't know what finite adeles are), so it's possible that in practice it's more convenient to work with filter bases.</p>",
        "id": 480088128,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730481371
    },
    {
        "content": "<p>I don't care about studying group-filters or group-filter-bases or anything like that. But I do care about things like \"given a commutative ring R and an ideal J, put the topological ring structure on R where powers J^n of J are a basis of open neighbourhoods of zero\" or \"given a commutative ring R and a subring S which has a topology, extend this topology to R by translating S around and this makes R into a topological ring\". I <em>think</em> that the only reason we have these funny group-filter-basis things in mathlib is as an auxiliary tool in order for us to make constructions like this easier. The difficulty with doing everything directly is that it's not difficult to write down a formula for the open sets, but then it's very tedious in general to prove that addition and multiplication are continuous if all you have is this formula. The trick with these auxiliary constructions is that they say things like \"if you know what the topology looks like near the identity, and the open sets near the identity satisfy some typically easy-to-check axioms, then the topology you get by translating the picture near the identity around <em>automatically</em> makes multiplication/addition/negation/whatever continuous\". But maybe it would also be easy with your approach.</p>",
        "id": 480118241,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730495178
    },
    {
        "content": "<p>Perhaps a more coherent answer is \"in practice you tend to be given the basis, not the filter\". For example you are given J^n for all n, not \"the set of all subsets which happen to contain J^n for some n\".</p>",
        "id": 480118428,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730495299
    },
    {
        "content": "<p>I agree with Kevin, I don’t see any example where you would give the filter directly here.</p>",
        "id": 480213319,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1730549405
    },
    {
        "content": "<p>in any case, it's probably simpler to define a filter as the one generated by some sets, and if you have been lucky enough to provide all of them, to state it as a theorem.</p>",
        "id": 480240128,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1730571670
    },
    {
        "content": "<p>Okay, I took some time to think about this, and here are my conclusions.</p>\n<p>First, I think Yury's suggestion definitely makes sense, and I'm absolutely convinced that one could make a perfectly usable API from it (wether you like filters or filter bases).</p>\n<p>The thing that makes me want to stick with my approach (other than \"I don't want to redo this refactor again\") is that I'm worried about giving too much importance to what is really a technical trick. Arguably my proposal is not perfect in this aspect either (e.g maybe <a href=\"https://github.com/leanprover-community/mathlib4/blob/1e03faf1188a2060cfe026068c39efe3c71c704c/Mathlib/Topology/Algebra/FilterBasisNew.lean#L163\">this lemma</a> should just be stated next to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopologicalGroup.of_nhds_one#doc\">docs#TopologicalGroup.of_nhds_one</a> without bundling anything in a fancy structure). The reason I care about this is that all of these tricks become useless as soon as you just want to prove <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousMul#doc\">docs#ContinuousMul</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousSMul#doc\">docs#ContinuousSMul</a> in isolation of any extra algebraic structures, and making these kind of generalizations painful (e.g because the APIs are completely distinct) would be very annoying. To take a concrete example, I think I would be against Yury's proposal to <em>use</em> the lattice isomorphism between group topologies and group filters, because this approach completely breaks down for monoid topologies.</p>\n<p>So my point is that we should focus on making these things easy to use, rather than trying to make them more general.</p>\n<p>If everyone is convinced by this argument, I'm going to move forward with my proposal.</p>",
        "id": 481931945,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1731413404
    },
    {
        "content": "<p>Here's a test case which I'll need soon! If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">A_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> are a family of topological groups and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">H_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> are a family of open subgroups, then I want to make the restricted product of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">A_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> over the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">H_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> to be a topological group, with a basis for the topology on the restricted product being <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mi>i</mi></msub><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\prod_i U_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.162em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>⊆</mo><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_i\\subseteq A_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> open for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>=</mo><msub><mi>H</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_i=H_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> for all but finitely many <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>.</p>",
        "id": 481973537,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731424825
    }
]