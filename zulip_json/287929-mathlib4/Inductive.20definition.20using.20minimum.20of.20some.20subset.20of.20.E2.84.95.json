[
    {
        "content": "<p>I want to define a sequence inductively, <strong>each term depending on the last and is defined as the minimum of some subset of ℕ</strong>. I found that<code>sInf</code> seems not so convenient while using. How shall I simplify <code>Nat.find ⋯ = 3</code> or should I use something other than <code>sInf</code> instead? (ℕ is well-ordered. Could I utilize this fact?)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span>\n<span class=\"n\">decreasing_by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_succ_self</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">A0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A0</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">prime_three</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">dif_pos</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  A0 : A 0 = 2</span>\n<span class=\"cm\">  h : ∃ x &gt; A 0, Nat.Prime x</span>\n<span class=\"cm\">  ⊢ Nat.find ⋯ = 3</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>",
        "id": 491065307,
        "sender_full_name": "Tony Ma",
        "timestamp": 1735366699
    },
    {
        "content": "<p>you might want to take a look at how <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.Subtype.ofNat#doc\">docs#Nat.Subtype.ofNat</a> does this using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.Subtype.succ#doc\">docs#Nat.Subtype.succ</a></p>",
        "id": 491065781,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1735367198
    },
    {
        "content": "<p>(or just use <code>Nat.Subtype.ofNat</code> itself)</p>",
        "id": 491065794,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1735367216
    },
    {
        "content": "<p>unless I'm misreading you and you're trying to do something more complex than just enumerating an infinite set (which is how I interpreted your example)</p>",
        "id": 491065949,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1735367398
    },
    {
        "content": "<p>The precise definition I wanted is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>So, the next element depends on the previous.</p>",
        "id": 491068606,
        "sender_full_name": "Tony Ma",
        "timestamp": 1735369968
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span> I guess inductive definition is required in my case.</p>",
        "id": 491068692,
        "sender_full_name": "Tony Ma",
        "timestamp": 1735370043
    },
    {
        "content": "<p>Well, there's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.strongRecOn#doc\">docs#Nat.strongRecOn</a> as another option... not sure what the pros or cons here would be</p>",
        "id": 491069374,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1735370643
    },
    {
        "content": "<p>Is there a way to simplify, if I still use <code>sInf</code>?</p>",
        "id": 491069424,
        "sender_full_name": "Tony Ma",
        "timestamp": 1735370689
    },
    {
        "content": "<p>I'm not sure... btw it looks like one of your conditions (<code>∀ i j k : Finset.Icc 0 n, A i + A j ≠ 3 * A k</code>) doesn't mention <code>x</code>... is that a typo?</p>",
        "id": 491069473,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1735370756
    },
    {
        "content": "<p>Oh yes. I shall remove that.</p>",
        "id": 491069577,
        "sender_full_name": "Tony Ma",
        "timestamp": 1735370849
    },
    {
        "content": "<p>What is the way to use strongRecOn?</p>",
        "id": 491069683,
        "sender_full_name": "Tony Ma",
        "timestamp": 1735370928
    },
    {
        "content": "<p>This isn't the best explanation, but:</p>\n<p>You pass it two arguments, the first being the input and the second argument is the inductive step, which you define as a function like <code>fun n IH =&gt; ...</code></p>\n<p>Within that function, you're able to use <code>IH</code> to access previously defined values. The type of <code>IH</code> is <code>(x : Nat) → x &lt; n → motive x</code>, so if you pass in some <code>x</code> along with a proof that <code>x &lt; n</code>, you get back the value of <code>A x</code> (which is what <code>motive x</code> is).</p>",
        "id": 491070185,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1735371463
    },
    {
        "content": "<p>Sorry I think I might be not familiar with how to define something... Could you show me some example that uses strongRecOn in definitino?</p>",
        "id": 491070345,
        "sender_full_name": "Tony Ma",
        "timestamp": 1735371621
    },
    {
        "content": "<p>honestly I think I'm leading you down the wrong path here... you should probably just stick with the inductive definition you were working with</p>",
        "id": 491070617,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1735371944
    },
    {
        "content": "<p>Ok. Nevermind and thx a lot. But maybe I could still use the inductive definition with sInf replaced by something better? Should I prove some lemma before or what could I do to avoid the complicated `Nat.find ... = 3</p>",
        "id": 491070724,
        "sender_full_name": "Tony Ma",
        "timestamp": 1735372037
    },
    {
        "content": "<p>What's the issue with using <code>sInf</code>?</p>",
        "id": 491122447,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735422231
    },
    {
        "content": "<p>The natural numbers implement <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ConditionallyCompleteLinearOrderBot#doc\">docs#ConditionallyCompleteLinearOrderBot</a> which is a very specific typeclass that interfaces well with them</p>",
        "id": 491122520,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735422288
    },
    {
        "content": "<p>There's even a few lemmas for well-ordered CCLOBs, such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=csInf_mem#doc\">docs#csInf_mem</a></p>",
        "id": 491122567,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735422334
    },
    {
        "content": "<p>You should only really be using <code>Nat.find</code> if you care about computability. In fact, you can see in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.instInfSet#doc\">docs#Nat.instInfSet</a> that <code>sInf</code> on naturals is defined in terms of <code>Nat.find</code>.</p>",
        "id": 491122645,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735422393
    }
]