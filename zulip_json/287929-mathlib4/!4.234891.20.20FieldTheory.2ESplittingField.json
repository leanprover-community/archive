[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/4339\">!4#4339</a> a lot of definitions (for example addition on splitting fields) are defined using <code>Nat.recOn</code>. in mathlib, Lean is able to guess the motive and the definitions are quite pleasant. Now, it seems we have to explicitly tell Lean what the motive is.</p>\n<p>Is this a known problem? Is there something we can do?</p>\n<p>CC <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span></p>",
        "id": 361103874,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685030625
    },
    {
        "content": "<p>Yeah lean 4 has got a lot worse at this. And I bet your motives are not good...</p>",
        "id": 361149130,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685042719
    },
    {
        "content": "<p>(you can at least write <code>(motive := ...)</code> instead of the <code>@</code> approach</p>",
        "id": 361149309,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685042774
    },
    {
        "content": "<p>Yes, that's what we're doing</p>",
        "id": 361149516,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685042855
    },
    {
        "content": "<p>I believe this is a file that will immediately compel us to improve core just so we can port it, like OperatorNorm</p>",
        "id": 361185398,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1685058632
    },
    {
        "content": "<p>Is it just missing an <code>elab_as_eliminator</code> attribute or something similar?</p>",
        "id": 361186886,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1685059703
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>  I don't know. But if you want to give a try you're more than welcome...</p>",
        "id": 361189024,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685061217
    },
    {
        "content": "<p>I'm looking at the file now.  Changing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">X_sub_C_mul_removeFactor</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f.natDegree</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot.root</span> <span class=\"n\">f.factor</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"n\">f.removeFactor</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot.of</span> <span class=\"n\">f.factor</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">factor_dvd_of_natDegree_ne_zero</span> <span class=\"n\">hf</span>\n  <span class=\"n\">mul_divByMonic_eq_iff_isRoot.2</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">IsRoot.def</span><span class=\"o\">,</span> <span class=\"n\">eval_map</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">eval₂_mul</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">AdjoinRoot.eval₂_root</span><span class=\"o\">,</span> <span class=\"n\">MulZeroClass.zero_mul</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">X_sub_C_mul_removeFactor</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f.natDegree</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot.root</span> <span class=\"n\">f.factor</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"n\">f.removeFactor</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot.of</span> <span class=\"n\">f.factor</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">factor_dvd_of_natDegree_ne_zero</span> <span class=\"n\">hf</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">mul_divByMonic_eq_iff_isRoot</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">AdjoinRoot</span> <span class=\"n\">f.factor</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">AdjoinRoot.root</span> <span class=\"n\">f.factor</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">IsRoot.def</span><span class=\"o\">,</span> <span class=\"n\">eval_map</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">eval₂_mul</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">AdjoinRoot.eval₂_root</span><span class=\"o\">,</span> <span class=\"n\">MulZeroClass.zero_mul</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>makes the elaboration time go from over 50s to &lt;16s.  I have already seen elsewhere that <code>apply</code> is sometimes much faster than <code>refine/exact</code> or term-mode.  In this case, not providing explicitly the implicit arguments <code>R</code> and <code>a</code> doubles the elaboration time to ~34s.</p>",
        "id": 361226875,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685082329
    },
    {
        "content": "<p>I guess that similar hacks could be done systematically, but it also does not seem the right solution to the problem...</p>",
        "id": 361226882,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685082331
    },
    {
        "content": "<p>Does adjusting to use <code>Nat.rec</code> instead of <code>Nat.rec_on</code> help?</p>",
        "id": 361252869,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685089794
    },
    {
        "content": "<p>In lean3 I think <code>rec</code> was harder to use in this file so we used <code>rec_on</code> instead</p>",
        "id": 361253031,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685089820
    },
    {
        "content": "<p>Switching to using the equation compiler might also be fine, though in Lean3 I think it generated <code>brec</code> recursion which was annoying</p>",
        "id": 361253159,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685089850
    },
    {
        "content": "<p>I'm trying, but I'm failing to write the correct <code>Nat.rec</code> application.</p>",
        "id": 361256928,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685090784
    },
    {
        "content": "<p>Also, I keep thinking that it seems that we are constantly fighting with the implementation of a splitting field, whereas I suspect that a better approach would be to abstract the characterising properties of \"a field in which something splits\".</p>",
        "id": 361257258,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685090876
    },
    {
        "content": "<p>(I'm not proposing this change during the port, but in the long run I suspect that it will be beneficial)</p>",
        "id": 361257504,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685090931
    },
    {
        "content": "<p>Like <code>IsSplittingField</code> in that file? :)</p>",
        "id": 361258103,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1685091100
    },
    {
        "content": "<p>Yes, although I would use it much earlier and probably do a similar thing first for <code>AdjoinRoot</code>.</p>",
        "id": 361259693,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685091553
    },
    {
        "content": "<p>Anyway, I have not actually tried, so there may very well be traps lying around...</p>",
        "id": 361259763,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685091580
    },
    {
        "content": "<p>I had a look but it doesn't seem like splitting (hah) <code>SplittingField</code> out would unblock too much. There's a use in <code>field_theory.normal</code> that might be avoidable (in the base case of <code>normal.of_is_splitting_field</code>), but seemingly more substantial uses in <code>field_theory.is_alg_closed.algebraic_closure</code> and <code>field_theory.primitive_element</code></p>",
        "id": 361263255,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1685092411
    },
    {
        "content": "<p>What I think is that a lot of the awkwardness about <code>SplittingFieldAux</code> and the issues with definitional equalities to get the instances to work may be mitigated by abstracting over what an <code>AdjoinRoot</code> is.</p>",
        "id": 361264010,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685092621
    },
    {
        "content": "<p>I'm still sad that unification seems far weaker in Lean4. I've made an example for <code>congrArg</code>, I'm gonna try to minimise this nat.rec stuff too.</p>",
        "id": 361264129,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1685092660
    },
    {
        "content": "<p>I do not know if it is weaker: the versions of the lemmas in Lean 3 grew alongside modifications to Lean to improve these specific proofs.  This happened over several years.  Right now, with the port, these files are simply shoved down Lean 4's throat, with as little modification as possible.</p>",
        "id": 361264400,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685092745
    },
    {
        "content": "<p>Maybe a better way of saying this is that Lean 4 has not evolved around these proofs.</p>",
        "id": 361264618,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685092805
    },
    {
        "content": "<p>This nat.recOn application is very simple, the expected type is given in its fullest extent and there's no magic elaboration magic that needs to be done (except identifying splitting_field_aux 0 with K). It's not the first time people have had problems with induction in lean4, and I think it'd be good to improve it</p>",
        "id": 361264721,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1685092839
    },
    {
        "content": "<p>lmk when you have a MWE</p>",
        "id": 361264916,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685092911
    },
    {
        "content": "<p>I have definitely observed <code>elab_as_elim</code> not being as powerful as lean 3 <code>elab_as_eliminator</code>, but I thought the main bugs were fixed</p>",
        "id": 361265072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685092952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361264129\">said</a>:</p>\n<blockquote>\n<p>I've made an example for <code>congrArg</code></p>\n</blockquote>\n<p>Can you share this example now so that we can all minimise it?</p>",
        "id": 361318620,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1685105696
    },
    {
        "content": "<p>Sadly, this PR is blocking all files on the path to quadratic reciprocity.</p>",
        "id": 361335779,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685109264
    },
    {
        "content": "<p>This is especially surprising, given the incredible number of different proofs of quadratic reciprocity that Gauss famously gave...</p>",
        "id": 361336025,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685109310
    },
    {
        "content": "<p>You should port measure theory and integration instead then!</p>",
        "id": 361338715,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1685109856
    },
    {
        "content": "<p>It feels like working for the competition, though...</p>",
        "id": 361338876,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685109893
    },
    {
        "content": "<p>It's an open issue on lean4 repo somewhere, I don't know what the number is but it's my only open issue there (I'm on mobile, sorry)</p>",
        "id": 361362036,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1685114670
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/issues/2051\">This</a> one</p>",
        "id": 361365400,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685115343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361336025\">said</a>:</p>\n<blockquote>\n<p>This is especially surprising, given the incredible number of different proofs of quadratic reciprocity that Gauss famously gave...</p>\n</blockquote>\n<p>I'm pretty sure that mathlib's original proof by Chris Hughes didn't use splitting fields :-) (indeed it was there well before splitting fields). But I really like Michael's refactor, it's much better to have a more conceptual proof. I'm always confused about why splitting fields are so hard in Lean.</p>",
        "id": 361381336,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685118775
    },
    {
        "content": "<p>Would it be simpler to define splitting fields in terms of the algebraic closure, rather than vice versa?</p>",
        "id": 361381924,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1685118922
    },
    {
        "content": "<p>I think we should wait and do such a refactor in Lean4 after the port, unless it's really hard to port the actual strategy. But still, we should understand why.</p>",
        "id": 361384942,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685119633
    },
    {
        "content": "<p>There's always <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>'s approach, which is different and maybe better for lean4. I don't rmemebrr what was different about it.</p>",
        "id": 361385563,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1685119788
    },
    {
        "content": "<p>Yes, I think after the port it is definitely worth considering using Junyan's algebraic closure, and then defining splitting field in terms of that.<br>\nHere's Junyan's algebraic closure for reference: <a href=\"https://gist.github.com/alreadydone/daa9760056383d31669755bbb41e2695\">https://gist.github.com/alreadydone/daa9760056383d31669755bbb41e2695</a></p>",
        "id": 361391412,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1685121025
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> do you agree that the problems started with <code>AdjoinRoot</code> and they just got worst here?</p>",
        "id": 361393894,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685121650
    },
    {
        "content": "<p>I mean, it can be easier to understand what's happening looking at <code>AdjoinRoot</code> rather than <code>SplittingField</code></p>",
        "id": 361393988,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685121680
    },
    {
        "content": "<p>AR was already quite terrible, yeah</p>",
        "id": 361399236,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1685122980
    },
    {
        "content": "<p>We've been looking at AdjoinRoot together in person, and it seems some of the reason is that <code>Polynomial.semiring K</code> on a field <code>K</code> going via <code>DivisionSemiring</code> has to be unified with <code>Polynomial.CommRing</code> going via <code>EuclideanDomain</code>. But I don't know how to avoid that/make that faster.</p>",
        "id": 361404923,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1685124428
    },
    {
        "content": "<p>I am trying to minimize the problem, and already</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Div.div</span> <span class=\"o\">(</span><span class=\"n\">f.map</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>takes more than 2 seconds to be stated. I will try to have a look at the trace.</p>",
        "id": 361441312,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685136330
    },
    {
        "content": "<p>Here <code>f : K[X]</code> with <code>K</code> a field.</p>",
        "id": 361441432,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1685136368
    },
    {
        "content": "<p>I think that I observed something similar: when Lean goes from <code>K</code> to <code>AdjoinRoot f</code> it is always very slow...  This is the issue, right?</p>",
        "id": 361441587,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685136458
    },
    {
        "content": "<p>In the example above, passing explicitly the implicit arguments <code>(R := AdjoinRoot f.factor) (a := AdjoinRoot.root f.factor)</code> makes the elaboration time go from ~35 to ~16 seconds.</p>",
        "id": 361441850,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685136565
    },
    {
        "content": "<p>In my example (the sorried one) you mean?</p>",
        "id": 361442017,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685136616
    },
    {
        "content": "<p>I meant <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361226875\">this one</a>.</p>",
        "id": 361442183,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685136713
    },
    {
        "content": "<p>On my computer, these are the timings:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--  ~8.5s</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Div.div</span> <span class=\"o\">(</span><span class=\"n\">f.map</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">--  ~2.5s</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Div.div</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">f.map</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 361442588,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685136890
    },
    {
        "content": "<p>From this, I deduce that your computer is about 4x more powerful than mine...</p>",
        "id": 361442680,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685136937
    },
    {
        "content": "<p>It's new indeed... I'm any case this looks like a reasonably small example to study</p>",
        "id": 361442789,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685136976
    },
    {
        "content": "<p>Note that it has to some work to do realize that <code>AdjoinRoot f</code> is still a field</p>",
        "id": 361442852,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685137009
    },
    {
        "content": "<p>I still think that abstracting <code>AdjoinRoot</code> to basically \"<code>K</code>-algebra with a root of <code>f</code>\" might make proofs easier and faster.  I am still hoping that this refactor can be done after the port, but I am less and less optimistic about this.</p>",
        "id": 361442949,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685137074
    },
    {
        "content": "<p>(adding, where appropriate, assumptions that the algebra map is injective, that the image is generated by the root,...)</p>",
        "id": 361443109,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685137140
    },
    {
        "content": "<p>Something along these lnes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.Adjoin.Field</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Polynomial</span> <span class=\"n\">AdjoinRoot</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">splex</span> <span class=\"o\">(</span><span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→+*</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">,</span>  <span class=\"n\">eval₂</span> <span class=\"n\">hom</span> <span class=\"n\">r</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">d</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">splex</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">of</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">root</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">eval₂_root</span> <span class=\"n\">f</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>The definition is still slow, but I am hopeful that working with <code>splex</code> instead of <code>d</code> would be better.</p>",
        "id": 361443415,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685137282
    },
    {
        "content": "<p>It'll be funny if my diamond stuff has to get overwritten so fast</p>",
        "id": 361444216,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1685137644
    },
    {
        "content": "<p>On the one hand I would like all lean3 code to work in lean4 but if refactoring all 'bad' code leads to a much faster mathlib4 in the future... Maybe it's the right price to pay</p>",
        "id": 361444352,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1685137693
    },
    {
        "content": "<p>These files are already slow in mathlib3, just not as much as in Lean4.  It was not pleasant to work with them even before the port.  At least for me...</p>",
        "id": 361444485,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685137770
    },
    {
        "content": "<p>We cannot refactor mathlib4 without doing it in mathlib3 (mathport would produce broken code). In my opinion we should consider this as a last resort</p>",
        "id": 361444486,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685137771
    },
    {
        "content": "<p>Here's some relevant parts of the typeclass trace for <code>Div.div (f.map (of f)) (X - C (root f)) = 0</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>[Meta.isDefEq] [1.969095s] ✅ CommSemiring.toSemiring =?= DivisionSemiring.toSemiring ▼\n  [] [1.968134s] ✅ CommSemiring.toSemiring =?= CommSemiring.toSemiring ▼\n    [] [1.968080s] ✅ CommRing.toCommSemiring.1 =?= Semifield.toCommSemiring.1 ▼\n      [] [1.968001s] ✅ Ring.toSemiring =?= Ring.toSemiring ▼\n        [] [1.967957s] ✅ CommRing.toRing.1 =?= CommRing.toRing.1 ▼\n          [] [1.967225s] ✅ Ring.toSemiring =?= Ring.toSemiring ▼\n            [] [1.966967s] ✅ (Function.Surjective.ring Quotient.mk'' (_ : Function.Surjective Quotient.mk'')\n                    (_ : Quotient.mk'' 0 = Quotient.mk'' 0) (_ : Quotient.mk'' 1 = Quotient.mk'' 1)\n                    (_ : ∀ (x x_1 : K[X]), Quotient.mk'' (x + x_1) = Quotient.mk'' (x + x_1))\n                    (_ : ∀ (x x_1 : K[X]), Quotient.mk'' (x * x_1) = Quotient.mk'' (x * x_1))\n                    (_ : ∀ (x : K[X]), Quotient.mk'' (-x) = Quotient.mk'' (-x))\n                    (_ : ∀ (x x_1 : K[X]), Quotient.mk'' (x - x_1) = Quotient.mk'' (x - x_1))\n                    (_ : ∀ (x : K[X]) (x_1 : ℕ), Quotient.mk'' (x_1 • x) = Quotient.mk'' (x_1 • x))\n                    (_ : ∀ (x : K[X]) (x_1 : ℤ), Quotient.mk'' (x_1 • x) = Quotient.mk'' (x_1 • x))\n                    (_ : ∀ (x : K[X]) (x_1 : ℕ), Quotient.mk'' (x ^ x_1) = Quotient.mk'' (x ^ x_1))\n                    (_ : ∀ (x : ℕ), Quotient.mk'' ↑x = Quotient.mk'' ↑x)\n                    (_ :\n                      ∀ (x : ℤ),\n                        Quotient.mk'' ↑x =\n                          Quotient.mk''\n                            ↑x)).1 =?= (Function.Surjective.ring Quotient.mk'' (_ : Function.Surjective Quotient.mk'')\n                    (_ : Quotient.mk'' 0 = Quotient.mk'' 0) (_ : Quotient.mk'' 1 = Quotient.mk'' 1)\n                    (_ : ∀ (x x_1 : K[X]), Quotient.mk'' (x + x_1) = Quotient.mk'' (x + x_1))\n                    (_ : ∀ (x x_1 : K[X]), Quotient.mk'' (x * x_1) = Quotient.mk'' (x * x_1))\n                    (_ : ∀ (x : K[X]), Quotient.mk'' (-x) = Quotient.mk'' (-x))\n                    (_ : ∀ (x x_1 : K[X]), Quotient.mk'' (x - x_1) = Quotient.mk'' (x - x_1))\n                    (_ : ∀ (x : K[X]) (x_1 : ℕ), Quotient.mk'' (x_1 • x) = Quotient.mk'' (x_1 • x))\n                    (_ : ∀ (x : K[X]) (x_1 : ℤ), Quotient.mk'' (x_1 • x) = Quotient.mk'' (x_1 • x))\n                    (_ : ∀ (x : K[X]) (x_1 : ℕ), Quotient.mk'' (x ^ x_1) = Quotient.mk'' (x ^ x_1))\n                    (_ : ∀ (x : ℕ), Quotient.mk'' ↑x = Quotient.mk'' ↑x)\n                    (_ : ∀ (x : ℤ), Quotient.mk'' ↑x = Quotient.mk'' ↑x)).1 ▶\n</code></pre></div>\n<p>Two seconds to decide if <code>Ring.toSemiring =?= Ring.toSemiring</code>. The next step is a baad way to do this and it has further ramifications. One of the two seconds is spent solving this:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>                    [] [1.005322s] ✅ AddCommMonoid.mk\n                          (_ :\n                            ∀ (a b : RingCon.Quotient (Ideal.Quotient.ringCon (Ideal.span {f}))),\n                              a + b =\n                                b +\n                                  a) =?= AddCommMonoid.mk\n                          (_ : ∀ (a b : RingCon.Quotient (Ideal.Quotient.ringCon (Ideal.span {f}))), a + b = b + a)\n</code></pre></div>",
        "id": 361448262,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685139506
    },
    {
        "content": "<p>You might have several problems, but I suspect that one of them is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.Adjoin.Field</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Polynomial</span> <span class=\"n\">AdjoinRoot</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">DivisionSemiring.toSemiring</span> <span class=\"o\">:</span> <span class=\"n\">Semiring</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">))</span>\n  <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommSemiring.toSemiring</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">CommRing.toCommSemiring</span> <span class=\"o\">:</span> <span class=\"n\">Semiring</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n<span class=\"c1\">-- tactic execution of Lean.Parser.Tactic.refl took 820ms</span>\n<span class=\"c1\">-- `congr` takes a similar amount of time.</span>\n</code></pre></div>\n<p>If f is irreducible then the adjoin-root ring will be a field, and hence a semiring via DivisionSemiring. But it's a semiring for any f (e.g. via CommSemiring). But typeclass inference isn't very good at proofs -- basically the only tactic it learnt was <code>rfl</code>, and <code>rfl</code>takes over 3/4 of a second to prove that this isn't a diamond.</p>",
        "id": 361451009,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685141011
    },
    {
        "content": "<p>Yep I agree. I am trying with (on the bus to the airport, not ideal...)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">Field.toSemifield</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">Field.toDivisionRing</span>\n</code></pre></div>\n<p>and it indeed it's faster, but still slow. Thinking about it.</p>",
        "id": 361453014,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685142047
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361448262\">said</a>:</p>\n<blockquote>\n<p>Two seconds to decide if <code>Ring.toSemiring =?= Ring.toSemiring</code>. The next step is a baad way to do this and it has further ramifications.</p>\n</blockquote>\n<p>That's it, we're going to have to change core again (most likely)</p>",
        "id": 361475861,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1685160595
    },
    {
        "content": "<p>By the way, on my computer it seems that adding <code>variable {K : Type u}</code> speeds up the computations (whether or not you have <code>universe u</code> before).</p>\n<p>However, <code>variable {K : Type _}</code>, with no mention of an explicit/autoImplicit universe, goes back to being about the same timing as not putting the <code>variable {K}</code> at all.</p>\n<p>Do you get the same behaviour?</p>",
        "id": 361486262,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685168290
    },
    {
        "content": "<p>I am pretty sure this is not the only problem, but changing the instance of <code>Field (AdjoinRoot f)</code> from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">field</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">AdjoinRoot.instCommRing</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"n\">Ideal.Quotient.field</span>\n      <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"k\">with</span>\n    <span class=\"n\">ratCast</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">of</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n    <span class=\"n\">ratCast_mk</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n      <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">GroupWithZero</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Ideal.Quotient.groupWithZero</span> <span class=\"n\">_</span>\n      <span class=\"c1\">-- porting note: was</span>\n      <span class=\"c1\">-- `rw [Rat.cast_mk' (K := ℚ), _root_.map_mul, _root_.map_intCast, map_inv₀, map_natCast]`</span>\n      <span class=\"n\">convert_to</span> <span class=\"o\">((</span><span class=\"n\">Rat.mk'</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n      <span class=\"bp\">.</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">_root_.map_mul</span><span class=\"o\">,</span> <span class=\"n\">map_intCast</span><span class=\"o\">,</span> <span class=\"n\">map_inv₀</span><span class=\"o\">,</span> <span class=\"n\">map_natCast</span><span class=\"o\">]</span>\n      <span class=\"bp\">.</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Rat.cast_mk'</span><span class=\"o\">,</span> <span class=\"n\">_root_.map_mul</span><span class=\"o\">,</span> <span class=\"n\">map_intCast</span><span class=\"o\">,</span> <span class=\"n\">map_inv₀</span><span class=\"o\">,</span> <span class=\"n\">map_natCast</span><span class=\"o\">]</span>\n    <span class=\"n\">qsmul</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">•</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n    <span class=\"n\">qsmul_eq_mul'</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"c1\">-- porting note: I gave the explicit motive and changed `rw` to `simp`.</span>\n      <span class=\"n\">AdjoinRoot.induction_on</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">smul_mk</span><span class=\"o\">,</span> <span class=\"n\">of</span><span class=\"o\">,</span> <span class=\"n\">RingHom.comp_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span><span class=\"o\">,</span> <span class=\"n\">Polynomial.rat_smul_eq_C_mul</span><span class=\"o\">]</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">field</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">AdjoinRoot.instCommRing</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"n\">Quotient.groupWithZero</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"k\">with</span>\n    <span class=\"c1\">--Ideal.Quotient.field</span>\n    <span class=\"c1\">--  (span {f} : Ideal K[X]) with</span>\n    <span class=\"n\">ratCast</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">of</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n    <span class=\"n\">ratCast_mk</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n      <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">GroupWithZero</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Ideal.Quotient.groupWithZero</span> <span class=\"n\">_</span>\n      <span class=\"c1\">-- porting note: was</span>\n      <span class=\"c1\">-- `rw [Rat.cast_mk' (K := ℚ), _root_.map_mul, _root_.map_intCast, map_inv₀, map_natCast]`</span>\n      <span class=\"n\">convert_to</span> <span class=\"o\">((</span><span class=\"n\">Rat.mk'</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n      <span class=\"bp\">.</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">_root_.map_mul</span><span class=\"o\">,</span> <span class=\"n\">map_intCast</span><span class=\"o\">,</span> <span class=\"n\">map_inv₀</span><span class=\"o\">,</span> <span class=\"n\">map_natCast</span><span class=\"o\">]</span>\n      <span class=\"bp\">.</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Rat.cast_mk'</span><span class=\"o\">,</span> <span class=\"n\">_root_.map_mul</span><span class=\"o\">,</span> <span class=\"n\">map_intCast</span><span class=\"o\">,</span> <span class=\"n\">map_inv₀</span><span class=\"o\">,</span> <span class=\"n\">map_natCast</span><span class=\"o\">]</span>\n    <span class=\"n\">qsmul</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">•</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n    <span class=\"n\">qsmul_eq_mul'</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"c1\">-- porting note: I gave the explicit motive and changed `rw` to `simp`.</span>\n      <span class=\"n\">AdjoinRoot.induction_on</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">smul_mk</span><span class=\"o\">,</span> <span class=\"n\">of</span><span class=\"o\">,</span> <span class=\"n\">RingHom.comp_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span><span class=\"o\">,</span> <span class=\"n\">Polynomial.rat_smul_eq_C_mul</span><span class=\"o\">]</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>makes <code>mul_div_root_cancel</code> quite faster: from 6.2 seconds to 0.4 seconds (and <code>/</code> instead of <code>Div.div</code> works!).</p>",
        "id": 361524885,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685181215
    },
    {
        "content": "<p>Do you think that the speed up is due to having fewer overlaps between the fields of the parents?  Is this a general heuristic?</p>\n<p>Maybe someone else has already observed this.</p>",
        "id": 361531918,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685182923
    },
    {
        "content": "<p>I don't know</p>",
        "id": 361532401,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685183067
    },
    {
        "content": "<p>But I've the impression it really helps, it solves Kevin's problem above</p>",
        "id": 361532485,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685183091
    },
    {
        "content": "<p>Just to make sure that I am following: you told lean to copy the fields of GroupWithZero, instead of the ones of Field and things are faster, right?</p>",
        "id": 361532724,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685183153
    },
    {
        "content": "<p>I wonder if this means that we should try to create typeclasses that are as disjoint as possible.</p>",
        "id": 361532880,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685183190
    },
    {
        "content": "<p>(or whether this is something that could be done semi-automatically)</p>",
        "id": 361533038,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685183223
    },
    {
        "content": "<p>Yes, I (randomly) copied the proof that the quotient by a maximal ideal is a field instead of using the theorem itself</p>",
        "id": 361534373,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685183572
    },
    {
        "content": "<p>At least the field providing the group with zero structure</p>",
        "id": 361534469,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685183594
    },
    {
        "content": "<p>I am wondering what happens if we make <code>AdjoinRoot</code> a notation or something similar</p>",
        "id": 361534861,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685183692
    },
    {
        "content": "<p>There was talk about having <code>Group (G : Type) [Mul G] [One G] [Inv G]</code> eventually in Lean 4. That would solve a lot of these problems I think.</p>",
        "id": 361540673,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1685185159
    },
    {
        "content": "<p>Chris, is the issue then mostly with overlapping fields that have data?  Or simply avoiding overlaps, whether or not they carry data?</p>",
        "id": 361541994,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685185457
    },
    {
        "content": "<p>I am saying this, since for <code>Group</code> you gave exactly the data fields...</p>",
        "id": 361542080,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685185477
    },
    {
        "content": "<p>This does not seem too wild: having typeclasses for each data field and then mix-and-match...</p>",
        "id": 361542285,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685185529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361540673\">said</a>:</p>\n<blockquote>\n<p>There was talk about having <code>Group (G : Type) [Mul G] [One G] [Inv G]</code> eventually in Lean 4. That would solve a lot of these problems I think.</p>\n</blockquote>\n<p>It's hard to know whether this will cause other problem elsewhere without doing it, and that's a herculean effort...</p>",
        "id": 361544766,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685186232
    },
    {
        "content": "<p>There is something that looks a little funny when you <code>#print</code> the two instances, the one going via <code>field</code> (<code>AdjoinRoot.field</code>) and the one going via <code>GroupWithZero</code> (<code>AdjoinRoot.pield</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">AdjoinRoot.field.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n  <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]}</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"bp\">→</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"bp\">↦</span>\n  <span class=\"k\">let</span> <span class=\"n\">src</span> <span class=\"o\">:=</span> <span class=\"n\">instCommRing</span> <span class=\"n\">f</span><span class=\"bp\">;</span>              <span class=\"c1\">-- &lt;--- both called `src`</span>\n  <span class=\"k\">let</span> <span class=\"n\">src</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient.field</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">})</span><span class=\"bp\">;</span>   <span class=\"c1\">-- &lt;--- both called `src`</span>\n  <span class=\"n\">Field.mk</span> <span class=\"n\">Field.zpow</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">⧸</span> <span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}),</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">x_1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">AdjoinRoot.pield.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n  <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]}</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"bp\">→</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"bp\">↦</span>\n  <span class=\"k\">let</span> <span class=\"n\">src</span> <span class=\"o\">:=</span> <span class=\"n\">instCommRing</span> <span class=\"n\">f</span><span class=\"bp\">;</span>                       <span class=\"c1\">-- &lt;--- one called src</span>\n  <span class=\"k\">let</span> <span class=\"n\">src_1</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient.groupWithZero</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">})</span><span class=\"bp\">;</span>  <span class=\"c1\">-- &lt;--- the other called src_1</span>\n  <span class=\"n\">Field.mk</span> <span class=\"n\">GroupWithZero.zpow</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">⧸</span> <span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}),</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">x_1</span>\n</code></pre></div>",
        "id": 361545107,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685186322
    },
    {
        "content": "<p>there shouldn't be any <code>let</code>s in instances in the first place, you should be using <code>letI</code></p>",
        "id": 361545414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685186406
    },
    {
        "content": "<p>I haven't, this is the whole <code>parent, fields</code> setup.</p>",
        "id": 361545605,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685186454
    },
    {
        "content": "<p>The instances are the <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361524885\">ones above</a></p>",
        "id": 361545682,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685186481
    },
    {
        "content": "<p>Oh, I see a <code>letI</code>!!!</p>",
        "id": 361545713,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685186502
    },
    {
        "content": "<p>The instances above now look so contrived: you get the <code>ratCast</code> fields by getting the <code>GroupWithZero</code> instance.</p>",
        "id": 361545990,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685186586
    },
    {
        "content": "<p><del>Eric</del>Mario, I think that you have spotted something very interesting, but I suspect that the <code>let</code> shown in the print are not the <code>letI</code>, right?</p>",
        "id": 361546225,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685186652
    },
    {
        "content": "<p>Using my second approach what happens if we remove the <code>letI</code>? (I'm on mobile)</p>",
        "id": 361546472,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685186725
    },
    {
        "content": "<p>It works...</p>",
        "id": 361546559,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685186750
    },
    {
        "content": "<p>Asking since I give it by hand</p>",
        "id": 361546668,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685186776
    },
    {
        "content": "<p>In any case I think we should understand why the rest of the file is still slow. This is one issue for sure, but not the only one</p>",
        "id": 361546955,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685186844
    },
    {
        "content": "<p>Ok, I'll replace the current instance with your version, Riccardo and remove the <code>letI</code>.</p>",
        "id": 361547153,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685186885
    },
    {
        "content": "<p>Ah, this is a change to an already ported file: should I open a new PR or should I add the change to the <code>SplittingField</code> PR?</p>",
        "id": 361547408,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685186944
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, first, sorry that I mistook you for Eric!</p>\n<p>Second, I think that the <code>let</code>s are introduced by the </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">parent</span><span class=\"o\">,</span> <span class=\"n\">field</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>syntax, right?  I find this syntax very hard to use, so I may have some completely wrong ideas...</p>",
        "id": 361547914,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685187081
    },
    {
        "content": "<p>Mmm, rather than opening a PR maybe it's better to try to fix the rest of the problem</p>",
        "id": 361548041,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685187117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361545414\">said</a>:</p>\n<blockquote>\n<p>there shouldn't be any <code>let</code>s in instances in the first place, you should be using <code>letI</code></p>\n</blockquote>\n<p>Doesnt <code>{ (some foo expr) with bar :=  .. }</code> generate a <code>let</code>?</p>",
        "id": 361548225,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685187155
    },
    {
        "content": "<p>In any case <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> should check that we are not reintroducing the diamond</p>",
        "id": 361548262,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685187165
    },
    {
        "content": "<p>Eric, that is what I also think...</p>",
        "id": 361548431,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685187210
    },
    {
        "content": "<p>Riccardo, I am going to try to make this change on a new branch of mathlib<code>3</code> and see if it breaks anything.</p>",
        "id": 361548687,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685187268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361548225\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361545414\">said</a>:</p>\n<blockquote>\n<p>there shouldn't be any <code>let</code>s in instances in the first place, you should be using <code>letI</code></p>\n</blockquote>\n<p>Doesnt <code>{ (some foo expr) with bar :=  .. }</code> generate a <code>let</code>?</p>\n</blockquote>\n<p>Perhaps it does. Lean generates a lot of <code>let</code>s for this kind of thing, <code>letI</code> isn't in core</p>",
        "id": 361549907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685187574
    },
    {
        "content": "<p>Does the <code>__ := some foo expr</code> syntax generate <code>letI</code>?</p>",
        "id": 361550627,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685187802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361548687\">said</a>:</p>\n<blockquote>\n<p>Riccardo, I am going to try to make this change on a new branch of mathlib<code>3</code> and see if it breaks anything.</p>\n</blockquote>\n<p>Just to check, you're not describing a <code>let</code>/<code>letI</code> change, right? The meanings are different in lean 3...</p>",
        "id": 361550884,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685187860
    },
    {
        "content": "<p>No, the observation is that in the Lean4 proof, the <code>letI</code> inside the <code>ratCast_mk</code> field is superfluous.  Moreover, you can get away with only copying the fields of <code>GroupWithZero</code>, instead of all the ones from <code>Field</code>.  I am implementing changes analogous to these in Lean3, if I can, to see if something breaks there.</p>",
        "id": 361551658,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685188046
    },
    {
        "content": "<p>I guess that the worry is that these changes in Lean4 might break something down the line that is not yet ported, so this is some form of test that maybe they won't.</p>",
        "id": 361551898,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685188098
    },
    {
        "content": "<p>Sure, testing that this doesn't break mathlib3 is necessary. But there must be something more fundamental that is wrong about <code>AdjoinRoot</code>, there are other slow declarations, slower than in mathlib3 I think</p>",
        "id": 361553546,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685188510
    },
    {
        "content": "<p>There is some <code>example</code>s in the file that guarantee the diamond won't break</p>",
        "id": 361554135,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1685188674
    },
    {
        "content": "<p>So as long as those aren't removed</p>",
        "id": 361554201,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1685188684
    },
    {
        "content": "<p>I have not removed the <code>letI</code>  from mathlib3, but going via <code>group_with_zero</code> does not break the <code>splitting_field</code> file.</p>",
        "id": 361555513,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685189005
    },
    {
        "content": "<p>(I found 6 examples there, there are comments about the diamond about them and they still work.</p>",
        "id": 361555786,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685189058
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/actions/runs/5098647698/jobs/9165907811\">CI confirms</a> that in Lean3, using the fields of <code>group_with_zero</code> does not break proofs further down the line</p>",
        "id": 361558731,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685189854
    },
    {
        "content": "<p>Fwiw, the closest thing to Lean4 letI in mathlib3 is tactic-mode haveI</p>",
        "id": 361564737,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685191500
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361558731\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/actions/runs/5098647698/jobs/9165907811\">CI confirms</a> that in Lean3, using the fields of <code>group_with_zero</code> does not break proofs further down the line</p>\n</blockquote>\n<p>The relevant diff is <a href=\"https://github.com/leanprover-community/mathlib/compare/spf_via_gw0\">here</a></p>",
        "id": 361565458,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685191700
    },
    {
        "content": "<p>I am analyzing the trace of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">modByMonicHom</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">g.Monic</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AdjoinRoot</span> <span class=\"n\">g</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">Submodule.liftQ</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Polynomial.modByMonicHom</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n        <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"n\">g</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"o\">(</span><span class=\"n\">mem_ker_mod_by_monic</span> <span class=\"n\">hg</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"n\">Ideal.mem_span_singleton.mp</span> <span class=\"n\">hf</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">&lt;|</span>\n    <span class=\"o\">(</span><span class=\"n\">Submodule.Quotient.restrictScalarsEquiv</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"n\">g</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]))</span><span class=\"bp\">.</span><span class=\"n\">symm.toLinearMap</span>\n</code></pre></div>\n<p>that takes almost 2 seconds on my laptop. I think the relevant part is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">197048</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">Algebra.toModule</span> <span class=\"bp\">=?=</span> <span class=\"n\">Submodule.Quotient.module'</span> <span class=\"o\">(</span><span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"n\">g</span><span class=\"o\">})</span>\n</code></pre></div>\n<p>Where Lean compares two <code>Module R</code>-structure on <code>AdjoinRoot g</code> (here <code>g : K[X]</code>, and <code>K</code> is a field): the first one is via the fact that <code>AdjoinRoot g</code>is a <code>K</code>-algebra, and the second one via <code>Submodule.Quotient.module'</code>. I've tried to modify the definition of <code>Algebra K (AdjoinRoot g)</code>, but I didn't succed. On the other hand if I add by hand</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">S</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Submodule.Quotient.module'</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">g</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>the declaration is 25% faster... but I have to stop now.</p>",
        "id": 361614686,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685206917
    },
    {
        "content": "<p>Thanks Riccardo!</p>",
        "id": 361616199,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685207560
    },
    {
        "content": "<p>In the meantime, removing the <code>letI</code> from the mathlib3 proof of <code>rat_cast_mk</code> is giving me a hard time!</p>",
        "id": 361616295,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685207600
    },
    {
        "content": "<p>Is it something we really want?</p>",
        "id": 361618858,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685208768
    },
    {
        "content": "<p>Maybe not, I simply thought that it would be straightforward, but it is actually a mess of coercions.</p>",
        "id": 361620132,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685209343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361616295\">said</a>:</p>\n<blockquote>\n<p>In the meantime, removing the <code>letI</code> from the mathlib3 proof of <code>rat_cast_mk</code> is giving me a hard time!</p>\n</blockquote>\n<p>this was a recent change to the proof, let me try dig up the old proof</p>",
        "id": 361624530,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1685211229
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/18857/commits/726384b71f83edc50b7dc1f0d1a23458ed43dc53\">https://github.com/leanprover-community/mathlib/pull/18857/commits/726384b71f83edc50b7dc1f0d1a23458ed43dc53</a></p>",
        "id": 361625561,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1685211626
    },
    {
        "content": "<p>this is a relevant commit</p>",
        "id": 361625570,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1685211630
    },
    {
        "content": "<p>Thanks Eric!</p>",
        "id": 361625855,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685211765
    },
    {
        "content": "<p>I guess that this might be one of these situations where the new way of dealing with coercions pays off: in the mathlib4 version, there is no longer the need to use group_with_zero, it \"just works\".</p>",
        "id": 361625964,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685211825
    },
    {
        "content": "<p>Does defining the <code>Field</code> instances in stages help?</p>",
        "id": 361634944,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1685216001
    },
    {
        "content": "<p>e.g. define the <code>AddCommMonoid (SplittingFieldAux n f)</code> first.</p>",
        "id": 361634988,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1685216023
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> Have you opened a mathlib3 PR? If it really works and makes things faster I don't see any reason to wait (especially now that in mathlib4 is almost a leaf file)</p>",
        "id": 361751621,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685279127
    },
    {
        "content": "<p>I am talking about <code>adjoin_root</code></p>",
        "id": 361751961,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685279221
    },
    {
        "content": "<p>I did not open the PR, but the mathlib3 branch passed CI.  I do not know whether it really helps with the <code>SplittingField</code> issue, but I imagine that it cannot make matters worse...</p>",
        "id": 361752059,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685279266
    },
    {
        "content": "<p>What is the procedure, make a simultaneous PR in mathlib3 and mathlib4 with the \"same\" changes?</p>",
        "id": 361752155,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685279299
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/actions/runs/5098647698/jobs/9165907811\">This is the branch</a></p>",
        "id": 361752260,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685279338
    },
    {
        "content": "<p>However, the supermarket closes in 20 mins and I do not have food for today!  I'll be back soon!</p>",
        "id": 361752340,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685279367
    },
    {
        "content": "<p>It doesn't solve the problem, but it helps: for example it makes <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AdjoinRoot.mul_div_root_cancel#doc\">docs4#AdjoinRoot.mul_div_root_cancel</a> much faster (and <code>/</code> instead of <code>Div.div</code>) works. As I sais above I <code>AdjoinRoot</code> has surely other problems, we should fix them before working on <code>SplittingField</code>.</p>",
        "id": 361752986,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685279553
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361752340\">said</a>:</p>\n<blockquote>\n<p>However, the supermarket closes in 20 mins and I do not have food for today!  I'll be back soon!</p>\n</blockquote>\n<p>Eating is still more important than fixing mathlib :D</p>",
        "id": 361753337,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685279676
    },
    {
        "content": "<p>Well, it turns out that the supermarket closed 30 mins before I thought it did: might as well fix mathlib!  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 361754124,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685279938
    },
    {
        "content": "<p>Is there a place where I can find out how to make the two PR, in congruent mathlib3 and mathlib4?</p>",
        "id": 361754473,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685280073
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/wiki/Mathlib3-Synchronisation\">Found it</a></p>",
        "id": 361754778,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685280191
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/19119\">#19119</a> this is the mathlib3 PR switching <code>..field</code> to <code>..group_with_zero</code>.</p>",
        "id": 361755349,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685280379
    },
    {
        "content": "<p>Eric, thanks for approving the PR!</p>",
        "id": 361776104,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685287677
    },
    {
        "content": "<p>Now, I <em>could</em> wait for the mathport output, but in this case, the code that we are going to use is the one above anyway: should I still wait for mathport, or can I go ahead and produce the mathlib4 PR?</p>",
        "id": 361776265,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685287734
    },
    {
        "content": "<p>You need anyway to wait for the mathlib3 PR to be merged (otherwise the SHA will not be the good one).</p>",
        "id": 361776938,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685287991
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> did you mean to <code>bors r+</code> or <code>bors d+</code>?  The PR passed CI and I have nothing else to add, so a <code>bors d+</code> is equivalent to a <code>bors r+</code>, as far as I am concerned!</p>",
        "id": 361786712,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685291699
    },
    {
        "content": "<p>Oops!</p>",
        "id": 361795712,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685295289
    },
    {
        "content": "<p>The change in syntax from bors3 to bors4 can be confusing... <span aria-label=\"stuck out tongue closed eyes\" class=\"emoji emoji-1f61d\" role=\"img\" title=\"stuck out tongue closed eyes\">:stuck_out_tongue_closed_eyes:</span></p>",
        "id": 361796945,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685295868
    },
    {
        "content": "<p>The change is now in mathlib3!  How do I find out when mathport picks it up?</p>",
        "id": 361801120,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685297801
    },
    {
        "content": "<p>You don't need to wait for mathport here</p>",
        "id": 361801676,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685298051
    },
    {
        "content": "<p>Ok, so I simply make a normal PR to mathlib4, mirroring the mathlib3 one, right?</p>",
        "id": 361803442,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685298848
    },
    {
        "content": "<p>I went ahead and made the PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/4456\">!4#4456</a>.  Should the commit hash of the corresponding mathlib3 version be updated?  Manually by me?  With some tool?</p>",
        "id": 361805157,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685299721
    },
    {
        "content": "<p>Yes, please manually update the commit hash</p>",
        "id": 361807066,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685300464
    },
    {
        "content": "<p>CI will tell you if the hash you pasted doesn't exist</p>",
        "id": 361807125,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685300490
    },
    {
        "content": "<p>Done.</p>\n<p>I also noticed that I had not removed a <code>LibrarySearch</code> import, so I removed this as well.  The whole PR consists of</p>\n<ul>\n<li>the change to the commit hash</li>\n<li>the removal of the <code>LibrarySearch</code> import</li>\n<li>using <code>groupWithZero</code> instead of <code>field</code>.</li>\n</ul>",
        "id": 361809019,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685301452
    },
    {
        "content": "<p>That second item should be in the PR description!</p>",
        "id": 361810361,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685302139
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span>, have you tried breaking the giant <code>: Field</code> declaration into smaller pieces? We have certainly had to do this elsewhere in the library, and we know there is a blow-up as proofs of earlier fields are copied into later fields when you define everything at once.</p>\n<p>I wouldn't be worrying about timeouts until after having made this change.</p>",
        "id": 361817417,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1685305953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361810361\">said</a>:</p>\n<blockquote>\n<p>That second item should be in the PR description!</p>\n</blockquote>\n<p>Done!</p>",
        "id": 361817621,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685306075
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361817417\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span>, have you tried breaking the giant <code>: Field</code> declaration into smaller pieces? We have certainly had to do this elsewhere in the library, and we know there is a blow-up as proofs of earlier fields are copied into later fields when you define everything at once.</p>\n<p>I wouldn't be worrying about timeouts until after having made this change.</p>\n</blockquote>\n<p>Not really, but quite a lot of timeouts happen in declarations without <code>Irreducible f</code>, so there is definitely something else going on. The next step in my opinion is to make  <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AdjoinRoot.mul_div_root_cancel#doc\">docs4#AdjoinRoot.mul_div_root_cancel</a> faster. I will not have time for a couple of days unfortunately (too much grading <span aria-label=\"unamused\" class=\"emoji emoji-1f612\" role=\"img\" title=\"unamused\">:unamused:</span> )</p>",
        "id": 361834792,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685318494
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253861\">Thomas Browning</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361391412\">said</a>:</p>\n<blockquote>\n<p>Yes, I think after the port it is definitely worth considering using Junyan's algebraic closure, and then defining splitting field in terms of that.<br>\nHere's Junyan's algebraic closure for reference: <a href=\"https://gist.github.com/alreadydone/daa9760056383d31669755bbb41e2695\">https://gist.github.com/alreadydone/daa9760056383d31669755bbb41e2695</a></p>\n</blockquote>\n<p>Is it sensible to do this before the port given the amount of effort splitting fields take? We can use Junyan's algebraic closure, or even prove <code>span_eval_ne_top</code> in the current <code>algebraic_closure</code> file withouut using splitting fields, which looks like it must be possible. For fun, I proved a <a href=\"https://gist.github.com/ChrisHughes24/e97dcf6be2b0e67449ab0fa1f5540d58\">category theoretic zorn's lemma</a> which could also be used to define algebraic closure. Maybe the splitting hell is providing motivation to improve things like <code>adjoin_root</code> so it's worth the effort.</p>",
        "id": 361889077,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1685350437
    },
    {
        "content": "<p>It's not clear to me whether Junyan's approach inherits scalar action structures in a useful way; it's not clear to me that actions on <code>K</code> transfer to the extension of <code>K</code> as they do with <code>splitting_field</code></p>",
        "id": 361902212,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685354040
    },
    {
        "content": "<p>Is there a type-class diamond that has to commute here?</p>",
        "id": 361903445,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1685354366
    },
    {
        "content": "<p>I guess the usual Z-algebra diamond is an example. It is very yucky that we have to think about this for algebraic closures and splitting fields.</p>",
        "id": 361904726,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1685354719
    },
    {
        "content": "<p>I think the Z and N instances are ok because Junyan's construction carries around the field structure</p>",
        "id": 361905626,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685354996
    },
    {
        "content": "<p>I doubt it. The field structure in the end in Junyan's construction just comes from the axiom of choice. Using zorn's lemma you show there is a maximal <code>alg_extension</code> and this is the algebraic closure, but it's not defined to be anything really.</p>",
        "id": 361907932,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1685355594
    },
    {
        "content": "<p>You can get the instances to commute on <code>alg_closure</code> by using the current definition <code>adjoin_monic</code> as the definition of <code>algebraic_closure</code>. This field is algebraically closed, but the definition is currently more complicated than that because it's a little bit tricky to prove <code>adjoin_monic</code> is alg closed so Kenny kept on adjoining more roots of polynomials. Then splitting field would work as a subset of this.</p>",
        "id": 361908947,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1685355810
    },
    {
        "content": "<p>the Q-diamond is the most important in practice regardless</p>",
        "id": 361910579,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1685356172
    },
    {
        "content": "<p>One thing that I find (mathematically) disturbing is that the ℚ-diamond is there for <em>every</em> field, not just fields of characteristic zero.</p>\n<p>I understand how it is implemented, but it always gives me an uncomfortable feeling.</p>",
        "id": 361913195,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685356789
    },
    {
        "content": "<p>It's not a diamond in other fields</p>",
        "id": 361913404,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685356837
    },
    {
        "content": "<p>I meant that there is a map of ℚ to every field, regardless of whether it creates diamonds or not.</p>",
        "id": 361913795,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685356936
    },
    {
        "content": "<p>it's interesting that our choices about junk values allow us to do it in a semi-consistent way that allows <a href=\"https://leanprover-community.github.io/mathlib_docs/find/distrib_smul\">docs#distrib_smul</a></p>",
        "id": 361914327,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1685357077
    },
    {
        "content": "<p>Yes, I think that this is one of those situations in which I trust that the conventions work out, mostly because it is formally verified.</p>",
        "id": 361914847,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685357207
    },
    {
        "content": "<p>In informal maths, I would never put myself in a situation where I have to rely on these \"coincidences\".</p>",
        "id": 361914953,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685357234
    },
    {
        "content": "<p>In fact, anything that depends on writing a rational number as a ratio of relatively prime integers, makes me already nervous.</p>",
        "id": 361915214,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685357294
    },
    {
        "content": "<p>The entire porting meeting today was devoted to a discussion of this issue. Perhaps <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> or <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> could summarise it?</p>",
        "id": 362034766,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685395347
    },
    {
        "content": "<p>The summary was that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">field</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">AdjoinRoot.instCommRing</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"n\">Ideal.Quotient.field</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"k\">with</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> etc -/</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>generates a term that ignores <code>AdjoinRoot.instCommRing f</code> entirely,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">field</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">AdjoinRoot.instCommRing</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"n\">Quotient.group_with_zero</span><span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"k\">with</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> etc -/</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>generates a bad version that eta-expands <code>AdjoinRoot.instCommRing</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">field</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">Ideal.Quotient.field</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"k\">with</span>\n    <span class=\"n\">toCommRing</span> <span class=\"o\">:=</span> <span class=\"n\">AdjoinRoot.instCommRing</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> etc -/</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>generates a much smaller one that actually just uses the existing commRing structure</p>",
        "id": 362035959,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685396029
    },
    {
        "content": "<p>I consider eta-expanding bad here because the original claim for why we wanted new style structures in the first place is that you can efficiently build structures from their parents; but it seems the <code>with</code> clause is choosing an inefficient arrangement that is probably no better than the one flat structures gave us; but with extra indirection</p>",
        "id": 362036247,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685396210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/362034766\">said</a>:</p>\n<blockquote>\n<p>The entire porting meeting today was devoted to a discussion of this issue. Perhaps <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> or <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> could summarise it?</p>\n</blockquote>\n<p>I am sorry to have missed that! Is next meeting on next Monday ?</p>",
        "id": 362038113,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1685397411
    },
    {
        "content": "<p>Note that with the last version both the <code>Div.div</code> problem and the earlier <code>splex</code> example much quicker.</p>",
        "id": 362038191,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685397475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234339.20.20FieldTheory.2ESplittingField/near/361545107\">said</a>:</p>\n<blockquote>\n<p>There is something that looks a little funny when you <code>#print</code> the two instances, the one going via <code>field</code> (<code>AdjoinRoot.field</code>) and the one going via <code>GroupWithZero</code> (<code>AdjoinRoot.pield</code>):</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">AdjoinRoot.field.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n  <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]}</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"bp\">→</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"bp\">↦</span>\n  <span class=\"k\">let</span> <span class=\"n\">src</span> <span class=\"o\">:=</span> <span class=\"n\">instCommRing</span> <span class=\"n\">f</span><span class=\"bp\">;</span>              <span class=\"c1\">-- &lt;--- both called `src`</span>\n  <span class=\"k\">let</span> <span class=\"n\">src</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient.field</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">})</span><span class=\"bp\">;</span>   <span class=\"c1\">-- &lt;--- both called `src`</span>\n  <span class=\"n\">Field.mk</span> <span class=\"n\">Field.zpow</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">⧸</span> <span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}),</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">x_1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">AdjoinRoot.pield.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n  <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]}</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"bp\">→</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"bp\">↦</span>\n  <span class=\"k\">let</span> <span class=\"n\">src</span> <span class=\"o\">:=</span> <span class=\"n\">instCommRing</span> <span class=\"n\">f</span><span class=\"bp\">;</span>                       <span class=\"c1\">-- &lt;--- one called src</span>\n  <span class=\"k\">let</span> <span class=\"n\">src_1</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient.groupWithZero</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">})</span><span class=\"bp\">;</span>  <span class=\"c1\">-- &lt;--- the other called src_1</span>\n  <span class=\"n\">Field.mk</span> <span class=\"n\">GroupWithZero.zpow</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">⧸</span> <span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}),</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">x_1</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This was diagnosed as: \"rather surprisingly, if you write it this way in the first example then<code>instCommRing f</code> isn't used in the actual definition at all, and so Lean is happy to just ignore its name and call the second one <code>src</code> too\"</p>",
        "id": 362039075,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1685398054
    },
    {
        "content": "<p>Oh, I wish I had taken part to the meeting!</p>\n<p>I am going to bed now, but this looks all very interesting!</p>",
        "id": 362039434,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685398282
    },
    {
        "content": "<p>I will also take me some time to get up to speed with new/flat style.</p>",
        "id": 362039592,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685398400
    },
    {
        "content": "<p>Anyway, thank you very much for looking into this and for the report!  I may have more questions tomorrow.</p>",
        "id": 362039610,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685398420
    },
    {
        "content": "<p>So, is it fair to summarize that, when building instances on top of others, you should only have at most one and then all the remaining ones go inside the <code>with</code>?</p>",
        "id": 362042277,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685399814
    },
    {
        "content": "<p>I'm sure that there will be exceptions, but is this a good rule of thumb?</p>",
        "id": 362042305,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685399836
    },
    {
        "content": "<p>I think more accurate summary would be \"if you can use a <code>toFoo</code> instead of the <code>with</code>, do\"</p>",
        "id": 362044983,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685401445
    },
    {
        "content": "<p>It's very rare to be in a situation where there is more that one non-trivial <code>to</code> field; only the bottom of the hierarchy has this luxury. But in those cases, it's probably best to provide each of them</p>",
        "id": 362045091,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685401510
    },
    {
        "content": "<p>Also, is the order in which you provide the fields/instance of any relevance, for considerations of time outs?</p>",
        "id": 362070614,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685421991
    },
    {
        "content": "<p>I tried simple-mindedly using </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">field</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Irreducible</span> <span class=\"n\">f</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">Ideal.Quotient.field</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"k\">with</span>\n    <span class=\"n\">toCommRing</span> <span class=\"o\">:=</span> <span class=\"n\">AdjoinRoot.instCommRing</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> etc -/</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>in <code>AdjoinRoot</code>, but <code>SplittingField</code> still times out.  I need to investigate this further.</p>",
        "id": 362212669,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1685459004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> has marked this topic as resolved.</p>",
        "id": 365051324,
        "sender_full_name": "Notification Bot",
        "timestamp": 1686385716
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> has marked this topic as unresolved.</p>",
        "id": 365051376,
        "sender_full_name": "Notification Bot",
        "timestamp": 1686385728
    },
    {
        "content": "<p>Sorry for the noise, I just wanted to change the title (there is a new PR)</p>",
        "id": 365051487,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686385763
    },
    {
        "content": "<p>tagging <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> since there is a new proposed approach to <code>SplittingField</code></p>",
        "id": 365057645,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686387592
    },
    {
        "content": "<p>Should we be making these refactors in mathlib3 first?</p>",
        "id": 365098965,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686397906
    },
    {
        "content": "<p>I agree, we don't want to discover that this creates problems somewhere else...</p>",
        "id": 365100391,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686398210
    },
    {
        "content": "<p>From the description alone, I think the design is a good one</p>",
        "id": 365101987,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686398588
    },
    {
        "content": "<p>I've mostly done this PR. The only things left are proving that something isomorphic to a field is a field and proving surjectivity of some map</p>",
        "id": 365106007,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1686399566
    },
    {
        "content": "<p>I did most of the field construction, but seem to be missing something at <code>qsmul_eq_mul'</code>.</p>",
        "id": 365430961,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686541947
    },
    {
        "content": "<p>I have time to take care of it now, but I still wonder if we want this in mathlib3 before having it in mathlib4</p>",
        "id": 365473419,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686557137
    },
    {
        "content": "<p>I'll have a look and try to backport :). Will justify me being late on the blogpost!</p>",
        "id": 365474632,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1686557439
    },
    {
        "content": "<p>All the tests to check the diamond is solved are in that file, right?</p>",
        "id": 365475374,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686557610
    },
    {
        "content": "<p>Yes!</p>",
        "id": 365475412,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1686557618
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/365473419\">said</a>:</p>\n<blockquote>\n<p>I have time to take care of it now, but I still wonder if we want this in mathlib3 before having it in mathlib4</p>\n</blockquote>\n<p>I kind of doubt it's worth the effort and we should just risk it. I can't see how it would make anything worse.</p>",
        "id": 365481731,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1686559093
    },
    {
        "content": "<p>Refactoring mathlib4 before the port is done creates work for porting downstream projects, because then there is no mathlib4 version corresponding to the mathlib 3 version</p>",
        "id": 365487605,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686560425
    },
    {
        "content": "<p>Backporting can be done in parallel (without blocking the mathlib4 PR), though</p>",
        "id": 365487821,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1686560463
    },
    {
        "content": "<p>Sure; though we have tools to help with forward-porting, but not with backporting</p>",
        "id": 365488214,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686560535
    },
    {
        "content": "<p>That is fair, and the tools are great! This file is a bit of a special case, though, since it is at the very top of <code>all.pdf</code>  and the port is close enough to being complete.</p>",
        "id": 365490708,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1686561065
    },
    {
        "content": "<p>I don't think there is that much of a risk, if I'm honest. As long as the API is identical, I don't think anyone outside of <code>splitting_field.lean</code> would be insane enough to try use any weird defeqs to do with it (and the ones we do we are careful to assert as <code>example</code>s in the file, and are just the algebra stuffs). On the other hand, I do agree that it's probably good practice to backport, because I would be very sad if <code>flt_regular</code> ends up being very hard to port because of this - we are lucky that unlike <code>lean-liquid</code>, we have managed to keep it pegged to <code>mathlib3</code> pretty closely.</p>",
        "id": 365493460,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1686561654
    },
    {
        "content": "<p>I agree the risk is very low, but this would creates a precedent, so we should probably think carefully about it. In any case the backport seems doable in a couple of hours, doesn't it?</p>",
        "id": 365504372,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686564074
    },
    {
        "content": "<p>I mean, if it creates problems in other files (in mathlib3) then it is going to creates problems with the port</p>",
        "id": 365504502,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686564103
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/19178\">#19178</a> for the backport (currently only waiting for cache)</p>",
        "id": 365516067,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686566424
    },
    {
        "content": "<p>Wait to celebrate, I essentially only opened the PR :)</p>",
        "id": 365530549,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686569737
    },
    {
        "content": "<p>So this doesn't touch AdjoinRoot?</p>\n<p>I spent a lot of time last week just staring at traces in AdjoinRoot stuff, and completely failing to figure out how to make things faster.</p>",
        "id": 365534152,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1686570585
    },
    {
        "content": "<p>It doesn't touch <code>AdjoinRoot</code></p>",
        "id": 365534289,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1686570607
    },
    {
        "content": "<p>That problem still needs to be fixed</p>",
        "id": 365534393,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1686570633
    },
    {
        "content": "<p>I have to teach now, if someone wants to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">splitting_field_aux_aux</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">],</span> <span class=\"kd\">by</span> <span class=\"n\">exactI</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]),</span>\n  <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.rec_on</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">K</span> <span class=\"n\">inst</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">inst</span><span class=\"o\">,</span> <span class=\"n\">infer_instance</span><span class=\"o\">⟩)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">ih</span> <span class=\"n\">K</span> <span class=\"n\">inst</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">ih</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">remove_factor</span> <span class=\"n\">K</span> <span class=\"n\">inst</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">fL</span><span class=\"o\">,</span> <span class=\"n\">alg</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exactI</span> <span class=\"o\">⟨</span><span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">fL</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.comp</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root.of</span> <span class=\"n\">f.factor</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">to_algebra</span><span class=\"o\">⟩,</span>\n<span class=\"kd\">end</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>in tactic mode please go ahead. Or at least convince Lean that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">:</span>\n  <span class=\"n\">splitting_field_aux</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">splitting_field_aux</span> <span class=\"n\">n</span> <span class=\"n\">f.remove_factor</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>should work.</p>",
        "id": 365535932,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686570977
    },
    {
        "content": "<p>Is this just a case of Lean3 not having eta. So we have to get rid of the <code>rcases</code> and write <code>let L := ih (@remove_factor K inst f); letI := L.2.1; letI := L.2.2; exact ⟨L.1, L.2.1, (ring_hom.comp (algebra_map _ _) (adjoin_root.of f.factor)).to_algebra⟩</code></p>",
        "id": 365536530,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1686571114
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/19179\">#19179</a> backports the root_set change (WIP)</p>",
        "id": 365547059,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686573347
    },
    {
        "content": "<p>Do you mind finishing off the downstream breakages once CI is done, <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>?</p>",
        "id": 365549064,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686573772
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/19178\">#19178</a> is more or less done (there is still one sorry, the same as in mathlib4). I've incorporated the modifications done in <a href=\"https://github.com/leanprover-community/mathlib/pull/19179\">#19179</a>.</p>",
        "id": 365623347,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686588665
    },
    {
        "content": "<p>Let's see what CI thinks</p>",
        "id": 365623368,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686588671
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/365549064\">said</a>:</p>\n<blockquote>\n<p>Do you mind finishing off the downstream breakages once CI is done, <span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span>?</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/19179\">#19179</a> is green. Is there anything else that should be done in this PR?</p>",
        "id": 365644618,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686594009
    },
    {
        "content": "<p>I propose to merge it quickly since it's helping the port.</p>",
        "id": 365644690,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686594032
    },
    {
        "content": "<p>I think it's ready to go, assuming there's consensus that it's a good change</p>",
        "id": 365657821,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686597509
    },
    {
        "content": "<p>Something is happening in <a href=\"https://github.com/leanprover-community/mathlib/pull/19178\">#19178</a>: there is deterministic timeout in <code>field_theory.finite.galois_field</code>. So maybe changing the definition of <code>splitting_field</code> <em>has</em> some consequence...</p>",
        "id": 365663692,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686598104
    },
    {
        "content": "<p>The timeout is in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">equiv_zmod_p</span> <span class=\"o\">:</span> <span class=\"n\">galois_field</span> <span class=\"n\">p</span> <span class=\"mi\">1</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"bp\">=</span> <span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">fintype.card</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)),</span>\n  <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_one</span><span class=\"o\">,</span> <span class=\"n\">zmod.card</span> <span class=\"n\">p</span><span class=\"o\">],</span>\n<span class=\"k\">have</span> <span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">is_splitting_field</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">X</span><span class=\"o\">),</span>\n  <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">apply_instance</span> <span class=\"o\">},</span>\n<span class=\"kd\">by</span> <span class=\"n\">exactI</span> <span class=\"o\">(</span><span class=\"n\">is_splitting_field.alg_equiv</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)[</span><span class=\"n\">X</span><span class=\"o\">]))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>\n<p>and it is there even if the proof is <code>sorry</code>. Any ideas?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">aaa</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">galois_field</span> <span class=\"n\">p</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>works without problems.</p>",
        "id": 365673382,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686601027
    },
    {
        "content": "<p>The red squiggle in under <code>≃ₐ</code> but I don't know if this means anything.</p>",
        "id": 365673469,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686601051
    },
    {
        "content": "<p>Even</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">equiv_zmod_p</span> <span class=\"o\">:</span> <span class=\"n\">galois_field</span> <span class=\"n\">p</span> <span class=\"mi\">1</span> <span class=\"bp\">→+</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>gives a timeout.</p>",
        "id": 365673769,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686601155
    },
    {
        "content": "<p>Ah it seems to be something related to computability.</p>",
        "id": 365676128,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686601906
    },
    {
        "content": "<p>Is it possible we've somehow made things worse because lean now has to unify the quotient relation in some way?</p>",
        "id": 365676360,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686601987
    },
    {
        "content": "<p>Hmm, so adding <code>noncomputable!</code> allows to do the proof. I am seeing what happens in tactic mode:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span><span class=\"bp\">!</span> <span class=\"kd\">def</span> <span class=\"n\">equiv_zmod_p</span> <span class=\"o\">:</span> <span class=\"n\">galois_field</span> <span class=\"n\">p</span> <span class=\"mi\">1</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"bp\">=</span> <span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">fintype.card</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)),</span>\n    <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_one</span><span class=\"o\">,</span> <span class=\"n\">zmod.card</span> <span class=\"n\">p</span><span class=\"o\">],</span>\n  <span class=\"n\">haveI</span> <span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">is_splitting_field</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">X</span><span class=\"o\">),</span>\n    <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">apply_instance</span> <span class=\"o\">},</span>\n  <span class=\"n\">delta</span> <span class=\"n\">galois_field</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"n\">is_splitting_field.alg_equiv</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)[</span><span class=\"n\">X</span><span class=\"o\">]),</span>\n<span class=\"c1\">--No problems until the previous line, `φ` has type `zmod p ≃ₐ[zmod p] (X ^ p ^ 1 - X).splitting_field` as expected.</span>\n<span class=\"c1\">-- Its inverse should give what we want</span>\n<span class=\"k\">let</span> <span class=\"bp\">Ψ</span> <span class=\"o\">:=</span> <span class=\"n\">φ.symm</span><span class=\"o\">,</span> <span class=\"c1\">--this line gives an error</span>\n<span class=\"c1\">-- synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized</span>\n<span class=\"c1\">--  splitting_field.algebra' (X ^ p ^ 1 - X)</span>\n<span class=\"c1\">-- inferred</span>\n<span class=\"c1\">--  splitting_field.algebra' (X ^ p ^ 1 - X)</span>\n  <span class=\"c1\">--exactI (is_splitting_field.alg_equiv (zmod p) (X ^ (p ^ 1) - X : (zmod p)[X])).symm,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 365679032,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686602886
    },
    {
        "content": "<p>That looks pretty damning</p>",
        "id": 365683927,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686604671
    },
    {
        "content": "<p>(also, <a href=\"https://github.com/leanprover-community/mathlib/pull/19179\">#19179</a> is now in master)</p>",
        "id": 365684160,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686604744
    },
    {
        "content": "<p>I remember that <code>zmod p</code> algebra diamonds were basically an unsolved problem last time I checked a couple of years ago. Has this now changed?</p>",
        "id": 365684406,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1686604823
    },
    {
        "content": "<p>It seems that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">splitting_field.algebra'</span>\n</code></pre></div>\n<p>helps a lot. Now we to wait again since I merged master, but I am optimistic.</p>",
        "id": 365684542,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686604886
    },
    {
        "content": "<p>The instances are</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">algebra</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">splitting_field</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">ideal.quotient.algebra</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">algebra'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">splitting_field</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">ideal.quotient.algebra</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>and I don't see anything wrong with them.</p>",
        "id": 365684724,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686604931
    },
    {
        "content": "<p>Oh, I completely forgot the porting meeting! Have you spoken about this issue?</p>",
        "id": 365685102,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686605117
    },
    {
        "content": "<p>We decided that thinking about splitting fields could wait!</p>",
        "id": 365687363,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1686606115
    },
    {
        "content": "<p>What is the standard solution to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">synthesized</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">expression</span> <span class=\"n\">inferred</span> <span class=\"kd\">by</span> <span class=\"n\">typing</span> <span class=\"n\">rules</span><span class=\"o\">,</span> <span class=\"n\">synthesized</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">p.splitting_field</span><span class=\"o\">),</span> <span class=\"n\">quotient.decidable_eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n<span class=\"n\">inferred</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">p.splitting_field</span><span class=\"o\">),</span> <span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>?<br>\nIt appears now in <code>field_theory.polynomial_galois_group</code>. I guess that removing <code>open locale classical</code> and using [decidable blah] everywhere will work, but there is maybe a quicker solution.</p>",
        "id": 365687759,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686606304
    },
    {
        "content": "<p>OK, I can use <code>@</code> and <code>classical.dec_eq</code></p>",
        "id": 365688134,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686606491
    },
    {
        "content": "<p>I think that removing open_locale classical is often a good idea especially if you're seeing errors like that!</p>",
        "id": 365693135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1686608804
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/365684542\">said</a>:</p>\n<blockquote>\n<p>It seems that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">splitting_field.algebra'</span>\n</code></pre></div>\n<p>helps a lot. Now we to wait again since I merged master, but I am optimistic.</p>\n</blockquote>\n<p>I really don't want to re-fix this for the sake of \"port port port\"</p>",
        "id": 365700672,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1686611875
    },
    {
        "content": "<p>we really want to have this instance!</p>",
        "id": 365700733,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1686611889
    },
    {
        "content": "<p>Yes, I agree. At the moment it is needed in only one file. I am finishing to fix all the rest, then we can decide. In any case there is still a (<code>Prop</code>-valued) <code>sorry</code> to finish in the construction of the splitting field.</p>",
        "id": 365701463,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686612217
    },
    {
        "content": "<p>There is now a new strange problem: another timeout it</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[nolint has_nonempty_instance]</span> <span class=\"c1\">-- can't prove that they always exist</span>\n<span class=\"kd\">structure</span> <span class=\"n\">primitive_add_char</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R'</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">char</span> <span class=\"o\">:</span> <span class=\"n\">add_char</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic_field</span> <span class=\"n\">n</span> <span class=\"n\">R'</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">prim</span> <span class=\"o\">:</span> <span class=\"n\">is_primitive</span> <span class=\"n\">char</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(in <code>src/number_theory/legendre_symbol/add_character.lean</code>). The problem seems to be related to the <code>n</code>: if I replace it with <code>3</code> it works, and also if I do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[nolint has_nonempty_instance]</span> <span class=\"c1\">-- can't prove that they always exist</span>\n<span class=\"kd\">structure</span> <span class=\"n\">primitive_add_char</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R'</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">char</span> <span class=\"o\">:</span> <span class=\"n\">add_char</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic_field</span> <span class=\"n\">n</span> <span class=\"n\">R'</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">prim</span> <span class=\"o\">:</span> <span class=\"n\">is_primitive</span> <span class=\"n\">char</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 365703193,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686613231
    },
    {
        "content": "<p>Time to go to sleep for me, but if someone wants to think about it here is a minimized version.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.splitting_field.construction</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">polynomial.splitting_field</span> <span class=\"n\">K</span> <span class=\"n\">inst</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">K</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>fails with deterministic timeout. I've added a test file to the PR to play with.</p>",
        "id": 365706320,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686615192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/365693135\">said</a>:</p>\n<blockquote>\n<p>I think that removing open_locale classical is often a good idea especially if you're seeing errors like that!</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/19182\">#19182</a></p>",
        "id": 365707565,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686615913
    },
    {
        "content": "<p>Annoying this probably came up during the port, so now the mathlib4 file probably contains a half-hearted attempt at the same cleanup</p>",
        "id": 365707674,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686615968
    },
    {
        "content": "<p>I merged that, despite any <a href=\"https://leanprover-community.github.io/mathlib-port-status/out-of-sync\">#outofsync</a> limits, as getting this straightened out is on the critical path!</p>",
        "id": 365708635,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686616515
    },
    {
        "content": "<p>One last remark before really going to sleep: the timeout is already there without <code>splitting_field</code>!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.mv_polynomial.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.ring_division</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"c1\">-- deterministic timeout</span>\n<span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">mv_polynomial</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">root_set</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Am I too sleepy to miss something trivial?</p>",
        "id": 365709085,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686616763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/365708635\">said</a>:</p>\n<blockquote>\n<p>I merged that, despite any <a href=\"https://leanprover-community.github.io/mathlib-port-status/out-of-sync\">#outofsync</a> limits, as getting this straightened out is on the critical path!</p>\n</blockquote>\n<p>CI isn't quite happy with it yet. I'm happy for someone else to take over the issues in downstream files if you want it done in the next 18 hours</p>",
        "id": 365711932,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686618194
    },
    {
        "content": "<p>21 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/mysterious.20finsupp.20related.20timeout\">#mathlib4 &gt; mysterious finsupp related timeout</a> by <span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span>.</p>",
        "id": 365773274,
        "sender_full_name": "Notification Bot",
        "timestamp": 1686642675
    },
    {
        "content": "<p>I moved a whole bunch of messages, because after minimizing the problem wasn't specific to splitting fields anymore.</p>",
        "id": 365773409,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1686642711
    },
    {
        "content": "<p>Returning to the topic of this thread, the PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/4891\">!4#4891</a> now passes CI. But I understand that the backport is still blocked on the timeout problem.</p>",
        "id": 365773674,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1686642767
    },
    {
        "content": "<p>We also need to forward-port the bit of the backport that _did_ go through</p>",
        "id": 365776999,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686643536
    },
    {
        "content": "<p>which bit exactly?</p>",
        "id": 365777167,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1686643567
    },
    {
        "content": "<p>I imagine we can just cherry-pick from <a href=\"https://github.com/leanprover-community/mathlib4/pull/4891\">!4#4891</a>, and then double check the output against <a href=\"https://leanprover-community.github.io/mathlib-port-status\">#port-dashboard</a></p>",
        "id": 365777238,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686643584
    },
    {
        "content": "<p>The rootSet change</p>",
        "id": 365777252,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686643589
    },
    {
        "content": "<p>Which was orthogonal to the redesign anyway</p>",
        "id": 365777282,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686643600
    },
    {
        "content": "<p>Ooh, I forward-ported that already</p>",
        "id": 365777355,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1686643618
    },
    {
        "content": "<p>But as part of <a href=\"https://github.com/leanprover-community/mathlib4/pull/4891\">!4#4891</a></p>",
        "id": 365777443,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1686643634
    },
    {
        "content": "<p>We should split it out so that it actually gets reviewed as a forward-port</p>",
        "id": 365777541,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686643654
    },
    {
        "content": "<p>I imagine the rest of splitting_field is going to need a few more days to settle anyway, so we may as well shrink the diff in the meantime</p>",
        "id": 365777686,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686643682
    },
    {
        "content": "<p>As a workaround I propose to modify (in mathlib3)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">primitive_add_char</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R'</span><span class=\"o\">]</span>  <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">char</span> <span class=\"o\">:</span> <span class=\"n\">add_char</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic_field</span> <span class=\"n\">n</span> <span class=\"n\">R'</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">prim</span> <span class=\"o\">:</span> <span class=\"n\">is_primitive</span> <span class=\"n\">char</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>into</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">primitive_add_char</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R'</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">Σ'</span> <span class=\"o\">(</span><span class=\"n\">char</span> <span class=\"o\">:</span> <span class=\"n\">add_char</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic_field</span> <span class=\"n\">n</span> <span class=\"n\">R'</span><span class=\"o\">)),</span> <span class=\"n\">is_primitive</span> <span class=\"n\">char</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span><span class=\"bp\">!</span> <span class=\"kd\">def</span> <span class=\"n\">primitive_add_char.n</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R'</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">primitive_add_char</span> <span class=\"n\">R</span> <span class=\"n\">R'</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">χ</span><span class=\"o\">,</span> <span class=\"n\">χ.1</span>\n\n<span class=\"kd\">noncomputable</span><span class=\"bp\">!</span> <span class=\"kd\">def</span> <span class=\"n\">primitive_add_char.char</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R'</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">χ</span> <span class=\"o\">:</span> <span class=\"n\">primitive_add_char</span> <span class=\"n\">R</span> <span class=\"n\">R'</span><span class=\"o\">),</span> <span class=\"n\">add_char</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic_field</span> <span class=\"n\">χ.n</span> <span class=\"n\">R'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">χ</span><span class=\"o\">,</span> <span class=\"n\">χ.2.1</span>\n\n<span class=\"kd\">noncomputable</span><span class=\"bp\">!</span> <span class=\"kd\">def</span> <span class=\"n\">primitive_add_char.prim</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R'</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">χ</span> <span class=\"o\">:</span> <span class=\"n\">primitive_add_char</span> <span class=\"n\">R</span> <span class=\"n\">R'</span><span class=\"o\">),</span> <span class=\"n\">is_primitive</span> <span class=\"n\">χ.char</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">χ</span><span class=\"o\">,</span> <span class=\"n\">χ.2.2</span>\n</code></pre></div>\n<p>To construct a primitive character one cannot use <code>{n = ...}</code> anymore, but <code>⟨_, _, _⟩</code> works fine, and <code>χ.n</code>, <code>χ.char</code> and <code>χ.prim</code> should be the same as before.</p>",
        "id": 365994074,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686691022
    },
    {
        "content": "<p>Instead of falling all the way back to <code>sigma</code>, can we define some simpler structure that at least has nice names?</p>",
        "id": 365999888,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686692979
    },
    {
        "content": "<p>I don't know how to do it, but I am open to any suggestion :)<br>\nAlso, I don't understand why but I have to mark the three definition as <code>noncomputable!</code>, otherwise there is again a timeout.</p>",
        "id": 366000917,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686693378
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/19178\">#19178</a> should now compile.</p>",
        "id": 366012412,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686698013
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/365684406\">said</a>:</p>\n<blockquote>\n<p>I remember that <code>zmod p</code> algebra diamonds were basically an unsolved problem last time I checked a couple of years ago. Has this now changed?</p>\n</blockquote>\n<p>It seems the wisdom is nowadays that the instance going from <code>CharP</code> to <code>Algebra ZMod</code> should be avoided because it creates data \"out of nothing\", and instead you should take an instance of <code>[Algebra (ZMod p) R]</code> if you want to get this map. Did we consider adding (in mathlib4?) an instance going the other way?</p>",
        "id": 366161184,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1686744777
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/366161184\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/365684406\">said</a>:</p>\n<blockquote>\n<p>I remember that <code>zmod p</code> algebra diamonds were basically an unsolved problem last time I checked a couple of years ago. Has this now changed?</p>\n</blockquote>\n<p>It seems the wisdom is nowadays that the instance going from <code>CharP</code> to <code>Algebra ZMod</code> should be avoided because it creates data \"out of nothing\", and instead you should take an instance of <code>[Algebra (ZMod p) R]</code> if you want to get this map. Did we consider adding (in mathlib4?) an instance going the other way?</p>\n</blockquote>\n<p>The other way to do this is somewhat similar to the <code>Rat</code> smul instance. We can define smul <code>zmod n</code> for every <code>ring</code>, <code>R</code> as <code>a bub x = a.val bub x</code> and then it only has nice properties when <code>char R</code> divides <code>n</code>.</p>",
        "id": 366184366,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1686749421
    },
    {
        "content": "<p>That definition doesn't work for <code>n = 0</code></p>",
        "id": 366185318,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686749595
    },
    {
        "content": "<p><code>a.toInt</code> or something then.</p>",
        "id": 366185681,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1686749663
    },
    {
        "content": "<p>I do wonder if all these things making the definition of a <code>Field</code> really complicated is a good idea or might cause big performance problems.</p>",
        "id": 366188119,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1686750086
    },
    {
        "content": "<p>Yeah, I'm not a big fan of including these structure maps. Already for <code>Rat</code> it's extremely dubious.<br>\nBut I understand it solves some problems that we were having.</p>",
        "id": 366193175,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1686751093
    },
    {
        "content": "<p>yeah, it's now got to the point where mathematically it already looks like we're cranks, so I no longer have any intuition about these questions. I look forward to the day where we have inbuilt maps both from <code>zmod n</code> and <code>fin n</code> to every ring :-/</p>",
        "id": 366203580,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1686752981
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/365994074\">said</a>:</p>\n<blockquote>\n<p>As a workaround I propose to modify (in mathlib3)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">primitive_add_char</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R'</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">char</span> <span class=\"o\">:</span> <span class=\"n\">add_char</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic_field</span> <span class=\"n\">n</span> <span class=\"n\">R'</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">prim</span> <span class=\"o\">:</span> <span class=\"n\">is_primitive</span> <span class=\"n\">char</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>into</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">primitive_add_char</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R'</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">Σ'</span> <span class=\"o\">(</span><span class=\"n\">char</span> <span class=\"o\">:</span> <span class=\"n\">add_char</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic_field</span> <span class=\"n\">n</span> <span class=\"n\">R'</span><span class=\"o\">)),</span> <span class=\"n\">is_primitive</span> <span class=\"n\">char</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span><span class=\"bp\">!</span> <span class=\"kd\">def</span> <span class=\"n\">primitive_add_char.n</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R'</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">primitive_add_char</span> <span class=\"n\">R</span> <span class=\"n\">R'</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">χ</span><span class=\"o\">,</span> <span class=\"n\">χ.1</span>\n\n<span class=\"kd\">noncomputable</span><span class=\"bp\">!</span> <span class=\"kd\">def</span> <span class=\"n\">primitive_add_char.char</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R'</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">χ</span> <span class=\"o\">:</span> <span class=\"n\">primitive_add_char</span> <span class=\"n\">R</span> <span class=\"n\">R'</span><span class=\"o\">),</span> <span class=\"n\">add_char</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic_field</span> <span class=\"n\">χ.n</span> <span class=\"n\">R'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">χ</span><span class=\"o\">,</span> <span class=\"n\">χ.2.1</span>\n\n<span class=\"kd\">noncomputable</span><span class=\"bp\">!</span> <span class=\"kd\">def</span> <span class=\"n\">primitive_add_char.prim</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">R'</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">χ</span> <span class=\"o\">:</span> <span class=\"n\">primitive_add_char</span> <span class=\"n\">R</span> <span class=\"n\">R'</span><span class=\"o\">),</span> <span class=\"n\">is_primitive</span> <span class=\"n\">χ.char</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">χ</span><span class=\"o\">,</span> <span class=\"n\">χ.2.2</span>\n</code></pre></div>\n<p>To construct a primitive character one cannot use <code>{n = ...}</code> anymore, but <code>⟨_, _, _⟩</code> works fine, and <code>χ.n</code>, <code>χ.char</code> and <code>χ.prim</code> should be the same as before.</p>\n</blockquote>\n<p>It would be sad if we could not write definitions like this in the natural way.</p>\n<p>Am I correct in thinking that the problem is not really the definition of <code>primitive_add_char</code>, but something more fundamental? (I have to admit that I did not follow the discussion in great detail...)</p>",
        "id": 366211528,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1686754385
    },
    {
        "content": "<p>Yes, it's not at all related to your definition.</p>",
        "id": 366211774,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686754435
    },
    {
        "content": "<p>It's to do with a lean issue, currently in lean3 and 4, about generating some lemmata</p>",
        "id": 366218779,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1686755754
    },
    {
        "content": "<p>Eric (other) is fixing this bug in lean3, I assume lean4 will get a fix soon</p>",
        "id": 366218920,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1686755773
    },
    {
        "content": "<p><a href=\"#narrow/stream/287929-mathlib4/topic/mysterious.20finsupp.20related.20timeout/near/366159344\">Already fixed in lean3</a>, just needs a review (and for mathlib to survive the change)</p>",
        "id": 366219878,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686755938
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, were you planning on compiling mathlib against this change to lean3 before or after we merge it?</p>",
        "id": 366347101,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686796843
    },
    {
        "content": "<p>Can we merge <a href=\"https://github.com/leanprover-community/mathlib/pull/19178\">#19178</a> yet? It's unclear to me if there is a still a blocker there.</p>",
        "id": 366347176,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686796889
    },
    {
        "content": "<p>I would also like to merge it.<br>\nBut there are 3 occasions where the instance <code>splitting_field.algebra'</code> is locally disabled...</p>",
        "id": 366374229,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1686810324
    },
    {
        "content": "<p>I think this shouldn't be a blocker though.</p>",
        "id": 366375244,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1686810641
    },
    {
        "content": "<p>Yes, I agree. This is still the longest path to completing the port, so I'd prefer that we enable people to start working on further steps concurrently with sorting out the fine details of the backport.</p>",
        "id": 366376635,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686810854
    },
    {
        "content": "<p>I would argue against merging it yet. I'd prefer to wait till <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> is happy, c.f.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/365700672\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/365684542\">said</a>:</p>\n<blockquote>\n<p>It seems that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">splitting_field.algebra'</span>\n</code></pre></div>\n<p>helps a lot. Now we to wait again since I merged master, but I am optimistic.</p>\n</blockquote>\n<p>I really don't want to re-fix this for the sake of \"port port port\"</p>\n</blockquote>",
        "id": 366398016,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686816320
    },
    {
        "content": "<p>This may still be the longest path to finishing the port, but IMO the graph of unported files is plenty wide enough that we shouldn't just rush through workarounds to satisfy some arbitrary metric</p>",
        "id": 366399524,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686816628
    },
    {
        "content": "<p>I would also like to have seen <a href=\"https://github.com/leanprover-community/lean/pull/812\">lean#812</a> merged before this PR</p>",
        "id": 366399679,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686816667
    },
    {
        "content": "<p>I see that at the end you merged it :D. Concerning</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">splitting_field.algebra'</span>\n</code></pre></div>\n<p>I have time now to try to understand why it is needed.</p>",
        "id": 366400958,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686816968
    },
    {
        "content": "<p>I share <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span>'s concern that that attribute is a very bad sign</p>",
        "id": 366401304,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686817063
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/366347101\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>, were you planning on compiling mathlib against this change to lean3 before or after we merge it?</p>\n</blockquote>\n<p>After, unless someone can remind me how to do it before.</p>",
        "id": 366401506,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686817104
    },
    {
        "content": "<p>First good news: there are only two <code>local attribute [-instance] splitting_field.algebra'</code>, and one of them (in <code>number_theory.cyclotomic.basic</code>) is useless (I probably forgot it when fixing something, sorry). I am working on the other one.</p>",
        "id": 366404227,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686817647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/366401506\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/366347101\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>, were you planning on compiling mathlib against this change to lean3 before or after we merge it?</p>\n</blockquote>\n<p>After, unless someone can remind me how to do it before.</p>\n</blockquote>\n<p>I'm compiling mathlib against it locally now.</p>",
        "id": 366408465,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686818503
    },
    {
        "content": "<p>The problem comes from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/zmod.algebra\">docs#zmod.algebra</a>. Indeed <code>local attribute [-instance] zmod.algebra</code> works too. The point is that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">splitting_field.algebra</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">@</span><span class=\"n\">splitting_field.algebra'</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">zmod.algebra</span> <span class=\"n\">_</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">--error</span>\n</code></pre></div>\n<p>fails.</p>",
        "id": 366408815,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686818572
    },
    {
        "content": "<p>Did that fail before the refactor?</p>",
        "id": 366409012,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686818616
    },
    {
        "content": "<p>More fundamentally,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">algebra.id</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(</span><span class=\"n\">zmod.algebra</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">--error</span>\n</code></pre></div>\n<p>fails</p>",
        "id": 366409013,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686818616
    },
    {
        "content": "<p>That one is well known</p>",
        "id": 366409253,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686818658
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/366409012\">said</a>:</p>\n<blockquote>\n<p>Did that fail before the refactor?</p>\n</blockquote>\n<p>This works on yesterday's mathlib :(</p>",
        "id": 366412828,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686819402
    },
    {
        "content": "<p>But to be honest it doesn't seem a problem in <code>splitting_field</code>. I mean, the two algebra structure on <code>zmod p</code> are not definitionally equal,  it looks like a fluke that using one or the other we get definitionally equal algebra structure on <code>splitting_field</code>. Should we set a priority on <a href=\"https://leanprover-community.github.io/mathlib_docs/find/zmod.algebra\">docs#zmod.algebra</a> to make sure that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.id\">docs#algebra.id</a> is used whenever possible?</p>",
        "id": 366414015,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686819624
    },
    {
        "content": "<p>Priorities are a lousy solution to solving diamond problem, as the wrong instance can still be introduced by using lemmas where only that instance applies</p>",
        "id": 366416817,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686820190
    },
    {
        "content": "<p>This</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"n\">p.prime</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"o\">(</span><span class=\"n\">mv_polynomial</span> <span class=\"n\">ι</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">ideal.quotient.algebra</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mv_polynomial</span> <span class=\"n\">ι</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mv_polynomial.algebra</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">ι</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">algebra.id</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)))</span> <span class=\"n\">I</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">@</span><span class=\"n\">ideal.quotient.algebra</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mv_polynomial</span> <span class=\"n\">ι</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mv_polynomial.algebra</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">ι</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">zmod.algebra</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">--fails</span>\n</code></pre></div>\n<p>fails and it is the reason why the same fails for <code>splitting_field</code>. With the old definition no <code>mv_polynomial</code> was involved and this was avoided.</p>",
        "id": 366418027,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686820450
    },
    {
        "content": "<p>Let me see if it also fails for polynomials in one variable.</p>",
        "id": 366418172,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686820484
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">polynomial.algebra_of_algebra</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">algebra.id</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">@</span><span class=\"n\">polynomial.algebra_of_algebra</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">zmod.algebra</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>fails</p>",
        "id": 366419147,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686820681
    },
    {
        "content": "<p>(<a href=\"https://github.com/leanprover-community/mathlib/pull/19191\">#19191</a> for the other one)</p>",
        "id": 366420180,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686820912
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/366408815\">said</a>:</p>\n<blockquote>\n<p>Indeed <code>local attribute [-instance] zmod.algebra</code> works too.</p>\n</blockquote>\n<p>Does this fix this diamond issue in all 3 occasions? Since <code>zmod.algebra</code> is known to cause diamonds all by itself, I think the conclusion is safe to draw that demoting <code>zmod.algebra</code> is better than <code>splitting_field.algebra'</code>. I'd even argue to do this globally, turning it into a localized instance, or just an outright <code>def</code>.</p>",
        "id": 366421978,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1686821272
    },
    {
        "content": "<p>I regret to say FieldTheory.IsAlgClosed.AlgebraicClosure (<a href=\"https://github.com/leanprover-community/mathlib4/pull/5074\">!4#5074</a>) is also full of timeouts</p>",
        "id": 366422499,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1686821390
    },
    {
        "content": "<p>I am puzzled that this does not show up more frequently. When we build an algebraic gadget <code>foo R</code>, we often add the instance <code>algebra R (foo R)</code>, and also <code>algebra A (foo R)</code>, where <code>R</code> is an <code>A</code>-algebra. Now, for <code>A = R = zmod p</code> this can cause a diamond, since Lean can choose to use two (non-definitionally equal) way of getting <code>algebra (zmod p) (zmod p)</code>. Of course this depend on the actual <code>foo</code>, but the problem is more fundamental.</p>",
        "id": 366422683,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686821423
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/366421978\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/366408815\">said</a>:</p>\n<blockquote>\n<p>Indeed <code>local attribute [-instance] zmod.algebra</code> works too.</p>\n</blockquote>\n<p>Does this fix this diamond issue in all 3 occasions? Since <code>zmod.algebra</code> is known to cause diamonds all by itself, I think the conclusion is safe to draw that demoting <code>zmod.algebra</code> is better than <code>splitting_field.algebra'</code>. I'd even argue to do this globally, turning it into a localized instance, or just an outright <code>def</code>.</p>\n</blockquote>\n<p>I've added this to <a href=\"https://github.com/leanprover-community/mathlib/pull/19191\">#19191</a>. Let's see what CI thinks.</p>",
        "id": 366423145,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686821512
    },
    {
        "content": "<p>Note that <a href=\"https://github.com/leanprover-community/mathlib4/pull/5069\">!4#5069</a> is already out of sync; we lose a lot of the benefit of a mathlib3 refactor if we then port the versions of downstream files that don't actually contain the changes from that refactor</p>",
        "id": 366427759,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686822450
    },
    {
        "content": "<p>Which is to say; I think it would be bet to refrain from porting a pile of downstream files until we actually have mathport output</p>",
        "id": 366428087,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686822507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/366423145\">said</a>:</p>\n<blockquote>\n<p>I've added this to <a href=\"https://github.com/leanprover-community/mathlib/pull/19191\">#19191</a>. Let's see what CI thinks.</p>\n</blockquote>\n<p>The build passed <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> so a <span aria-label=\"peace sign\" class=\"emoji emoji-270c\" role=\"img\" title=\"peace sign\">:peace_sign:</span> from me on the new version.</p>",
        "id": 366431311,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1686823156
    },
    {
        "content": "<p>I agree there is no need to rush here. I think we should first of all fix the various <a href=\"https://leanprover-community.github.io/mathlib-port-status/out-of-sync\">#outofsync</a> and then maybe double checking that the actual <code>FieldTheory.SplittingField.Construction</code> (in mathlib4) is coherent with the mathport output.</p>",
        "id": 366435303,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686823863
    },
    {
        "content": "<p>We can simply take the mathport output tomorrow and using the fixes already existing, it should be very easy.</p>",
        "id": 366435502,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686823900
    },
    {
        "content": "<p>Are you suggesting we port things using the old mathport output then copy over the changes tomorrow, or refrain from porting until tomorrow?</p>",
        "id": 366435812,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686823942
    },
    {
        "content": "<p>The three direct dependents are already PRd, fwiw</p>",
        "id": 366436108,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1686823980
    },
    {
        "content": "<p>I am suggesting to wait, but in <a href=\"https://github.com/leanprover-community/mathlib/pull/19178\">#19178</a> no direct dependents has been modified, so it shouldn't make a huge difference.</p>",
        "id": 366437263,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686824168
    },
    {
        "content": "<p>We should perhaps refrain from merging any of those dependents</p>",
        "id": 366438175,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686824283
    },
    {
        "content": "<p>Or alternative, add a <a href=\"https://github.com/leanprover-community/mathlib4/wiki/port-comments\">#port-comments</a> to all the files in <a href=\"https://github.com/leanprover-community/mathlib/pull/19178\">#19178</a> saying \"please wait till 2023-06-16T04:00:00+01:00 \"</p>",
        "id": 366438417,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686824322
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/366435303\">said</a>:</p>\n<blockquote>\n<p>I think we should first of all fix the various <a href=\"https://leanprover-community.github.io/mathlib-port-status/out-of-sync\">#outofsync</a></p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/5070\">!4#5070</a> is now green</p>",
        "id": 366443227,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686825037
    },
    {
        "content": "<p>As is <a href=\"https://github.com/leanprover-community/mathlib4/pull/5024\">!4#5024</a></p>",
        "id": 366444674,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686825308
    },
    {
        "content": "<p>I will review after lunch</p>",
        "id": 366446935,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686825749
    },
    {
        "content": "<p>do we need the definitional aspects of <code>def equiv_zmod_p : galois_field p 1 ≃ₐ[zmod p] (zmod p)</code> or just the fact it exists? Maybe the correct way to fix this is to make a private version (like this) and then make it polymorphic over all <code>zmod p</code> algebras</p>",
        "id": 366454300,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1686826954
    },
    {
        "content": "<p>Is it reasonable to run mathport locally to have the new version of <code>splitting_field.construction</code>? I followed the instruction doing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">./</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">mathport</span> <span class=\"n\">config.json</span> <span class=\"n\">Mathbin</span><span class=\"o\">::</span><span class=\"n\">field_theory.splitting_field.construction</span>\n</code></pre></div>\n<p>but where is the output?</p>",
        "id": 366455925,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686827262
    },
    {
        "content": "<p><code>Outputs/src/mathbin</code></p>",
        "id": 366456964,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686827481
    },
    {
        "content": "<p>I have pulled <a href=\"https://github.com/leanprover-community/mathlib4/pull/5071\">!4#5071</a> off the queue because it depends on <code>SplittingField.Construction</code> and this thread advocated waiting.</p>",
        "id": 366458144,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1686827734
    },
    {
        "content": "<p>Ah, I used <code>download-release</code>, so I am getting yesterday's version. Let me see how long it takes to <code>make predata</code></p>",
        "id": 366458287,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686827758
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span>, re: your question about whether <a href=\"https://github.com/leanprover-community/lean/pull/812\">lean#812</a> fixes the timeout issue. I'm running out of time tonight, but if you can point me to a mathlib3 commit I can pull that and compile.</p>",
        "id": 366458431,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686827779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/366458144\">said</a>:</p>\n<blockquote>\n<p>I have pulled <a href=\"https://github.com/leanprover-community/mathlib4/pull/5071\">!4#5071</a> off the queue because it depends on <code>SplittingField.Construction</code> and this thread advocated waiting.</p>\n</blockquote>\n<p>What precise condition is needed for <a href=\"https://github.com/leanprover-community/mathlib4/pull/5071\">!4#5071</a> to be ready to merge?</p>",
        "id": 366459159,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1686827914
    },
    {
        "content": "<p>If there were some PR to mathlib3 that touched the file, that might be a reason not to merge it. But I don't think there is such a PR?</p>",
        "id": 366459508,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686827982
    },
    {
        "content": "<p>The story is the following:</p>\n<ul>\n<li><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> opened the first mathlib4 PR and realized that porting the file seemed very problematic.</li>\n<li>he then changed the definition of <code>SplittingField</code>, directly in the PR (so in mathlib4)</li>\n<li>I backported the new definition to mathlib3. This PR of myself got merged a couple of hours ago.</li>\n<li>The mathlib4 PR got merged just after</li>\n</ul>",
        "id": 366460082,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686828108
    },
    {
        "content": "<p>So the current version is <em>not</em> the one produced by mathport, but rather the opposite, the mathlib3 file is the manually backported version of mathlib4.</p>",
        "id": 366460369,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686828160
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/5069\">!4#5069</a> is ready for review otherwise</p>",
        "id": 366460393,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1686828168
    },
    {
        "content": "<p>I suggest to modify the mathlib4 using the output of mathport (and the fixes already existing of course). We cannot do it right now since mathport has not yet run again the mathlib3 version.</p>",
        "id": 366460753,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686828235
    },
    {
        "content": "<p>It seems unlike that this will cause problems in directly dependents file, but it also seemed unlike that backporting the new def would have caused problems, and it did...</p>",
        "id": 366461164,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686828293
    },
    {
        "content": "<p>I've mathport locally. Here <a href=\"https://github.com/leanprover-community/mathlib4/pull/5087\">!4#5087</a> is the result.</p>",
        "id": 366571981,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686849430
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  can you check the this will not confuse any script?</p>",
        "id": 366579011,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686850994
    },
    {
        "content": "<p>Is there any reason to wait any longer on <a href=\"https://github.com/leanprover-community/mathlib4/pull/5069\">!4#5069</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/5071\">!4#5071</a>?</p>",
        "id": 366643983,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686869554
    },
    {
        "content": "<p>let's just merge master on them when <a href=\"https://github.com/leanprover-community/mathlib4/pull/5087\">!4#5087</a> is merged (half an hour?)</p>",
        "id": 366644671,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686869854
    },
    {
        "content": "<p>I will do it</p>",
        "id": 366644705,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686869874
    },
    {
        "content": "<p>To be extra safe we could wait for the next mathport output for any downstream files</p>",
        "id": 366645081,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686870065
    },
    {
        "content": "<p>yes, it is in a couple of hours, right?</p>",
        "id": 366645310,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686870143
    },
    {
        "content": "<p>no, the new output just landed</p>",
        "id": 366645836,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686870443
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/5069\">!4#5069</a> are <a href=\"https://github.com/leanprover-community/mathlib4/pull/5071\">!4#5071</a> are both ready to go (I am just waiting for CI), both the current mathport and the version used to open the PR are built against <code>df76f43357840485b9d04ed5dee5ab115d420e87</code>.</p>",
        "id": 366646065,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686870596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/366454300\">said</a>:</p>\n<blockquote>\n<p>do we need the definitional aspects of <code>def equiv_zmod_p : galois_field p 1 ≃ₐ[zmod p] (zmod p)</code> or just the fact it exists? Maybe the correct way to fix this is to make a private version (like this) and then make it polymorphic over all <code>zmod p</code> algebras</p>\n</blockquote>\n<p>im just going to bump this to ask if it's a good idea</p>",
        "id": 366648439,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1686871903
    },
    {
        "content": "<p>Well, mathematically there is one and only one iso, so we cannot really need anything specific about it.</p>",
        "id": 366649441,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686872445
    },
    {
        "content": "<p>But I really like <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> 's suggestion to turn <a href=\"https://leanprover-community.github.io/mathlib_docs/find/zmod.algebra\">docs#zmod.algebra</a> into a def, or a local instance.  I will try tomorrow, but the diamond is really there, and it has nothing to to with <code>splitting_field</code> or <code>galois_field</code>.</p>",
        "id": 366649714,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1686872617
    },
    {
        "content": "<p>In that case, I suggest that we go ahead and merge the open porting PRs using splitting fields that are ready to go</p>",
        "id": 366682311,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1686888170
    },
    {
        "content": "<p>(That had already happened. Although maybe there are again more by now!)</p>",
        "id": 366700586,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686896051
    },
    {
        "content": "<p>Yeah my open github page showed me an old cache when I was looking at the PRs this morning.</p>",
        "id": 366700783,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1686896140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/366421978\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/287929-mathlib4/topic/!4.234891.20.20FieldTheory.2ESplittingField/near/366408815\">said</a>:</p>\n<blockquote>\n<p>Indeed <code>local attribute [-instance] zmod.algebra</code> works too.</p>\n</blockquote>\n<p>Does this fix this diamond issue in all 3 occasions? Since <code>zmod.algebra</code> is known to cause diamonds all by itself, I think the conclusion is safe to draw that demoting <code>zmod.algebra</code> is better than <code>splitting_field.algebra'</code>. I'd even argue to do this globally, turning it into a localized instance, or just an outright <code>def</code>.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/19197\">#19197</a></p>",
        "id": 367157525,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1687004835
    },
    {
        "content": "<p>Should <a href=\"https://github.com/leanprover-community/mathlib4/pull/5139\">!4#5139</a> wait for this?</p>",
        "id": 367162395,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1687005863
    },
    {
        "content": "<p>I think it should wait. I'll add a note on the PR.</p>",
        "id": 367163510,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1687006155
    },
    {
        "content": "<p>In any case, this doesn't explain the original issue that declaring variables before a definition or inside the definition makes a difference in the chosen instance path. This feels like a weird bug.</p>",
        "id": 367163523,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1687006160
    },
    {
        "content": "<p>Do we have a mwe for that?</p>",
        "id": 367176658,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1687009456
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.FieldTheory.SplittingField.Construction</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.ZMod.Algebra</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Polynomial</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">GaloisField0</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">SplittingField</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">p</span><span class=\"o\">)[</span><span class=\"n\">X</span><span class=\"o\">])</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">GaloisField0</span> <span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">GaloisField0</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">GaloisField1</span> <span class=\"o\">:=</span> <span class=\"n\">SplittingField</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">p</span><span class=\"o\">)[</span><span class=\"n\">X</span><span class=\"o\">])</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">GaloisField1</span> <span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">GaloisField1</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">GaloisField0</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">≃+*</span> <span class=\"n\">GaloisField1</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">GaloisField0</span><span class=\"o\">,</span> <span class=\"n\">GaloisField1</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">RingEquiv.refl</span> <span class=\"n\">_</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 367377768,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1687093006
    },
    {
        "content": "<p>I guess it could be reduced more</p>",
        "id": 367377912,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1687093045
    }
]