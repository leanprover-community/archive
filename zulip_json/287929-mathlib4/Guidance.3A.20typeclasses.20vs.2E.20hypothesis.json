[
    {
        "content": "<p>What heuristics should I use to decide whether a condition on a given object would best be implemented as a typeclass, versus by explicitly taking an additional argument? </p>\n<p>One obvious point is that instances are supposed to be canonical, so in particular if the typeclass lives most naturally in <code>Prop</code> it seems like it would be a natural choice for being a typeclass, as that means that instance synthesis can efficiently and convenient provide the relevant conditions under various common use cases. Except that there are <em>lots</em> of cases in Mathlib where this heuristic doesn't apply, which makes me think I'm missing something.</p>",
        "id": 455829149,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722574160
    },
    {
        "content": "<p>It also depends whether the instances would be at all specific. Eg <code>[Continuous f] [Continuous g] : Continuous (f ∘ g)</code> would be a terrible since literally every function <code>h</code> is syntactically of the form <code>f ∘ g</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.comp#doc\">docs#Function.comp</a> is reducible)</p>",
        "id": 455830378,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722574802
    },
    {
        "content": "<p>... and whether you expect the arguments to be annoying/impossible to provide by hand. Eg if you want your hypothesis to be used by an instance, it must itself be a typeclass</p>",
        "id": 455831054,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722574922
    },
    {
        "content": "<p>Hmmm... So my specific case is that I'm defining the extra structure needed for a semiring ideal to make nice quotients, and one of the things I'd like to do is to make the noise go away when it's unnecessary. In particular, if the semiring is in fact a ring then all ideals are subtractive, and if the ideal is the kernel of a hom then it's also subtractive. </p>\n<p>Both of these seem like things that instance synthesis should be able to handle without horrible performance penalties, I think?</p>",
        "id": 455831527,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722575126
    },
    {
        "content": "<p>Yes, but will you expect structural instances to exist? eg instances of the form<code>[IsSubtractive I] [IsSubtractive J] : IsSubtractive (I + J)</code></p>",
        "id": 455831743,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722575211
    },
    {
        "content": "<p>There is also the concern that someone might want to rewrite their subtractive ideal to a different form where it's not structurally obvious anymore that it is subtractive</p>",
        "id": 455831805,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722575248
    },
    {
        "content": "<p>... You <em>could</em>, certainly, there are a bunch of theorems about subtractive ideals being preserved under various transformations/homomorphisms...?</p>",
        "id": 455831959,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722575304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Guidance.3A.20typeclasses.20vs.2E.20hypothesis/near/455831805\">said</a>:</p>\n<blockquote>\n<p>There is also the concern that someone might want to rewrite their subtractive ideal to a different form where it's not structurally obvious anymore that it is subtractive</p>\n</blockquote>\n<p>Yes, but I feel like that's best handled by giving the instance an explicit name so that you can use <code>... (inst := ⟨h⟩)</code> conveniently</p>",
        "id": 455832010,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722575352
    },
    {
        "content": "<p>at least, that seems like the best of both worlds to me</p>",
        "id": 455832016,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722575357
    },
    {
        "content": "<p>Another case that's coming up is the definition of a maximal/partitioning ring hom, which is a condition that does carry data, but one can prove that any two ways of filling out the data fields produce isomorphic quotients, so it's \"morally\" the same case as <code>Prop</code>. Though it still has the potential for diamond issues... Actually, in some ways I think that's a stronger argument for it being a typeclass, as otherwise providing all that bundled data would be really annoying.</p>",
        "id": 455832153,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722575458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Guidance.3A.20typeclasses.20vs.2E.20hypothesis/near/455830378\">said</a>:</p>\n<blockquote>\n<p>It also depends whether the instances would be at all specific. Eg <code>[Continuous f] [Continuous g] : Continuous (f ∘ g)</code> would be a terrible since literally every function <code>h</code> is syntactically of the form <code>f ∘ g</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.comp#doc\">docs#Function.comp</a> is reducible)</p>\n</blockquote>\n<p>This makes me kind of want a gadget <code>inParam</code>, that makes instance synthesis behave like <code>aesop safe destruct</code> ^.^;</p>",
        "id": 455832321,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722575582
    },
    {
        "content": "<p>don't think the instance synth mechanism allows for that tho</p>",
        "id": 455832331,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722575595
    },
    {
        "content": "<p>Either case, you should try! It's always possible to refactor from/to a typeclass later</p>",
        "id": 455832787,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722575951
    },
    {
        "content": "<p>Fair enough!</p>",
        "id": 455832799,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722575965
    }
]