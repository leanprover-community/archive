[
    {
        "content": "<p>So, in many places in Mathlib I've seen match patterns like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">match_pattern</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toFoo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>This seems strange to me, because near as I can tell this doesn't and can't work -- if you try to actually match against that pattern, Lean will expect you to be matching an <code>Equiv</code>, not the result of <em>applying</em> the <code>Equiv</code>. Is there something I'm missing here that would make this work, or is this something we should just be fixing across the board?</p>",
        "id": 563693216,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1765723063
    },
    {
        "content": "<p>Maybe this worked in lean 3?</p>",
        "id": 563706515,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1765738998
    },
    {
        "content": "<p>Or alternatively, maybe this was tagged and then later converted to an Equiv from a plain function</p>",
        "id": 563706530,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1765739019
    }
]