[
    {
        "content": "<p>I'd like to better understand <code>Bool.noConfusionType</code> and <code>Nat.noConfusionType</code>.</p>\n<p>Firstly, is this a general construction for any inductive type? Can I see the source code anywhere?</p>\n<p>When I print <code>Bool.noConfusionType</code> I see:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">noConfusionType</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>When <code>P</code> is <code>False</code> or <code>Empty</code>, this looks very close to the observational equality type of <code>Bool</code>. But how should I think about this parameter <code>P</code> in general? What other cases of <code>P</code> are useful?</p>\n<p>When I print <code>Nat.noConfusionType</code> I see:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">noConfusionType</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n_1</span><span class=\"w\"> </span><span class=\"bp\">â†¦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n_1</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">P</span>\n</code></pre></div>\n<p>Again when <code>P</code> is <code>False</code> or <code>Empty</code> I can see that this is equivalent to the observation equality type of <code>Nat</code>. In the final inductive step for <code>n n_1 : Nat</code> it defines <code>Nat.noConfusionType P n.succ n_1.succ</code> to be <code>(n = n_1 -&gt; P) -&gt; P</code> which is equivalent to <code>P -&gt; P</code> in the case the equality is true and <code>P</code> in the case the equality is false.</p>\n<p>Tl;dr: I've never seen this construction before. Can someone explain both where it comes from (theoretically) and where it is defined in mathlib?</p>",
        "id": 546529912,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1761159293
    },
    {
        "content": "<p>basically, it's a way to conclude constructor injectivity from pattern-matching</p>",
        "id": 546530190,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761159395
    },
    {
        "content": "<p>I don't think it's defined anywhere in mathlib, it's automatically generated for each inductive type you have</p>",
        "id": 546530244,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761159416
    },
    {
        "content": "<p>maybe I can find you the code that does this generation</p>",
        "id": 546530262,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761159424
    },
    {
        "content": "<p>it's stated for an arbitrary <code>P</code> so you don't have to compose with <code>False.elim</code> or <code>Empty.elim</code> when you're using it to derive a contradiction ...probably</p>",
        "id": 546530397,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761159472
    },
    {
        "content": "<p>Kevin Buzzard has a post about noConfusion here: <a href=\"https://xenaproject.wordpress.com/2018/03/24/no-confusion-over-no_confusion/\">https://xenaproject.wordpress.com/2018/03/24/no-confusion-over-no_confusion/</a><br>\nand according to <a href=\"https://lean-lang.org/doc/reference/4.21.0/The-Type-System/Inductive-Types/\">https://lean-lang.org/doc/reference/4.21.0/The-Type-System/Inductive-Types/</a> , noConfusionType is used to build that.</p>",
        "id": 546531039,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1761159685
    },
    {
        "content": "<p>found it <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.mkNoConfusion#doc\">docs#Lean.mkNoConfusion</a></p>",
        "id": 546531156,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761159722
    },
    {
        "content": "<p>don't know how helpful it will be but that's the code that creates the no confusion types</p>",
        "id": 546531276,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761159768
    },
    {
        "content": "<p>I think of <code>(n = n_1 -&gt; P) -&gt; P</code> as a cps-transform of <code>n = n_1</code></p>",
        "id": 546532492,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761160138
    },
    {
        "content": "<p>so you're actually concluding <code>n = n_1</code> which you can see by setting <code>P := (n = n_1)</code> and passing in <code>id</code></p>",
        "id": 546532565,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761160170
    },
    {
        "content": "<p>but this way you can pass in a continuation</p>",
        "id": 546532604,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761160187
    },
    {
        "content": "<p>idk maybe it's not actually that useful</p>",
        "id": 546532636,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761160207
    },
    {
        "content": "<p>I guess it's also good to be consistent and have your return type always be <code>P</code></p>",
        "id": 546532684,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761160228
    },
    {
        "content": "<p>What does \"cps-transform\" mean?</p>",
        "id": 546532836,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1761160285
    },
    {
        "content": "<p>I'm familiar with what this is used for (from HoTT where we use the observational equality types to similar ends). But I don't understand the specific construction with the parameter <code>P</code>.</p>",
        "id": 546532948,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1761160326
    },
    {
        "content": "<p>continuation passing style</p>",
        "id": 546533525,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761160549
    },
    {
        "content": "<p>it takes a type <code>C</code> and turns it into <code>(C -&gt; R) -&gt; R</code></p>",
        "id": 546533626,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761160596
    },
    {
        "content": "<p>see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cont#doc\">docs#Cont</a></p>",
        "id": 546533851,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761160697
    },
    {
        "content": "<p>Thanks. I'm understanding better.</p>\n<p>This may be too much to hope for but is there some sort of parametricity result (warning: I don't actually understand parametricity) that proves this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">nat_for_free</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ï†</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ï†</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Ï†</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">âˆ˜</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ï†</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ï†</span><span class=\"w\"> </span><span class=\"n\">B</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Because if so we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">yoneda</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">â‰ƒ</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"n\">Ï†</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ï†</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"n\">Ï†</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">nat_for_free</span>\n</code></pre></div>",
        "id": 546537915,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1761162169
    },
    {
        "content": "<p>Parametericity doesn't hold in Lean's theory, it's essentially incompatible with choice. (<code>yoneda</code> is false.)</p>",
        "id": 546538594,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1761162401
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/287929-mathlib4/topic/noConfusionType/near/546537915\">said</a>:</p>\n<blockquote>\n<p>parametricity result (warning: I don't actually understand parametricity)</p>\n</blockquote>\n<p>the only thing i know about parametricity is that you can never prove parametricity (inside the language) <span aria-label=\"melt\" class=\"emoji emoji-1fae0\" role=\"img\" title=\"melt\">:melt:</span></p>",
        "id": 546538658,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761162425
    },
    {
        "content": "<p>See <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/Parametericity/near/428031283\">#lean4 &gt; Parametericity @ ðŸ’¬</a>  for a nice counterexample from Kyle Miller</p>",
        "id": 546538764,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1761162468
    },
    {
        "content": "<p>Ah, right of course. I was leveraging intuitions from a different formal system which is constructive and where a result similar to this is true. Thanks.</p>",
        "id": 546539798,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1761162831
    },
    {
        "content": "<p>not all transformations are natural</p>",
        "id": 546541420,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761163404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/287929-mathlib4/topic/noConfusionType/near/546539798\">said</a>:</p>\n<blockquote>\n<p>true</p>\n</blockquote>\n<p>but was it provable?</p>",
        "id": 546542662,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761163866
    },
    {
        "content": "<p>I mean it's still true in Lean that the only function you can define (without using choice) is the identity</p>",
        "id": 546542751,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761163892
    },
    {
        "content": "<p>This came up elsewhere recently, Kevin Buzzard had an old blog post that gave this rather concrete example of building up to 'values from different constructors are not equal' (updated for Lean 4):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">mytype</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">AA</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mytype</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ZZ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mytype</span>\n\n<span class=\"c1\">-- This is the setup that guides case analysis</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mytype_equal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mytype</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">mytype</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">AA</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">AA</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">AA</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ZZ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">False</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ZZ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">AA</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">False</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ZZ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ZZ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mytype_no_confusion</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mytype</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mytype</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">mytype_equal</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">H</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">H</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- The `simp` here just unfolds `mytype_equal`.</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mytype_equal</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">unconfused</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mytype</span><span class=\"bp\">.</span><span class=\"n\">AA</span><span class=\"w\"> </span><span class=\"bp\">â‰ </span><span class=\"w\"> </span><span class=\"n\">mytype</span><span class=\"bp\">.</span><span class=\"n\">ZZ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mytype_no_confusion</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">AA</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ZZ</span>\n</code></pre></div>",
        "id": 546551453,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1761167327
    }
]