[
    {
        "content": "<p>I'm constructing the homeomorphism between irrationals and Baire space using continued fractions, and found that <code>Stream'</code>, which represents infinite list, is inefficient.<br>\nCurrently, <code>Stream' α</code> is an alias of <code>ℕ → α</code>.<br>\nFor example, consider taking first <code>n</code>-th element of the fibonacci sequence:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Stream'</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fibAux</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Stream'</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">corec</span> <span class=\"n\">Prod.snd</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">:</span> <span class=\"n\">Stream'</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">fibAux</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">take</span> <span class=\"mi\">5</span> <span class=\"n\">fib</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">  take 5 fib</span>\n<span class=\"cm\">→×6 [((fun (m, n) =&gt; (n, m + n))^[0] (0, 1)).2, ((fun (m, n) =&gt; (n, m + n))^[1] (0, 1)).2, ((fun (m, n) =&gt; (n, m + n))^[2] (0, 1)).2, ((fun (m, n) =&gt; (n, m + n))^[3] (0, 1)).2, ((fun (m, n) =&gt; (n, m + n))^[4] (0, 1)).2]</span>\n<span class=\"cm\">→×4 [((fun (m, n) =&gt; (n, m + n))^[0] (0, 1)).2, ((fun (m, n) =&gt; (n, m + n))^[0] (1, 1)).2, ((fun (m, n) =&gt; (n, m + n))^[1] (1, 1)).2, ((fun (m, n) =&gt; (n, m + n))^[2] (1, 1)).2, ((fun (m, n) =&gt; (n, m + n))^[3] (1, 1)).2]</span>\n<span class=\"cm\">→×3 [((fun (m, n) =&gt; (n, m + n))^[0] (0, 1)).2, ((fun (m, n) =&gt; (n, m + n))^[0] (1, 1)).2, ((fun (m, n) =&gt; (n, m + n))^[0] (1, 2)).2, ((fun (m, n) =&gt; (n, m + n))^[1] (1, 2)).2, ((fun (m, n) =&gt; (n, m + n))^[2] (1, 2)).2]</span>\n<span class=\"cm\">→×2 [((fun (m, n) =&gt; (n, m + n))^[0] (0, 1)).2, ((fun (m, n) =&gt; (n, m + n))^[0] (1, 1)).2, ((fun (m, n) =&gt; (n, m + n))^[0] (1, 2)).2, ((fun (m, n) =&gt; (n, m + n))^[0] (2, 3)).2, ((fun (m, n) =&gt; (n, m + n))^[1] (2, 3)).2]</span>\n<span class=\"cm\">→ [((fun (m, n) =&gt; (n, m + n))^[0] (0, 1)).2, ((fun (m, n) =&gt; (n, m + n))^[0] (1, 1)).2, ((fun (m, n) =&gt; (n, m + n))^[0] (1, 2)).2, ((fun (m, n) =&gt; (n, m + n))^[0] (2, 3)).2, ((fun (m, n) =&gt; (n, m + n))^[0] (3, 5)).2]</span>\n<span class=\"cm\">→×5 [(0, 1).2, (1, 1).2, (1, 2).2, (2, 3).2, (3, 5).2]</span>\n<span class=\"cm\">→×5 [1, 1, 2, 3, 5]</span>\n<span class=\"cm\">Time 26  (O(N ^ 2))</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span> <span class=\"n\">Stream'</span>\n</code></pre></div>\n<p>As you see, the duplication of computation occurs.<br>\nThe one of solution is implementing \"coinductive type\". This is used in Coq.<br>\nWith coinductive type, the computation become faster:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">coinductive</span> <span class=\"n\">Stream'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Stream'</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Stream'</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Stream'</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"n\">corec</span> <span class=\"kd\">def</span> <span class=\"n\">fibAux</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Stream'</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">cons</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">fibAux</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">:</span> <span class=\"n\">Stream'</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">fibAux</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">take</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Stream'</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span>    <span class=\"o\">,</span> <span class=\"n\">_</span>        <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">take</span> <span class=\"n\">n</span> <span class=\"n\">s</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">take</span> <span class=\"mi\">5</span> <span class=\"n\">fib</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">  take 5 fib</span>\n<span class=\"cm\">= take 5 (fibAux 0 1)</span>\n<span class=\"cm\">→ take 5 (cons 1 (fibAux 1 1))</span>\n<span class=\"cm\">→ 1 :: take 4 (fibAux 1 1)</span>\n<span class=\"cm\">→ 1 :: take 4 (cons 1 (fibAux 1 2))</span>\n<span class=\"cm\">→ 1 :: 1 :: take 3 (fibAux 1 2)</span>\n<span class=\"cm\">→ 1 :: 1 :: take 3 (cons 2 (fibAux 2 3))</span>\n<span class=\"cm\">→ 1 :: 1 :: 2 :: take 2 (fibAux 2 3)</span>\n<span class=\"cm\">→ 1 :: 1 :: 2 :: take 2 (cons 3 (fibAux 3 5))</span>\n<span class=\"cm\">→ 1 :: 1 :: 2 :: 3 :: take 1 (fibAux 3 5)</span>\n<span class=\"cm\">→ 1 :: 1 :: 2 :: 3 :: take 1 (cons 5 (fibAux 5 8))</span>\n<span class=\"cm\">→ 1 :: 1 :: 2 :: 3 :: 5 :: take 0 (fibAux 5 8)</span>\n<span class=\"cm\">→ [1, 1, 2, 3, 5]</span>\n<span class=\"cm\">Time 11 (O(N))</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Stream'</span>\n</code></pre></div>\n<p>However, Lean has no coinductive types, but the alternative is formalized in mathlib: <code>PFunctor.M</code>.<br>\nSimulating the construction of <code>PFunctor.M</code>, The definition of <code>Stream'</code> can become more efficient:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Vector</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Stream'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">take</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n  <span class=\"n\">consistent</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">toList</span> <span class=\"o\">(</span><span class=\"n\">take</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">&lt;+</span><span class=\"o\">:</span> <span class=\"n\">toList</span> <span class=\"o\">(</span><span class=\"n\">take</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Should we change the definition of <code>Stream'</code> to this?<br>\nWhy I ask about this question is that the equivalence of <code>Stream' α</code> and <code>ℕ → α</code> is required in my work. Currently this transformation is done by the equality of types, but if this change comes after, my proof breaks.</p>",
        "id": 390747386,
        "sender_full_name": "Pol'tta / Miyahara Kō",
        "timestamp": 1694618467
    },
    {
        "content": "<p>/poll Should we change the definition of Stream'?<br>\nYes<br>\nNo</p>",
        "id": 390748097,
        "sender_full_name": "Pol'tta / Miyahara Kō",
        "timestamp": 1694618669
    },
    {
        "content": "<p>I don't think you should be deciding \"should lean get coinductive types\" by a poll</p>",
        "id": 390786041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694632264
    },
    {
        "content": "<p>Yes, <code>Stream'</code> is a model and does not reflect the desired computational behavior. There really isn't anything that does, PFunctor.M is not better</p>",
        "id": 390786119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694632309
    },
    {
        "content": "<p>Implementing coinductive types requires more than that, it needs a vm_override to something with the desired computational behavior</p>",
        "id": 390786217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694632340
    },
    {
        "content": "<p>and of course we want to see that, the QPF paper was about making that happen but we never finished the implementation side of things</p>",
        "id": 390786274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694632373
    },
    {
        "content": "<p>I don't recommend using <code>PFunctor.M</code> directly, it is intended only as a model construction</p>",
        "id": 390786323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1694632392
    },
    {
        "content": "<p>I've implemented coinductive types in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7512\">#7512</a>.</p>",
        "id": 394970263,
        "sender_full_name": "Pol'tta / Miyahara Kō",
        "timestamp": 1696485924
    },
    {
        "content": "<p><a href=\"#narrow/stream/287929-mathlib4/topic/Implementing.20coinductive.20types/near/394970263\">A message</a> was moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/.02klzzwxh.3A0000.03.20is.20inefficient\">#mathlib4 &gt; <code>Stream'</code> is inefficient</a> by <span class=\"user-mention silent\" data-user-id=\"569722\">Pol'tta / Miyahara Kō</span>.</p>",
        "id": 394970688,
        "sender_full_name": "Notification Bot",
        "timestamp": 1696486114
    },
    {
        "content": "<p>2 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/Implementing.20coinductive.20types\">#mathlib4 &gt; Implementing coinductive types</a> by <span class=\"user-mention silent\" data-user-id=\"569722\">Pol'tta / Miyahara Kō</span>.</p>",
        "id": 394971170,
        "sender_full_name": "Notification Bot",
        "timestamp": 1696486366
    },
    {
        "content": "<p>There is already a coinductive package over here: <a href=\"https://github.com/alexkeizer/QpfTypes\">https://github.com/alexkeizer/QpfTypes</a>, I don't think we should be duplicating work like this. CC <span class=\"user-mention\" data-user-id=\"481133\">@Alex Keizer</span> </p>\n<p>Also am I seeing correctly that you <code>Thunk.mk</code> every single element while iterating through your tree? That's a horrible computational behavior too isn't it?</p>",
        "id": 394980901,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1696490894
    },
    {
        "content": "<p>My PR improve the computational behavor of <code>PFunctor.M</code> &amp; <code>QPF.Cofix</code>, that package implements the new syntax for <code>MvQPF.Fix</code> &amp; <code>MvQPF.Cofix</code>. Their roles are different.</p>",
        "id": 394983925,
        "sender_full_name": "Pol'tta / Miyahara Kō",
        "timestamp": 1696492234
    },
    {
        "content": "<p>Also, tree of coinductive types can be infinite, so we should prevent evaluating unnecessary data. <code>Thunk.mk</code>s are required for this reason.</p>",
        "id": 394986154,
        "sender_full_name": "Pol'tta / Miyahara Kō",
        "timestamp": 1696493187
    },
    {
        "content": "<p>Good to see more people interested in coinductive types!<br>\n<span class=\"user-mention\" data-user-id=\"569722\">@Pol'tta / Miyahara Kō</span> it might make sense to post an example of what you are trying to do where you're running into these computational issues. Maybe with a little benchmark with your <code>Thunk</code>-ed version to get a better idea of the speed-up.</p>\n<p>EDIT: I just saw you started this thread with an example.</p>",
        "id": 394998551,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1696497805
    },
    {
        "content": "<p>The benchmark is in <code>test/M.lean</code>.</p>",
        "id": 394999409,
        "sender_full_name": "Pol'tta / Miyahara Kō",
        "timestamp": 1696498129
    },
    {
        "content": "<p>From what I can tell, you're not necessarily using the Thunk to memoize earlier results in the stream, you just want iteration through the thing to be fast?<br>\nI have some vague ideas about how we might be able to make that faster. Essentially, inhabitants of a coinductive type are defined as a state machine, and the corecursion principle translates this state machine description to the internal <code>M</code>-type representation.<br>\nIterating through this <code>M</code>-type is slow, but if we can somehow keep the original state machine around and iterate over that directly, it should be much faster. <br>\nPossibly, we could model the infinite tree as a quotient over such state machines, to still get the same model with nicer computational behaviour without needing <code>implemented_by</code>? <br>\nAlthough all this comes with the caveat that I haven't properly worked out any of that.</p>",
        "id": 395000774,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1696498628
    },
    {
        "content": "<p>OK, I will try implementing as quotient.</p>",
        "id": 395011852,
        "sender_full_name": "Pol'tta / Miyahara Kō",
        "timestamp": 1696502400
    },
    {
        "content": "<p>Did you mean this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">MMachine</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n  <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">X</span>\n  <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">X</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MMachine</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">IsBisimulation</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">MMachine</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">MMachine</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">dest</span> <span class=\"o\">{</span><span class=\"n\">X₁</span> <span class=\"n\">X₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">X₁</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">X₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">X₂</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">X₂</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i₁</span> <span class=\"o\">:</span> <span class=\"n\">X₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i₂</span> <span class=\"o\">:</span> <span class=\"n\">X₂</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">R</span> <span class=\"o\">⟨</span><span class=\"n\">f₁</span><span class=\"o\">,</span> <span class=\"n\">i₁</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">f₂</span><span class=\"o\">,</span> <span class=\"n\">i₂</span><span class=\"o\">⟩</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">g₁</span> <span class=\"n\">g₂</span><span class=\"o\">,</span> <span class=\"n\">f₁</span> <span class=\"n\">i₁</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">g₁</span><span class=\"o\">⟩</span> <span class=\"bp\">∧</span> <span class=\"n\">f₂</span> <span class=\"n\">i₂</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">g₂</span><span class=\"o\">⟩</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"o\">⟨</span><span class=\"n\">f₁</span><span class=\"o\">,</span> <span class=\"n\">g₁</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">f₂</span><span class=\"o\">,</span> <span class=\"n\">g₂</span> <span class=\"n\">b</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">PFunctor.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"o\">(</span><span class=\"n\">MMachine</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">r</span> <span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">MMachine</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">MMachine</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"n\">IsBisimulation</span> <span class=\"n\">R</span> <span class=\"bp\">∧</span> <span class=\"n\">R</span> <span class=\"n\">m₁</span> <span class=\"n\">m₂</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MMachine</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MIntl</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quotient</span> <span class=\"o\">(</span><span class=\"n\">MMachine.setoid</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">MIntl.small</span> <span class=\"o\">:</span> <span class=\"n\">Small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">MIntl</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">M2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Shrink</span> <span class=\"o\">(</span><span class=\"n\">MIntl</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I oppose this implementation.<br>\n\"This type lives in the higher universe\" &amp; \"<code>corec</code> isn't polymorphic anymore\" are one of the reasons, but these problems can be solved by using <code>Shrink</code> &amp; make <code>equivShrink</code> computable.<br>\nThe decitive factor is that we can't change the state type later anymore.<br>\nI changed the implementation of <code>M.mk</code> &amp; <code>M.corec'</code> to make the state type more simple at the right timing.<br>\nWe can't do this optimization in this <code>M2</code> model.<br>\nThese two functions are guessed to be used frequently, in this case, the state type becomes too complex in <code>M2</code> model.</p>",
        "id": 395440597,
        "sender_full_name": "Pol'tta / Miyahara Kō",
        "timestamp": 1696701592
    },
    {
        "content": "<p>Thanks for working out my half-baked idea! The universe bump, even if solvable with <code>Shrink</code>, does seem a bit nasty indeed.<br>\nI'm curious what you mean by \"<code>corec</code> isn't polymorhpic anymore\" and not being able to change the state type later?</p>",
        "id": 395707206,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1696860421
    },
    {
        "content": "<p><strong>1. <code>corec</code> isn't polymorhpic anymore</strong><br>\nLet's implement <code>MIntl.corec</code> naively:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">MIntl</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">corec</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MIntl</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">⟦</span><span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">⟩</span><span class=\"bp\">⟧</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MIntl</span>\n</code></pre></div>\n<p>The universe of state type is fixed to the one of <code>F</code>, however, the universe of state type of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/PFunctor/Univariate/M.html#PFunctor.M.corec\">M.corec</a> is polymorphic.<br>\nActually, this can be made polymorphic using <code>Shrink</code> too.</p>\n<p><strong>2. not being able to change the state type later</strong><br>\nLet's implement <code>MIntl.mk</code> like <code>M.mk</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">MIntl</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Polymorphic `corec` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">corecP</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MIntl</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dest</span> <span class=\"o\">:</span> <span class=\"n\">MIntl2</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">MIntl2</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quotient.lift</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">match</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">o</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">⟦</span><span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">o</span> <span class=\"n\">b</span><span class=\"o\">⟩</span><span class=\"bp\">⟧</span><span class=\"o\">⟩)</span>\n    <span class=\"gr\">sorry</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">MIntl2</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">MIntl2</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"n\">corecP</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">dest</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MIntl</span>\n</code></pre></div>\n<p>In this implementation, for <code>b : F.B a</code>, the state type of <code>(dest (mk ⟨a, o⟩)).2 b</code> is still <code>F (MIntl2 F)</code>, not <code>(o b).unquot.X</code>.<br>\nIf we use <code>mk</code> many times, the state type become <code>F (F (F ...)))</code>. This is inefficient.<br>\nI avoid this problem in <code>M.mk</code> by this implementation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">M.mkUnsafe</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">o</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ofI</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">CofixI.mk</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Thunk.pure</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">toI</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"n\">b</span><span class=\"o\">)⟩</span>\n</code></pre></div>",
        "id": 396199152,
        "sender_full_name": "Pol'tta / Miyahara Kō",
        "timestamp": 1697078497
    },
    {
        "content": "<p>Sorry, I was going to improve the computational behavor of <code>PFunctor.M</code> &amp; <code>QPF.Cofix</code>, and define <code>Stream'</code>, <code>Computation</code> &amp; <code>Stream'.Seq</code> using <code>QPF.Cofix</code>, but <code>QPF.Cofix.corec</code> isn't polymorphic in contrast to <code>Stream'.corec</code>, and making <code>QPF.Cofix.corec</code> polymorphic is difficult, so I abandon the works for <code>PFunctor.M</code> &amp; <code>QPF.Cofix</code>. Instead, we override the data structures of <code>Stream'</code>, <code>Computation</code> &amp; <code>Stream'.Seq</code> directly.</p>",
        "id": 399940733,
        "sender_full_name": "Pol'tta / Miyahara Kō",
        "timestamp": 1698933108
    },
    {
        "content": "<p>Thank you for this work. I'm eagerly awaiting the results.</p>",
        "id": 400391644,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1699187819
    }
]