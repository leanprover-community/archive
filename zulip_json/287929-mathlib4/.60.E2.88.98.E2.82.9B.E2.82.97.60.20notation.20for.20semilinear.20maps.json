[
    {
        "content": "<p>There is <code>∘ₗ</code> notation for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.comp#doc\">docs#LinearMap.comp</a> as some kind of fallback (from the docs: \"<code>∘ₗ</code> is notation for composition of two linear (not semilinear!) maps into a linear map. This is useful when Lean is struggling to infer the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Ring/CompTypeclasses.html#RingHomCompTriple\">RingHomCompTriple</a> instance.\")</p>\n<p>Why is there no <code>∘ₛₗ</code> notation? I tried locally this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">infixr</span><span class=\"o\">:</span><span class=\"mi\">90</span><span class=\"w\"> </span><span class=\"s2\">\" ∘ₛₗ \"</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">comp</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span>\n</code></pre></div>\n<p>and it seems to work.</p>",
        "id": 497518603,
        "sender_full_name": "Michał Staromiejski",
        "timestamp": 1738611878
    },
    {
        "content": "<p>The non-semilinear notation exists primarily because <code>.comp</code> is much more finicky to elaborate (as it isn't restricted to non-semilinearity). That's not to say we couldn't have what you propose, only the reason the other one was more important</p>",
        "id": 497519485,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1738612242
    },
    {
        "content": "<p>I don't see any reason why we shouldn't have this notation.</p>",
        "id": 497523216,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738613737
    },
    {
        "content": "<p>A bit later but created PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/22704\">#22704</a> for the notation.</p>",
        "id": 504213416,
        "sender_full_name": "Michał Staromiejski",
        "timestamp": 1741395353
    },
    {
        "content": "<p>Hmm, I would have been more inclined towards a PR which also replaced the existing comps in the library with the notation (I recently reviewed another PR which added notation for an already-existing function and suggested that there but this PR all happened when I was asleep). Actually using the notation is also a good check that you've got things like priorities correct.</p>",
        "id": 504251855,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741422569
    },
    {
        "content": "<p>We should add the isomorphism version too</p>",
        "id": 504254127,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741423998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60.E2.88.98.E2.82.9B.E2.82.97.60.20notation.20for.20semilinear.20maps/near/504251855\">said</a>:</p>\n<blockquote>\n<p>Actually using the notation is also a good check that you've got things like priorities correct.</p>\n</blockquote>\n<p>Fair enough.</p>",
        "id": 504254396,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1741424181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60.E2.88.98.E2.82.9B.E2.82.97.60.20notation.20for.20semilinear.20maps/near/504254127\">said</a>:</p>\n<blockquote>\n<p>We should add the isomorphism version too</p>\n</blockquote>\n<p>There is one already in <code>Mathlib.Algebra.Module.Equiv.Defs</code> I think? Or you mean something else?</p>",
        "id": 504278958,
        "sender_full_name": "Michał Staromiejski",
        "timestamp": 1741442923
    },
    {
        "content": "<p>Do we already have the \"sl\" version there?</p>",
        "id": 504307817,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741461579
    },
    {
        "content": "<p>Line 70:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- `M ≃ₛₗ[σ] M₂` denotes the type of linear equivalences between `M` and `M₂` over a</span>\n<span class=\"sd\">ring homomorphism `σ`. -/</span>\n<span class=\"kn\">notation</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"s2\">\" ≃ₛₗ[\"</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"s2\">\"] \"</span><span class=\"w\"> </span><span class=\"n\">M₂</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">LinearEquiv</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">M₂</span>\n</code></pre></div>\n<p>It looks like this?</p>",
        "id": 504313702,
        "sender_full_name": "Michał Staromiejski",
        "timestamp": 1741465437
    },
    {
        "content": "<p>I mean the one for <code>LinearEquiv.trans</code>, which is analogous to the <code>LinearMap.comp</code> you added notation for</p>",
        "id": 504325510,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741474240
    },
    {
        "content": "<p>I see. But is there even counterpart for regular functions/relations? Or for other algebraic structures?</p>",
        "id": 504335532,
        "sender_full_name": "Michał Staromiejski",
        "timestamp": 1741482723
    },
    {
        "content": "<p>For regular functions there is <code>∘</code>, I'm not sure how you would compose a relation though.</p>",
        "id": 504335636,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741482827
    },
    {
        "content": "<p>We have <code>\\&lt;&lt;&gt;&gt;ₗ</code> but probably no <code>\\&lt;&lt;&gt;&gt;ₛₗ</code></p>",
        "id": 504367420,
        "sender_full_name": "Jz Pan",
        "timestamp": 1741508003
    },
    {
        "content": "<p>Seems to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">LinearEquiv</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">infixr</span><span class=\"o\">:</span><span class=\"mi\">90</span><span class=\"w\"> </span><span class=\"s2\">\" ≪≫ₛₗ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">trans</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">LinearEquiv</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R₁</span><span class=\"w\"> </span><span class=\"n\">R₂</span><span class=\"w\"> </span><span class=\"n\">M₁</span><span class=\"w\"> </span><span class=\"n\">M₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R₂</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M₂</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R₁</span><span class=\"w\"> </span><span class=\"n\">M₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R₂</span><span class=\"w\"> </span><span class=\"n\">M₂</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">σ₁₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R₁</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">R₂</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">σ₂₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R₂</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">R₁</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span><span class=\"w\"> </span><span class=\"n\">σ₁₂</span><span class=\"w\"> </span><span class=\"n\">σ₂₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span><span class=\"w\"> </span><span class=\"n\">σ₂₁</span><span class=\"w\"> </span><span class=\"n\">σ₁₂</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">symm_trans_self'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M₁</span><span class=\"w\"> </span><span class=\"bp\">≃ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ₁₂</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">≪≫ₛₗ</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">LinearEquiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">R₂</span><span class=\"w\"> </span><span class=\"n\">M₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 504395988,
        "sender_full_name": "Michał Staromiejski",
        "timestamp": 1741528532
    },
    {
        "content": "<p>Would be cool if Lean had overloading (at least basic); after all the types of arguments are different so there is a way to interpret <code>g ∘ₛₗ f</code> for <code>(f : M₁ ≃ₛₗ[σ₁₂] M₂) (g : M₂ ≃ₛₗ[σ₂₃] M₃)</code> as <code>g.trans f</code> and for <code>(f : M₁ →ₛₗ[σ₁₂] M₂) (g : M₂ →ₛₗ[σ₂₃] M₃)</code> as <code>g.comp f</code>...</p>",
        "id": 504396764,
        "sender_full_name": "Michał Staromiejski",
        "timestamp": 1741529065
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"759408\">Michał Staromiejski</span> <a href=\"#narrow/channel/287929-mathlib4/topic/.60.E2.88.98.E2.82.9B.E2.82.97.60.20notation.20for.20semilinear.20maps/near/504396764\">said</a>:</p>\n<blockquote>\n<p>Would be cool if Lean had overloading (at least basic); after all the types of arguments are different so there is a way to interpret <code>g ∘ₛₗ f</code> for <code>(f : M₁ ≃ₛₗ[σ₁₂] M₂) (g : M₂ ≃ₛₗ[σ₂₃] M₃)</code> as <code>g.trans f</code> and for <code>(f : M₁ →ₛₗ[σ₁₂] M₂) (g : M₂ →ₛₗ[σ₂₃] M₃)</code> as <code>g.comp f</code>...</p>\n</blockquote>\n<p>That could be done, you would need to have a way of knowing what type you want though.</p>",
        "id": 504399913,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741531429
    }
]