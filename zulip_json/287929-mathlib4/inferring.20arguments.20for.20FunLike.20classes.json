[
    {
        "content": "<p>If I define a function which depends on some implicit parameters, and then I apply my function to something, Lean will try to figure out the implicit arguments from the types of the explicit ones. </p>\n<p>However, when I define, rather than a function, some bundled <code>FunLike</code> thing, it seems that this doesn't apply: the implicit-parameter inference process doesn't \"see through\" the coercion-to-a-function operation. Is there a way of getting around this?</p>\n<p>To be much more concrete: the following works, to define the \"shift operator\" that sends a function <code>f : A → B</code> to the function <code>a ↦ f (a + 1)</code>, where <code>A</code> is a ring and <code>B</code> an abelian addgroup:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Shift-by-1 operator -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">shift</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>Here the types <code>A</code> and <code>B</code> are implicit parameters to <code>shift</code>, but it can correctly deduce these from the type of <code>f</code>. However, if I define <code>shiftₗ</code> to be the same thing bundled as a linear operator on functions, not just a bare map, it seems to be unable to use <code>f</code> to figure out the type arguments to <code>shiftₗ</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Shift-by-1 operator bundled as `ℤ`-linear endomorphism -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">shiftₗ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">map_add'</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">map_smul'</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">shiftₗ</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"c1\">-- fails: function expected ... term has type Module.End ℤ (?m.5014 → ?m.5015)</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">shiftₗ</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"c1\">-- works, but ugly</span>\n</code></pre></div>\n<p>Is there some clever hack that will allow me to write <code>shiftₗ f</code> without explicitly giving the types?</p>",
        "id": 476147028,
        "sender_full_name": "David Loeffler",
        "timestamp": 1728570148
    },
    {
        "content": "<p>I've seen this kind of thing, before, but not for a long time. I think it's something to do with linear maps specifically. Note that the same problem does <em>not</em> exist if you make <code>shiftₗ</code> and <code>AddMonoidHom</code>, for instance.</p>",
        "id": 476154752,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1728572245
    },
    {
        "content": "<p>Interesting! It does indeed work bundled as an AddMonoidHom. Unfortunately I really do need to bundle it in some way that gives a ring structure, since I want to write things like <code>(shiftₗ - 1)^7 f</code>.</p>",
        "id": 476159205,
        "sender_full_name": "David Loeffler",
        "timestamp": 1728573413
    },
    {
        "content": "<p>certainly, I'm not saying that you shouldn't be able to have the linear map version, I'm just trying to help narrow down where the problem occurs, because Lena definitely should be able to do this. I had similar issues about 10 months ago with star algebra homomorphisms, because those went away (I don't recall what the fix was, but I didn't implement it), so I'm surprised it's back.</p>",
        "id": 476159924,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1728573618
    },
    {
        "content": "<p>(the motivation here is to get Newton's formula for forward differences by applying the binomial theorem inside the ring <code>Module.End ℤ (A → B)</code>.)</p>",
        "id": 476159931,
        "sender_full_name": "David Loeffler",
        "timestamp": 1728573621
    },
    {
        "content": "<p>Another remark about this: oddly, for <code>shiftₗ</code> applied to a function <code>A → B</code>, it seems to be able to figure out <code>A</code>, but not <code>B</code>: that is, </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">shiftₗ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\">  </span><span class=\"c1\">-- fails</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">shiftₗ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\">  </span><span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 476220300,
        "sender_full_name": "David Loeffler",
        "timestamp": 1728592654
    }
]