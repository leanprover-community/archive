[
    {
        "content": "<p>Does anyone know of any examples of meta code which uses Qq to match compositions of morphisms in a category? <br>\nIdeally I want something of type <code>Expr -&gt; MetaM (Expr x Expr)</code> which will split out <code>f</code> and <code>g</code> (as exprs) given <code>f ≫ g</code> as input.</p>",
        "id": 402375367,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700105718
    },
    {
        "content": "<p>I did this long long ago, but I'm sure I've lost the branch. :-(</p>",
        "id": 402378015,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700106983
    },
    {
        "content": "<p>In the meantime, I'm using </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Meta</span> <span class=\"n\">Term</span> <span class=\"n\">Command</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"c1\">-- Given an expression of the composition `f ≫ g`, return `f` and `g`.</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.Expr.matchCategoryStructComp</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span>\n      <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">CategoryStruct.comp</span> <span class=\"o\">[</span><span class=\"n\">_v</span><span class=\"o\">,</span> <span class=\"n\">_u</span><span class=\"o\">])</span> <span class=\"n\">_obj</span><span class=\"o\">)</span> <span class=\"n\">_inst</span><span class=\"o\">)</span> <span class=\"n\">_X</span><span class=\"o\">)</span> <span class=\"n\">_Y</span><span class=\"o\">)</span> <span class=\"n\">_Z</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">failure</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"foo\"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Elab.Command.runTermElabM</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">withSynthesize</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Elab.Term.elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">e</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">e.matchCategoryStructComp</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{f}, {g}\"</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span>\n\n<span class=\"n\">foo</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span>\n</code></pre></div>\n<p>I would love to see how to Qq can be used for this. Are there any other tricks I'm missing?</p>",
        "id": 402381677,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700108639
    },
    {
        "content": "<p>Here's a trick I've been meaning to contribute eventually:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Meta</span> <span class=\"n\">Term</span> <span class=\"n\">Command</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span> <span class=\"n\">mkAppN</span><span class=\"kd\">]</span>\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">mkAppN</span> <span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span><span class=\"o\">(</span><span class=\"n\">xs.getElems.foldlM</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Expr.app</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">))</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">MacroM</span> <span class=\"n\">Term</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Given an expression of the composition `f ≫ g`, return `f` and `g`.</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.Expr.matchCategoryStructComp</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mkAppN</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">CategoryStruct.comp</span> <span class=\"o\">[</span><span class=\"n\">_v</span><span class=\"o\">,</span> <span class=\"n\">_u</span><span class=\"o\">])</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">_obj</span><span class=\"o\">,</span> <span class=\"n\">_inst</span><span class=\"o\">,</span> <span class=\"n\">_X</span><span class=\"o\">,</span> <span class=\"n\">_Y</span><span class=\"o\">,</span> <span class=\"n\">_Z</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">failure</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"foo\"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Elab.Command.runTermElabM</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">withSynthesize</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Elab.Term.elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">e</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">e.matchCategoryStructComp</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{f}, {g}\"</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span>\n\n<span class=\"n\">foo</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span>\n</code></pre></div>\n<p>This way <code>mkAppN</code> is both a function and a pattern (so long as the pattern uses an explicit array).</p>",
        "id": 402392417,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700114794
    },
    {
        "content": "<p>Without that trick, you can also do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Lean.Expr.matchCategoryStructComp</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">e.getAppFnArgs</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">``</span><span class=\"n\">CategoryStruct.comp</span><span class=\"o\">,</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">_obj</span><span class=\"o\">,</span> <span class=\"n\">_inst</span><span class=\"o\">,</span> <span class=\"n\">_X</span><span class=\"o\">,</span> <span class=\"n\">_Y</span><span class=\"o\">,</span> <span class=\"n\">_Z</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">failure</span>\n</code></pre></div>",
        "id": 402392418,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700114795
    },
    {
        "content": "<p>Thanks Kyle! That is indeed a nice trick. And I should have remembered about <code>getAppFnArgs</code> as I’ve used it in the past.</p>",
        "id": 402479193,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700144007
    },
    {
        "content": "<p>Here's the Qq version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Lean.Expr.matchCategoryStructComp</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">Level.succ</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Quiver.Hom</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CategoryStruct.toQuiver</span> <span class=\"bp\">$</span><span class=\"n\">C</span> <span class=\"bp\">$</span><span class=\"n\">instCat</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">X</span> <span class=\"bp\">$</span><span class=\"n\">Y</span><span class=\"o\">),</span>\n    <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CategoryStruct.comp</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">$</span><span class=\"n\">Y</span> <span class=\"n\">_</span> <span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"n\">g</span><span class=\"o\">)⟩</span> <span class=\"bp\">←</span> <span class=\"n\">inferTypeQ</span> <span class=\"n\">e</span> <span class=\"bp\">|</span> <span class=\"n\">failure</span>\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 402484764,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700145562
    },
    {
        "content": "<p><code>inferTypeQ</code> is pretty much always the Qq tool you need if you started with an <code>Expr</code>, though unfortunately the match syntax fights you every step of the way</p>",
        "id": 402485032,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700145623
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> . Yes, that works, but do you know of any way to do this without every typing the character <code>@</code>? Ideally I would like to just use the category theoretic notation <code>\\hom</code> and <code>\\gg</code></p>",
        "id": 402497580,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700148875
    },
    {
        "content": "<p>You'd need to somehow turn on the \"turn instance arguments into metavariables\" flag, which I don't remember the spelling of</p>",
        "id": 402498977,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700149269
    },
    {
        "content": "<p>We have that for <code>apply</code>, right?</p>",
        "id": 402499318,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700149353
    },
    {
        "content": "<p>oh maybe.</p>",
        "id": 402499735,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700149460
    },
    {
        "content": "<p>let me try something out</p>",
        "id": 402499760,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700149466
    },
    {
        "content": "<p>I think Qq does need fixing here so that what you want to write just works</p>",
        "id": 402500144,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700149571
    },
    {
        "content": "<p>I mean, I want to be able to write </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Lean.Expr.matchCategoryStructComp'</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"bp\">$</span><span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">g</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">failure</span>\n</code></pre></div>",
        "id": 402500532,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700149679
    },
    {
        "content": "<p>But maybe that's too optimistic</p>",
        "id": 402500674,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700149709
    },
    {
        "content": "<p>I think you should still be forced to write <code>inferTypeQ</code>, but you should be allowed to put underscores almost everywhere and drop all the <code>@</code>s</p>",
        "id": 402500735,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700149730
    },
    {
        "content": "<p>This works, but it's quite verbose:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Lean.Expr.matchCategoryStructComp</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span>\n  <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span>\n  <span class=\"k\">let</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVarQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">_inst</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"bp\">$</span><span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVarQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"bp\">$</span><span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVarQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVarQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVarQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"bp\">$</span><span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVarQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"bp\">$</span><span class=\"n\">Y</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"bp\">$</span><span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVarQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"bp\">$</span><span class=\"n\">Z</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">_h</span> <span class=\"bp\">←</span> <span class=\"n\">assertDefEqQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"bp\">$</span><span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">e</span>\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"foo\"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Elab.Command.runTermElabM</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">withSynthesize</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Elab.Term.elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">e</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">e.matchCategoryStructComp</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{f}, {g}\"</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span>\n\n<span class=\"n\">foo</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span>\n</code></pre></div>",
        "id": 402501729,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700150021
    },
    {
        "content": "<p>and also the infoview craps out near the <code>let _h</code> line.</p>",
        "id": 402501792,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700150041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Matching.20compositions.20with.20Qq/near/402499318\">said</a>:</p>\n<blockquote>\n<p>We have that for <code>apply</code>, right?</p>\n</blockquote>\n<p>Do you remember the spelling of this \"turn TC into subgoals\" version of apply?</p>",
        "id": 402502115,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700150150
    },
    {
        "content": "<p>No, I don't</p>",
        "id": 402502264,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700150191
    },
    {
        "content": "<p>Do you have any memory of something like it existing, or am I imagining?</p>",
        "id": 402502471,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700150266
    },
    {
        "content": "<p>It existed in Lean3 for sure as <code>apply_with ... { instances := false }</code>, but I've never used something similar in Lean4.</p>",
        "id": 402502706,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700150332
    },
    {
        "content": "<p>Aha I think it's <code>apply (config := { allowSynthFailures := true })</code>.</p>",
        "id": 402503201,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700150459
    },
    {
        "content": "<p>And it looks like this is just part of <code>apply</code> itself now: <a href=\"https://github.com/leanprover-community/mathlib4/blob/52199f53d887e390b8433f0866c1bad71d571357//Mathlib/Tactic/ApplyWith.lean#L7-L13\">https://github.com/leanprover-community/mathlib4/blob/52199f53d887e390b8433f0866c1bad71d571357//Mathlib/Tactic/ApplyWith.lean#L7-L13</a></p>",
        "id": 402503518,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700150531
    },
    {
        "content": "<p>I was hoping this would lead to some kind of <code>no_synth% foo x y</code> elaborator that would just work out of the box with Qq, but I don't see it</p>",
        "id": 402504040,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700150645
    },
    {
        "content": "<p>Oh that’s a good idea though</p>",
        "id": 402504384,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700150717
    },
    {
        "content": "<p>I certainly think that the current \"failed to synthesize instance\" behavior of Qq is a good thing, just not all the time</p>",
        "id": 402504639,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700150771
    },
    {
        "content": "<p>E.g. if I'm matching nat addition, I probably want it to be defeq to the real instance</p>",
        "id": 402504725,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700150797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Matching.20compositions.20with.20Qq/near/402501792\">said</a>:</p>\n<blockquote>\n<p>and also the infoview craps out near the <code>let _h</code> line.</p>\n</blockquote>\n<p>This error is strange.... does anyone understand why this happens? I can't find any way around it.</p>",
        "id": 402508349,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700151870
    },
    {
        "content": "<p><code>Error updating: Error fetching goals: Rpc error: InternalError: failed. Try again.</code></p>",
        "id": 402508395,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700151883
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, could we please have your macro trick PR'd? It is life changing. :-) I would love it in Std or even Lean.</p>",
        "id": 402597724,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700186860
    },
    {
        "content": "<p>I’ll second that!</p>",
        "id": 402597868,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700186916
    }
]