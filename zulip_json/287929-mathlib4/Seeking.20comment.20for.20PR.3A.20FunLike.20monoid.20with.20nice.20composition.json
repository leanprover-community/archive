[
    {
        "content": "<p>Hi, I'm new here. I am planning on making a series of PRs towards the <a href=\"https://en.wikipedia.org/wiki/Markov%E2%80%93Kakutani_fixed-point_theorem\">Markov-Kakutani fixed-point theorem</a>. The first of these PRs are the definitions of a few type classes that provide an interface between the algebraic and set-theoretic properties of composing self-maps, as well as a few basic results. I first posted about this idea <a href=\"#narrow/channel/287929-mathlib4/topic/Semigroup.20of.20compositions\">here</a>. </p>\n<p><a href=\"https://github.com/automorphis/mathlib4/commit/d237481fee257f5aba54803b654c9301d0c51990\">Here is the commit to my side branch.</a></p>\n<p>For your convenience, here is the commit message (I plan on making this the PR title/description as well):</p>\n<blockquote>\n<p>feat(Dynamics): type classes for FunLike monoids with nice composition</p>\n<p>The type synonyms <code>Function.End</code>, <code>Monoid.End</code>, <code>Module.End</code>, etc. all instance <code>Monoid</code> in the same manner, where the <code>mul</code> field is composition (of bundled endomorphisms), <code>one</code> is the identity endomorphism, and <code>mul_assoc</code> is the proof that function composition is associative. Making a <code>Monoid</code> instance for each End type synonym in this manner is not difficult. However, it is tedious to translate algebraic properties of the monoid to set-theoretic properties of the unbundled endomorphisms. The type classes <code>CompSemigroup</code> and its extensions make this translation easier.</p>\n</blockquote>\n<p>Here is the description at the top of the new file Mathlib/Dynamics/Algebra.lean:</p>\n<blockquote>\n<h1>Monoids of functions with composition.</h1>\n<p>This module is an interface between the algebraic and set-theoretic properties of composing self-maps. The basic type class of this module is <code>CompSemigroup</code>. A type <code>F</code> can instance <code>CompSemigroup</code> whenever <code>F</code> consists of bundled functions and composing elements of <code>F</code> agrees with composing the unbundled functions. For example, the type <code>F := V →ₗ[R] V</code> of <code>R</code>-linear endomorphisms of a vector space <code>V</code> can instance <code>CompSemigroup</code> because <code>LinearMap.comp</code> merely composes the unbundled linear maps.</p>\n</blockquote>\n<p>My phrasing feels sorta tortured, so please let me know if you have a better description. Also, I put the definitions in the new file Mathlib/Dynamics/Algebra.lean, please let me know if you think they should go elsewhere.</p>",
        "id": 526317915,
        "sender_full_name": "Michael Lane",
        "timestamp": 1751257821
    },
    {
        "content": "<p>I would guess that it becomes quite annoying switching back and forth between CompMonoid.comp and MonoidHom.comp, and similarly for id.</p>",
        "id": 526321939,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751261389
    },
    {
        "content": "<p>One solution to that is to make comp and id outParams, though that might bring other challenges</p>",
        "id": 526321997,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751261434
    },
    {
        "content": "<p>Another would be to characterize it as <code>(f * g) x = f (g x)</code> without reference to <code>comp : F -&gt; F -&gt; F</code> at all</p>",
        "id": 526322143,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751261529
    },
    {
        "content": "<p>If I may, I should warn you that this sort of change is hugely distracting. Here you have a nice end result which doesn't seem to need any \"composition monoid\"; where do you use them?</p>",
        "id": 526351884,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1751273856
    },
    {
        "content": "<p>(Yael is an expert in being hugely distracted)</p>",
        "id": 526352013,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751273901
    },
    {
        "content": "<blockquote>\n<p>Here you have a nice end result which doesn't seem to need any \"composition monoid\";  where do you use them?</p>\n</blockquote>\n<p>One of the inputs of the Markov-Kakutani theorem is a commuting collection of continuous affine maps. WLOG, we may assume instead that we have a commuting monoid of continuous affine maps, hence <code>CompMonoid</code>.</p>\n<p>It is very common in dynamics to assume that you have a <em>commuting</em> collection/semigroup/monoid/group/whatever of transformations. One reason for this assumption is that the fixed points of a transformation are invariant under another transformation, if the two transformations commute (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Semiconj.mapsTo_fixedPoints#doc\">docs#Function.Semiconj.mapsTo_fixedPoints</a>). This fact is used in the proof of Markov-Kakutani.</p>\n<p>So in general, say we had a different type of bundled functions (smooth, Lipschitz, linear, ....). For every such type, we would need a theorem matching the following blueprint:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">jointFixedPoints_of_commuting</span>\n<span class=\"c1\">-- inputs: some bundled functions and a proof that they commute</span>\n<span class=\"o\">:</span><span class=\"w\"> </span><span class=\"c1\">-- Prop : The intersection of all fixedPoints is invariant under every function</span>\n</code></pre></div>\n<p>The proof of every such theorem would basically be the same: Coerce to functions and apply <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.mapsTo_iInter_iInter#doc\">docs#Set.mapsTo_iInter_iInter</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Semiconj.mapsTo_fixedPoints#doc\">docs#Function.Semiconj.mapsTo_fixedPoints</a>, and CompSemigroup.function_commute_iff_commute (or rather, its proof). CompSemigroup can do all these  at once:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">jointFixedPoints</span>\n<span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⋂</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">fixedPoints</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">jointFixedPoints_of_commuting</span>\n<span class=\"o\">{</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompSemigroup</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsMulCommutative</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">MapsTo</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">jointFixedPoints</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">jointFixedPoints</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mapsTo_iInter_iInter</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Semiconj</span><span class=\"bp\">.</span><span class=\"n\">mapsTo_fixedPoints</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CompSemigroup</span><span class=\"bp\">.</span><span class=\"n\">function_commute_iff_commute</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">IsMulCommutative</span><span class=\"bp\">.</span><span class=\"n\">is_comm</span><span class=\"bp\">.</span><span class=\"n\">comm</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span>\n</code></pre></div>",
        "id": 526498230,
        "sender_full_name": "Michael Lane",
        "timestamp": 1751324515
    },
    {
        "content": "<blockquote>\n<p>I would guess that it becomes quite annoying switching back and forth between CompMonoid.comp and MonoidHom.comp, and similarly for id.</p>\n</blockquote>\n<p>I haven't encountered this difficulty yet, although I've only applied CompSemigroup to the Markov-Kakutani proof.</p>",
        "id": 526498355,
        "sender_full_name": "Michael Lane",
        "timestamp": 1751324609
    }
]