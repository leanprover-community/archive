[
    {
        "content": "<p>I think this has been around for a while but I haven't seen any progress on it and I can't find it in issues. What's the status of <code>simp?</code> giving lemmas which are entirely irrelevant? Is this something that's being actively worked on, or is it just an accepted known regression?</p>",
        "id": 403082483,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1700449053
    },
    {
        "content": "<p>Could you make an issue with some examples?</p>",
        "id": 403083301,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700449541
    },
    {
        "content": "<p>(It's surely neither actively worked on, nor an accepted known regression, if it doesn't have an issue. :-)</p>",
        "id": 403083320,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700449564
    },
    {
        "content": "<p>Sure, I just wanted to check that no-one else knew about an issue first! Searching <code>simp?</code> seemed pretty useless :P</p>",
        "id": 403083462,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1700449667
    },
    {
        "content": "<p>At this point I've just sort of gotten accustomed to manually deleting stuff from the output of <code>simp?</code>.</p>",
        "id": 403083469,
        "sender_full_name": "David Renshaw",
        "timestamp": 1700449674
    },
    {
        "content": "<p>Yeah I'm the same, but I decided today that I probably shouldn't be finding this acceptable!</p>",
        "id": 403083624,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1700449800
    },
    {
        "content": "<p>Tangential question - <del>what's the trace option to turn on to get simp to tell me which rewrites are occurring and where?</del> edit: found it, it was trace.Meta.Tactic.simp.rewrite</p>",
        "id": 403084630,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1700450481
    },
    {
        "content": "<p>Here's one example, simplified a bunch but not yet mathlib-free:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Int.Cast.Lemmas</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">square_eq</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">max</span> <span class=\"n\">x.natAbs</span> <span class=\"n\">y.natAbs</span> <span class=\"bp\">=</span> <span class=\"n\">max</span> <span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"bp\">|</span> <span class=\"bp\">|</span><span class=\"n\">y</span><span class=\"bp\">|</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span>\n</code></pre></div>",
        "id": 403085611,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1700451086
    },
    {
        "content": "<p>It seems that <code>simp</code> is applying <code>ge_iff_le</code> to an expression which is an <code>le</code> - <code>ge_iff_le</code> and <code>gt_iff_lt</code> are the ones I experience most like this (a syntactic change that's definitionally rfl) but I'll check others too</p>",
        "id": 403085812,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1700451228
    },
    {
        "content": "<p>I've frequently experienced those lemmas appearing in <code>simp?</code> too</p>",
        "id": 403091362,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700454857
    },
    {
        "content": "<p>I was just going to make an issue for this!</p>",
        "id": 403120580,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1700469627
    },
    {
        "content": "<p>I just moved <code>ge_iff_le</code> to Std, so hopefully that makes it easier to make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>!</p>",
        "id": 403120675,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700469670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.3F.20giving.20nonsense.20lemmas/near/403085812\">said</a>:</p>\n<blockquote>\n<p>It seems that <code>simp</code> is applying <code>ge_iff_le</code> to an expression which is an <code>le</code> - <code>ge_iff_le</code> and <code>gt_iff_lt</code> are the ones I experience most like this (a syntactic change that's definitionally rfl) but I'll check others too</p>\n</blockquote>\n<p>My theory is that it comes from some of the metadata that's attached to exprs in lean4 - how can we see this?</p>",
        "id": 403121051,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1700469827
    },
    {
        "content": "<p>You need to get hold of the actual <code>Expr</code> and print / process the raw representation.</p>",
        "id": 403131294,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700473584
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">Expr.mdata</span> <span class=\"bp\">.</span><span class=\"n\">empty</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Int</span><span class=\"o\">)</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">foo</span> <span class=\"c1\">-- Expr.mdata { entries := [] } (Expr.const `Int [])</span>\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">_</span> <span class=\"k\">from</span> <span class=\"k\">do</span> <span class=\"n\">ppExpr</span> <span class=\"n\">foo</span> <span class=\"c1\">-- Int</span>\n</code></pre></div>",
        "id": 403131488,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700473668
    },
    {
        "content": "<p>here's some minimisation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.SimpTrace</span>\n\n<span class=\"c1\">-- this import is important: commenting it out fixes the issue (in this specific case)</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Order.Basic</span>\n<span class=\"c1\">-- as it imports only:</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Order.Ring.Canonical</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Bits</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>still working on it!</p>",
        "id": 403131611,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1700473705
    },
    {
        "content": "<p>Here's a <code>Std</code>-only repro, as minimal as I can get it without downloading Std (which I am doing right now)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.SimpTrace</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Classes.Order</span> <span class=\"c1\">-- this import is minimal</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"c1\">-- this is important!</span>\n<span class=\"c1\">--variable {α : Type} [LE α] [Sub α] [OfNat α 0] {a b c d : α} -- doesn't have the issue!</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Sub</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">tsub_eq_zero_of_le</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_sub_succ_eq_sub</span><span class=\"o\">]</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I'm going to keep trying to minimise, I think I'm pretty close. Note the really surprising thing is that somehow this is a universe issue!</p>",
        "id": 403139349,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1700476133
    },
    {
        "content": "<p>it seems <code>simp?</code> is reporting on lemmas that it is trying and then giving up on, though</p>",
        "id": 403139718,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1700476258
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.SimpTrace</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"c1\">-- this is important! {α : Type} works as expected, as does making all these lemmas for `Nat`.</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Sub</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">tsub_eq_zero_of_le</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ge_iff_le</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_sub_succ_eq_sub</span><span class=\"o\">]</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>it just needed <code>ge_iff_le</code>, d'oh. here's a minimal one <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> :)</p>",
        "id": 403140680,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1700476564
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span>, here is is without Std:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"c1\">-- {α : Type} works as expected, as does making this lemma for `Nat`.</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">tsub_eq_zero_of_le</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Sub</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ge_iff_le</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">tactic.simp.trace</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_sub_succ_eq_sub</span><span class=\"o\">]</span> <span class=\"c1\">-- Try this: simp only [ge_iff_le, Nat.succ_sub_succ_eq_sub]</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 403154347,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700481410
    },
    {
        "content": "<p>Turning on <code>set_option trace.Meta.Tactic.simp true</code>, it looks like lemmas that it is successfully rewriting by during <em>failed</em> discharging attempts are being recorded in the output.</p>",
        "id": 403155532,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700481811
    },
    {
        "content": "<p>Hopefully that's the clue. :-)</p>",
        "id": 403155539,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700481816
    },
    {
        "content": "<p>Oh, I bet the <code>MonadBacktrack</code> instance for <code>SimpM</code> is wrong.</p>",
        "id": 403156708,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700482271
    },
    {
        "content": "<p>Yay, have a fix along these lines.</p>",
        "id": 403157637,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700482655
    },
    {
        "content": "<p>I'm not entirely certain how much state I should be backtracking when the discharger fails.</p>",
        "id": 403157753,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700482692
    },
    {
        "content": "<p>So I'm not sure whether I should make the minimal fix, that <em>just</em> backtracks <code>UsedSimps</code>, or if it's okay to backtrack the whole <code>MetaM</code> state too.</p>",
        "id": 403157829,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700482730
    },
    {
        "content": "<p>We can sort that out in review.</p>",
        "id": 403157878,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700482748
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span>, would you mind posting an issue with that last <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, and I'll clean up the fix?</p>",
        "id": 403157922,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700482769
    },
    {
        "content": "<p>In the lean4 repo, or std?</p>",
        "id": 403158377,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1700482934
    },
    {
        "content": "<p>Lean</p>",
        "id": 403158492,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700482980
    },
    {
        "content": "<p>The fix is at <a href=\"https://github.com/leanprover/lean4/pull/2923\">lean4#2923</a></p>",
        "id": 403160988,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700483863
    },
    {
        "content": "<p>It would be nice to use the opportunity to work on getting <code>simp?</code> closer to optionally output a <code>simp_rw</code>.</p>",
        "id": 403179109,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1700489818
    },
    {
        "content": "<p>I'm thinking about it... it's pretty tricky, because the lemmas returned by <code>UsedTheorems</code> are currently a big bag of lemmas used for rewriting, discharging, and congruence. Working out how to thread through a replayable history of what simp does is a tall order.</p>",
        "id": 403188785,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700492559
    },
    {
        "content": "<p>I'm still more in optimistic about the \"take the big bag, and shake it into the right order using a search heuristic\" approach...</p>",
        "id": 403188920,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700492596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.3F.20giving.20nonsense.20lemmas/near/403188785\">said</a>:</p>\n<blockquote>\n<p>I'm thinking about it... it's pretty tricky, because the lemmas returned by <code>UsedTheorems</code> are currently a big bag of lemmas used for rewriting, discharging, and congruence. Working out how to thread through a replayable history of what simp does is a tall order.</p>\n</blockquote>\n<p>There's a good chance I'm misunderstanding the complexities of what's going on here, but it seems like the obvious solution is for <code>UsedTheorems</code> to return a tree, so the lemmas used to solve side goals from a rewrite A would be all contained in a subtree of A. Then if it turns out we don't want to keep A, we can throw away the whole subtree and know safely that this doesn't affect any other rewrites</p>",
        "id": 403190176,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1700492987
    },
    {
        "content": "<p>I'm still befuddled as to where the universe comes into it all.</p>",
        "id": 403207086,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1700498517
    }
]