[
    {
        "content": "<p>Currently Finsupp is unnecessarily marked noncomputable and uses classical instead of DecidableEq in the core definitions (but with DecidableEq also sprinkled around other parts).</p>\n<p>This creates the problem that things do not reduce as they get stuck on Classical.decEq and it isn't possible to use Finsupp in programs despite the fact that it's obviously a perfectly computable notion.</p>\n<p>Is there any plan to fix it? Would contributions be welcome?</p>\n<p>I started doing it but unfortunately a lot of things depend on it so it's a significant amount of work and churn.</p>",
        "id": 476642459,
        "sender_full_name": "lyphyser",
        "timestamp": 1728858892
    },
    {
        "content": "<p>Using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFinsupp#doc\">docs#DFinsupp</a> will avoid the issue</p>",
        "id": 476643660,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728860253
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"751429\">lyphyser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Computable.2Fdecidable.20Finsupp.3F/near/476642459\">said</a>:</p>\n<blockquote>\n<p>it isn't possible to use Finsupp in programs despite the fact that it's obviously a perfectly computable notion.</p>\n</blockquote>\n<p>They are also not a very good data structure for programs, since Finsupp operations never memoize the underlying functions, leading to giant closures and surprising negative performance. DFinsupp has similar issues.</p>\n<p>If the goal is computation, I would suggest making/finding appropriate basic data structures. Then, if you need to prove anything, create the function from this structure to Finsupp and prove the supporting lemmas to carry operations over.</p>",
        "id": 476644816,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1728861641
    },
    {
        "content": "<p>thanks! I completely missed DFinsupp, just assumed it was the same but dependent</p>",
        "id": 476645062,
        "sender_full_name": "lyphyser",
        "timestamp": 1728861941
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">They</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">also</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">very</span><span class=\"w\"> </span><span class=\"n\">good</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">programs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">since</span><span class=\"w\"> </span><span class=\"n\">Finsupp</span><span class=\"w\"> </span><span class=\"n\">operations</span><span class=\"w\"> </span><span class=\"n\">never</span><span class=\"w\"> </span><span class=\"n\">memoize</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">underlying</span><span class=\"w\"> </span><span class=\"n\">functions</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">leading</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">giant</span><span class=\"w\"> </span><span class=\"n\">closures</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">surprising</span><span class=\"w\"> </span><span class=\"n\">negative</span><span class=\"w\"> </span><span class=\"n\">performance</span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">DFinsupp</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">similar</span><span class=\"w\"> </span><span class=\"n\">issues</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>Indeed, although my goal right now is only reducibility and being able to produce a computable function, but probably not running it, so DFinsupp seems perfect for now.</p>\n<p>More in general, I think this might perhaps be solvable though by redefining Finsupp/DFinsupp to be a custom function-like type plus an RBMap overriding it with specific values; this way (D)Finsupp.update would work efficiently by updating the RBMap and the function-like type could just be an empty function where all operations are trivial if it's constructed from Finsupp.single/etc.; but unlike just using RBMap this would allow to still specify arbitrary functions with huge but finite support and use them seamlessly along with the single/update RBMap ones.</p>",
        "id": 476645655,
        "sender_full_name": "lyphyser",
        "timestamp": 1728862541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Computable.2Fdecidable.20Finsupp.3F/near/476644816\">said</a>:</p>\n<blockquote>\n<p>They are also not a very good data structure for programs, since Finsupp operations never memoize the underlying functions, leading to giant closures and surprising negative performance. DFinsupp has similar issues.</p>\n</blockquote>\n<p>If all you do with DFinsupp in a program is evaluate the function and sum over the support, then it is a fine data structure. It's <em>some of the operations</em> on that structure that are inefficient, notably addition.</p>",
        "id": 476646569,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728863579
    },
    {
        "content": "<p>I think using RBMap is troublesome for mathlib as this requires the indices to be ordered</p>",
        "id": 476646639,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728863652
    },
    {
        "content": "<p>Maybe we can make this palatable with some <code>Indexing I</code> typeclass which carries <code>DecidableEq I</code> and <code>Trunc (LinearOrder I)</code> or similar</p>",
        "id": 476646691,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728863736
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"751429\">lyphyser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Computable.2Fdecidable.20Finsupp.3F/near/476645655\">said</a>:</p>\n<blockquote>\n<p>redefining Finsupp/DFinsupp</p>\n</blockquote>\n<p>I think for math purposes, Finsupp/DFinsupp are fine as they are, and I would like to see development going in the direction of making new computational versions of the types that have reasonable efficiency and creating bridges to the mathematical types.</p>\n<p>The alternative to unnecessary noncomputability is the math library seeing unnecessary decidability. It'd be better to not have to make compromises on this point and instead have separate types.</p>",
        "id": 476647034,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1728864041
    },
    {
        "content": "<p>It would be nice to have some <code>to_computable</code> tactic  (or what should it be?) that takes a definition and tries to replace noncomputable bits with computable, searching for missing <code>[Decidable..]</code> etc instances for the types in question. So that we should be able to redefine <code>Finsupp</code> without anything computable (i.e., no <code>Finset</code>s, just <code>Set.Finite toFun.support</code>), then lift specific <code>Finsupp</code>s needed for, e.g., <code>Nat.factorization</code> to something computable. Not sure how can it work and if it's actually possible.</p>",
        "id": 476664592,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728875422
    },
    {
        "content": "<p>I just found myself hitting the same issue. I've got some rather long definitions (involving <code>Nat.find</code>, <code>Encodable.encode</code>, etc.) and I would like to be able to just <code>native_decide</code>/<code>decide</code> it. But I can't, because there's Finsupp.instAdd in there.</p>\n<p>Is there a reason explicitly to <em>not</em> let Finsupp be noncomputable? Is there a real worry that someone will write code that uses it, expects performance, and suffers for it?</p>",
        "id": 477704966,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1729274470
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span>,can you use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFinsupp#doc\">docs#DFinsupp</a> ?</p>",
        "id": 477706478,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729275073
    },
    {
        "content": "<blockquote>\n<p>Is there a reason explicitly to <em>not</em> let Finsupp be noncomputable?</p>\n</blockquote>\n<p>My personal opinion is no, but very pragmatically it is extraordinarily hard to make this change across all of Mathlib at once</p>",
        "id": 477706651,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729275138
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Computable.2Fdecidable.20Finsupp.3F/near/477706478\">said</a>:</p>\n<blockquote>\n<p>can you use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFinsupp#doc\">docs#DFinsupp</a> ?</p>\n</blockquote>\n<p>I'll try that and see. :) If it works (or maybe even it it doesn't!) it would be good to add some comment to this effect in Finsupp/Defs.lean, next to where it says \"This file is a <code>noncomputable theory</code> and uses classical logic throughout.\".</p>",
        "id": 477707064,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1729275326
    },
    {
        "content": "<p>If you want to pursue this, I think a good stepping stone would be to switch <code>Basis</code> to use <code>DFinsupp</code></p>",
        "id": 477707471,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729275493
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/17881\">#17881</a> has a nice example of where computable dfinsupp is handy</p>",
        "id": 477708957,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729276153
    },
    {
        "content": "<p>I just ran into this myself with in <a href=\"https://github.com/leanprover-community/mathlib4/pull/28075\">#28075</a> (thanks for pointing this out <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span>!). Based on the conversation above, it seems that I'm not the only one who naturally thought that <code>Finsupp</code> would be a good type for computation.</p>\n<p><code>DFinsupp</code> works for me as well, but it doesn't have as much theory and utility functions built on top of it as <code>Finsupp</code> has, and it feels clunky to work with dependent types when I just don't need them. I do think that it would be worthwhile to have <code>Finsupp</code> be computable when its not that inconvenient.</p>",
        "id": 533529224,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1754687127
    },
    {
        "content": "<p>I think in the short term we should build the API for DFinsupp that's missing</p>",
        "id": 533530903,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1754688294
    },
    {
        "content": "<p>FWIW, I found it very surprising that <code>DFinsupp</code> and <code>Finsupp</code> are so different (decidability vs classical approach). The <code>D</code>-naming suggests the latter is just the non-dependent version of the former.</p>",
        "id": 534350467,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1755153449
    },
    {
        "content": "<p>Yeah... turns out the <code>d</code> also stands for \"decidable\" <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span> <span aria-label=\"oops\" class=\"emoji emoji-1f643\" role=\"img\" title=\"oops\">:oops:</span></p>",
        "id": 534364792,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1755154696
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>, there are plans to change this. But it takes time and effort to coordinate such changes. I am personally currently doing as many \"obviously good\" changes in that direction, before attacking the ones that the community has historically been wary about</p>",
        "id": 534426220,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1755157495
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Computable.2Fdecidable.20Finsupp.3F/near/534426220\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span>, there are plans to change this. But it takes time and effort to coordinate such changes. I am personally currently doing as many \"obviously good\" changes in that direction, before attacking the ones that the community has historically been wary about</p>\n</blockquote>\n<p>Thanks for the note!<br>\n(I appreciate the complexity of such changes, these things take time. :))</p>",
        "id": 534432923,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1755160072
    }
]