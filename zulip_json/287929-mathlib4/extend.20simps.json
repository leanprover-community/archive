[
    {
        "content": "<p><a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/A.20quadratic.20scaling.20problem/near/547257481\">#mathlib4 &gt; A quadratic scaling problem @ ðŸ’¬</a> </p>\n<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> and others have expressed interest to change <code>@[simps]</code> in some ways, such as adding more projections that aren't a part of the definition; let's discuss it here</p>",
        "id": 547257957,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761566170
    },
    {
        "content": "<p>My two \"wishes\" for <code>[simps]</code> and <code>[simps!]</code> are that </p>\n<ol>\n<li>The current logging is very painful to navigate. When writing or reviewing code itâ€™s crucial to use <code>@[simps!?]</code> and <code>@[simps?]</code> to check the generated lemmas, and the current system is hard to read. It would be super cool have an output ressembling that of a failing <code>grind</code> call. I have explored this a bit privately but this did not get very far. </li>\n<li>More importantly, current <code>simps/simps!</code> is very bad with inductive types: it often generates lemmas with match arms in the RHS, and the \"correct\" lemmas are often obtained by applying a constructor to one of the inputs, in these cases we have to do every lemma manually which is boring, repetitive, takes up code space (e.g <a href=\"https://github.com/yonggyuchoimath/mathlib4/blob/26ace3363ae5a80b6368ee4ea2c6538b93519867/Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean#L157-L206\">here</a>), but canâ€™t really be avoided if one wants good characterizing lemmas (Iâ€™ll let you imagine what it would be if the inductive type in this example had 4 constructors instead of 2...). Perhaps this falls under the umbrella of what <span class=\"user-mention\" data-user-id=\"359992\">@Robert Maxton</span> described as \"custom projections\"?</li>\n</ol>",
        "id": 547260169,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1761566830
    },
    {
        "content": "<p>Also: this message <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/.22Missing.20Tactics.22.20list/near/523377726\">#general &gt; \"Missing Tactics\" list @ ðŸ’¬</a> is relevant for this discussion.</p>",
        "id": 547260413,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1761566910
    },
    {
        "content": "<p>Yeah, <code>simps</code> still has a lot of rough edges, and improvements are welcome (there are also a bunch of open issues in the Mathlib4 issue tracker).</p>\n<p>Adding simp-lemmas for definitions where one of the arguments is an inductive type is indeed nice, but it might be nice to think how you want to design that precisely, since it's complicated. For example, if I have two arguments of type <code>Option Î±</code>, we can potentially generate 9 lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Markdown\"><pre><span></span><code>variable, variable (the only one we can currently generate)\nvariable, some\nvariable, none\nsome, variable\nsome, some\nsome, none\nnone, variable\nnone, some\nnone, none\n</code></pre></div>\n<p>Which ones do we generate by default? How do we specify others we want to generalize?<br>\nHow does this work if the arguments have type <code>Option â„•</code>? How does it interact with the codomain having as type a structure that generates 4 simp-lemmas?<br>\nAnother tricky thing is to compute the \"correct\" right-hand side of the simp-lemma (though you could just apply <code>simp</code> to compute it after unfolding the definition, and that might be fine).</p>\n<p>It is even more complicated if you want to add more custom projections that are not of the form \"apply to a constructor (or a definitionally equal variant) of an inductive type\" or \"apply (definitionally equal variant of) a projection of the return-type\". I believe this is what <span class=\"user-mention\" data-user-id=\"359992\">@Robert Maxton</span> was suggesting in the post linked above. In that case I'm not even sure how you'd compute the right-hand-side of the generated lemmas (unless you just unfold the new definition and call <code>simp</code>).</p>",
        "id": 547290608,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1761575195
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/extend.20simps/near/547290608\">said</a>:</p>\n<blockquote>\n<p>unless you just unfold the new definition and call <code>simp</code></p>\n</blockquote>\n<p>is there any drawbacks to this?</p>",
        "id": 547290930,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761575269
    },
    {
        "content": "<p>That might be fine. I'm not sure if that is the lemma you actually want in the use cases people care about. <br>\nThe only drawback I can imagine is that it might be somewhat slow to call <code>simp</code> once for every lemma you generate (but we already do that for <code>@[simps!]</code> IIRC).</p>",
        "id": 547291559,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1761575407
    },
    {
        "content": "<p>Yes, I agree that one of the main problem with \"apply constructor of the inductive\" is that we need to be able to surgically specify (and name!) which generated lemmas we want and which ones we donâ€™t. I guess a discussion thread like this is specifically made so that this can be discussed and we can come up with ideas before doing any actual implementations. I do not guarantee that I would have time or skills do to a full implementation anyways, but at least having a focused proposal would be good starting point.</p>",
        "id": 547291947,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1761575491
    },
    {
        "content": "<p>I think the <em>default</em> behavior with inductive should stay unchanged (so that we donâ€™t suddenly generate a huge amount of lemmas), and then perhaps we could have syntax <code>[simps! +inductive foo]</code> which says that \"for every argument of type foo in the generated lemmas, build for their consructor\"? This would at least be a start, though it wouldnâ€™t handle well the case you describe where the declaration takes many inductive of the same type as input and we only want to apply constructor to some but not all of them.</p>",
        "id": 547294110,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1761575958
    },
    {
        "content": "<p>so, only \"opt-in\" when dealing with inductives.</p>",
        "id": 547294223,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1761575987
    },
    {
        "content": "<p>Can we have custom simps projections that aren't just wrappers around the default projections</p>",
        "id": 547313664,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761580244
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/channel/287929-mathlib4/topic/extend.20simps/near/547290608\">said</a>:</p>\n<blockquote>\n<p>It is even more complicated if you want to add more custom projections that are not of the form \"apply to a constructor (or a definitionally equal variant) of an inductive type\" or \"apply (definitionally equal variant of) a projection of the return-type\". I believe this is what @Robert Maxton was suggesting in the post linked above. In that case I'm not even sure how you'd compute the right-hand-side of the generated lemmas (unless you just unfold the new definition and call <code>simp</code>).</p>\n</blockquote>\n<p>Essentially, yes. For some type <code>Foo</code> you'd write down a \"computed field\" <code>Foo.bar</code>, which is approximately just a definition for which projection notation would be valid, and then every time you make a definition of type <code>Foo</code> <code>simps</code> would attempt to create a lemma of the form <code>x.bar = _</code>. </p>\n<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span>'s idea appears to essentially be the dual concept -- writing custom 'coprojections' /possibly-non-canonical constructors such that, whenever <code>simps</code> creates a lemma that <em>accepts</em> a <code>Foo</code>, it should (instead?) create lemmas for each possible constructor, registered noncanonical constructors included. Then we could just use the existing <code>initialize_simps_projections</code> command to say e.g. \"please write lemmas that accept variables of <code>Option Î±</code> and also values of the form <code>some _</code>, but not <code>none</code>\" (purely as an example, I'm not sure we'd actually want to register <code>Option</code> this way.\"</p>",
        "id": 553290450,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1762134862
    }
]